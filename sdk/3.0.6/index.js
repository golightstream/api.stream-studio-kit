var Xn = Object.defineProperty;
var Qn = (a, u, c) => u in a ? Xn(a, u, { enumerable: !0, configurable: !0, writable: !0, value: c }) : a[u] = c;
var qt = (a, u, c) => (Qn(a, typeof u != "symbol" ? u + "" : u, c), c);
import React, { useState, useEffect, useContext, useMemo, useRef, useLayoutEffect } from "react";
import ReactDOM from "react-dom";
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$2(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
function getAugmentedNamespace(a) {
  if (a.__esModule)
    return a;
  var u = a.default;
  if (typeof u == "function") {
    var c = function l() {
      return this instanceof l ? Reflect.construct(u, arguments, this.constructor) : u.apply(this, arguments);
    };
    c.prototype = u.prototype;
  } else
    c = {};
  return Object.defineProperty(c, "__esModule", { value: !0 }), Object.keys(a).forEach(function(l) {
    var v = Object.getOwnPropertyDescriptor(a, l);
    Object.defineProperty(c, l, v.get ? v : {
      enumerable: !0,
      get: function() {
        return a[l];
      }
    });
  }), c;
}
var lib$2 = {};
function e(a) {
  this.message = a;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r$2 = typeof window < "u" && window.atob && window.atob.bind(window) || function(a) {
  var u = String(a).replace(/=+$/, "");
  if (u.length % 4 == 1)
    throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var c, l, v = 0, p = 0, _ = ""; l = u.charAt(p++); ~l && (c = v % 4 ? 64 * c + l : l, v++ % 4) ? _ += String.fromCharCode(255 & c >> (-2 * v & 6)) : 0)
    l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(l);
  return _;
};
function t(a) {
  var u = a.replace(/-/g, "+").replace(/_/g, "/");
  switch (u.length % 4) {
    case 0:
      break;
    case 2:
      u += "==";
      break;
    case 3:
      u += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(c) {
      return decodeURIComponent(r$2(c).replace(/(.)/g, function(l, v) {
        var p = v.charCodeAt(0).toString(16).toUpperCase();
        return p.length < 2 && (p = "0" + p), "%" + p;
      }));
    }(u);
  } catch {
    return r$2(u);
  }
}
function n(a) {
  this.message = a;
}
function o(a, u) {
  if (typeof a != "string")
    throw new n("Invalid token specified");
  var c = (u = u || {}).header === !0 ? 0 : 1;
  try {
    return JSON.parse(t(a.split(".")[c]));
  } catch (l) {
    throw new n("Invalid token specified: " + l.message);
  }
}
n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
const jwtDecode_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InvalidTokenError: n,
  default: o
}, Symbol.toStringTag, { value: "Module" })), require$$0$3 = /* @__PURE__ */ getAugmentedNamespace(jwtDecode_esm);
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$2(a) {
  return typeof a == "string" && REGEX.test(a);
}
var byteToHex = [];
for (var i$2 = 0; i$2 < 256; ++i$2)
  byteToHex.push((i$2 + 256).toString(16).substr(1));
function stringify(a) {
  var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, c = (byteToHex[a[u + 0]] + byteToHex[a[u + 1]] + byteToHex[a[u + 2]] + byteToHex[a[u + 3]] + "-" + byteToHex[a[u + 4]] + byteToHex[a[u + 5]] + "-" + byteToHex[a[u + 6]] + byteToHex[a[u + 7]] + "-" + byteToHex[a[u + 8]] + byteToHex[a[u + 9]] + "-" + byteToHex[a[u + 10]] + byteToHex[a[u + 11]] + byteToHex[a[u + 12]] + byteToHex[a[u + 13]] + byteToHex[a[u + 14]] + byteToHex[a[u + 15]]).toLowerCase();
  if (!validate$2(c))
    throw TypeError("Stringified UUID is invalid");
  return c;
}
var _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;
function v1(a, u, c) {
  var l = u && c || 0, v = u || new Array(16);
  a = a || {};
  var p = a.node || _nodeId, _ = a.clockseq !== void 0 ? a.clockseq : _clockseq;
  if (p == null || _ == null) {
    var I = a.random || (a.rng || rng)();
    p == null && (p = _nodeId = [I[0] | 1, I[1], I[2], I[3], I[4], I[5]]), _ == null && (_ = _clockseq = (I[6] << 8 | I[7]) & 16383);
  }
  var P = a.msecs !== void 0 ? a.msecs : Date.now(), $ = a.nsecs !== void 0 ? a.nsecs : _lastNSecs + 1, F = P - _lastMSecs + ($ - _lastNSecs) / 1e4;
  if (F < 0 && a.clockseq === void 0 && (_ = _ + 1 & 16383), (F < 0 || P > _lastMSecs) && a.nsecs === void 0 && ($ = 0), $ >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  _lastMSecs = P, _lastNSecs = $, _clockseq = _, P += 122192928e5;
  var H = ((P & 268435455) * 1e4 + $) % 4294967296;
  v[l++] = H >>> 24 & 255, v[l++] = H >>> 16 & 255, v[l++] = H >>> 8 & 255, v[l++] = H & 255;
  var j = P / 4294967296 * 1e4 & 268435455;
  v[l++] = j >>> 8 & 255, v[l++] = j & 255, v[l++] = j >>> 24 & 15 | 16, v[l++] = j >>> 16 & 255, v[l++] = _ >>> 8 | 128, v[l++] = _ & 255;
  for (var ee = 0; ee < 6; ++ee)
    v[l + ee] = p[ee];
  return u || stringify(v);
}
function parse$3(a) {
  if (!validate$2(a))
    throw TypeError("Invalid UUID");
  var u, c = new Uint8Array(16);
  return c[0] = (u = parseInt(a.slice(0, 8), 16)) >>> 24, c[1] = u >>> 16 & 255, c[2] = u >>> 8 & 255, c[3] = u & 255, c[4] = (u = parseInt(a.slice(9, 13), 16)) >>> 8, c[5] = u & 255, c[6] = (u = parseInt(a.slice(14, 18), 16)) >>> 8, c[7] = u & 255, c[8] = (u = parseInt(a.slice(19, 23), 16)) >>> 8, c[9] = u & 255, c[10] = (u = parseInt(a.slice(24, 36), 16)) / 1099511627776 & 255, c[11] = u / 4294967296 & 255, c[12] = u >>> 24 & 255, c[13] = u >>> 16 & 255, c[14] = u >>> 8 & 255, c[15] = u & 255, c;
}
function stringToBytes(a) {
  a = unescape(encodeURIComponent(a));
  for (var u = [], c = 0; c < a.length; ++c)
    u.push(a.charCodeAt(c));
  return u;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(a, u, c) {
  function l(v, p, _, I) {
    if (typeof v == "string" && (v = stringToBytes(v)), typeof p == "string" && (p = parse$3(p)), p.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var P = new Uint8Array(16 + v.length);
    if (P.set(p), P.set(v, p.length), P = c(P), P[6] = P[6] & 15 | u, P[8] = P[8] & 63 | 128, _) {
      I = I || 0;
      for (var $ = 0; $ < 16; ++$)
        _[I + $] = P[$];
      return _;
    }
    return stringify(P);
  }
  try {
    l.name = a;
  } catch {
  }
  return l.DNS = DNS, l.URL = URL$1, l;
}
function md5$3(a) {
  if (typeof a == "string") {
    var u = unescape(encodeURIComponent(a));
    a = new Uint8Array(u.length);
    for (var c = 0; c < u.length; ++c)
      a[c] = u.charCodeAt(c);
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(a), a.length * 8));
}
function md5ToHexEncodedArray(a) {
  for (var u = [], c = a.length * 32, l = "0123456789abcdef", v = 0; v < c; v += 8) {
    var p = a[v >> 5] >>> v % 32 & 255, _ = parseInt(l.charAt(p >>> 4 & 15) + l.charAt(p & 15), 16);
    u.push(_);
  }
  return u;
}
function getOutputLength(a) {
  return (a + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(a, u) {
  a[u >> 5] |= 128 << u % 32, a[getOutputLength(u) - 1] = u;
  for (var c = 1732584193, l = -271733879, v = -1732584194, p = 271733878, _ = 0; _ < a.length; _ += 16) {
    var I = c, P = l, $ = v, F = p;
    c = md5ff(c, l, v, p, a[_], 7, -680876936), p = md5ff(p, c, l, v, a[_ + 1], 12, -389564586), v = md5ff(v, p, c, l, a[_ + 2], 17, 606105819), l = md5ff(l, v, p, c, a[_ + 3], 22, -1044525330), c = md5ff(c, l, v, p, a[_ + 4], 7, -176418897), p = md5ff(p, c, l, v, a[_ + 5], 12, 1200080426), v = md5ff(v, p, c, l, a[_ + 6], 17, -1473231341), l = md5ff(l, v, p, c, a[_ + 7], 22, -45705983), c = md5ff(c, l, v, p, a[_ + 8], 7, 1770035416), p = md5ff(p, c, l, v, a[_ + 9], 12, -1958414417), v = md5ff(v, p, c, l, a[_ + 10], 17, -42063), l = md5ff(l, v, p, c, a[_ + 11], 22, -1990404162), c = md5ff(c, l, v, p, a[_ + 12], 7, 1804603682), p = md5ff(p, c, l, v, a[_ + 13], 12, -40341101), v = md5ff(v, p, c, l, a[_ + 14], 17, -1502002290), l = md5ff(l, v, p, c, a[_ + 15], 22, 1236535329), c = md5gg(c, l, v, p, a[_ + 1], 5, -165796510), p = md5gg(p, c, l, v, a[_ + 6], 9, -1069501632), v = md5gg(v, p, c, l, a[_ + 11], 14, 643717713), l = md5gg(l, v, p, c, a[_], 20, -373897302), c = md5gg(c, l, v, p, a[_ + 5], 5, -701558691), p = md5gg(p, c, l, v, a[_ + 10], 9, 38016083), v = md5gg(v, p, c, l, a[_ + 15], 14, -660478335), l = md5gg(l, v, p, c, a[_ + 4], 20, -405537848), c = md5gg(c, l, v, p, a[_ + 9], 5, 568446438), p = md5gg(p, c, l, v, a[_ + 14], 9, -1019803690), v = md5gg(v, p, c, l, a[_ + 3], 14, -187363961), l = md5gg(l, v, p, c, a[_ + 8], 20, 1163531501), c = md5gg(c, l, v, p, a[_ + 13], 5, -1444681467), p = md5gg(p, c, l, v, a[_ + 2], 9, -51403784), v = md5gg(v, p, c, l, a[_ + 7], 14, 1735328473), l = md5gg(l, v, p, c, a[_ + 12], 20, -1926607734), c = md5hh(c, l, v, p, a[_ + 5], 4, -378558), p = md5hh(p, c, l, v, a[_ + 8], 11, -2022574463), v = md5hh(v, p, c, l, a[_ + 11], 16, 1839030562), l = md5hh(l, v, p, c, a[_ + 14], 23, -35309556), c = md5hh(c, l, v, p, a[_ + 1], 4, -1530992060), p = md5hh(p, c, l, v, a[_ + 4], 11, 1272893353), v = md5hh(v, p, c, l, a[_ + 7], 16, -155497632), l = md5hh(l, v, p, c, a[_ + 10], 23, -1094730640), c = md5hh(c, l, v, p, a[_ + 13], 4, 681279174), p = md5hh(p, c, l, v, a[_], 11, -358537222), v = md5hh(v, p, c, l, a[_ + 3], 16, -722521979), l = md5hh(l, v, p, c, a[_ + 6], 23, 76029189), c = md5hh(c, l, v, p, a[_ + 9], 4, -640364487), p = md5hh(p, c, l, v, a[_ + 12], 11, -421815835), v = md5hh(v, p, c, l, a[_ + 15], 16, 530742520), l = md5hh(l, v, p, c, a[_ + 2], 23, -995338651), c = md5ii(c, l, v, p, a[_], 6, -198630844), p = md5ii(p, c, l, v, a[_ + 7], 10, 1126891415), v = md5ii(v, p, c, l, a[_ + 14], 15, -1416354905), l = md5ii(l, v, p, c, a[_ + 5], 21, -57434055), c = md5ii(c, l, v, p, a[_ + 12], 6, 1700485571), p = md5ii(p, c, l, v, a[_ + 3], 10, -1894986606), v = md5ii(v, p, c, l, a[_ + 10], 15, -1051523), l = md5ii(l, v, p, c, a[_ + 1], 21, -2054922799), c = md5ii(c, l, v, p, a[_ + 8], 6, 1873313359), p = md5ii(p, c, l, v, a[_ + 15], 10, -30611744), v = md5ii(v, p, c, l, a[_ + 6], 15, -1560198380), l = md5ii(l, v, p, c, a[_ + 13], 21, 1309151649), c = md5ii(c, l, v, p, a[_ + 4], 6, -145523070), p = md5ii(p, c, l, v, a[_ + 11], 10, -1120210379), v = md5ii(v, p, c, l, a[_ + 2], 15, 718787259), l = md5ii(l, v, p, c, a[_ + 9], 21, -343485551), c = safeAdd(c, I), l = safeAdd(l, P), v = safeAdd(v, $), p = safeAdd(p, F);
  }
  return [c, l, v, p];
}
function bytesToWords(a) {
  if (a.length === 0)
    return [];
  for (var u = a.length * 8, c = new Uint32Array(getOutputLength(u)), l = 0; l < u; l += 8)
    c[l >> 5] |= (a[l / 8] & 255) << l % 32;
  return c;
}
function safeAdd(a, u) {
  var c = (a & 65535) + (u & 65535), l = (a >> 16) + (u >> 16) + (c >> 16);
  return l << 16 | c & 65535;
}
function bitRotateLeft(a, u) {
  return a << u | a >>> 32 - u;
}
function md5cmn(a, u, c, l, v, p) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(u, a), safeAdd(l, p)), v), c);
}
function md5ff(a, u, c, l, v, p, _) {
  return md5cmn(u & c | ~u & l, a, u, v, p, _);
}
function md5gg(a, u, c, l, v, p, _) {
  return md5cmn(u & l | c & ~l, a, u, v, p, _);
}
function md5hh(a, u, c, l, v, p, _) {
  return md5cmn(u ^ c ^ l, a, u, v, p, _);
}
function md5ii(a, u, c, l, v, p, _) {
  return md5cmn(c ^ (u | ~l), a, u, v, p, _);
}
var v3 = v35("v3", 48, md5$3);
const v3$1 = v3;
function v4(a, u, c) {
  a = a || {};
  var l = a.random || (a.rng || rng)();
  if (l[6] = l[6] & 15 | 64, l[8] = l[8] & 63 | 128, u) {
    c = c || 0;
    for (var v = 0; v < 16; ++v)
      u[c + v] = l[v];
    return u;
  }
  return stringify(l);
}
function f$1(a, u, c, l) {
  switch (a) {
    case 0:
      return u & c ^ ~u & l;
    case 1:
      return u ^ c ^ l;
    case 2:
      return u & c ^ u & l ^ c & l;
    case 3:
      return u ^ c ^ l;
  }
}
function ROTL(a, u) {
  return a << u | a >>> 32 - u;
}
function sha1$1(a) {
  var u = [1518500249, 1859775393, 2400959708, 3395469782], c = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof a == "string") {
    var l = unescape(encodeURIComponent(a));
    a = [];
    for (var v = 0; v < l.length; ++v)
      a.push(l.charCodeAt(v));
  } else
    Array.isArray(a) || (a = Array.prototype.slice.call(a));
  a.push(128);
  for (var p = a.length / 4 + 2, _ = Math.ceil(p / 16), I = new Array(_), P = 0; P < _; ++P) {
    for (var $ = new Uint32Array(16), F = 0; F < 16; ++F)
      $[F] = a[P * 64 + F * 4] << 24 | a[P * 64 + F * 4 + 1] << 16 | a[P * 64 + F * 4 + 2] << 8 | a[P * 64 + F * 4 + 3];
    I[P] = $;
  }
  I[_ - 1][14] = (a.length - 1) * 8 / Math.pow(2, 32), I[_ - 1][14] = Math.floor(I[_ - 1][14]), I[_ - 1][15] = (a.length - 1) * 8 & 4294967295;
  for (var H = 0; H < _; ++H) {
    for (var j = new Uint32Array(80), ee = 0; ee < 16; ++ee)
      j[ee] = I[H][ee];
    for (var X = 16; X < 80; ++X)
      j[X] = ROTL(j[X - 3] ^ j[X - 8] ^ j[X - 14] ^ j[X - 16], 1);
    for (var ie = c[0], Q = c[1], ne = c[2], Z = c[3], de = c[4], he = 0; he < 80; ++he) {
      var pe = Math.floor(he / 20), be = ROTL(ie, 5) + f$1(pe, Q, ne, Z) + de + u[pe] + j[he] >>> 0;
      de = Z, Z = ne, ne = ROTL(Q, 30) >>> 0, Q = ie, ie = be;
    }
    c[0] = c[0] + ie >>> 0, c[1] = c[1] + Q >>> 0, c[2] = c[2] + ne >>> 0, c[3] = c[3] + Z >>> 0, c[4] = c[4] + de >>> 0;
  }
  return [c[0] >> 24 & 255, c[0] >> 16 & 255, c[0] >> 8 & 255, c[0] & 255, c[1] >> 24 & 255, c[1] >> 16 & 255, c[1] >> 8 & 255, c[1] & 255, c[2] >> 24 & 255, c[2] >> 16 & 255, c[2] >> 8 & 255, c[2] & 255, c[3] >> 24 & 255, c[3] >> 16 & 255, c[3] >> 8 & 255, c[3] & 255, c[4] >> 24 & 255, c[4] >> 16 & 255, c[4] >> 8 & 255, c[4] & 255];
}
var v5 = v35("v5", 80, sha1$1);
const v5$1 = v5, nil = "00000000-0000-0000-0000-000000000000";
function version$5(a) {
  if (!validate$2(a))
    throw TypeError("Invalid UUID");
  return parseInt(a.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil,
  parse: parse$3,
  stringify,
  v1,
  v3: v3$1,
  v4,
  v5: v5$1,
  validate: validate$2,
  version: version$5
}, Symbol.toStringTag, { value: "Module" })), require$$1$4 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
let EnhancedMap$1 = class extends Map {
  /**
   * If key has a mapping already returns the currently associated value. If
   * there is no mapping, calls the computer which must return a value V.
   * The value is then stored for given key and returned.
   * @param key Key
   * @param computer Computer which is called only if key has no mapping yet.
   * @return Existing value if the key already existed, or the newly computed value.
   */
  computeIfAbsent(u, c) {
    if (this.has(u))
      return this.get(u);
    const l = c(u);
    return this.set(u, l), l;
  }
  /**
   * If the key exists already calls given computer, if the key does not exist
   * this method does nothing.
   *
   * The computer is called with current key and current value associated. The
   * computer can return a (new) value V or undefined. When undefined is returned
   * the key is removed from this map, when a V is returned the key is updated
   * with the new value V.
   * @param key Key
   * @param computer Computer which is called only if the key has a mapping already
   * @return Undefined if the key has no mapping, otherwise the value returned from computer
   */
  computeIfPresent(u, c) {
    const l = this.get(u);
    if (l === void 0)
      return;
    const v = c(u, l);
    return v !== void 0 ? this.set(u, v) : this.delete(u), v;
  }
  /**
   * Computes a value for given key, the computer can return a value V (in which case the map
   * will set the value for given key), if it returns undefined the mapping for key K will be
   * removed.
   * @param key Key to compute
   * @param computer Computer which is called, note that the currentValue argument contains the existing
   *                 value or is undefined when no mapping exists for the key.
   * @return The newly computed value
   */
  compute(u, c) {
    const l = this.get(u), v = c(u, l);
    return v ? this.set(u, v) : this.delete(u), v;
  }
};
var InternalLogLevel$1;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error";
})(InternalLogLevel$1 || (InternalLogLevel$1 = {}));
function getInternalLogger$1(a) {
  return provider$1.getLogger(a);
}
const INTERNAL_LOGGING_SETTINGS$1 = {
  /**
   * Changes the log level for the internal logging (for all new and existing loggers)
   * @param level New log level
   */
  setInternalLogLevel: (a) => provider$1.changeLogLevel(a),
  /**
   * Changes where messages are written to for all new and existing loggers),
   * by default they are written to the console.
   * @param fnOutput Function to write messages to
   */
  setOutput: (a) => provider$1.changeOutput(a),
  /**
   * Resets the log level and output back to defaults (level to error and writing to console)
   * for all new and existing loggers.
   */
  reset: () => provider$1.reset()
};
let InternalLoggerImpl$1 = class {
  constructor(u, c, l) {
    this._name = u, this._level = c, this._fnOutput = l;
  }
  trace(u) {
    this.log(InternalLogLevel$1.Trace, u);
  }
  debug(u) {
    this.log(InternalLogLevel$1.Debug, u);
  }
  error(u, c) {
    this.log(InternalLogLevel$1.Error, u, c);
  }
  info(u) {
    this.log(InternalLogLevel$1.Info, u);
  }
  warn(u, c) {
    this.log(InternalLogLevel$1.Warn, u, c);
  }
  setLevel(u) {
    this._level = u;
  }
  setOutput(u) {
    this._fnOutput = u;
  }
  log(u, c, l) {
    this._level > u || this._fnOutput(`${InternalLogLevel$1[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${c()}${l ? `
` + l.stack : ""}`);
  }
}, InternalProviderImpl$1 = class Kt {
  constructor() {
    this._loggers = new EnhancedMap$1(), this._logLevel = InternalLogLevel$1.Error, this._fnOutput = Kt.logConsole;
  }
  getLogger(u) {
    return this._loggers.computeIfAbsent(u, (c) => new InternalLoggerImpl$1(c, this._logLevel, this._fnOutput));
  }
  changeLogLevel(u) {
    this._logLevel = u, this._loggers.forEach((c) => c.setLevel(u));
  }
  changeOutput(u) {
    this._fnOutput = u, this._loggers.forEach((c) => c.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel$1.Error), this._fnOutput = Kt.logConsole, this._loggers.forEach((u) => u.setOutput(this._fnOutput));
  }
  static logConsole(u) {
    console && console.log && console.log(u);
  }
};
const provider$1 = new InternalProviderImpl$1();
var InternalLogger$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get InternalLogLevel() {
    return InternalLogLevel$1;
  },
  getInternalLogger: getInternalLogger$1,
  INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS$1
}), LogLevel$2;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error", a[a.Fatal = 5] = "Fatal";
})(LogLevel$2 || (LogLevel$2 = {}));
(function(a) {
  function u(c) {
    switch (c.toLowerCase()) {
      case "trace":
        return a.Trace;
      case "debug":
        return a.Debug;
      case "info":
        return a.Info;
      case "warn":
        return a.Warn;
      case "error":
        return a.Error;
      case "fatal":
        return a.Fatal;
      default:
        return;
    }
  }
  a.toLogLevel = u;
})(LogLevel$2 || (LogLevel$2 = {}));
let CoreLoggerImpl$1 = class Jn {
  constructor(u) {
    this._runtime = u;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(u) {
    this._runtime = u;
  }
  trace(u, ...c) {
    this.logMessage(LogLevel$2.Trace, u, c);
  }
  debug(u, ...c) {
    this.logMessage(LogLevel$2.Debug, u, c);
  }
  info(u, ...c) {
    this.logMessage(LogLevel$2.Info, u, c);
  }
  warn(u, ...c) {
    this.logMessage(LogLevel$2.Warn, u, c);
  }
  error(u, ...c) {
    this.logMessage(LogLevel$2.Error, u, c);
  }
  fatal(u, ...c) {
    this.logMessage(LogLevel$2.Fatal, u, c);
  }
  logMessage(u, c, l) {
    if (this._runtime.level > u)
      return;
    const v = Date.now(), p = typeof c == "string" ? c : c(), _ = Jn.getErrorAndArgs(l);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({
          message: p,
          exception: _.error,
          args: _.args,
          timeInMillis: v,
          level: u,
          logNames: this._runtime.name
        }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(p, u, _, v));
        break;
    }
  }
  formatArgValue(u) {
    try {
      return this._runtime.argumentFormatter(u);
    } catch {
      return `>>ARG CONVERT FAILED: '${u !== void 0 ? u.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(u, c, l, v) {
    let p;
    const _ = l.error, I = l.args;
    _ && (p = `${_.name}: ${_.message}`, _.stack && (p += `@
${_.stack}`));
    const P = this._runtime.dateFormatter(v);
    let $ = LogLevel$2[c].toUpperCase();
    $.length < 5 && ($ += " ");
    const F = typeof this._runtime.name == "string" ? this._runtime.name : this._runtime.name.join(", "), H = typeof I < "u" && I.length > 0 ? " [" + I.map((ee) => this.formatArgValue(ee)).join(", ") + "]" : "";
    return {
      message: P + " " + $ + " [" + F + "] " + u + H,
      error: p
    };
  }
  static getErrorAndArgs(u) {
    if (u.length === 0)
      return {};
    let c, l;
    const v = u[0];
    if (v instanceof Error)
      return c = v, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l };
    if (typeof v == "function") {
      const p = v();
      return p instanceof Error ? (c = p, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l }) : u.length === 1 ? Array.isArray(p) ? { args: p.length > 0 ? p : void 0 } : { args: p } : Array.isArray(p) ? { args: [...p, ...u.slice(1)] } : { args: [p, ...u.slice(1)] };
    }
    return { args: u };
  }
};
function padStart$1(a, u, c = " ") {
  return padInternal$1(a, u, "start", c);
}
function padEnd$1(a, u, c = " ") {
  return padInternal$1(a, u, "end", c);
}
function maxLengthStringValueInArray$1(a) {
  return a.map((u) => u.length).reduce((u, c) => c > u ? c : u, 0);
}
function padInternal$1(a, u, c, l = " ") {
  if (u <= a.length)
    return a;
  if (l.length > 1)
    throw new Error(`Fill char must be one char exactly, it is: ${l.length}`);
  const v = u - a.length;
  let p = "";
  for (let _ = 0; _ < v; _++)
    p += l;
  return c === "start" ? p + a : a + p;
}
function formatArgument$1(a) {
  return a === void 0 ? "undefined" : JSON.stringify(a);
}
function formatDate$1(a) {
  const u = new Date(a), c = u.getFullYear(), l = padStart$1((u.getMonth() + 1).toString(), 2, "0"), v = padStart$1(u.getDate().toString(), 2, "0"), p = padStart$1(u.getHours().toString(), 2, "0"), _ = padStart$1(u.getMinutes().toString(), 2, "0"), I = padStart$1(u.getSeconds().toString(), 2, "0"), P = padStart$1(u.getMilliseconds().toString(), 2, "0");
  return `${c}-${l}-${v} ${p}:${_}:${I},${P}`;
}
let ConsoleLogChannel$1 = class {
  constructor() {
    this.type = "LogChannel";
  }
  write(u) {
    console && console.log && console.log(u.message + (u.error ? `
${u.error}` : ""));
  }
};
var DefaultChannels$1;
(function(a) {
  function u() {
    return new ConsoleLogChannel$1();
  }
  a.createConsoleChannel = u;
})(DefaultChannels$1 || (DefaultChannels$1 = {}));
let LogProviderImpl$1 = class Wt {
  constructor(u, c) {
    this._log = getInternalLogger$1("core.impl.LogProviderImpl"), this._name = u, this._settings = c, this._loggers = new EnhancedMap$1(), this._idToKeyMap = new EnhancedMap$1(), this._globalRuntimeSettings = { level: c.level, channel: c.channel }, this._nextLoggerId = 1, this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(u) {
    return this.getOrCreateLogger(u);
  }
  updateLoggerRuntime(u, c) {
    this._log.debug(() => `Updating logger ${u.id} runtime settings using: '${JSON.stringify(c)}'`);
    const l = this._idToKeyMap.get(u.id);
    return l === void 0 ? (this._log.warn(() => `Cannot update logger with id: ${u.id}, it was not found.`), !1) : (this._loggers.computeIfPresent(l, (v, p) => (p.runtimeSettings = Wt.mergeRuntimeSettingsIntoLogRuntime(p.runtimeSettings, c), p)), !0);
  }
  updateRuntimeSettings(u) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(u)}'`), this._globalRuntimeSettings = {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: u.level !== void 0 ? u.level : this._globalRuntimeSettings.level,
      channel: u.channel !== void 0 ? u.channel : this._globalRuntimeSettings.channel
    }, this._loggers.forEach((c) => c.runtimeSettings = Wt.mergeRuntimeSettingsIntoLogRuntime(c.runtimeSettings, u));
  }
  /**
   * Removes all state and loggers, it reverts back to as it was after initial construction.
   */
  clear() {
    this._loggers.clear(), this._idToKeyMap.clear(), this._globalRuntimeSettings = Object.assign({}, this._settings), this._nextLoggerId = 1;
  }
  getOrCreateLogger(u) {
    const c = Wt.createKey(u), l = this._loggers.computeIfAbsent(c, () => {
      const v = {
        level: this._globalRuntimeSettings.level,
        channel: this._globalRuntimeSettings.channel,
        id: this.nextLoggerId(),
        name: u,
        argumentFormatter: this._settings.argumentFormatter,
        dateFormatter: this._settings.dateFormatter
      };
      return new CoreLoggerImpl$1(v);
    });
    return this._idToKeyMap.computeIfAbsent(l.id, () => c), l;
  }
  nextLoggerId() {
    const u = this._name + "_" + this._nextLoggerId;
    return this._nextLoggerId++, u;
  }
  static mergeRuntimeSettingsIntoLogRuntime(u, c) {
    return Object.assign(Object.assign({}, u), {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: c.level !== void 0 ? c.level : u.level,
      channel: c.channel !== void 0 ? c.channel : u.channel
    });
  }
  static createKey(u) {
    return typeof u == "string" ? u : u.join(",");
  }
};
function createLogProvider$1(a, u) {
  return new LogProviderImpl$1(a, u);
}
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EnhancedMap: EnhancedMap$1,
  padStart: padStart$1,
  padEnd: padEnd$1,
  maxLengthStringValueInArray: maxLengthStringValueInArray$1
});
class ArrayLogChannel {
  constructor() {
    this._buffer = [], this.type = "LogChannel";
  }
  write(u) {
    this._buffer.push(u);
  }
  get logMessages() {
    return this._buffer;
  }
  get messages() {
    return this._buffer.map((u) => u.message);
  }
}
class ArrayRawLogChannel {
  constructor() {
    this._buffer = [], this.type = "RawLogChannel";
  }
  write(u, c) {
    this._buffer.push(u);
  }
  get messages() {
    return this._buffer.map((u) => u.message);
  }
  get errors() {
    return this._buffer.map((u) => u.exception);
  }
  get size() {
    return this._buffer.length;
  }
  get rawMessages() {
    return this._buffer;
  }
  clear() {
    this._buffer = [];
  }
}
class TestControlMessage {
  constructor() {
    this._messages = [], this.write = this.write.bind(this);
  }
  get messages() {
    return this._messages;
  }
  write(u) {
    this._messages.push(u);
  }
  clear() {
    this._messages = [];
  }
}
var TestClasses = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArrayLogChannel,
  ArrayRawLogChannel,
  TestControlMessage
});
const typescriptLogging_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $internal: InternalLogger$1,
  $test: TestClasses,
  get DefaultChannels() {
    return DefaultChannels$1;
  },
  get LogLevel() {
    return LogLevel$2;
  },
  createLogProvider: createLogProvider$1,
  formatArgument: formatArgument$1,
  formatDate: formatDate$1,
  util: index$4
}, Symbol.toStringTag, { value: "Module" })), require$$2$2 = /* @__PURE__ */ getAugmentedNamespace(typescriptLogging_esm);
var layoutapi = {}, lib$1 = {}, lib = {}, Metadata = {};
Object.defineProperty(Metadata, "__esModule", { value: !0 });
Metadata.Metadata = void 0;
Metadata.Metadata = function(u) {
  const c = /* @__PURE__ */ new Map(), l = {
    set(v, p) {
      if (v = normalizeKey(v), Array.isArray(p))
        if (p.length === 0)
          c.delete(v);
        else {
          for (const _ of p)
            validate$1(v, _);
          c.set(v, v.endsWith("-bin") ? p : [p.join(", ")]);
        }
      else
        validate$1(v, p), c.set(v, [p]);
      return l;
    },
    append(v, p) {
      v = normalizeKey(v), validate$1(v, p);
      let _ = c.get(v);
      return _ == null && (_ = [], c.set(v, _)), _.push(p), v.endsWith("-bin") || c.set(v, [_.join(", ")]), l;
    },
    delete(v) {
      v = normalizeKey(v), c.delete(v);
    },
    get(v) {
      var p;
      return v = normalizeKey(v), (p = c.get(v)) === null || p === void 0 ? void 0 : p[0];
    },
    getAll(v) {
      var p;
      return v = normalizeKey(v), (p = c.get(v)) !== null && p !== void 0 ? p : [];
    },
    has(v) {
      return v = normalizeKey(v), c.has(v);
    },
    [Symbol.iterator]() {
      return c[Symbol.iterator]();
    }
  };
  if (u != null) {
    const v = isIterable$1(u) ? u : Object.entries(u);
    for (const [p, _] of v)
      l.set(p, _);
  }
  return l;
};
function normalizeKey(a) {
  return a.toLowerCase();
}
function validate$1(a, u) {
  if (!/^[0-9a-z_.-]+$/.test(a))
    throw new Error(`Metadata key '${a}' contains illegal characters`);
  if (a.endsWith("-bin")) {
    if (!(u instanceof Uint8Array))
      throw new Error(`Metadata key '${a}' ends with '-bin', thus it must have binary value`);
  } else {
    if (typeof u != "string")
      throw new Error(`Metadata key '${a}' doesn't end with '-bin', thus it must have string value`);
    if (!/^[ -~]*$/.test(u))
      throw new Error(`Metadata value '${u}' of key '${a}' contains illegal characters`);
  }
}
function isIterable$1(a) {
  return Symbol.iterator in a;
}
var Status = {};
(function(a) {
  Object.defineProperty(a, "__esModule", { value: !0 }), a.Status = void 0, function(u) {
    u[u.OK = 0] = "OK", u[u.CANCELLED = 1] = "CANCELLED", u[u.UNKNOWN = 2] = "UNKNOWN", u[u.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", u[u.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", u[u.NOT_FOUND = 5] = "NOT_FOUND", u[u.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", u[u.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", u[u.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", u[u.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", u[u.ABORTED = 10] = "ABORTED", u[u.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", u[u.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", u[u.INTERNAL = 13] = "INTERNAL", u[u.UNAVAILABLE = 14] = "UNAVAILABLE", u[u.DATA_LOSS = 15] = "DATA_LOSS", u[u.UNAUTHENTICATED = 16] = "UNAUTHENTICATED";
  }(a.Status || (a.Status = {}));
})(Status);
var MethodDescriptor = {};
Object.defineProperty(MethodDescriptor, "__esModule", { value: !0 });
var CallOptions = {};
Object.defineProperty(CallOptions, "__esModule", { value: !0 });
var ClientMiddleware = {};
Object.defineProperty(ClientMiddleware, "__esModule", { value: !0 });
var composeClientMiddleware$1 = {};
Object.defineProperty(composeClientMiddleware$1, "__esModule", { value: !0 });
composeClientMiddleware$1.composeClientMiddleware = void 0;
function composeClientMiddleware(a, u) {
  return (c, l) => u({
    ...c,
    next: (v, p) => a({ ...c, request: v }, p)
  }, l);
}
composeClientMiddleware$1.composeClientMiddleware = composeClientMiddleware;
var ClientError$1 = {}, cjs = {}, helpers = {};
helpers.__esModule = void 0;
helpers.__esModule = !0;
var objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf == "function", objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf == "function", objectDefinePropertyIsDefined = typeof Object.defineProperty == "function", objectCreateIsDefined = typeof Object.create == "function", objectHasOwnPropertyIsDefined = typeof Object.prototype.hasOwnProperty == "function", setPrototypeOf = function(u, c) {
  objectSetPrototypeOfIsDefined ? Object.setPrototypeOf(u, c) : u.__proto__ = c;
};
helpers.setPrototypeOf = setPrototypeOf;
var getPrototypeOf$1 = function(u) {
  return objectGetPrototypeOfIsDefined ? Object.getPrototypeOf(u) : u.__proto__ || u.prototype;
};
helpers.getPrototypeOf = getPrototypeOf$1;
var ie8ObjectDefinePropertyBug = !1, defineProperty$1 = function a(u, c, l) {
  if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug)
    try {
      Object.defineProperty(u, c, l);
    } catch {
      ie8ObjectDefinePropertyBug = !0, a(u, c, l);
    }
  else
    u[c] = l.value;
};
helpers.defineProperty = defineProperty$1;
var hasOwnProperty$g = function(u, c) {
  return objectHasOwnPropertyIsDefined ? u.hasOwnProperty(u, c) : u[c] === void 0;
};
helpers.hasOwnProperty = hasOwnProperty$g;
var objectCreate$1 = function(u, c) {
  if (objectCreateIsDefined)
    return Object.create(u, c);
  var l = function() {
  };
  l.prototype = u;
  var v = new l();
  if (typeof c > "u")
    return v;
  if (typeof c == "null")
    throw new Error("PropertyDescriptors must not be null.");
  if (typeof c == "object")
    for (var p in c)
      hasOwnProperty$g(c, p) && (v[p] = c[p].value);
  return v;
};
helpers.objectCreate = objectCreate$1;
(function(a) {
  a.__esModule = void 0, a.__esModule = !0;
  var u = helpers, c = u.setPrototypeOf, l = u.getPrototypeOf, v = u.defineProperty, p = u.objectCreate, _ = new Error().toString() === "[object Error]", I = "";
  function P($) {
    var F = this.constructor, H = F.name || function() {
      var Q = F.toString().match(/^function\s*([^\s(]+)/);
      return Q === null ? I || "Error" : Q[1];
    }(), j = H === "Error", ee = j ? I : H, X = Error.apply(this, arguments);
    if (c(X, l(this)), !(X instanceof F) || !(X instanceof P)) {
      var X = this;
      Error.apply(this, arguments), v(X, "message", {
        configurable: !0,
        enumerable: !1,
        value: $,
        writable: !0
      });
    }
    if (v(X, "name", {
      configurable: !0,
      enumerable: !1,
      value: ee,
      writable: !0
    }), Error.captureStackTrace && Error.captureStackTrace(
      X,
      j ? P : F
    ), X.stack === void 0) {
      var ie = new Error($);
      ie.name = X.name, X.stack = ie.stack;
    }
    return _ && v(X, "toString", {
      configurable: !0,
      enumerable: !1,
      value: function() {
        return (this.name || "Error") + (typeof this.message > "u" ? "" : ": " + this.message);
      },
      writable: !0
    }), X;
  }
  I = P.name || "ExtendableError", P.prototype = p(Error.prototype, {
    constructor: {
      value: Error,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), a.ExtendableError = P, a.default = a.ExtendableError;
})(cjs);
Object.defineProperty(ClientError$1, "__esModule", { value: !0 });
ClientError$1.ClientError = void 0;
const ts_error_1$1 = cjs, Status_1$1 = Status;
class ClientError extends ts_error_1$1.ExtendableError {
  constructor(u, c, l) {
    super(`${u} ${Status_1$1.Status[c]}: ${l}`), this.path = u, this.code = c, this.details = l, this.name = "ClientError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ClientError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](u) {
    return this !== ClientError ? this.prototype.isPrototypeOf(u) : typeof u == "object" && u !== null && (u.constructor === ClientError || u["@@nice-grpc:ClientError"] === !0 || u.name === "ClientError" && u["@@nice-grpc"] === !0);
  }
}
ClientError$1.ClientError = ClientError;
var CallContext = {};
Object.defineProperty(CallContext, "__esModule", { value: !0 });
var ServerMiddleware = {};
Object.defineProperty(ServerMiddleware, "__esModule", { value: !0 });
var composeServerMiddleware$1 = {};
Object.defineProperty(composeServerMiddleware$1, "__esModule", { value: !0 });
composeServerMiddleware$1.composeServerMiddleware = void 0;
function composeServerMiddleware(a, u) {
  return (c, l) => a({
    ...c,
    next: (v, p) => u({ ...c, request: v }, p)
  }, l);
}
composeServerMiddleware$1.composeServerMiddleware = composeServerMiddleware;
var ServerError$1 = {};
Object.defineProperty(ServerError$1, "__esModule", { value: !0 });
ServerError$1.ServerError = void 0;
const ts_error_1 = cjs, Status_1 = Status;
class ServerError extends ts_error_1.ExtendableError {
  constructor(u, c) {
    super(`${Status_1.Status[u]}: ${c}`), this.code = u, this.details = c, this.name = "ServerError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ServerError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](u) {
    return this !== ServerError ? this.prototype.isPrototypeOf(u) : typeof u == "object" && u !== null && (u.constructor === ServerError || u["@@nice-grpc:ServerError"] === !0 || u.name === "ServerError" && u["@@nice-grpc"] === !0);
  }
}
ServerError$1.ServerError = ServerError;
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(l, v, p, _) {
    _ === void 0 && (_ = p);
    var I = Object.getOwnPropertyDescriptor(v, p);
    (!I || ("get" in I ? !v.__esModule : I.writable || I.configurable)) && (I = { enumerable: !0, get: function() {
      return v[p];
    } }), Object.defineProperty(l, _, I);
  } : function(l, v, p, _) {
    _ === void 0 && (_ = p), l[_] = v[p];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(l, v) {
    for (var p in l)
      p !== "default" && !Object.prototype.hasOwnProperty.call(v, p) && u(v, l, p);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), c(Metadata, a), c(Status, a), c(MethodDescriptor, a), c(CallOptions, a), c(ClientMiddleware, a), c(composeClientMiddleware$1, a), c(ClientError$1, a), c(CallContext, a), c(ServerMiddleware, a), c(composeServerMiddleware$1, a), c(ServerError$1, a);
})(lib);
var serviceDefinitions = {}, grpcWeb = {};
Object.defineProperty(grpcWeb, "__esModule", { value: !0 });
grpcWeb.isGrpcWebServiceDefinition = grpcWeb.fromGrpcWebServiceDefinition = void 0;
function fromGrpcWebServiceDefinition(a) {
  const u = {};
  for (const [c, l] of Object.entries(a)) {
    if (c === "serviceName")
      continue;
    const v = l;
    u[uncapitalize(c)] = {
      path: `/${a.serviceName}/${c}`,
      requestStream: v.requestStream,
      responseStream: v.responseStream,
      requestDeserialize: v.requestType.deserializeBinary,
      requestSerialize: (p) => p.serializeBinary(),
      responseDeserialize: v.responseType.deserializeBinary,
      responseSerialize: (p) => p.serializeBinary(),
      options: {}
    };
  }
  return u;
}
grpcWeb.fromGrpcWebServiceDefinition = fromGrpcWebServiceDefinition;
function isGrpcWebServiceDefinition(a) {
  return "prototype" in a;
}
grpcWeb.isGrpcWebServiceDefinition = isGrpcWebServiceDefinition;
function uncapitalize(a) {
  return a.length === 0 ? a : a[0].toLowerCase() + a.slice(1);
}
var tsProto = {};
Object.defineProperty(tsProto, "__esModule", { value: !0 });
tsProto.isTsProtoServiceDefinition = tsProto.fromTsProtoServiceDefinition = void 0;
function fromTsProtoServiceDefinition(a) {
  const u = {};
  for (const [c, l] of Object.entries(a.methods)) {
    const v = l.requestType.encode, p = l.requestType.fromPartial, _ = l.responseType.encode, I = l.responseType.fromPartial;
    u[c] = {
      path: `/${a.fullName}/${l.name}`,
      requestStream: l.requestStream,
      responseStream: l.responseStream,
      requestDeserialize: l.requestType.decode,
      requestSerialize: p != null ? (P) => v(p(P)).finish() : (P) => v(P).finish(),
      responseDeserialize: l.responseType.decode,
      responseSerialize: I != null ? (P) => _(I(P)).finish() : (P) => _(P).finish(),
      options: l.options
    };
  }
  return u;
}
tsProto.fromTsProtoServiceDefinition = fromTsProtoServiceDefinition;
function isTsProtoServiceDefinition(a) {
  return "name" in a && "fullName" in a && "methods" in a;
}
tsProto.isTsProtoServiceDefinition = isTsProtoServiceDefinition;
Object.defineProperty(serviceDefinitions, "__esModule", { value: !0 });
serviceDefinitions.toGrpcWebMethodDefinition = serviceDefinitions.normalizeServiceDefinition = void 0;
const grpc_web_1$5 = grpcWeb, ts_proto_1 = tsProto;
function normalizeServiceDefinition(a) {
  return (0, grpc_web_1$5.isGrpcWebServiceDefinition)(a) ? (0, grpc_web_1$5.fromGrpcWebServiceDefinition)(a) : (0, ts_proto_1.isTsProtoServiceDefinition)(a) ? (0, ts_proto_1.fromTsProtoServiceDefinition)(a) : a;
}
serviceDefinitions.normalizeServiceDefinition = normalizeServiceDefinition;
function toGrpcWebMethodDefinition(a) {
  const [, u, c] = a.path.split("/");
  return {
    service: {
      serviceName: u
    },
    methodName: c,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    requestType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(l) {
        return a.requestDeserialize(l);
      }
    },
    responseType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(l) {
        return a.responseDeserialize(l);
      }
    }
  };
}
serviceDefinitions.toGrpcWebMethodDefinition = toGrpcWebMethodDefinition;
var channel = {};
Object.defineProperty(channel, "__esModule", { value: !0 });
channel.createChannel = void 0;
function createChannel(a, u) {
  return { address: a, transport: u };
}
channel.createChannel = createChannel;
var ClientFactory = {}, createBidiStreamingMethod$1 = {}, grpcWebClient_umd = { exports: {} };
(function(a, u) {
  (function(c, l) {
    a.exports = l();
  })(commonjsGlobal$1, function() {
    return c = { 418: function(v, p) {
      (function(_, I) {
        for (var P in I)
          _[P] = I[P];
      })(p, function(_) {
        var I = {};
        function P($) {
          if (I[$])
            return I[$].exports;
          var F = I[$] = { i: $, l: !1, exports: {} };
          return _[$].call(F.exports, F, F.exports, P), F.l = !0, F.exports;
        }
        return P.m = _, P.c = I, P.i = function($) {
          return $;
        }, P.d = function($, F, H) {
          P.o($, F) || Object.defineProperty($, F, { configurable: !1, enumerable: !0, get: H });
        }, P.n = function($) {
          var F = $ && $.__esModule ? function() {
            return $.default;
          } : function() {
            return $;
          };
          return P.d(F, "a", F), F;
        }, P.o = function($, F) {
          return Object.prototype.hasOwnProperty.call($, F);
        }, P.p = "", P(P.s = 1);
      }([function(_, I, P) {
        Object.defineProperty(I, "__esModule", { value: !0 });
        var $ = P(3), F = function() {
          function H(j, ee) {
            j === void 0 && (j = {}), ee === void 0 && (ee = { splitValues: !1 });
            var X, ie = this;
            this.headersMap = {}, j && (typeof Headers < "u" && j instanceof Headers ? $.getHeaderKeys(j).forEach(function(Q) {
              $.getHeaderValues(j, Q).forEach(function(ne) {
                ee.splitValues ? ie.append(Q, $.splitHeaderValue(ne)) : ie.append(Q, ne);
              });
            }) : typeof (X = j) == "object" && typeof X.headersMap == "object" && typeof X.forEach == "function" ? j.forEach(function(Q, ne) {
              ie.append(Q, ne);
            }) : typeof Map < "u" && j instanceof Map ? j.forEach(function(Q, ne) {
              ie.append(ne, Q);
            }) : typeof j == "string" ? this.appendFromString(j) : typeof j == "object" && Object.getOwnPropertyNames(j).forEach(function(Q) {
              var ne = j[Q];
              Array.isArray(ne) ? ne.forEach(function(Z) {
                ie.append(Q, Z);
              }) : ie.append(Q, ne);
            }));
          }
          return H.prototype.appendFromString = function(j) {
            for (var ee = j.split(`\r
`), X = 0; X < ee.length; X++) {
              var ie = ee[X], Q = ie.indexOf(":");
              if (Q > 0) {
                var ne = ie.substring(0, Q).trim(), Z = ie.substring(Q + 1).trim();
                this.append(ne, Z);
              }
            }
          }, H.prototype.delete = function(j, ee) {
            var X = $.normalizeName(j);
            if (ee === void 0)
              delete this.headersMap[X];
            else {
              var ie = this.headersMap[X];
              if (ie) {
                var Q = ie.indexOf(ee);
                Q >= 0 && ie.splice(Q, 1), ie.length === 0 && delete this.headersMap[X];
              }
            }
          }, H.prototype.append = function(j, ee) {
            var X = this, ie = $.normalizeName(j);
            Array.isArray(this.headersMap[ie]) || (this.headersMap[ie] = []), Array.isArray(ee) ? ee.forEach(function(Q) {
              X.headersMap[ie].push($.normalizeValue(Q));
            }) : this.headersMap[ie].push($.normalizeValue(ee));
          }, H.prototype.set = function(j, ee) {
            var X = $.normalizeName(j);
            if (Array.isArray(ee)) {
              var ie = [];
              ee.forEach(function(Q) {
                ie.push($.normalizeValue(Q));
              }), this.headersMap[X] = ie;
            } else
              this.headersMap[X] = [$.normalizeValue(ee)];
          }, H.prototype.has = function(j, ee) {
            var X = this.headersMap[$.normalizeName(j)];
            if (!Array.isArray(X))
              return !1;
            if (ee !== void 0) {
              var ie = $.normalizeValue(ee);
              return X.indexOf(ie) >= 0;
            }
            return !0;
          }, H.prototype.get = function(j) {
            var ee = this.headersMap[$.normalizeName(j)];
            return ee !== void 0 ? ee.concat() : [];
          }, H.prototype.forEach = function(j) {
            var ee = this;
            Object.getOwnPropertyNames(this.headersMap).forEach(function(X) {
              j(X, ee.headersMap[X]);
            }, this);
          }, H.prototype.toHeaders = function() {
            if (typeof Headers < "u") {
              var j = new Headers();
              return this.forEach(function(ee, X) {
                X.forEach(function(ie) {
                  j.append(ee, ie);
                });
              }), j;
            }
            throw new Error("Headers class is not defined");
          }, H;
        }();
        I.BrowserHeaders = F;
      }, function(_, I, P) {
        Object.defineProperty(I, "__esModule", { value: !0 });
        var $ = P(0);
        I.BrowserHeaders = $.BrowserHeaders;
      }, function(_, I, P) {
        Object.defineProperty(I, "__esModule", { value: !0 }), I.iterateHeaders = function($, F) {
          for (var H = $[Symbol.iterator](), j = H.next(); !j.done; )
            F(j.value[0]), j = H.next();
        }, I.iterateHeadersKeys = function($, F) {
          for (var H = $.keys(), j = H.next(); !j.done; )
            F(j.value), j = H.next();
        };
      }, function(_, I, P) {
        Object.defineProperty(I, "__esModule", { value: !0 });
        var $ = P(2);
        I.normalizeName = function(F) {
          if (typeof F != "string" && (F = String(F)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(F))
            throw new TypeError("Invalid character in header field name");
          return F.toLowerCase();
        }, I.normalizeValue = function(F) {
          return typeof F != "string" && (F = String(F)), F;
        }, I.getHeaderValues = function(F, H) {
          var j = F;
          if (j instanceof Headers && j.getAll)
            return j.getAll(H);
          var ee = j.get(H);
          return ee && typeof ee == "string" ? [ee] : ee;
        }, I.getHeaderKeys = function(F) {
          var H = F, j = {}, ee = [];
          return H.keys ? $.iterateHeadersKeys(H, function(X) {
            j[X] || (j[X] = !0, ee.push(X));
          }) : H.forEach ? H.forEach(function(X, ie) {
            j[ie] || (j[ie] = !0, ee.push(ie));
          }) : $.iterateHeaders(H, function(X) {
            var ie = X[0];
            j[ie] || (j[ie] = !0, ee.push(ie));
          }), ee;
        }, I.splitHeaderValue = function(F) {
          var H = [];
          return F.split(", ").forEach(function(j) {
            j.split(",").forEach(function(ee) {
              H.push(ee);
            });
          }), H;
        };
      }]));
    }, 617: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.ChunkParser = p.ChunkType = p.encodeASCII = p.decodeASCII = void 0;
      var I, P = _(65);
      function $(Q) {
        return (ne = Q) === 9 || ne === 10 || ne === 13 || Q >= 32 && Q <= 126;
        var ne;
      }
      function F(Q) {
        for (var ne = 0; ne !== Q.length; ++ne)
          if (!$(Q[ne]))
            throw new Error("Metadata is not valid (printable) ASCII");
        return String.fromCharCode.apply(String, Array.prototype.slice.call(Q));
      }
      function H(Q) {
        return (128 & Q.getUint8(0)) == 128;
      }
      function j(Q) {
        return Q.getUint32(1, !1);
      }
      function ee(Q, ne, Z) {
        return Q.byteLength - ne >= Z;
      }
      function X(Q, ne, Z) {
        if (Q.slice)
          return Q.slice(ne, Z);
        var de = Q.length;
        Z !== void 0 && (de = Z);
        for (var he = new Uint8Array(de - ne), pe = 0, be = ne; be < de; be++)
          he[pe++] = Q[be];
        return he;
      }
      p.decodeASCII = F, p.encodeASCII = function(Q) {
        for (var ne = new Uint8Array(Q.length), Z = 0; Z !== Q.length; ++Z) {
          var de = Q.charCodeAt(Z);
          if (!$(de))
            throw new Error("Metadata contains invalid ASCII");
          ne[Z] = de;
        }
        return ne;
      }, function(Q) {
        Q[Q.MESSAGE = 1] = "MESSAGE", Q[Q.TRAILERS = 2] = "TRAILERS";
      }(I = p.ChunkType || (p.ChunkType = {}));
      var ie = function() {
        function Q() {
          this.buffer = null, this.position = 0;
        }
        return Q.prototype.parse = function(ne, Z) {
          if (ne.length === 0 && Z)
            return [];
          var de, he = [];
          if (this.buffer == null)
            this.buffer = ne, this.position = 0;
          else if (this.position === this.buffer.byteLength)
            this.buffer = ne, this.position = 0;
          else {
            var pe = this.buffer.byteLength - this.position, be = new Uint8Array(pe + ne.byteLength), ke = X(this.buffer, this.position);
            be.set(ke, 0);
            var _e = new Uint8Array(ne);
            be.set(_e, pe), this.buffer = be, this.position = 0;
          }
          for (; ; ) {
            if (!ee(this.buffer, this.position, 5))
              return he;
            var q = X(this.buffer, this.position, this.position + 5), z = new DataView(q.buffer, q.byteOffset, q.byteLength), C = j(z);
            if (!ee(this.buffer, this.position, 5 + C))
              return he;
            var b = X(this.buffer, this.position + 5, this.position + 5 + C);
            if (this.position += 5 + C, H(z))
              return he.push({ chunkType: I.TRAILERS, trailers: (de = b, new P.Metadata(F(de))) }), he;
            he.push({ chunkType: I.MESSAGE, data: b });
          }
        }, Q;
      }();
      p.ChunkParser = ie;
    }, 8: function(v, p) {
      var _;
      Object.defineProperty(p, "__esModule", { value: !0 }), p.httpStatusToCode = p.Code = void 0, function(I) {
        I[I.OK = 0] = "OK", I[I.Canceled = 1] = "Canceled", I[I.Unknown = 2] = "Unknown", I[I.InvalidArgument = 3] = "InvalidArgument", I[I.DeadlineExceeded = 4] = "DeadlineExceeded", I[I.NotFound = 5] = "NotFound", I[I.AlreadyExists = 6] = "AlreadyExists", I[I.PermissionDenied = 7] = "PermissionDenied", I[I.ResourceExhausted = 8] = "ResourceExhausted", I[I.FailedPrecondition = 9] = "FailedPrecondition", I[I.Aborted = 10] = "Aborted", I[I.OutOfRange = 11] = "OutOfRange", I[I.Unimplemented = 12] = "Unimplemented", I[I.Internal = 13] = "Internal", I[I.Unavailable = 14] = "Unavailable", I[I.DataLoss = 15] = "DataLoss", I[I.Unauthenticated = 16] = "Unauthenticated";
      }(_ = p.Code || (p.Code = {})), p.httpStatusToCode = function(I) {
        switch (I) {
          case 0:
            return _.Internal;
          case 200:
            return _.OK;
          case 400:
            return _.InvalidArgument;
          case 401:
            return _.Unauthenticated;
          case 403:
            return _.PermissionDenied;
          case 404:
            return _.NotFound;
          case 409:
            return _.Aborted;
          case 412:
            return _.FailedPrecondition;
          case 429:
            return _.ResourceExhausted;
          case 499:
            return _.Canceled;
          case 500:
            return _.Unknown;
          case 501:
            return _.Unimplemented;
          case 503:
            return _.Unavailable;
          case 504:
            return _.DeadlineExceeded;
          default:
            return _.Unknown;
        }
      };
    }, 934: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.client = void 0;
      var I = _(65), P = _(617), $ = _(8), F = _(346), H = _(57), j = _(882);
      p.client = function(ie, Q) {
        return new ee(ie, Q);
      };
      var ee = function() {
        function ie(Q, ne) {
          this.started = !1, this.sentFirstMessage = !1, this.completed = !1, this.closed = !1, this.finishedSending = !1, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new P.ChunkParser(), this.methodDefinition = Q, this.props = ne, this.createTransport();
        }
        return ie.prototype.createTransport = function() {
          var Q = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, ne = { methodDefinition: this.methodDefinition, debug: this.props.debug || !1, url: Q, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
          this.props.transport ? this.transport = this.props.transport(ne) : this.transport = H.makeDefaultTransport(ne);
        }, ie.prototype.onTransportHeaders = function(Q, ne) {
          if (this.props.debug && F.debug("onHeaders", Q, ne), this.closed)
            this.props.debug && F.debug("grpc.onHeaders received after request was closed - ignoring");
          else if (ne !== 0) {
            this.responseHeaders = Q, this.props.debug && F.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
            var Z = X(Q);
            this.props.debug && F.debug("onHeaders.gRPCStatus", Z);
            var de = Z && Z >= 0 ? Z : $.httpStatusToCode(ne);
            this.props.debug && F.debug("onHeaders.code", de);
            var he = Q.get("grpc-message") || [];
            if (this.props.debug && F.debug("onHeaders.gRPCMessage", he), this.rawOnHeaders(Q), de !== $.Code.OK) {
              var pe = this.decodeGRPCStatus(he[0]);
              this.rawOnError(de, pe, Q);
            }
          }
        }, ie.prototype.onTransportChunk = function(Q) {
          var ne = this;
          if (this.closed)
            this.props.debug && F.debug("grpc.onChunk received after request was closed - ignoring");
          else {
            var Z = [];
            try {
              Z = this.parser.parse(Q);
            } catch (de) {
              return this.props.debug && F.debug("onChunk.parsing error", de, de.message), void this.rawOnError($.Code.Internal, "parsing error: " + de.message);
            }
            Z.forEach(function(de) {
              if (de.chunkType === P.ChunkType.MESSAGE) {
                var he = ne.methodDefinition.responseType.deserializeBinary(de.data);
                ne.rawOnMessage(he);
              } else
                de.chunkType === P.ChunkType.TRAILERS && (ne.responseHeaders ? (ne.responseTrailers = new I.Metadata(de.trailers), ne.props.debug && F.debug("onChunk.trailers", ne.responseTrailers)) : (ne.responseHeaders = new I.Metadata(de.trailers), ne.rawOnHeaders(ne.responseHeaders)));
            });
          }
        }, ie.prototype.onTransportEnd = function() {
          if (this.props.debug && F.debug("grpc.onEnd"), this.closed)
            this.props.debug && F.debug("grpc.onEnd received after request was closed - ignoring");
          else if (this.responseTrailers !== void 0) {
            var Q = X(this.responseTrailers);
            if (Q !== null) {
              var ne = this.responseTrailers.get("grpc-message"), Z = this.decodeGRPCStatus(ne[0]);
              this.rawOnEnd(Q, Z, this.responseTrailers);
            } else
              this.rawOnError($.Code.Internal, "Response closed without grpc-status (Trailers provided)");
          } else {
            if (this.responseHeaders === void 0)
              return void this.rawOnError($.Code.Unknown, "Response closed without headers");
            var de = X(this.responseHeaders), he = this.responseHeaders.get("grpc-message");
            if (this.props.debug && F.debug("grpc.headers only response ", de, he), de === null)
              return void this.rawOnEnd($.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
            var pe = this.decodeGRPCStatus(he[0]);
            this.rawOnEnd(de, pe, this.responseHeaders);
          }
        }, ie.prototype.decodeGRPCStatus = function(Q) {
          if (!Q)
            return "";
          try {
            return decodeURIComponent(Q);
          } catch {
            return Q;
          }
        }, ie.prototype.rawOnEnd = function(Q, ne, Z) {
          var de = this;
          this.props.debug && F.debug("rawOnEnd", Q, ne, Z), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(he) {
            if (!de.closed)
              try {
                he(Q, ne, Z);
              } catch (pe) {
                setTimeout(function() {
                  throw pe;
                }, 0);
              }
          }));
        }, ie.prototype.rawOnHeaders = function(Q) {
          this.props.debug && F.debug("rawOnHeaders", Q), this.completed || this.onHeadersCallbacks.forEach(function(ne) {
            try {
              ne(Q);
            } catch (Z) {
              setTimeout(function() {
                throw Z;
              }, 0);
            }
          });
        }, ie.prototype.rawOnError = function(Q, ne, Z) {
          var de = this;
          Z === void 0 && (Z = new I.Metadata()), this.props.debug && F.debug("rawOnError", Q, ne), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(he) {
            if (!de.closed)
              try {
                he(Q, ne, Z);
              } catch (pe) {
                setTimeout(function() {
                  throw pe;
                }, 0);
              }
          }));
        }, ie.prototype.rawOnMessage = function(Q) {
          var ne = this;
          this.props.debug && F.debug("rawOnMessage", Q.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(Z) {
            if (!ne.closed)
              try {
                Z(Q);
              } catch (de) {
                setTimeout(function() {
                  throw de;
                }, 0);
              }
          });
        }, ie.prototype.onHeaders = function(Q) {
          this.onHeadersCallbacks.push(Q);
        }, ie.prototype.onMessage = function(Q) {
          this.onMessageCallbacks.push(Q);
        }, ie.prototype.onEnd = function(Q) {
          this.onEndCallbacks.push(Q);
        }, ie.prototype.start = function(Q) {
          if (this.started)
            throw new Error("Client already started - cannot .start()");
          this.started = !0;
          var ne = new I.Metadata(Q || {});
          ne.set("content-type", "application/grpc-web+proto"), ne.set("x-grpc-web", "1"), this.transport.start(ne);
        }, ie.prototype.send = function(Q) {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .send()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .send()");
          if (!this.methodDefinition.requestStream && this.sentFirstMessage)
            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
          this.sentFirstMessage = !0;
          var ne = j.frameRequest(Q);
          this.transport.sendMessage(ne);
        }, ie.prototype.finishSend = function() {
          if (!this.started)
            throw new Error("Client not started - .finishSend() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .finishSend()");
          this.finishedSending = !0, this.transport.finishSend();
        }, ie.prototype.close = function() {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .close()");
          this.closed = !0, this.props.debug && F.debug("request.abort aborting request"), this.transport.cancel();
        }, ie;
      }();
      function X(ie) {
        var Q = ie.get("grpc-status") || [];
        if (Q.length > 0)
          try {
            var ne = Q[0];
            return parseInt(ne, 10);
          } catch {
            return null;
          }
        return null;
      }
    }, 346: function(v, p) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.debug = void 0, p.debug = function() {
        for (var _ = [], I = 0; I < arguments.length; I++)
          _[I] = arguments[I];
        console.debug ? console.debug.apply(null, _) : console.log.apply(null, _);
      };
    }, 607: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.grpc = void 0;
      var I, P = _(418), $ = _(57), F = _(229), H = _(540), j = _(210), ee = _(859), X = _(8), ie = _(938), Q = _(35), ne = _(934);
      (I = p.grpc || (p.grpc = {})).setDefaultTransport = $.setDefaultTransportFactory, I.CrossBrowserHttpTransport = ee.CrossBrowserHttpTransport, I.FetchReadableStreamTransport = F.FetchReadableStreamTransport, I.XhrTransport = j.XhrTransport, I.WebsocketTransport = H.WebsocketTransport, I.Code = X.Code, I.Metadata = P.BrowserHeaders, I.client = function(Z, de) {
        return ne.client(Z, de);
      }, I.invoke = ie.invoke, I.unary = Q.unary;
    }, 938: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.invoke = void 0;
      var I = _(934);
      p.invoke = function(P, $) {
        if (P.requestStream)
          throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
        var F = I.client(P, { host: $.host, transport: $.transport, debug: $.debug });
        return $.onHeaders && F.onHeaders($.onHeaders), $.onMessage && F.onMessage($.onMessage), $.onEnd && F.onEnd($.onEnd), F.start($.metadata), F.send($.request), F.finishSend(), { close: function() {
          F.close();
        } };
      };
    }, 65: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.Metadata = void 0;
      var I = _(418);
      Object.defineProperty(p, "Metadata", { enumerable: !0, get: function() {
        return I.BrowserHeaders;
      } });
    }, 57: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.makeDefaultTransport = p.setDefaultTransportFactory = void 0;
      var I = _(859), P = function($) {
        return I.CrossBrowserHttpTransport({ withCredentials: !1 })($);
      };
      p.setDefaultTransportFactory = function($) {
        P = $;
      }, p.makeDefaultTransport = function($) {
        return P($);
      };
    }, 229: function(v, p, _) {
      var I = this && this.__assign || function() {
        return (I = Object.assign || function(H) {
          for (var j, ee = 1, X = arguments.length; ee < X; ee++)
            for (var ie in j = arguments[ee])
              Object.prototype.hasOwnProperty.call(j, ie) && (H[ie] = j[ie]);
          return H;
        }).apply(this, arguments);
      };
      Object.defineProperty(p, "__esModule", { value: !0 }), p.detectFetchSupport = p.FetchReadableStreamTransport = void 0;
      var P = _(65), $ = _(346);
      p.FetchReadableStreamTransport = function(H) {
        return function(j) {
          return function(ee, X) {
            return ee.debug && $.debug("fetchRequest", ee), new F(ee, X);
          }(j, H);
        };
      };
      var F = function() {
        function H(j, ee) {
          this.cancelled = !1, this.controller = self.AbortController && new AbortController(), this.options = j, this.init = ee;
        }
        return H.prototype.pump = function(j, ee) {
          var X = this;
          if (this.reader = j, this.cancelled)
            return this.options.debug && $.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(ie) {
              X.options.debug && $.debug("Fetch.pump.reader.cancel exception", ie);
            });
          this.reader.read().then(function(ie) {
            if (ie.done)
              return X.options.onEnd(), ee;
            X.options.onChunk(ie.value), X.pump(X.reader, ee);
          }).catch(function(ie) {
            X.cancelled ? X.options.debug && $.debug("Fetch.catch - request cancelled") : (X.cancelled = !0, X.options.debug && $.debug("Fetch.catch", ie.message), X.options.onEnd(ie));
          });
        }, H.prototype.send = function(j) {
          var ee = this;
          fetch(this.options.url, I(I({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: j, signal: this.controller && this.controller.signal })).then(function(X) {
            if (ee.options.debug && $.debug("Fetch.response", X), ee.options.onHeaders(new P.Metadata(X.headers), X.status), !X.body)
              return X;
            ee.pump(X.body.getReader(), X);
          }).catch(function(X) {
            ee.cancelled ? ee.options.debug && $.debug("Fetch.catch - request cancelled") : (ee.cancelled = !0, ee.options.debug && $.debug("Fetch.catch", X.message), ee.options.onEnd(X));
          });
        }, H.prototype.sendMessage = function(j) {
          this.send(j);
        }, H.prototype.finishSend = function() {
        }, H.prototype.start = function(j) {
          this.metadata = j;
        }, H.prototype.cancel = function() {
          var j = this;
          this.cancelled ? this.options.debug && $.debug("Fetch.cancel already cancelled") : (this.cancelled = !0, this.controller ? (this.options.debug && $.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && $.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && $.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(ee) {
            j.options.debug && $.debug("Fetch.cancel.reader.cancel exception", ee);
          })) : this.options.debug && $.debug("Fetch.cancel before reader"));
        }, H;
      }();
      p.detectFetchSupport = function() {
        return typeof Response < "u" && Response.prototype.hasOwnProperty("body") && typeof Headers == "function";
      };
    }, 859: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.CrossBrowserHttpTransport = void 0;
      var I = _(229), P = _(210);
      p.CrossBrowserHttpTransport = function($) {
        if (I.detectFetchSupport()) {
          var F = { credentials: $.withCredentials ? "include" : "same-origin" };
          return I.FetchReadableStreamTransport(F);
        }
        return P.XhrTransport({ withCredentials: $.withCredentials });
      };
    }, 210: function(v, p, _) {
      var I, P = this && this.__extends || (I = function(Q, ne) {
        return (I = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(Z, de) {
          Z.__proto__ = de;
        } || function(Z, de) {
          for (var he in de)
            Object.prototype.hasOwnProperty.call(de, he) && (Z[he] = de[he]);
        })(Q, ne);
      }, function(Q, ne) {
        function Z() {
          this.constructor = Q;
        }
        I(Q, ne), Q.prototype = ne === null ? Object.create(ne) : (Z.prototype = ne.prototype, new Z());
      });
      Object.defineProperty(p, "__esModule", { value: !0 }), p.stringToArrayBuffer = p.MozChunkedArrayBufferXHR = p.XHR = p.XhrTransport = void 0;
      var $ = _(65), F = _(346), H = _(849);
      p.XhrTransport = function(Q) {
        return function(ne) {
          if (H.detectMozXHRSupport())
            return new ee(ne, Q);
          if (H.detectXHROverrideMimeTypeSupport())
            return new j(ne, Q);
          throw new Error("This environment's XHR implementation cannot support binary transfer.");
        };
      };
      var j = function() {
        function Q(ne, Z) {
          this.options = ne, this.init = Z;
        }
        return Q.prototype.onProgressEvent = function() {
          this.options.debug && F.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
          var ne = this.xhr.response.substr(this.index);
          this.index = this.xhr.response.length;
          var Z = ie(ne);
          this.options.onChunk(Z);
        }, Q.prototype.onLoadEvent = function() {
          this.options.debug && F.debug("XHR.onLoadEvent"), this.options.onEnd();
        }, Q.prototype.onStateChange = function() {
          this.options.debug && F.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new $.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
        }, Q.prototype.sendMessage = function(ne) {
          this.xhr.send(ne);
        }, Q.prototype.finishSend = function() {
        }, Q.prototype.start = function(ne) {
          var Z = this;
          this.metadata = ne;
          var de = new XMLHttpRequest();
          this.xhr = de, de.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(he, pe) {
            de.setRequestHeader(he, pe.join(", "));
          }), de.withCredentials = !!this.init.withCredentials, de.addEventListener("readystatechange", this.onStateChange.bind(this)), de.addEventListener("progress", this.onProgressEvent.bind(this)), de.addEventListener("loadend", this.onLoadEvent.bind(this)), de.addEventListener("error", function(he) {
            Z.options.debug && F.debug("XHR.error", he), Z.options.onEnd(he.error);
          });
        }, Q.prototype.configureXhr = function() {
          this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }, Q.prototype.cancel = function() {
          this.options.debug && F.debug("XHR.abort"), this.xhr.abort();
        }, Q;
      }();
      p.XHR = j;
      var ee = function(Q) {
        function ne() {
          return Q !== null && Q.apply(this, arguments) || this;
        }
        return P(ne, Q), ne.prototype.configureXhr = function() {
          this.options.debug && F.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
        }, ne.prototype.onProgressEvent = function() {
          var Z = this.xhr.response;
          this.options.debug && F.debug("MozXHR.onProgressEvent: ", new Uint8Array(Z)), this.options.onChunk(new Uint8Array(Z));
        }, ne;
      }(j);
      function X(Q, ne) {
        var Z = Q.charCodeAt(ne);
        if (Z >= 55296 && Z <= 56319) {
          var de = Q.charCodeAt(ne + 1);
          de >= 56320 && de <= 57343 && (Z = 65536 + (Z - 55296 << 10) + (de - 56320));
        }
        return Z;
      }
      function ie(Q) {
        for (var ne = new Uint8Array(Q.length), Z = 0, de = 0; de < Q.length; de++) {
          var he = String.prototype.codePointAt ? Q.codePointAt(de) : X(Q, de);
          ne[Z++] = 255 & he;
        }
        return ne;
      }
      p.MozChunkedArrayBufferXHR = ee, p.stringToArrayBuffer = ie;
    }, 849: function(v, p) {
      var _;
      function I() {
        if (_ !== void 0)
          return _;
        if (XMLHttpRequest) {
          _ = new XMLHttpRequest();
          try {
            _.open("GET", "https://localhost");
          } catch {
          }
        }
        return _;
      }
      function P($) {
        var F = I();
        if (!F)
          return !1;
        try {
          return F.responseType = $, F.responseType === $;
        } catch {
        }
        return !1;
      }
      Object.defineProperty(p, "__esModule", { value: !0 }), p.detectXHROverrideMimeTypeSupport = p.detectMozXHRSupport = p.xhrSupportsResponseType = void 0, p.xhrSupportsResponseType = P, p.detectMozXHRSupport = function() {
        return typeof XMLHttpRequest < "u" && P("moz-chunked-arraybuffer");
      }, p.detectXHROverrideMimeTypeSupport = function() {
        return typeof XMLHttpRequest < "u" && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
      };
    }, 540: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.WebsocketTransport = void 0;
      var I, P = _(346), $ = _(617);
      (function(H) {
        H[H.FINISH_SEND = 1] = "FINISH_SEND";
      })(I || (I = {}));
      var F = new Uint8Array([1]);
      p.WebsocketTransport = function() {
        return function(H) {
          return function(j) {
            j.debug && P.debug("websocketRequest", j);
            var ee, X = function(ne) {
              if (ne.substr(0, 8) === "https://")
                return "wss://" + ne.substr(8);
              if (ne.substr(0, 7) === "http://")
                return "ws://" + ne.substr(7);
              throw new Error("Websocket transport constructed with non-https:// or http:// host.");
            }(j.url), ie = [];
            function Q(ne) {
              if (ne === I.FINISH_SEND)
                ee.send(F);
              else {
                var Z = ne, de = new Int8Array(Z.byteLength + 1);
                de.set(new Uint8Array([0])), de.set(Z, 1), ee.send(de);
              }
            }
            return { sendMessage: function(ne) {
              ee && ee.readyState !== ee.CONNECTING ? Q(ne) : ie.push(ne);
            }, finishSend: function() {
              ee && ee.readyState !== ee.CONNECTING ? Q(I.FINISH_SEND) : ie.push(I.FINISH_SEND);
            }, start: function(ne) {
              (ee = new WebSocket(X, ["grpc-websockets"])).binaryType = "arraybuffer", ee.onopen = function() {
                var Z;
                j.debug && P.debug("websocketRequest.onopen"), ee.send((Z = "", ne.forEach(function(de, he) {
                  Z += de + ": " + he.join(", ") + `\r
`;
                }), $.encodeASCII(Z))), ie.forEach(function(de) {
                  Q(de);
                });
              }, ee.onclose = function(Z) {
                j.debug && P.debug("websocketRequest.onclose", Z), j.onEnd();
              }, ee.onerror = function(Z) {
                j.debug && P.debug("websocketRequest.onerror", Z);
              }, ee.onmessage = function(Z) {
                j.onChunk(new Uint8Array(Z.data));
              };
            }, cancel: function() {
              j.debug && P.debug("websocket.abort"), ee.close();
            } };
          }(H);
        };
      };
    }, 35: function(v, p, _) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.unary = void 0;
      var I = _(65), P = _(934);
      p.unary = function($, F) {
        if ($.responseStream)
          throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
        if ($.requestStream)
          throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
        var H = null, j = null, ee = P.client($, { host: F.host, transport: F.transport, debug: F.debug });
        return ee.onHeaders(function(X) {
          H = X;
        }), ee.onMessage(function(X) {
          j = X;
        }), ee.onEnd(function(X, ie, Q) {
          F.onEnd({ status: X, statusMessage: ie, headers: H || new I.Metadata(), message: j, trailers: Q });
        }), ee.start(F.metadata), ee.send(F.request), ee.finishSend(), { close: function() {
          ee.close();
        } };
      };
    }, 882: function(v, p) {
      Object.defineProperty(p, "__esModule", { value: !0 }), p.frameRequest = void 0, p.frameRequest = function(_) {
        var I = _.serializeBinary(), P = new ArrayBuffer(I.byteLength + 5);
        return new DataView(P, 1, 4).setUint32(0, I.length, !1), new Uint8Array(P, 5).set(I), new Uint8Array(P);
      };
    } }, l = {}, function v(p) {
      if (l[p])
        return l[p].exports;
      var _ = l[p] = { exports: {} };
      return c[p].call(_.exports, _, _.exports, v), _.exports;
    }(607);
    var c, l;
  });
})(grpcWebClient_umd);
var grpcWebClient_umdExports = grpcWebClient_umd.exports;
class AbortError extends Error {
  constructor() {
    super("The operation has been aborted"), this.message = "The operation has been aborted", this.name = "AbortError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
  }
}
function isAbortError(a) {
  return typeof a == "object" && a !== null && a.name === "AbortError";
}
function throwIfAborted(a) {
  if (a.aborted)
    throw new AbortError();
}
function rethrowAbortError(a) {
  if (isAbortError(a))
    throw a;
}
function catchAbortError(a) {
  if (!isAbortError(a))
    throw a;
}
function execute(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    let v, p = !1;
    function _() {
      p || (p = !0, v != null && v());
    }
    const I = u((P) => {
      c(P), _();
    }, (P) => {
      l(P), _();
    });
    if (!p) {
      const P = () => {
        const $ = I();
        $ == null ? l(new AbortError()) : $.then(() => {
          l(new AbortError());
        }, (F) => {
          l(F);
        }), _();
      };
      a.addEventListener("abort", P), v = () => {
        a.removeEventListener("abort", P);
      };
    }
  });
}
function abortable(a, u) {
  if (a.aborted) {
    const c = () => {
    };
    u.then(c, c);
  }
  return execute(a, (c, l) => (u.then(c, l), () => {
  }));
}
function delay$1(a, u) {
  return execute(a, (c) => {
    const l = typeof u == "number" ? u : u.getTime() - Date.now(), v = setTimeout(c, l);
    return () => {
      clearTimeout(v);
    };
  });
}
function forever(a) {
  return execute(a, () => () => {
  });
}
function waitForEvent(a, u, c, l) {
  return execute(a, (v) => {
    let p, _ = !1;
    return p = listen(u, c, (...P) => {
      v(P.length > 1 ? P : P[0]), _ = !0, p != null && p();
    }, l), _ && p(), () => {
      _ = !0, p != null && p();
    };
  });
}
function listen(a, u, c, l) {
  if (isEventTarget(a))
    return a.addEventListener(u, c, l), () => a.removeEventListener(u, c, l);
  if (isJQueryStyleEventEmitter(a))
    return a.on(u, c), () => a.off(u, c);
  if (isNodeStyleEventEmitter(a))
    return a.addListener(u, c), () => a.removeListener(u, c);
  throw new Error("Invalid event target");
}
function isNodeStyleEventEmitter(a) {
  return isFunction$4(a.addListener) && isFunction$4(a.removeListener);
}
function isJQueryStyleEventEmitter(a) {
  return isFunction$4(a.on) && isFunction$4(a.off);
}
function isEventTarget(a) {
  return isFunction$4(a.addEventListener) && isFunction$4(a.removeEventListener);
}
const isFunction$4 = (a) => typeof a == "function";
var browser$g = { exports: {} };
const _global = typeof self < "u" ? self : typeof window < "u" ? window : (
  /* otherwise */
  void 0
);
if (!_global)
  throw new Error(
    "Unable to find global scope. Are you sure this is running in the browser?"
  );
if (!_global.AbortController)
  throw new Error(
    'Could not find "AbortController" in the global scope. You need to polyfill it first'
  );
browser$g.exports = _global.AbortController;
browser$g.exports.default = _global.AbortController;
var browserExports$2 = browser$g.exports;
const AbortController$1 = /* @__PURE__ */ getDefaultExportFromCjs$2(browserExports$2);
function all(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    const v = new AbortController$1(), p = u(v.signal);
    if (p.length === 0) {
      c([]);
      return;
    }
    const _ = () => {
      v.abort();
    };
    a.addEventListener("abort", _);
    let I;
    const P = new Array(p.length);
    let $ = 0;
    function F() {
      $ += 1, $ === p.length && (a.removeEventListener("abort", _), I != null ? l(I.reason) : c(P));
    }
    for (const [H, j] of p.entries())
      j.then((ee) => {
        P[H] = ee, F();
      }, (ee) => {
        v.abort(), (I == null || !isAbortError(ee) && isAbortError(I.reason)) && (I = { reason: ee }), F();
      });
  });
}
function race$2(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    const v = new AbortController$1(), p = u(v.signal), _ = () => {
      v.abort();
    };
    a.addEventListener("abort", _);
    let I = 0;
    function P(F) {
      v.abort(), I += 1, I === p.length && (a.removeEventListener("abort", _), F.status === "fulfilled" ? c(F.value) : l(F.reason));
    }
    let $;
    for (const F of p)
      F.then((H) => {
        $ == null && ($ = { status: "fulfilled", value: H }), P($);
      }, (H) => {
        ($ == null || !isAbortError(H) && ($.status === "fulfilled" || isAbortError($.reason))) && ($ = { status: "rejected", reason: H }), P($);
      });
  });
}
async function retry$1(a, u, c = {}) {
  const { baseMs: l = 1e3, maxDelayMs: v = 15e3, onError: p, maxAttempts: _ = 1 / 0 } = c;
  let I = 0;
  const P = () => {
    I = -1;
  };
  for (; ; )
    try {
      return await u(a, I, P);
    } catch ($) {
      if (rethrowAbortError($), I >= _)
        throw $;
      let F;
      if (I === -1)
        F = 0;
      else {
        const H = Math.min(v, Math.pow(2, I) * l);
        F = Math.round(H * (1 + Math.random()) / 2);
      }
      p && p($, I, F), F !== 0 && await delay$1(a, F), I += 1;
    }
}
function spawn(a, u) {
  if (a.aborted)
    return Promise.reject(new AbortError());
  const c = [], l = new AbortController$1(), v = l.signal, p = () => {
    l.abort();
  };
  a.addEventListener("abort", p);
  const _ = () => {
    a.removeEventListener("abort", p);
  }, I = /* @__PURE__ */ new Set(), P = () => {
    for (const H of I)
      H.abort();
  };
  v.addEventListener("abort", P);
  const $ = () => {
    v.removeEventListener("abort", P);
  };
  let F = new Promise((H, j) => {
    let ee, X;
    ie((Q) => u(Q, {
      defer(ne) {
        c.push(ne);
      },
      fork: ie
    })).join().then((Q) => {
      l.abort(), ee = { value: Q };
    }, (Q) => {
      l.abort(), (!isAbortError(Q) || X == null) && (X = { error: Q });
    });
    function ie(Q) {
      if (v.aborted)
        return {
          abort() {
          },
          async join() {
            throw new AbortError();
          }
        };
      const ne = new AbortController$1(), Z = ne.signal, de = Q(Z), he = {
        abort() {
          ne.abort();
        },
        join: () => de
      };
      return I.add(he), de.catch(catchAbortError).catch((pe) => {
        X = { error: pe }, l.abort();
      }).finally(() => {
        I.delete(he), I.size === 0 && (X != null ? j(X.error) : H(ee.value));
      }), he;
    }
  });
  return F = F.finally(() => {
    _(), $();
    let H = Promise.resolve();
    for (let j = c.length - 1; j >= 0; j--)
      H = H.finally(c[j]);
    return H;
  }), F;
}
function run(a) {
  const u = new AbortController$1(), c = a(u.signal).catch(catchAbortError);
  return () => (u.abort(), c);
}
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortError,
  abortable,
  all,
  catchAbortError,
  delay: delay$1,
  execute,
  forever,
  isAbortError,
  race: race$2,
  rethrowAbortError,
  retry: retry$1,
  run,
  spawn,
  throwIfAborted,
  waitForEvent
}, Symbol.toStringTag, { value: "Module" })), require$$1$3 = /* @__PURE__ */ getAugmentedNamespace(es);
var AsyncSink$1 = {};
Object.defineProperty(AsyncSink$1, "__esModule", { value: !0 });
AsyncSink$1.AsyncSink = void 0;
const ARRAY_VALUE = "value", ARRAY_ERROR = "error";
class AsyncSink {
  constructor() {
    this._ended = !1, this._values = [], this._resolvers = [];
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  write(u) {
    this._push({ type: ARRAY_VALUE, value: u });
  }
  error(u) {
    this._push({ type: ARRAY_ERROR, error: u });
  }
  _push(u) {
    if (this._ended)
      throw new Error("AsyncSink already ended");
    if (this._resolvers.length > 0) {
      const { resolve: c, reject: l } = this._resolvers.shift();
      u.type === ARRAY_ERROR ? l(u.error) : c({ done: !1, value: u.value });
    } else
      this._values.push(u);
  }
  next() {
    if (this._values.length > 0) {
      const { type: u, value: c, error: l } = this._values.shift();
      return u === ARRAY_ERROR ? Promise.reject(l) : Promise.resolve({ done: !1, value: c });
    }
    return this._ended ? Promise.resolve({ done: !0 }) : new Promise((u, c) => {
      this._resolvers.push({ resolve: u, reject: c });
    });
  }
  end() {
    for (; this._resolvers.length > 0; )
      this._resolvers.shift().resolve({ done: !0 });
    this._ended = !0;
  }
}
AsyncSink$1.AsyncSink = AsyncSink;
var isAsyncIterable$1 = {};
Object.defineProperty(isAsyncIterable$1, "__esModule", { value: !0 });
isAsyncIterable$1.isAsyncIterable = void 0;
function isAsyncIterable(a) {
  return a != null && Symbol.asyncIterator in a;
}
isAsyncIterable$1.isAsyncIterable = isAsyncIterable;
var convertMetadata = {}, buffer$3 = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(a) {
  var u = a.length;
  if (u % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var c = a.indexOf("=");
  c === -1 && (c = u);
  var l = c === u ? 0 : 4 - c % 4;
  return [c, l];
}
function byteLength(a) {
  var u = getLens(a), c = u[0], l = u[1];
  return (c + l) * 3 / 4 - l;
}
function _byteLength(a, u, c) {
  return (u + c) * 3 / 4 - c;
}
function toByteArray(a) {
  var u, c = getLens(a), l = c[0], v = c[1], p = new Arr(_byteLength(a, l, v)), _ = 0, I = v > 0 ? l - 4 : l, P;
  for (P = 0; P < I; P += 4)
    u = revLookup[a.charCodeAt(P)] << 18 | revLookup[a.charCodeAt(P + 1)] << 12 | revLookup[a.charCodeAt(P + 2)] << 6 | revLookup[a.charCodeAt(P + 3)], p[_++] = u >> 16 & 255, p[_++] = u >> 8 & 255, p[_++] = u & 255;
  return v === 2 && (u = revLookup[a.charCodeAt(P)] << 2 | revLookup[a.charCodeAt(P + 1)] >> 4, p[_++] = u & 255), v === 1 && (u = revLookup[a.charCodeAt(P)] << 10 | revLookup[a.charCodeAt(P + 1)] << 4 | revLookup[a.charCodeAt(P + 2)] >> 2, p[_++] = u >> 8 & 255, p[_++] = u & 255), p;
}
function tripletToBase64(a) {
  return lookup[a >> 18 & 63] + lookup[a >> 12 & 63] + lookup[a >> 6 & 63] + lookup[a & 63];
}
function encodeChunk(a, u, c) {
  for (var l, v = [], p = u; p < c; p += 3)
    l = (a[p] << 16 & 16711680) + (a[p + 1] << 8 & 65280) + (a[p + 2] & 255), v.push(tripletToBase64(l));
  return v.join("");
}
function fromByteArray(a) {
  for (var u, c = a.length, l = c % 3, v = [], p = 16383, _ = 0, I = c - l; _ < I; _ += p)
    v.push(encodeChunk(a, _, _ + p > I ? I : _ + p));
  return l === 1 ? (u = a[c - 1], v.push(
    lookup[u >> 2] + lookup[u << 4 & 63] + "=="
  )) : l === 2 && (u = (a[c - 2] << 8) + a[c - 1], v.push(
    lookup[u >> 10] + lookup[u >> 4 & 63] + lookup[u << 2 & 63] + "="
  )), v.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(a, u, c, l, v) {
  var p, _, I = v * 8 - l - 1, P = (1 << I) - 1, $ = P >> 1, F = -7, H = c ? v - 1 : 0, j = c ? -1 : 1, ee = a[u + H];
  for (H += j, p = ee & (1 << -F) - 1, ee >>= -F, F += I; F > 0; p = p * 256 + a[u + H], H += j, F -= 8)
    ;
  for (_ = p & (1 << -F) - 1, p >>= -F, F += l; F > 0; _ = _ * 256 + a[u + H], H += j, F -= 8)
    ;
  if (p === 0)
    p = 1 - $;
  else {
    if (p === P)
      return _ ? NaN : (ee ? -1 : 1) * (1 / 0);
    _ = _ + Math.pow(2, l), p = p - $;
  }
  return (ee ? -1 : 1) * _ * Math.pow(2, p - l);
};
ieee754.write = function(a, u, c, l, v, p) {
  var _, I, P, $ = p * 8 - v - 1, F = (1 << $) - 1, H = F >> 1, j = v === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ee = l ? 0 : p - 1, X = l ? 1 : -1, ie = u < 0 || u === 0 && 1 / u < 0 ? 1 : 0;
  for (u = Math.abs(u), isNaN(u) || u === 1 / 0 ? (I = isNaN(u) ? 1 : 0, _ = F) : (_ = Math.floor(Math.log(u) / Math.LN2), u * (P = Math.pow(2, -_)) < 1 && (_--, P *= 2), _ + H >= 1 ? u += j / P : u += j * Math.pow(2, 1 - H), u * P >= 2 && (_++, P /= 2), _ + H >= F ? (I = 0, _ = F) : _ + H >= 1 ? (I = (u * P - 1) * Math.pow(2, v), _ = _ + H) : (I = u * Math.pow(2, H - 1) * Math.pow(2, v), _ = 0)); v >= 8; a[c + ee] = I & 255, ee += X, I /= 256, v -= 8)
    ;
  for (_ = _ << v | I, $ += v; $ > 0; a[c + ee] = _ & 255, ee += X, _ /= 256, $ -= 8)
    ;
  a[c + ee - X] |= ie * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(a) {
  const u = base64Js, c = ieee754, l = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  a.Buffer = F, a.SlowBuffer = pe, a.INSPECT_MAX_BYTES = 50;
  const v = 2147483647;
  a.kMaxLength = v;
  const { Uint8Array: p, ArrayBuffer: _, SharedArrayBuffer: I } = globalThis;
  F.TYPED_ARRAY_SUPPORT = P(), !F.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function P() {
    try {
      const ue = new p(1), ce = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(ce, p.prototype), Object.setPrototypeOf(ue, ce), ue.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(F.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (F.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(F.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (F.isBuffer(this))
        return this.byteOffset;
    }
  });
  function $(ue) {
    if (ue > v)
      throw new RangeError('The value "' + ue + '" is invalid for option "size"');
    const ce = new p(ue);
    return Object.setPrototypeOf(ce, F.prototype), ce;
  }
  function F(ue, ce, ve) {
    if (typeof ue == "number") {
      if (typeof ce == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return X(ue);
    }
    return H(ue, ce, ve);
  }
  F.poolSize = 8192;
  function H(ue, ce, ve) {
    if (typeof ue == "string")
      return ie(ue, ce);
    if (_.isView(ue))
      return ne(ue);
    if (ue == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ue
      );
    if (Te(ue, _) || ue && Te(ue.buffer, _) || typeof I < "u" && (Te(ue, I) || ue && Te(ue.buffer, I)))
      return Z(ue, ce, ve);
    if (typeof ue == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Ce = ue.valueOf && ue.valueOf();
    if (Ce != null && Ce !== ue)
      return F.from(Ce, ce, ve);
    const Be = de(ue);
    if (Be)
      return Be;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof ue[Symbol.toPrimitive] == "function")
      return F.from(ue[Symbol.toPrimitive]("string"), ce, ve);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof ue
    );
  }
  F.from = function(ue, ce, ve) {
    return H(ue, ce, ve);
  }, Object.setPrototypeOf(F.prototype, p.prototype), Object.setPrototypeOf(F, p);
  function j(ue) {
    if (typeof ue != "number")
      throw new TypeError('"size" argument must be of type number');
    if (ue < 0)
      throw new RangeError('The value "' + ue + '" is invalid for option "size"');
  }
  function ee(ue, ce, ve) {
    return j(ue), ue <= 0 ? $(ue) : ce !== void 0 ? typeof ve == "string" ? $(ue).fill(ce, ve) : $(ue).fill(ce) : $(ue);
  }
  F.alloc = function(ue, ce, ve) {
    return ee(ue, ce, ve);
  };
  function X(ue) {
    return j(ue), $(ue < 0 ? 0 : he(ue) | 0);
  }
  F.allocUnsafe = function(ue) {
    return X(ue);
  }, F.allocUnsafeSlow = function(ue) {
    return X(ue);
  };
  function ie(ue, ce) {
    if ((typeof ce != "string" || ce === "") && (ce = "utf8"), !F.isEncoding(ce))
      throw new TypeError("Unknown encoding: " + ce);
    const ve = be(ue, ce) | 0;
    let Ce = $(ve);
    const Be = Ce.write(ue, ce);
    return Be !== ve && (Ce = Ce.slice(0, Be)), Ce;
  }
  function Q(ue) {
    const ce = ue.length < 0 ? 0 : he(ue.length) | 0, ve = $(ce);
    for (let Ce = 0; Ce < ce; Ce += 1)
      ve[Ce] = ue[Ce] & 255;
    return ve;
  }
  function ne(ue) {
    if (Te(ue, p)) {
      const ce = new p(ue);
      return Z(ce.buffer, ce.byteOffset, ce.byteLength);
    }
    return Q(ue);
  }
  function Z(ue, ce, ve) {
    if (ce < 0 || ue.byteLength < ce)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (ue.byteLength < ce + (ve || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Ce;
    return ce === void 0 && ve === void 0 ? Ce = new p(ue) : ve === void 0 ? Ce = new p(ue, ce) : Ce = new p(ue, ce, ve), Object.setPrototypeOf(Ce, F.prototype), Ce;
  }
  function de(ue) {
    if (F.isBuffer(ue)) {
      const ce = he(ue.length) | 0, ve = $(ce);
      return ve.length === 0 || ue.copy(ve, 0, 0, ce), ve;
    }
    if (ue.length !== void 0)
      return typeof ue.length != "number" || We(ue.length) ? $(0) : Q(ue);
    if (ue.type === "Buffer" && Array.isArray(ue.data))
      return Q(ue.data);
  }
  function he(ue) {
    if (ue >= v)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + v.toString(16) + " bytes");
    return ue | 0;
  }
  function pe(ue) {
    return +ue != ue && (ue = 0), F.alloc(+ue);
  }
  F.isBuffer = function(ce) {
    return ce != null && ce._isBuffer === !0 && ce !== F.prototype;
  }, F.compare = function(ce, ve) {
    if (Te(ce, p) && (ce = F.from(ce, ce.offset, ce.byteLength)), Te(ve, p) && (ve = F.from(ve, ve.offset, ve.byteLength)), !F.isBuffer(ce) || !F.isBuffer(ve))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (ce === ve)
      return 0;
    let Ce = ce.length, Be = ve.length;
    for (let He = 0, Ve = Math.min(Ce, Be); He < Ve; ++He)
      if (ce[He] !== ve[He]) {
        Ce = ce[He], Be = ve[He];
        break;
      }
    return Ce < Be ? -1 : Be < Ce ? 1 : 0;
  }, F.isEncoding = function(ce) {
    switch (String(ce).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, F.concat = function(ce, ve) {
    if (!Array.isArray(ce))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (ce.length === 0)
      return F.alloc(0);
    let Ce;
    if (ve === void 0)
      for (ve = 0, Ce = 0; Ce < ce.length; ++Ce)
        ve += ce[Ce].length;
    const Be = F.allocUnsafe(ve);
    let He = 0;
    for (Ce = 0; Ce < ce.length; ++Ce) {
      let Ve = ce[Ce];
      if (Te(Ve, p))
        He + Ve.length > Be.length ? (F.isBuffer(Ve) || (Ve = F.from(Ve)), Ve.copy(Be, He)) : p.prototype.set.call(
          Be,
          Ve,
          He
        );
      else if (F.isBuffer(Ve))
        Ve.copy(Be, He);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      He += Ve.length;
    }
    return Be;
  };
  function be(ue, ce) {
    if (F.isBuffer(ue))
      return ue.length;
    if (_.isView(ue) || Te(ue, _))
      return ue.byteLength;
    if (typeof ue != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof ue
      );
    const ve = ue.length, Ce = arguments.length > 2 && arguments[2] === !0;
    if (!Ce && ve === 0)
      return 0;
    let Be = !1;
    for (; ; )
      switch (ce) {
        case "ascii":
        case "latin1":
        case "binary":
          return ve;
        case "utf8":
        case "utf-8":
          return yt(ue).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ve * 2;
        case "hex":
          return ve >>> 1;
        case "base64":
          return V(ue).length;
        default:
          if (Be)
            return Ce ? -1 : yt(ue).length;
          ce = ("" + ce).toLowerCase(), Be = !0;
      }
  }
  F.byteLength = be;
  function ke(ue, ce, ve) {
    let Ce = !1;
    if ((ce === void 0 || ce < 0) && (ce = 0), ce > this.length || ((ve === void 0 || ve > this.length) && (ve = this.length), ve <= 0) || (ve >>>= 0, ce >>>= 0, ve <= ce))
      return "";
    for (ue || (ue = "utf8"); ; )
      switch (ue) {
        case "hex":
          return te(this, ce, ve);
        case "utf8":
        case "utf-8":
          return x(this, ce, ve);
        case "ascii":
          return T(this, ce, ve);
        case "latin1":
        case "binary":
          return D(this, ce, ve);
        case "base64":
          return A(this, ce, ve);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return me(this, ce, ve);
        default:
          if (Ce)
            throw new TypeError("Unknown encoding: " + ue);
          ue = (ue + "").toLowerCase(), Ce = !0;
      }
  }
  F.prototype._isBuffer = !0;
  function _e(ue, ce, ve) {
    const Ce = ue[ce];
    ue[ce] = ue[ve], ue[ve] = Ce;
  }
  F.prototype.swap16 = function() {
    const ce = this.length;
    if (ce % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let ve = 0; ve < ce; ve += 2)
      _e(this, ve, ve + 1);
    return this;
  }, F.prototype.swap32 = function() {
    const ce = this.length;
    if (ce % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let ve = 0; ve < ce; ve += 4)
      _e(this, ve, ve + 3), _e(this, ve + 1, ve + 2);
    return this;
  }, F.prototype.swap64 = function() {
    const ce = this.length;
    if (ce % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let ve = 0; ve < ce; ve += 8)
      _e(this, ve, ve + 7), _e(this, ve + 1, ve + 6), _e(this, ve + 2, ve + 5), _e(this, ve + 3, ve + 4);
    return this;
  }, F.prototype.toString = function() {
    const ce = this.length;
    return ce === 0 ? "" : arguments.length === 0 ? x(this, 0, ce) : ke.apply(this, arguments);
  }, F.prototype.toLocaleString = F.prototype.toString, F.prototype.equals = function(ce) {
    if (!F.isBuffer(ce))
      throw new TypeError("Argument must be a Buffer");
    return this === ce ? !0 : F.compare(this, ce) === 0;
  }, F.prototype.inspect = function() {
    let ce = "";
    const ve = a.INSPECT_MAX_BYTES;
    return ce = this.toString("hex", 0, ve).replace(/(.{2})/g, "$1 ").trim(), this.length > ve && (ce += " ... "), "<Buffer " + ce + ">";
  }, l && (F.prototype[l] = F.prototype.inspect), F.prototype.compare = function(ce, ve, Ce, Be, He) {
    if (Te(ce, p) && (ce = F.from(ce, ce.offset, ce.byteLength)), !F.isBuffer(ce))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof ce
      );
    if (ve === void 0 && (ve = 0), Ce === void 0 && (Ce = ce ? ce.length : 0), Be === void 0 && (Be = 0), He === void 0 && (He = this.length), ve < 0 || Ce > ce.length || Be < 0 || He > this.length)
      throw new RangeError("out of range index");
    if (Be >= He && ve >= Ce)
      return 0;
    if (Be >= He)
      return -1;
    if (ve >= Ce)
      return 1;
    if (ve >>>= 0, Ce >>>= 0, Be >>>= 0, He >>>= 0, this === ce)
      return 0;
    let Ve = He - Be, Ze = Ce - ve;
    const Ke = Math.min(Ve, Ze), U = this.slice(Be, He), se = ce.slice(ve, Ce);
    for (let Se = 0; Se < Ke; ++Se)
      if (U[Se] !== se[Se]) {
        Ve = U[Se], Ze = se[Se];
        break;
      }
    return Ve < Ze ? -1 : Ze < Ve ? 1 : 0;
  };
  function q(ue, ce, ve, Ce, Be) {
    if (ue.length === 0)
      return -1;
    if (typeof ve == "string" ? (Ce = ve, ve = 0) : ve > 2147483647 ? ve = 2147483647 : ve < -2147483648 && (ve = -2147483648), ve = +ve, We(ve) && (ve = Be ? 0 : ue.length - 1), ve < 0 && (ve = ue.length + ve), ve >= ue.length) {
      if (Be)
        return -1;
      ve = ue.length - 1;
    } else if (ve < 0)
      if (Be)
        ve = 0;
      else
        return -1;
    if (typeof ce == "string" && (ce = F.from(ce, Ce)), F.isBuffer(ce))
      return ce.length === 0 ? -1 : z(ue, ce, ve, Ce, Be);
    if (typeof ce == "number")
      return ce = ce & 255, typeof p.prototype.indexOf == "function" ? Be ? p.prototype.indexOf.call(ue, ce, ve) : p.prototype.lastIndexOf.call(ue, ce, ve) : z(ue, [ce], ve, Ce, Be);
    throw new TypeError("val must be string, number or Buffer");
  }
  function z(ue, ce, ve, Ce, Be) {
    let He = 1, Ve = ue.length, Ze = ce.length;
    if (Ce !== void 0 && (Ce = String(Ce).toLowerCase(), Ce === "ucs2" || Ce === "ucs-2" || Ce === "utf16le" || Ce === "utf-16le")) {
      if (ue.length < 2 || ce.length < 2)
        return -1;
      He = 2, Ve /= 2, Ze /= 2, ve /= 2;
    }
    function Ke(se, Se) {
      return He === 1 ? se[Se] : se.readUInt16BE(Se * He);
    }
    let U;
    if (Be) {
      let se = -1;
      for (U = ve; U < Ve; U++)
        if (Ke(ue, U) === Ke(ce, se === -1 ? 0 : U - se)) {
          if (se === -1 && (se = U), U - se + 1 === Ze)
            return se * He;
        } else
          se !== -1 && (U -= U - se), se = -1;
    } else
      for (ve + Ze > Ve && (ve = Ve - Ze), U = ve; U >= 0; U--) {
        let se = !0;
        for (let Se = 0; Se < Ze; Se++)
          if (Ke(ue, U + Se) !== Ke(ce, Se)) {
            se = !1;
            break;
          }
        if (se)
          return U;
      }
    return -1;
  }
  F.prototype.includes = function(ce, ve, Ce) {
    return this.indexOf(ce, ve, Ce) !== -1;
  }, F.prototype.indexOf = function(ce, ve, Ce) {
    return q(this, ce, ve, Ce, !0);
  }, F.prototype.lastIndexOf = function(ce, ve, Ce) {
    return q(this, ce, ve, Ce, !1);
  };
  function C(ue, ce, ve, Ce) {
    ve = Number(ve) || 0;
    const Be = ue.length - ve;
    Ce ? (Ce = Number(Ce), Ce > Be && (Ce = Be)) : Ce = Be;
    const He = ce.length;
    Ce > He / 2 && (Ce = He / 2);
    let Ve;
    for (Ve = 0; Ve < Ce; ++Ve) {
      const Ze = parseInt(ce.substr(Ve * 2, 2), 16);
      if (We(Ze))
        return Ve;
      ue[ve + Ve] = Ze;
    }
    return Ve;
  }
  function b(ue, ce, ve, Ce) {
    return ge(yt(ce, ue.length - ve), ue, ve, Ce);
  }
  function E(ue, ce, ve, Ce) {
    return ge(Xe(ce), ue, ve, Ce);
  }
  function k(ue, ce, ve, Ce) {
    return ge(V(ce), ue, ve, Ce);
  }
  function O(ue, ce, ve, Ce) {
    return ge(Ge(ce, ue.length - ve), ue, ve, Ce);
  }
  F.prototype.write = function(ce, ve, Ce, Be) {
    if (ve === void 0)
      Be = "utf8", Ce = this.length, ve = 0;
    else if (Ce === void 0 && typeof ve == "string")
      Be = ve, Ce = this.length, ve = 0;
    else if (isFinite(ve))
      ve = ve >>> 0, isFinite(Ce) ? (Ce = Ce >>> 0, Be === void 0 && (Be = "utf8")) : (Be = Ce, Ce = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const He = this.length - ve;
    if ((Ce === void 0 || Ce > He) && (Ce = He), ce.length > 0 && (Ce < 0 || ve < 0) || ve > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Be || (Be = "utf8");
    let Ve = !1;
    for (; ; )
      switch (Be) {
        case "hex":
          return C(this, ce, ve, Ce);
        case "utf8":
        case "utf-8":
          return b(this, ce, ve, Ce);
        case "ascii":
        case "latin1":
        case "binary":
          return E(this, ce, ve, Ce);
        case "base64":
          return k(this, ce, ve, Ce);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return O(this, ce, ve, Ce);
        default:
          if (Ve)
            throw new TypeError("Unknown encoding: " + Be);
          Be = ("" + Be).toLowerCase(), Ve = !0;
      }
  }, F.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function A(ue, ce, ve) {
    return ce === 0 && ve === ue.length ? u.fromByteArray(ue) : u.fromByteArray(ue.slice(ce, ve));
  }
  function x(ue, ce, ve) {
    ve = Math.min(ue.length, ve);
    const Ce = [];
    let Be = ce;
    for (; Be < ve; ) {
      const He = ue[Be];
      let Ve = null, Ze = He > 239 ? 4 : He > 223 ? 3 : He > 191 ? 2 : 1;
      if (Be + Ze <= ve) {
        let Ke, U, se, Se;
        switch (Ze) {
          case 1:
            He < 128 && (Ve = He);
            break;
          case 2:
            Ke = ue[Be + 1], (Ke & 192) === 128 && (Se = (He & 31) << 6 | Ke & 63, Se > 127 && (Ve = Se));
            break;
          case 3:
            Ke = ue[Be + 1], U = ue[Be + 2], (Ke & 192) === 128 && (U & 192) === 128 && (Se = (He & 15) << 12 | (Ke & 63) << 6 | U & 63, Se > 2047 && (Se < 55296 || Se > 57343) && (Ve = Se));
            break;
          case 4:
            Ke = ue[Be + 1], U = ue[Be + 2], se = ue[Be + 3], (Ke & 192) === 128 && (U & 192) === 128 && (se & 192) === 128 && (Se = (He & 15) << 18 | (Ke & 63) << 12 | (U & 63) << 6 | se & 63, Se > 65535 && Se < 1114112 && (Ve = Se));
        }
      }
      Ve === null ? (Ve = 65533, Ze = 1) : Ve > 65535 && (Ve -= 65536, Ce.push(Ve >>> 10 & 1023 | 55296), Ve = 56320 | Ve & 1023), Ce.push(Ve), Be += Ze;
    }
    return B(Ce);
  }
  const Y = 4096;
  function B(ue) {
    const ce = ue.length;
    if (ce <= Y)
      return String.fromCharCode.apply(String, ue);
    let ve = "", Ce = 0;
    for (; Ce < ce; )
      ve += String.fromCharCode.apply(
        String,
        ue.slice(Ce, Ce += Y)
      );
    return ve;
  }
  function T(ue, ce, ve) {
    let Ce = "";
    ve = Math.min(ue.length, ve);
    for (let Be = ce; Be < ve; ++Be)
      Ce += String.fromCharCode(ue[Be] & 127);
    return Ce;
  }
  function D(ue, ce, ve) {
    let Ce = "";
    ve = Math.min(ue.length, ve);
    for (let Be = ce; Be < ve; ++Be)
      Ce += String.fromCharCode(ue[Be]);
    return Ce;
  }
  function te(ue, ce, ve) {
    const Ce = ue.length;
    (!ce || ce < 0) && (ce = 0), (!ve || ve < 0 || ve > Ce) && (ve = Ce);
    let Be = "";
    for (let He = ce; He < ve; ++He)
      Be += Re[ue[He]];
    return Be;
  }
  function me(ue, ce, ve) {
    const Ce = ue.slice(ce, ve);
    let Be = "";
    for (let He = 0; He < Ce.length - 1; He += 2)
      Be += String.fromCharCode(Ce[He] + Ce[He + 1] * 256);
    return Be;
  }
  F.prototype.slice = function(ce, ve) {
    const Ce = this.length;
    ce = ~~ce, ve = ve === void 0 ? Ce : ~~ve, ce < 0 ? (ce += Ce, ce < 0 && (ce = 0)) : ce > Ce && (ce = Ce), ve < 0 ? (ve += Ce, ve < 0 && (ve = 0)) : ve > Ce && (ve = Ce), ve < ce && (ve = ce);
    const Be = this.subarray(ce, ve);
    return Object.setPrototypeOf(Be, F.prototype), Be;
  };
  function Ie(ue, ce, ve) {
    if (ue % 1 !== 0 || ue < 0)
      throw new RangeError("offset is not uint");
    if (ue + ce > ve)
      throw new RangeError("Trying to access beyond buffer length");
  }
  F.prototype.readUintLE = F.prototype.readUIntLE = function(ce, ve, Ce) {
    ce = ce >>> 0, ve = ve >>> 0, Ce || Ie(ce, ve, this.length);
    let Be = this[ce], He = 1, Ve = 0;
    for (; ++Ve < ve && (He *= 256); )
      Be += this[ce + Ve] * He;
    return Be;
  }, F.prototype.readUintBE = F.prototype.readUIntBE = function(ce, ve, Ce) {
    ce = ce >>> 0, ve = ve >>> 0, Ce || Ie(ce, ve, this.length);
    let Be = this[ce + --ve], He = 1;
    for (; ve > 0 && (He *= 256); )
      Be += this[ce + --ve] * He;
    return Be;
  }, F.prototype.readUint8 = F.prototype.readUInt8 = function(ce, ve) {
    return ce = ce >>> 0, ve || Ie(ce, 1, this.length), this[ce];
  }, F.prototype.readUint16LE = F.prototype.readUInt16LE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ie(ce, 2, this.length), this[ce] | this[ce + 1] << 8;
  }, F.prototype.readUint16BE = F.prototype.readUInt16BE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ie(ce, 2, this.length), this[ce] << 8 | this[ce + 1];
  }, F.prototype.readUint32LE = F.prototype.readUInt32LE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ie(ce, 4, this.length), (this[ce] | this[ce + 1] << 8 | this[ce + 2] << 16) + this[ce + 3] * 16777216;
  }, F.prototype.readUint32BE = F.prototype.readUInt32BE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ie(ce, 4, this.length), this[ce] * 16777216 + (this[ce + 1] << 16 | this[ce + 2] << 8 | this[ce + 3]);
  }, F.prototype.readBigUInt64LE = J(function(ce) {
    ce = ce >>> 0, Oe(ce, "offset");
    const ve = this[ce], Ce = this[ce + 7];
    (ve === void 0 || Ce === void 0) && qe(ce, this.length - 8);
    const Be = ve + this[++ce] * 2 ** 8 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 24, He = this[++ce] + this[++ce] * 2 ** 8 + this[++ce] * 2 ** 16 + Ce * 2 ** 24;
    return BigInt(Be) + (BigInt(He) << BigInt(32));
  }), F.prototype.readBigUInt64BE = J(function(ce) {
    ce = ce >>> 0, Oe(ce, "offset");
    const ve = this[ce], Ce = this[ce + 7];
    (ve === void 0 || Ce === void 0) && qe(ce, this.length - 8);
    const Be = ve * 2 ** 24 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 8 + this[++ce], He = this[++ce] * 2 ** 24 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 8 + Ce;
    return (BigInt(Be) << BigInt(32)) + BigInt(He);
  }), F.prototype.readIntLE = function(ce, ve, Ce) {
    ce = ce >>> 0, ve = ve >>> 0, Ce || Ie(ce, ve, this.length);
    let Be = this[ce], He = 1, Ve = 0;
    for (; ++Ve < ve && (He *= 256); )
      Be += this[ce + Ve] * He;
    return He *= 128, Be >= He && (Be -= Math.pow(2, 8 * ve)), Be;
  }, F.prototype.readIntBE = function(ce, ve, Ce) {
    ce = ce >>> 0, ve = ve >>> 0, Ce || Ie(ce, ve, this.length);
    let Be = ve, He = 1, Ve = this[ce + --Be];
    for (; Be > 0 && (He *= 256); )
      Ve += this[ce + --Be] * He;
    return He *= 128, Ve >= He && (Ve -= Math.pow(2, 8 * ve)), Ve;
  }, F.prototype.readInt8 = function(ce, ve) {
    return ce = ce >>> 0, ve || Ie(ce, 1, this.length), this[ce] & 128 ? (255 - this[ce] + 1) * -1 : this[ce];
  }, F.prototype.readInt16LE = function(ce, ve) {
    ce = ce >>> 0, ve || Ie(ce, 2, this.length);
    const Ce = this[ce] | this[ce + 1] << 8;
    return Ce & 32768 ? Ce | 4294901760 : Ce;
  }, F.prototype.readInt16BE = function(ce, ve) {
    ce = ce >>> 0, ve || Ie(ce, 2, this.length);
    const Ce = this[ce + 1] | this[ce] << 8;
    return Ce & 32768 ? Ce | 4294901760 : Ce;
  }, F.prototype.readInt32LE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ie(ce, 4, this.length), this[ce] | this[ce + 1] << 8 | this[ce + 2] << 16 | this[ce + 3] << 24;
  }, F.prototype.readInt32BE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ie(ce, 4, this.length), this[ce] << 24 | this[ce + 1] << 16 | this[ce + 2] << 8 | this[ce + 3];
  }, F.prototype.readBigInt64LE = J(function(ce) {
    ce = ce >>> 0, Oe(ce, "offset");
    const ve = this[ce], Ce = this[ce + 7];
    (ve === void 0 || Ce === void 0) && qe(ce, this.length - 8);
    const Be = this[ce + 4] + this[ce + 5] * 2 ** 8 + this[ce + 6] * 2 ** 16 + (Ce << 24);
    return (BigInt(Be) << BigInt(32)) + BigInt(ve + this[++ce] * 2 ** 8 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 24);
  }), F.prototype.readBigInt64BE = J(function(ce) {
    ce = ce >>> 0, Oe(ce, "offset");
    const ve = this[ce], Ce = this[ce + 7];
    (ve === void 0 || Ce === void 0) && qe(ce, this.length - 8);
    const Be = (ve << 24) + // Overflow
    this[++ce] * 2 ** 16 + this[++ce] * 2 ** 8 + this[++ce];
    return (BigInt(Be) << BigInt(32)) + BigInt(this[++ce] * 2 ** 24 + this[++ce] * 2 ** 16 + this[++ce] * 2 ** 8 + Ce);
  }), F.prototype.readFloatLE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ie(ce, 4, this.length), c.read(this, ce, !0, 23, 4);
  }, F.prototype.readFloatBE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ie(ce, 4, this.length), c.read(this, ce, !1, 23, 4);
  }, F.prototype.readDoubleLE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ie(ce, 8, this.length), c.read(this, ce, !0, 52, 8);
  }, F.prototype.readDoubleBE = function(ce, ve) {
    return ce = ce >>> 0, ve || Ie(ce, 8, this.length), c.read(this, ce, !1, 52, 8);
  };
  function $e(ue, ce, ve, Ce, Be, He) {
    if (!F.isBuffer(ue))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (ce > Be || ce < He)
      throw new RangeError('"value" argument is out of bounds');
    if (ve + Ce > ue.length)
      throw new RangeError("Index out of range");
  }
  F.prototype.writeUintLE = F.prototype.writeUIntLE = function(ce, ve, Ce, Be) {
    if (ce = +ce, ve = ve >>> 0, Ce = Ce >>> 0, !Be) {
      const Ze = Math.pow(2, 8 * Ce) - 1;
      $e(this, ce, ve, Ce, Ze, 0);
    }
    let He = 1, Ve = 0;
    for (this[ve] = ce & 255; ++Ve < Ce && (He *= 256); )
      this[ve + Ve] = ce / He & 255;
    return ve + Ce;
  }, F.prototype.writeUintBE = F.prototype.writeUIntBE = function(ce, ve, Ce, Be) {
    if (ce = +ce, ve = ve >>> 0, Ce = Ce >>> 0, !Be) {
      const Ze = Math.pow(2, 8 * Ce) - 1;
      $e(this, ce, ve, Ce, Ze, 0);
    }
    let He = Ce - 1, Ve = 1;
    for (this[ve + He] = ce & 255; --He >= 0 && (Ve *= 256); )
      this[ve + He] = ce / Ve & 255;
    return ve + Ce;
  }, F.prototype.writeUint8 = F.prototype.writeUInt8 = function(ce, ve, Ce) {
    return ce = +ce, ve = ve >>> 0, Ce || $e(this, ce, ve, 1, 255, 0), this[ve] = ce & 255, ve + 1;
  }, F.prototype.writeUint16LE = F.prototype.writeUInt16LE = function(ce, ve, Ce) {
    return ce = +ce, ve = ve >>> 0, Ce || $e(this, ce, ve, 2, 65535, 0), this[ve] = ce & 255, this[ve + 1] = ce >>> 8, ve + 2;
  }, F.prototype.writeUint16BE = F.prototype.writeUInt16BE = function(ce, ve, Ce) {
    return ce = +ce, ve = ve >>> 0, Ce || $e(this, ce, ve, 2, 65535, 0), this[ve] = ce >>> 8, this[ve + 1] = ce & 255, ve + 2;
  }, F.prototype.writeUint32LE = F.prototype.writeUInt32LE = function(ce, ve, Ce) {
    return ce = +ce, ve = ve >>> 0, Ce || $e(this, ce, ve, 4, 4294967295, 0), this[ve + 3] = ce >>> 24, this[ve + 2] = ce >>> 16, this[ve + 1] = ce >>> 8, this[ve] = ce & 255, ve + 4;
  }, F.prototype.writeUint32BE = F.prototype.writeUInt32BE = function(ce, ve, Ce) {
    return ce = +ce, ve = ve >>> 0, Ce || $e(this, ce, ve, 4, 4294967295, 0), this[ve] = ce >>> 24, this[ve + 1] = ce >>> 16, this[ve + 2] = ce >>> 8, this[ve + 3] = ce & 255, ve + 4;
  };
  function ye(ue, ce, ve, Ce, Be) {
    Ne(ce, Ce, Be, ue, ve, 7);
    let He = Number(ce & BigInt(4294967295));
    ue[ve++] = He, He = He >> 8, ue[ve++] = He, He = He >> 8, ue[ve++] = He, He = He >> 8, ue[ve++] = He;
    let Ve = Number(ce >> BigInt(32) & BigInt(4294967295));
    return ue[ve++] = Ve, Ve = Ve >> 8, ue[ve++] = Ve, Ve = Ve >> 8, ue[ve++] = Ve, Ve = Ve >> 8, ue[ve++] = Ve, ve;
  }
  function fe(ue, ce, ve, Ce, Be) {
    Ne(ce, Ce, Be, ue, ve, 7);
    let He = Number(ce & BigInt(4294967295));
    ue[ve + 7] = He, He = He >> 8, ue[ve + 6] = He, He = He >> 8, ue[ve + 5] = He, He = He >> 8, ue[ve + 4] = He;
    let Ve = Number(ce >> BigInt(32) & BigInt(4294967295));
    return ue[ve + 3] = Ve, Ve = Ve >> 8, ue[ve + 2] = Ve, Ve = Ve >> 8, ue[ve + 1] = Ve, Ve = Ve >> 8, ue[ve] = Ve, ve + 8;
  }
  F.prototype.writeBigUInt64LE = J(function(ce, ve = 0) {
    return ye(this, ce, ve, BigInt(0), BigInt("0xffffffffffffffff"));
  }), F.prototype.writeBigUInt64BE = J(function(ce, ve = 0) {
    return fe(this, ce, ve, BigInt(0), BigInt("0xffffffffffffffff"));
  }), F.prototype.writeIntLE = function(ce, ve, Ce, Be) {
    if (ce = +ce, ve = ve >>> 0, !Be) {
      const Ke = Math.pow(2, 8 * Ce - 1);
      $e(this, ce, ve, Ce, Ke - 1, -Ke);
    }
    let He = 0, Ve = 1, Ze = 0;
    for (this[ve] = ce & 255; ++He < Ce && (Ve *= 256); )
      ce < 0 && Ze === 0 && this[ve + He - 1] !== 0 && (Ze = 1), this[ve + He] = (ce / Ve >> 0) - Ze & 255;
    return ve + Ce;
  }, F.prototype.writeIntBE = function(ce, ve, Ce, Be) {
    if (ce = +ce, ve = ve >>> 0, !Be) {
      const Ke = Math.pow(2, 8 * Ce - 1);
      $e(this, ce, ve, Ce, Ke - 1, -Ke);
    }
    let He = Ce - 1, Ve = 1, Ze = 0;
    for (this[ve + He] = ce & 255; --He >= 0 && (Ve *= 256); )
      ce < 0 && Ze === 0 && this[ve + He + 1] !== 0 && (Ze = 1), this[ve + He] = (ce / Ve >> 0) - Ze & 255;
    return ve + Ce;
  }, F.prototype.writeInt8 = function(ce, ve, Ce) {
    return ce = +ce, ve = ve >>> 0, Ce || $e(this, ce, ve, 1, 127, -128), ce < 0 && (ce = 255 + ce + 1), this[ve] = ce & 255, ve + 1;
  }, F.prototype.writeInt16LE = function(ce, ve, Ce) {
    return ce = +ce, ve = ve >>> 0, Ce || $e(this, ce, ve, 2, 32767, -32768), this[ve] = ce & 255, this[ve + 1] = ce >>> 8, ve + 2;
  }, F.prototype.writeInt16BE = function(ce, ve, Ce) {
    return ce = +ce, ve = ve >>> 0, Ce || $e(this, ce, ve, 2, 32767, -32768), this[ve] = ce >>> 8, this[ve + 1] = ce & 255, ve + 2;
  }, F.prototype.writeInt32LE = function(ce, ve, Ce) {
    return ce = +ce, ve = ve >>> 0, Ce || $e(this, ce, ve, 4, 2147483647, -2147483648), this[ve] = ce & 255, this[ve + 1] = ce >>> 8, this[ve + 2] = ce >>> 16, this[ve + 3] = ce >>> 24, ve + 4;
  }, F.prototype.writeInt32BE = function(ce, ve, Ce) {
    return ce = +ce, ve = ve >>> 0, Ce || $e(this, ce, ve, 4, 2147483647, -2147483648), ce < 0 && (ce = 4294967295 + ce + 1), this[ve] = ce >>> 24, this[ve + 1] = ce >>> 16, this[ve + 2] = ce >>> 8, this[ve + 3] = ce & 255, ve + 4;
  }, F.prototype.writeBigInt64LE = J(function(ce, ve = 0) {
    return ye(this, ce, ve, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), F.prototype.writeBigInt64BE = J(function(ce, ve = 0) {
    return fe(this, ce, ve, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Me(ue, ce, ve, Ce, Be, He) {
    if (ve + Ce > ue.length)
      throw new RangeError("Index out of range");
    if (ve < 0)
      throw new RangeError("Index out of range");
  }
  function Ae(ue, ce, ve, Ce, Be) {
    return ce = +ce, ve = ve >>> 0, Be || Me(ue, ce, ve, 4), c.write(ue, ce, ve, Ce, 23, 4), ve + 4;
  }
  F.prototype.writeFloatLE = function(ce, ve, Ce) {
    return Ae(this, ce, ve, !0, Ce);
  }, F.prototype.writeFloatBE = function(ce, ve, Ce) {
    return Ae(this, ce, ve, !1, Ce);
  };
  function xe(ue, ce, ve, Ce, Be) {
    return ce = +ce, ve = ve >>> 0, Be || Me(ue, ce, ve, 8), c.write(ue, ce, ve, Ce, 52, 8), ve + 8;
  }
  F.prototype.writeDoubleLE = function(ce, ve, Ce) {
    return xe(this, ce, ve, !0, Ce);
  }, F.prototype.writeDoubleBE = function(ce, ve, Ce) {
    return xe(this, ce, ve, !1, Ce);
  }, F.prototype.copy = function(ce, ve, Ce, Be) {
    if (!F.isBuffer(ce))
      throw new TypeError("argument should be a Buffer");
    if (Ce || (Ce = 0), !Be && Be !== 0 && (Be = this.length), ve >= ce.length && (ve = ce.length), ve || (ve = 0), Be > 0 && Be < Ce && (Be = Ce), Be === Ce || ce.length === 0 || this.length === 0)
      return 0;
    if (ve < 0)
      throw new RangeError("targetStart out of bounds");
    if (Ce < 0 || Ce >= this.length)
      throw new RangeError("Index out of range");
    if (Be < 0)
      throw new RangeError("sourceEnd out of bounds");
    Be > this.length && (Be = this.length), ce.length - ve < Be - Ce && (Be = ce.length - ve + Ce);
    const He = Be - Ce;
    return this === ce && typeof p.prototype.copyWithin == "function" ? this.copyWithin(ve, Ce, Be) : p.prototype.set.call(
      ce,
      this.subarray(Ce, Be),
      ve
    ), He;
  }, F.prototype.fill = function(ce, ve, Ce, Be) {
    if (typeof ce == "string") {
      if (typeof ve == "string" ? (Be = ve, ve = 0, Ce = this.length) : typeof Ce == "string" && (Be = Ce, Ce = this.length), Be !== void 0 && typeof Be != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Be == "string" && !F.isEncoding(Be))
        throw new TypeError("Unknown encoding: " + Be);
      if (ce.length === 1) {
        const Ve = ce.charCodeAt(0);
        (Be === "utf8" && Ve < 128 || Be === "latin1") && (ce = Ve);
      }
    } else
      typeof ce == "number" ? ce = ce & 255 : typeof ce == "boolean" && (ce = Number(ce));
    if (ve < 0 || this.length < ve || this.length < Ce)
      throw new RangeError("Out of range index");
    if (Ce <= ve)
      return this;
    ve = ve >>> 0, Ce = Ce === void 0 ? this.length : Ce >>> 0, ce || (ce = 0);
    let He;
    if (typeof ce == "number")
      for (He = ve; He < Ce; ++He)
        this[He] = ce;
    else {
      const Ve = F.isBuffer(ce) ? ce : F.from(ce, Be), Ze = Ve.length;
      if (Ze === 0)
        throw new TypeError('The value "' + ce + '" is invalid for argument "value"');
      for (He = 0; He < Ce - ve; ++He)
        this[He + ve] = Ve[He % Ze];
    }
    return this;
  };
  const ae = {};
  function N(ue, ce, ve) {
    ae[ue] = class extends ve {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: ce.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${ue}]`, this.stack, delete this.name;
      }
      get code() {
        return ue;
      }
      set code(Be) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Be,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${ue}]: ${this.message}`;
      }
    };
  }
  N(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(ue) {
      return ue ? `${ue} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), N(
    "ERR_INVALID_ARG_TYPE",
    function(ue, ce) {
      return `The "${ue}" argument must be of type number. Received type ${typeof ce}`;
    },
    TypeError
  ), N(
    "ERR_OUT_OF_RANGE",
    function(ue, ce, ve) {
      let Ce = `The value of "${ue}" is out of range.`, Be = ve;
      return Number.isInteger(ve) && Math.abs(ve) > 2 ** 32 ? Be = re(String(ve)) : typeof ve == "bigint" && (Be = String(ve), (ve > BigInt(2) ** BigInt(32) || ve < -(BigInt(2) ** BigInt(32))) && (Be = re(Be)), Be += "n"), Ce += ` It must be ${ce}. Received ${Be}`, Ce;
    },
    RangeError
  );
  function re(ue) {
    let ce = "", ve = ue.length;
    const Ce = ue[0] === "-" ? 1 : 0;
    for (; ve >= Ce + 4; ve -= 3)
      ce = `_${ue.slice(ve - 3, ve)}${ce}`;
    return `${ue.slice(0, ve)}${ce}`;
  }
  function le(ue, ce, ve) {
    Oe(ce, "offset"), (ue[ce] === void 0 || ue[ce + ve] === void 0) && qe(ce, ue.length - (ve + 1));
  }
  function Ne(ue, ce, ve, Ce, Be, He) {
    if (ue > ve || ue < ce) {
      const Ve = typeof ce == "bigint" ? "n" : "";
      let Ze;
      throw He > 3 ? ce === 0 || ce === BigInt(0) ? Ze = `>= 0${Ve} and < 2${Ve} ** ${(He + 1) * 8}${Ve}` : Ze = `>= -(2${Ve} ** ${(He + 1) * 8 - 1}${Ve}) and < 2 ** ${(He + 1) * 8 - 1}${Ve}` : Ze = `>= ${ce}${Ve} and <= ${ve}${Ve}`, new ae.ERR_OUT_OF_RANGE("value", Ze, ue);
    }
    le(Ce, Be, He);
  }
  function Oe(ue, ce) {
    if (typeof ue != "number")
      throw new ae.ERR_INVALID_ARG_TYPE(ce, "number", ue);
  }
  function qe(ue, ce, ve) {
    throw Math.floor(ue) !== ue ? (Oe(ue, ve), new ae.ERR_OUT_OF_RANGE(ve || "offset", "an integer", ue)) : ce < 0 ? new ae.ERR_BUFFER_OUT_OF_BOUNDS() : new ae.ERR_OUT_OF_RANGE(
      ve || "offset",
      `>= ${ve ? 1 : 0} and <= ${ce}`,
      ue
    );
  }
  const je = /[^+/0-9A-Za-z-_]/g;
  function Fe(ue) {
    if (ue = ue.split("=")[0], ue = ue.trim().replace(je, ""), ue.length < 2)
      return "";
    for (; ue.length % 4 !== 0; )
      ue = ue + "=";
    return ue;
  }
  function yt(ue, ce) {
    ce = ce || 1 / 0;
    let ve;
    const Ce = ue.length;
    let Be = null;
    const He = [];
    for (let Ve = 0; Ve < Ce; ++Ve) {
      if (ve = ue.charCodeAt(Ve), ve > 55295 && ve < 57344) {
        if (!Be) {
          if (ve > 56319) {
            (ce -= 3) > -1 && He.push(239, 191, 189);
            continue;
          } else if (Ve + 1 === Ce) {
            (ce -= 3) > -1 && He.push(239, 191, 189);
            continue;
          }
          Be = ve;
          continue;
        }
        if (ve < 56320) {
          (ce -= 3) > -1 && He.push(239, 191, 189), Be = ve;
          continue;
        }
        ve = (Be - 55296 << 10 | ve - 56320) + 65536;
      } else
        Be && (ce -= 3) > -1 && He.push(239, 191, 189);
      if (Be = null, ve < 128) {
        if ((ce -= 1) < 0)
          break;
        He.push(ve);
      } else if (ve < 2048) {
        if ((ce -= 2) < 0)
          break;
        He.push(
          ve >> 6 | 192,
          ve & 63 | 128
        );
      } else if (ve < 65536) {
        if ((ce -= 3) < 0)
          break;
        He.push(
          ve >> 12 | 224,
          ve >> 6 & 63 | 128,
          ve & 63 | 128
        );
      } else if (ve < 1114112) {
        if ((ce -= 4) < 0)
          break;
        He.push(
          ve >> 18 | 240,
          ve >> 12 & 63 | 128,
          ve >> 6 & 63 | 128,
          ve & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return He;
  }
  function Xe(ue) {
    const ce = [];
    for (let ve = 0; ve < ue.length; ++ve)
      ce.push(ue.charCodeAt(ve) & 255);
    return ce;
  }
  function Ge(ue, ce) {
    let ve, Ce, Be;
    const He = [];
    for (let Ve = 0; Ve < ue.length && !((ce -= 2) < 0); ++Ve)
      ve = ue.charCodeAt(Ve), Ce = ve >> 8, Be = ve % 256, He.push(Be), He.push(Ce);
    return He;
  }
  function V(ue) {
    return u.toByteArray(Fe(ue));
  }
  function ge(ue, ce, ve, Ce) {
    let Be;
    for (Be = 0; Be < Ce && !(Be + ve >= ce.length || Be >= ue.length); ++Be)
      ce[Be + ve] = ue[Be];
    return Be;
  }
  function Te(ue, ce) {
    return ue instanceof ce || ue != null && ue.constructor != null && ue.constructor.name != null && ue.constructor.name === ce.name;
  }
  function We(ue) {
    return ue !== ue;
  }
  const Re = function() {
    const ue = "0123456789abcdef", ce = new Array(256);
    for (let ve = 0; ve < 16; ++ve) {
      const Ce = ve * 16;
      for (let Be = 0; Be < 16; ++Be)
        ce[Ce + Be] = ue[ve] + ue[Be];
    }
    return ce;
  }();
  function J(ue) {
    return typeof BigInt > "u" ? Ee : ue;
  }
  function Ee() {
    throw new Error("BigInt not supported");
  }
})(buffer$3);
const Buffer$O = buffer$3.Buffer, Blob$1 = buffer$3.Blob, BlobOptions = buffer$3.BlobOptions, Buffer$1$1 = buffer$3.Buffer, File = buffer$3.File, FileOptions = buffer$3.FileOptions, INSPECT_MAX_BYTES = buffer$3.INSPECT_MAX_BYTES, SlowBuffer$1 = buffer$3.SlowBuffer, TranscodeEncoding = buffer$3.TranscodeEncoding, atob$1 = buffer$3.atob, btoa$1 = buffer$3.btoa, constants$1 = buffer$3.constants, isAscii = buffer$3.isAscii, isUtf8 = buffer$3.isUtf8, kMaxLength = buffer$3.kMaxLength, kStringMaxLength = buffer$3.kStringMaxLength, resolveObjectURL = buffer$3.resolveObjectURL, transcode = buffer$3.transcode, dist$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob: Blob$1,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer: SlowBuffer$1,
  TranscodeEncoding,
  atob: atob$1,
  btoa: btoa$1,
  constants: constants$1,
  default: Buffer$O,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var base64$2 = { exports: {} };
(function(a, u) {
  (function(c, l) {
    a.exports = l();
  })(typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal$1, function() {
    var c = "3.7.2", l = c, v = typeof atob == "function", p = typeof btoa == "function", _ = typeof Buffer$O == "function", I = typeof TextDecoder == "function" ? new TextDecoder() : void 0, P = typeof TextEncoder == "function" ? new TextEncoder() : void 0, $ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", F = Array.prototype.slice.call($), H = function(fe) {
      var Me = {};
      return fe.forEach(function(Ae, xe) {
        return Me[Ae] = xe;
      }), Me;
    }(F), j = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, ee = String.fromCharCode.bind(String), X = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : function(fe, Me) {
      return Me === void 0 && (Me = function(Ae) {
        return Ae;
      }), new Uint8Array(Array.prototype.slice.call(fe, 0).map(Me));
    }, ie = function(fe) {
      return fe.replace(/=/g, "").replace(/[+\/]/g, function(Me) {
        return Me == "+" ? "-" : "_";
      });
    }, Q = function(fe) {
      return fe.replace(/[^A-Za-z0-9\+\/]/g, "");
    }, ne = function(fe) {
      for (var Me, Ae, xe, ae, N = "", re = fe.length % 3, le = 0; le < fe.length; ) {
        if ((Ae = fe.charCodeAt(le++)) > 255 || (xe = fe.charCodeAt(le++)) > 255 || (ae = fe.charCodeAt(le++)) > 255)
          throw new TypeError("invalid character found");
        Me = Ae << 16 | xe << 8 | ae, N += F[Me >> 18 & 63] + F[Me >> 12 & 63] + F[Me >> 6 & 63] + F[Me & 63];
      }
      return re ? N.slice(0, re - 3) + "===".substring(re) : N;
    }, Z = p ? function(fe) {
      return btoa(fe);
    } : _ ? function(fe) {
      return Buffer$O.from(fe, "binary").toString("base64");
    } : ne, de = _ ? function(fe) {
      return Buffer$O.from(fe).toString("base64");
    } : function(fe) {
      for (var Me = 4096, Ae = [], xe = 0, ae = fe.length; xe < ae; xe += Me)
        Ae.push(ee.apply(null, fe.subarray(xe, xe + Me)));
      return Z(Ae.join(""));
    }, he = function(fe, Me) {
      return Me === void 0 && (Me = !1), Me ? ie(de(fe)) : de(fe);
    }, pe = function(fe) {
      if (fe.length < 2) {
        var Me = fe.charCodeAt(0);
        return Me < 128 ? fe : Me < 2048 ? ee(192 | Me >>> 6) + ee(128 | Me & 63) : ee(224 | Me >>> 12 & 15) + ee(128 | Me >>> 6 & 63) + ee(128 | Me & 63);
      } else {
        var Me = 65536 + (fe.charCodeAt(0) - 55296) * 1024 + (fe.charCodeAt(1) - 56320);
        return ee(240 | Me >>> 18 & 7) + ee(128 | Me >>> 12 & 63) + ee(128 | Me >>> 6 & 63) + ee(128 | Me & 63);
      }
    }, be = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, ke = function(fe) {
      return fe.replace(be, pe);
    }, _e = _ ? function(fe) {
      return Buffer$O.from(fe, "utf8").toString("base64");
    } : P ? function(fe) {
      return de(P.encode(fe));
    } : function(fe) {
      return Z(ke(fe));
    }, q = function(fe, Me) {
      return Me === void 0 && (Me = !1), Me ? ie(_e(fe)) : _e(fe);
    }, z = function(fe) {
      return q(fe, !0);
    }, C = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, b = function(fe) {
      switch (fe.length) {
        case 4:
          var Me = (7 & fe.charCodeAt(0)) << 18 | (63 & fe.charCodeAt(1)) << 12 | (63 & fe.charCodeAt(2)) << 6 | 63 & fe.charCodeAt(3), Ae = Me - 65536;
          return ee((Ae >>> 10) + 55296) + ee((Ae & 1023) + 56320);
        case 3:
          return ee((15 & fe.charCodeAt(0)) << 12 | (63 & fe.charCodeAt(1)) << 6 | 63 & fe.charCodeAt(2));
        default:
          return ee((31 & fe.charCodeAt(0)) << 6 | 63 & fe.charCodeAt(1));
      }
    }, E = function(fe) {
      return fe.replace(C, b);
    }, k = function(fe) {
      if (fe = fe.replace(/\s+/g, ""), !j.test(fe))
        throw new TypeError("malformed base64.");
      fe += "==".slice(2 - (fe.length & 3));
      for (var Me, Ae = "", xe, ae, N = 0; N < fe.length; )
        Me = H[fe.charAt(N++)] << 18 | H[fe.charAt(N++)] << 12 | (xe = H[fe.charAt(N++)]) << 6 | (ae = H[fe.charAt(N++)]), Ae += xe === 64 ? ee(Me >> 16 & 255) : ae === 64 ? ee(Me >> 16 & 255, Me >> 8 & 255) : ee(Me >> 16 & 255, Me >> 8 & 255, Me & 255);
      return Ae;
    }, O = v ? function(fe) {
      return atob(Q(fe));
    } : _ ? function(fe) {
      return Buffer$O.from(fe, "base64").toString("binary");
    } : k, A = _ ? function(fe) {
      return X(Buffer$O.from(fe, "base64"));
    } : function(fe) {
      return X(O(fe), function(Me) {
        return Me.charCodeAt(0);
      });
    }, x = function(fe) {
      return A(B(fe));
    }, Y = _ ? function(fe) {
      return Buffer$O.from(fe, "base64").toString("utf8");
    } : I ? function(fe) {
      return I.decode(A(fe));
    } : function(fe) {
      return E(O(fe));
    }, B = function(fe) {
      return Q(fe.replace(/[-_]/g, function(Me) {
        return Me == "-" ? "+" : "/";
      }));
    }, T = function(fe) {
      return Y(B(fe));
    }, D = function(fe) {
      if (typeof fe != "string")
        return !1;
      var Me = fe.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(Me) || !/[^\s0-9a-zA-Z\-_]/.test(Me);
    }, te = function(fe) {
      return {
        value: fe,
        enumerable: !1,
        writable: !0,
        configurable: !0
      };
    }, me = function() {
      var fe = function(Me, Ae) {
        return Object.defineProperty(String.prototype, Me, te(Ae));
      };
      fe("fromBase64", function() {
        return T(this);
      }), fe("toBase64", function(Me) {
        return q(this, Me);
      }), fe("toBase64URI", function() {
        return q(this, !0);
      }), fe("toBase64URL", function() {
        return q(this, !0);
      }), fe("toUint8Array", function() {
        return x(this);
      });
    }, Ie = function() {
      var fe = function(Me, Ae) {
        return Object.defineProperty(Uint8Array.prototype, Me, te(Ae));
      };
      fe("toBase64", function(Me) {
        return he(this, Me);
      }), fe("toBase64URI", function() {
        return he(this, !0);
      }), fe("toBase64URL", function() {
        return he(this, !0);
      });
    }, $e = function() {
      me(), Ie();
    }, ye = {
      version: c,
      VERSION: l,
      atob: O,
      atobPolyfill: k,
      btoa: Z,
      btoaPolyfill: ne,
      fromBase64: T,
      toBase64: q,
      encode: q,
      encodeURI: z,
      encodeURL: z,
      utob: ke,
      btou: E,
      decode: T,
      isValid: D,
      fromUint8Array: he,
      toUint8Array: x,
      extendString: me,
      extendUint8Array: Ie,
      extendBuiltins: $e
    };
    return ye.Base64 = {}, Object.keys(ye).forEach(function(fe) {
      return ye.Base64[fe] = ye[fe];
    }), ye;
  });
})(base64$2);
var base64Exports = base64$2.exports;
Object.defineProperty(convertMetadata, "__esModule", { value: !0 });
convertMetadata.convertMetadataFromGrpcWeb = convertMetadata.convertMetadataToGrpcWeb = void 0;
const grpc_web_1$4 = grpcWebClient_umdExports, nice_grpc_common_1$5 = lib, js_base64_1 = base64Exports;
function convertMetadataToGrpcWeb(a) {
  const u = new grpc_web_1$4.grpc.Metadata();
  for (const [c, l] of a)
    for (const v of l)
      u.append(c, typeof v == "string" ? v : js_base64_1.Base64.fromUint8Array(v));
  return u;
}
convertMetadata.convertMetadataToGrpcWeb = convertMetadataToGrpcWeb;
function convertMetadataFromGrpcWeb(a) {
  const u = (0, nice_grpc_common_1$5.Metadata)();
  for (const [c, l] of Object.entries(a.headersMap))
    u.set(c, c.endsWith("-bin") ? l.map((v) => js_base64_1.Base64.toUint8Array(v)) : l);
  return u;
}
convertMetadata.convertMetadataFromGrpcWeb = convertMetadataFromGrpcWeb;
var __importDefault$h = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createBidiStreamingMethod$1, "__esModule", { value: !0 });
createBidiStreamingMethod$1.createBidiStreamingMethod = void 0;
const nice_grpc_common_1$4 = lib, grpc_web_1$3 = grpcWebClient_umdExports, abort_controller_x_1$4 = require$$1$3, node_abort_controller_1$3 = __importDefault$h(browserExports$2), AsyncSink_1$1 = AsyncSink$1, service_definitions_1$4 = serviceDefinitions, isAsyncIterable_1$3 = isAsyncIterable$1, convertMetadata_1$3 = convertMetadata;
function createBidiStreamingMethod(a, u, c, l) {
  const v = (0, service_definitions_1$4.toGrpcWebMethodDefinition)(a), p = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* _(P, $) {
    if (!(0, isAsyncIterable_1$3.isAsyncIterable)(P))
      throw new Error("A middleware passed invalid request to next(): expected a single message for bidirectional streaming method");
    const { metadata: F = (0, nice_grpc_common_1$4.Metadata)(), signal: H = new node_abort_controller_1$3.default().signal, onHeader: j, onTrailer: ee } = $, X = new node_abort_controller_1$3.default(), ie = new AsyncSink_1$1.AsyncSink(), Q = grpc_web_1$3.grpc.client(v, {
      host: u.address,
      transport: u.transport
    });
    Q.onHeaders((de) => {
      j == null || j((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(de));
    }), Q.onMessage((de) => {
      ie.write(de);
    }), Q.onEnd((de, he, pe) => {
      ee == null || ee((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(pe)), de === grpc_web_1$3.grpc.Code.OK ? ie.end() : ie.error(new nice_grpc_common_1$4.ClientError(a.path, +de, he));
    }), Q.start((0, convertMetadata_1$3.convertMetadataToGrpcWeb)(F));
    let ne;
    pipeRequest$1(X.signal, P, Q, a).then(() => {
      Q.finishSend();
    }, (de) => {
      (0, abort_controller_x_1$4.isAbortError)(de) || (ne = de, Q.close(), ie.end());
    });
    const Z = () => {
      ie.error(new abort_controller_x_1$4.AbortError()), X.abort(), Q.close();
    };
    H.addEventListener("abort", Z);
    try {
      yield* ie;
    } finally {
      if (X.abort(), H.removeEventListener("abort", Z), (0, abort_controller_x_1$4.throwIfAborted)(H), ne)
        throw ne;
    }
  }
  const I = c == null ? _ : (P, $) => c({
    method: p,
    requestStream: !0,
    request: P,
    responseStream: !0,
    next: _
  }, $);
  return (P, $) => {
    const H = I(P, {
      ...l,
      ...$
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const j = await H.next();
            return j.done && j.value != null ? await H.throw(new Error("A middleware returned a message, but expected to return void for bidirectional streaming method")) : j;
          },
          return() {
            return H.return();
          },
          throw(j) {
            return H.throw(j);
          }
        };
      }
    };
  };
}
createBidiStreamingMethod$1.createBidiStreamingMethod = createBidiStreamingMethod;
async function pipeRequest$1(a, u, c, l) {
  for await (const v of u)
    (0, abort_controller_x_1$4.throwIfAborted)(a), c.send({
      serializeBinary: () => l.requestSerialize(v)
    });
}
var createClientStreamingMethod$1 = {}, __importDefault$g = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createClientStreamingMethod$1, "__esModule", { value: !0 });
createClientStreamingMethod$1.createClientStreamingMethod = void 0;
const nice_grpc_common_1$3 = lib, grpc_web_1$2 = grpcWebClient_umdExports, abort_controller_x_1$3 = require$$1$3, node_abort_controller_1$2 = __importDefault$g(browserExports$2), service_definitions_1$3 = serviceDefinitions, isAsyncIterable_1$2 = isAsyncIterable$1, convertMetadata_1$2 = convertMetadata;
function createClientStreamingMethod(a, u, c, l) {
  const v = (0, service_definitions_1$3.toGrpcWebMethodDefinition)(a), p = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* _(P, $) {
    if (!(0, isAsyncIterable_1$2.isAsyncIterable)(P))
      throw new Error("A middleware passed invalid request to next(): expected a single message for client streaming method");
    const { metadata: F = (0, nice_grpc_common_1$3.Metadata)(), signal: H = new node_abort_controller_1$2.default().signal, onHeader: j, onTrailer: ee } = $;
    return await (0, abort_controller_x_1$3.execute)(H, (X, ie) => {
      const Q = new node_abort_controller_1$2.default();
      let ne;
      const Z = grpc_web_1$2.grpc.client(v, {
        host: u.address,
        transport: u.transport
      });
      return Z.onHeaders((de) => {
        j == null || j((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(de));
      }), Z.onMessage((de) => {
        ne = de;
      }), Z.onEnd((de, he, pe) => {
        ee == null || ee((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(pe)), Q.abort(), de === grpc_web_1$2.grpc.Code.OK ? X(ne) : ie(new nice_grpc_common_1$3.ClientError(a.path, +de, he));
      }), Z.start((0, convertMetadata_1$2.convertMetadataToGrpcWeb)(F)), pipeRequest(Q.signal, P, Z, a).then(() => {
        Z.finishSend();
      }, (de) => {
        (0, abort_controller_x_1$3.isAbortError)(de) || (ie(de), Z.close());
      }), () => {
        Q.abort(), Z.close();
      };
    });
  }
  const I = c == null ? _ : (P, $) => c({
    method: p,
    requestStream: !0,
    request: P,
    responseStream: !1,
    next: _
  }, $);
  return async (P, $) => {
    const H = I(P, {
      ...l,
      ...$
    })[Symbol.asyncIterator]();
    let j = await H.next();
    for (; ; ) {
      if (!j.done) {
        j = await H.throw(new Error("A middleware yielded a message, but expected to only return a message for client streaming method"));
        continue;
      }
      if (j.value == null) {
        j = await H.throw(new Error("A middleware returned void, but expected to return a message for client streaming method"));
        continue;
      }
      return j.value;
    }
  };
}
createClientStreamingMethod$1.createClientStreamingMethod = createClientStreamingMethod;
async function pipeRequest(a, u, c, l) {
  for await (const v of u)
    (0, abort_controller_x_1$3.throwIfAborted)(a), c.send({
      serializeBinary: () => l.requestSerialize(v)
    });
}
var createServerStreamingMethod$1 = {}, __importDefault$f = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createServerStreamingMethod$1, "__esModule", { value: !0 });
createServerStreamingMethod$1.createServerStreamingMethod = void 0;
const grpc_web_1$1 = grpcWebClient_umdExports, abort_controller_x_1$2 = require$$1$3, AsyncSink_1 = AsyncSink$1, nice_grpc_common_1$2 = lib, node_abort_controller_1$1 = __importDefault$f(browserExports$2), service_definitions_1$2 = serviceDefinitions, convertMetadata_1$1 = convertMetadata, isAsyncIterable_1$1 = isAsyncIterable$1;
function createServerStreamingMethod(a, u, c, l) {
  const v = (0, service_definitions_1$2.toGrpcWebMethodDefinition)(a), p = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* _(P, $) {
    if ((0, isAsyncIterable_1$1.isAsyncIterable)(P))
      throw new Error("A middleware passed invalid request to next(): expected a single message for server streaming method");
    const { metadata: F = (0, nice_grpc_common_1$2.Metadata)(), signal: H = new node_abort_controller_1$1.default().signal, onHeader: j, onTrailer: ee } = $, X = new AsyncSink_1.AsyncSink(), ie = grpc_web_1$1.grpc.client(v, {
      host: u.address,
      transport: u.transport
    });
    ie.onHeaders((ne) => {
      j == null || j((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(ne));
    }), ie.onMessage((ne) => {
      X.write(ne);
    }), ie.onEnd((ne, Z, de) => {
      ee == null || ee((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(de)), ne === grpc_web_1$1.grpc.Code.OK ? X.end() : X.error(new nice_grpc_common_1$2.ClientError(a.path, +ne, Z));
    }), ie.start((0, convertMetadata_1$1.convertMetadataToGrpcWeb)(F)), ie.send({
      serializeBinary: () => a.requestSerialize(P)
    }), ie.finishSend();
    const Q = () => {
      X.error(new abort_controller_x_1$2.AbortError()), ie.close();
    };
    H.addEventListener("abort", Q);
    try {
      yield* X;
    } finally {
      H.removeEventListener("abort", Q), (0, abort_controller_x_1$2.throwIfAborted)(H);
    }
  }
  const I = c == null ? _ : (P, $) => c({
    method: p,
    requestStream: !1,
    request: P,
    responseStream: !0,
    next: _
  }, $);
  return (P, $) => {
    const H = I(P, {
      ...l,
      ...$
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const j = await H.next();
            return j.done && j.value != null ? await H.throw(new Error("A middleware returned a message, but expected to return void for server streaming method")) : j;
          },
          return() {
            return H.return();
          },
          throw(j) {
            return H.throw(j);
          }
        };
      }
    };
  };
}
createServerStreamingMethod$1.createServerStreamingMethod = createServerStreamingMethod;
var createUnaryMethod$1 = {}, __importDefault$e = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createUnaryMethod$1, "__esModule", { value: !0 });
createUnaryMethod$1.createUnaryMethod = void 0;
const nice_grpc_common_1$1 = lib, grpc_web_1 = grpcWebClient_umdExports, abort_controller_x_1$1 = require$$1$3, node_abort_controller_1 = __importDefault$e(browserExports$2), service_definitions_1$1 = serviceDefinitions, isAsyncIterable_1 = isAsyncIterable$1, convertMetadata_1 = convertMetadata;
function createUnaryMethod(a, u, c, l) {
  const v = (0, service_definitions_1$1.toGrpcWebMethodDefinition)(a), p = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* _(P, $) {
    if ((0, isAsyncIterable_1.isAsyncIterable)(P))
      throw new Error("A middleware passed invalid request to next(): expected a single message for unary method");
    const { metadata: F = (0, nice_grpc_common_1$1.Metadata)(), signal: H = new node_abort_controller_1.default().signal, onHeader: j, onTrailer: ee } = $;
    return await (0, abort_controller_x_1$1.execute)(H, (X, ie) => {
      let Q;
      const ne = grpc_web_1.grpc.client(v, {
        host: u.address,
        transport: u.transport
      });
      return ne.onHeaders((Z) => {
        j == null || j((0, convertMetadata_1.convertMetadataFromGrpcWeb)(Z));
      }), ne.onMessage((Z) => {
        Q = Z;
      }), ne.onEnd((Z, de, he) => {
        ee == null || ee((0, convertMetadata_1.convertMetadataFromGrpcWeb)(he)), Z === grpc_web_1.grpc.Code.OK ? X(Q) : ie(new nice_grpc_common_1$1.ClientError(a.path, +Z, de));
      }), ne.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(F)), ne.send({
        serializeBinary: () => a.requestSerialize(P)
      }), ne.finishSend(), () => {
        ne.close();
      };
    });
  }
  const I = c == null ? _ : (P, $) => c({
    method: p,
    requestStream: !1,
    request: P,
    responseStream: !1,
    next: _
  }, $);
  return async (P, $) => {
    const H = I(P, {
      ...l,
      ...$
    })[Symbol.asyncIterator]();
    let j = await H.next();
    for (; ; ) {
      if (!j.done) {
        j = await H.throw(new Error("A middleware yielded a message, but expected to only return a message for unary method"));
        continue;
      }
      if (j.value == null) {
        j = await H.throw(new Error("A middleware returned void, but expected to return a message for unary method"));
        continue;
      }
      return j.value;
    }
  };
}
createUnaryMethod$1.createUnaryMethod = createUnaryMethod;
Object.defineProperty(ClientFactory, "__esModule", { value: !0 });
ClientFactory.createClient = ClientFactory.createClientFactory = void 0;
const nice_grpc_common_1 = lib, service_definitions_1 = serviceDefinitions, createBidiStreamingMethod_1 = createBidiStreamingMethod$1, createClientStreamingMethod_1 = createClientStreamingMethod$1, createServerStreamingMethod_1 = createServerStreamingMethod$1, createUnaryMethod_1 = createUnaryMethod$1;
function createClientFactory() {
  return createClientFactoryWithMiddleware();
}
ClientFactory.createClientFactory = createClientFactory;
function createClient(a, u, c) {
  return createClientFactory().create(a, u, c);
}
ClientFactory.createClient = createClient;
function createClientFactoryWithMiddleware(a) {
  return {
    use(u) {
      return createClientFactoryWithMiddleware(a == null ? u : (0, nice_grpc_common_1.composeClientMiddleware)(a, u));
    },
    create(u, c, l = {}) {
      const v = {}, p = Object.entries((0, service_definitions_1.normalizeServiceDefinition)(u));
      for (const [_, I] of p) {
        const P = {
          ...l["*"],
          ...l[_]
        };
        I.requestStream ? I.responseStream ? v[_] = (0, createBidiStreamingMethod_1.createBidiStreamingMethod)(I, c, a, P) : v[_] = (0, createClientStreamingMethod_1.createClientStreamingMethod)(I, c, a, P) : I.responseStream ? v[_] = (0, createServerStreamingMethod_1.createServerStreamingMethod)(I, c, a, P) : v[_] = (0, createUnaryMethod_1.createUnaryMethod)(I, c, a, P);
      }
      return v;
    }
  };
}
var Client = {};
Object.defineProperty(Client, "__esModule", { value: !0 });
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(v, p, _, I) {
    I === void 0 && (I = _);
    var P = Object.getOwnPropertyDescriptor(p, _);
    (!P || ("get" in P ? !p.__esModule : P.writable || P.configurable)) && (P = { enumerable: !0, get: function() {
      return p[_];
    } }), Object.defineProperty(v, I, P);
  } : function(v, p, _, I) {
    I === void 0 && (I = _), v[I] = p[_];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(v, p) {
    for (var _ in v)
      _ !== "default" && !Object.prototype.hasOwnProperty.call(p, _) && u(p, v, _);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.Status = a.Metadata = a.composeClientMiddleware = a.ClientError = void 0;
  var l = lib;
  Object.defineProperty(a, "ClientError", { enumerable: !0, get: function() {
    return l.ClientError;
  } }), Object.defineProperty(a, "composeClientMiddleware", { enumerable: !0, get: function() {
    return l.composeClientMiddleware;
  } }), Object.defineProperty(a, "Metadata", { enumerable: !0, get: function() {
    return l.Metadata;
  } }), Object.defineProperty(a, "Status", { enumerable: !0, get: function() {
    return l.Status;
  } }), c(serviceDefinitions, a), c(channel, a), c(ClientFactory, a), c(Client, a);
})(lib$1);
var dist$2 = {}, api$4 = {}, umd = { exports: {} };
(function(a, u) {
  var c = function(l) {
    Object.defineProperty(l, "__esModule", {
      value: !0
    }), l.default = void 0;
    /**
     * @license
     * Copyright 2009 The Closure Library Authors
     * Copyright 2020 Daniel Wirtz / The long.js Authors.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * SPDX-License-Identifier: Apache-2.0
     */
    var v = null;
    try {
      v = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
    } catch {
    }
    function p(A, x, Y) {
      this.low = A | 0, this.high = x | 0, this.unsigned = !!Y;
    }
    p.prototype.__isLong__, Object.defineProperty(p.prototype, "__isLong__", {
      value: !0
    });
    function _(A) {
      return (A && A.__isLong__) === !0;
    }
    function I(A) {
      var x = Math.clz32(A & -A);
      return A ? 31 - x : x;
    }
    p.isLong = _;
    var P = {}, $ = {};
    function F(A, x) {
      var Y, B, T;
      return x ? (A >>>= 0, (T = 0 <= A && A < 256) && (B = $[A], B) ? B : (Y = j(A, 0, !0), T && ($[A] = Y), Y)) : (A |= 0, (T = -128 <= A && A < 128) && (B = P[A], B) ? B : (Y = j(A, A < 0 ? -1 : 0, !1), T && (P[A] = Y), Y));
    }
    p.fromInt = F;
    function H(A, x) {
      if (isNaN(A))
        return x ? ke : be;
      if (x) {
        if (A < 0)
          return ke;
        if (A >= de)
          return b;
      } else {
        if (A <= -he)
          return E;
        if (A + 1 >= he)
          return C;
      }
      return A < 0 ? H(-A, x).neg() : j(A % Z | 0, A / Z | 0, x);
    }
    p.fromNumber = H;
    function j(A, x, Y) {
      return new p(A, x, Y);
    }
    p.fromBits = j;
    var ee = Math.pow;
    function X(A, x, Y) {
      if (A.length === 0)
        throw Error("empty string");
      if (typeof x == "number" ? (Y = x, x = !1) : x = !!x, A === "NaN" || A === "Infinity" || A === "+Infinity" || A === "-Infinity")
        return x ? ke : be;
      if (Y = Y || 10, Y < 2 || 36 < Y)
        throw RangeError("radix");
      var B;
      if ((B = A.indexOf("-")) > 0)
        throw Error("interior hyphen");
      if (B === 0)
        return X(A.substring(1), x, Y).neg();
      for (var T = H(ee(Y, 8)), D = be, te = 0; te < A.length; te += 8) {
        var me = Math.min(8, A.length - te), Ie = parseInt(A.substring(te, te + me), Y);
        if (me < 8) {
          var $e = H(ee(Y, me));
          D = D.mul($e).add(H(Ie));
        } else
          D = D.mul(T), D = D.add(H(Ie));
      }
      return D.unsigned = x, D;
    }
    p.fromString = X;
    function ie(A, x) {
      return typeof A == "number" ? H(A, x) : typeof A == "string" ? X(A, x) : j(A.low, A.high, typeof x == "boolean" ? x : A.unsigned);
    }
    p.fromValue = ie;
    var Q = 65536, ne = 1 << 24, Z = Q * Q, de = Z * Z, he = de / 2, pe = F(ne), be = F(0);
    p.ZERO = be;
    var ke = F(0, !0);
    p.UZERO = ke;
    var _e = F(1);
    p.ONE = _e;
    var q = F(1, !0);
    p.UONE = q;
    var z = F(-1);
    p.NEG_ONE = z;
    var C = j(-1, 2147483647, !1);
    p.MAX_VALUE = C;
    var b = j(-1, -1, !0);
    p.MAX_UNSIGNED_VALUE = b;
    var E = j(0, -2147483648, !1);
    p.MIN_VALUE = E;
    var k = p.prototype;
    k.toInt = function() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }, k.toNumber = function() {
      return this.unsigned ? (this.high >>> 0) * Z + (this.low >>> 0) : this.high * Z + (this.low >>> 0);
    }, k.toString = function(x) {
      if (x = x || 10, x < 2 || 36 < x)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative())
        if (this.eq(E)) {
          var Y = H(x), B = this.div(Y), T = B.mul(Y).sub(this);
          return B.toString(x) + T.toInt().toString(x);
        } else
          return "-" + this.neg().toString(x);
      for (var D = H(ee(x, 6), this.unsigned), te = this, me = ""; ; ) {
        var Ie = te.div(D), $e = te.sub(Ie.mul(D)).toInt() >>> 0, ye = $e.toString(x);
        if (te = Ie, te.isZero())
          return ye + me;
        for (; ye.length < 6; )
          ye = "0" + ye;
        me = "" + ye + me;
      }
    }, k.getHighBits = function() {
      return this.high;
    }, k.getHighBitsUnsigned = function() {
      return this.high >>> 0;
    }, k.getLowBits = function() {
      return this.low;
    }, k.getLowBitsUnsigned = function() {
      return this.low >>> 0;
    }, k.getNumBitsAbs = function() {
      if (this.isNegative())
        return this.eq(E) ? 64 : this.neg().getNumBitsAbs();
      for (var x = this.high != 0 ? this.high : this.low, Y = 31; Y > 0 && !(x & 1 << Y); Y--)
        ;
      return this.high != 0 ? Y + 33 : Y + 1;
    }, k.isZero = function() {
      return this.high === 0 && this.low === 0;
    }, k.eqz = k.isZero, k.isNegative = function() {
      return !this.unsigned && this.high < 0;
    }, k.isPositive = function() {
      return this.unsigned || this.high >= 0;
    }, k.isOdd = function() {
      return (this.low & 1) === 1;
    }, k.isEven = function() {
      return (this.low & 1) === 0;
    }, k.equals = function(x) {
      return _(x) || (x = ie(x)), this.unsigned !== x.unsigned && this.high >>> 31 === 1 && x.high >>> 31 === 1 ? !1 : this.high === x.high && this.low === x.low;
    }, k.eq = k.equals, k.notEquals = function(x) {
      return !this.eq(
        /* validates */
        x
      );
    }, k.neq = k.notEquals, k.ne = k.notEquals, k.lessThan = function(x) {
      return this.comp(
        /* validates */
        x
      ) < 0;
    }, k.lt = k.lessThan, k.lessThanOrEqual = function(x) {
      return this.comp(
        /* validates */
        x
      ) <= 0;
    }, k.lte = k.lessThanOrEqual, k.le = k.lessThanOrEqual, k.greaterThan = function(x) {
      return this.comp(
        /* validates */
        x
      ) > 0;
    }, k.gt = k.greaterThan, k.greaterThanOrEqual = function(x) {
      return this.comp(
        /* validates */
        x
      ) >= 0;
    }, k.gte = k.greaterThanOrEqual, k.ge = k.greaterThanOrEqual, k.compare = function(x) {
      if (_(x) || (x = ie(x)), this.eq(x))
        return 0;
      var Y = this.isNegative(), B = x.isNegative();
      return Y && !B ? -1 : !Y && B ? 1 : this.unsigned ? x.high >>> 0 > this.high >>> 0 || x.high === this.high && x.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(x).isNegative() ? -1 : 1;
    }, k.comp = k.compare, k.negate = function() {
      return !this.unsigned && this.eq(E) ? E : this.not().add(_e);
    }, k.neg = k.negate, k.add = function(x) {
      _(x) || (x = ie(x));
      var Y = this.high >>> 16, B = this.high & 65535, T = this.low >>> 16, D = this.low & 65535, te = x.high >>> 16, me = x.high & 65535, Ie = x.low >>> 16, $e = x.low & 65535, ye = 0, fe = 0, Me = 0, Ae = 0;
      return Ae += D + $e, Me += Ae >>> 16, Ae &= 65535, Me += T + Ie, fe += Me >>> 16, Me &= 65535, fe += B + me, ye += fe >>> 16, fe &= 65535, ye += Y + te, ye &= 65535, j(Me << 16 | Ae, ye << 16 | fe, this.unsigned);
    }, k.subtract = function(x) {
      return _(x) || (x = ie(x)), this.add(x.neg());
    }, k.sub = k.subtract, k.multiply = function(x) {
      if (this.isZero())
        return this;
      if (_(x) || (x = ie(x)), v) {
        var Y = v.mul(this.low, this.high, x.low, x.high);
        return j(Y, v.get_high(), this.unsigned);
      }
      if (x.isZero())
        return this.unsigned ? ke : be;
      if (this.eq(E))
        return x.isOdd() ? E : be;
      if (x.eq(E))
        return this.isOdd() ? E : be;
      if (this.isNegative())
        return x.isNegative() ? this.neg().mul(x.neg()) : this.neg().mul(x).neg();
      if (x.isNegative())
        return this.mul(x.neg()).neg();
      if (this.lt(pe) && x.lt(pe))
        return H(this.toNumber() * x.toNumber(), this.unsigned);
      var B = this.high >>> 16, T = this.high & 65535, D = this.low >>> 16, te = this.low & 65535, me = x.high >>> 16, Ie = x.high & 65535, $e = x.low >>> 16, ye = x.low & 65535, fe = 0, Me = 0, Ae = 0, xe = 0;
      return xe += te * ye, Ae += xe >>> 16, xe &= 65535, Ae += D * ye, Me += Ae >>> 16, Ae &= 65535, Ae += te * $e, Me += Ae >>> 16, Ae &= 65535, Me += T * ye, fe += Me >>> 16, Me &= 65535, Me += D * $e, fe += Me >>> 16, Me &= 65535, Me += te * Ie, fe += Me >>> 16, Me &= 65535, fe += B * ye + T * $e + D * Ie + te * me, fe &= 65535, j(Ae << 16 | xe, fe << 16 | Me, this.unsigned);
    }, k.mul = k.multiply, k.divide = function(x) {
      if (_(x) || (x = ie(x)), x.isZero())
        throw Error("division by zero");
      if (v) {
        if (!this.unsigned && this.high === -2147483648 && x.low === -1 && x.high === -1)
          return this;
        var Y = (this.unsigned ? v.div_u : v.div_s)(this.low, this.high, x.low, x.high);
        return j(Y, v.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? ke : be;
      var B, T, D;
      if (this.unsigned) {
        if (x.unsigned || (x = x.toUnsigned()), x.gt(this))
          return ke;
        if (x.gt(this.shru(1)))
          return q;
        D = ke;
      } else {
        if (this.eq(E)) {
          if (x.eq(_e) || x.eq(z))
            return E;
          if (x.eq(E))
            return _e;
          var te = this.shr(1);
          return B = te.div(x).shl(1), B.eq(be) ? x.isNegative() ? _e : z : (T = this.sub(x.mul(B)), D = B.add(T.div(x)), D);
        } else if (x.eq(E))
          return this.unsigned ? ke : be;
        if (this.isNegative())
          return x.isNegative() ? this.neg().div(x.neg()) : this.neg().div(x).neg();
        if (x.isNegative())
          return this.div(x.neg()).neg();
        D = be;
      }
      for (T = this; T.gte(x); ) {
        B = Math.max(1, Math.floor(T.toNumber() / x.toNumber()));
        for (var me = Math.ceil(Math.log(B) / Math.LN2), Ie = me <= 48 ? 1 : ee(2, me - 48), $e = H(B), ye = $e.mul(x); ye.isNegative() || ye.gt(T); )
          B -= Ie, $e = H(B, this.unsigned), ye = $e.mul(x);
        $e.isZero() && ($e = _e), D = D.add($e), T = T.sub(ye);
      }
      return D;
    }, k.div = k.divide, k.modulo = function(x) {
      if (_(x) || (x = ie(x)), v) {
        var Y = (this.unsigned ? v.rem_u : v.rem_s)(this.low, this.high, x.low, x.high);
        return j(Y, v.get_high(), this.unsigned);
      }
      return this.sub(this.div(x).mul(x));
    }, k.mod = k.modulo, k.rem = k.modulo, k.not = function() {
      return j(~this.low, ~this.high, this.unsigned);
    }, k.countLeadingZeros = function() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    }, k.clz = k.countLeadingZeros, k.countTrailingZeros = function() {
      return this.low ? I(this.low) : I(this.high) + 32;
    }, k.ctz = k.countTrailingZeros, k.and = function(x) {
      return _(x) || (x = ie(x)), j(this.low & x.low, this.high & x.high, this.unsigned);
    }, k.or = function(x) {
      return _(x) || (x = ie(x)), j(this.low | x.low, this.high | x.high, this.unsigned);
    }, k.xor = function(x) {
      return _(x) || (x = ie(x)), j(this.low ^ x.low, this.high ^ x.high, this.unsigned);
    }, k.shiftLeft = function(x) {
      return _(x) && (x = x.toInt()), (x &= 63) === 0 ? this : x < 32 ? j(this.low << x, this.high << x | this.low >>> 32 - x, this.unsigned) : j(0, this.low << x - 32, this.unsigned);
    }, k.shl = k.shiftLeft, k.shiftRight = function(x) {
      return _(x) && (x = x.toInt()), (x &= 63) === 0 ? this : x < 32 ? j(this.low >>> x | this.high << 32 - x, this.high >> x, this.unsigned) : j(this.high >> x - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }, k.shr = k.shiftRight, k.shiftRightUnsigned = function(x) {
      return _(x) && (x = x.toInt()), (x &= 63) === 0 ? this : x < 32 ? j(this.low >>> x | this.high << 32 - x, this.high >>> x, this.unsigned) : x === 32 ? j(this.high, 0, this.unsigned) : j(this.high >>> x - 32, 0, this.unsigned);
    }, k.shru = k.shiftRightUnsigned, k.shr_u = k.shiftRightUnsigned, k.rotateLeft = function(x) {
      var Y;
      return _(x) && (x = x.toInt()), (x &= 63) === 0 ? this : x === 32 ? j(this.high, this.low, this.unsigned) : x < 32 ? (Y = 32 - x, j(this.low << x | this.high >>> Y, this.high << x | this.low >>> Y, this.unsigned)) : (x -= 32, Y = 32 - x, j(this.high << x | this.low >>> Y, this.low << x | this.high >>> Y, this.unsigned));
    }, k.rotl = k.rotateLeft, k.rotateRight = function(x) {
      var Y;
      return _(x) && (x = x.toInt()), (x &= 63) === 0 ? this : x === 32 ? j(this.high, this.low, this.unsigned) : x < 32 ? (Y = 32 - x, j(this.high << Y | this.low >>> x, this.low << Y | this.high >>> x, this.unsigned)) : (x -= 32, Y = 32 - x, j(this.low << Y | this.high >>> x, this.high << Y | this.low >>> x, this.unsigned));
    }, k.rotr = k.rotateRight, k.toSigned = function() {
      return this.unsigned ? j(this.low, this.high, !1) : this;
    }, k.toUnsigned = function() {
      return this.unsigned ? this : j(this.low, this.high, !0);
    }, k.toBytes = function(x) {
      return x ? this.toBytesLE() : this.toBytesBE();
    }, k.toBytesLE = function() {
      var x = this.high, Y = this.low;
      return [Y & 255, Y >>> 8 & 255, Y >>> 16 & 255, Y >>> 24, x & 255, x >>> 8 & 255, x >>> 16 & 255, x >>> 24];
    }, k.toBytesBE = function() {
      var x = this.high, Y = this.low;
      return [x >>> 24, x >>> 16 & 255, x >>> 8 & 255, x & 255, Y >>> 24, Y >>> 16 & 255, Y >>> 8 & 255, Y & 255];
    }, p.fromBytes = function(x, Y, B) {
      return B ? p.fromBytesLE(x, Y) : p.fromBytesBE(x, Y);
    }, p.fromBytesLE = function(x, Y) {
      return new p(x[0] | x[1] << 8 | x[2] << 16 | x[3] << 24, x[4] | x[5] << 8 | x[6] << 16 | x[7] << 24, Y);
    }, p.fromBytesBE = function(x, Y) {
      return new p(x[4] << 24 | x[5] << 16 | x[6] << 8 | x[7], x[0] << 24 | x[1] << 16 | x[2] << 8 | x[3], Y);
    };
    var O = p;
    return l.default = O, "default" in l ? l.default : l;
  }({});
  a.exports = c;
})(umd);
var umdExports = umd.exports, indexMinimal = {}, minimal$1 = {}, aspromise = asPromise;
function asPromise(a, u) {
  for (var c = new Array(arguments.length - 1), l = 0, v = 2, p = !0; v < arguments.length; )
    c[l++] = arguments[v++];
  return new Promise(function(I, P) {
    c[l] = function(F) {
      if (p)
        if (p = !1, F)
          P(F);
        else {
          for (var H = new Array(arguments.length - 1), j = 0; j < H.length; )
            H[j++] = arguments[j];
          I.apply(null, H);
        }
    };
    try {
      a.apply(u || null, c);
    } catch ($) {
      p && (p = !1, P($));
    }
  });
}
var base64$1 = {};
(function(a) {
  var u = a;
  u.length = function(I) {
    var P = I.length;
    if (!P)
      return 0;
    for (var $ = 0; --P % 4 > 1 && I.charAt(P) === "="; )
      ++$;
    return Math.ceil(I.length * 3) / 4 - $;
  };
  for (var c = new Array(64), l = new Array(123), v = 0; v < 64; )
    l[c[v] = v < 26 ? v + 65 : v < 52 ? v + 71 : v < 62 ? v - 4 : v - 59 | 43] = v++;
  u.encode = function(I, P, $) {
    for (var F = null, H = [], j = 0, ee = 0, X; P < $; ) {
      var ie = I[P++];
      switch (ee) {
        case 0:
          H[j++] = c[ie >> 2], X = (ie & 3) << 4, ee = 1;
          break;
        case 1:
          H[j++] = c[X | ie >> 4], X = (ie & 15) << 2, ee = 2;
          break;
        case 2:
          H[j++] = c[X | ie >> 6], H[j++] = c[ie & 63], ee = 0;
          break;
      }
      j > 8191 && ((F || (F = [])).push(String.fromCharCode.apply(String, H)), j = 0);
    }
    return ee && (H[j++] = c[X], H[j++] = 61, ee === 1 && (H[j++] = 61)), F ? (j && F.push(String.fromCharCode.apply(String, H.slice(0, j))), F.join("")) : String.fromCharCode.apply(String, H.slice(0, j));
  };
  var p = "invalid encoding";
  u.decode = function(I, P, $) {
    for (var F = $, H = 0, j, ee = 0; ee < I.length; ) {
      var X = I.charCodeAt(ee++);
      if (X === 61 && H > 1)
        break;
      if ((X = l[X]) === void 0)
        throw Error(p);
      switch (H) {
        case 0:
          j = X, H = 1;
          break;
        case 1:
          P[$++] = j << 2 | (X & 48) >> 4, j = X, H = 2;
          break;
        case 2:
          P[$++] = (j & 15) << 4 | (X & 60) >> 2, j = X, H = 3;
          break;
        case 3:
          P[$++] = (j & 3) << 6 | X, H = 0;
          break;
      }
    }
    if (H === 1)
      throw Error(p);
    return $ - F;
  }, u.test = function(I) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(I);
  };
})(base64$1);
var eventemitter = EventEmitter$2;
function EventEmitter$2() {
  this._listeners = {};
}
EventEmitter$2.prototype.on = function(u, c, l) {
  return (this._listeners[u] || (this._listeners[u] = [])).push({
    fn: c,
    ctx: l || this
  }), this;
};
EventEmitter$2.prototype.off = function(u, c) {
  if (u === void 0)
    this._listeners = {};
  else if (c === void 0)
    this._listeners[u] = [];
  else
    for (var l = this._listeners[u], v = 0; v < l.length; )
      l[v].fn === c ? l.splice(v, 1) : ++v;
  return this;
};
EventEmitter$2.prototype.emit = function(u) {
  var c = this._listeners[u];
  if (c) {
    for (var l = [], v = 1; v < arguments.length; )
      l.push(arguments[v++]);
    for (v = 0; v < c.length; )
      c[v].fn.apply(c[v++].ctx, l);
  }
  return this;
};
var float = factory(factory);
function factory(a) {
  return typeof Float32Array < "u" ? function() {
    var u = new Float32Array([-0]), c = new Uint8Array(u.buffer), l = c[3] === 128;
    function v(P, $, F) {
      u[0] = P, $[F] = c[0], $[F + 1] = c[1], $[F + 2] = c[2], $[F + 3] = c[3];
    }
    function p(P, $, F) {
      u[0] = P, $[F] = c[3], $[F + 1] = c[2], $[F + 2] = c[1], $[F + 3] = c[0];
    }
    a.writeFloatLE = l ? v : p, a.writeFloatBE = l ? p : v;
    function _(P, $) {
      return c[0] = P[$], c[1] = P[$ + 1], c[2] = P[$ + 2], c[3] = P[$ + 3], u[0];
    }
    function I(P, $) {
      return c[3] = P[$], c[2] = P[$ + 1], c[1] = P[$ + 2], c[0] = P[$ + 3], u[0];
    }
    a.readFloatLE = l ? _ : I, a.readFloatBE = l ? I : _;
  }() : function() {
    function u(l, v, p, _) {
      var I = v < 0 ? 1 : 0;
      if (I && (v = -v), v === 0)
        l(1 / v > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), p, _);
      else if (isNaN(v))
        l(2143289344, p, _);
      else if (v > 34028234663852886e22)
        l((I << 31 | 2139095040) >>> 0, p, _);
      else if (v < 11754943508222875e-54)
        l((I << 31 | Math.round(v / 1401298464324817e-60)) >>> 0, p, _);
      else {
        var P = Math.floor(Math.log(v) / Math.LN2), $ = Math.round(v * Math.pow(2, -P) * 8388608) & 8388607;
        l((I << 31 | P + 127 << 23 | $) >>> 0, p, _);
      }
    }
    a.writeFloatLE = u.bind(null, writeUintLE), a.writeFloatBE = u.bind(null, writeUintBE);
    function c(l, v, p) {
      var _ = l(v, p), I = (_ >> 31) * 2 + 1, P = _ >>> 23 & 255, $ = _ & 8388607;
      return P === 255 ? $ ? NaN : I * (1 / 0) : P === 0 ? I * 1401298464324817e-60 * $ : I * Math.pow(2, P - 150) * ($ + 8388608);
    }
    a.readFloatLE = c.bind(null, readUintLE), a.readFloatBE = c.bind(null, readUintBE);
  }(), typeof Float64Array < "u" ? function() {
    var u = new Float64Array([-0]), c = new Uint8Array(u.buffer), l = c[7] === 128;
    function v(P, $, F) {
      u[0] = P, $[F] = c[0], $[F + 1] = c[1], $[F + 2] = c[2], $[F + 3] = c[3], $[F + 4] = c[4], $[F + 5] = c[5], $[F + 6] = c[6], $[F + 7] = c[7];
    }
    function p(P, $, F) {
      u[0] = P, $[F] = c[7], $[F + 1] = c[6], $[F + 2] = c[5], $[F + 3] = c[4], $[F + 4] = c[3], $[F + 5] = c[2], $[F + 6] = c[1], $[F + 7] = c[0];
    }
    a.writeDoubleLE = l ? v : p, a.writeDoubleBE = l ? p : v;
    function _(P, $) {
      return c[0] = P[$], c[1] = P[$ + 1], c[2] = P[$ + 2], c[3] = P[$ + 3], c[4] = P[$ + 4], c[5] = P[$ + 5], c[6] = P[$ + 6], c[7] = P[$ + 7], u[0];
    }
    function I(P, $) {
      return c[7] = P[$], c[6] = P[$ + 1], c[5] = P[$ + 2], c[4] = P[$ + 3], c[3] = P[$ + 4], c[2] = P[$ + 5], c[1] = P[$ + 6], c[0] = P[$ + 7], u[0];
    }
    a.readDoubleLE = l ? _ : I, a.readDoubleBE = l ? I : _;
  }() : function() {
    function u(l, v, p, _, I, P) {
      var $ = _ < 0 ? 1 : 0;
      if ($ && (_ = -_), _ === 0)
        l(0, I, P + v), l(1 / _ > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), I, P + p);
      else if (isNaN(_))
        l(0, I, P + v), l(2146959360, I, P + p);
      else if (_ > 17976931348623157e292)
        l(0, I, P + v), l(($ << 31 | 2146435072) >>> 0, I, P + p);
      else {
        var F;
        if (_ < 22250738585072014e-324)
          F = _ / 5e-324, l(F >>> 0, I, P + v), l(($ << 31 | F / 4294967296) >>> 0, I, P + p);
        else {
          var H = Math.floor(Math.log(_) / Math.LN2);
          H === 1024 && (H = 1023), F = _ * Math.pow(2, -H), l(F * 4503599627370496 >>> 0, I, P + v), l(($ << 31 | H + 1023 << 20 | F * 1048576 & 1048575) >>> 0, I, P + p);
        }
      }
    }
    a.writeDoubleLE = u.bind(null, writeUintLE, 0, 4), a.writeDoubleBE = u.bind(null, writeUintBE, 4, 0);
    function c(l, v, p, _, I) {
      var P = l(_, I + v), $ = l(_, I + p), F = ($ >> 31) * 2 + 1, H = $ >>> 20 & 2047, j = 4294967296 * ($ & 1048575) + P;
      return H === 2047 ? j ? NaN : F * (1 / 0) : H === 0 ? F * 5e-324 * j : F * Math.pow(2, H - 1075) * (j + 4503599627370496);
    }
    a.readDoubleLE = c.bind(null, readUintLE, 0, 4), a.readDoubleBE = c.bind(null, readUintBE, 4, 0);
  }(), a;
}
function writeUintLE(a, u, c) {
  u[c] = a & 255, u[c + 1] = a >>> 8 & 255, u[c + 2] = a >>> 16 & 255, u[c + 3] = a >>> 24;
}
function writeUintBE(a, u, c) {
  u[c] = a >>> 24, u[c + 1] = a >>> 16 & 255, u[c + 2] = a >>> 8 & 255, u[c + 3] = a & 255;
}
function readUintLE(a, u) {
  return (a[u] | a[u + 1] << 8 | a[u + 2] << 16 | a[u + 3] << 24) >>> 0;
}
function readUintBE(a, u) {
  return (a[u] << 24 | a[u + 1] << 16 | a[u + 2] << 8 | a[u + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (a) {
  }
  return null;
}
var utf8$2 = {};
(function(a) {
  var u = a;
  u.length = function(l) {
    for (var v = 0, p = 0, _ = 0; _ < l.length; ++_)
      p = l.charCodeAt(_), p < 128 ? v += 1 : p < 2048 ? v += 2 : (p & 64512) === 55296 && (l.charCodeAt(_ + 1) & 64512) === 56320 ? (++_, v += 4) : v += 3;
    return v;
  }, u.read = function(l, v, p) {
    var _ = p - v;
    if (_ < 1)
      return "";
    for (var I = null, P = [], $ = 0, F; v < p; )
      F = l[v++], F < 128 ? P[$++] = F : F > 191 && F < 224 ? P[$++] = (F & 31) << 6 | l[v++] & 63 : F > 239 && F < 365 ? (F = ((F & 7) << 18 | (l[v++] & 63) << 12 | (l[v++] & 63) << 6 | l[v++] & 63) - 65536, P[$++] = 55296 + (F >> 10), P[$++] = 56320 + (F & 1023)) : P[$++] = (F & 15) << 12 | (l[v++] & 63) << 6 | l[v++] & 63, $ > 8191 && ((I || (I = [])).push(String.fromCharCode.apply(String, P)), $ = 0);
    return I ? ($ && I.push(String.fromCharCode.apply(String, P.slice(0, $))), I.join("")) : String.fromCharCode.apply(String, P.slice(0, $));
  }, u.write = function(l, v, p) {
    for (var _ = p, I, P, $ = 0; $ < l.length; ++$)
      I = l.charCodeAt($), I < 128 ? v[p++] = I : I < 2048 ? (v[p++] = I >> 6 | 192, v[p++] = I & 63 | 128) : (I & 64512) === 55296 && ((P = l.charCodeAt($ + 1)) & 64512) === 56320 ? (I = 65536 + ((I & 1023) << 10) + (P & 1023), ++$, v[p++] = I >> 18 | 240, v[p++] = I >> 12 & 63 | 128, v[p++] = I >> 6 & 63 | 128, v[p++] = I & 63 | 128) : (v[p++] = I >> 12 | 224, v[p++] = I >> 6 & 63 | 128, v[p++] = I & 63 | 128);
    return p - _;
  };
})(utf8$2);
var pool_1 = pool;
function pool(a, u, c) {
  var l = c || 8192, v = l >>> 1, p = null, _ = l;
  return function(P) {
    if (P < 1 || P > v)
      return a(P);
    _ + P > l && (p = a(l), _ = 0);
    var $ = u.call(p, _, _ += P);
    return _ & 7 && (_ = (_ | 7) + 1), $;
  };
}
var longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1, longbits = u;
  var a = requireMinimal();
  function u(p, _) {
    this.lo = p >>> 0, this.hi = _ >>> 0;
  }
  var c = u.zero = new u(0, 0);
  c.toNumber = function() {
    return 0;
  }, c.zzEncode = c.zzDecode = function() {
    return this;
  }, c.length = function() {
    return 1;
  };
  var l = u.zeroHash = "\0\0\0\0\0\0\0\0";
  u.fromNumber = function(_) {
    if (_ === 0)
      return c;
    var I = _ < 0;
    I && (_ = -_);
    var P = _ >>> 0, $ = (_ - P) / 4294967296 >>> 0;
    return I && ($ = ~$ >>> 0, P = ~P >>> 0, ++P > 4294967295 && (P = 0, ++$ > 4294967295 && ($ = 0))), new u(P, $);
  }, u.from = function(_) {
    if (typeof _ == "number")
      return u.fromNumber(_);
    if (a.isString(_))
      if (a.Long)
        _ = a.Long.fromString(_);
      else
        return u.fromNumber(parseInt(_, 10));
    return _.low || _.high ? new u(_.low >>> 0, _.high >>> 0) : c;
  }, u.prototype.toNumber = function(_) {
    if (!_ && this.hi >>> 31) {
      var I = ~this.lo + 1 >>> 0, P = ~this.hi >>> 0;
      return I || (P = P + 1 >>> 0), -(I + P * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, u.prototype.toLong = function(_) {
    return a.Long ? new a.Long(this.lo | 0, this.hi | 0, !!_) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!_ };
  };
  var v = String.prototype.charCodeAt;
  return u.fromHash = function(_) {
    return _ === l ? c : new u(
      (v.call(_, 0) | v.call(_, 1) << 8 | v.call(_, 2) << 16 | v.call(_, 3) << 24) >>> 0,
      (v.call(_, 4) | v.call(_, 5) << 8 | v.call(_, 6) << 16 | v.call(_, 7) << 24) >>> 0
    );
  }, u.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, u.prototype.zzEncode = function() {
    var _ = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ _) >>> 0, this.lo = (this.lo << 1 ^ _) >>> 0, this;
  }, u.prototype.zzDecode = function() {
    var _ = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ _) >>> 0, this.hi = (this.hi >>> 1 ^ _) >>> 0, this;
  }, u.prototype.length = function() {
    var _ = this.lo, I = (this.lo >>> 28 | this.hi << 4) >>> 0, P = this.hi >>> 24;
    return P === 0 ? I === 0 ? _ < 16384 ? _ < 128 ? 1 : 2 : _ < 2097152 ? 3 : 4 : I < 16384 ? I < 128 ? 5 : 6 : I < 2097152 ? 7 : 8 : P < 128 ? 9 : 10;
  }, longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, function(a) {
    var u = a;
    u.asPromise = aspromise, u.base64 = base64$1, u.EventEmitter = eventemitter, u.float = float, u.inquire = inquire_1, u.utf8 = utf8$2, u.pool = pool_1, u.LongBits = requireLongbits(), u.isNode = !!(typeof commonjsGlobal$1 < "u" && commonjsGlobal$1 && commonjsGlobal$1.process && commonjsGlobal$1.process.versions && commonjsGlobal$1.process.versions.node), u.global = u.isNode && commonjsGlobal$1 || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal$1, u.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), u.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), u.isInteger = Number.isInteger || /* istanbul ignore next */
    function(p) {
      return typeof p == "number" && isFinite(p) && Math.floor(p) === p;
    }, u.isString = function(p) {
      return typeof p == "string" || p instanceof String;
    }, u.isObject = function(p) {
      return p && typeof p == "object";
    }, u.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    u.isSet = function(p, _) {
      var I = p[_];
      return I != null && p.hasOwnProperty(_) ? typeof I != "object" || (Array.isArray(I) ? I.length : Object.keys(I).length) > 0 : !1;
    }, u.Buffer = function() {
      try {
        var v = u.inquire("buffer").Buffer;
        return v.prototype.utf8Write ? v : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), u._Buffer_from = null, u._Buffer_allocUnsafe = null, u.newBuffer = function(p) {
      return typeof p == "number" ? u.Buffer ? u._Buffer_allocUnsafe(p) : new u.Array(p) : u.Buffer ? u._Buffer_from(p) : typeof Uint8Array > "u" ? p : new Uint8Array(p);
    }, u.Array = typeof Uint8Array < "u" ? Uint8Array : Array, u.Long = /* istanbul ignore next */
    u.global.dcodeIO && /* istanbul ignore next */
    u.global.dcodeIO.Long || /* istanbul ignore next */
    u.global.Long || u.inquire("long"), u.key2Re = /^true|false|0|1$/, u.key32Re = /^-?(?:0|[1-9][0-9]*)$/, u.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, u.longToHash = function(p) {
      return p ? u.LongBits.from(p).toHash() : u.LongBits.zeroHash;
    }, u.longFromHash = function(p, _) {
      var I = u.LongBits.fromHash(p);
      return u.Long ? u.Long.fromBits(I.lo, I.hi, _) : I.toNumber(!!_);
    };
    function c(v, p, _) {
      for (var I = Object.keys(p), P = 0; P < I.length; ++P)
        (v[I[P]] === void 0 || !_) && (v[I[P]] = p[I[P]]);
      return v;
    }
    u.merge = c, u.lcFirst = function(p) {
      return p.charAt(0).toLowerCase() + p.substring(1);
    };
    function l(v) {
      function p(_, I) {
        if (!(this instanceof p))
          return new p(_, I);
        Object.defineProperty(this, "message", { get: function() {
          return _;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, p) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), I && c(this, I);
      }
      return (p.prototype = Object.create(Error.prototype)).constructor = p, Object.defineProperty(p.prototype, "name", { get: function() {
        return v;
      } }), p.prototype.toString = function() {
        return this.name + ": " + this.message;
      }, p;
    }
    u.newError = l, u.ProtocolError = l("ProtocolError"), u.oneOfGetter = function(p) {
      for (var _ = {}, I = 0; I < p.length; ++I)
        _[p[I]] = 1;
      return function() {
        for (var P = Object.keys(this), $ = P.length - 1; $ > -1; --$)
          if (_[P[$]] === 1 && this[P[$]] !== void 0 && this[P[$]] !== null)
            return P[$];
      };
    }, u.oneOfSetter = function(p) {
      return function(_) {
        for (var I = 0; I < p.length; ++I)
          p[I] !== _ && delete this[p[I]];
      };
    }, u.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, u._configure = function() {
      var v = u.Buffer;
      if (!v) {
        u._Buffer_from = u._Buffer_allocUnsafe = null;
        return;
      }
      u._Buffer_from = v.from !== Uint8Array.from && v.from || /* istanbul ignore next */
      function(_, I) {
        return new v(_, I);
      }, u._Buffer_allocUnsafe = v.allocUnsafe || /* istanbul ignore next */
      function(_) {
        return new v(_);
      };
    };
  }(minimal$1)), minimal$1;
}
var writer$2 = Writer$1, util$9 = requireMinimal(), BufferWriter$1, LongBits$1 = util$9.LongBits, base64 = util$9.base64, utf8$1 = util$9.utf8;
function Op(a, u, c) {
  this.fn = a, this.len = u, this.next = void 0, this.val = c;
}
function noop$7() {
}
function State(a) {
  this.head = a.head, this.tail = a.tail, this.len = a.len, this.next = a.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop$7, 0, 0), this.tail = this.head, this.states = null;
}
var create$3 = function a() {
  return util$9.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
Writer$1.create = create$3();
Writer$1.alloc = function a(u) {
  return new util$9.Array(u);
};
util$9.Array !== Array && (Writer$1.alloc = util$9.pool(Writer$1.alloc, util$9.Array.prototype.subarray));
Writer$1.prototype._push = function a(u, c, l) {
  return this.tail = this.tail.next = new Op(u, c, l), this.len += c, this;
};
function writeByte(a, u, c) {
  u[c] = a & 255;
}
function writeVarint32(a, u, c) {
  for (; a > 127; )
    u[c++] = a & 127 | 128, a >>>= 7;
  u[c] = a;
}
function VarintOp(a, u) {
  this.len = a, this.next = void 0, this.val = u;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function a(u) {
  return this.len += (this.tail = this.tail.next = new VarintOp(
    (u = u >>> 0) < 128 ? 1 : u < 16384 ? 2 : u < 2097152 ? 3 : u < 268435456 ? 4 : 5,
    u
  )).len, this;
};
Writer$1.prototype.int32 = function a(u) {
  return u < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(u)) : this.uint32(u);
};
Writer$1.prototype.sint32 = function a(u) {
  return this.uint32((u << 1 ^ u >> 31) >>> 0);
};
function writeVarint64(a, u, c) {
  for (; a.hi; )
    u[c++] = a.lo & 127 | 128, a.lo = (a.lo >>> 7 | a.hi << 25) >>> 0, a.hi >>>= 7;
  for (; a.lo > 127; )
    u[c++] = a.lo & 127 | 128, a.lo = a.lo >>> 7;
  u[c++] = a.lo;
}
Writer$1.prototype.uint64 = function a(u) {
  var c = LongBits$1.from(u);
  return this._push(writeVarint64, c.length(), c);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function a(u) {
  var c = LongBits$1.from(u).zzEncode();
  return this._push(writeVarint64, c.length(), c);
};
Writer$1.prototype.bool = function a(u) {
  return this._push(writeByte, 1, u ? 1 : 0);
};
function writeFixed32(a, u, c) {
  u[c] = a & 255, u[c + 1] = a >>> 8 & 255, u[c + 2] = a >>> 16 & 255, u[c + 3] = a >>> 24;
}
Writer$1.prototype.fixed32 = function a(u) {
  return this._push(writeFixed32, 4, u >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function a(u) {
  var c = LongBits$1.from(u);
  return this._push(writeFixed32, 4, c.lo)._push(writeFixed32, 4, c.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function a(u) {
  return this._push(util$9.float.writeFloatLE, 4, u);
};
Writer$1.prototype.double = function a(u) {
  return this._push(util$9.float.writeDoubleLE, 8, u);
};
var writeBytes = util$9.Array.prototype.set ? function a(u, c, l) {
  c.set(u, l);
} : function a(u, c, l) {
  for (var v = 0; v < u.length; ++v)
    c[l + v] = u[v];
};
Writer$1.prototype.bytes = function a(u) {
  var c = u.length >>> 0;
  if (!c)
    return this._push(writeByte, 1, 0);
  if (util$9.isString(u)) {
    var l = Writer$1.alloc(c = base64.length(u));
    base64.decode(u, l, 0), u = l;
  }
  return this.uint32(c)._push(writeBytes, c, u);
};
Writer$1.prototype.string = function a(u) {
  var c = utf8$1.length(u);
  return c ? this.uint32(c)._push(utf8$1.write, c, u) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function a() {
  return this.states = new State(this), this.head = this.tail = new Op(noop$7, 0, 0), this.len = 0, this;
};
Writer$1.prototype.reset = function a() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop$7, 0, 0), this.len = 0), this;
};
Writer$1.prototype.ldelim = function a() {
  var u = this.head, c = this.tail, l = this.len;
  return this.reset().uint32(l), l && (this.tail.next = u.next, this.tail = c, this.len += l), this;
};
Writer$1.prototype.finish = function a() {
  for (var u = this.head.next, c = this.constructor.alloc(this.len), l = 0; u; )
    u.fn(u.val, c, l), l += u.len, u = u.next;
  return c;
};
Writer$1._configure = function(a) {
  BufferWriter$1 = a, Writer$1.create = create$3(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter, Writer = writer$2;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$8 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$8._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$8.Buffer && util$8.Buffer.prototype instanceof Uint8Array && util$8.Buffer.prototype.set.name === "set" ? function(u, c, l) {
    c.set(u, l);
  } : function(u, c, l) {
    if (u.copy)
      u.copy(c, l, 0, u.length);
    else
      for (var v = 0; v < u.length; )
        c[l++] = u[v++];
  };
};
BufferWriter.prototype.bytes = function a(u) {
  util$8.isString(u) && (u = util$8._Buffer_from(u, "base64"));
  var c = u.length >>> 0;
  return this.uint32(c), c && this._push(BufferWriter.writeBytesBuffer, c, u), this;
};
function writeStringBuffer(a, u, c) {
  a.length < 40 ? util$8.utf8.write(a, u, c) : u.utf8Write ? u.utf8Write(a, c) : u.write(a, c);
}
BufferWriter.prototype.string = function a(u) {
  var c = util$8.Buffer.byteLength(u);
  return this.uint32(c), c && this._push(writeStringBuffer, c, u), this;
};
BufferWriter._configure();
var reader = Reader$1, util$7 = requireMinimal(), BufferReader$1, LongBits = util$7.LongBits, utf8 = util$7.utf8;
function indexOutOfRange(a, u) {
  return RangeError("index out of range: " + a.pos + " + " + (u || 1) + " > " + a.len);
}
function Reader$1(a) {
  this.buf = a, this.pos = 0, this.len = a.length;
}
var create_array = typeof Uint8Array < "u" ? function a(u) {
  if (u instanceof Uint8Array || Array.isArray(u))
    return new Reader$1(u);
  throw Error("illegal buffer");
} : function a(u) {
  if (Array.isArray(u))
    return new Reader$1(u);
  throw Error("illegal buffer");
}, create$2 = function a() {
  return util$7.Buffer ? function(c) {
    return (Reader$1.create = function(v) {
      return util$7.Buffer.isBuffer(v) ? new BufferReader$1(v) : create_array(v);
    })(c);
  } : create_array;
};
Reader$1.create = create$2();
Reader$1.prototype._slice = util$7.Array.prototype.subarray || /* istanbul ignore next */
util$7.Array.prototype.slice;
Reader$1.prototype.uint32 = /* @__PURE__ */ function a() {
  var u = 4294967295;
  return function() {
    if (u = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (u = (u | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
      return u;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, indexOutOfRange(this, 10);
    return u;
  };
}();
Reader$1.prototype.int32 = function a() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function a() {
  var u = this.uint32();
  return u >>> 1 ^ -(u & 1) | 0;
};
function readLongVarint() {
  var a = new LongBits(0, 0), u = 0;
  if (this.len - this.pos > 4) {
    for (; u < 4; ++u)
      if (a.lo = (a.lo | (this.buf[this.pos] & 127) << u * 7) >>> 0, this.buf[this.pos++] < 128)
        return a;
    if (a.lo = (a.lo | (this.buf[this.pos] & 127) << 28) >>> 0, a.hi = (a.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return a;
    u = 0;
  } else {
    for (; u < 3; ++u) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (a.lo = (a.lo | (this.buf[this.pos] & 127) << u * 7) >>> 0, this.buf[this.pos++] < 128)
        return a;
    }
    return a.lo = (a.lo | (this.buf[this.pos++] & 127) << u * 7) >>> 0, a;
  }
  if (this.len - this.pos > 4) {
    for (; u < 5; ++u)
      if (a.hi = (a.hi | (this.buf[this.pos] & 127) << u * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return a;
  } else
    for (; u < 5; ++u) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (a.hi = (a.hi | (this.buf[this.pos] & 127) << u * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return a;
    }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function a() {
  return this.uint32() !== 0;
};
function readFixed32_end(a, u) {
  return (a[u - 4] | a[u - 3] << 8 | a[u - 2] << 16 | a[u - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var u = util$7.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, u;
};
Reader$1.prototype.double = function a() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var u = util$7.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, u;
};
Reader$1.prototype.bytes = function a() {
  var u = this.uint32(), c = this.pos, l = this.pos + u;
  if (l > this.len)
    throw indexOutOfRange(this, u);
  return this.pos += u, Array.isArray(this.buf) ? this.buf.slice(c, l) : c === l ? new this.buf.constructor(0) : this._slice.call(this.buf, c, l);
};
Reader$1.prototype.string = function a() {
  var u = this.bytes();
  return utf8.read(u, 0, u.length);
};
Reader$1.prototype.skip = function a(u) {
  if (typeof u == "number") {
    if (this.pos + u > this.len)
      throw indexOutOfRange(this, u);
    this.pos += u;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Reader$1.prototype.skipType = function(a) {
  switch (a) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (a = this.uint32() & 7) !== 4; )
        this.skipType(a);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + a + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(a) {
  BufferReader$1 = a, Reader$1.create = create$2(), BufferReader$1._configure();
  var u = util$7.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$7.merge(Reader$1.prototype, {
    int64: function() {
      return readLongVarint.call(this)[u](!1);
    },
    uint64: function() {
      return readLongVarint.call(this)[u](!0);
    },
    sint64: function() {
      return readLongVarint.call(this).zzDecode()[u](!1);
    },
    fixed64: function() {
      return readFixed64.call(this)[u](!0);
    },
    sfixed64: function() {
      return readFixed64.call(this)[u](!1);
    }
  });
};
var reader_buffer = BufferReader, Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$6 = requireMinimal();
function BufferReader(a) {
  Reader.call(this, a);
}
BufferReader._configure = function() {
  util$6.Buffer && (BufferReader.prototype._slice = util$6.Buffer.prototype.slice);
};
BufferReader.prototype.string = function a() {
  var u = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + u, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + u, this.len));
};
BufferReader._configure();
var rpc = {}, service = Service, util$5 = requireMinimal();
(Service.prototype = Object.create(util$5.EventEmitter.prototype)).constructor = Service;
function Service(a, u, c) {
  if (typeof a != "function")
    throw TypeError("rpcImpl must be a function");
  util$5.EventEmitter.call(this), this.rpcImpl = a, this.requestDelimited = !!u, this.responseDelimited = !!c;
}
Service.prototype.rpcCall = function a(u, c, l, v, p) {
  if (!v)
    throw TypeError("request must be specified");
  var _ = this;
  if (!p)
    return util$5.asPromise(a, _, u, c, l, v);
  if (!_.rpcImpl) {
    setTimeout(function() {
      p(Error("already ended"));
    }, 0);
    return;
  }
  try {
    return _.rpcImpl(
      u,
      c[_.requestDelimited ? "encodeDelimited" : "encode"](v).finish(),
      function(P, $) {
        if (P)
          return _.emit("error", P, u), p(P);
        if ($ === null) {
          _.end(
            /* endedByRPC */
            !0
          );
          return;
        }
        if (!($ instanceof l))
          try {
            $ = l[_.responseDelimited ? "decodeDelimited" : "decode"]($);
          } catch (F) {
            return _.emit("error", F, u), p(F);
          }
        return _.emit("data", $, u), p(null, $);
      }
    );
  } catch (I) {
    _.emit("error", I, u), setTimeout(function() {
      p(I);
    }, 0);
    return;
  }
};
Service.prototype.end = function a(u) {
  return this.rpcImpl && (u || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
};
(function(a) {
  var u = a;
  u.Service = service;
})(rpc);
var roots = {};
(function(a) {
  var u = a;
  u.build = "minimal", u.Writer = writer$2, u.BufferWriter = writer_buffer, u.Reader = reader, u.BufferReader = reader_buffer, u.util = requireMinimal(), u.rpc = rpc, u.roots = roots, u.configure = c;
  function c() {
    u.util._configure(), u.Writer._configure(u.BufferWriter), u.Reader._configure(u.BufferReader);
  }
  c();
})(indexMinimal);
var minimal = indexMinimal, struct$2 = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(Z, de, he, pe) {
    pe === void 0 && (pe = he), Object.defineProperty(Z, pe, { enumerable: !0, get: function() {
      return de[he];
    } });
  } : function(Z, de, he, pe) {
    pe === void 0 && (pe = he), Z[pe] = de[he];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(Z, de) {
    Object.defineProperty(Z, "default", { enumerable: !0, value: de });
  } : function(Z, de) {
    Z.default = de;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(Z) {
    if (Z && Z.__esModule)
      return Z;
    var de = {};
    if (Z != null)
      for (var he in Z)
        he !== "default" && Object.hasOwnProperty.call(Z, he) && u(de, Z, he);
    return c(de, Z), de;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(Z) {
    return Z && Z.__esModule ? Z : { default: Z };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal);
  a.protobufPackage = "google.protobuf";
  var I;
  (function(Z) {
    Z.NULL_VALUE = "NULL_VALUE";
  })(I = a.NullValue || (a.NullValue = {}));
  function P(Z) {
    switch (Z) {
      case 0:
      case "NULL_VALUE":
        return I.NULL_VALUE;
      default:
        throw new ie.Error("Unrecognized enum value " + Z + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = P;
  function $(Z) {
    switch (Z) {
      case I.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  a.nullValueToJSON = $;
  function F(Z) {
    switch (Z) {
      case I.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  a.nullValueToNumber = F;
  function H() {
    return { fields: {} };
  }
  a.Struct = {
    encode(Z, de = _.Writer.create()) {
      return Object.entries(Z.fields).forEach(([he, pe]) => {
        pe !== void 0 && a.Struct_FieldsEntry.encode({ key: he, value: pe }, de.uint32(10).fork()).ldelim();
      }), de;
    },
    decode(Z, de) {
      const he = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let pe = de === void 0 ? he.len : he.pos + de;
      const be = H();
      for (; he.pos < pe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            const _e = a.Struct_FieldsEntry.decode(he, he.uint32());
            _e.value !== void 0 && (be.fields[_e.key] = _e.value);
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(Z) {
      return {
        fields: Q(Z.fields) ? Object.entries(Z.fields).reduce((de, [he, pe]) => (de[he] = pe, de), {}) : {}
      };
    },
    toJSON(Z) {
      const de = {};
      return de.fields = {}, Z.fields && Object.entries(Z.fields).forEach(([he, pe]) => {
        de.fields[he] = pe;
      }), de;
    },
    fromPartial(Z) {
      var de;
      const he = H();
      return he.fields = Object.entries((de = Z.fields) !== null && de !== void 0 ? de : {}).reduce((pe, [be, ke]) => (ke !== void 0 && (pe[be] = ke), pe), {}), he;
    },
    wrap(Z) {
      const de = H();
      return Z !== void 0 && Object.keys(Z).forEach((he) => {
        de.fields[he] = Z[he];
      }), de;
    },
    unwrap(Z) {
      const de = {};
      return Object.keys(Z.fields).forEach((he) => {
        de[he] = Z.fields[he];
      }), de;
    }
  };
  function j() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(Z, de = _.Writer.create()) {
      return Z.key !== "" && de.uint32(10).string(Z.key), Z.value !== void 0 && a.Value.encode(a.Value.wrap(Z.value), de.uint32(18).fork()).ldelim(), de;
    },
    decode(Z, de) {
      const he = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let pe = de === void 0 ? he.len : he.pos + de;
      const be = j();
      for (; he.pos < pe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            be.key = he.string();
            break;
          case 2:
            be.value = a.Value.unwrap(a.Value.decode(he, he.uint32()));
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(Z) {
      return {
        key: ne(Z.key) ? String(Z.key) : "",
        value: ne(Z == null ? void 0 : Z.value) ? Z.value : void 0
      };
    },
    toJSON(Z) {
      const de = {};
      return Z.key !== void 0 && (de.key = Z.key), Z.value !== void 0 && (de.value = Z.value), de;
    },
    fromPartial(Z) {
      var de, he;
      const pe = j();
      return pe.key = (de = Z.key) !== null && de !== void 0 ? de : "", pe.value = (he = Z.value) !== null && he !== void 0 ? he : void 0, pe;
    }
  };
  function ee() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(Z, de = _.Writer.create()) {
      return Z.nullValue !== void 0 && de.uint32(8).int32(F(Z.nullValue)), Z.numberValue !== void 0 && de.uint32(17).double(Z.numberValue), Z.stringValue !== void 0 && de.uint32(26).string(Z.stringValue), Z.boolValue !== void 0 && de.uint32(32).bool(Z.boolValue), Z.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(Z.structValue), de.uint32(42).fork()).ldelim(), Z.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(Z.listValue), de.uint32(50).fork()).ldelim(), de;
    },
    decode(Z, de) {
      const he = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let pe = de === void 0 ? he.len : he.pos + de;
      const be = ee();
      for (; he.pos < pe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            be.nullValue = P(he.int32());
            break;
          case 2:
            be.numberValue = he.double();
            break;
          case 3:
            be.stringValue = he.string();
            break;
          case 4:
            be.boolValue = he.bool();
            break;
          case 5:
            be.structValue = a.Struct.unwrap(a.Struct.decode(he, he.uint32()));
            break;
          case 6:
            be.listValue = a.ListValue.unwrap(a.ListValue.decode(he, he.uint32()));
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(Z) {
      return {
        nullValue: ne(Z.nullValue) ? P(Z.nullValue) : void 0,
        numberValue: ne(Z.numberValue) ? Number(Z.numberValue) : void 0,
        stringValue: ne(Z.stringValue) ? String(Z.stringValue) : void 0,
        boolValue: ne(Z.boolValue) ? !!Z.boolValue : void 0,
        structValue: Q(Z.structValue) ? Z.structValue : void 0,
        listValue: Array.isArray(Z.listValue) ? [...Z.listValue] : void 0
      };
    },
    toJSON(Z) {
      const de = {};
      return Z.nullValue !== void 0 && (de.nullValue = Z.nullValue !== void 0 ? $(Z.nullValue) : void 0), Z.numberValue !== void 0 && (de.numberValue = Z.numberValue), Z.stringValue !== void 0 && (de.stringValue = Z.stringValue), Z.boolValue !== void 0 && (de.boolValue = Z.boolValue), Z.structValue !== void 0 && (de.structValue = Z.structValue), Z.listValue !== void 0 && (de.listValue = Z.listValue), de;
    },
    fromPartial(Z) {
      var de, he, pe, be, ke, _e;
      const q = ee();
      return q.nullValue = (de = Z.nullValue) !== null && de !== void 0 ? de : void 0, q.numberValue = (he = Z.numberValue) !== null && he !== void 0 ? he : void 0, q.stringValue = (pe = Z.stringValue) !== null && pe !== void 0 ? pe : void 0, q.boolValue = (be = Z.boolValue) !== null && be !== void 0 ? be : void 0, q.structValue = (ke = Z.structValue) !== null && ke !== void 0 ? ke : void 0, q.listValue = (_e = Z.listValue) !== null && _e !== void 0 ? _e : void 0, q;
    },
    wrap(Z) {
      const de = ee();
      if (Z === null)
        de.nullValue = I.NULL_VALUE;
      else if (typeof Z == "boolean")
        de.boolValue = Z;
      else if (typeof Z == "number")
        de.numberValue = Z;
      else if (typeof Z == "string")
        de.stringValue = Z;
      else if (Array.isArray(Z))
        de.listValue = Z;
      else if (typeof Z == "object")
        de.structValue = Z;
      else if (typeof Z < "u")
        throw new Error("Unsupported any value type: " + typeof Z);
      return de;
    },
    unwrap(Z) {
      if ((Z == null ? void 0 : Z.stringValue) !== void 0)
        return Z.stringValue;
      if ((Z == null ? void 0 : Z.numberValue) !== void 0)
        return Z.numberValue;
      if ((Z == null ? void 0 : Z.boolValue) !== void 0)
        return Z.boolValue;
      if ((Z == null ? void 0 : Z.structValue) !== void 0)
        return Z.structValue;
      if ((Z == null ? void 0 : Z.listValue) !== void 0)
        return Z.listValue;
      if ((Z == null ? void 0 : Z.nullValue) !== void 0)
        return null;
    }
  };
  function X() {
    return { values: [] };
  }
  a.ListValue = {
    encode(Z, de = _.Writer.create()) {
      for (const he of Z.values)
        a.Value.encode(a.Value.wrap(he), de.uint32(10).fork()).ldelim();
      return de;
    },
    decode(Z, de) {
      const he = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let pe = de === void 0 ? he.len : he.pos + de;
      const be = X();
      for (; he.pos < pe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            be.values.push(a.Value.unwrap(a.Value.decode(he, he.uint32())));
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(Z) {
      return {
        values: Array.isArray(Z == null ? void 0 : Z.values) ? [...Z.values] : []
      };
    },
    toJSON(Z) {
      const de = {};
      return Z.values ? de.values = Z.values.map((he) => he) : de.values = [], de;
    },
    fromPartial(Z) {
      var de;
      const he = X();
      return he.values = ((de = Z.values) === null || de === void 0 ? void 0 : de.map((pe) => pe)) || [], he;
    },
    wrap(Z) {
      const de = X();
      return de.values = Z ?? [], de;
    },
    unwrap(Z) {
      return Z.values;
    }
  };
  var ie = (() => {
    if (typeof ie < "u")
      return ie;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function Q(Z) {
    return typeof Z == "object" && Z !== null;
  }
  function ne(Z) {
    return Z != null;
  }
})(struct$2);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(U, se, Se, Ue) {
    Ue === void 0 && (Ue = Se), Object.defineProperty(U, Ue, { enumerable: !0, get: function() {
      return se[Se];
    } });
  } : function(U, se, Se, Ue) {
    Ue === void 0 && (Ue = Se), U[Ue] = se[Se];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(U, se) {
    Object.defineProperty(U, "default", { enumerable: !0, value: se });
  } : function(U, se) {
    U.default = se;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(U) {
    if (U && U.__esModule)
      return U;
    var se = {};
    if (U != null)
      for (var Se in U)
        Se !== "default" && Object.hasOwnProperty.call(U, Se) && u(se, U, Se);
    return c(se, U), se;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(U) {
    return U && U.__esModule ? U : { default: U };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LayoutServiceDefinition = a.LayoutServiceClientImpl = a.LayerServiceDefinition = a.LayerServiceClientImpl = a.Event = a.LayerEvent = a.LayoutEvent = a.BatchLayerRequest_BatchItem = a.BatchLayerRequest = a.BatchDeleteLayerRequest = a.DeleteLayerPayload = a.UpdateLayerRequest = a.GetLayerRequest = a.CreateLayerRequest = a.ListLayersResponse = a.ListLayersRequest = a.PartialLayerWithID = a.PartialLayer = a.LayerAnimation = a.DeleteLayoutResponse = a.DeleteLayoutRequest = a.DeleteLayoutPayload = a.UpdateLayoutRequest = a.GetLayoutRequest = a.CreateLayoutRequest = a.ListLayoutsResponse = a.ListLayoutsRequest = a.PartialLayout = a.BatchLayerResponse_BatchLayerItem = a.BatchLayerResponse = a.DeleteLayerResponse = a.DeleteLayerRequest = a.Layer = a.Layout = a.Transition_TransitionStinger = a.Transition_TransitionStingerCut = a.Transition_TransitionSwipe = a.Transition_TransitionCrossfade = a.Transition_TransitionFadeToColor = a.Transition_TransitionCut = a.Transition_TransitionMediaType = a.Transition = a.transition_TransitionSwipeTypeToNumber = a.transition_TransitionSwipeTypeToJSON = a.transition_TransitionSwipeTypeFromJSON = a.Transition_TransitionSwipeType = a.transition_TransitionDirectionToNumber = a.transition_TransitionDirectionToJSON = a.transition_TransitionDirectionFromJSON = a.Transition_TransitionDirection = a.eventTypeToNumber = a.eventTypeToJSON = a.eventTypeFromJSON = a.EventType = a.eventSubTypeToNumber = a.eventSubTypeToJSON = a.eventSubTypeFromJSON = a.EventSubType = a.requestAnimationModeToNumber = a.requestAnimationModeToJSON = a.requestAnimationModeFromJSON = a.RequestAnimationMode = a.layoutTypeToNumber = a.layoutTypeToJSON = a.layoutTypeFromJSON = a.LayoutType = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal), I = struct$2;
  a.protobufPackage = "apis.layout.v2";
  var P;
  (function(U) {
    U.LAYOUT_TYPE_UNSPECIFIED = "LAYOUT_TYPE_UNSPECIFIED", U.LAYOUT_TYPE_SCENELESS = "LAYOUT_TYPE_SCENELESS", U.LAYOUT_TYPE_SCENE = "LAYOUT_TYPE_SCENE";
  })(P = a.LayoutType || (a.LayoutType = {}));
  function $(U) {
    switch (U) {
      case 0:
      case "LAYOUT_TYPE_UNSPECIFIED":
        return P.LAYOUT_TYPE_UNSPECIFIED;
      case 1:
      case "LAYOUT_TYPE_SCENELESS":
        return P.LAYOUT_TYPE_SCENELESS;
      case 2:
      case "LAYOUT_TYPE_SCENE":
        return P.LAYOUT_TYPE_SCENE;
      default:
        throw new Ve.Error("Unrecognized enum value " + U + " for enum LayoutType");
    }
  }
  a.layoutTypeFromJSON = $;
  function F(U) {
    switch (U) {
      case P.LAYOUT_TYPE_UNSPECIFIED:
        return "LAYOUT_TYPE_UNSPECIFIED";
      case P.LAYOUT_TYPE_SCENELESS:
        return "LAYOUT_TYPE_SCENELESS";
      case P.LAYOUT_TYPE_SCENE:
        return "LAYOUT_TYPE_SCENE";
      default:
        return "UNKNOWN";
    }
  }
  a.layoutTypeToJSON = F;
  function H(U) {
    switch (U) {
      case P.LAYOUT_TYPE_UNSPECIFIED:
        return 0;
      case P.LAYOUT_TYPE_SCENELESS:
        return 1;
      case P.LAYOUT_TYPE_SCENE:
        return 2;
      default:
        return 0;
    }
  }
  a.layoutTypeToNumber = H;
  var j;
  (function(U) {
    U.REQUEST_ANIMATION_MODE_UNSPECIFIED = "REQUEST_ANIMATION_MODE_UNSPECIFIED", U.REQUEST_ANIMATION_MODE_PARALLEL = "REQUEST_ANIMATION_MODE_PARALLEL", U.REQUEST_ANIMATION_MODE_SERIES = "REQUEST_ANIMATION_MODE_SERIES";
  })(j = a.RequestAnimationMode || (a.RequestAnimationMode = {}));
  function ee(U) {
    switch (U) {
      case 0:
      case "REQUEST_ANIMATION_MODE_UNSPECIFIED":
        return j.REQUEST_ANIMATION_MODE_UNSPECIFIED;
      case 1:
      case "REQUEST_ANIMATION_MODE_PARALLEL":
        return j.REQUEST_ANIMATION_MODE_PARALLEL;
      case 2:
      case "REQUEST_ANIMATION_MODE_SERIES":
        return j.REQUEST_ANIMATION_MODE_SERIES;
      default:
        throw new Ve.Error("Unrecognized enum value " + U + " for enum RequestAnimationMode");
    }
  }
  a.requestAnimationModeFromJSON = ee;
  function X(U) {
    switch (U) {
      case j.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return "REQUEST_ANIMATION_MODE_UNSPECIFIED";
      case j.REQUEST_ANIMATION_MODE_PARALLEL:
        return "REQUEST_ANIMATION_MODE_PARALLEL";
      case j.REQUEST_ANIMATION_MODE_SERIES:
        return "REQUEST_ANIMATION_MODE_SERIES";
      default:
        return "UNKNOWN";
    }
  }
  a.requestAnimationModeToJSON = X;
  function ie(U) {
    switch (U) {
      case j.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return 0;
      case j.REQUEST_ANIMATION_MODE_PARALLEL:
        return 1;
      case j.REQUEST_ANIMATION_MODE_SERIES:
        return 2;
      default:
        return 0;
    }
  }
  a.requestAnimationModeToNumber = ie;
  var Q;
  (function(U) {
    U.EVENT_SUB_TYPE_UNSPECIFIED = "EVENT_SUB_TYPE_UNSPECIFIED", U.EVENT_SUB_TYPE_CREATE = "EVENT_SUB_TYPE_CREATE", U.EVENT_SUB_TYPE_UPDATE = "EVENT_SUB_TYPE_UPDATE", U.EVENT_SUB_TYPE_DELETE = "EVENT_SUB_TYPE_DELETE", U.EVENT_SUB_TYPE_BATCH = "EVENT_SUB_TYPE_BATCH";
  })(Q = a.EventSubType || (a.EventSubType = {}));
  function ne(U) {
    switch (U) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return Q.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return Q.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return Q.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return Q.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_BATCH":
        return Q.EVENT_SUB_TYPE_BATCH;
      default:
        throw new Ve.Error("Unrecognized enum value " + U + " for enum EventSubType");
    }
  }
  a.eventSubTypeFromJSON = ne;
  function Z(U) {
    switch (U) {
      case Q.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case Q.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case Q.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case Q.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case Q.EVENT_SUB_TYPE_BATCH:
        return "EVENT_SUB_TYPE_BATCH";
      default:
        return "UNKNOWN";
    }
  }
  a.eventSubTypeToJSON = Z;
  function de(U) {
    switch (U) {
      case Q.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case Q.EVENT_SUB_TYPE_CREATE:
        return 1;
      case Q.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case Q.EVENT_SUB_TYPE_DELETE:
        return 3;
      case Q.EVENT_SUB_TYPE_BATCH:
        return 4;
      default:
        return 0;
    }
  }
  a.eventSubTypeToNumber = de;
  var he;
  (function(U) {
    U.EVENT_TYPE_UNSPECIFIED = "EVENT_TYPE_UNSPECIFIED", U.EVENT_TYPE_LAYOUT = "EVENT_TYPE_LAYOUT", U.EVENT_TYPE_LAYER = "EVENT_TYPE_LAYER";
  })(he = a.EventType || (a.EventType = {}));
  function pe(U) {
    switch (U) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return he.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_LAYOUT":
        return he.EVENT_TYPE_LAYOUT;
      case 2:
      case "EVENT_TYPE_LAYER":
        return he.EVENT_TYPE_LAYER;
      default:
        throw new Ve.Error("Unrecognized enum value " + U + " for enum EventType");
    }
  }
  a.eventTypeFromJSON = pe;
  function be(U) {
    switch (U) {
      case he.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case he.EVENT_TYPE_LAYOUT:
        return "EVENT_TYPE_LAYOUT";
      case he.EVENT_TYPE_LAYER:
        return "EVENT_TYPE_LAYER";
      default:
        return "UNKNOWN";
    }
  }
  a.eventTypeToJSON = be;
  function ke(U) {
    switch (U) {
      case he.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case he.EVENT_TYPE_LAYOUT:
        return 1;
      case he.EVENT_TYPE_LAYER:
        return 2;
      default:
        return 0;
    }
  }
  a.eventTypeToNumber = ke;
  var _e;
  (function(U) {
    U.TRANSITION_DIRECTION_UNSPECIFIED = "TRANSITION_DIRECTION_UNSPECIFIED", U.TRANSITION_DIRECTION_LEFT = "TRANSITION_DIRECTION_LEFT", U.TRANSITION_DIRECTION_RIGHT = "TRANSITION_DIRECTION_RIGHT", U.TRANSITION_DIRECTION_UP = "TRANSITION_DIRECTION_UP", U.TRANSITION_DIRECTION_DOWN = "TRANSITION_DIRECTION_DOWN";
  })(_e = a.Transition_TransitionDirection || (a.Transition_TransitionDirection = {}));
  function q(U) {
    switch (U) {
      case 0:
      case "TRANSITION_DIRECTION_UNSPECIFIED":
        return _e.TRANSITION_DIRECTION_UNSPECIFIED;
      case 1:
      case "TRANSITION_DIRECTION_LEFT":
        return _e.TRANSITION_DIRECTION_LEFT;
      case 2:
      case "TRANSITION_DIRECTION_RIGHT":
        return _e.TRANSITION_DIRECTION_RIGHT;
      case 3:
      case "TRANSITION_DIRECTION_UP":
        return _e.TRANSITION_DIRECTION_UP;
      case 4:
      case "TRANSITION_DIRECTION_DOWN":
        return _e.TRANSITION_DIRECTION_DOWN;
      default:
        throw new Ve.Error("Unrecognized enum value " + U + " for enum Transition_TransitionDirection");
    }
  }
  a.transition_TransitionDirectionFromJSON = q;
  function z(U) {
    switch (U) {
      case _e.TRANSITION_DIRECTION_UNSPECIFIED:
        return "TRANSITION_DIRECTION_UNSPECIFIED";
      case _e.TRANSITION_DIRECTION_LEFT:
        return "TRANSITION_DIRECTION_LEFT";
      case _e.TRANSITION_DIRECTION_RIGHT:
        return "TRANSITION_DIRECTION_RIGHT";
      case _e.TRANSITION_DIRECTION_UP:
        return "TRANSITION_DIRECTION_UP";
      case _e.TRANSITION_DIRECTION_DOWN:
        return "TRANSITION_DIRECTION_DOWN";
      default:
        return "UNKNOWN";
    }
  }
  a.transition_TransitionDirectionToJSON = z;
  function C(U) {
    switch (U) {
      case _e.TRANSITION_DIRECTION_UNSPECIFIED:
        return 0;
      case _e.TRANSITION_DIRECTION_LEFT:
        return 1;
      case _e.TRANSITION_DIRECTION_RIGHT:
        return 2;
      case _e.TRANSITION_DIRECTION_UP:
        return 3;
      case _e.TRANSITION_DIRECTION_DOWN:
        return 4;
      default:
        return 0;
    }
  }
  a.transition_TransitionDirectionToNumber = C;
  var b;
  (function(U) {
    U.TRANSITION_SWIPE_TYPE_UNSPECIFIED = "TRANSITION_SWIPE_TYPE_UNSPECIFIED", U.TRANSITION_SWIPE_TYPE_COMBINED = "TRANSITION_SWIPE_TYPE_COMBINED", U.TRANSITION_SWIPE_TYPE_SOURCE = "TRANSITION_SWIPE_TYPE_SOURCE", U.TRANSITION_SWIPE_TYPE_DESTINATION = "TRANSITION_SWIPE_TYPE_DESTINATION";
  })(b = a.Transition_TransitionSwipeType || (a.Transition_TransitionSwipeType = {}));
  function E(U) {
    switch (U) {
      case 0:
      case "TRANSITION_SWIPE_TYPE_UNSPECIFIED":
        return b.TRANSITION_SWIPE_TYPE_UNSPECIFIED;
      case 1:
      case "TRANSITION_SWIPE_TYPE_COMBINED":
        return b.TRANSITION_SWIPE_TYPE_COMBINED;
      case 2:
      case "TRANSITION_SWIPE_TYPE_SOURCE":
        return b.TRANSITION_SWIPE_TYPE_SOURCE;
      case 3:
      case "TRANSITION_SWIPE_TYPE_DESTINATION":
        return b.TRANSITION_SWIPE_TYPE_DESTINATION;
      default:
        throw new Ve.Error("Unrecognized enum value " + U + " for enum Transition_TransitionSwipeType");
    }
  }
  a.transition_TransitionSwipeTypeFromJSON = E;
  function k(U) {
    switch (U) {
      case b.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return "TRANSITION_SWIPE_TYPE_UNSPECIFIED";
      case b.TRANSITION_SWIPE_TYPE_COMBINED:
        return "TRANSITION_SWIPE_TYPE_COMBINED";
      case b.TRANSITION_SWIPE_TYPE_SOURCE:
        return "TRANSITION_SWIPE_TYPE_SOURCE";
      case b.TRANSITION_SWIPE_TYPE_DESTINATION:
        return "TRANSITION_SWIPE_TYPE_DESTINATION";
      default:
        return "UNKNOWN";
    }
  }
  a.transition_TransitionSwipeTypeToJSON = k;
  function O(U) {
    switch (U) {
      case b.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return 0;
      case b.TRANSITION_SWIPE_TYPE_COMBINED:
        return 1;
      case b.TRANSITION_SWIPE_TYPE_SOURCE:
        return 2;
      case b.TRANSITION_SWIPE_TYPE_DESTINATION:
        return 3;
      default:
        return 0;
    }
  }
  a.transition_TransitionSwipeTypeToNumber = O;
  function A() {
    return {
      fromLayoutIds: [],
      cut: void 0,
      crossfade: void 0,
      fadeToColor: void 0,
      swipe: void 0,
      stinger: void 0
    };
  }
  a.Transition = {
    encode(U, se = _.Writer.create()) {
      for (const Se of U.fromLayoutIds)
        se.uint32(10).string(Se);
      return U.cut !== void 0 && a.Transition_TransitionCut.encode(U.cut, se.uint32(82).fork()).ldelim(), U.crossfade !== void 0 && a.Transition_TransitionCrossfade.encode(U.crossfade, se.uint32(90).fork()).ldelim(), U.fadeToColor !== void 0 && a.Transition_TransitionFadeToColor.encode(U.fadeToColor, se.uint32(98).fork()).ldelim(), U.swipe !== void 0 && a.Transition_TransitionSwipe.encode(U.swipe, se.uint32(106).fork()).ldelim(), U.stinger !== void 0 && a.Transition_TransitionStinger.encode(U.stinger, se.uint32(114).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = A();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.fromLayoutIds.push(Se.string());
            break;
          case 10:
            De.cut = a.Transition_TransitionCut.decode(Se, Se.uint32());
            break;
          case 11:
            De.crossfade = a.Transition_TransitionCrossfade.decode(Se, Se.uint32());
            break;
          case 12:
            De.fadeToColor = a.Transition_TransitionFadeToColor.decode(Se, Se.uint32());
            break;
          case 13:
            De.swipe = a.Transition_TransitionSwipe.decode(Se, Se.uint32());
            break;
          case 14:
            De.stinger = a.Transition_TransitionStinger.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        fromLayoutIds: Array.isArray(U == null ? void 0 : U.fromLayoutIds) ? U.fromLayoutIds.map((se) => String(se)) : [],
        cut: Ke(U.cut) ? a.Transition_TransitionCut.fromJSON(U.cut) : void 0,
        crossfade: Ke(U.crossfade) ? a.Transition_TransitionCrossfade.fromJSON(U.crossfade) : void 0,
        fadeToColor: Ke(U.fadeToColor) ? a.Transition_TransitionFadeToColor.fromJSON(U.fadeToColor) : void 0,
        swipe: Ke(U.swipe) ? a.Transition_TransitionSwipe.fromJSON(U.swipe) : void 0,
        stinger: Ke(U.stinger) ? a.Transition_TransitionStinger.fromJSON(U.stinger) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.fromLayoutIds ? se.fromLayoutIds = U.fromLayoutIds.map((Se) => Se) : se.fromLayoutIds = [], U.cut !== void 0 && (se.cut = U.cut ? a.Transition_TransitionCut.toJSON(U.cut) : void 0), U.crossfade !== void 0 && (se.crossfade = U.crossfade ? a.Transition_TransitionCrossfade.toJSON(U.crossfade) : void 0), U.fadeToColor !== void 0 && (se.fadeToColor = U.fadeToColor ? a.Transition_TransitionFadeToColor.toJSON(U.fadeToColor) : void 0), U.swipe !== void 0 && (se.swipe = U.swipe ? a.Transition_TransitionSwipe.toJSON(U.swipe) : void 0), U.stinger !== void 0 && (se.stinger = U.stinger ? a.Transition_TransitionStinger.toJSON(U.stinger) : void 0), se;
    },
    fromPartial(U) {
      var se;
      const Se = A();
      return Se.fromLayoutIds = ((se = U.fromLayoutIds) === null || se === void 0 ? void 0 : se.map((Ue) => Ue)) || [], Se.cut = U.cut !== void 0 && U.cut !== null ? a.Transition_TransitionCut.fromPartial(U.cut) : void 0, Se.crossfade = U.crossfade !== void 0 && U.crossfade !== null ? a.Transition_TransitionCrossfade.fromPartial(U.crossfade) : void 0, Se.fadeToColor = U.fadeToColor !== void 0 && U.fadeToColor !== null ? a.Transition_TransitionFadeToColor.fromPartial(U.fadeToColor) : void 0, Se.swipe = U.swipe !== void 0 && U.swipe !== null ? a.Transition_TransitionSwipe.fromPartial(U.swipe) : void 0, Se.stinger = U.stinger !== void 0 && U.stinger !== null ? a.Transition_TransitionStinger.fromPartial(U.stinger) : void 0, Se;
    }
  };
  function x() {
    return { url: "", volume: 0 };
  }
  a.Transition_TransitionMediaType = {
    encode(U, se = _.Writer.create()) {
      return U.url !== "" && se.uint32(10).string(U.url), U.volume !== 0 && se.uint32(17).double(U.volume), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = x();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.url = Se.string();
            break;
          case 2:
            De.volume = Se.double();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        url: Ke(U.url) ? String(U.url) : "",
        volume: Ke(U.volume) ? Number(U.volume) : 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.url !== void 0 && (se.url = U.url), U.volume !== void 0 && (se.volume = U.volume), se;
    },
    fromPartial(U) {
      var se, Se;
      const Ue = x();
      return Ue.url = (se = U.url) !== null && se !== void 0 ? se : "", Ue.volume = (Se = U.volume) !== null && Se !== void 0 ? Se : 0, Ue;
    }
  };
  function Y() {
    return {};
  }
  a.Transition_TransitionCut = {
    encode(U, se = _.Writer.create()) {
      return se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = Y();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {};
    },
    toJSON(U) {
      return {};
    },
    fromPartial(U) {
      return Y();
    }
  };
  function B() {
    return { durationMs: 0, backgroundColor: "" };
  }
  a.Transition_TransitionFadeToColor = {
    encode(U, se = _.Writer.create()) {
      return U.durationMs !== 0 && se.uint32(8).int32(U.durationMs), U.backgroundColor !== "" && se.uint32(18).string(U.backgroundColor), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = B();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.durationMs = Se.int32();
            break;
          case 2:
            De.backgroundColor = Se.string();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        durationMs: Ke(U.durationMs) ? Number(U.durationMs) : 0,
        backgroundColor: Ke(U.backgroundColor) ? String(U.backgroundColor) : ""
      };
    },
    toJSON(U) {
      const se = {};
      return U.durationMs !== void 0 && (se.durationMs = Math.round(U.durationMs)), U.backgroundColor !== void 0 && (se.backgroundColor = U.backgroundColor), se;
    },
    fromPartial(U) {
      var se, Se;
      const Ue = B();
      return Ue.durationMs = (se = U.durationMs) !== null && se !== void 0 ? se : 0, Ue.backgroundColor = (Se = U.backgroundColor) !== null && Se !== void 0 ? Se : "", Ue;
    }
  };
  function T() {
    return { durationMs: 0 };
  }
  a.Transition_TransitionCrossfade = {
    encode(U, se = _.Writer.create()) {
      return U.durationMs !== 0 && se.uint32(8).int32(U.durationMs), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = T();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.durationMs = Se.int32();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        durationMs: Ke(U.durationMs) ? Number(U.durationMs) : 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.durationMs !== void 0 && (se.durationMs = Math.round(U.durationMs)), se;
    },
    fromPartial(U) {
      var se;
      const Se = T();
      return Se.durationMs = (se = U.durationMs) !== null && se !== void 0 ? se : 0, Se;
    }
  };
  function D() {
    return {
      durationMs: 0,
      direction: _e.TRANSITION_DIRECTION_UNSPECIFIED,
      combinedAnimation: b.TRANSITION_SWIPE_TYPE_UNSPECIFIED
    };
  }
  a.Transition_TransitionSwipe = {
    encode(U, se = _.Writer.create()) {
      return U.durationMs !== 0 && se.uint32(8).int32(U.durationMs), U.direction !== _e.TRANSITION_DIRECTION_UNSPECIFIED && se.uint32(16).int32(C(U.direction)), U.combinedAnimation !== b.TRANSITION_SWIPE_TYPE_UNSPECIFIED && se.uint32(24).int32(O(U.combinedAnimation)), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = D();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.durationMs = Se.int32();
            break;
          case 2:
            De.direction = q(Se.int32());
            break;
          case 3:
            De.combinedAnimation = E(Se.int32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        durationMs: Ke(U.durationMs) ? Number(U.durationMs) : 0,
        direction: Ke(U.direction) ? q(U.direction) : _e.TRANSITION_DIRECTION_UNSPECIFIED,
        combinedAnimation: Ke(U.combinedAnimation) ? E(U.combinedAnimation) : b.TRANSITION_SWIPE_TYPE_UNSPECIFIED
      };
    },
    toJSON(U) {
      const se = {};
      return U.durationMs !== void 0 && (se.durationMs = Math.round(U.durationMs)), U.direction !== void 0 && (se.direction = z(U.direction)), U.combinedAnimation !== void 0 && (se.combinedAnimation = k(U.combinedAnimation)), se;
    },
    fromPartial(U) {
      var se, Se, Ue;
      const De = D();
      return De.durationMs = (se = U.durationMs) !== null && se !== void 0 ? se : 0, De.direction = (Se = U.direction) !== null && Se !== void 0 ? Se : _e.TRANSITION_DIRECTION_UNSPECIFIED, De.combinedAnimation = (Ue = U.combinedAnimation) !== null && Ue !== void 0 ? Ue : b.TRANSITION_SWIPE_TYPE_UNSPECIFIED, De;
    }
  };
  function te() {
    return { cutPointMs: 0, media: void 0 };
  }
  a.Transition_TransitionStingerCut = {
    encode(U, se = _.Writer.create()) {
      return U.cutPointMs !== 0 && se.uint32(8).int32(U.cutPointMs), U.media !== void 0 && a.Transition_TransitionMediaType.encode(U.media, se.uint32(18).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = te();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.cutPointMs = Se.int32();
            break;
          case 2:
            De.media = a.Transition_TransitionMediaType.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        cutPointMs: Ke(U.cutPointMs) ? Number(U.cutPointMs) : 0,
        media: Ke(U.media) ? a.Transition_TransitionMediaType.fromJSON(U.media) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.cutPointMs !== void 0 && (se.cutPointMs = Math.round(U.cutPointMs)), U.media !== void 0 && (se.media = U.media ? a.Transition_TransitionMediaType.toJSON(U.media) : void 0), se;
    },
    fromPartial(U) {
      var se;
      const Se = te();
      return Se.cutPointMs = (se = U.cutPointMs) !== null && se !== void 0 ? se : 0, Se.media = U.media !== void 0 && U.media !== null ? a.Transition_TransitionMediaType.fromPartial(U.media) : void 0, Se;
    }
  };
  function me() {
    return { cut: void 0 };
  }
  a.Transition_TransitionStinger = {
    encode(U, se = _.Writer.create()) {
      return U.cut !== void 0 && a.Transition_TransitionStingerCut.encode(U.cut, se.uint32(10).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = me();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.cut = a.Transition_TransitionStingerCut.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        cut: Ke(U.cut) ? a.Transition_TransitionStingerCut.fromJSON(U.cut) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.cut !== void 0 && (se.cut = U.cut ? a.Transition_TransitionStingerCut.toJSON(U.cut) : void 0), se;
    },
    fromPartial(U) {
      const se = me();
      return se.cut = U.cut !== void 0 && U.cut !== null ? a.Transition_TransitionStingerCut.fromPartial(U.cut) : void 0, se;
    }
  };
  function Ie() {
    return {
      id: "",
      width: 0,
      height: 0,
      metadata: void 0,
      projectId: void 0,
      collectionId: void 0,
      type: void 0,
      transitions: [],
      requestMetadata: void 0
    };
  }
  a.Layout = {
    encode(U, se = _.Writer.create()) {
      U.id !== "" && se.uint32(10).string(U.id), U.width !== 0 && se.uint32(16).int32(U.width), U.height !== 0 && se.uint32(24).int32(U.height), U.metadata !== void 0 && I.Value.encode(I.Value.wrap(U.metadata), se.uint32(50).fork()).ldelim(), U.projectId !== void 0 && se.uint32(58).string(U.projectId), U.collectionId !== void 0 && se.uint32(66).string(U.collectionId), U.type !== void 0 && se.uint32(72).int32(H(U.type));
      for (const Se of U.transitions)
        a.Transition.encode(Se, se.uint32(82).fork()).ldelim();
      return U.requestMetadata !== void 0 && I.Value.encode(I.Value.wrap(U.requestMetadata), se.uint32(810).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = Ie();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.id = Se.string();
            break;
          case 2:
            De.width = Se.int32();
            break;
          case 3:
            De.height = Se.int32();
            break;
          case 6:
            De.metadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 7:
            De.projectId = Se.string();
            break;
          case 8:
            De.collectionId = Se.string();
            break;
          case 9:
            De.type = $(Se.int32());
            break;
          case 10:
            De.transitions.push(a.Transition.decode(Se, Se.uint32()));
            break;
          case 101:
            De.requestMetadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        id: Ke(U.id) ? String(U.id) : "",
        width: Ke(U.width) ? Number(U.width) : 0,
        height: Ke(U.height) ? Number(U.height) : 0,
        metadata: Ke(U == null ? void 0 : U.metadata) ? U.metadata : void 0,
        projectId: Ke(U.projectId) ? String(U.projectId) : void 0,
        collectionId: Ke(U.collectionId) ? String(U.collectionId) : void 0,
        type: Ke(U.type) ? $(U.type) : void 0,
        transitions: Array.isArray(U == null ? void 0 : U.transitions) ? U.transitions.map((se) => a.Transition.fromJSON(se)) : [],
        requestMetadata: Ke(U == null ? void 0 : U.requestMetadata) ? U.requestMetadata : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.id !== void 0 && (se.id = U.id), U.width !== void 0 && (se.width = Math.round(U.width)), U.height !== void 0 && (se.height = Math.round(U.height)), U.metadata !== void 0 && (se.metadata = U.metadata), U.projectId !== void 0 && (se.projectId = U.projectId), U.collectionId !== void 0 && (se.collectionId = U.collectionId), U.type !== void 0 && (se.type = U.type !== void 0 ? F(U.type) : void 0), U.transitions ? se.transitions = U.transitions.map((Se) => Se ? a.Transition.toJSON(Se) : void 0) : se.transitions = [], U.requestMetadata !== void 0 && (se.requestMetadata = U.requestMetadata), se;
    },
    fromPartial(U) {
      var se, Se, Ue, De, Ye, Qe, st, St, tt;
      const it = Ie();
      return it.id = (se = U.id) !== null && se !== void 0 ? se : "", it.width = (Se = U.width) !== null && Se !== void 0 ? Se : 0, it.height = (Ue = U.height) !== null && Ue !== void 0 ? Ue : 0, it.metadata = (De = U.metadata) !== null && De !== void 0 ? De : void 0, it.projectId = (Ye = U.projectId) !== null && Ye !== void 0 ? Ye : void 0, it.collectionId = (Qe = U.collectionId) !== null && Qe !== void 0 ? Qe : void 0, it.type = (st = U.type) !== null && st !== void 0 ? st : void 0, it.transitions = ((St = U.transitions) === null || St === void 0 ? void 0 : St.map((Tt) => a.Transition.fromPartial(Tt))) || [], it.requestMetadata = (tt = U.requestMetadata) !== null && tt !== void 0 ? tt : void 0, it;
    }
  };
  function $e() {
    return {
      type: "",
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: 0,
      opacity: 0,
      scale: 0,
      hidden: !1,
      children: void 0,
      metadata: void 0,
      id: "",
      layoutId: "",
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.Layer = {
    encode(U, se = _.Writer.create()) {
      U.type !== "" && se.uint32(10).string(U.type), U.data !== void 0 && I.Struct.encode(I.Struct.wrap(U.data), se.uint32(18).fork()).ldelim(), U.x !== void 0 && I.Value.encode(I.Value.wrap(U.x), se.uint32(26).fork()).ldelim(), U.y !== void 0 && I.Value.encode(I.Value.wrap(U.y), se.uint32(34).fork()).ldelim(), U.width !== void 0 && I.Value.encode(I.Value.wrap(U.width), se.uint32(42).fork()).ldelim(), U.height !== void 0 && I.Value.encode(I.Value.wrap(U.height), se.uint32(50).fork()).ldelim(), U.rotation !== 0 && se.uint32(57).double(U.rotation), U.opacity !== 0 && se.uint32(65).double(U.opacity), U.scale !== 0 && se.uint32(73).double(U.scale), U.hidden === !0 && se.uint32(80).bool(U.hidden), U.children !== void 0 && I.ListValue.encode(I.ListValue.wrap(U.children), se.uint32(98).fork()).ldelim(), U.metadata !== void 0 && I.Value.encode(I.Value.wrap(U.metadata), se.uint32(114).fork()).ldelim(), U.id !== "" && se.uint32(802).string(U.id), U.layoutId !== "" && se.uint32(818).string(U.layoutId), U.requestMetadata !== void 0 && I.Value.encode(I.Value.wrap(U.requestMetadata), se.uint32(810).fork()).ldelim();
      for (const Se of U.requestAnimation)
        a.LayerAnimation.encode(Se, se.uint32(826).fork()).ldelim();
      return se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = $e();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.type = Se.string();
            break;
          case 2:
            De.data = I.Struct.unwrap(I.Struct.decode(Se, Se.uint32()));
            break;
          case 3:
            De.x = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 4:
            De.y = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 5:
            De.width = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 6:
            De.height = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 7:
            De.rotation = Se.double();
            break;
          case 8:
            De.opacity = Se.double();
            break;
          case 9:
            De.scale = Se.double();
            break;
          case 10:
            De.hidden = Se.bool();
            break;
          case 12:
            De.children = I.ListValue.unwrap(I.ListValue.decode(Se, Se.uint32()));
            break;
          case 14:
            De.metadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 100:
            De.id = Se.string();
            break;
          case 102:
            De.layoutId = Se.string();
            break;
          case 101:
            De.requestMetadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 103:
            De.requestAnimation.push(a.LayerAnimation.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        type: Ke(U.type) ? String(U.type) : "",
        data: Ze(U.data) ? U.data : void 0,
        x: Ke(U == null ? void 0 : U.x) ? U.x : void 0,
        y: Ke(U == null ? void 0 : U.y) ? U.y : void 0,
        width: Ke(U == null ? void 0 : U.width) ? U.width : void 0,
        height: Ke(U == null ? void 0 : U.height) ? U.height : void 0,
        rotation: Ke(U.rotation) ? Number(U.rotation) : 0,
        opacity: Ke(U.opacity) ? Number(U.opacity) : 0,
        scale: Ke(U.scale) ? Number(U.scale) : 0,
        hidden: Ke(U.hidden) ? !!U.hidden : !1,
        children: Array.isArray(U.children) ? [...U.children] : void 0,
        metadata: Ke(U == null ? void 0 : U.metadata) ? U.metadata : void 0,
        id: Ke(U.id) ? String(U.id) : "",
        layoutId: Ke(U.layoutId) ? String(U.layoutId) : "",
        requestMetadata: Ke(U == null ? void 0 : U.requestMetadata) ? U.requestMetadata : void 0,
        requestAnimation: Array.isArray(U == null ? void 0 : U.requestAnimation) ? U.requestAnimation.map((se) => a.LayerAnimation.fromJSON(se)) : []
      };
    },
    toJSON(U) {
      const se = {};
      return U.type !== void 0 && (se.type = U.type), U.data !== void 0 && (se.data = U.data), U.x !== void 0 && (se.x = U.x), U.y !== void 0 && (se.y = U.y), U.width !== void 0 && (se.width = U.width), U.height !== void 0 && (se.height = U.height), U.rotation !== void 0 && (se.rotation = U.rotation), U.opacity !== void 0 && (se.opacity = U.opacity), U.scale !== void 0 && (se.scale = U.scale), U.hidden !== void 0 && (se.hidden = U.hidden), U.children !== void 0 && (se.children = U.children), U.metadata !== void 0 && (se.metadata = U.metadata), U.id !== void 0 && (se.id = U.id), U.layoutId !== void 0 && (se.layoutId = U.layoutId), U.requestMetadata !== void 0 && (se.requestMetadata = U.requestMetadata), U.requestAnimation ? se.requestAnimation = U.requestAnimation.map((Se) => Se ? a.LayerAnimation.toJSON(Se) : void 0) : se.requestAnimation = [], se;
    },
    fromPartial(U) {
      var se, Se, Ue, De, Ye, Qe, st, St, tt, it, Tt, rt, dt, wt, nt, at;
      const gt = $e();
      return gt.type = (se = U.type) !== null && se !== void 0 ? se : "", gt.data = (Se = U.data) !== null && Se !== void 0 ? Se : void 0, gt.x = (Ue = U.x) !== null && Ue !== void 0 ? Ue : void 0, gt.y = (De = U.y) !== null && De !== void 0 ? De : void 0, gt.width = (Ye = U.width) !== null && Ye !== void 0 ? Ye : void 0, gt.height = (Qe = U.height) !== null && Qe !== void 0 ? Qe : void 0, gt.rotation = (st = U.rotation) !== null && st !== void 0 ? st : 0, gt.opacity = (St = U.opacity) !== null && St !== void 0 ? St : 0, gt.scale = (tt = U.scale) !== null && tt !== void 0 ? tt : 0, gt.hidden = (it = U.hidden) !== null && it !== void 0 ? it : !1, gt.children = (Tt = U.children) !== null && Tt !== void 0 ? Tt : void 0, gt.metadata = (rt = U.metadata) !== null && rt !== void 0 ? rt : void 0, gt.id = (dt = U.id) !== null && dt !== void 0 ? dt : "", gt.layoutId = (wt = U.layoutId) !== null && wt !== void 0 ? wt : "", gt.requestMetadata = (nt = U.requestMetadata) !== null && nt !== void 0 ? nt : void 0, gt.requestAnimation = ((at = U.requestAnimation) === null || at === void 0 ? void 0 : at.map((ot) => a.LayerAnimation.fromPartial(ot))) || [], gt;
    }
  };
  function ye() {
    return { layoutId: "", layerId: "", payload: void 0 };
  }
  a.DeleteLayerRequest = {
    encode(U, se = _.Writer.create()) {
      return U.layoutId !== "" && se.uint32(10).string(U.layoutId), U.layerId !== "" && se.uint32(18).string(U.layerId), U.payload !== void 0 && a.DeleteLayerPayload.encode(U.payload, se.uint32(26).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = ye();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.layoutId = Se.string();
            break;
          case 2:
            De.layerId = Se.string();
            break;
          case 3:
            De.payload = a.DeleteLayerPayload.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layoutId: Ke(U.layoutId) ? String(U.layoutId) : "",
        layerId: Ke(U.layerId) ? String(U.layerId) : "",
        payload: Ke(U.payload) ? a.DeleteLayerPayload.fromJSON(U.payload) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.layoutId !== void 0 && (se.layoutId = U.layoutId), U.layerId !== void 0 && (se.layerId = U.layerId), U.payload !== void 0 && (se.payload = U.payload ? a.DeleteLayerPayload.toJSON(U.payload) : void 0), se;
    },
    fromPartial(U) {
      var se, Se;
      const Ue = ye();
      return Ue.layoutId = (se = U.layoutId) !== null && se !== void 0 ? se : "", Ue.layerId = (Se = U.layerId) !== null && Se !== void 0 ? Se : "", Ue.payload = U.payload !== void 0 && U.payload !== null ? a.DeleteLayerPayload.fromPartial(U.payload) : void 0, Ue;
    }
  };
  function fe() {
    return { id: "", layoutId: "", requestMetadata: void 0 };
  }
  a.DeleteLayerResponse = {
    encode(U, se = _.Writer.create()) {
      return U.id !== "" && se.uint32(10).string(U.id), U.layoutId !== "" && se.uint32(18).string(U.layoutId), U.requestMetadata !== void 0 && I.Value.encode(I.Value.wrap(U.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = fe();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.id = Se.string();
            break;
          case 2:
            De.layoutId = Se.string();
            break;
          case 100:
            De.requestMetadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        id: Ke(U.id) ? String(U.id) : "",
        layoutId: Ke(U.layoutId) ? String(U.layoutId) : "",
        requestMetadata: Ke(U == null ? void 0 : U.requestMetadata) ? U.requestMetadata : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.id !== void 0 && (se.id = U.id), U.layoutId !== void 0 && (se.layoutId = U.layoutId), U.requestMetadata !== void 0 && (se.requestMetadata = U.requestMetadata), se;
    },
    fromPartial(U) {
      var se, Se, Ue;
      const De = fe();
      return De.id = (se = U.id) !== null && se !== void 0 ? se : "", De.layoutId = (Se = U.layoutId) !== null && Se !== void 0 ? Se : "", De.requestMetadata = (Ue = U.requestMetadata) !== null && Ue !== void 0 ? Ue : void 0, De;
    }
  };
  function Me() {
    return {
      layers: [],
      layoutId: "",
      requestMetadata: void 0,
      requestAnimationMode: j.REQUEST_ANIMATION_MODE_UNSPECIFIED
    };
  }
  a.BatchLayerResponse = {
    encode(U, se = _.Writer.create()) {
      for (const Se of U.layers)
        a.BatchLayerResponse_BatchLayerItem.encode(Se, se.uint32(18).fork()).ldelim();
      return U.layoutId !== "" && se.uint32(26).string(U.layoutId), U.requestMetadata !== void 0 && I.Value.encode(I.Value.wrap(U.requestMetadata), se.uint32(802).fork()).ldelim(), U.requestAnimationMode !== j.REQUEST_ANIMATION_MODE_UNSPECIFIED && se.uint32(808).int32(ie(U.requestAnimationMode)), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = Me();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 2:
            De.layers.push(a.BatchLayerResponse_BatchLayerItem.decode(Se, Se.uint32()));
            break;
          case 3:
            De.layoutId = Se.string();
            break;
          case 100:
            De.requestMetadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 101:
            De.requestAnimationMode = ee(Se.int32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layers: Array.isArray(U == null ? void 0 : U.layers) ? U.layers.map((se) => a.BatchLayerResponse_BatchLayerItem.fromJSON(se)) : [],
        layoutId: Ke(U.layoutId) ? String(U.layoutId) : "",
        requestMetadata: Ke(U == null ? void 0 : U.requestMetadata) ? U.requestMetadata : void 0,
        requestAnimationMode: Ke(U.requestAnimationMode) ? ee(U.requestAnimationMode) : j.REQUEST_ANIMATION_MODE_UNSPECIFIED
      };
    },
    toJSON(U) {
      const se = {};
      return U.layers ? se.layers = U.layers.map((Se) => Se ? a.BatchLayerResponse_BatchLayerItem.toJSON(Se) : void 0) : se.layers = [], U.layoutId !== void 0 && (se.layoutId = U.layoutId), U.requestMetadata !== void 0 && (se.requestMetadata = U.requestMetadata), U.requestAnimationMode !== void 0 && (se.requestAnimationMode = X(U.requestAnimationMode)), se;
    },
    fromPartial(U) {
      var se, Se, Ue, De;
      const Ye = Me();
      return Ye.layers = ((se = U.layers) === null || se === void 0 ? void 0 : se.map((Qe) => a.BatchLayerResponse_BatchLayerItem.fromPartial(Qe))) || [], Ye.layoutId = (Se = U.layoutId) !== null && Se !== void 0 ? Se : "", Ye.requestMetadata = (Ue = U.requestMetadata) !== null && Ue !== void 0 ? Ue : void 0, Ye.requestAnimationMode = (De = U.requestAnimationMode) !== null && De !== void 0 ? De : j.REQUEST_ANIMATION_MODE_UNSPECIFIED, Ye;
    }
  };
  function Ae() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.BatchLayerResponse_BatchLayerItem = {
    encode(U, se = _.Writer.create()) {
      return U.create !== void 0 && a.Layer.encode(U.create, se.uint32(10).fork()).ldelim(), U.update !== void 0 && a.Layer.encode(U.update, se.uint32(18).fork()).ldelim(), U.delete !== void 0 && a.DeleteLayerResponse.encode(U.delete, se.uint32(26).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = Ae();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.create = a.Layer.decode(Se, Se.uint32());
            break;
          case 2:
            De.update = a.Layer.decode(Se, Se.uint32());
            break;
          case 3:
            De.delete = a.DeleteLayerResponse.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        create: Ke(U.create) ? a.Layer.fromJSON(U.create) : void 0,
        update: Ke(U.update) ? a.Layer.fromJSON(U.update) : void 0,
        delete: Ke(U.delete) ? a.DeleteLayerResponse.fromJSON(U.delete) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.create !== void 0 && (se.create = U.create ? a.Layer.toJSON(U.create) : void 0), U.update !== void 0 && (se.update = U.update ? a.Layer.toJSON(U.update) : void 0), U.delete !== void 0 && (se.delete = U.delete ? a.DeleteLayerResponse.toJSON(U.delete) : void 0), se;
    },
    fromPartial(U) {
      const se = Ae();
      return se.create = U.create !== void 0 && U.create !== null ? a.Layer.fromPartial(U.create) : void 0, se.update = U.update !== void 0 && U.update !== null ? a.Layer.fromPartial(U.update) : void 0, se.delete = U.delete !== void 0 && U.delete !== null ? a.DeleteLayerResponse.fromPartial(U.delete) : void 0, se;
    }
  };
  function xe() {
    return {
      width: void 0,
      height: void 0,
      metadata: void 0,
      projectId: void 0,
      collectionId: void 0,
      type: void 0,
      transitions: [],
      requestMetadata: void 0
    };
  }
  a.PartialLayout = {
    encode(U, se = _.Writer.create()) {
      U.width !== void 0 && se.uint32(16).int32(U.width), U.height !== void 0 && se.uint32(24).int32(U.height), U.metadata !== void 0 && I.Value.encode(I.Value.wrap(U.metadata), se.uint32(50).fork()).ldelim(), U.projectId !== void 0 && se.uint32(58).string(U.projectId), U.collectionId !== void 0 && se.uint32(66).string(U.collectionId), U.type !== void 0 && se.uint32(72).int32(H(U.type));
      for (const Se of U.transitions)
        a.Transition.encode(Se, se.uint32(82).fork()).ldelim();
      return U.requestMetadata !== void 0 && I.Value.encode(I.Value.wrap(U.requestMetadata), se.uint32(810).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = xe();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 2:
            De.width = Se.int32();
            break;
          case 3:
            De.height = Se.int32();
            break;
          case 6:
            De.metadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 7:
            De.projectId = Se.string();
            break;
          case 8:
            De.collectionId = Se.string();
            break;
          case 9:
            De.type = $(Se.int32());
            break;
          case 10:
            De.transitions.push(a.Transition.decode(Se, Se.uint32()));
            break;
          case 101:
            De.requestMetadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        width: Ke(U.width) ? Number(U.width) : void 0,
        height: Ke(U.height) ? Number(U.height) : void 0,
        metadata: Ke(U == null ? void 0 : U.metadata) ? U.metadata : void 0,
        projectId: Ke(U.projectId) ? String(U.projectId) : void 0,
        collectionId: Ke(U.collectionId) ? String(U.collectionId) : void 0,
        type: Ke(U.type) ? $(U.type) : void 0,
        transitions: Array.isArray(U == null ? void 0 : U.transitions) ? U.transitions.map((se) => a.Transition.fromJSON(se)) : [],
        requestMetadata: Ke(U == null ? void 0 : U.requestMetadata) ? U.requestMetadata : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.width !== void 0 && (se.width = Math.round(U.width)), U.height !== void 0 && (se.height = Math.round(U.height)), U.metadata !== void 0 && (se.metadata = U.metadata), U.projectId !== void 0 && (se.projectId = U.projectId), U.collectionId !== void 0 && (se.collectionId = U.collectionId), U.type !== void 0 && (se.type = U.type !== void 0 ? F(U.type) : void 0), U.transitions ? se.transitions = U.transitions.map((Se) => Se ? a.Transition.toJSON(Se) : void 0) : se.transitions = [], U.requestMetadata !== void 0 && (se.requestMetadata = U.requestMetadata), se;
    },
    fromPartial(U) {
      var se, Se, Ue, De, Ye, Qe, st, St;
      const tt = xe();
      return tt.width = (se = U.width) !== null && se !== void 0 ? se : void 0, tt.height = (Se = U.height) !== null && Se !== void 0 ? Se : void 0, tt.metadata = (Ue = U.metadata) !== null && Ue !== void 0 ? Ue : void 0, tt.projectId = (De = U.projectId) !== null && De !== void 0 ? De : void 0, tt.collectionId = (Ye = U.collectionId) !== null && Ye !== void 0 ? Ye : void 0, tt.type = (Qe = U.type) !== null && Qe !== void 0 ? Qe : void 0, tt.transitions = ((st = U.transitions) === null || st === void 0 ? void 0 : st.map((it) => a.Transition.fromPartial(it))) || [], tt.requestMetadata = (St = U.requestMetadata) !== null && St !== void 0 ? St : void 0, tt;
    }
  };
  function ae() {
    return { projectId: void 0, collectionId: void 0, type: void 0 };
  }
  a.ListLayoutsRequest = {
    encode(U, se = _.Writer.create()) {
      return U.projectId !== void 0 && se.uint32(10).string(U.projectId), U.collectionId !== void 0 && se.uint32(18).string(U.collectionId), U.type !== void 0 && se.uint32(24).int32(H(U.type)), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = ae();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.projectId = Se.string();
            break;
          case 2:
            De.collectionId = Se.string();
            break;
          case 3:
            De.type = $(Se.int32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        projectId: Ke(U.projectId) ? String(U.projectId) : void 0,
        collectionId: Ke(U.collectionId) ? String(U.collectionId) : void 0,
        type: Ke(U.type) ? $(U.type) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.projectId !== void 0 && (se.projectId = U.projectId), U.collectionId !== void 0 && (se.collectionId = U.collectionId), U.type !== void 0 && (se.type = U.type !== void 0 ? F(U.type) : void 0), se;
    },
    fromPartial(U) {
      var se, Se, Ue;
      const De = ae();
      return De.projectId = (se = U.projectId) !== null && se !== void 0 ? se : void 0, De.collectionId = (Se = U.collectionId) !== null && Se !== void 0 ? Se : void 0, De.type = (Ue = U.type) !== null && Ue !== void 0 ? Ue : void 0, De;
    }
  };
  function N() {
    return { layouts: [] };
  }
  a.ListLayoutsResponse = {
    encode(U, se = _.Writer.create()) {
      for (const Se of U.layouts)
        a.Layout.encode(Se, se.uint32(10).fork()).ldelim();
      return se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = N();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.layouts.push(a.Layout.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layouts: Array.isArray(U == null ? void 0 : U.layouts) ? U.layouts.map((se) => a.Layout.fromJSON(se)) : []
      };
    },
    toJSON(U) {
      const se = {};
      return U.layouts ? se.layouts = U.layouts.map((Se) => Se ? a.Layout.toJSON(Se) : void 0) : se.layouts = [], se;
    },
    fromPartial(U) {
      var se;
      const Se = N();
      return Se.layouts = ((se = U.layouts) === null || se === void 0 ? void 0 : se.map((Ue) => a.Layout.fromPartial(Ue))) || [], Se;
    }
  };
  function re() {
    return { layout: void 0 };
  }
  a.CreateLayoutRequest = {
    encode(U, se = _.Writer.create()) {
      return U.layout !== void 0 && a.PartialLayout.encode(U.layout, se.uint32(18).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = re();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 2:
            De.layout = a.PartialLayout.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layout: Ke(U.layout) ? a.PartialLayout.fromJSON(U.layout) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.layout !== void 0 && (se.layout = U.layout ? a.PartialLayout.toJSON(U.layout) : void 0), se;
    },
    fromPartial(U) {
      const se = re();
      return se.layout = U.layout !== void 0 && U.layout !== null ? a.PartialLayout.fromPartial(U.layout) : void 0, se;
    }
  };
  function le() {
    return { layoutId: "" };
  }
  a.GetLayoutRequest = {
    encode(U, se = _.Writer.create()) {
      return U.layoutId !== "" && se.uint32(10).string(U.layoutId), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = le();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.layoutId = Se.string();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layoutId: Ke(U.layoutId) ? String(U.layoutId) : ""
      };
    },
    toJSON(U) {
      const se = {};
      return U.layoutId !== void 0 && (se.layoutId = U.layoutId), se;
    },
    fromPartial(U) {
      var se;
      const Se = le();
      return Se.layoutId = (se = U.layoutId) !== null && se !== void 0 ? se : "", Se;
    }
  };
  function Ne() {
    return { layoutId: "", layout: void 0 };
  }
  a.UpdateLayoutRequest = {
    encode(U, se = _.Writer.create()) {
      return U.layoutId !== "" && se.uint32(10).string(U.layoutId), U.layout !== void 0 && a.PartialLayout.encode(U.layout, se.uint32(26).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = Ne();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.layoutId = Se.string();
            break;
          case 3:
            De.layout = a.PartialLayout.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layoutId: Ke(U.layoutId) ? String(U.layoutId) : "",
        layout: Ke(U.layout) ? a.PartialLayout.fromJSON(U.layout) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.layoutId !== void 0 && (se.layoutId = U.layoutId), U.layout !== void 0 && (se.layout = U.layout ? a.PartialLayout.toJSON(U.layout) : void 0), se;
    },
    fromPartial(U) {
      var se;
      const Se = Ne();
      return Se.layoutId = (se = U.layoutId) !== null && se !== void 0 ? se : "", Se.layout = U.layout !== void 0 && U.layout !== null ? a.PartialLayout.fromPartial(U.layout) : void 0, Se;
    }
  };
  function Oe() {
    return { requestMetadata: void 0 };
  }
  a.DeleteLayoutPayload = {
    encode(U, se = _.Writer.create()) {
      return U.requestMetadata !== void 0 && I.Value.encode(I.Value.wrap(U.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = Oe();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 100:
            De.requestMetadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        requestMetadata: Ke(U == null ? void 0 : U.requestMetadata) ? U.requestMetadata : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.requestMetadata !== void 0 && (se.requestMetadata = U.requestMetadata), se;
    },
    fromPartial(U) {
      var se;
      const Se = Oe();
      return Se.requestMetadata = (se = U.requestMetadata) !== null && se !== void 0 ? se : void 0, Se;
    }
  };
  function qe() {
    return { layoutId: "", payload: void 0 };
  }
  a.DeleteLayoutRequest = {
    encode(U, se = _.Writer.create()) {
      return U.layoutId !== "" && se.uint32(10).string(U.layoutId), U.payload !== void 0 && a.DeleteLayoutPayload.encode(U.payload, se.uint32(18).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = qe();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.layoutId = Se.string();
            break;
          case 2:
            De.payload = a.DeleteLayoutPayload.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layoutId: Ke(U.layoutId) ? String(U.layoutId) : "",
        payload: Ke(U.payload) ? a.DeleteLayoutPayload.fromJSON(U.payload) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.layoutId !== void 0 && (se.layoutId = U.layoutId), U.payload !== void 0 && (se.payload = U.payload ? a.DeleteLayoutPayload.toJSON(U.payload) : void 0), se;
    },
    fromPartial(U) {
      var se;
      const Se = qe();
      return Se.layoutId = (se = U.layoutId) !== null && se !== void 0 ? se : "", Se.payload = U.payload !== void 0 && U.payload !== null ? a.DeleteLayoutPayload.fromPartial(U.payload) : void 0, Se;
    }
  };
  function je() {
    return { id: "", requestMetadata: void 0 };
  }
  a.DeleteLayoutResponse = {
    encode(U, se = _.Writer.create()) {
      return U.id !== "" && se.uint32(18).string(U.id), U.requestMetadata !== void 0 && I.Value.encode(I.Value.wrap(U.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = je();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 2:
            De.id = Se.string();
            break;
          case 100:
            De.requestMetadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        id: Ke(U.id) ? String(U.id) : "",
        requestMetadata: Ke(U == null ? void 0 : U.requestMetadata) ? U.requestMetadata : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.id !== void 0 && (se.id = U.id), U.requestMetadata !== void 0 && (se.requestMetadata = U.requestMetadata), se;
    },
    fromPartial(U) {
      var se, Se;
      const Ue = je();
      return Ue.id = (se = U.id) !== null && se !== void 0 ? se : "", Ue.requestMetadata = (Se = U.requestMetadata) !== null && Se !== void 0 ? Se : void 0, Ue;
    }
  };
  function Fe() {
    return {
      properties: [],
      durationMs: 0,
      delayMs: void 0,
      easingMode: void 0
    };
  }
  a.LayerAnimation = {
    encode(U, se = _.Writer.create()) {
      for (const Se of U.properties)
        se.uint32(10).string(Se);
      return U.durationMs !== 0 && se.uint32(16).int32(U.durationMs), U.delayMs !== void 0 && se.uint32(32).int32(U.delayMs), U.easingMode !== void 0 && se.uint32(42).string(U.easingMode), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = Fe();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.properties.push(Se.string());
            break;
          case 2:
            De.durationMs = Se.int32();
            break;
          case 4:
            De.delayMs = Se.int32();
            break;
          case 5:
            De.easingMode = Se.string();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        properties: Array.isArray(U == null ? void 0 : U.properties) ? U.properties.map((se) => String(se)) : [],
        durationMs: Ke(U.durationMs) ? Number(U.durationMs) : 0,
        delayMs: Ke(U.delayMs) ? Number(U.delayMs) : void 0,
        easingMode: Ke(U.easingMode) ? String(U.easingMode) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.properties ? se.properties = U.properties.map((Se) => Se) : se.properties = [], U.durationMs !== void 0 && (se.durationMs = Math.round(U.durationMs)), U.delayMs !== void 0 && (se.delayMs = Math.round(U.delayMs)), U.easingMode !== void 0 && (se.easingMode = U.easingMode), se;
    },
    fromPartial(U) {
      var se, Se, Ue, De;
      const Ye = Fe();
      return Ye.properties = ((se = U.properties) === null || se === void 0 ? void 0 : se.map((Qe) => Qe)) || [], Ye.durationMs = (Se = U.durationMs) !== null && Se !== void 0 ? Se : 0, Ye.delayMs = (Ue = U.delayMs) !== null && Ue !== void 0 ? Ue : void 0, Ye.easingMode = (De = U.easingMode) !== null && De !== void 0 ? De : void 0, Ye;
    }
  };
  function yt() {
    return {
      type: void 0,
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: void 0,
      opacity: void 0,
      scale: void 0,
      hidden: void 0,
      children: void 0,
      parentId: void 0,
      metadata: void 0,
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.PartialLayer = {
    encode(U, se = _.Writer.create()) {
      U.type !== void 0 && se.uint32(10).string(U.type), U.data !== void 0 && I.Struct.encode(I.Struct.wrap(U.data), se.uint32(18).fork()).ldelim(), U.x !== void 0 && I.Value.encode(I.Value.wrap(U.x), se.uint32(26).fork()).ldelim(), U.y !== void 0 && I.Value.encode(I.Value.wrap(U.y), se.uint32(34).fork()).ldelim(), U.width !== void 0 && I.Value.encode(I.Value.wrap(U.width), se.uint32(42).fork()).ldelim(), U.height !== void 0 && I.Value.encode(I.Value.wrap(U.height), se.uint32(50).fork()).ldelim(), U.rotation !== void 0 && se.uint32(57).double(U.rotation), U.opacity !== void 0 && se.uint32(65).double(U.opacity), U.scale !== void 0 && se.uint32(73).double(U.scale), U.hidden !== void 0 && se.uint32(80).bool(U.hidden), U.children !== void 0 && I.ListValue.encode(I.ListValue.wrap(U.children), se.uint32(98).fork()).ldelim(), U.parentId !== void 0 && se.uint32(106).string(U.parentId), U.metadata !== void 0 && I.Value.encode(I.Value.wrap(U.metadata), se.uint32(114).fork()).ldelim(), U.requestMetadata !== void 0 && I.Value.encode(I.Value.wrap(U.requestMetadata), se.uint32(802).fork()).ldelim();
      for (const Se of U.requestAnimation)
        a.LayerAnimation.encode(Se, se.uint32(826).fork()).ldelim();
      return se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = yt();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.type = Se.string();
            break;
          case 2:
            De.data = I.Struct.unwrap(I.Struct.decode(Se, Se.uint32()));
            break;
          case 3:
            De.x = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 4:
            De.y = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 5:
            De.width = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 6:
            De.height = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 7:
            De.rotation = Se.double();
            break;
          case 8:
            De.opacity = Se.double();
            break;
          case 9:
            De.scale = Se.double();
            break;
          case 10:
            De.hidden = Se.bool();
            break;
          case 12:
            De.children = I.ListValue.unwrap(I.ListValue.decode(Se, Se.uint32()));
            break;
          case 13:
            De.parentId = Se.string();
            break;
          case 14:
            De.metadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 100:
            De.requestMetadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 103:
            De.requestAnimation.push(a.LayerAnimation.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        type: Ke(U.type) ? String(U.type) : void 0,
        data: Ze(U.data) ? U.data : void 0,
        x: Ke(U == null ? void 0 : U.x) ? U.x : void 0,
        y: Ke(U == null ? void 0 : U.y) ? U.y : void 0,
        width: Ke(U == null ? void 0 : U.width) ? U.width : void 0,
        height: Ke(U == null ? void 0 : U.height) ? U.height : void 0,
        rotation: Ke(U.rotation) ? Number(U.rotation) : void 0,
        opacity: Ke(U.opacity) ? Number(U.opacity) : void 0,
        scale: Ke(U.scale) ? Number(U.scale) : void 0,
        hidden: Ke(U.hidden) ? !!U.hidden : void 0,
        children: Array.isArray(U.children) ? [...U.children] : void 0,
        parentId: Ke(U.parentId) ? String(U.parentId) : void 0,
        metadata: Ke(U == null ? void 0 : U.metadata) ? U.metadata : void 0,
        requestMetadata: Ke(U == null ? void 0 : U.requestMetadata) ? U.requestMetadata : void 0,
        requestAnimation: Array.isArray(U == null ? void 0 : U.requestAnimation) ? U.requestAnimation.map((se) => a.LayerAnimation.fromJSON(se)) : []
      };
    },
    toJSON(U) {
      const se = {};
      return U.type !== void 0 && (se.type = U.type), U.data !== void 0 && (se.data = U.data), U.x !== void 0 && (se.x = U.x), U.y !== void 0 && (se.y = U.y), U.width !== void 0 && (se.width = U.width), U.height !== void 0 && (se.height = U.height), U.rotation !== void 0 && (se.rotation = U.rotation), U.opacity !== void 0 && (se.opacity = U.opacity), U.scale !== void 0 && (se.scale = U.scale), U.hidden !== void 0 && (se.hidden = U.hidden), U.children !== void 0 && (se.children = U.children), U.parentId !== void 0 && (se.parentId = U.parentId), U.metadata !== void 0 && (se.metadata = U.metadata), U.requestMetadata !== void 0 && (se.requestMetadata = U.requestMetadata), U.requestAnimation ? se.requestAnimation = U.requestAnimation.map((Se) => Se ? a.LayerAnimation.toJSON(Se) : void 0) : se.requestAnimation = [], se;
    },
    fromPartial(U) {
      var se, Se, Ue, De, Ye, Qe, st, St, tt, it, Tt, rt, dt, wt, nt;
      const at = yt();
      return at.type = (se = U.type) !== null && se !== void 0 ? se : void 0, at.data = (Se = U.data) !== null && Se !== void 0 ? Se : void 0, at.x = (Ue = U.x) !== null && Ue !== void 0 ? Ue : void 0, at.y = (De = U.y) !== null && De !== void 0 ? De : void 0, at.width = (Ye = U.width) !== null && Ye !== void 0 ? Ye : void 0, at.height = (Qe = U.height) !== null && Qe !== void 0 ? Qe : void 0, at.rotation = (st = U.rotation) !== null && st !== void 0 ? st : void 0, at.opacity = (St = U.opacity) !== null && St !== void 0 ? St : void 0, at.scale = (tt = U.scale) !== null && tt !== void 0 ? tt : void 0, at.hidden = (it = U.hidden) !== null && it !== void 0 ? it : void 0, at.children = (Tt = U.children) !== null && Tt !== void 0 ? Tt : void 0, at.parentId = (rt = U.parentId) !== null && rt !== void 0 ? rt : void 0, at.metadata = (dt = U.metadata) !== null && dt !== void 0 ? dt : void 0, at.requestMetadata = (wt = U.requestMetadata) !== null && wt !== void 0 ? wt : void 0, at.requestAnimation = ((nt = U.requestAnimation) === null || nt === void 0 ? void 0 : nt.map((gt) => a.LayerAnimation.fromPartial(gt))) || [], at;
    }
  };
  function Xe() {
    return {
      id: "",
      type: void 0,
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: void 0,
      opacity: void 0,
      scale: void 0,
      hidden: void 0,
      children: void 0,
      parentId: void 0,
      metadata: void 0,
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.PartialLayerWithID = {
    encode(U, se = _.Writer.create()) {
      U.id !== "" && se.uint32(8002).string(U.id), U.type !== void 0 && se.uint32(10).string(U.type), U.data !== void 0 && I.Struct.encode(I.Struct.wrap(U.data), se.uint32(18).fork()).ldelim(), U.x !== void 0 && I.Value.encode(I.Value.wrap(U.x), se.uint32(26).fork()).ldelim(), U.y !== void 0 && I.Value.encode(I.Value.wrap(U.y), se.uint32(34).fork()).ldelim(), U.width !== void 0 && I.Value.encode(I.Value.wrap(U.width), se.uint32(42).fork()).ldelim(), U.height !== void 0 && I.Value.encode(I.Value.wrap(U.height), se.uint32(50).fork()).ldelim(), U.rotation !== void 0 && se.uint32(57).double(U.rotation), U.opacity !== void 0 && se.uint32(65).double(U.opacity), U.scale !== void 0 && se.uint32(73).double(U.scale), U.hidden !== void 0 && se.uint32(80).bool(U.hidden), U.children !== void 0 && I.ListValue.encode(I.ListValue.wrap(U.children), se.uint32(98).fork()).ldelim(), U.parentId !== void 0 && se.uint32(106).string(U.parentId), U.metadata !== void 0 && I.Value.encode(I.Value.wrap(U.metadata), se.uint32(114).fork()).ldelim(), U.requestMetadata !== void 0 && I.Value.encode(I.Value.wrap(U.requestMetadata), se.uint32(802).fork()).ldelim();
      for (const Se of U.requestAnimation)
        a.LayerAnimation.encode(Se, se.uint32(826).fork()).ldelim();
      return se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = Xe();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1e3:
            De.id = Se.string();
            break;
          case 1:
            De.type = Se.string();
            break;
          case 2:
            De.data = I.Struct.unwrap(I.Struct.decode(Se, Se.uint32()));
            break;
          case 3:
            De.x = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 4:
            De.y = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 5:
            De.width = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 6:
            De.height = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 7:
            De.rotation = Se.double();
            break;
          case 8:
            De.opacity = Se.double();
            break;
          case 9:
            De.scale = Se.double();
            break;
          case 10:
            De.hidden = Se.bool();
            break;
          case 12:
            De.children = I.ListValue.unwrap(I.ListValue.decode(Se, Se.uint32()));
            break;
          case 13:
            De.parentId = Se.string();
            break;
          case 14:
            De.metadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 100:
            De.requestMetadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 103:
            De.requestAnimation.push(a.LayerAnimation.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        id: Ke(U.id) ? String(U.id) : "",
        type: Ke(U.type) ? String(U.type) : void 0,
        data: Ze(U.data) ? U.data : void 0,
        x: Ke(U == null ? void 0 : U.x) ? U.x : void 0,
        y: Ke(U == null ? void 0 : U.y) ? U.y : void 0,
        width: Ke(U == null ? void 0 : U.width) ? U.width : void 0,
        height: Ke(U == null ? void 0 : U.height) ? U.height : void 0,
        rotation: Ke(U.rotation) ? Number(U.rotation) : void 0,
        opacity: Ke(U.opacity) ? Number(U.opacity) : void 0,
        scale: Ke(U.scale) ? Number(U.scale) : void 0,
        hidden: Ke(U.hidden) ? !!U.hidden : void 0,
        children: Array.isArray(U.children) ? [...U.children] : void 0,
        parentId: Ke(U.parentId) ? String(U.parentId) : void 0,
        metadata: Ke(U == null ? void 0 : U.metadata) ? U.metadata : void 0,
        requestMetadata: Ke(U == null ? void 0 : U.requestMetadata) ? U.requestMetadata : void 0,
        requestAnimation: Array.isArray(U == null ? void 0 : U.requestAnimation) ? U.requestAnimation.map((se) => a.LayerAnimation.fromJSON(se)) : []
      };
    },
    toJSON(U) {
      const se = {};
      return U.id !== void 0 && (se.id = U.id), U.type !== void 0 && (se.type = U.type), U.data !== void 0 && (se.data = U.data), U.x !== void 0 && (se.x = U.x), U.y !== void 0 && (se.y = U.y), U.width !== void 0 && (se.width = U.width), U.height !== void 0 && (se.height = U.height), U.rotation !== void 0 && (se.rotation = U.rotation), U.opacity !== void 0 && (se.opacity = U.opacity), U.scale !== void 0 && (se.scale = U.scale), U.hidden !== void 0 && (se.hidden = U.hidden), U.children !== void 0 && (se.children = U.children), U.parentId !== void 0 && (se.parentId = U.parentId), U.metadata !== void 0 && (se.metadata = U.metadata), U.requestMetadata !== void 0 && (se.requestMetadata = U.requestMetadata), U.requestAnimation ? se.requestAnimation = U.requestAnimation.map((Se) => Se ? a.LayerAnimation.toJSON(Se) : void 0) : se.requestAnimation = [], se;
    },
    fromPartial(U) {
      var se, Se, Ue, De, Ye, Qe, st, St, tt, it, Tt, rt, dt, wt, nt, at;
      const gt = Xe();
      return gt.id = (se = U.id) !== null && se !== void 0 ? se : "", gt.type = (Se = U.type) !== null && Se !== void 0 ? Se : void 0, gt.data = (Ue = U.data) !== null && Ue !== void 0 ? Ue : void 0, gt.x = (De = U.x) !== null && De !== void 0 ? De : void 0, gt.y = (Ye = U.y) !== null && Ye !== void 0 ? Ye : void 0, gt.width = (Qe = U.width) !== null && Qe !== void 0 ? Qe : void 0, gt.height = (st = U.height) !== null && st !== void 0 ? st : void 0, gt.rotation = (St = U.rotation) !== null && St !== void 0 ? St : void 0, gt.opacity = (tt = U.opacity) !== null && tt !== void 0 ? tt : void 0, gt.scale = (it = U.scale) !== null && it !== void 0 ? it : void 0, gt.hidden = (Tt = U.hidden) !== null && Tt !== void 0 ? Tt : void 0, gt.children = (rt = U.children) !== null && rt !== void 0 ? rt : void 0, gt.parentId = (dt = U.parentId) !== null && dt !== void 0 ? dt : void 0, gt.metadata = (wt = U.metadata) !== null && wt !== void 0 ? wt : void 0, gt.requestMetadata = (nt = U.requestMetadata) !== null && nt !== void 0 ? nt : void 0, gt.requestAnimation = ((at = U.requestAnimation) === null || at === void 0 ? void 0 : at.map((ot) => a.LayerAnimation.fromPartial(ot))) || [], gt;
    }
  };
  function Ge() {
    return { layoutId: "" };
  }
  a.ListLayersRequest = {
    encode(U, se = _.Writer.create()) {
      return U.layoutId !== "" && se.uint32(10).string(U.layoutId), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = Ge();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.layoutId = Se.string();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layoutId: Ke(U.layoutId) ? String(U.layoutId) : ""
      };
    },
    toJSON(U) {
      const se = {};
      return U.layoutId !== void 0 && (se.layoutId = U.layoutId), se;
    },
    fromPartial(U) {
      var se;
      const Se = Ge();
      return Se.layoutId = (se = U.layoutId) !== null && se !== void 0 ? se : "", Se;
    }
  };
  function V() {
    return { layers: [] };
  }
  a.ListLayersResponse = {
    encode(U, se = _.Writer.create()) {
      for (const Se of U.layers)
        a.Layer.encode(Se, se.uint32(10).fork()).ldelim();
      return se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = V();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.layers.push(a.Layer.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layers: Array.isArray(U == null ? void 0 : U.layers) ? U.layers.map((se) => a.Layer.fromJSON(se)) : []
      };
    },
    toJSON(U) {
      const se = {};
      return U.layers ? se.layers = U.layers.map((Se) => Se ? a.Layer.toJSON(Se) : void 0) : se.layers = [], se;
    },
    fromPartial(U) {
      var se;
      const Se = V();
      return Se.layers = ((se = U.layers) === null || se === void 0 ? void 0 : se.map((Ue) => a.Layer.fromPartial(Ue))) || [], Se;
    }
  };
  function ge() {
    return { layoutId: "", layer: void 0 };
  }
  a.CreateLayerRequest = {
    encode(U, se = _.Writer.create()) {
      return U.layoutId !== "" && se.uint32(10).string(U.layoutId), U.layer !== void 0 && a.PartialLayer.encode(U.layer, se.uint32(18).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = ge();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.layoutId = Se.string();
            break;
          case 2:
            De.layer = a.PartialLayer.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layoutId: Ke(U.layoutId) ? String(U.layoutId) : "",
        layer: Ke(U.layer) ? a.PartialLayer.fromJSON(U.layer) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.layoutId !== void 0 && (se.layoutId = U.layoutId), U.layer !== void 0 && (se.layer = U.layer ? a.PartialLayer.toJSON(U.layer) : void 0), se;
    },
    fromPartial(U) {
      var se;
      const Se = ge();
      return Se.layoutId = (se = U.layoutId) !== null && se !== void 0 ? se : "", Se.layer = U.layer !== void 0 && U.layer !== null ? a.PartialLayer.fromPartial(U.layer) : void 0, Se;
    }
  };
  function Te() {
    return { layoutId: "", layerId: "" };
  }
  a.GetLayerRequest = {
    encode(U, se = _.Writer.create()) {
      return U.layoutId !== "" && se.uint32(10).string(U.layoutId), U.layerId !== "" && se.uint32(18).string(U.layerId), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = Te();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.layoutId = Se.string();
            break;
          case 2:
            De.layerId = Se.string();
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layoutId: Ke(U.layoutId) ? String(U.layoutId) : "",
        layerId: Ke(U.layerId) ? String(U.layerId) : ""
      };
    },
    toJSON(U) {
      const se = {};
      return U.layoutId !== void 0 && (se.layoutId = U.layoutId), U.layerId !== void 0 && (se.layerId = U.layerId), se;
    },
    fromPartial(U) {
      var se, Se;
      const Ue = Te();
      return Ue.layoutId = (se = U.layoutId) !== null && se !== void 0 ? se : "", Ue.layerId = (Se = U.layerId) !== null && Se !== void 0 ? Se : "", Ue;
    }
  };
  function We() {
    return { layoutId: "", layerId: "", layer: void 0 };
  }
  a.UpdateLayerRequest = {
    encode(U, se = _.Writer.create()) {
      return U.layoutId !== "" && se.uint32(10).string(U.layoutId), U.layerId !== "" && se.uint32(18).string(U.layerId), U.layer !== void 0 && a.PartialLayer.encode(U.layer, se.uint32(26).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = We();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.layoutId = Se.string();
            break;
          case 2:
            De.layerId = Se.string();
            break;
          case 3:
            De.layer = a.PartialLayer.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layoutId: Ke(U.layoutId) ? String(U.layoutId) : "",
        layerId: Ke(U.layerId) ? String(U.layerId) : "",
        layer: Ke(U.layer) ? a.PartialLayer.fromJSON(U.layer) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.layoutId !== void 0 && (se.layoutId = U.layoutId), U.layerId !== void 0 && (se.layerId = U.layerId), U.layer !== void 0 && (se.layer = U.layer ? a.PartialLayer.toJSON(U.layer) : void 0), se;
    },
    fromPartial(U) {
      var se, Se;
      const Ue = We();
      return Ue.layoutId = (se = U.layoutId) !== null && se !== void 0 ? se : "", Ue.layerId = (Se = U.layerId) !== null && Se !== void 0 ? Se : "", Ue.layer = U.layer !== void 0 && U.layer !== null ? a.PartialLayer.fromPartial(U.layer) : void 0, Ue;
    }
  };
  function Re() {
    return { requestMetadata: void 0 };
  }
  a.DeleteLayerPayload = {
    encode(U, se = _.Writer.create()) {
      return U.requestMetadata !== void 0 && I.Value.encode(I.Value.wrap(U.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = Re();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 100:
            De.requestMetadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        requestMetadata: Ke(U == null ? void 0 : U.requestMetadata) ? U.requestMetadata : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.requestMetadata !== void 0 && (se.requestMetadata = U.requestMetadata), se;
    },
    fromPartial(U) {
      var se;
      const Se = Re();
      return Se.requestMetadata = (se = U.requestMetadata) !== null && se !== void 0 ? se : void 0, Se;
    }
  };
  function J() {
    return { id: "", requestMetadata: void 0 };
  }
  a.BatchDeleteLayerRequest = {
    encode(U, se = _.Writer.create()) {
      return U.id !== "" && se.uint32(10).string(U.id), U.requestMetadata !== void 0 && I.Value.encode(I.Value.wrap(U.requestMetadata), se.uint32(802).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = J();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.id = Se.string();
            break;
          case 100:
            De.requestMetadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        id: Ke(U.id) ? String(U.id) : "",
        requestMetadata: Ke(U == null ? void 0 : U.requestMetadata) ? U.requestMetadata : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.id !== void 0 && (se.id = U.id), U.requestMetadata !== void 0 && (se.requestMetadata = U.requestMetadata), se;
    },
    fromPartial(U) {
      var se, Se;
      const Ue = J();
      return Ue.id = (se = U.id) !== null && se !== void 0 ? se : "", Ue.requestMetadata = (Se = U.requestMetadata) !== null && Se !== void 0 ? Se : void 0, Ue;
    }
  };
  function Ee() {
    return {
      layoutId: "",
      layers: [],
      requestMetadata: void 0,
      requestAnimationMode: void 0
    };
  }
  a.BatchLayerRequest = {
    encode(U, se = _.Writer.create()) {
      U.layoutId !== "" && se.uint32(10).string(U.layoutId);
      for (const Se of U.layers)
        a.BatchLayerRequest_BatchItem.encode(Se, se.uint32(18).fork()).ldelim();
      return U.requestMetadata !== void 0 && I.Value.encode(I.Value.wrap(U.requestMetadata), se.uint32(802).fork()).ldelim(), U.requestAnimationMode !== void 0 && se.uint32(808).int32(ie(U.requestAnimationMode)), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = Ee();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.layoutId = Se.string();
            break;
          case 2:
            De.layers.push(a.BatchLayerRequest_BatchItem.decode(Se, Se.uint32()));
            break;
          case 100:
            De.requestMetadata = I.Value.unwrap(I.Value.decode(Se, Se.uint32()));
            break;
          case 101:
            De.requestAnimationMode = ee(Se.int32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layoutId: Ke(U.layoutId) ? String(U.layoutId) : "",
        layers: Array.isArray(U == null ? void 0 : U.layers) ? U.layers.map((se) => a.BatchLayerRequest_BatchItem.fromJSON(se)) : [],
        requestMetadata: Ke(U == null ? void 0 : U.requestMetadata) ? U.requestMetadata : void 0,
        requestAnimationMode: Ke(U.requestAnimationMode) ? ee(U.requestAnimationMode) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.layoutId !== void 0 && (se.layoutId = U.layoutId), U.layers ? se.layers = U.layers.map((Se) => Se ? a.BatchLayerRequest_BatchItem.toJSON(Se) : void 0) : se.layers = [], U.requestMetadata !== void 0 && (se.requestMetadata = U.requestMetadata), U.requestAnimationMode !== void 0 && (se.requestAnimationMode = U.requestAnimationMode !== void 0 ? X(U.requestAnimationMode) : void 0), se;
    },
    fromPartial(U) {
      var se, Se, Ue, De;
      const Ye = Ee();
      return Ye.layoutId = (se = U.layoutId) !== null && se !== void 0 ? se : "", Ye.layers = ((Se = U.layers) === null || Se === void 0 ? void 0 : Se.map((Qe) => a.BatchLayerRequest_BatchItem.fromPartial(Qe))) || [], Ye.requestMetadata = (Ue = U.requestMetadata) !== null && Ue !== void 0 ? Ue : void 0, Ye.requestAnimationMode = (De = U.requestAnimationMode) !== null && De !== void 0 ? De : void 0, Ye;
    }
  };
  function ue() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.BatchLayerRequest_BatchItem = {
    encode(U, se = _.Writer.create()) {
      return U.create !== void 0 && a.PartialLayer.encode(U.create, se.uint32(10).fork()).ldelim(), U.update !== void 0 && a.PartialLayerWithID.encode(U.update, se.uint32(18).fork()).ldelim(), U.delete !== void 0 && a.BatchDeleteLayerRequest.encode(U.delete, se.uint32(26).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = ue();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.create = a.PartialLayer.decode(Se, Se.uint32());
            break;
          case 2:
            De.update = a.PartialLayerWithID.decode(Se, Se.uint32());
            break;
          case 3:
            De.delete = a.BatchDeleteLayerRequest.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        create: Ke(U.create) ? a.PartialLayer.fromJSON(U.create) : void 0,
        update: Ke(U.update) ? a.PartialLayerWithID.fromJSON(U.update) : void 0,
        delete: Ke(U.delete) ? a.BatchDeleteLayerRequest.fromJSON(U.delete) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.create !== void 0 && (se.create = U.create ? a.PartialLayer.toJSON(U.create) : void 0), U.update !== void 0 && (se.update = U.update ? a.PartialLayerWithID.toJSON(U.update) : void 0), U.delete !== void 0 && (se.delete = U.delete ? a.BatchDeleteLayerRequest.toJSON(U.delete) : void 0), se;
    },
    fromPartial(U) {
      const se = ue();
      return se.create = U.create !== void 0 && U.create !== null ? a.PartialLayer.fromPartial(U.create) : void 0, se.update = U.update !== void 0 && U.update !== null ? a.PartialLayerWithID.fromPartial(U.update) : void 0, se.delete = U.delete !== void 0 && U.delete !== null ? a.BatchDeleteLayerRequest.fromPartial(U.delete) : void 0, se;
    }
  };
  function ce() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.LayoutEvent = {
    encode(U, se = _.Writer.create()) {
      return U.create !== void 0 && a.Layout.encode(U.create, se.uint32(10).fork()).ldelim(), U.update !== void 0 && a.Layout.encode(U.update, se.uint32(18).fork()).ldelim(), U.delete !== void 0 && a.DeleteLayoutResponse.encode(U.delete, se.uint32(26).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = ce();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.create = a.Layout.decode(Se, Se.uint32());
            break;
          case 2:
            De.update = a.Layout.decode(Se, Se.uint32());
            break;
          case 3:
            De.delete = a.DeleteLayoutResponse.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        create: Ke(U.create) ? a.Layout.fromJSON(U.create) : void 0,
        update: Ke(U.update) ? a.Layout.fromJSON(U.update) : void 0,
        delete: Ke(U.delete) ? a.DeleteLayoutResponse.fromJSON(U.delete) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.create !== void 0 && (se.create = U.create ? a.Layout.toJSON(U.create) : void 0), U.update !== void 0 && (se.update = U.update ? a.Layout.toJSON(U.update) : void 0), U.delete !== void 0 && (se.delete = U.delete ? a.DeleteLayoutResponse.toJSON(U.delete) : void 0), se;
    },
    fromPartial(U) {
      const se = ce();
      return se.create = U.create !== void 0 && U.create !== null ? a.Layout.fromPartial(U.create) : void 0, se.update = U.update !== void 0 && U.update !== null ? a.Layout.fromPartial(U.update) : void 0, se.delete = U.delete !== void 0 && U.delete !== null ? a.DeleteLayoutResponse.fromPartial(U.delete) : void 0, se;
    }
  };
  function ve() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      batch: void 0
    };
  }
  a.LayerEvent = {
    encode(U, se = _.Writer.create()) {
      return U.create !== void 0 && a.Layer.encode(U.create, se.uint32(10).fork()).ldelim(), U.update !== void 0 && a.Layer.encode(U.update, se.uint32(18).fork()).ldelim(), U.delete !== void 0 && a.DeleteLayerResponse.encode(U.delete, se.uint32(26).fork()).ldelim(), U.batch !== void 0 && a.BatchLayerResponse.encode(U.batch, se.uint32(34).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = ve();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.create = a.Layer.decode(Se, Se.uint32());
            break;
          case 2:
            De.update = a.Layer.decode(Se, Se.uint32());
            break;
          case 3:
            De.delete = a.DeleteLayerResponse.decode(Se, Se.uint32());
            break;
          case 4:
            De.batch = a.BatchLayerResponse.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        create: Ke(U.create) ? a.Layer.fromJSON(U.create) : void 0,
        update: Ke(U.update) ? a.Layer.fromJSON(U.update) : void 0,
        delete: Ke(U.delete) ? a.DeleteLayerResponse.fromJSON(U.delete) : void 0,
        batch: Ke(U.batch) ? a.BatchLayerResponse.fromJSON(U.batch) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.create !== void 0 && (se.create = U.create ? a.Layer.toJSON(U.create) : void 0), U.update !== void 0 && (se.update = U.update ? a.Layer.toJSON(U.update) : void 0), U.delete !== void 0 && (se.delete = U.delete ? a.DeleteLayerResponse.toJSON(U.delete) : void 0), U.batch !== void 0 && (se.batch = U.batch ? a.BatchLayerResponse.toJSON(U.batch) : void 0), se;
    },
    fromPartial(U) {
      const se = ve();
      return se.create = U.create !== void 0 && U.create !== null ? a.Layer.fromPartial(U.create) : void 0, se.update = U.update !== void 0 && U.update !== null ? a.Layer.fromPartial(U.update) : void 0, se.delete = U.delete !== void 0 && U.delete !== null ? a.DeleteLayerResponse.fromPartial(U.delete) : void 0, se.batch = U.batch !== void 0 && U.batch !== null ? a.BatchLayerResponse.fromPartial(U.batch) : void 0, se;
    }
  };
  function Ce() {
    return { layout: void 0, layer: void 0 };
  }
  a.Event = {
    encode(U, se = _.Writer.create()) {
      return U.layout !== void 0 && a.LayoutEvent.encode(U.layout, se.uint32(10).fork()).ldelim(), U.layer !== void 0 && a.LayerEvent.encode(U.layer, se.uint32(18).fork()).ldelim(), se;
    },
    decode(U, se) {
      const Se = U instanceof _.Reader ? U : new _.Reader(U);
      let Ue = se === void 0 ? Se.len : Se.pos + se;
      const De = Ce();
      for (; Se.pos < Ue; ) {
        const Ye = Se.uint32();
        switch (Ye >>> 3) {
          case 1:
            De.layout = a.LayoutEvent.decode(Se, Se.uint32());
            break;
          case 2:
            De.layer = a.LayerEvent.decode(Se, Se.uint32());
            break;
          default:
            Se.skipType(Ye & 7);
            break;
        }
      }
      return De;
    },
    fromJSON(U) {
      return {
        layout: Ke(U.layout) ? a.LayoutEvent.fromJSON(U.layout) : void 0,
        layer: Ke(U.layer) ? a.LayerEvent.fromJSON(U.layer) : void 0
      };
    },
    toJSON(U) {
      const se = {};
      return U.layout !== void 0 && (se.layout = U.layout ? a.LayoutEvent.toJSON(U.layout) : void 0), U.layer !== void 0 && (se.layer = U.layer ? a.LayerEvent.toJSON(U.layer) : void 0), se;
    },
    fromPartial(U) {
      const se = Ce();
      return se.layout = U.layout !== void 0 && U.layout !== null ? a.LayoutEvent.fromPartial(U.layout) : void 0, se.layer = U.layer !== void 0 && U.layer !== null ? a.LayerEvent.fromPartial(U.layer) : void 0, se;
    }
  };
  class Be {
    constructor(se) {
      this.rpc = se, this.ListLayers = this.ListLayers.bind(this), this.CreateLayer = this.CreateLayer.bind(this), this.GetLayer = this.GetLayer.bind(this), this.UpdateLayer = this.UpdateLayer.bind(this), this.DeleteLayer = this.DeleteLayer.bind(this), this.Batch = this.Batch.bind(this);
    }
    ListLayers(se) {
      const Se = a.ListLayersRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "ListLayers", Se).then((De) => a.ListLayersResponse.decode(new _.Reader(De)));
    }
    CreateLayer(se) {
      const Se = a.CreateLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "CreateLayer", Se).then((De) => a.Layer.decode(new _.Reader(De)));
    }
    GetLayer(se) {
      const Se = a.GetLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "GetLayer", Se).then((De) => a.Layer.decode(new _.Reader(De)));
    }
    UpdateLayer(se) {
      const Se = a.UpdateLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "UpdateLayer", Se).then((De) => a.Layer.decode(new _.Reader(De)));
    }
    DeleteLayer(se) {
      const Se = a.DeleteLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "DeleteLayer", Se).then((De) => a.DeleteLayerResponse.decode(new _.Reader(De)));
    }
    Batch(se) {
      const Se = a.BatchLayerRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "Batch", Se).then((De) => a.BatchLayerResponse.decode(new _.Reader(De)));
    }
  }
  a.LayerServiceClientImpl = Be, a.LayerServiceDefinition = {
    name: "LayerService",
    fullName: "apis.layout.v2.LayerService",
    methods: {
      /** List all layers */
      listLayers: {
        name: "ListLayers",
        requestType: a.ListLayersRequest,
        requestStream: !1,
        responseType: a.ListLayersResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create a layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      createLayer: {
        name: "CreateLayer",
        requestType: a.CreateLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /**
       * Get a single layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      getLayer: {
        name: "GetLayer",
        requestType: a.GetLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /**
       * Update a layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      updateLayer: {
        name: "UpdateLayer",
        requestType: a.UpdateLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /** Delete a layer */
      deleteLayer: {
        name: "DeleteLayer",
        requestType: a.DeleteLayerRequest,
        requestStream: !1,
        responseType: a.DeleteLayerResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Batch update
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      batch: {
        name: "Batch",
        requestType: a.BatchLayerRequest,
        requestStream: !1,
        responseType: a.BatchLayerResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class He {
    constructor(se) {
      this.rpc = se, this.ListLayouts = this.ListLayouts.bind(this), this.CreateLayout = this.CreateLayout.bind(this), this.GetLayout = this.GetLayout.bind(this), this.UpdateLayout = this.UpdateLayout.bind(this), this.DeleteLayout = this.DeleteLayout.bind(this);
    }
    ListLayouts(se) {
      const Se = a.ListLayoutsRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "ListLayouts", Se).then((De) => a.ListLayoutsResponse.decode(new _.Reader(De)));
    }
    CreateLayout(se) {
      const Se = a.CreateLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "CreateLayout", Se).then((De) => a.Layout.decode(new _.Reader(De)));
    }
    GetLayout(se) {
      const Se = a.GetLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "GetLayout", Se).then((De) => a.Layout.decode(new _.Reader(De)));
    }
    UpdateLayout(se) {
      const Se = a.UpdateLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "UpdateLayout", Se).then((De) => a.Layout.decode(new _.Reader(De)));
    }
    DeleteLayout(se) {
      const Se = a.DeleteLayoutRequest.encode(se).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "DeleteLayout", Se).then((De) => a.DeleteLayoutResponse.decode(new _.Reader(De)));
    }
  }
  a.LayoutServiceClientImpl = He, a.LayoutServiceDefinition = {
    name: "LayoutService",
    fullName: "apis.layout.v2.LayoutService",
    methods: {
      /** Get all layouts owned by the user. */
      listLayouts: {
        name: "ListLayouts",
        requestType: a.ListLayoutsRequest,
        requestStream: !1,
        responseType: a.ListLayoutsResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create a new layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      createLayout: {
        name: "CreateLayout",
        requestType: a.CreateLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /**
       * Get a layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      getLayout: {
        name: "GetLayout",
        requestType: a.GetLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /**
       * Update a layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      updateLayout: {
        name: "UpdateLayout",
        requestType: a.UpdateLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /** Delete a layout */
      deleteLayout: {
        name: "DeleteLayout",
        requestType: a.DeleteLayoutRequest,
        requestStream: !1,
        responseType: a.DeleteLayoutResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var Ve = (() => {
    if (typeof Ve < "u")
      return Ve;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function Ze(U) {
    return typeof U == "object" && U !== null;
  }
  function Ke(U) {
    return U != null;
  }
})(api$4);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(v, p, _, I) {
    I === void 0 && (I = _), Object.defineProperty(v, I, { enumerable: !0, get: function() {
      return p[_];
    } });
  } : function(v, p, _, I) {
    I === void 0 && (I = _), v[I] = p[_];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(v, p) {
    for (var _ in v)
      _ !== "default" && !p.hasOwnProperty(_) && u(p, v, _);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.layoutApiEventMap = void 0;
  const l = api$4;
  c(api$4, a), a.layoutApiEventMap = {
    [l.EventType.EVENT_TYPE_LAYOUT]: "layout",
    [l.EventType.EVENT_TYPE_LAYER]: "layer",
    [l.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified"
  };
})(dist$2);
var api$3 = {}, browser$f = !1;
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$3 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var logger = {};
class EnhancedMap extends Map {
  /**
   * If key has a mapping already returns the currently associated value. If
   * there is no mapping, calls the computer which must return a value V.
   * The value is then stored for given key and returned.
   * @param key Key
   * @param computer Computer which is called only if key has no mapping yet.
   * @return Existing value if the key already existed, or the newly computed value.
   */
  computeIfAbsent(u, c) {
    if (this.has(u))
      return this.get(u);
    const l = c(u);
    return this.set(u, l), l;
  }
  /**
   * If the key exists already calls given computer, if the key does not exist
   * this method does nothing.
   *
   * The computer is called with current key and current value associated. The
   * computer can return a (new) value V or undefined. When undefined is returned
   * the key is removed from this map, when a V is returned the key is updated
   * with the new value V.
   * @param key Key
   * @param computer Computer which is called only if the key has a mapping already
   * @return Undefined if the key has no mapping, otherwise the value returned from computer
   */
  computeIfPresent(u, c) {
    const l = this.get(u);
    if (l === void 0)
      return;
    const v = c(u, l);
    return v !== void 0 ? this.set(u, v) : this.delete(u), v;
  }
  /**
   * Computes a value for given key, the computer can return a value V (in which case the map
   * will set the value for given key), if it returns undefined the mapping for key K will be
   * removed.
   * @param key Key to compute
   * @param computer Computer which is called, note that the currentValue argument contains the existing
   *                 value or is undefined when no mapping exists for the key.
   * @return The newly computed value
   */
  compute(u, c) {
    const l = this.get(u), v = c(u, l);
    return v ? this.set(u, v) : this.delete(u), v;
  }
}
var InternalLogLevel;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error";
})(InternalLogLevel || (InternalLogLevel = {}));
function getInternalLogger(a) {
  return provider.getLogger(a);
}
const INTERNAL_LOGGING_SETTINGS = {
  /**
   * Changes the log level for the internal logging (for all new and existing loggers)
   * @param level New log level
   */
  setInternalLogLevel: (a) => provider.changeLogLevel(a),
  /**
   * Changes where messages are written to for all new and existing loggers),
   * by default they are written to the console.
   * @param fnOutput Function to write messages to
   */
  setOutput: (a) => provider.changeOutput(a),
  /**
   * Resets the log level and output back to defaults (level to error and writing to console)
   * for all new and existing loggers.
   */
  reset: () => provider.reset()
};
class InternalLoggerImpl {
  constructor(u, c, l) {
    this._name = u, this._level = c, this._fnOutput = l;
  }
  trace(u) {
    this.log(InternalLogLevel.Trace, u);
  }
  debug(u) {
    this.log(InternalLogLevel.Debug, u);
  }
  error(u, c) {
    this.log(InternalLogLevel.Error, u, c);
  }
  info(u) {
    this.log(InternalLogLevel.Info, u);
  }
  warn(u, c) {
    this.log(InternalLogLevel.Warn, u, c);
  }
  setLevel(u) {
    this._level = u;
  }
  setOutput(u) {
    this._fnOutput = u;
  }
  log(u, c, l) {
    this._level > u || this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${c()}${l ? `
` + l.stack : ""}`);
  }
}
class InternalProviderImpl {
  constructor() {
    this._loggers = new EnhancedMap(), this._logLevel = InternalLogLevel.Error, this._fnOutput = InternalProviderImpl.logConsole;
  }
  getLogger(u) {
    return this._loggers.computeIfAbsent(u, (c) => new InternalLoggerImpl(c, this._logLevel, this._fnOutput));
  }
  changeLogLevel(u) {
    this._logLevel = u, this._loggers.forEach((c) => c.setLevel(u));
  }
  changeOutput(u) {
    this._fnOutput = u, this._loggers.forEach((c) => c.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel.Error), this._fnOutput = InternalProviderImpl.logConsole, this._loggers.forEach((u) => u.setOutput(this._fnOutput));
  }
  static logConsole(u) {
    console && console.log && console.log(u);
  }
}
const provider = new InternalProviderImpl();
var InternalLogger = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get InternalLogLevel() {
    return InternalLogLevel;
  },
  getInternalLogger,
  INTERNAL_LOGGING_SETTINGS
}), LogLevel$1;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error", a[a.Fatal = 5] = "Fatal";
})(LogLevel$1 || (LogLevel$1 = {}));
(function(a) {
  function u(c) {
    switch (c.toLowerCase()) {
      case "trace":
        return a.Trace;
      case "debug":
        return a.Debug;
      case "info":
        return a.Info;
      case "warn":
        return a.Warn;
      case "error":
        return a.Error;
      case "fatal":
        return a.Fatal;
      default:
        return;
    }
  }
  a.toLogLevel = u;
})(LogLevel$1 || (LogLevel$1 = {}));
class CoreLoggerImpl {
  constructor(u) {
    this._runtime = u;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(u) {
    this._runtime = u;
  }
  trace(u, ...c) {
    this.logMessage(LogLevel$1.Trace, u, c);
  }
  debug(u, ...c) {
    this.logMessage(LogLevel$1.Debug, u, c);
  }
  info(u, ...c) {
    this.logMessage(LogLevel$1.Info, u, c);
  }
  warn(u, ...c) {
    this.logMessage(LogLevel$1.Warn, u, c);
  }
  error(u, ...c) {
    this.logMessage(LogLevel$1.Error, u, c);
  }
  fatal(u, ...c) {
    this.logMessage(LogLevel$1.Fatal, u, c);
  }
  logMessage(u, c, l) {
    if (this._runtime.level > u)
      return;
    const v = Date.now(), p = typeof c == "string" ? c : c(), _ = CoreLoggerImpl.getErrorAndArgs(l);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({
          message: p,
          exception: _.error,
          args: _.args,
          timeInMillis: v,
          level: u,
          logNames: this._runtime.name
        }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(p, u, _, v));
        break;
    }
  }
  formatArgValue(u) {
    try {
      return this._runtime.argumentFormatter(u);
    } catch {
      return `>>ARG CONVERT FAILED: '${u !== void 0 ? u.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(u, c, l, v) {
    let p;
    const _ = l.error, I = l.args;
    _ && (p = `${_.name}: ${_.message}`, _.stack && (p += `@
${_.stack}`));
    const P = this._runtime.dateFormatter(v);
    let $ = LogLevel$1[c].toUpperCase();
    $.length < 5 && ($ += " ");
    const F = typeof this._runtime.name == "string" ? this._runtime.name : this._runtime.name.join(", "), H = typeof I < "u" && I.length > 0 ? " [" + I.map((ee) => this.formatArgValue(ee)).join(", ") + "]" : "";
    return {
      message: P + " " + $ + " [" + F + "] " + u + H,
      error: p
    };
  }
  static getErrorAndArgs(u) {
    if (u.length === 0)
      return {};
    let c, l;
    const v = u[0];
    if (v instanceof Error)
      return c = v, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l };
    if (typeof v == "function") {
      const p = v();
      return p instanceof Error ? (c = p, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l }) : u.length === 1 ? Array.isArray(p) ? { args: p.length > 0 ? p : void 0 } : { args: p } : Array.isArray(p) ? { args: [...p, ...u.slice(1)] } : { args: [p, ...u.slice(1)] };
    }
    return { args: u };
  }
}
function padStart(a, u, c = " ") {
  return padInternal(a, u, "start", c);
}
function padEnd(a, u, c = " ") {
  return padInternal(a, u, "end", c);
}
function maxLengthStringValueInArray(a) {
  return a.map((u) => u.length).reduce((u, c) => c > u ? c : u, 0);
}
function padInternal(a, u, c, l = " ") {
  if (u <= a.length)
    return a;
  if (l.length > 1)
    throw new Error(`Fill char must be one char exactly, it is: ${l.length}`);
  const v = u - a.length;
  let p = "";
  for (let _ = 0; _ < v; _++)
    p += l;
  return c === "start" ? p + a : a + p;
}
function formatArgument(a) {
  return a === void 0 ? "undefined" : JSON.stringify(a);
}
function formatDate(a) {
  const u = new Date(a), c = u.getFullYear(), l = padStart((u.getMonth() + 1).toString(), 2, "0"), v = padStart(u.getDate().toString(), 2, "0"), p = padStart(u.getHours().toString(), 2, "0"), _ = padStart(u.getMinutes().toString(), 2, "0"), I = padStart(u.getSeconds().toString(), 2, "0"), P = padStart(u.getMilliseconds().toString(), 2, "0");
  return `${c}-${l}-${v} ${p}:${_}:${I},${P}`;
}
class ConsoleLogChannel {
  constructor() {
    this.type = "LogChannel";
  }
  write(u) {
    console && console.log && console.log(u.message + (u.error ? `
${u.error}` : ""));
  }
}
var DefaultChannels;
(function(a) {
  function u() {
    return new ConsoleLogChannel();
  }
  a.createConsoleChannel = u;
})(DefaultChannels || (DefaultChannels = {}));
class LogProviderImpl {
  constructor(u, c) {
    this._log = getInternalLogger("core.impl.LogProviderImpl"), this._name = u, this._settings = c, this._loggers = new EnhancedMap(), this._idToKeyMap = new EnhancedMap(), this._globalRuntimeSettings = { level: c.level, channel: c.channel }, this._nextLoggerId = 1, this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(u) {
    return this.getOrCreateLogger(u);
  }
  updateLoggerRuntime(u, c) {
    this._log.debug(() => `Updating logger ${u.id} runtime settings using: '${JSON.stringify(c)}'`);
    const l = this._idToKeyMap.get(u.id);
    return l === void 0 ? (this._log.warn(() => `Cannot update logger with id: ${u.id}, it was not found.`), !1) : (this._loggers.computeIfPresent(l, (v, p) => (p.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(p.runtimeSettings, c), p)), !0);
  }
  updateRuntimeSettings(u) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(u)}'`), this._globalRuntimeSettings = {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: u.level !== void 0 ? u.level : this._globalRuntimeSettings.level,
      channel: u.channel !== void 0 ? u.channel : this._globalRuntimeSettings.channel
    }, this._loggers.forEach((c) => c.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(c.runtimeSettings, u));
  }
  /**
   * Removes all state and loggers, it reverts back to as it was after initial construction.
   */
  clear() {
    this._loggers.clear(), this._idToKeyMap.clear(), this._globalRuntimeSettings = Object.assign({}, this._settings), this._nextLoggerId = 1;
  }
  getOrCreateLogger(u) {
    const c = LogProviderImpl.createKey(u), l = this._loggers.computeIfAbsent(c, () => {
      const v = {
        level: this._globalRuntimeSettings.level,
        channel: this._globalRuntimeSettings.channel,
        id: this.nextLoggerId(),
        name: u,
        argumentFormatter: this._settings.argumentFormatter,
        dateFormatter: this._settings.dateFormatter
      };
      return new CoreLoggerImpl(v);
    });
    return this._idToKeyMap.computeIfAbsent(l.id, () => c), l;
  }
  nextLoggerId() {
    const u = this._name + "_" + this._nextLoggerId;
    return this._nextLoggerId++, u;
  }
  static mergeRuntimeSettingsIntoLogRuntime(u, c) {
    return Object.assign(Object.assign({}, u), {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: c.level !== void 0 ? c.level : u.level,
      channel: c.channel !== void 0 ? c.channel : u.channel
    });
  }
  static createKey(u) {
    return typeof u == "string" ? u : u.join(",");
  }
}
function createLogProvider(a, u) {
  return new LogProviderImpl(a, u);
}
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EnhancedMap,
  padStart,
  padEnd,
  maxLengthStringValueInArray
});
class CategoryImpl {
  constructor(u, c, l, v) {
    this._children = [], this._logger = u, this._name = c, this._parent = l, this._fnGetOrCreateChildCategory = v;
  }
  get name() {
    return this._name;
  }
  get parent() {
    return this._parent;
  }
  get path() {
    const u = [];
    let c = this;
    for (; c !== void 0; )
      u.push(c.name), c = c.parent;
    return u.reverse();
  }
  get children() {
    return [...this._children];
  }
  addChild(u) {
    if (u.parent !== this)
      throw new Error(`Cannot add child '${u.name}', expected parent '${this._name} but got ${u.parent ? u.parent.name : "undefined"}'`);
    this._children.push(u);
  }
  getChildCategory(u) {
    const c = this._children.find((l) => l.name === u);
    return c !== void 0 ? c : this._fnGetOrCreateChildCategory(u, this);
  }
  get id() {
    return this._logger.id;
  }
  get logLevel() {
    return this._logger.logLevel;
  }
  get runtimeSettings() {
    return this._logger.runtimeSettings;
  }
  get logger() {
    return this._logger;
  }
  trace(u, ...c) {
    this._logger.trace(u, ...c);
  }
  debug(u, ...c) {
    this._logger.debug(u, ...c);
  }
  info(u, ...c) {
    this._logger.info(u, ...c);
  }
  warn(u, ...c) {
    this._logger.warn(u, ...c);
  }
  error(u, ...c) {
    this._logger.error(u, ...c);
  }
  fatal(u, ...c) {
    this._logger.fatal(u, ...c);
  }
}
const CATEGORY_PATH_SEPARATOR = "#";
class CategoryProviderImpl {
  constructor(u, c) {
    this._name = u, this._initialConfig = c, this._categoryStorage = new CategoryStorage(u, c);
  }
  get name() {
    return this._name;
  }
  get config() {
    return this._initialConfig;
  }
  get runtimeConfig() {
    return this._categoryStorage.getCurrentRuntimeConfig();
  }
  getCategory(u, c) {
    return this._categoryStorage.getOrCreateCategory(u, c);
  }
  updateRuntimeSettingsCategory(u, c) {
    this._categoryStorage.updateRuntimeSettingsCategory(u, c);
  }
  updateRuntimeSettings(u) {
    this._categoryStorage.updateRuntimeSettings(u);
  }
  /** Returns all currently registered categories */
  getRegisteredCategories() {
    return this._categoryStorage.getRegisteredCategories();
  }
  /** Get a category by path, note that paths must be separated by #, e.g. root#child1#child1_1 */
  getCategoryByPath(u) {
    return this._categoryStorage.getCategoryByPath(u);
  }
}
class CategoryStorage {
  constructor(u, c) {
    this._categoriesById = /* @__PURE__ */ new Map(), this._categoriesByPath = /* @__PURE__ */ new Map(), this._categoryProviderName = u, this._allowSameCategoryName = c.allowSameCategoryName, this._logProvider = createLogProvider(u, Object.assign({}, c)), this.getOrCreateCategory = this.getOrCreateCategory.bind(this);
  }
  getOrCreateCategory(u, c) {
    if (u.indexOf(CATEGORY_PATH_SEPARATOR) !== -1)
      throw new Error(`Cannot create category '${u}', name cannot contain a '${CATEGORY_PATH_SEPARATOR}'.`);
    const l = c !== void 0 ? this.getParentCategory(c) : void 0;
    return l === void 0 ? this.getOrCreateRootCategory(u) : this.getOrCreateChildCategory(u, l);
  }
  updateRuntimeSettingsCategory(u, c) {
    if (!u.id.startsWith(this._categoryProviderName))
      throw new Error(`Category '${u.name}' with LogId '${u.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    const l = this._categoriesById.get(u.id);
    l !== void 0 && (this._logProvider.updateLoggerRuntime(l.logger, { level: c.level }), !(c.disableRecursion !== void 0 && c.disableRecursion) && l.children.forEach((v) => this.updateRuntimeSettingsCategory(v, c)));
  }
  updateRuntimeSettings(u) {
    this._logProvider.updateRuntimeSettings(u);
  }
  getCurrentRuntimeConfig() {
    return Object.assign(Object.assign({}, this._logProvider.runtimeSettings), { allowSameCategoryName: this._allowSameCategoryName });
  }
  /** Returns all currently registered categories */
  getRegisteredCategories() {
    return [...this._categoriesById.values()];
  }
  /** Get a category by path, note that paths must be separated by #, e.g. root#child1#child1_1 */
  getCategoryByPath(u) {
    return this._categoriesByPath.get(u);
  }
  getParentCategory(u) {
    let c;
    if (CategoryStorage.isLogId(u)) {
      if (c = this._categoriesById.get(u), c === void 0)
        throw new Error(`Parent category was not found by LogId '${u}'. Are you sure you passed in the correct argument?`);
    } else if (c = this._categoriesById.get(u.id), c === void 0)
      throw new Error(`Parent category '${u.name}' was not found by it's LogId '${u.id}'. Are you sure you passed in the correct parent category?`);
    return c;
  }
  getOrCreateRootCategory(u) {
    const c = this._categoriesByPath.get(u);
    if (c) {
      if (!this._allowSameCategoryName)
        throw new Error(`Category '${u} already exists, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      return c;
    }
    const l = this._logProvider.getLogger(u), v = new CategoryImpl(l, u, void 0, this.getOrCreateCategory);
    return this._categoriesById.set(v.id, v), this._categoriesByPath.set(u, v), v;
  }
  getOrCreateChildCategory(u, c) {
    if (!c.id.startsWith(this._categoryProviderName))
      throw new Error(`Parent category '${c.name}' with LogId '${c.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    const l = [...c.path, u].join(CATEGORY_PATH_SEPARATOR), v = this._categoriesByPath.get(l);
    if (v) {
      if (!this._allowSameCategoryName)
        throw new Error(`Child category '${u} already exists for parent category ${c.name}, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      return v;
    }
    const p = this._logProvider.getLogger(l);
    this._logProvider.updateLoggerRuntime(p, {
      level: c.logger.runtimeSettings.level,
      channel: c.logger.runtimeSettings.channel
    });
    const _ = new CategoryImpl(p, u, c, this.getOrCreateCategory);
    return this._categoriesById.set(_.id, _), this._categoriesByPath.set(_.path.join(CATEGORY_PATH_SEPARATOR), _), c.addChild(_), _;
  }
  static isLogId(u) {
    return typeof u == "string";
  }
}
class CategoryControlProviderImpl {
  constructor(u, c) {
    this._provider = u, this._messageChannel = c, this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(u);
  }
  get name() {
    return this._provider.name;
  }
  /**
   * Shows current settings.
   */
  showSettings() {
    let u = `Available categories (CategoryProvider '${this._provider.name}'):
`;
    const c = this.createCategoryInfoHierarchy(), l = c.size.toString().length, v = index$3.maxLengthStringValueInArray([...c.values()].map((_) => _.category.name + " ".repeat(_.depth))), p = [...c.values()].map((_, I) => CategoryControlProviderImpl.createSettingLineCategory(_, I, l, v));
    u += p.join(`
`) + (p.length > 0 ? `
` : ""), this._messageChannel(u);
  }
  help() {
    const u = `You can use the following commands (CategoryProvider ${this._provider.name}):
  showSettings()
    Shows the current configuration settings.
  update(level: CategoryControlProviderLogLevel, categoryId?: number | string, noRecurse?: boolean)
    Change the log level for a category (by default recursively).
      @param level      The log level to set - must be one of 'trace', 'debug', 'info', 'warn', 'error' or 'fatal'
      @param categoryId The category id or path of a category (e.g. root#child1) to update. Use showSettings() for id and/or name.
                        When omitted, it applies the level to all categories recursively.
  reset()
    Resets the log levels of the config groups back to when this control provider was created.
  save()
    Saves the current log levels for all categories of this provider. Use restore() to load last saved state.
  restore()
    Restore stored saved state, if any. Log levels will be set according to the saved state.
  help()
    Shows this help.
`;
    this._messageChannel(u);
  }
  reset() {
    const u = new Map(this._provider.getRegisteredCategories().map((c) => [c.id, c]));
    this._originalLogLevels.forEach((c, l) => {
      const v = u.get(l);
      v !== void 0 && this._provider.updateRuntimeSettingsCategory(v, { level: c, disableRecursion: !0 }), u.delete(l);
    }), u.forEach((c) => {
      c.parent !== void 0 && this._provider.updateRuntimeSettingsCategory(c, { level: c.parent.logLevel, disableRecursion: !0 });
    }), this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider), this._messageChannel("Successfully reset log levels back to original state (from when this CategoryControlProvider was created).");
  }
  save() {
    if (!localStorage) {
      this._messageChannel("Cannot save state, localStorage is not available.");
      return;
    }
    const u = this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).map((l) => CategoryControlProviderImpl.createCategorySaveData(l)), c = {
      name: this._provider.name,
      rootCategories: u
    };
    localStorage.setItem(this.createKey(), JSON.stringify(c)), this._messageChannel(`Successfully saved state for CategoryControlProvider '${this._provider.name}'.`);
  }
  restore(u) {
    const c = u !== void 0 ? u : !0;
    if (!localStorage) {
      c && this._messageChannel(`Will not attempt to restore state for CategoryControlProvider '${this._provider.name}', localStorage is not available.`);
      return;
    }
    const l = this.createKey(), v = localStorage.getItem(l);
    if (v === null) {
      c && this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', no data available.`);
      return;
    }
    try {
      const p = JSON.parse(v);
      if (this._provider.name !== p.name) {
        c && this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not for provider - found name '${p.name}'.`);
        return;
      }
      this.restoreBySaveData(p, c), this._messageChannel(`Successfully restored state for CategoryControlProvider '${this._provider.name}'`), this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider);
    } catch {
      localStorage.removeItem(l), this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not valid. Invalid data removed from localStorage.`);
    }
  }
  update(u, c, l) {
    typeof c > "u" ? this.updateAll(u) : typeof c == "number" ? this.updateByIndex(u, c, l !== void 0 ? l : !1) : this.updateByPath(u, c, l !== void 0 ? l : !1);
  }
  updateAll(u) {
    const c = LogLevel$1.toLogLevel(u);
    this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).forEach((l) => this._provider.updateRuntimeSettingsCategory(l, { level: c })), this._messageChannel(`Updated all categories to use log level '${u.toLowerCase()}'`);
  }
  updateByPath(u, c, l) {
    const v = this._provider.getCategoryByPath(c);
    if (v === void 0) {
      this._messageChannel(`Failed to find a provider by path '${c}', please make sure to separate the parts by a ${CATEGORY_PATH_SEPARATOR}.`);
      return;
    }
    this._provider.updateRuntimeSettingsCategory(v, { level: LogLevel$1.toLogLevel(u), disableRecursion: l }), this._messageChannel(`Successfully updated category '${v.name}' with path '${c}' to log level '${u.toLowerCase()}'${l ? "" : " and recursively applied to children (if any)"}.`);
  }
  updateByIndex(u, c, l) {
    if (c < 0) {
      this._messageChannel(`Cannot update category by index '${c}', it is negative.`);
      return;
    }
    const v = this.createCategoryInfoHierarchy();
    if (c >= v.size) {
      this._messageChannel(`Cannot update category by index '${c}', it is outside of the range of available categories, use showSettings() to see the indices.`);
      return;
    }
    const p = [...v.values()][c].category;
    this._provider.updateRuntimeSettingsCategory(p, { level: LogLevel$1.toLogLevel(u), disableRecursion: l }), this._messageChannel(`Successfully updated category '${p.name}' by index '${c}' to log level '${u.toLowerCase()}'${l ? "" : " and recursively applied to children (if any)"}.`);
  }
  restoreBySaveData(u, c) {
    const l = (v, p) => {
      const _ = p.length > 0 ? p + CATEGORY_PATH_SEPARATOR + v.name : v.name, I = this._provider.getCategoryByPath(_);
      if (I !== void 0) {
        const P = LogLevel$1.toLogLevel(v.level);
        P !== void 0 ? this._provider.updateRuntimeSettingsCategory(I, { level: P, disableRecursion: !0 }) : c && this._messageChannel(`CategoryControlProvider '${this._provider.name}' - cannot restore log level for category path '${_}', log level is invalid.`);
        for (const $ of v.children)
          l($, _);
      } else
        c && this._messageChannel(`CategoryControlProvider '${this._provider.name}' - failed to find a Category by path '${_}', will not restore category (and children)`);
    };
    for (const v of u.rootCategories)
      l(v, "");
  }
  createKey() {
    return `CategoryProvider-${this._provider.name}`;
  }
  createCategoryInfoHierarchy() {
    const u = /* @__PURE__ */ new Map();
    return this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).forEach((l) => CategoryControlProviderImpl.addCategoryInfoHierarchy(l, 0, u)), u;
  }
  static createCategorySaveData(u) {
    return {
      name: u.name,
      level: LogLevel$1[u.logLevel],
      children: u.children.map((c) => this.createCategorySaveData(c))
    };
  }
  static loadCurrentGroupLogLevels(u) {
    return new Map(u.getRegisteredCategories().map((c) => [c.id, c.logLevel]));
  }
  static createSettingLineCategory(u, c, l, v) {
    const _ = " ".repeat(u.depth) + u.category.name;
    return `  [${index$3.padStart(c.toString(), l)}, ${index$3.padEnd(_, v)} (level=${index$3.padEnd(u.logLevel, 5)})]`;
  }
  static addCategoryInfoHierarchy(u, c, l) {
    l.set(u.id, {
      category: u,
      logLevel: LogLevel$1[u.logLevel],
      depth: c
    }), u.children.forEach((v) => this.addCategoryInfoHierarchy(v, c + 1, l));
  }
}
function categoryConfigDebug(a) {
  return `CategoryConfig=level: ${LogLevel$1[a.level].toString()}, allowSameCategoryName=${a.allowSameCategoryName}`;
}
class CategoryProviderService {
  constructor() {
    this._log = InternalLogger.getInternalLogger("category.impl.CategoryProviderService"), this._providers = new index$3.EnhancedMap();
  }
  createLogProvider(u, c) {
    const l = this._providers.compute(u, (v, p) => {
      if (p)
        throw new Error(`CategoryProvider with name '${u}' already exists, cannot create another.`);
      const _ = mergeWithDefaults(c);
      return this._log.debug(() => `Creating new CategoryProvider with name '${u}', using config settings '${categoryConfigDebug(_)}'.`), new CategoryProviderImpl(u, _);
    });
    if (l)
      return l;
    throw new Error("No CategoryProvider? This is a bug.");
  }
  getCategoryControl(u) {
    const c = u || ((l) => {
      if (console && console.log)
        console.log(l);
      else
        throw new Error("Cannot use console (it is not present), please specify a custom function to write to.");
    });
    return {
      help: () => c(CategoryProviderService.help()),
      showSettings: () => c(this.showSettings()),
      getProvider: (l) => this.getCategoryControlProviderByIdOrName(l, c)
    };
  }
  clear() {
    this._providers.clear();
  }
  /* Functions for CategoryControl follow */
  showSettings() {
    let u = `Available CategoryProviders:
`;
    const c = this._providers.size.toString().length, l = index$3.maxLengthStringValueInArray([...this._providers.keys()]), v = [...this._providers.entries()].map((p, _) => {
      const I = p[0];
      return `  [${index$3.padStart(_.toString(), c)}, ${index$3.padEnd(I, l)}]`;
    });
    return u += v.join(`
`) + (v.length > 0 ? `
` : ""), u;
  }
  getCategoryControlProviderByIdOrName(u, c) {
    if (typeof u == "string") {
      const v = this._providers.get(u);
      if (v === void 0)
        throw new Error(`Provider with name '${u}' does not exist.`);
      return new CategoryControlProviderImpl(v, c);
    }
    const l = [...this._providers.values()];
    if (u < 0 || u >= l.length)
      throw new Error(`Provider with index '${u}' does not exist (outside of range).`);
    return new CategoryControlProviderImpl(l[u], c);
  }
  static help() {
    return `You can use the following commands:
  showSettings()
    Shows the current configuration settings.
  getProvider: (id: number | string): CategoryControlProvider
    Get access to a CategoryControlProvider to change log levels.
      @param id The id (use showSettings to see) or name of the provider
  help()
    Shows this help.
`;
  }
}
const CATEGORY_PROVIDER_SERVICE = new CategoryProviderService(), CATEGORY_LOG_CONTROL = (a) => CATEGORY_PROVIDER_SERVICE.getCategoryControl(a);
function mergeWithDefaults(a) {
  const u = {
    channel: DefaultChannels.createConsoleChannel(),
    allowSameCategoryName: !0,
    level: LogLevel$1.Error,
    dateFormatter: formatDate,
    argumentFormatter: formatArgument
  };
  return a ? {
    channel: a.channel ? a.channel : u.channel,
    allowSameCategoryName: a.allowSameCategoryName !== void 0 ? a.allowSameCategoryName : u.allowSameCategoryName,
    level: a.level ? a.level : u.level,
    dateFormatter: a.dateFormatter ? a.dateFormatter : u.dateFormatter,
    argumentFormatter: a.argumentFormatter ? a.argumentFormatter : u.argumentFormatter
  } : u;
}
var CategoryProvider;
(function(a) {
  function u(l, v) {
    return CATEGORY_PROVIDER_SERVICE.createLogProvider(l, v);
  }
  a.createProvider = u;
  function c() {
    CATEGORY_PROVIDER_SERVICE.clear();
  }
  a.clear = c;
})(CategoryProvider || (CategoryProvider = {}));
const typescriptLoggingCategory_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CATEGORY_LOG_CONTROL,
  get CategoryProvider() {
    return CategoryProvider;
  }
}, Symbol.toStringTag, { value: "Module" })), require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(typescriptLoggingCategory_esm);
Object.defineProperty(logger, "__esModule", { value: !0 });
logger.logger = void 0;
const typescript_logging_1 = require$$2$2, typescript_logging_category_style_1 = require$$1$2;
logger.logger = typescript_logging_category_style_1.CategoryProvider.createProvider("ApiStream", { allowSameCategoryName: !0, level: typescript_logging_1.LogLevel.Warn });
var version$4 = "1.0.25", __createBinding$3 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar$3 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$3(u, a, c);
  return __setModuleDefault$3(u, a), u;
}, __importDefault$d = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(api$3, "__esModule", { value: !0 });
api$3.ApiClient = void 0;
const NiceGrpc$1 = __importStar$3(lib$1), abort_controller_x_1 = require$$1$3, detect_node_1 = __importDefault$d(browser$f), NodeTransport = __importStar$3(require$$3), logger_1 = logger, clientVersion$1 = version$4;
class ApiClient {
  constructor(u, c, l, v, p, _) {
    this.sessionId = u, this.sdkVersion = l, this.version = clientVersion$1, this.apiLogCallback = p, this.eventLogCallback = _, this.log = logger_1.logger.getCategory(v), this.channel = NiceGrpc$1.createChannel(c, detect_node_1.default ? NodeTransport.NodeHttpTransport() : void 0), this.clientFactory = NiceGrpc$1.createClientFactory().use(this.logMiddleware.bind(this));
  }
  async *logMiddleware(u, c) {
    const { path: l } = u.method;
    try {
      const v = yield* u.next(u.request, c);
      if (this.log.debug(`-> ${l}: ok`), this.log.trace(`${JSON.stringify(u.request)} -> ${l}: ${JSON.stringify(v)}`), this.apiLogCallback) {
        let p = l.split("/"), _ = p[1].split("."), I = _[_.length - 1], P = _[_.length - 2], $ = _[_.length - 3], F = p[2];
        this.apiLogCallback($, I, F, u.request, v);
      }
      return v;
    } catch (v) {
      throw this.log.trace(`${JSON.stringify(u.request)} -> ${l}`), v instanceof NiceGrpc$1.ClientError ? this.log.warn(`-> ${l}: error: ${NiceGrpc$1.Status[v.code]}: ${v.details}`) : (0, abort_controller_x_1.isAbortError)(v) ? this.log.warn(`-> ${l}: cancel`) : this.log.warn(`-> ${l}: error: ${v == null ? void 0 : v.stack}`), v;
    }
  }
  setAccessToken(u) {
    (this.accessToken == null || this.accessToken != u) && (this.log.debug("access token refreshed"), this.accessToken = u, this.setup());
  }
  makeGrpcMetadata() {
    let u = NiceGrpc$1.Metadata({
      Authorization: `Bearer ${this.accessToken}`,
      Version: this.version,
      SessionId: this.sessionId
    });
    return this.sdkVersion != null && u.set("SdkVersion", this.sdkVersion), u;
  }
  setup() {
    let u = {
      metadata: this.makeGrpcMetadata()
    };
    this._setup(u);
  }
  _setup(u) {
  }
}
api$3.ApiClient = ApiClient;
var decorator = {};
Object.defineProperty(decorator, "__esModule", { value: !0 });
decorator.RequiresSdkAuthentication = void 0;
function RequiresSdkAuthentication() {
  return function(a, u) {
    const c = Symbol(u);
    Object.defineProperty(a, u, {
      get: function() {
        if (!this[c])
          throw new Error("Please authenticate ApiStream by calling apiStream.load( accessToken )");
        return this[c];
      },
      set: function(l) {
        this[c] = l;
      }
    });
  };
}
decorator.RequiresSdkAuthentication = RequiresSdkAuthentication;
var __createBinding$2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __decorate = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(a, u, c, l) {
  var v = arguments.length, p = v < 3 ? u : l === null ? l = Object.getOwnPropertyDescriptor(u, c) : l, _;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    p = Reflect.decorate(a, u, c, l);
  else
    for (var I = a.length - 1; I >= 0; I--)
      (_ = a[I]) && (p = (v < 3 ? _(p) : v > 3 ? _(u, c, p) : _(u, c)) || p);
  return v > 3 && p && Object.defineProperty(u, c, p), p;
}, __importStar$2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$2(u, a, c);
  return __setModuleDefault$2(u, a), u;
}, __metadata = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function(a, u) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(a, u);
};
Object.defineProperty(layoutapi, "__esModule", { value: !0 });
layoutapi.LayoutApi = void 0;
__importStar$2(lib$1);
const LayoutApiModel = __importStar$2(dist$2), api_1$1 = api$3, decorator_1 = decorator, LOG_CATEGORY$1 = "LayoutApi";
class LayoutApi extends api_1$1.ApiClient {
  constructor(u, c, l, v, p) {
    super(u, l, v, LOG_CATEGORY$1, p), this.handlers = {}, this.eventApi = c, this.eventApi.on("event", { name: `${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: !0 }, (_) => {
      var I;
      const [, P] = _.name.split(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:`), [$, F] = P.split(":"), H = _.payload;
      for (const j of (I = this.handlers[$]) !== null && I !== void 0 ? I : [])
        j(Object.values(H).find((ee) => !!ee), F);
    });
  }
  _setup(u) {
    this.layer = this.clientFactory.create(LayoutApiModel.LayerServiceDefinition, this.channel, {
      "*": u
    }), this.layout = this.clientFactory.create(LayoutApiModel.LayoutServiceDefinition, this.channel, {
      "*": u
    });
  }
  /**
   * Subscribe to all events for a given layout.
   *
   * @param layoutId - the id of the layout to which you want to subscribe to layout events
   */
  async subscribeToLayout(u) {
    await Promise.all([
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId: u } }),
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId: u } })
    ]);
  }
  /**
   * Unsubscribe from all events for a given layout.
   *
   * @param layoutId - the id of the layout to which you want to unsubscribe to layout events
   */
  async unsubscribeFromLayout(u) {
    await Promise.all([
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId: u } }),
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId: u } })
    ]);
  }
  /**
   * Subscribe to all events for layouts in a project.
   *
   * @param collectionId - the id of the collection the layouts are in.
   * @param projectId - the id of the project the layouts are in.
   */
  async subscribeToLayoutsInProject(u, c) {
    await Promise.all([
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId: u, projectId: c } }),
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId: u, projectId: c } })
    ]);
  }
  /**
   * Unsubscribe from all events for layouts in a project.
   *
   * @param collectionId - the id of the collection the layouts are in.
   * @param projectId - the id of the project the layouts are in.
   */
  async unsubscribeFromLayoutsInProject(u, c) {
    await Promise.all([
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId: u, projectId: c } }),
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId: u, projectId: c } })
    ]);
  }
  /**
   * Register an event handler
   *
   * @param type Type of event
   * @param handler
   */
  on(u, c) {
    var l;
    this.handlers[u] = (l = this.handlers[u]) !== null && l !== void 0 ? l : [], this.handlers[u].push(c);
  }
  /**
   * Unregister an event handler
   *
   * @param type Type of event
   * @param handler
   */
  off(u, c) {
    this.handlers[u] = this.handlers[u].filter((l) => l !== c);
  }
}
LayoutApi.LAYOUTAPI_EVENT_PREFIX = "apistream:layout";
__decorate([
  (0, decorator_1.RequiresSdkAuthentication)(),
  __metadata("design:type", Object)
], LayoutApi.prototype, "layout", void 0);
__decorate([
  (0, decorator_1.RequiresSdkAuthentication)(),
  __metadata("design:type", Object)
], LayoutApi.prototype, "layer", void 0);
layoutapi.LayoutApi = LayoutApi;
var liveapi = {}, api$2 = {}, httpbody = {}, any = {}, __importDefault$c = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(any, "__esModule", { value: !0 });
any.Any = any.protobufPackage = void 0;
const minimal_1$5 = __importDefault$c(minimal);
any.protobufPackage = "google.protobuf";
function createBaseAny() {
  return { typeUrl: "", value: new Uint8Array() };
}
any.Any = {
  encode(a, u = minimal_1$5.default.Writer.create()) {
    return a.typeUrl !== "" && u.uint32(10).string(a.typeUrl), a.value.length !== 0 && u.uint32(18).bytes(a.value), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$5.default.Reader ? a : new minimal_1$5.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseAny();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.typeUrl = c.string();
          break;
        case 2:
          v.value = c.bytes();
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      typeUrl: isSet$5(a.typeUrl) ? String(a.typeUrl) : "",
      value: isSet$5(a.value) ? bytesFromBase64$1(a.value) : new Uint8Array()
    };
  },
  toJSON(a) {
    const u = {};
    return a.typeUrl !== void 0 && (u.typeUrl = a.typeUrl), a.value !== void 0 && (u.value = base64FromBytes$1(a.value !== void 0 ? a.value : new Uint8Array())), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseAny();
    return l.typeUrl = (u = a.typeUrl) !== null && u !== void 0 ? u : "", l.value = (c = a.value) !== null && c !== void 0 ? c : new Uint8Array(), l;
  }
};
var globalThis$5 = (() => {
  if (typeof globalThis$5 < "u")
    return globalThis$5;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function bytesFromBase64$1(a) {
  if (globalThis$5.Buffer)
    return Uint8Array.from(globalThis$5.Buffer.from(a, "base64"));
  {
    const u = globalThis$5.atob(a), c = new Uint8Array(u.length);
    for (let l = 0; l < u.length; ++l)
      c[l] = u.charCodeAt(l);
    return c;
  }
}
function base64FromBytes$1(a) {
  if (globalThis$5.Buffer)
    return globalThis$5.Buffer.from(a).toString("base64");
  {
    const u = [];
    return a.forEach((c) => {
      u.push(String.fromCharCode(c));
    }), globalThis$5.btoa(u.join(""));
  }
}
function isSet$5(a) {
  return a != null;
}
var __importDefault$b = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(httpbody, "__esModule", { value: !0 });
httpbody.HttpBody = httpbody.protobufPackage = void 0;
const minimal_1$4 = __importDefault$b(minimal), any_1 = any;
httpbody.protobufPackage = "google.api";
function createBaseHttpBody() {
  return { contentType: "", data: new Uint8Array(), extensions: [] };
}
httpbody.HttpBody = {
  encode(a, u = minimal_1$4.default.Writer.create()) {
    a.contentType !== "" && u.uint32(10).string(a.contentType), a.data.length !== 0 && u.uint32(18).bytes(a.data);
    for (const c of a.extensions)
      any_1.Any.encode(c, u.uint32(26).fork()).ldelim();
    return u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$4.default.Reader ? a : new minimal_1$4.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseHttpBody();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.contentType = c.string();
          break;
        case 2:
          v.data = c.bytes();
          break;
        case 3:
          v.extensions.push(any_1.Any.decode(c, c.uint32()));
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      contentType: isSet$4(a.contentType) ? String(a.contentType) : "",
      data: isSet$4(a.data) ? bytesFromBase64(a.data) : new Uint8Array(),
      extensions: Array.isArray(a == null ? void 0 : a.extensions) ? a.extensions.map((u) => any_1.Any.fromJSON(u)) : []
    };
  },
  toJSON(a) {
    const u = {};
    return a.contentType !== void 0 && (u.contentType = a.contentType), a.data !== void 0 && (u.data = base64FromBytes(a.data !== void 0 ? a.data : new Uint8Array())), a.extensions ? u.extensions = a.extensions.map((c) => c ? any_1.Any.toJSON(c) : void 0) : u.extensions = [], u;
  },
  fromPartial(a) {
    var u, c, l;
    const v = createBaseHttpBody();
    return v.contentType = (u = a.contentType) !== null && u !== void 0 ? u : "", v.data = (c = a.data) !== null && c !== void 0 ? c : new Uint8Array(), v.extensions = ((l = a.extensions) === null || l === void 0 ? void 0 : l.map((p) => any_1.Any.fromPartial(p))) || [], v;
  }
};
var globalThis$4 = (() => {
  if (typeof globalThis$4 < "u")
    return globalThis$4;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function bytesFromBase64(a) {
  if (globalThis$4.Buffer)
    return Uint8Array.from(globalThis$4.Buffer.from(a, "base64"));
  {
    const u = globalThis$4.atob(a), c = new Uint8Array(u.length);
    for (let l = 0; l < u.length; ++l)
      c[l] = u.charCodeAt(l);
    return c;
  }
}
function base64FromBytes(a) {
  if (globalThis$4.Buffer)
    return globalThis$4.Buffer.from(a).toString("base64");
  {
    const u = [];
    return a.forEach((c) => {
      u.push(String.fromCharCode(c));
    }), globalThis$4.btoa(u.join(""));
  }
}
function isSet$4(a) {
  return a != null;
}
var field_mask = {}, __importDefault$a = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(field_mask, "__esModule", { value: !0 });
field_mask.FieldMask = field_mask.protobufPackage = void 0;
const minimal_1$3 = __importDefault$a(minimal);
field_mask.protobufPackage = "google.protobuf";
function createBaseFieldMask() {
  return { paths: [] };
}
field_mask.FieldMask = {
  encode(a, u = minimal_1$3.default.Writer.create()) {
    for (const c of a.paths)
      u.uint32(10).string(c);
    return u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$3.default.Reader ? a : new minimal_1$3.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseFieldMask();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.paths.push(c.string());
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      paths: typeof a == "string" ? a.split(",").filter(Boolean) : Array.isArray(a == null ? void 0 : a.paths) ? a.paths.map(String) : []
    };
  },
  toJSON(a) {
    return a.paths.join(",");
  },
  fromPartial(a) {
    var u;
    const c = createBaseFieldMask();
    return c.paths = ((u = a.paths) === null || u === void 0 ? void 0 : u.map((l) => l)) || [], c;
  },
  wrap(a) {
    const u = createBaseFieldMask();
    return u.paths = a, u;
  },
  unwrap(a) {
    return a.paths;
  }
};
var struct$1 = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(X) {
    return X && X.__esModule ? X : { default: X };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const c = u(minimal);
  a.protobufPackage = "google.protobuf";
  var l;
  (function(X) {
    X.NULL_VALUE = "NULL_VALUE";
  })(l = a.NullValue || (a.NullValue = {}));
  function v(X) {
    switch (X) {
      case 0:
      case "NULL_VALUE":
        return l.NULL_VALUE;
      default:
        throw new H.Error("Unrecognized enum value " + X + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = v;
  function p(X) {
    switch (X) {
      case l.NULL_VALUE:
        return "NULL_VALUE";
      default:
        throw new H.Error("Unrecognized enum value " + X + " for enum NullValue");
    }
  }
  a.nullValueToJSON = p;
  function _(X) {
    switch (X) {
      case l.NULL_VALUE:
        return 0;
      default:
        throw new H.Error("Unrecognized enum value " + X + " for enum NullValue");
    }
  }
  a.nullValueToNumber = _;
  function I() {
    return { fields: {} };
  }
  a.Struct = {
    encode(X, ie = c.default.Writer.create()) {
      return Object.entries(X.fields).forEach(([Q, ne]) => {
        ne !== void 0 && a.Struct_FieldsEntry.encode({ key: Q, value: ne }, ie.uint32(10).fork()).ldelim();
      }), ie;
    },
    decode(X, ie) {
      const Q = X instanceof c.default.Reader ? X : new c.default.Reader(X);
      let ne = ie === void 0 ? Q.len : Q.pos + ie;
      const Z = I();
      for (; Q.pos < ne; ) {
        const de = Q.uint32();
        switch (de >>> 3) {
          case 1:
            const he = a.Struct_FieldsEntry.decode(Q, Q.uint32());
            he.value !== void 0 && (Z.fields[he.key] = he.value);
            break;
          default:
            Q.skipType(de & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(X) {
      return {
        fields: j(X.fields) ? Object.entries(X.fields).reduce((ie, [Q, ne]) => (ie[Q] = ne, ie), {}) : {}
      };
    },
    toJSON(X) {
      const ie = {};
      return ie.fields = {}, X.fields && Object.entries(X.fields).forEach(([Q, ne]) => {
        ie.fields[Q] = ne;
      }), ie;
    },
    fromPartial(X) {
      var ie;
      const Q = I();
      return Q.fields = Object.entries((ie = X.fields) !== null && ie !== void 0 ? ie : {}).reduce((ne, [Z, de]) => (de !== void 0 && (ne[Z] = de), ne), {}), Q;
    },
    wrap(X) {
      const ie = I();
      return X !== void 0 && Object.keys(X).forEach((Q) => {
        ie.fields[Q] = X[Q];
      }), ie;
    },
    unwrap(X) {
      const ie = {};
      return Object.keys(X.fields).forEach((Q) => {
        ie[Q] = X.fields[Q];
      }), ie;
    }
  };
  function P() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(X, ie = c.default.Writer.create()) {
      return X.key !== "" && ie.uint32(10).string(X.key), X.value !== void 0 && a.Value.encode(a.Value.wrap(X.value), ie.uint32(18).fork()).ldelim(), ie;
    },
    decode(X, ie) {
      const Q = X instanceof c.default.Reader ? X : new c.default.Reader(X);
      let ne = ie === void 0 ? Q.len : Q.pos + ie;
      const Z = P();
      for (; Q.pos < ne; ) {
        const de = Q.uint32();
        switch (de >>> 3) {
          case 1:
            Z.key = Q.string();
            break;
          case 2:
            Z.value = a.Value.unwrap(a.Value.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(de & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(X) {
      return { key: ee(X.key) ? String(X.key) : "", value: ee(X == null ? void 0 : X.value) ? X.value : void 0 };
    },
    toJSON(X) {
      const ie = {};
      return X.key !== void 0 && (ie.key = X.key), X.value !== void 0 && (ie.value = X.value), ie;
    },
    fromPartial(X) {
      var ie, Q;
      const ne = P();
      return ne.key = (ie = X.key) !== null && ie !== void 0 ? ie : "", ne.value = (Q = X.value) !== null && Q !== void 0 ? Q : void 0, ne;
    }
  };
  function $() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(X, ie = c.default.Writer.create()) {
      return X.nullValue !== void 0 && ie.uint32(8).int32(_(X.nullValue)), X.numberValue !== void 0 && ie.uint32(17).double(X.numberValue), X.stringValue !== void 0 && ie.uint32(26).string(X.stringValue), X.boolValue !== void 0 && ie.uint32(32).bool(X.boolValue), X.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(X.structValue), ie.uint32(42).fork()).ldelim(), X.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(X.listValue), ie.uint32(50).fork()).ldelim(), ie;
    },
    decode(X, ie) {
      const Q = X instanceof c.default.Reader ? X : new c.default.Reader(X);
      let ne = ie === void 0 ? Q.len : Q.pos + ie;
      const Z = $();
      for (; Q.pos < ne; ) {
        const de = Q.uint32();
        switch (de >>> 3) {
          case 1:
            Z.nullValue = v(Q.int32());
            break;
          case 2:
            Z.numberValue = Q.double();
            break;
          case 3:
            Z.stringValue = Q.string();
            break;
          case 4:
            Z.boolValue = Q.bool();
            break;
          case 5:
            Z.structValue = a.Struct.unwrap(a.Struct.decode(Q, Q.uint32()));
            break;
          case 6:
            Z.listValue = a.ListValue.unwrap(a.ListValue.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(de & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(X) {
      return {
        nullValue: ee(X.nullValue) ? v(X.nullValue) : void 0,
        numberValue: ee(X.numberValue) ? Number(X.numberValue) : void 0,
        stringValue: ee(X.stringValue) ? String(X.stringValue) : void 0,
        boolValue: ee(X.boolValue) ? !!X.boolValue : void 0,
        structValue: j(X.structValue) ? X.structValue : void 0,
        listValue: Array.isArray(X.listValue) ? [...X.listValue] : void 0
      };
    },
    toJSON(X) {
      const ie = {};
      return X.nullValue !== void 0 && (ie.nullValue = X.nullValue !== void 0 ? p(X.nullValue) : void 0), X.numberValue !== void 0 && (ie.numberValue = X.numberValue), X.stringValue !== void 0 && (ie.stringValue = X.stringValue), X.boolValue !== void 0 && (ie.boolValue = X.boolValue), X.structValue !== void 0 && (ie.structValue = X.structValue), X.listValue !== void 0 && (ie.listValue = X.listValue), ie;
    },
    fromPartial(X) {
      var ie, Q, ne, Z, de, he;
      const pe = $();
      return pe.nullValue = (ie = X.nullValue) !== null && ie !== void 0 ? ie : void 0, pe.numberValue = (Q = X.numberValue) !== null && Q !== void 0 ? Q : void 0, pe.stringValue = (ne = X.stringValue) !== null && ne !== void 0 ? ne : void 0, pe.boolValue = (Z = X.boolValue) !== null && Z !== void 0 ? Z : void 0, pe.structValue = (de = X.structValue) !== null && de !== void 0 ? de : void 0, pe.listValue = (he = X.listValue) !== null && he !== void 0 ? he : void 0, pe;
    },
    wrap(X) {
      const ie = $();
      if (X === null)
        ie.nullValue = l.NULL_VALUE;
      else if (typeof X == "boolean")
        ie.boolValue = X;
      else if (typeof X == "number")
        ie.numberValue = X;
      else if (typeof X == "string")
        ie.stringValue = X;
      else if (Array.isArray(X))
        ie.listValue = X;
      else if (typeof X == "object")
        ie.structValue = X;
      else if (typeof X < "u")
        throw new Error("Unsupported any value type: " + typeof X);
      return ie;
    },
    unwrap(X) {
      if ((X == null ? void 0 : X.stringValue) !== void 0)
        return X.stringValue;
      if ((X == null ? void 0 : X.numberValue) !== void 0)
        return X.numberValue;
      if ((X == null ? void 0 : X.boolValue) !== void 0)
        return X.boolValue;
      if ((X == null ? void 0 : X.structValue) !== void 0)
        return X.structValue;
      if ((X == null ? void 0 : X.listValue) !== void 0)
        return X.listValue;
      if ((X == null ? void 0 : X.nullValue) !== void 0)
        return null;
    }
  };
  function F() {
    return { values: [] };
  }
  a.ListValue = {
    encode(X, ie = c.default.Writer.create()) {
      for (const Q of X.values)
        a.Value.encode(a.Value.wrap(Q), ie.uint32(10).fork()).ldelim();
      return ie;
    },
    decode(X, ie) {
      const Q = X instanceof c.default.Reader ? X : new c.default.Reader(X);
      let ne = ie === void 0 ? Q.len : Q.pos + ie;
      const Z = F();
      for (; Q.pos < ne; ) {
        const de = Q.uint32();
        switch (de >>> 3) {
          case 1:
            Z.values.push(a.Value.unwrap(a.Value.decode(Q, Q.uint32())));
            break;
          default:
            Q.skipType(de & 7);
            break;
        }
      }
      return Z;
    },
    fromJSON(X) {
      return { values: Array.isArray(X == null ? void 0 : X.values) ? [...X.values] : [] };
    },
    toJSON(X) {
      const ie = {};
      return X.values ? ie.values = X.values.map((Q) => Q) : ie.values = [], ie;
    },
    fromPartial(X) {
      var ie;
      const Q = F();
      return Q.values = ((ie = X.values) === null || ie === void 0 ? void 0 : ie.map((ne) => ne)) || [], Q;
    },
    wrap(X) {
      const ie = F();
      return ie.values = X ?? [], ie;
    },
    unwrap(X) {
      return X.values;
    }
  };
  var H = (() => {
    if (typeof H < "u")
      return H;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function j(X) {
    return typeof X == "object" && X !== null;
  }
  function ee(X) {
    return X != null;
  }
})(struct$1);
var timestamp$2 = {}, __importDefault$9 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(timestamp$2, "__esModule", { value: !0 });
timestamp$2.Timestamp = timestamp$2.protobufPackage = void 0;
const long_1$2 = __importDefault$9(umdExports), minimal_1$2 = __importDefault$9(minimal);
timestamp$2.protobufPackage = "google.protobuf";
function createBaseTimestamp$1() {
  return { seconds: 0, nanos: 0 };
}
timestamp$2.Timestamp = {
  encode(a, u = minimal_1$2.default.Writer.create()) {
    return a.seconds !== 0 && u.uint32(8).int64(a.seconds), a.nanos !== 0 && u.uint32(16).int32(a.nanos), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$2.default.Reader ? a : new minimal_1$2.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseTimestamp$1();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.seconds = longToNumber$2(c.int64());
          break;
        case 2:
          v.nanos = c.int32();
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      seconds: isSet$3(a.seconds) ? Number(a.seconds) : 0,
      nanos: isSet$3(a.nanos) ? Number(a.nanos) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.seconds !== void 0 && (u.seconds = Math.round(a.seconds)), a.nanos !== void 0 && (u.nanos = Math.round(a.nanos)), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseTimestamp$1();
    return l.seconds = (u = a.seconds) !== null && u !== void 0 ? u : 0, l.nanos = (c = a.nanos) !== null && c !== void 0 ? c : 0, l;
  }
};
var globalThis$3 = (() => {
  if (typeof globalThis$3 < "u")
    return globalThis$3;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber$2(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$3.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1$2.default.util.Long !== long_1$2.default && (minimal_1$2.default.util.Long = long_1$2.default, minimal_1$2.default.configure());
function isSet$3(a) {
  return a != null;
}
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(S) {
    return S && S.__esModule ? S : { default: S };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.Role = a.regionToNumber = a.regionToJSON = a.regionFromJSON = a.Region = a.sourceTriggerActionToNumber = a.sourceTriggerActionToJSON = a.sourceTriggerActionFromJSON = a.SourceTriggerAction = a.s3ACLToNumber = a.s3ACLToJSON = a.s3ACLFromJSON = a.S3ACL = a.projectBroadcastPhaseToNumber = a.projectBroadcastPhaseToJSON = a.projectBroadcastPhaseFromJSON = a.ProjectBroadcastPhase = a.videoCodecRateControlModeToNumber = a.videoCodecRateControlModeToJSON = a.videoCodecRateControlModeFromJSON = a.VideoCodecRateControlMode = a.audioCodecToNumber = a.audioCodecToJSON = a.audioCodecFromJSON = a.AudioCodec = a.videoCodecProfileToNumber = a.videoCodecProfileToJSON = a.videoCodecProfileFromJSON = a.VideoCodecProfile = a.videoCodecToNumber = a.videoCodecToJSON = a.videoCodecFromJSON = a.VideoCodec = a.renderingQualityToNumber = a.renderingQualityToJSON = a.renderingQualityFromJSON = a.RenderingQuality = a.audioChannelLayoutToNumber = a.audioChannelLayoutToJSON = a.audioChannelLayoutFromJSON = a.AudioChannelLayout = a.videoColorSpaceToNumber = a.videoColorSpaceToJSON = a.videoColorSpaceFromJSON = a.VideoColorSpace = a.imageFormatToNumber = a.imageFormatToJSON = a.imageFormatFromJSON = a.ImageFormat = a.protobufPackage = void 0, a.ExternalComposition = a.SceneComposition = a.StudioSdkComposition = a.PreviewAddress = a.PreviewWebRtcAddress = a.PreviewHlsPullAddress = a.ProjectTrigger = a.WebRtcTrigger = a.SourceTrigger = a.DestinationAddress = a.S3StorageAddress = a.ObjectStoragePackaging = a.HlsPackaging = a.HlsLifecycle = a.HlsLifecycleVod = a.HlsLifecycleLive = a.DestinationAgoraPushAddress = a.DestinationSrtPushAddress = a.DestinationRtmpPushAddress = a.SourceAddress = a.SrtPullAddress = a.RtmpPullAddress = a.SrtPushAddress = a.SourceRtmpPushAddress = a.Encoding = a.AudioEncoding = a.VideoEncoding = a.VideoCodecRateControl = a.Rendering = a.AudioRendering = a.VideoRendering = a.eventTypeToNumber = a.eventTypeToJSON = a.eventTypeFromJSON = a.EventType = a.eventSubTypeToNumber = a.eventSubTypeToJSON = a.eventSubTypeFromJSON = a.EventSubType = a.connectStateToNumber = a.connectStateToJSON = a.connectStateFromJSON = a.ConnectState = a.projectBroadcastErrorToNumber = a.projectBroadcastErrorToJSON = a.projectBroadcastErrorFromJSON = a.ProjectBroadcastError = a.roleToNumber = a.roleToJSON = a.roleFromJSON = void 0, a.CreateSourceResponse = a.CreateSourceRequest = a.UpdateDestinationResponse = a.UpdateDestinationRequest = a.DeleteDestinationResponse = a.DeleteDestinationRequest = a.GetDestinationResponse = a.GetDestinationRequest = a.CreateDestinationResponse = a.CreateDestinationRequest = a.StopProjectWebRtcResponse = a.StopProjectWebRtcRequest = a.StartProjectWebRtcResponse = a.StartProjectWebRtcRequest = a.GetProjectBroadcastStatusResponse = a.GetProjectBroadcastStatusRequest = a.GetProjectBroadcastSnapshotResponse = a.GetProjectBroadcastSnapshotRequest = a.GetProjectResponse = a.GetProjectRequest = a.StopProjectBroadcastResponse = a.StopProjectBroadcastRequest = a.StartProjectBroadcastResponse = a.StartProjectBroadcastRequest = a.DeleteProjectResponse = a.DeleteProjectRequest = a.UpdateProjectResponse = a.UpdateProjectRequest = a.CreateProjectResponse = a.CreateProjectRequest = a.GetCollectionsResponse = a.GetCollectionsRequest = a.DeleteCollectionResponse = a.DeleteCollectionRequest = a.UpdateCollectionResponse = a.UpdateCollectionRequest = a.GetCollectionResponse = a.GetCollectionRequest = a.CreateCollectionResponse = a.CreateCollectionRequest = a.Collection = a.Project = a.Destination = a.Source = a.ProjectBroadcastStatus = a.LatLong = a.WebRtcAccess = a.WebRtc = a.HostedWebRtc = a.Composition = void 0, a.SourceAddEvent = a.SourceUpdateEvent = a.SourceDeleteEvent = a.SourceCreateEvent = a.CollectionUpdateEvent = a.CollectionDeleteEvent = a.CollectionCreateEvent = a.ProjectBroadcastStateEvent = a.ProjectUpdateEvent = a.ProjectDeleteEvent = a.ProjectCreateEvent = a.DestinationStateEvent = a.DestinationUpdateEvent = a.DestinationDeleteEvent = a.DestinationCreateEvent = a.GetTestTokenResponse = a.GetTestTokenRequest = a.GetJsonWebKeySetResponse = a.GetJsonWebKeySetRequest = a.JsonWebKey = a.GuestCodeRedirectResponse = a.GuestCodeRedirectRequest = a.GuestCode = a.RefreshAccessTokenResponse = a.RefreshAccessTokenRequest = a.CreateWebRtcAccessTokenResponse = a.CreateWebRtcAccessTokenRequest = a.CreateGuestAccessTokenResponse = a.CreateGuestAccessTokenRequest = a.GuestAccessToken = a.GuestAccessTokenExchange = a.GuestAccessTokenDirect = a.CreateAccessTokenResponse = a.CreateAccessTokenRequest = a.GetSourcePlaylistResponse = a.GetSourcePlaylistRequest = a.RemoveSourceFromProjectResponse = a.RemoveSourceFromProjectRequest = a.UpdateSourceResponse = a.UpdateSourceRequest = a.GetSourcesResponse = a.GetSourcesRequest = a.GetSourceResponse = a.GetSourceRequest = a.UpdateSourceInProjectResponse = a.UpdateSourceInProjectRequest = a.AddSourceToProjectResponse = a.AddSourceToProjectRequest = a.DeleteSourceResponse = a.DeleteSourceRequest = void 0, a.PublicAuthenticationServiceDefinition = a.PublicAuthenticationServiceClientImpl = a.AuthenticationServiceDefinition = a.AuthenticationServiceClientImpl = a.BackendAuthenticationServiceDefinition = a.BackendAuthenticationServiceClientImpl = a.SourceServiceDefinition = a.SourceServiceClientImpl = a.DestinationServiceDefinition = a.DestinationServiceClientImpl = a.ProjectServiceDefinition = a.ProjectServiceClientImpl = a.CollectionServiceDefinition = a.CollectionServiceClientImpl = a.LiveEvent = a.SourceEvent = a.ProjectEvent = a.DestinationEvent = a.CollectionEvent = a.SourceStateEvent = a.SourceRemoveEvent = void 0;
  const c = u(minimal), l = httpbody, v = field_mask, p = struct$1, _ = timestamp$2;
  a.protobufPackage = "live.v21";
  var I;
  (function(S) {
    S.IMAGE_FORMAT_UNSPECIFIED = "IMAGE_FORMAT_UNSPECIFIED", S.IMAGE_FORMAT_JPEG = "IMAGE_FORMAT_JPEG";
  })(I = a.ImageFormat || (a.ImageFormat = {}));
  function P(S) {
    switch (S) {
      case 0:
      case "IMAGE_FORMAT_UNSPECIFIED":
        return I.IMAGE_FORMAT_UNSPECIFIED;
      case 1:
      case "IMAGE_FORMAT_JPEG":
        return I.IMAGE_FORMAT_JPEG;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum ImageFormat");
    }
  }
  a.imageFormatFromJSON = P;
  function $(S) {
    switch (S) {
      case I.IMAGE_FORMAT_UNSPECIFIED:
        return "IMAGE_FORMAT_UNSPECIFIED";
      case I.IMAGE_FORMAT_JPEG:
        return "IMAGE_FORMAT_JPEG";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum ImageFormat");
    }
  }
  a.imageFormatToJSON = $;
  function F(S) {
    switch (S) {
      case I.IMAGE_FORMAT_UNSPECIFIED:
        return 0;
      case I.IMAGE_FORMAT_JPEG:
        return 1;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum ImageFormat");
    }
  }
  a.imageFormatToNumber = F;
  var H;
  (function(S) {
    S.VIDEO_COLOR_SPACE_UNSPECIFIED = "VIDEO_COLOR_SPACE_UNSPECIFIED", S.VIDEO_COLOR_SPACE_YUV420 = "VIDEO_COLOR_SPACE_YUV420";
  })(H = a.VideoColorSpace || (a.VideoColorSpace = {}));
  function j(S) {
    switch (S) {
      case 0:
      case "VIDEO_COLOR_SPACE_UNSPECIFIED":
        return H.VIDEO_COLOR_SPACE_UNSPECIFIED;
      case 1:
      case "VIDEO_COLOR_SPACE_YUV420":
        return H.VIDEO_COLOR_SPACE_YUV420;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceFromJSON = j;
  function ee(S) {
    switch (S) {
      case H.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return "VIDEO_COLOR_SPACE_UNSPECIFIED";
      case H.VIDEO_COLOR_SPACE_YUV420:
        return "VIDEO_COLOR_SPACE_YUV420";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceToJSON = ee;
  function X(S) {
    switch (S) {
      case H.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return 0;
      case H.VIDEO_COLOR_SPACE_YUV420:
        return 1;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceToNumber = X;
  var ie;
  (function(S) {
    S.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED = "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED", S.AUDIO_CHANNEL_LAYOUT_STEREO = "AUDIO_CHANNEL_LAYOUT_STEREO";
  })(ie = a.AudioChannelLayout || (a.AudioChannelLayout = {}));
  function Q(S) {
    switch (S) {
      case 0:
      case "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED":
        return ie.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED;
      case 1:
      case "AUDIO_CHANNEL_LAYOUT_STEREO":
        return ie.AUDIO_CHANNEL_LAYOUT_STEREO;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutFromJSON = Q;
  function ne(S) {
    switch (S) {
      case ie.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED";
      case ie.AUDIO_CHANNEL_LAYOUT_STEREO:
        return "AUDIO_CHANNEL_LAYOUT_STEREO";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutToJSON = ne;
  function Z(S) {
    switch (S) {
      case ie.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return 0;
      case ie.AUDIO_CHANNEL_LAYOUT_STEREO:
        return 1;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutToNumber = Z;
  var de;
  (function(S) {
    S.RENDERING_QUALITY_UNSPECIFIED = "RENDERING_QUALITY_UNSPECIFIED", S.RENDERING_QUALITY_STANDARD = "RENDERING_QUALITY_STANDARD", S.RENDERING_QUALITY_HIGH = "RENDERING_QUALITY_HIGH";
  })(de = a.RenderingQuality || (a.RenderingQuality = {}));
  function he(S) {
    switch (S) {
      case 0:
      case "RENDERING_QUALITY_UNSPECIFIED":
        return de.RENDERING_QUALITY_UNSPECIFIED;
      case 1:
      case "RENDERING_QUALITY_STANDARD":
        return de.RENDERING_QUALITY_STANDARD;
      case 2:
      case "RENDERING_QUALITY_HIGH":
        return de.RENDERING_QUALITY_HIGH;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum RenderingQuality");
    }
  }
  a.renderingQualityFromJSON = he;
  function pe(S) {
    switch (S) {
      case de.RENDERING_QUALITY_UNSPECIFIED:
        return "RENDERING_QUALITY_UNSPECIFIED";
      case de.RENDERING_QUALITY_STANDARD:
        return "RENDERING_QUALITY_STANDARD";
      case de.RENDERING_QUALITY_HIGH:
        return "RENDERING_QUALITY_HIGH";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum RenderingQuality");
    }
  }
  a.renderingQualityToJSON = pe;
  function be(S) {
    switch (S) {
      case de.RENDERING_QUALITY_UNSPECIFIED:
        return 0;
      case de.RENDERING_QUALITY_STANDARD:
        return 1;
      case de.RENDERING_QUALITY_HIGH:
        return 2;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum RenderingQuality");
    }
  }
  a.renderingQualityToNumber = be;
  var ke;
  (function(S) {
    S.VIDEO_CODEC_UNSPECIFIED = "VIDEO_CODEC_UNSPECIFIED", S.VIDEO_CODEC_H264 = "VIDEO_CODEC_H264";
  })(ke = a.VideoCodec || (a.VideoCodec = {}));
  function _e(S) {
    switch (S) {
      case 0:
      case "VIDEO_CODEC_UNSPECIFIED":
        return ke.VIDEO_CODEC_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_H264":
        return ke.VIDEO_CODEC_H264;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum VideoCodec");
    }
  }
  a.videoCodecFromJSON = _e;
  function q(S) {
    switch (S) {
      case ke.VIDEO_CODEC_UNSPECIFIED:
        return "VIDEO_CODEC_UNSPECIFIED";
      case ke.VIDEO_CODEC_H264:
        return "VIDEO_CODEC_H264";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum VideoCodec");
    }
  }
  a.videoCodecToJSON = q;
  function z(S) {
    switch (S) {
      case ke.VIDEO_CODEC_UNSPECIFIED:
        return 0;
      case ke.VIDEO_CODEC_H264:
        return 1;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum VideoCodec");
    }
  }
  a.videoCodecToNumber = z;
  var C;
  (function(S) {
    S.VIDEO_CODEC_PROFILE_UNSPECIFIED = "VIDEO_CODEC_PROFILE_UNSPECIFIED", S.VIDEO_CODEC_PROFILE_BASELINE = "VIDEO_CODEC_PROFILE_BASELINE", S.VIDEO_CODEC_PROFILE_MAIN = "VIDEO_CODEC_PROFILE_MAIN", S.VIDEO_CODEC_PROFILE_HIGH = "VIDEO_CODEC_PROFILE_HIGH";
  })(C = a.VideoCodecProfile || (a.VideoCodecProfile = {}));
  function b(S) {
    switch (S) {
      case 0:
      case "VIDEO_CODEC_PROFILE_UNSPECIFIED":
        return C.VIDEO_CODEC_PROFILE_UNSPECIFIED;
      case 2:
      case "VIDEO_CODEC_PROFILE_BASELINE":
        return C.VIDEO_CODEC_PROFILE_BASELINE;
      case 3:
      case "VIDEO_CODEC_PROFILE_MAIN":
        return C.VIDEO_CODEC_PROFILE_MAIN;
      case 4:
      case "VIDEO_CODEC_PROFILE_HIGH":
        return C.VIDEO_CODEC_PROFILE_HIGH;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileFromJSON = b;
  function E(S) {
    switch (S) {
      case C.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return "VIDEO_CODEC_PROFILE_UNSPECIFIED";
      case C.VIDEO_CODEC_PROFILE_BASELINE:
        return "VIDEO_CODEC_PROFILE_BASELINE";
      case C.VIDEO_CODEC_PROFILE_MAIN:
        return "VIDEO_CODEC_PROFILE_MAIN";
      case C.VIDEO_CODEC_PROFILE_HIGH:
        return "VIDEO_CODEC_PROFILE_HIGH";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileToJSON = E;
  function k(S) {
    switch (S) {
      case C.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return 0;
      case C.VIDEO_CODEC_PROFILE_BASELINE:
        return 2;
      case C.VIDEO_CODEC_PROFILE_MAIN:
        return 3;
      case C.VIDEO_CODEC_PROFILE_HIGH:
        return 4;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileToNumber = k;
  var O;
  (function(S) {
    S.AUDIO_CODEC_UNSPECIFIED = "AUDIO_CODEC_UNSPECIFIED", S.AUDIO_CODEC_AAC = "AUDIO_CODEC_AAC";
  })(O = a.AudioCodec || (a.AudioCodec = {}));
  function A(S) {
    switch (S) {
      case 0:
      case "AUDIO_CODEC_UNSPECIFIED":
        return O.AUDIO_CODEC_UNSPECIFIED;
      case 1:
      case "AUDIO_CODEC_AAC":
        return O.AUDIO_CODEC_AAC;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum AudioCodec");
    }
  }
  a.audioCodecFromJSON = A;
  function x(S) {
    switch (S) {
      case O.AUDIO_CODEC_UNSPECIFIED:
        return "AUDIO_CODEC_UNSPECIFIED";
      case O.AUDIO_CODEC_AAC:
        return "AUDIO_CODEC_AAC";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum AudioCodec");
    }
  }
  a.audioCodecToJSON = x;
  function Y(S) {
    switch (S) {
      case O.AUDIO_CODEC_UNSPECIFIED:
        return 0;
      case O.AUDIO_CODEC_AAC:
        return 1;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum AudioCodec");
    }
  }
  a.audioCodecToNumber = Y;
  var B;
  (function(S) {
    S.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED = "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED", S.VIDEO_CODEC_RATE_CONTROL_MODE_CBR = "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
  })(B = a.VideoCodecRateControlMode || (a.VideoCodecRateControlMode = {}));
  function T(S) {
    switch (S) {
      case 0:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED":
        return B.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_CBR":
        return B.VIDEO_CODEC_RATE_CONTROL_MODE_CBR;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeFromJSON = T;
  function D(S) {
    switch (S) {
      case B.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED";
      case B.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeToJSON = D;
  function te(S) {
    switch (S) {
      case B.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return 0;
      case B.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return 1;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeToNumber = te;
  var me;
  (function(S) {
    S.PROJECT_BROADCAST_PHASE_UNSPECIFIED = "PROJECT_BROADCAST_PHASE_UNSPECIFIED", S.PROJECT_BROADCAST_PHASE_NOT_RUNNING = "PROJECT_BROADCAST_PHASE_NOT_RUNNING", S.PROJECT_BROADCAST_PHASE_WAITING = "PROJECT_BROADCAST_PHASE_WAITING", S.PROJECT_BROADCAST_PHASE_STARTING = "PROJECT_BROADCAST_PHASE_STARTING", S.PROJECT_BROADCAST_PHASE_RUNNING = "PROJECT_BROADCAST_PHASE_RUNNING", S.PROJECT_BROADCAST_PHASE_STOPPING = "PROJECT_BROADCAST_PHASE_STOPPING", S.PROJECT_BROADCAST_PHASE_STOPPED = "PROJECT_BROADCAST_PHASE_STOPPED", S.PROJECT_BROADCAST_PHASE_ARCHIVED = "PROJECT_BROADCAST_PHASE_ARCHIVED";
  })(me = a.ProjectBroadcastPhase || (a.ProjectBroadcastPhase = {}));
  function Ie(S) {
    switch (S) {
      case 0:
      case "PROJECT_BROADCAST_PHASE_UNSPECIFIED":
        return me.PROJECT_BROADCAST_PHASE_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_PHASE_NOT_RUNNING":
        return me.PROJECT_BROADCAST_PHASE_NOT_RUNNING;
      case 2:
      case "PROJECT_BROADCAST_PHASE_WAITING":
        return me.PROJECT_BROADCAST_PHASE_WAITING;
      case 3:
      case "PROJECT_BROADCAST_PHASE_STARTING":
        return me.PROJECT_BROADCAST_PHASE_STARTING;
      case 4:
      case "PROJECT_BROADCAST_PHASE_RUNNING":
        return me.PROJECT_BROADCAST_PHASE_RUNNING;
      case 5:
      case "PROJECT_BROADCAST_PHASE_STOPPING":
        return me.PROJECT_BROADCAST_PHASE_STOPPING;
      case 6:
      case "PROJECT_BROADCAST_PHASE_STOPPED":
        return me.PROJECT_BROADCAST_PHASE_STOPPED;
      case 7:
      case "PROJECT_BROADCAST_PHASE_ARCHIVED":
        return me.PROJECT_BROADCAST_PHASE_ARCHIVED;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseFromJSON = Ie;
  function $e(S) {
    switch (S) {
      case me.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return "PROJECT_BROADCAST_PHASE_UNSPECIFIED";
      case me.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return "PROJECT_BROADCAST_PHASE_NOT_RUNNING";
      case me.PROJECT_BROADCAST_PHASE_WAITING:
        return "PROJECT_BROADCAST_PHASE_WAITING";
      case me.PROJECT_BROADCAST_PHASE_STARTING:
        return "PROJECT_BROADCAST_PHASE_STARTING";
      case me.PROJECT_BROADCAST_PHASE_RUNNING:
        return "PROJECT_BROADCAST_PHASE_RUNNING";
      case me.PROJECT_BROADCAST_PHASE_STOPPING:
        return "PROJECT_BROADCAST_PHASE_STOPPING";
      case me.PROJECT_BROADCAST_PHASE_STOPPED:
        return "PROJECT_BROADCAST_PHASE_STOPPED";
      case me.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return "PROJECT_BROADCAST_PHASE_ARCHIVED";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseToJSON = $e;
  function ye(S) {
    switch (S) {
      case me.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return 0;
      case me.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return 1;
      case me.PROJECT_BROADCAST_PHASE_WAITING:
        return 2;
      case me.PROJECT_BROADCAST_PHASE_STARTING:
        return 3;
      case me.PROJECT_BROADCAST_PHASE_RUNNING:
        return 4;
      case me.PROJECT_BROADCAST_PHASE_STOPPING:
        return 5;
      case me.PROJECT_BROADCAST_PHASE_STOPPED:
        return 6;
      case me.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return 7;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseToNumber = ye;
  var fe;
  (function(S) {
    S.S3ACL_UNSPECIFIED = "S3ACL_UNSPECIFIED", S.S3ACL_PRIVATE = "S3ACL_PRIVATE", S.S3ACL_PUBLIC_READ = "S3ACL_PUBLIC_READ", S.S3ACL_PUBLIC_READ_WRITE = "S3ACL_PUBLIC_READ_WRITE", S.S3ACL_AUTHENTICATED_READ = "S3ACL_AUTHENTICATED_READ", S.S3ACL_BUCKET_OWNER_READ = "S3ACL_BUCKET_OWNER_READ", S.S3ACL_BUCKET_OWNER_FULL_CONTROL = "S3ACL_BUCKET_OWNER_FULL_CONTROL";
  })(fe = a.S3ACL || (a.S3ACL = {}));
  function Me(S) {
    switch (S) {
      case 0:
      case "S3ACL_UNSPECIFIED":
        return fe.S3ACL_UNSPECIFIED;
      case 1:
      case "S3ACL_PRIVATE":
        return fe.S3ACL_PRIVATE;
      case 2:
      case "S3ACL_PUBLIC_READ":
        return fe.S3ACL_PUBLIC_READ;
      case 3:
      case "S3ACL_PUBLIC_READ_WRITE":
        return fe.S3ACL_PUBLIC_READ_WRITE;
      case 4:
      case "S3ACL_AUTHENTICATED_READ":
        return fe.S3ACL_AUTHENTICATED_READ;
      case 5:
      case "S3ACL_BUCKET_OWNER_READ":
        return fe.S3ACL_BUCKET_OWNER_READ;
      case 6:
      case "S3ACL_BUCKET_OWNER_FULL_CONTROL":
        return fe.S3ACL_BUCKET_OWNER_FULL_CONTROL;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum S3ACL");
    }
  }
  a.s3ACLFromJSON = Me;
  function Ae(S) {
    switch (S) {
      case fe.S3ACL_UNSPECIFIED:
        return "S3ACL_UNSPECIFIED";
      case fe.S3ACL_PRIVATE:
        return "S3ACL_PRIVATE";
      case fe.S3ACL_PUBLIC_READ:
        return "S3ACL_PUBLIC_READ";
      case fe.S3ACL_PUBLIC_READ_WRITE:
        return "S3ACL_PUBLIC_READ_WRITE";
      case fe.S3ACL_AUTHENTICATED_READ:
        return "S3ACL_AUTHENTICATED_READ";
      case fe.S3ACL_BUCKET_OWNER_READ:
        return "S3ACL_BUCKET_OWNER_READ";
      case fe.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return "S3ACL_BUCKET_OWNER_FULL_CONTROL";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum S3ACL");
    }
  }
  a.s3ACLToJSON = Ae;
  function xe(S) {
    switch (S) {
      case fe.S3ACL_UNSPECIFIED:
        return 0;
      case fe.S3ACL_PRIVATE:
        return 1;
      case fe.S3ACL_PUBLIC_READ:
        return 2;
      case fe.S3ACL_PUBLIC_READ_WRITE:
        return 3;
      case fe.S3ACL_AUTHENTICATED_READ:
        return 4;
      case fe.S3ACL_BUCKET_OWNER_READ:
        return 5;
      case fe.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return 6;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum S3ACL");
    }
  }
  a.s3ACLToNumber = xe;
  var ae;
  (function(S) {
    S.SOURCE_TRIGGER_ACTION_UNSPECIFIED = "SOURCE_TRIGGER_ACTION_UNSPECIFIED", S.SOURCE_TRIGGER_ACTION_IGNORE = "SOURCE_TRIGGER_ACTION_IGNORE", S.SOURCE_TRIGGER_ACTION_OR = "SOURCE_TRIGGER_ACTION_OR";
  })(ae = a.SourceTriggerAction || (a.SourceTriggerAction = {}));
  function N(S) {
    switch (S) {
      case 0:
      case "SOURCE_TRIGGER_ACTION_UNSPECIFIED":
        return ae.SOURCE_TRIGGER_ACTION_UNSPECIFIED;
      case 1:
      case "SOURCE_TRIGGER_ACTION_IGNORE":
        return ae.SOURCE_TRIGGER_ACTION_IGNORE;
      case 3:
      case "SOURCE_TRIGGER_ACTION_OR":
        return ae.SOURCE_TRIGGER_ACTION_OR;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionFromJSON = N;
  function re(S) {
    switch (S) {
      case ae.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return "SOURCE_TRIGGER_ACTION_UNSPECIFIED";
      case ae.SOURCE_TRIGGER_ACTION_IGNORE:
        return "SOURCE_TRIGGER_ACTION_IGNORE";
      case ae.SOURCE_TRIGGER_ACTION_OR:
        return "SOURCE_TRIGGER_ACTION_OR";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionToJSON = re;
  function le(S) {
    switch (S) {
      case ae.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return 0;
      case ae.SOURCE_TRIGGER_ACTION_IGNORE:
        return 1;
      case ae.SOURCE_TRIGGER_ACTION_OR:
        return 3;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionToNumber = le;
  var Ne;
  (function(S) {
    S.REGION_UNSPECIFIED = "REGION_UNSPECIFIED", S.REGION_US_EAST_1 = "REGION_US_EAST_1", S.REGION_US_EAST_2 = "REGION_US_EAST_2", S.REGION_US_WEST_1 = "REGION_US_WEST_1", S.REGION_US_WEST_2 = "REGION_US_WEST_2", S.REGION_US_CENTRAL_1 = "REGION_US_CENTRAL_1", S.REGION_AP_SOUTHEAST_1 = "REGION_AP_SOUTHEAST_1", S.REGION_AP_SOUTHEAST_2 = "REGION_AP_SOUTHEAST_2", S.REGION_AP_SOUTH_1 = "REGION_AP_SOUTH_1", S.REGION_CA_EAST_1 = "REGION_CA_EAST_1", S.REGION_EU_CENTRAL_1 = "REGION_EU_CENTRAL_1", S.REGION_EU_WEST_1 = "REGION_EU_WEST_1";
  })(Ne = a.Region || (a.Region = {}));
  function Oe(S) {
    switch (S) {
      case 0:
      case "REGION_UNSPECIFIED":
        return Ne.REGION_UNSPECIFIED;
      case 1:
      case "REGION_US_EAST_1":
        return Ne.REGION_US_EAST_1;
      case 2:
      case "REGION_US_EAST_2":
        return Ne.REGION_US_EAST_2;
      case 3:
      case "REGION_US_WEST_1":
        return Ne.REGION_US_WEST_1;
      case 4:
      case "REGION_US_WEST_2":
        return Ne.REGION_US_WEST_2;
      case 5:
      case "REGION_US_CENTRAL_1":
        return Ne.REGION_US_CENTRAL_1;
      case 10:
      case "REGION_AP_SOUTHEAST_1":
        return Ne.REGION_AP_SOUTHEAST_1;
      case 11:
      case "REGION_AP_SOUTHEAST_2":
        return Ne.REGION_AP_SOUTHEAST_2;
      case 15:
      case "REGION_AP_SOUTH_1":
        return Ne.REGION_AP_SOUTH_1;
      case 20:
      case "REGION_CA_EAST_1":
        return Ne.REGION_CA_EAST_1;
      case 30:
      case "REGION_EU_CENTRAL_1":
        return Ne.REGION_EU_CENTRAL_1;
      case 31:
      case "REGION_EU_WEST_1":
        return Ne.REGION_EU_WEST_1;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum Region");
    }
  }
  a.regionFromJSON = Oe;
  function qe(S) {
    switch (S) {
      case Ne.REGION_UNSPECIFIED:
        return "REGION_UNSPECIFIED";
      case Ne.REGION_US_EAST_1:
        return "REGION_US_EAST_1";
      case Ne.REGION_US_EAST_2:
        return "REGION_US_EAST_2";
      case Ne.REGION_US_WEST_1:
        return "REGION_US_WEST_1";
      case Ne.REGION_US_WEST_2:
        return "REGION_US_WEST_2";
      case Ne.REGION_US_CENTRAL_1:
        return "REGION_US_CENTRAL_1";
      case Ne.REGION_AP_SOUTHEAST_1:
        return "REGION_AP_SOUTHEAST_1";
      case Ne.REGION_AP_SOUTHEAST_2:
        return "REGION_AP_SOUTHEAST_2";
      case Ne.REGION_AP_SOUTH_1:
        return "REGION_AP_SOUTH_1";
      case Ne.REGION_CA_EAST_1:
        return "REGION_CA_EAST_1";
      case Ne.REGION_EU_CENTRAL_1:
        return "REGION_EU_CENTRAL_1";
      case Ne.REGION_EU_WEST_1:
        return "REGION_EU_WEST_1";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum Region");
    }
  }
  a.regionToJSON = qe;
  function je(S) {
    switch (S) {
      case Ne.REGION_UNSPECIFIED:
        return 0;
      case Ne.REGION_US_EAST_1:
        return 1;
      case Ne.REGION_US_EAST_2:
        return 2;
      case Ne.REGION_US_WEST_1:
        return 3;
      case Ne.REGION_US_WEST_2:
        return 4;
      case Ne.REGION_US_CENTRAL_1:
        return 5;
      case Ne.REGION_AP_SOUTHEAST_1:
        return 10;
      case Ne.REGION_AP_SOUTHEAST_2:
        return 11;
      case Ne.REGION_AP_SOUTH_1:
        return 15;
      case Ne.REGION_CA_EAST_1:
        return 20;
      case Ne.REGION_EU_CENTRAL_1:
        return 30;
      case Ne.REGION_EU_WEST_1:
        return 31;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum Region");
    }
  }
  a.regionToNumber = je;
  var Fe;
  (function(S) {
    S.ROLE_UNSPECIFIED = "ROLE_UNSPECIFIED", S.ROLE_HOST = "ROLE_HOST", S.ROLE_COHOST = "ROLE_COHOST", S.ROLE_CONTRIBUTOR = "ROLE_CONTRIBUTOR", S.ROLE_GUEST = "ROLE_GUEST", S.ROLE_VIEWER = "ROLE_VIEWER", S.ROLE_RENDERER = "ROLE_RENDERER", S.ROLE_PLATFORM = "ROLE_PLATFORM", S.ROLE_IMPERSONATE = "ROLE_IMPERSONATE";
  })(Fe = a.Role || (a.Role = {}));
  function yt(S) {
    switch (S) {
      case 0:
      case "ROLE_UNSPECIFIED":
        return Fe.ROLE_UNSPECIFIED;
      case 1:
      case "ROLE_HOST":
        return Fe.ROLE_HOST;
      case 2:
      case "ROLE_COHOST":
        return Fe.ROLE_COHOST;
      case 3:
      case "ROLE_CONTRIBUTOR":
        return Fe.ROLE_CONTRIBUTOR;
      case 4:
      case "ROLE_GUEST":
        return Fe.ROLE_GUEST;
      case 5:
      case "ROLE_VIEWER":
        return Fe.ROLE_VIEWER;
      case 6:
      case "ROLE_RENDERER":
        return Fe.ROLE_RENDERER;
      case 7:
      case "ROLE_PLATFORM":
        return Fe.ROLE_PLATFORM;
      case 8:
      case "ROLE_IMPERSONATE":
        return Fe.ROLE_IMPERSONATE;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum Role");
    }
  }
  a.roleFromJSON = yt;
  function Xe(S) {
    switch (S) {
      case Fe.ROLE_UNSPECIFIED:
        return "ROLE_UNSPECIFIED";
      case Fe.ROLE_HOST:
        return "ROLE_HOST";
      case Fe.ROLE_COHOST:
        return "ROLE_COHOST";
      case Fe.ROLE_CONTRIBUTOR:
        return "ROLE_CONTRIBUTOR";
      case Fe.ROLE_GUEST:
        return "ROLE_GUEST";
      case Fe.ROLE_VIEWER:
        return "ROLE_VIEWER";
      case Fe.ROLE_RENDERER:
        return "ROLE_RENDERER";
      case Fe.ROLE_PLATFORM:
        return "ROLE_PLATFORM";
      case Fe.ROLE_IMPERSONATE:
        return "ROLE_IMPERSONATE";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum Role");
    }
  }
  a.roleToJSON = Xe;
  function Ge(S) {
    switch (S) {
      case Fe.ROLE_UNSPECIFIED:
        return 0;
      case Fe.ROLE_HOST:
        return 1;
      case Fe.ROLE_COHOST:
        return 2;
      case Fe.ROLE_CONTRIBUTOR:
        return 3;
      case Fe.ROLE_GUEST:
        return 4;
      case Fe.ROLE_VIEWER:
        return 5;
      case Fe.ROLE_RENDERER:
        return 6;
      case Fe.ROLE_PLATFORM:
        return 7;
      case Fe.ROLE_IMPERSONATE:
        return 8;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum Role");
    }
  }
  a.roleToNumber = Ge;
  var V;
  (function(S) {
    S.PROJECT_BROADCAST_ERROR_UNSPECIFIED = "PROJECT_BROADCAST_ERROR_UNSPECIFIED", S.PROJECT_BROADCAST_ERROR_INTERNAL = "PROJECT_BROADCAST_ERROR_INTERNAL", S.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED = "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
  })(V = a.ProjectBroadcastError || (a.ProjectBroadcastError = {}));
  function ge(S) {
    switch (S) {
      case 0:
      case "PROJECT_BROADCAST_ERROR_UNSPECIFIED":
        return V.PROJECT_BROADCAST_ERROR_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_ERROR_INTERNAL":
        return V.PROJECT_BROADCAST_ERROR_INTERNAL;
      case 2:
      case "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED":
        return V.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorFromJSON = ge;
  function Te(S) {
    switch (S) {
      case V.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return "PROJECT_BROADCAST_ERROR_UNSPECIFIED";
      case V.PROJECT_BROADCAST_ERROR_INTERNAL:
        return "PROJECT_BROADCAST_ERROR_INTERNAL";
      case V.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorToJSON = Te;
  function We(S) {
    switch (S) {
      case V.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return 0;
      case V.PROJECT_BROADCAST_ERROR_INTERNAL:
        return 1;
      case V.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return 2;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorToNumber = We;
  var Re;
  (function(S) {
    S.CONNECT_STATE_UNSPECIFIED = "CONNECT_STATE_UNSPECIFIED", S.CONNECT_STATE_CONNECTED = "CONNECT_STATE_CONNECTED", S.CONNECT_STATE_DISCONNECTED = "CONNECT_STATE_DISCONNECTED";
  })(Re = a.ConnectState || (a.ConnectState = {}));
  function J(S) {
    switch (S) {
      case 0:
      case "CONNECT_STATE_UNSPECIFIED":
        return Re.CONNECT_STATE_UNSPECIFIED;
      case 1:
      case "CONNECT_STATE_CONNECTED":
        return Re.CONNECT_STATE_CONNECTED;
      case 2:
      case "CONNECT_STATE_DISCONNECTED":
        return Re.CONNECT_STATE_DISCONNECTED;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum ConnectState");
    }
  }
  a.connectStateFromJSON = J;
  function Ee(S) {
    switch (S) {
      case Re.CONNECT_STATE_UNSPECIFIED:
        return "CONNECT_STATE_UNSPECIFIED";
      case Re.CONNECT_STATE_CONNECTED:
        return "CONNECT_STATE_CONNECTED";
      case Re.CONNECT_STATE_DISCONNECTED:
        return "CONNECT_STATE_DISCONNECTED";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum ConnectState");
    }
  }
  a.connectStateToJSON = Ee;
  function ue(S) {
    switch (S) {
      case Re.CONNECT_STATE_UNSPECIFIED:
        return 0;
      case Re.CONNECT_STATE_CONNECTED:
        return 1;
      case Re.CONNECT_STATE_DISCONNECTED:
        return 2;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum ConnectState");
    }
  }
  a.connectStateToNumber = ue;
  var ce;
  (function(S) {
    S.EVENT_SUB_TYPE_UNSPECIFIED = "EVENT_SUB_TYPE_UNSPECIFIED", S.EVENT_SUB_TYPE_CREATE = "EVENT_SUB_TYPE_CREATE", S.EVENT_SUB_TYPE_UPDATE = "EVENT_SUB_TYPE_UPDATE", S.EVENT_SUB_TYPE_DELETE = "EVENT_SUB_TYPE_DELETE", S.EVENT_SUB_TYPE_ADD = "EVENT_SUB_TYPE_ADD", S.EVENT_SUB_TYPE_REMOVE = "EVENT_SUB_TYPE_REMOVE", S.EVENT_SUB_TYPE_STATE = "EVENT_SUB_TYPE_STATE";
  })(ce = a.EventSubType || (a.EventSubType = {}));
  function ve(S) {
    switch (S) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return ce.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return ce.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return ce.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return ce.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_ADD":
        return ce.EVENT_SUB_TYPE_ADD;
      case 5:
      case "EVENT_SUB_TYPE_REMOVE":
        return ce.EVENT_SUB_TYPE_REMOVE;
      case 6:
      case "EVENT_SUB_TYPE_STATE":
        return ce.EVENT_SUB_TYPE_STATE;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum EventSubType");
    }
  }
  a.eventSubTypeFromJSON = ve;
  function Ce(S) {
    switch (S) {
      case ce.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case ce.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case ce.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case ce.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case ce.EVENT_SUB_TYPE_ADD:
        return "EVENT_SUB_TYPE_ADD";
      case ce.EVENT_SUB_TYPE_REMOVE:
        return "EVENT_SUB_TYPE_REMOVE";
      case ce.EVENT_SUB_TYPE_STATE:
        return "EVENT_SUB_TYPE_STATE";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum EventSubType");
    }
  }
  a.eventSubTypeToJSON = Ce;
  function Be(S) {
    switch (S) {
      case ce.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case ce.EVENT_SUB_TYPE_CREATE:
        return 1;
      case ce.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case ce.EVENT_SUB_TYPE_DELETE:
        return 3;
      case ce.EVENT_SUB_TYPE_ADD:
        return 4;
      case ce.EVENT_SUB_TYPE_REMOVE:
        return 5;
      case ce.EVENT_SUB_TYPE_STATE:
        return 6;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum EventSubType");
    }
  }
  a.eventSubTypeToNumber = Be;
  var He;
  (function(S) {
    S.EVENT_TYPE_UNSPECIFIED = "EVENT_TYPE_UNSPECIFIED", S.EVENT_TYPE_COLLECTION = "EVENT_TYPE_COLLECTION", S.EVENT_TYPE_PROJECT = "EVENT_TYPE_PROJECT", S.EVENT_TYPE_SOURCE = "EVENT_TYPE_SOURCE", S.EVENT_TYPE_DESTINATION = "EVENT_TYPE_DESTINATION";
  })(He = a.EventType || (a.EventType = {}));
  function Ve(S) {
    switch (S) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return He.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_COLLECTION":
        return He.EVENT_TYPE_COLLECTION;
      case 2:
      case "EVENT_TYPE_PROJECT":
        return He.EVENT_TYPE_PROJECT;
      case 4:
      case "EVENT_TYPE_SOURCE":
        return He.EVENT_TYPE_SOURCE;
      case 5:
      case "EVENT_TYPE_DESTINATION":
        return He.EVENT_TYPE_DESTINATION;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum EventType");
    }
  }
  a.eventTypeFromJSON = Ve;
  function Ze(S) {
    switch (S) {
      case He.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case He.EVENT_TYPE_COLLECTION:
        return "EVENT_TYPE_COLLECTION";
      case He.EVENT_TYPE_PROJECT:
        return "EVENT_TYPE_PROJECT";
      case He.EVENT_TYPE_SOURCE:
        return "EVENT_TYPE_SOURCE";
      case He.EVENT_TYPE_DESTINATION:
        return "EVENT_TYPE_DESTINATION";
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum EventType");
    }
  }
  a.eventTypeToJSON = Ze;
  function Ke(S) {
    switch (S) {
      case He.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case He.EVENT_TYPE_COLLECTION:
        return 1;
      case He.EVENT_TYPE_PROJECT:
        return 2;
      case He.EVENT_TYPE_SOURCE:
        return 4;
      case He.EVENT_TYPE_DESTINATION:
        return 5;
      default:
        throw new It.Error("Unrecognized enum value " + S + " for enum EventType");
    }
  }
  a.eventTypeToNumber = Ke;
  function U() {
    return { height: void 0, width: void 0, framerate: void 0, colorSpace: void 0 };
  }
  a.VideoRendering = {
    encode(S, M = c.default.Writer.create()) {
      return S.height !== void 0 && M.uint32(8).uint32(S.height), S.width !== void 0 && M.uint32(16).uint32(S.width), S.framerate !== void 0 && M.uint32(29).float(S.framerate), S.colorSpace !== void 0 && M.uint32(32).int32(X(S.colorSpace)), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = U();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.height = L.uint32();
            break;
          case 2:
            oe.width = L.uint32();
            break;
          case 3:
            oe.framerate = L.float();
            break;
          case 4:
            oe.colorSpace = j(L.int32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        height: Le(S.height) ? Number(S.height) : void 0,
        width: Le(S.width) ? Number(S.width) : void 0,
        framerate: Le(S.framerate) ? Number(S.framerate) : void 0,
        colorSpace: Le(S.colorSpace) ? j(S.colorSpace) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.height !== void 0 && (M.height = Math.round(S.height)), S.width !== void 0 && (M.width = Math.round(S.width)), S.framerate !== void 0 && (M.framerate = S.framerate), S.colorSpace !== void 0 && (M.colorSpace = S.colorSpace !== void 0 ? ee(S.colorSpace) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we, oe;
      const Pe = U();
      return Pe.height = (M = S.height) !== null && M !== void 0 ? M : void 0, Pe.width = (L = S.width) !== null && L !== void 0 ? L : void 0, Pe.framerate = (we = S.framerate) !== null && we !== void 0 ? we : void 0, Pe.colorSpace = (oe = S.colorSpace) !== null && oe !== void 0 ? oe : void 0, Pe;
    }
  };
  function se() {
    return { channelLayout: void 0 };
  }
  a.AudioRendering = {
    encode(S, M = c.default.Writer.create()) {
      return S.channelLayout !== void 0 && M.uint32(8).int32(Z(S.channelLayout)), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = se();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.channelLayout = Q(L.int32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        channelLayout: Le(S.channelLayout) ? Q(S.channelLayout) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.channelLayout !== void 0 && (M.channelLayout = S.channelLayout !== void 0 ? ne(S.channelLayout) : void 0), M;
    },
    fromPartial(S) {
      var M;
      const L = se();
      return L.channelLayout = (M = S.channelLayout) !== null && M !== void 0 ? M : void 0, L;
    }
  };
  function Se() {
    return { video: void 0, audio: void 0, quality: void 0, targetLatency: void 0, complexity: void 0 };
  }
  a.Rendering = {
    encode(S, M = c.default.Writer.create()) {
      return S.video !== void 0 && a.VideoRendering.encode(S.video, M.uint32(10).fork()).ldelim(), S.audio !== void 0 && a.AudioRendering.encode(S.audio, M.uint32(18).fork()).ldelim(), S.quality !== void 0 && M.uint32(24).int32(be(S.quality)), S.targetLatency !== void 0 && M.uint32(32).uint32(S.targetLatency), S.complexity !== void 0 && M.uint32(40).int32(S.complexity), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Se();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.video = a.VideoRendering.decode(L, L.uint32());
            break;
          case 2:
            oe.audio = a.AudioRendering.decode(L, L.uint32());
            break;
          case 3:
            oe.quality = he(L.int32());
            break;
          case 4:
            oe.targetLatency = L.uint32();
            break;
          case 5:
            oe.complexity = L.int32();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        video: Le(S.video) ? a.VideoRendering.fromJSON(S.video) : void 0,
        audio: Le(S.audio) ? a.AudioRendering.fromJSON(S.audio) : void 0,
        quality: Le(S.quality) ? he(S.quality) : void 0,
        targetLatency: Le(S.targetLatency) ? Number(S.targetLatency) : void 0,
        complexity: Le(S.complexity) ? Number(S.complexity) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.video !== void 0 && (M.video = S.video ? a.VideoRendering.toJSON(S.video) : void 0), S.audio !== void 0 && (M.audio = S.audio ? a.AudioRendering.toJSON(S.audio) : void 0), S.quality !== void 0 && (M.quality = S.quality !== void 0 ? pe(S.quality) : void 0), S.targetLatency !== void 0 && (M.targetLatency = Math.round(S.targetLatency)), S.complexity !== void 0 && (M.complexity = Math.round(S.complexity)), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = Se();
      return oe.video = S.video !== void 0 && S.video !== null ? a.VideoRendering.fromPartial(S.video) : void 0, oe.audio = S.audio !== void 0 && S.audio !== null ? a.AudioRendering.fromPartial(S.audio) : void 0, oe.quality = (M = S.quality) !== null && M !== void 0 ? M : void 0, oe.targetLatency = (L = S.targetLatency) !== null && L !== void 0 ? L : void 0, oe.complexity = (we = S.complexity) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function Ue() {
    return { mode: void 0, targetBitrate: void 0, maxKeyFrameInterval: void 0 };
  }
  a.VideoCodecRateControl = {
    encode(S, M = c.default.Writer.create()) {
      return S.mode !== void 0 && M.uint32(8).int32(te(S.mode)), S.targetBitrate !== void 0 && M.uint32(16).uint32(S.targetBitrate), S.maxKeyFrameInterval !== void 0 && M.uint32(24).uint32(S.maxKeyFrameInterval), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Ue();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.mode = T(L.int32());
            break;
          case 2:
            oe.targetBitrate = L.uint32();
            break;
          case 3:
            oe.maxKeyFrameInterval = L.uint32();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        mode: Le(S.mode) ? T(S.mode) : void 0,
        targetBitrate: Le(S.targetBitrate) ? Number(S.targetBitrate) : void 0,
        maxKeyFrameInterval: Le(S.maxKeyFrameInterval) ? Number(S.maxKeyFrameInterval) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.mode !== void 0 && (M.mode = S.mode !== void 0 ? D(S.mode) : void 0), S.targetBitrate !== void 0 && (M.targetBitrate = Math.round(S.targetBitrate)), S.maxKeyFrameInterval !== void 0 && (M.maxKeyFrameInterval = Math.round(S.maxKeyFrameInterval)), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = Ue();
      return oe.mode = (M = S.mode) !== null && M !== void 0 ? M : void 0, oe.targetBitrate = (L = S.targetBitrate) !== null && L !== void 0 ? L : void 0, oe.maxKeyFrameInterval = (we = S.maxKeyFrameInterval) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function De() {
    return { codec: void 0, rateControl: void 0, profile: void 0 };
  }
  a.VideoEncoding = {
    encode(S, M = c.default.Writer.create()) {
      return S.codec !== void 0 && M.uint32(8).int32(z(S.codec)), S.rateControl !== void 0 && a.VideoCodecRateControl.encode(S.rateControl, M.uint32(18).fork()).ldelim(), S.profile !== void 0 && M.uint32(32).int32(k(S.profile)), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = De();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.codec = _e(L.int32());
            break;
          case 2:
            oe.rateControl = a.VideoCodecRateControl.decode(L, L.uint32());
            break;
          case 4:
            oe.profile = b(L.int32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        codec: Le(S.codec) ? _e(S.codec) : void 0,
        rateControl: Le(S.rateControl) ? a.VideoCodecRateControl.fromJSON(S.rateControl) : void 0,
        profile: Le(S.profile) ? b(S.profile) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.codec !== void 0 && (M.codec = S.codec !== void 0 ? q(S.codec) : void 0), S.rateControl !== void 0 && (M.rateControl = S.rateControl ? a.VideoCodecRateControl.toJSON(S.rateControl) : void 0), S.profile !== void 0 && (M.profile = S.profile !== void 0 ? E(S.profile) : void 0), M;
    },
    fromPartial(S) {
      var M, L;
      const we = De();
      return we.codec = (M = S.codec) !== null && M !== void 0 ? M : void 0, we.rateControl = S.rateControl !== void 0 && S.rateControl !== null ? a.VideoCodecRateControl.fromPartial(S.rateControl) : void 0, we.profile = (L = S.profile) !== null && L !== void 0 ? L : void 0, we;
    }
  };
  function Ye() {
    return { codec: void 0 };
  }
  a.AudioEncoding = {
    encode(S, M = c.default.Writer.create()) {
      return S.codec !== void 0 && M.uint32(8).int32(Y(S.codec)), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Ye();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.codec = A(L.int32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { codec: Le(S.codec) ? A(S.codec) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.codec !== void 0 && (M.codec = S.codec !== void 0 ? x(S.codec) : void 0), M;
    },
    fromPartial(S) {
      var M;
      const L = Ye();
      return L.codec = (M = S.codec) !== null && M !== void 0 ? M : void 0, L;
    }
  };
  function Qe() {
    return { video: void 0, audio: void 0 };
  }
  a.Encoding = {
    encode(S, M = c.default.Writer.create()) {
      return S.video !== void 0 && a.VideoEncoding.encode(S.video, M.uint32(10).fork()).ldelim(), S.audio !== void 0 && a.AudioEncoding.encode(S.audio, M.uint32(18).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Qe();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.video = a.VideoEncoding.decode(L, L.uint32());
            break;
          case 2:
            oe.audio = a.AudioEncoding.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        video: Le(S.video) ? a.VideoEncoding.fromJSON(S.video) : void 0,
        audio: Le(S.audio) ? a.AudioEncoding.fromJSON(S.audio) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.video !== void 0 && (M.video = S.video ? a.VideoEncoding.toJSON(S.video) : void 0), S.audio !== void 0 && (M.audio = S.audio ? a.AudioEncoding.toJSON(S.audio) : void 0), M;
    },
    fromPartial(S) {
      const M = Qe();
      return M.video = S.video !== void 0 && S.video !== null ? a.VideoEncoding.fromPartial(S.video) : void 0, M.audio = S.audio !== void 0 && S.audio !== null ? a.AudioEncoding.fromPartial(S.audio) : void 0, M;
    }
  };
  function st() {
    return {
      enabled: void 0,
      key: void 0,
      url: void 0,
      baseUrl: void 0,
      previewUrl: void 0,
      ingestId: void 0,
      secure: void 0,
      ingestType: void 0
    };
  }
  a.SourceRtmpPushAddress = {
    encode(S, M = c.default.Writer.create()) {
      return S.enabled !== void 0 && M.uint32(8).bool(S.enabled), S.key !== void 0 && M.uint32(18).string(S.key), S.url !== void 0 && M.uint32(26).string(S.url), S.baseUrl !== void 0 && M.uint32(34).string(S.baseUrl), S.previewUrl !== void 0 && M.uint32(42).string(S.previewUrl), S.ingestId !== void 0 && M.uint32(50).string(S.ingestId), S.secure !== void 0 && M.uint32(56).bool(S.secure), S.ingestType !== void 0 && M.uint32(66).string(S.ingestType), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = st();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.enabled = L.bool();
            break;
          case 2:
            oe.key = L.string();
            break;
          case 3:
            oe.url = L.string();
            break;
          case 4:
            oe.baseUrl = L.string();
            break;
          case 5:
            oe.previewUrl = L.string();
            break;
          case 6:
            oe.ingestId = L.string();
            break;
          case 7:
            oe.secure = L.bool();
            break;
          case 8:
            oe.ingestType = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        enabled: Le(S.enabled) ? !!S.enabled : void 0,
        key: Le(S.key) ? String(S.key) : void 0,
        url: Le(S.url) ? String(S.url) : void 0,
        baseUrl: Le(S.baseUrl) ? String(S.baseUrl) : void 0,
        previewUrl: Le(S.previewUrl) ? String(S.previewUrl) : void 0,
        ingestId: Le(S.ingestId) ? String(S.ingestId) : void 0,
        secure: Le(S.secure) ? !!S.secure : void 0,
        ingestType: Le(S.ingestType) ? String(S.ingestType) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.enabled !== void 0 && (M.enabled = S.enabled), S.key !== void 0 && (M.key = S.key), S.url !== void 0 && (M.url = S.url), S.baseUrl !== void 0 && (M.baseUrl = S.baseUrl), S.previewUrl !== void 0 && (M.previewUrl = S.previewUrl), S.ingestId !== void 0 && (M.ingestId = S.ingestId), S.secure !== void 0 && (M.secure = S.secure), S.ingestType !== void 0 && (M.ingestType = S.ingestType), M;
    },
    fromPartial(S) {
      var M, L, we, oe, Pe, bt, At, Dt;
      const Lt = st();
      return Lt.enabled = (M = S.enabled) !== null && M !== void 0 ? M : void 0, Lt.key = (L = S.key) !== null && L !== void 0 ? L : void 0, Lt.url = (we = S.url) !== null && we !== void 0 ? we : void 0, Lt.baseUrl = (oe = S.baseUrl) !== null && oe !== void 0 ? oe : void 0, Lt.previewUrl = (Pe = S.previewUrl) !== null && Pe !== void 0 ? Pe : void 0, Lt.ingestId = (bt = S.ingestId) !== null && bt !== void 0 ? bt : void 0, Lt.secure = (At = S.secure) !== null && At !== void 0 ? At : void 0, Lt.ingestType = (Dt = S.ingestType) !== null && Dt !== void 0 ? Dt : void 0, Lt;
    }
  };
  function St() {
    return {
      enabled: void 0,
      streamId: void 0,
      url: void 0,
      baseUrl: void 0,
      previewUrl: void 0,
      ingestId: void 0,
      ingestType: void 0
    };
  }
  a.SrtPushAddress = {
    encode(S, M = c.default.Writer.create()) {
      return S.enabled !== void 0 && M.uint32(8).bool(S.enabled), S.streamId !== void 0 && M.uint32(18).string(S.streamId), S.url !== void 0 && M.uint32(26).string(S.url), S.baseUrl !== void 0 && M.uint32(34).string(S.baseUrl), S.previewUrl !== void 0 && M.uint32(42).string(S.previewUrl), S.ingestId !== void 0 && M.uint32(50).string(S.ingestId), S.ingestType !== void 0 && M.uint32(58).string(S.ingestType), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = St();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.enabled = L.bool();
            break;
          case 2:
            oe.streamId = L.string();
            break;
          case 3:
            oe.url = L.string();
            break;
          case 4:
            oe.baseUrl = L.string();
            break;
          case 5:
            oe.previewUrl = L.string();
            break;
          case 6:
            oe.ingestId = L.string();
            break;
          case 7:
            oe.ingestType = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        enabled: Le(S.enabled) ? !!S.enabled : void 0,
        streamId: Le(S.streamId) ? String(S.streamId) : void 0,
        url: Le(S.url) ? String(S.url) : void 0,
        baseUrl: Le(S.baseUrl) ? String(S.baseUrl) : void 0,
        previewUrl: Le(S.previewUrl) ? String(S.previewUrl) : void 0,
        ingestId: Le(S.ingestId) ? String(S.ingestId) : void 0,
        ingestType: Le(S.ingestType) ? String(S.ingestType) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.enabled !== void 0 && (M.enabled = S.enabled), S.streamId !== void 0 && (M.streamId = S.streamId), S.url !== void 0 && (M.url = S.url), S.baseUrl !== void 0 && (M.baseUrl = S.baseUrl), S.previewUrl !== void 0 && (M.previewUrl = S.previewUrl), S.ingestId !== void 0 && (M.ingestId = S.ingestId), S.ingestType !== void 0 && (M.ingestType = S.ingestType), M;
    },
    fromPartial(S) {
      var M, L, we, oe, Pe, bt, At;
      const Dt = St();
      return Dt.enabled = (M = S.enabled) !== null && M !== void 0 ? M : void 0, Dt.streamId = (L = S.streamId) !== null && L !== void 0 ? L : void 0, Dt.url = (we = S.url) !== null && we !== void 0 ? we : void 0, Dt.baseUrl = (oe = S.baseUrl) !== null && oe !== void 0 ? oe : void 0, Dt.previewUrl = (Pe = S.previewUrl) !== null && Pe !== void 0 ? Pe : void 0, Dt.ingestId = (bt = S.ingestId) !== null && bt !== void 0 ? bt : void 0, Dt.ingestType = (At = S.ingestType) !== null && At !== void 0 ? At : void 0, Dt;
    }
  };
  function tt() {
    return { url: "" };
  }
  a.RtmpPullAddress = {
    encode(S, M = c.default.Writer.create()) {
      return S.url !== "" && M.uint32(10).string(S.url), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = tt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.url = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { url: Le(S.url) ? String(S.url) : "" };
    },
    toJSON(S) {
      const M = {};
      return S.url !== void 0 && (M.url = S.url), M;
    },
    fromPartial(S) {
      var M;
      const L = tt();
      return L.url = (M = S.url) !== null && M !== void 0 ? M : "", L;
    }
  };
  function it() {
    return { url: "" };
  }
  a.SrtPullAddress = {
    encode(S, M = c.default.Writer.create()) {
      return S.url !== "" && M.uint32(10).string(S.url), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = it();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.url = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { url: Le(S.url) ? String(S.url) : "" };
    },
    toJSON(S) {
      const M = {};
      return S.url !== void 0 && (M.url = S.url), M;
    },
    fromPartial(S) {
      var M;
      const L = it();
      return L.url = (M = S.url) !== null && M !== void 0 ? M : "", L;
    }
  };
  function Tt() {
    return { rtmpPush: void 0, srtPush: void 0, rtmpPull: void 0, srtPull: void 0 };
  }
  a.SourceAddress = {
    encode(S, M = c.default.Writer.create()) {
      return S.rtmpPush !== void 0 && a.SourceRtmpPushAddress.encode(S.rtmpPush, M.uint32(10).fork()).ldelim(), S.srtPush !== void 0 && a.SrtPushAddress.encode(S.srtPush, M.uint32(18).fork()).ldelim(), S.rtmpPull !== void 0 && a.RtmpPullAddress.encode(S.rtmpPull, M.uint32(26).fork()).ldelim(), S.srtPull !== void 0 && a.SrtPullAddress.encode(S.srtPull, M.uint32(34).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Tt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.rtmpPush = a.SourceRtmpPushAddress.decode(L, L.uint32());
            break;
          case 2:
            oe.srtPush = a.SrtPushAddress.decode(L, L.uint32());
            break;
          case 3:
            oe.rtmpPull = a.RtmpPullAddress.decode(L, L.uint32());
            break;
          case 4:
            oe.srtPull = a.SrtPullAddress.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        rtmpPush: Le(S.rtmpPush) ? a.SourceRtmpPushAddress.fromJSON(S.rtmpPush) : void 0,
        srtPush: Le(S.srtPush) ? a.SrtPushAddress.fromJSON(S.srtPush) : void 0,
        rtmpPull: Le(S.rtmpPull) ? a.RtmpPullAddress.fromJSON(S.rtmpPull) : void 0,
        srtPull: Le(S.srtPull) ? a.SrtPullAddress.fromJSON(S.srtPull) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.rtmpPush !== void 0 && (M.rtmpPush = S.rtmpPush ? a.SourceRtmpPushAddress.toJSON(S.rtmpPush) : void 0), S.srtPush !== void 0 && (M.srtPush = S.srtPush ? a.SrtPushAddress.toJSON(S.srtPush) : void 0), S.rtmpPull !== void 0 && (M.rtmpPull = S.rtmpPull ? a.RtmpPullAddress.toJSON(S.rtmpPull) : void 0), S.srtPull !== void 0 && (M.srtPull = S.srtPull ? a.SrtPullAddress.toJSON(S.srtPull) : void 0), M;
    },
    fromPartial(S) {
      const M = Tt();
      return M.rtmpPush = S.rtmpPush !== void 0 && S.rtmpPush !== null ? a.SourceRtmpPushAddress.fromPartial(S.rtmpPush) : void 0, M.srtPush = S.srtPush !== void 0 && S.srtPush !== null ? a.SrtPushAddress.fromPartial(S.srtPush) : void 0, M.rtmpPull = S.rtmpPull !== void 0 && S.rtmpPull !== null ? a.RtmpPullAddress.fromPartial(S.rtmpPull) : void 0, M.srtPull = S.srtPull !== void 0 && S.srtPull !== null ? a.SrtPullAddress.fromPartial(S.srtPull) : void 0, M;
    }
  };
  function rt() {
    return { key: void 0, url: "" };
  }
  a.DestinationRtmpPushAddress = {
    encode(S, M = c.default.Writer.create()) {
      return S.key !== void 0 && M.uint32(10).string(S.key), S.url !== "" && M.uint32(18).string(S.url), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = rt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.key = L.string();
            break;
          case 2:
            oe.url = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        key: Le(S.key) ? String(S.key) : void 0,
        url: Le(S.url) ? String(S.url) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.key !== void 0 && (M.key = S.key), S.url !== void 0 && (M.url = S.url), M;
    },
    fromPartial(S) {
      var M, L;
      const we = rt();
      return we.key = (M = S.key) !== null && M !== void 0 ? M : void 0, we.url = (L = S.url) !== null && L !== void 0 ? L : "", we;
    }
  };
  function dt() {
    return { url: "" };
  }
  a.DestinationSrtPushAddress = {
    encode(S, M = c.default.Writer.create()) {
      return S.url !== "" && M.uint32(18).string(S.url), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = dt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 2:
            oe.url = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { url: Le(S.url) ? String(S.url) : "" };
    },
    toJSON(S) {
      const M = {};
      return S.url !== void 0 && (M.url = S.url), M;
    },
    fromPartial(S) {
      var M;
      const L = dt();
      return L.url = (M = S.url) !== null && M !== void 0 ? M : "", L;
    }
  };
  function wt() {
    return { appId: "", channelId: "", userId: "" };
  }
  a.DestinationAgoraPushAddress = {
    encode(S, M = c.default.Writer.create()) {
      return S.appId !== "" && M.uint32(10).string(S.appId), S.channelId !== "" && M.uint32(18).string(S.channelId), S.userId !== "" && M.uint32(26).string(S.userId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = wt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.appId = L.string();
            break;
          case 2:
            oe.channelId = L.string();
            break;
          case 3:
            oe.userId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        appId: Le(S.appId) ? String(S.appId) : "",
        channelId: Le(S.channelId) ? String(S.channelId) : "",
        userId: Le(S.userId) ? String(S.userId) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.appId !== void 0 && (M.appId = S.appId), S.channelId !== void 0 && (M.channelId = S.channelId), S.userId !== void 0 && (M.userId = S.userId), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = wt();
      return oe.appId = (M = S.appId) !== null && M !== void 0 ? M : "", oe.channelId = (L = S.channelId) !== null && L !== void 0 ? L : "", oe.userId = (we = S.userId) !== null && we !== void 0 ? we : "", oe;
    }
  };
  function nt() {
    return { playlistCount: void 0, fileCount: void 0 };
  }
  a.HlsLifecycleLive = {
    encode(S, M = c.default.Writer.create()) {
      return S.playlistCount !== void 0 && M.uint32(8).int32(S.playlistCount), S.fileCount !== void 0 && M.uint32(16).int32(S.fileCount), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = nt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.playlistCount = L.int32();
            break;
          case 2:
            oe.fileCount = L.int32();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        playlistCount: Le(S.playlistCount) ? Number(S.playlistCount) : void 0,
        fileCount: Le(S.fileCount) ? Number(S.fileCount) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.playlistCount !== void 0 && (M.playlistCount = Math.round(S.playlistCount)), S.fileCount !== void 0 && (M.fileCount = Math.round(S.fileCount)), M;
    },
    fromPartial(S) {
      var M, L;
      const we = nt();
      return we.playlistCount = (M = S.playlistCount) !== null && M !== void 0 ? M : void 0, we.fileCount = (L = S.fileCount) !== null && L !== void 0 ? L : void 0, we;
    }
  };
  function at() {
    return { maxDuration: void 0 };
  }
  a.HlsLifecycleVod = {
    encode(S, M = c.default.Writer.create()) {
      return S.maxDuration !== void 0 && M.uint32(8).int32(S.maxDuration), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = at();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.maxDuration = L.int32();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { maxDuration: Le(S.maxDuration) ? Number(S.maxDuration) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.maxDuration !== void 0 && (M.maxDuration = Math.round(S.maxDuration)), M;
    },
    fromPartial(S) {
      var M;
      const L = at();
      return L.maxDuration = (M = S.maxDuration) !== null && M !== void 0 ? M : void 0, L;
    }
  };
  function gt() {
    return { vod: void 0, live: void 0 };
  }
  a.HlsLifecycle = {
    encode(S, M = c.default.Writer.create()) {
      return S.vod !== void 0 && a.HlsLifecycleVod.encode(S.vod, M.uint32(10).fork()).ldelim(), S.live !== void 0 && a.HlsLifecycleLive.encode(S.live, M.uint32(18).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = gt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.vod = a.HlsLifecycleVod.decode(L, L.uint32());
            break;
          case 2:
            oe.live = a.HlsLifecycleLive.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        vod: Le(S.vod) ? a.HlsLifecycleVod.fromJSON(S.vod) : void 0,
        live: Le(S.live) ? a.HlsLifecycleLive.fromJSON(S.live) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.vod !== void 0 && (M.vod = S.vod ? a.HlsLifecycleVod.toJSON(S.vod) : void 0), S.live !== void 0 && (M.live = S.live ? a.HlsLifecycleLive.toJSON(S.live) : void 0), M;
    },
    fromPartial(S) {
      const M = gt();
      return M.vod = S.vod !== void 0 && S.vod !== null ? a.HlsLifecycleVod.fromPartial(S.vod) : void 0, M.live = S.live !== void 0 && S.live !== null ? a.HlsLifecycleLive.fromPartial(S.live) : void 0, M;
    }
  };
  function ot() {
    return { lifecycle: void 0, segmentDuration: void 0 };
  }
  a.HlsPackaging = {
    encode(S, M = c.default.Writer.create()) {
      return S.lifecycle !== void 0 && a.HlsLifecycle.encode(S.lifecycle, M.uint32(10).fork()).ldelim(), S.segmentDuration !== void 0 && M.uint32(16).int32(S.segmentDuration), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = ot();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.lifecycle = a.HlsLifecycle.decode(L, L.uint32());
            break;
          case 2:
            oe.segmentDuration = L.int32();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        lifecycle: Le(S.lifecycle) ? a.HlsLifecycle.fromJSON(S.lifecycle) : void 0,
        segmentDuration: Le(S.segmentDuration) ? Number(S.segmentDuration) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.lifecycle !== void 0 && (M.lifecycle = S.lifecycle ? a.HlsLifecycle.toJSON(S.lifecycle) : void 0), S.segmentDuration !== void 0 && (M.segmentDuration = Math.round(S.segmentDuration)), M;
    },
    fromPartial(S) {
      var M;
      const L = ot();
      return L.lifecycle = S.lifecycle !== void 0 && S.lifecycle !== null ? a.HlsLifecycle.fromPartial(S.lifecycle) : void 0, L.segmentDuration = (M = S.segmentDuration) !== null && M !== void 0 ? M : void 0, L;
    }
  };
  function ct() {
    return { hls: void 0 };
  }
  a.ObjectStoragePackaging = {
    encode(S, M = c.default.Writer.create()) {
      return S.hls !== void 0 && a.HlsPackaging.encode(S.hls, M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = ct();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.hls = a.HlsPackaging.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { hls: Le(S.hls) ? a.HlsPackaging.fromJSON(S.hls) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.hls !== void 0 && (M.hls = S.hls ? a.HlsPackaging.toJSON(S.hls) : void 0), M;
    },
    fromPartial(S) {
      const M = ct();
      return M.hls = S.hls !== void 0 && S.hls !== null ? a.HlsPackaging.fromPartial(S.hls) : void 0, M;
    }
  };
  function Ct() {
    return {
      region: "",
      bucket: "",
      prefix: void 0,
      accessKey: "",
      secretKey: "",
      token: void 0,
      tokenDuration: void 0,
      acl: void 0,
      endpoint: void 0,
      packaging: void 0
    };
  }
  a.S3StorageAddress = {
    encode(S, M = c.default.Writer.create()) {
      return S.region !== "" && M.uint32(10).string(S.region), S.bucket !== "" && M.uint32(18).string(S.bucket), S.prefix !== void 0 && M.uint32(26).string(S.prefix), S.accessKey !== "" && M.uint32(34).string(S.accessKey), S.secretKey !== "" && M.uint32(42).string(S.secretKey), S.token !== void 0 && M.uint32(50).string(S.token), S.tokenDuration !== void 0 && M.uint32(56).int32(S.tokenDuration), S.acl !== void 0 && M.uint32(64).int32(xe(S.acl)), S.endpoint !== void 0 && M.uint32(74).string(S.endpoint), S.packaging !== void 0 && a.ObjectStoragePackaging.encode(S.packaging, M.uint32(82).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Ct();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.region = L.string();
            break;
          case 2:
            oe.bucket = L.string();
            break;
          case 3:
            oe.prefix = L.string();
            break;
          case 4:
            oe.accessKey = L.string();
            break;
          case 5:
            oe.secretKey = L.string();
            break;
          case 6:
            oe.token = L.string();
            break;
          case 7:
            oe.tokenDuration = L.int32();
            break;
          case 8:
            oe.acl = Me(L.int32());
            break;
          case 9:
            oe.endpoint = L.string();
            break;
          case 10:
            oe.packaging = a.ObjectStoragePackaging.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        region: Le(S.region) ? String(S.region) : "",
        bucket: Le(S.bucket) ? String(S.bucket) : "",
        prefix: Le(S.prefix) ? String(S.prefix) : void 0,
        accessKey: Le(S.accessKey) ? String(S.accessKey) : "",
        secretKey: Le(S.secretKey) ? String(S.secretKey) : "",
        token: Le(S.token) ? String(S.token) : void 0,
        tokenDuration: Le(S.tokenDuration) ? Number(S.tokenDuration) : void 0,
        acl: Le(S.acl) ? Me(S.acl) : void 0,
        endpoint: Le(S.endpoint) ? String(S.endpoint) : void 0,
        packaging: Le(S.packaging) ? a.ObjectStoragePackaging.fromJSON(S.packaging) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.region !== void 0 && (M.region = S.region), S.bucket !== void 0 && (M.bucket = S.bucket), S.prefix !== void 0 && (M.prefix = S.prefix), S.accessKey !== void 0 && (M.accessKey = S.accessKey), S.secretKey !== void 0 && (M.secretKey = S.secretKey), S.token !== void 0 && (M.token = S.token), S.tokenDuration !== void 0 && (M.tokenDuration = Math.round(S.tokenDuration)), S.acl !== void 0 && (M.acl = S.acl !== void 0 ? Ae(S.acl) : void 0), S.endpoint !== void 0 && (M.endpoint = S.endpoint), S.packaging !== void 0 && (M.packaging = S.packaging ? a.ObjectStoragePackaging.toJSON(S.packaging) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we, oe, Pe, bt, At, Dt, Lt;
      const Ft = Ct();
      return Ft.region = (M = S.region) !== null && M !== void 0 ? M : "", Ft.bucket = (L = S.bucket) !== null && L !== void 0 ? L : "", Ft.prefix = (we = S.prefix) !== null && we !== void 0 ? we : void 0, Ft.accessKey = (oe = S.accessKey) !== null && oe !== void 0 ? oe : "", Ft.secretKey = (Pe = S.secretKey) !== null && Pe !== void 0 ? Pe : "", Ft.token = (bt = S.token) !== null && bt !== void 0 ? bt : void 0, Ft.tokenDuration = (At = S.tokenDuration) !== null && At !== void 0 ? At : void 0, Ft.acl = (Dt = S.acl) !== null && Dt !== void 0 ? Dt : void 0, Ft.endpoint = (Lt = S.endpoint) !== null && Lt !== void 0 ? Lt : void 0, Ft.packaging = S.packaging !== void 0 && S.packaging !== null ? a.ObjectStoragePackaging.fromPartial(S.packaging) : void 0, Ft;
    }
  };
  function ut() {
    return { rtmpPush: void 0, agora: void 0, s3Storage: void 0, srtPush: void 0 };
  }
  a.DestinationAddress = {
    encode(S, M = c.default.Writer.create()) {
      return S.rtmpPush !== void 0 && a.DestinationRtmpPushAddress.encode(S.rtmpPush, M.uint32(10).fork()).ldelim(), S.agora !== void 0 && a.DestinationAgoraPushAddress.encode(S.agora, M.uint32(18).fork()).ldelim(), S.s3Storage !== void 0 && a.S3StorageAddress.encode(S.s3Storage, M.uint32(26).fork()).ldelim(), S.srtPush !== void 0 && a.DestinationSrtPushAddress.encode(S.srtPush, M.uint32(34).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = ut();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.rtmpPush = a.DestinationRtmpPushAddress.decode(L, L.uint32());
            break;
          case 2:
            oe.agora = a.DestinationAgoraPushAddress.decode(L, L.uint32());
            break;
          case 3:
            oe.s3Storage = a.S3StorageAddress.decode(L, L.uint32());
            break;
          case 4:
            oe.srtPush = a.DestinationSrtPushAddress.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        rtmpPush: Le(S.rtmpPush) ? a.DestinationRtmpPushAddress.fromJSON(S.rtmpPush) : void 0,
        agora: Le(S.agora) ? a.DestinationAgoraPushAddress.fromJSON(S.agora) : void 0,
        s3Storage: Le(S.s3Storage) ? a.S3StorageAddress.fromJSON(S.s3Storage) : void 0,
        srtPush: Le(S.srtPush) ? a.DestinationSrtPushAddress.fromJSON(S.srtPush) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.rtmpPush !== void 0 && (M.rtmpPush = S.rtmpPush ? a.DestinationRtmpPushAddress.toJSON(S.rtmpPush) : void 0), S.agora !== void 0 && (M.agora = S.agora ? a.DestinationAgoraPushAddress.toJSON(S.agora) : void 0), S.s3Storage !== void 0 && (M.s3Storage = S.s3Storage ? a.S3StorageAddress.toJSON(S.s3Storage) : void 0), S.srtPush !== void 0 && (M.srtPush = S.srtPush ? a.DestinationSrtPushAddress.toJSON(S.srtPush) : void 0), M;
    },
    fromPartial(S) {
      const M = ut();
      return M.rtmpPush = S.rtmpPush !== void 0 && S.rtmpPush !== null ? a.DestinationRtmpPushAddress.fromPartial(S.rtmpPush) : void 0, M.agora = S.agora !== void 0 && S.agora !== null ? a.DestinationAgoraPushAddress.fromPartial(S.agora) : void 0, M.s3Storage = S.s3Storage !== void 0 && S.s3Storage !== null ? a.S3StorageAddress.fromPartial(S.s3Storage) : void 0, M.srtPush = S.srtPush !== void 0 && S.srtPush !== null ? a.DestinationSrtPushAddress.fromPartial(S.srtPush) : void 0, M;
    }
  };
  function lt() {
    return { sourceId: "", start: void 0, stop: void 0 };
  }
  a.SourceTrigger = {
    encode(S, M = c.default.Writer.create()) {
      return S.sourceId !== "" && M.uint32(10).string(S.sourceId), S.start !== void 0 && M.uint32(16).int32(le(S.start)), S.stop !== void 0 && M.uint32(24).int32(le(S.stop)), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = lt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.sourceId = L.string();
            break;
          case 2:
            oe.start = N(L.int32());
            break;
          case 3:
            oe.stop = N(L.int32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        sourceId: Le(S.sourceId) ? String(S.sourceId) : "",
        start: Le(S.start) ? N(S.start) : void 0,
        stop: Le(S.stop) ? N(S.stop) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.sourceId !== void 0 && (M.sourceId = S.sourceId), S.start !== void 0 && (M.start = S.start !== void 0 ? re(S.start) : void 0), S.stop !== void 0 && (M.stop = S.stop !== void 0 ? re(S.stop) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = lt();
      return oe.sourceId = (M = S.sourceId) !== null && M !== void 0 ? M : "", oe.start = (L = S.start) !== null && L !== void 0 ? L : void 0, oe.stop = (we = S.stop) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function kt() {
    return { stop: void 0 };
  }
  a.WebRtcTrigger = {
    encode(S, M = c.default.Writer.create()) {
      return S.stop !== void 0 && M.uint32(24).int32(le(S.stop)), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = kt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 3:
            oe.stop = N(L.int32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { stop: Le(S.stop) ? N(S.stop) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.stop !== void 0 && (M.stop = S.stop !== void 0 ? re(S.stop) : void 0), M;
    },
    fromPartial(S) {
      var M;
      const L = kt();
      return L.stop = (M = S.stop) !== null && M !== void 0 ? M : void 0, L;
    }
  };
  function Rt() {
    return { source: void 0 };
  }
  a.ProjectTrigger = {
    encode(S, M = c.default.Writer.create()) {
      return S.source !== void 0 && a.SourceTrigger.encode(S.source, M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Rt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.source = a.SourceTrigger.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { source: Le(S.source) ? a.SourceTrigger.fromJSON(S.source) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.source !== void 0 && (M.source = S.source ? a.SourceTrigger.toJSON(S.source) : void 0), M;
    },
    fromPartial(S) {
      const M = Rt();
      return M.source = S.source !== void 0 && S.source !== null ? a.SourceTrigger.fromPartial(S.source) : void 0, M;
    }
  };
  function Je() {
    return { enabled: void 0, url: void 0 };
  }
  a.PreviewHlsPullAddress = {
    encode(S, M = c.default.Writer.create()) {
      return S.enabled !== void 0 && M.uint32(8).bool(S.enabled), S.url !== void 0 && M.uint32(18).string(S.url), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Je();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.enabled = L.bool();
            break;
          case 2:
            oe.url = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        enabled: Le(S.enabled) ? !!S.enabled : void 0,
        url: Le(S.url) ? String(S.url) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.enabled !== void 0 && (M.enabled = S.enabled), S.url !== void 0 && (M.url = S.url), M;
    },
    fromPartial(S) {
      var M, L;
      const we = Je();
      return we.enabled = (M = S.enabled) !== null && M !== void 0 ? M : void 0, we.url = (L = S.url) !== null && L !== void 0 ? L : void 0, we;
    }
  };
  function ze() {
    return { enabled: void 0, displayName: void 0, participantId: void 0 };
  }
  a.PreviewWebRtcAddress = {
    encode(S, M = c.default.Writer.create()) {
      return S.enabled !== void 0 && M.uint32(8).bool(S.enabled), S.displayName !== void 0 && M.uint32(18).string(S.displayName), S.participantId !== void 0 && M.uint32(26).string(S.participantId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = ze();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.enabled = L.bool();
            break;
          case 2:
            oe.displayName = L.string();
            break;
          case 3:
            oe.participantId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        enabled: Le(S.enabled) ? !!S.enabled : void 0,
        displayName: Le(S.displayName) ? String(S.displayName) : void 0,
        participantId: Le(S.participantId) ? String(S.participantId) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.enabled !== void 0 && (M.enabled = S.enabled), S.displayName !== void 0 && (M.displayName = S.displayName), S.participantId !== void 0 && (M.participantId = S.participantId), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = ze();
      return oe.enabled = (M = S.enabled) !== null && M !== void 0 ? M : void 0, oe.displayName = (L = S.displayName) !== null && L !== void 0 ? L : void 0, oe.participantId = (we = S.participantId) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function et() {
    return { webrtc: void 0 };
  }
  a.PreviewAddress = {
    encode(S, M = c.default.Writer.create()) {
      return S.webrtc !== void 0 && a.PreviewWebRtcAddress.encode(S.webrtc, M.uint32(18).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = et();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 2:
            oe.webrtc = a.PreviewWebRtcAddress.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { webrtc: Le(S.webrtc) ? a.PreviewWebRtcAddress.fromJSON(S.webrtc) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.webrtc !== void 0 && (M.webrtc = S.webrtc ? a.PreviewWebRtcAddress.toJSON(S.webrtc) : void 0), M;
    },
    fromPartial(S) {
      const M = et();
      return M.webrtc = S.webrtc !== void 0 && S.webrtc !== null ? a.PreviewWebRtcAddress.fromPartial(S.webrtc) : void 0, M;
    }
  };
  function pt() {
    return { rendererUrl: void 0, version: void 0 };
  }
  a.StudioSdkComposition = {
    encode(S, M = c.default.Writer.create()) {
      return S.rendererUrl !== void 0 && M.uint32(10).string(S.rendererUrl), S.version !== void 0 && M.uint32(18).string(S.version), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = pt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.rendererUrl = L.string();
            break;
          case 2:
            oe.version = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        rendererUrl: Le(S.rendererUrl) ? String(S.rendererUrl) : void 0,
        version: Le(S.version) ? String(S.version) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.rendererUrl !== void 0 && (M.rendererUrl = S.rendererUrl), S.version !== void 0 && (M.version = S.version), M;
    },
    fromPartial(S) {
      var M, L;
      const we = pt();
      return we.rendererUrl = (M = S.rendererUrl) !== null && M !== void 0 ? M : void 0, we.version = (L = S.version) !== null && L !== void 0 ? L : void 0, we;
    }
  };
  function mt() {
    return { rendererUrl: void 0, selectedLayoutId: void 0, debug: void 0 };
  }
  a.SceneComposition = {
    encode(S, M = c.default.Writer.create()) {
      return S.rendererUrl !== void 0 && M.uint32(10).string(S.rendererUrl), S.selectedLayoutId !== void 0 && M.uint32(18).string(S.selectedLayoutId), S.debug !== void 0 && M.uint32(24).bool(S.debug), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = mt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.rendererUrl = L.string();
            break;
          case 2:
            oe.selectedLayoutId = L.string();
            break;
          case 3:
            oe.debug = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        rendererUrl: Le(S.rendererUrl) ? String(S.rendererUrl) : void 0,
        selectedLayoutId: Le(S.selectedLayoutId) ? String(S.selectedLayoutId) : void 0,
        debug: Le(S.debug) ? !!S.debug : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.rendererUrl !== void 0 && (M.rendererUrl = S.rendererUrl), S.selectedLayoutId !== void 0 && (M.selectedLayoutId = S.selectedLayoutId), S.debug !== void 0 && (M.debug = S.debug), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = mt();
      return oe.rendererUrl = (M = S.rendererUrl) !== null && M !== void 0 ? M : void 0, oe.selectedLayoutId = (L = S.selectedLayoutId) !== null && L !== void 0 ? L : void 0, oe.debug = (we = S.debug) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function vt() {
    return { url: "" };
  }
  a.ExternalComposition = {
    encode(S, M = c.default.Writer.create()) {
      return S.url !== "" && M.uint32(10).string(S.url), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = vt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.url = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { url: Le(S.url) ? String(S.url) : "" };
    },
    toJSON(S) {
      const M = {};
      return S.url !== void 0 && (M.url = S.url), M;
    },
    fromPartial(S) {
      var M;
      const L = vt();
      return L.url = (M = S.url) !== null && M !== void 0 ? M : "", L;
    }
  };
  function ht() {
    return { external: void 0, studioSdk: void 0, scene: void 0 };
  }
  a.Composition = {
    encode(S, M = c.default.Writer.create()) {
      return S.external !== void 0 && a.ExternalComposition.encode(S.external, M.uint32(10).fork()).ldelim(), S.studioSdk !== void 0 && a.StudioSdkComposition.encode(S.studioSdk, M.uint32(18).fork()).ldelim(), S.scene !== void 0 && a.SceneComposition.encode(S.scene, M.uint32(34).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = ht();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.external = a.ExternalComposition.decode(L, L.uint32());
            break;
          case 2:
            oe.studioSdk = a.StudioSdkComposition.decode(L, L.uint32());
            break;
          case 4:
            oe.scene = a.SceneComposition.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        external: Le(S.external) ? a.ExternalComposition.fromJSON(S.external) : void 0,
        studioSdk: Le(S.studioSdk) ? a.StudioSdkComposition.fromJSON(S.studioSdk) : void 0,
        scene: Le(S.scene) ? a.SceneComposition.fromJSON(S.scene) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.external !== void 0 && (M.external = S.external ? a.ExternalComposition.toJSON(S.external) : void 0), S.studioSdk !== void 0 && (M.studioSdk = S.studioSdk ? a.StudioSdkComposition.toJSON(S.studioSdk) : void 0), S.scene !== void 0 && (M.scene = S.scene ? a.SceneComposition.toJSON(S.scene) : void 0), M;
    },
    fromPartial(S) {
      const M = ht();
      return M.external = S.external !== void 0 && S.external !== null ? a.ExternalComposition.fromPartial(S.external) : void 0, M.studioSdk = S.studioSdk !== void 0 && S.studioSdk !== null ? a.StudioSdkComposition.fromPartial(S.studioSdk) : void 0, M.scene = S.scene !== void 0 && S.scene !== null ? a.SceneComposition.fromPartial(S.scene) : void 0, M;
    }
  };
  function _t() {
    return { enabled: void 0 };
  }
  a.HostedWebRtc = {
    encode(S, M = c.default.Writer.create()) {
      return S.enabled !== void 0 && M.uint32(8).bool(S.enabled), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = _t();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.enabled = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { enabled: Le(S.enabled) ? !!S.enabled : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.enabled !== void 0 && (M.enabled = S.enabled), M;
    },
    fromPartial(S) {
      var M;
      const L = _t();
      return L.enabled = (M = S.enabled) !== null && M !== void 0 ? M : void 0, L;
    }
  };
  function Et() {
    return { hosted: void 0 };
  }
  a.WebRtc = {
    encode(S, M = c.default.Writer.create()) {
      return S.hosted !== void 0 && a.HostedWebRtc.encode(S.hosted, M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Et();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.hosted = a.HostedWebRtc.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { hosted: Le(S.hosted) ? a.HostedWebRtc.fromJSON(S.hosted) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.hosted !== void 0 && (M.hosted = S.hosted ? a.HostedWebRtc.toJSON(S.hosted) : void 0), M;
    },
    fromPartial(S) {
      const M = Et();
      return M.hosted = S.hosted !== void 0 && S.hosted !== null ? a.HostedWebRtc.fromPartial(S.hosted) : void 0, M;
    }
  };
  function Pt() {
    return { accessToken: "", participantId: void 0 };
  }
  a.WebRtcAccess = {
    encode(S, M = c.default.Writer.create()) {
      return S.accessToken !== "" && M.uint32(10).string(S.accessToken), S.participantId !== void 0 && M.uint32(26).string(S.participantId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Pt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.accessToken = L.string();
            break;
          case 3:
            oe.participantId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        accessToken: Le(S.accessToken) ? String(S.accessToken) : "",
        participantId: Le(S.participantId) ? String(S.participantId) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.accessToken !== void 0 && (M.accessToken = S.accessToken), S.participantId !== void 0 && (M.participantId = S.participantId), M;
    },
    fromPartial(S) {
      var M, L;
      const we = Pt();
      return we.accessToken = (M = S.accessToken) !== null && M !== void 0 ? M : "", we.participantId = (L = S.participantId) !== null && L !== void 0 ? L : void 0, we;
    }
  };
  function Nt() {
    return { latitude: 0, longitude: 0 };
  }
  a.LatLong = {
    encode(S, M = c.default.Writer.create()) {
      return S.latitude !== 0 && M.uint32(9).double(S.latitude), S.longitude !== 0 && M.uint32(17).double(S.longitude), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Nt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.latitude = L.double();
            break;
          case 2:
            oe.longitude = L.double();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        latitude: Le(S.latitude) ? Number(S.latitude) : 0,
        longitude: Le(S.longitude) ? Number(S.longitude) : 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.latitude !== void 0 && (M.latitude = S.latitude), S.longitude !== void 0 && (M.longitude = S.longitude), M;
    },
    fromPartial(S) {
      var M, L;
      const we = Nt();
      return we.latitude = (M = S.latitude) !== null && M !== void 0 ? M : 0, we.longitude = (L = S.longitude) !== null && L !== void 0 ? L : 0, we;
    }
  };
  function Mt() {
    return {
      collectionId: "",
      projectId: "",
      broadcastId: void 0,
      duration: void 0,
      start: void 0,
      stop: void 0,
      phase: me.PROJECT_BROADCAST_PHASE_UNSPECIFIED,
      region: void 0,
      datacenter: void 0
    };
  }
  a.ProjectBroadcastStatus = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.broadcastId !== void 0 && M.uint32(26).string(S.broadcastId), S.duration !== void 0 && M.uint32(32).uint32(S.duration), S.start !== void 0 && _.Timestamp.encode(Ht(S.start), M.uint32(42).fork()).ldelim(), S.stop !== void 0 && _.Timestamp.encode(Ht(S.stop), M.uint32(50).fork()).ldelim(), S.phase !== me.PROJECT_BROADCAST_PHASE_UNSPECIFIED && M.uint32(56).int32(ye(S.phase)), S.region !== void 0 && M.uint32(64).int32(je(S.region)), S.datacenter !== void 0 && M.uint32(74).string(S.datacenter), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Mt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.broadcastId = L.string();
            break;
          case 4:
            oe.duration = L.uint32();
            break;
          case 5:
            oe.start = zt(_.Timestamp.decode(L, L.uint32()));
            break;
          case 6:
            oe.stop = zt(_.Timestamp.decode(L, L.uint32()));
            break;
          case 7:
            oe.phase = Ie(L.int32());
            break;
          case 8:
            oe.region = Oe(L.int32());
            break;
          case 9:
            oe.datacenter = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        broadcastId: Le(S.broadcastId) ? String(S.broadcastId) : void 0,
        duration: Le(S.duration) ? Number(S.duration) : void 0,
        start: Le(S.start) ? String(S.start) : void 0,
        stop: Le(S.stop) ? String(S.stop) : void 0,
        phase: Le(S.phase) ? Ie(S.phase) : me.PROJECT_BROADCAST_PHASE_UNSPECIFIED,
        region: Le(S.region) ? Oe(S.region) : void 0,
        datacenter: Le(S.datacenter) ? String(S.datacenter) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.broadcastId !== void 0 && (M.broadcastId = S.broadcastId), S.duration !== void 0 && (M.duration = Math.round(S.duration)), S.start !== void 0 && (M.start = S.start), S.stop !== void 0 && (M.stop = S.stop), S.phase !== void 0 && (M.phase = $e(S.phase)), S.region !== void 0 && (M.region = S.region !== void 0 ? qe(S.region) : void 0), S.datacenter !== void 0 && (M.datacenter = S.datacenter), M;
    },
    fromPartial(S) {
      var M, L, we, oe, Pe, bt, At, Dt, Lt;
      const Ft = Mt();
      return Ft.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", Ft.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", Ft.broadcastId = (we = S.broadcastId) !== null && we !== void 0 ? we : void 0, Ft.duration = (oe = S.duration) !== null && oe !== void 0 ? oe : void 0, Ft.start = (Pe = S.start) !== null && Pe !== void 0 ? Pe : void 0, Ft.stop = (bt = S.stop) !== null && bt !== void 0 ? bt : void 0, Ft.phase = (At = S.phase) !== null && At !== void 0 ? At : me.PROJECT_BROADCAST_PHASE_UNSPECIFIED, Ft.region = (Dt = S.region) !== null && Dt !== void 0 ? Dt : void 0, Ft.datacenter = (Lt = S.datacenter) !== null && Lt !== void 0 ? Lt : void 0, Ft;
    }
  };
  function Ot() {
    return { collectionId: "", sourceId: "", metadata: void 0, preview: void 0, address: void 0 };
  }
  a.Source = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.sourceId !== "" && M.uint32(18).string(S.sourceId), S.metadata !== void 0 && p.Value.encode(p.Value.wrap(S.metadata), M.uint32(26).fork()).ldelim(), S.preview !== void 0 && a.PreviewAddress.encode(S.preview, M.uint32(34).fork()).ldelim(), S.address !== void 0 && a.SourceAddress.encode(S.address, M.uint32(50).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Ot();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.sourceId = L.string();
            break;
          case 3:
            oe.metadata = p.Value.unwrap(p.Value.decode(L, L.uint32()));
            break;
          case 4:
            oe.preview = a.PreviewAddress.decode(L, L.uint32());
            break;
          case 6:
            oe.address = a.SourceAddress.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : "",
        metadata: Le(S == null ? void 0 : S.metadata) ? S.metadata : void 0,
        preview: Le(S.preview) ? a.PreviewAddress.fromJSON(S.preview) : void 0,
        address: Le(S.address) ? a.SourceAddress.fromJSON(S.address) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), S.metadata !== void 0 && (M.metadata = S.metadata), S.preview !== void 0 && (M.preview = S.preview ? a.PreviewAddress.toJSON(S.preview) : void 0), S.address !== void 0 && (M.address = S.address ? a.SourceAddress.toJSON(S.address) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = Ot();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.sourceId = (L = S.sourceId) !== null && L !== void 0 ? L : "", oe.metadata = (we = S.metadata) !== null && we !== void 0 ? we : void 0, oe.preview = S.preview !== void 0 && S.preview !== null ? a.PreviewAddress.fromPartial(S.preview) : void 0, oe.address = S.address !== void 0 && S.address !== null ? a.SourceAddress.fromPartial(S.address) : void 0, oe;
    }
  };
  function $t() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      metadata: void 0,
      enabled: void 0,
      address: void 0,
      timeout: void 0
    };
  }
  a.Destination = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.destinationId !== "" && M.uint32(26).string(S.destinationId), S.metadata !== void 0 && p.Value.encode(p.Value.wrap(S.metadata), M.uint32(34).fork()).ldelim(), S.enabled !== void 0 && M.uint32(40).bool(S.enabled), S.address !== void 0 && a.DestinationAddress.encode(S.address, M.uint32(50).fork()).ldelim(), S.timeout !== void 0 && M.uint32(56).uint32(S.timeout), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = $t();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.destinationId = L.string();
            break;
          case 4:
            oe.metadata = p.Value.unwrap(p.Value.decode(L, L.uint32()));
            break;
          case 5:
            oe.enabled = L.bool();
            break;
          case 6:
            oe.address = a.DestinationAddress.decode(L, L.uint32());
            break;
          case 7:
            oe.timeout = L.uint32();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        destinationId: Le(S.destinationId) ? String(S.destinationId) : "",
        metadata: Le(S == null ? void 0 : S.metadata) ? S.metadata : void 0,
        enabled: Le(S.enabled) ? !!S.enabled : void 0,
        address: Le(S.address) ? a.DestinationAddress.fromJSON(S.address) : void 0,
        timeout: Le(S.timeout) ? Number(S.timeout) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.destinationId !== void 0 && (M.destinationId = S.destinationId), S.metadata !== void 0 && (M.metadata = S.metadata), S.enabled !== void 0 && (M.enabled = S.enabled), S.address !== void 0 && (M.address = S.address ? a.DestinationAddress.toJSON(S.address) : void 0), S.timeout !== void 0 && (M.timeout = Math.round(S.timeout)), M;
    },
    fromPartial(S) {
      var M, L, we, oe, Pe, bt;
      const At = $t();
      return At.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", At.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", At.destinationId = (we = S.destinationId) !== null && we !== void 0 ? we : "", At.metadata = (oe = S.metadata) !== null && oe !== void 0 ? oe : void 0, At.enabled = (Pe = S.enabled) !== null && Pe !== void 0 ? Pe : void 0, At.address = S.address !== void 0 && S.address !== null ? a.DestinationAddress.fromPartial(S.address) : void 0, At.timeout = (bt = S.timeout) !== null && bt !== void 0 ? bt : void 0, At;
    }
  };
  function Bt() {
    return {
      collectionId: "",
      projectId: "",
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      sources: [],
      destinations: [],
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      triggers: [],
      location: void 0,
      guestCodes: []
    };
  }
  a.Project = {
    encode(S, M = c.default.Writer.create()) {
      S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.metadata !== void 0 && p.Value.encode(p.Value.wrap(S.metadata), M.uint32(26).fork()).ldelim(), S.rendering !== void 0 && a.Rendering.encode(S.rendering, M.uint32(34).fork()).ldelim(), S.encoding !== void 0 && a.Encoding.encode(S.encoding, M.uint32(42).fork()).ldelim();
      for (const L of S.sources)
        a.Source.encode(L, M.uint32(50).fork()).ldelim();
      for (const L of S.destinations)
        a.Destination.encode(L, M.uint32(58).fork()).ldelim();
      S.composition !== void 0 && a.Composition.encode(S.composition, M.uint32(66).fork()).ldelim(), S.maxDuration !== void 0 && M.uint32(72).uint32(S.maxDuration), S.webrtc !== void 0 && a.WebRtc.encode(S.webrtc, M.uint32(82).fork()).ldelim();
      for (const L of S.triggers)
        a.ProjectTrigger.encode(L, M.uint32(90).fork()).ldelim();
      S.location !== void 0 && a.LatLong.encode(S.location, M.uint32(98).fork()).ldelim();
      for (const L of S.guestCodes)
        a.GuestCode.encode(L, M.uint32(106).fork()).ldelim();
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Bt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.metadata = p.Value.unwrap(p.Value.decode(L, L.uint32()));
            break;
          case 4:
            oe.rendering = a.Rendering.decode(L, L.uint32());
            break;
          case 5:
            oe.encoding = a.Encoding.decode(L, L.uint32());
            break;
          case 6:
            oe.sources.push(a.Source.decode(L, L.uint32()));
            break;
          case 7:
            oe.destinations.push(a.Destination.decode(L, L.uint32()));
            break;
          case 8:
            oe.composition = a.Composition.decode(L, L.uint32());
            break;
          case 9:
            oe.maxDuration = L.uint32();
            break;
          case 10:
            oe.webrtc = a.WebRtc.decode(L, L.uint32());
            break;
          case 11:
            oe.triggers.push(a.ProjectTrigger.decode(L, L.uint32()));
            break;
          case 12:
            oe.location = a.LatLong.decode(L, L.uint32());
            break;
          case 13:
            oe.guestCodes.push(a.GuestCode.decode(L, L.uint32()));
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        metadata: Le(S == null ? void 0 : S.metadata) ? S.metadata : void 0,
        rendering: Le(S.rendering) ? a.Rendering.fromJSON(S.rendering) : void 0,
        encoding: Le(S.encoding) ? a.Encoding.fromJSON(S.encoding) : void 0,
        sources: Array.isArray(S == null ? void 0 : S.sources) ? S.sources.map((M) => a.Source.fromJSON(M)) : [],
        destinations: Array.isArray(S == null ? void 0 : S.destinations) ? S.destinations.map((M) => a.Destination.fromJSON(M)) : [],
        composition: Le(S.composition) ? a.Composition.fromJSON(S.composition) : void 0,
        maxDuration: Le(S.maxDuration) ? Number(S.maxDuration) : void 0,
        webrtc: Le(S.webrtc) ? a.WebRtc.fromJSON(S.webrtc) : void 0,
        triggers: Array.isArray(S == null ? void 0 : S.triggers) ? S.triggers.map((M) => a.ProjectTrigger.fromJSON(M)) : [],
        location: Le(S.location) ? a.LatLong.fromJSON(S.location) : void 0,
        guestCodes: Array.isArray(S == null ? void 0 : S.guestCodes) ? S.guestCodes.map((M) => a.GuestCode.fromJSON(M)) : []
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.metadata !== void 0 && (M.metadata = S.metadata), S.rendering !== void 0 && (M.rendering = S.rendering ? a.Rendering.toJSON(S.rendering) : void 0), S.encoding !== void 0 && (M.encoding = S.encoding ? a.Encoding.toJSON(S.encoding) : void 0), S.sources ? M.sources = S.sources.map((L) => L ? a.Source.toJSON(L) : void 0) : M.sources = [], S.destinations ? M.destinations = S.destinations.map((L) => L ? a.Destination.toJSON(L) : void 0) : M.destinations = [], S.composition !== void 0 && (M.composition = S.composition ? a.Composition.toJSON(S.composition) : void 0), S.maxDuration !== void 0 && (M.maxDuration = Math.round(S.maxDuration)), S.webrtc !== void 0 && (M.webrtc = S.webrtc ? a.WebRtc.toJSON(S.webrtc) : void 0), S.triggers ? M.triggers = S.triggers.map((L) => L ? a.ProjectTrigger.toJSON(L) : void 0) : M.triggers = [], S.location !== void 0 && (M.location = S.location ? a.LatLong.toJSON(S.location) : void 0), S.guestCodes ? M.guestCodes = S.guestCodes.map((L) => L ? a.GuestCode.toJSON(L) : void 0) : M.guestCodes = [], M;
    },
    fromPartial(S) {
      var M, L, we, oe, Pe, bt, At, Dt;
      const Lt = Bt();
      return Lt.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", Lt.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", Lt.metadata = (we = S.metadata) !== null && we !== void 0 ? we : void 0, Lt.rendering = S.rendering !== void 0 && S.rendering !== null ? a.Rendering.fromPartial(S.rendering) : void 0, Lt.encoding = S.encoding !== void 0 && S.encoding !== null ? a.Encoding.fromPartial(S.encoding) : void 0, Lt.sources = ((oe = S.sources) === null || oe === void 0 ? void 0 : oe.map((Ft) => a.Source.fromPartial(Ft))) || [], Lt.destinations = ((Pe = S.destinations) === null || Pe === void 0 ? void 0 : Pe.map((Ft) => a.Destination.fromPartial(Ft))) || [], Lt.composition = S.composition !== void 0 && S.composition !== null ? a.Composition.fromPartial(S.composition) : void 0, Lt.maxDuration = (bt = S.maxDuration) !== null && bt !== void 0 ? bt : void 0, Lt.webrtc = S.webrtc !== void 0 && S.webrtc !== null ? a.WebRtc.fromPartial(S.webrtc) : void 0, Lt.triggers = ((At = S.triggers) === null || At === void 0 ? void 0 : At.map((Ft) => a.ProjectTrigger.fromPartial(Ft))) || [], Lt.location = S.location !== void 0 && S.location !== null ? a.LatLong.fromPartial(S.location) : void 0, Lt.guestCodes = ((Dt = S.guestCodes) === null || Dt === void 0 ? void 0 : Dt.map((Ft) => a.GuestCode.fromPartial(Ft))) || [], Lt;
    }
  };
  function xt() {
    return { collectionId: "", metadata: void 0, projects: [], sources: [] };
  }
  a.Collection = {
    encode(S, M = c.default.Writer.create()) {
      S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.metadata !== void 0 && p.Value.encode(p.Value.wrap(S.metadata), M.uint32(18).fork()).ldelim();
      for (const L of S.projects)
        a.Project.encode(L, M.uint32(26).fork()).ldelim();
      for (const L of S.sources)
        a.Source.encode(L, M.uint32(34).fork()).ldelim();
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = xt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.metadata = p.Value.unwrap(p.Value.decode(L, L.uint32()));
            break;
          case 3:
            oe.projects.push(a.Project.decode(L, L.uint32()));
            break;
          case 4:
            oe.sources.push(a.Source.decode(L, L.uint32()));
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        metadata: Le(S == null ? void 0 : S.metadata) ? S.metadata : void 0,
        projects: Array.isArray(S == null ? void 0 : S.projects) ? S.projects.map((M) => a.Project.fromJSON(M)) : [],
        sources: Array.isArray(S == null ? void 0 : S.sources) ? S.sources.map((M) => a.Source.fromJSON(M)) : []
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.metadata !== void 0 && (M.metadata = S.metadata), S.projects ? M.projects = S.projects.map((L) => L ? a.Project.toJSON(L) : void 0) : M.projects = [], S.sources ? M.sources = S.sources.map((L) => L ? a.Source.toJSON(L) : void 0) : M.sources = [], M;
    },
    fromPartial(S) {
      var M, L, we, oe;
      const Pe = xt();
      return Pe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", Pe.metadata = (L = S.metadata) !== null && L !== void 0 ? L : void 0, Pe.projects = ((we = S.projects) === null || we === void 0 ? void 0 : we.map((bt) => a.Project.fromPartial(bt))) || [], Pe.sources = ((oe = S.sources) === null || oe === void 0 ? void 0 : oe.map((bt) => a.Source.fromPartial(bt))) || [], Pe;
    }
  };
  function Ut() {
    return { metadata: void 0 };
  }
  a.CreateCollectionRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.metadata !== void 0 && p.Value.encode(p.Value.wrap(S.metadata), M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Ut();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.metadata = p.Value.unwrap(p.Value.decode(L, L.uint32()));
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { metadata: Le(S == null ? void 0 : S.metadata) ? S.metadata : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.metadata !== void 0 && (M.metadata = S.metadata), M;
    },
    fromPartial(S) {
      var M;
      const L = Ut();
      return L.metadata = (M = S.metadata) !== null && M !== void 0 ? M : void 0, L;
    }
  };
  function Jt() {
    return { collection: void 0 };
  }
  a.CreateCollectionResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.collection !== void 0 && a.Collection.encode(S.collection, M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Jt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collection = a.Collection.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { collection: Le(S.collection) ? a.Collection.fromJSON(S.collection) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.collection !== void 0 && (M.collection = S.collection ? a.Collection.toJSON(S.collection) : void 0), M;
    },
    fromPartial(S) {
      const M = Jt();
      return M.collection = S.collection !== void 0 && S.collection !== null ? a.Collection.fromPartial(S.collection) : void 0, M;
    }
  };
  function Vt() {
    return { collectionId: "", populateProjects: void 0, populateSources: void 0 };
  }
  a.GetCollectionRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.populateProjects !== void 0 && M.uint32(16).bool(S.populateProjects), S.populateSources !== void 0 && M.uint32(24).bool(S.populateSources), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Vt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.populateProjects = L.bool();
            break;
          case 3:
            oe.populateSources = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        populateProjects: Le(S.populateProjects) ? !!S.populateProjects : void 0,
        populateSources: Le(S.populateSources) ? !!S.populateSources : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.populateProjects !== void 0 && (M.populateProjects = S.populateProjects), S.populateSources !== void 0 && (M.populateSources = S.populateSources), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = Vt();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.populateProjects = (L = S.populateProjects) !== null && L !== void 0 ? L : void 0, oe.populateSources = (we = S.populateSources) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function Yt() {
    return { collection: void 0 };
  }
  a.GetCollectionResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.collection !== void 0 && a.Collection.encode(S.collection, M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Yt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collection = a.Collection.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { collection: Le(S.collection) ? a.Collection.fromJSON(S.collection) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.collection !== void 0 && (M.collection = S.collection ? a.Collection.toJSON(S.collection) : void 0), M;
    },
    fromPartial(S) {
      const M = Yt();
      return M.collection = S.collection !== void 0 && S.collection !== null ? a.Collection.fromPartial(S.collection) : void 0, M;
    }
  };
  function jt() {
    return { collectionId: "", updateMask: void 0, metadata: void 0 };
  }
  a.UpdateCollectionRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(S.updateMask), M.uint32(18).fork()).ldelim(), S.metadata !== void 0 && p.Value.encode(p.Value.wrap(S.metadata), M.uint32(26).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = jt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(L, L.uint32()));
            break;
          case 3:
            oe.metadata = p.Value.unwrap(p.Value.decode(L, L.uint32()));
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        updateMask: Le(S.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(S.updateMask)) : void 0,
        metadata: Le(S == null ? void 0 : S.metadata) ? S.metadata : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.updateMask !== void 0 && (M.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(S.updateMask))), S.metadata !== void 0 && (M.metadata = S.metadata), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = jt();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.updateMask = (L = S.updateMask) !== null && L !== void 0 ? L : void 0, oe.metadata = (we = S.metadata) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function Zt() {
    return { collection: void 0 };
  }
  a.UpdateCollectionResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.collection !== void 0 && a.Collection.encode(S.collection, M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Zt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collection = a.Collection.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { collection: Le(S.collection) ? a.Collection.fromJSON(S.collection) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.collection !== void 0 && (M.collection = S.collection ? a.Collection.toJSON(S.collection) : void 0), M;
    },
    fromPartial(S) {
      const M = Zt();
      return M.collection = S.collection !== void 0 && S.collection !== null ? a.Collection.fromPartial(S.collection) : void 0, M;
    }
  };
  function Xt() {
    return { collectionId: "", force: void 0 };
  }
  a.DeleteCollectionRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.force !== void 0 && M.uint32(16).bool(S.force), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Xt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.force = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        force: Le(S.force) ? !!S.force : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.force !== void 0 && (M.force = S.force), M;
    },
    fromPartial(S) {
      var M, L;
      const we = Xt();
      return we.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", we.force = (L = S.force) !== null && L !== void 0 ? L : void 0, we;
    }
  };
  function Qt() {
    return { sourcesDeleted: 0, projectsDeleted: 0, projectIdsStopped: [] };
  }
  a.DeleteCollectionResponse = {
    encode(S, M = c.default.Writer.create()) {
      S.sourcesDeleted !== 0 && M.uint32(8).uint32(S.sourcesDeleted), S.projectsDeleted !== 0 && M.uint32(16).uint32(S.projectsDeleted);
      for (const L of S.projectIdsStopped)
        M.uint32(26).string(L);
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Qt();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.sourcesDeleted = L.uint32();
            break;
          case 2:
            oe.projectsDeleted = L.uint32();
            break;
          case 3:
            oe.projectIdsStopped.push(L.string());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        sourcesDeleted: Le(S.sourcesDeleted) ? Number(S.sourcesDeleted) : 0,
        projectsDeleted: Le(S.projectsDeleted) ? Number(S.projectsDeleted) : 0,
        projectIdsStopped: Array.isArray(S == null ? void 0 : S.projectIdsStopped) ? S.projectIdsStopped.map((M) => String(M)) : []
      };
    },
    toJSON(S) {
      const M = {};
      return S.sourcesDeleted !== void 0 && (M.sourcesDeleted = Math.round(S.sourcesDeleted)), S.projectsDeleted !== void 0 && (M.projectsDeleted = Math.round(S.projectsDeleted)), S.projectIdsStopped ? M.projectIdsStopped = S.projectIdsStopped.map((L) => L) : M.projectIdsStopped = [], M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = Qt();
      return oe.sourcesDeleted = (M = S.sourcesDeleted) !== null && M !== void 0 ? M : 0, oe.projectsDeleted = (L = S.projectsDeleted) !== null && L !== void 0 ? L : 0, oe.projectIdsStopped = ((we = S.projectIdsStopped) === null || we === void 0 ? void 0 : we.map((Pe) => Pe)) || [], oe;
    }
  };
  function er() {
    return {};
  }
  a.GetCollectionsRequest = {
    encode(S, M = c.default.Writer.create()) {
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = er();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return er();
    }
  };
  function tr() {
    return { collections: [] };
  }
  a.GetCollectionsResponse = {
    encode(S, M = c.default.Writer.create()) {
      for (const L of S.collections)
        a.Collection.encode(L, M.uint32(10).fork()).ldelim();
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = tr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collections.push(a.Collection.decode(L, L.uint32()));
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collections: Array.isArray(S == null ? void 0 : S.collections) ? S.collections.map((M) => a.Collection.fromJSON(M)) : []
      };
    },
    toJSON(S) {
      const M = {};
      return S.collections ? M.collections = S.collections.map((L) => L ? a.Collection.toJSON(L) : void 0) : M.collections = [], M;
    },
    fromPartial(S) {
      var M;
      const L = tr();
      return L.collections = ((M = S.collections) === null || M === void 0 ? void 0 : M.map((we) => a.Collection.fromPartial(we))) || [], L;
    }
  };
  function rr() {
    return {
      collectionId: "",
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      location: void 0
    };
  }
  a.CreateProjectRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.metadata !== void 0 && p.Value.encode(p.Value.wrap(S.metadata), M.uint32(18).fork()).ldelim(), S.rendering !== void 0 && a.Rendering.encode(S.rendering, M.uint32(26).fork()).ldelim(), S.encoding !== void 0 && a.Encoding.encode(S.encoding, M.uint32(34).fork()).ldelim(), S.composition !== void 0 && a.Composition.encode(S.composition, M.uint32(42).fork()).ldelim(), S.maxDuration !== void 0 && M.uint32(48).uint32(S.maxDuration), S.webrtc !== void 0 && a.WebRtc.encode(S.webrtc, M.uint32(58).fork()).ldelim(), S.location !== void 0 && a.LatLong.encode(S.location, M.uint32(74).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = rr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.metadata = p.Value.unwrap(p.Value.decode(L, L.uint32()));
            break;
          case 3:
            oe.rendering = a.Rendering.decode(L, L.uint32());
            break;
          case 4:
            oe.encoding = a.Encoding.decode(L, L.uint32());
            break;
          case 5:
            oe.composition = a.Composition.decode(L, L.uint32());
            break;
          case 6:
            oe.maxDuration = L.uint32();
            break;
          case 7:
            oe.webrtc = a.WebRtc.decode(L, L.uint32());
            break;
          case 9:
            oe.location = a.LatLong.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        metadata: Le(S == null ? void 0 : S.metadata) ? S.metadata : void 0,
        rendering: Le(S.rendering) ? a.Rendering.fromJSON(S.rendering) : void 0,
        encoding: Le(S.encoding) ? a.Encoding.fromJSON(S.encoding) : void 0,
        composition: Le(S.composition) ? a.Composition.fromJSON(S.composition) : void 0,
        maxDuration: Le(S.maxDuration) ? Number(S.maxDuration) : void 0,
        webrtc: Le(S.webrtc) ? a.WebRtc.fromJSON(S.webrtc) : void 0,
        location: Le(S.location) ? a.LatLong.fromJSON(S.location) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.metadata !== void 0 && (M.metadata = S.metadata), S.rendering !== void 0 && (M.rendering = S.rendering ? a.Rendering.toJSON(S.rendering) : void 0), S.encoding !== void 0 && (M.encoding = S.encoding ? a.Encoding.toJSON(S.encoding) : void 0), S.composition !== void 0 && (M.composition = S.composition ? a.Composition.toJSON(S.composition) : void 0), S.maxDuration !== void 0 && (M.maxDuration = Math.round(S.maxDuration)), S.webrtc !== void 0 && (M.webrtc = S.webrtc ? a.WebRtc.toJSON(S.webrtc) : void 0), S.location !== void 0 && (M.location = S.location ? a.LatLong.toJSON(S.location) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = rr();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.metadata = (L = S.metadata) !== null && L !== void 0 ? L : void 0, oe.rendering = S.rendering !== void 0 && S.rendering !== null ? a.Rendering.fromPartial(S.rendering) : void 0, oe.encoding = S.encoding !== void 0 && S.encoding !== null ? a.Encoding.fromPartial(S.encoding) : void 0, oe.composition = S.composition !== void 0 && S.composition !== null ? a.Composition.fromPartial(S.composition) : void 0, oe.maxDuration = (we = S.maxDuration) !== null && we !== void 0 ? we : void 0, oe.webrtc = S.webrtc !== void 0 && S.webrtc !== null ? a.WebRtc.fromPartial(S.webrtc) : void 0, oe.location = S.location !== void 0 && S.location !== null ? a.LatLong.fromPartial(S.location) : void 0, oe;
    }
  };
  function nr() {
    return { project: void 0 };
  }
  a.CreateProjectResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.project !== void 0 && a.Project.encode(S.project, M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = nr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.project = a.Project.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { project: Le(S.project) ? a.Project.fromJSON(S.project) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.project !== void 0 && (M.project = S.project ? a.Project.toJSON(S.project) : void 0), M;
    },
    fromPartial(S) {
      const M = nr();
      return M.project = S.project !== void 0 && S.project !== null ? a.Project.fromPartial(S.project) : void 0, M;
    }
  };
  function ir() {
    return {
      collectionId: "",
      projectId: "",
      updateMask: void 0,
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      location: void 0
    };
  }
  a.UpdateProjectRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(S.updateMask), M.uint32(26).fork()).ldelim(), S.metadata !== void 0 && p.Value.encode(p.Value.wrap(S.metadata), M.uint32(34).fork()).ldelim(), S.rendering !== void 0 && a.Rendering.encode(S.rendering, M.uint32(42).fork()).ldelim(), S.encoding !== void 0 && a.Encoding.encode(S.encoding, M.uint32(50).fork()).ldelim(), S.composition !== void 0 && a.Composition.encode(S.composition, M.uint32(58).fork()).ldelim(), S.maxDuration !== void 0 && M.uint32(64).uint32(S.maxDuration), S.webrtc !== void 0 && a.WebRtc.encode(S.webrtc, M.uint32(74).fork()).ldelim(), S.location !== void 0 && a.LatLong.encode(S.location, M.uint32(82).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = ir();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(L, L.uint32()));
            break;
          case 4:
            oe.metadata = p.Value.unwrap(p.Value.decode(L, L.uint32()));
            break;
          case 5:
            oe.rendering = a.Rendering.decode(L, L.uint32());
            break;
          case 6:
            oe.encoding = a.Encoding.decode(L, L.uint32());
            break;
          case 7:
            oe.composition = a.Composition.decode(L, L.uint32());
            break;
          case 8:
            oe.maxDuration = L.uint32();
            break;
          case 9:
            oe.webrtc = a.WebRtc.decode(L, L.uint32());
            break;
          case 10:
            oe.location = a.LatLong.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        updateMask: Le(S.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(S.updateMask)) : void 0,
        metadata: Le(S == null ? void 0 : S.metadata) ? S.metadata : void 0,
        rendering: Le(S.rendering) ? a.Rendering.fromJSON(S.rendering) : void 0,
        encoding: Le(S.encoding) ? a.Encoding.fromJSON(S.encoding) : void 0,
        composition: Le(S.composition) ? a.Composition.fromJSON(S.composition) : void 0,
        maxDuration: Le(S.maxDuration) ? Number(S.maxDuration) : void 0,
        webrtc: Le(S.webrtc) ? a.WebRtc.fromJSON(S.webrtc) : void 0,
        location: Le(S.location) ? a.LatLong.fromJSON(S.location) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.updateMask !== void 0 && (M.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(S.updateMask))), S.metadata !== void 0 && (M.metadata = S.metadata), S.rendering !== void 0 && (M.rendering = S.rendering ? a.Rendering.toJSON(S.rendering) : void 0), S.encoding !== void 0 && (M.encoding = S.encoding ? a.Encoding.toJSON(S.encoding) : void 0), S.composition !== void 0 && (M.composition = S.composition ? a.Composition.toJSON(S.composition) : void 0), S.maxDuration !== void 0 && (M.maxDuration = Math.round(S.maxDuration)), S.webrtc !== void 0 && (M.webrtc = S.webrtc ? a.WebRtc.toJSON(S.webrtc) : void 0), S.location !== void 0 && (M.location = S.location ? a.LatLong.toJSON(S.location) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we, oe, Pe;
      const bt = ir();
      return bt.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", bt.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", bt.updateMask = (we = S.updateMask) !== null && we !== void 0 ? we : void 0, bt.metadata = (oe = S.metadata) !== null && oe !== void 0 ? oe : void 0, bt.rendering = S.rendering !== void 0 && S.rendering !== null ? a.Rendering.fromPartial(S.rendering) : void 0, bt.encoding = S.encoding !== void 0 && S.encoding !== null ? a.Encoding.fromPartial(S.encoding) : void 0, bt.composition = S.composition !== void 0 && S.composition !== null ? a.Composition.fromPartial(S.composition) : void 0, bt.maxDuration = (Pe = S.maxDuration) !== null && Pe !== void 0 ? Pe : void 0, bt.webrtc = S.webrtc !== void 0 && S.webrtc !== null ? a.WebRtc.fromPartial(S.webrtc) : void 0, bt.location = S.location !== void 0 && S.location !== null ? a.LatLong.fromPartial(S.location) : void 0, bt;
    }
  };
  function ar() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.UpdateProjectResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.project !== void 0 && a.Project.encode(S.project, M.uint32(10).fork()).ldelim(), S.broadcastUpdated === !0 && M.uint32(16).bool(S.broadcastUpdated), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = ar();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.project = a.Project.decode(L, L.uint32());
            break;
          case 2:
            oe.broadcastUpdated = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        project: Le(S.project) ? a.Project.fromJSON(S.project) : void 0,
        broadcastUpdated: Le(S.broadcastUpdated) ? !!S.broadcastUpdated : !1
      };
    },
    toJSON(S) {
      const M = {};
      return S.project !== void 0 && (M.project = S.project ? a.Project.toJSON(S.project) : void 0), S.broadcastUpdated !== void 0 && (M.broadcastUpdated = S.broadcastUpdated), M;
    },
    fromPartial(S) {
      var M;
      const L = ar();
      return L.project = S.project !== void 0 && S.project !== null ? a.Project.fromPartial(S.project) : void 0, L.broadcastUpdated = (M = S.broadcastUpdated) !== null && M !== void 0 ? M : !1, L;
    }
  };
  function or() {
    return { collectionId: "", projectId: "", force: void 0 };
  }
  a.DeleteProjectRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.force !== void 0 && M.uint32(24).bool(S.force), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = or();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.force = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        force: Le(S.force) ? !!S.force : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.force !== void 0 && (M.force = S.force), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = or();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", oe.force = (we = S.force) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function ur() {
    return { broadcastStopped: !1, layoutsDeleted: 0 };
  }
  a.DeleteProjectResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.broadcastStopped === !0 && M.uint32(8).bool(S.broadcastStopped), S.layoutsDeleted !== 0 && M.uint32(16).uint32(S.layoutsDeleted), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = ur();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.broadcastStopped = L.bool();
            break;
          case 2:
            oe.layoutsDeleted = L.uint32();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        broadcastStopped: Le(S.broadcastStopped) ? !!S.broadcastStopped : !1,
        layoutsDeleted: Le(S.layoutsDeleted) ? Number(S.layoutsDeleted) : 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.broadcastStopped !== void 0 && (M.broadcastStopped = S.broadcastStopped), S.layoutsDeleted !== void 0 && (M.layoutsDeleted = Math.round(S.layoutsDeleted)), M;
    },
    fromPartial(S) {
      var M, L;
      const we = ur();
      return we.broadcastStopped = (M = S.broadcastStopped) !== null && M !== void 0 ? M : !1, we.layoutsDeleted = (L = S.layoutsDeleted) !== null && L !== void 0 ? L : 0, we;
    }
  };
  function dr() {
    return { collectionId: "", projectId: "", webrtcStart: void 0 };
  }
  a.StartProjectBroadcastRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.webrtcStart !== void 0 && M.uint32(24).bool(S.webrtcStart), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = dr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.webrtcStart = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        webrtcStart: Le(S.webrtcStart) ? !!S.webrtcStart : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.webrtcStart !== void 0 && (M.webrtcStart = S.webrtcStart), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = dr();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", oe.webrtcStart = (we = S.webrtcStart) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function cr() {
    return { broadcastId: "" };
  }
  a.StartProjectBroadcastResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.broadcastId !== "" && M.uint32(10).string(S.broadcastId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = cr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.broadcastId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { broadcastId: Le(S.broadcastId) ? String(S.broadcastId) : "" };
    },
    toJSON(S) {
      const M = {};
      return S.broadcastId !== void 0 && (M.broadcastId = S.broadcastId), M;
    },
    fromPartial(S) {
      var M;
      const L = cr();
      return L.broadcastId = (M = S.broadcastId) !== null && M !== void 0 ? M : "", L;
    }
  };
  function lr() {
    return { collectionId: "", projectId: "", webrtcStop: void 0 };
  }
  a.StopProjectBroadcastRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.webrtcStop !== void 0 && M.uint32(24).bool(S.webrtcStop), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = lr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.webrtcStop = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        webrtcStop: Le(S.webrtcStop) ? !!S.webrtcStop : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.webrtcStop !== void 0 && (M.webrtcStop = S.webrtcStop), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = lr();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", oe.webrtcStop = (we = S.webrtcStop) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function fr() {
    return {};
  }
  a.StopProjectBroadcastResponse = {
    encode(S, M = c.default.Writer.create()) {
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = fr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return fr();
    }
  };
  function pr() {
    return { collectionId: "", projectId: "", status: void 0 };
  }
  a.GetProjectRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.status !== void 0 && M.uint32(24).bool(S.status), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = pr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.status = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        status: Le(S.status) ? !!S.status : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.status !== void 0 && (M.status = S.status), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = pr();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", oe.status = (we = S.status) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function vr() {
    return { project: void 0, status: void 0 };
  }
  a.GetProjectResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.project !== void 0 && a.Project.encode(S.project, M.uint32(10).fork()).ldelim(), S.status !== void 0 && a.ProjectBroadcastStatus.encode(S.status, M.uint32(18).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = vr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.project = a.Project.decode(L, L.uint32());
            break;
          case 2:
            oe.status = a.ProjectBroadcastStatus.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        project: Le(S.project) ? a.Project.fromJSON(S.project) : void 0,
        status: Le(S.status) ? a.ProjectBroadcastStatus.fromJSON(S.status) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.project !== void 0 && (M.project = S.project ? a.Project.toJSON(S.project) : void 0), S.status !== void 0 && (M.status = S.status ? a.ProjectBroadcastStatus.toJSON(S.status) : void 0), M;
    },
    fromPartial(S) {
      const M = vr();
      return M.project = S.project !== void 0 && S.project !== null ? a.Project.fromPartial(S.project) : void 0, M.status = S.status !== void 0 && S.status !== null ? a.ProjectBroadcastStatus.fromPartial(S.status) : void 0, M;
    }
  };
  function yr() {
    return { collectionId: "", projectId: "", format: void 0 };
  }
  a.GetProjectBroadcastSnapshotRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.format !== void 0 && M.uint32(24).int32(F(S.format)), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = yr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.format = P(L.int32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        format: Le(S.format) ? P(S.format) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.format !== void 0 && (M.format = S.format !== void 0 ? $(S.format) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = yr();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", oe.format = (we = S.format) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function gr() {
    return { format: I.IMAGE_FORMAT_UNSPECIFIED, image: new Uint8Array() };
  }
  a.GetProjectBroadcastSnapshotResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.format !== I.IMAGE_FORMAT_UNSPECIFIED && M.uint32(8).int32(F(S.format)), S.image.length !== 0 && M.uint32(18).bytes(S.image), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = gr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.format = P(L.int32());
            break;
          case 2:
            oe.image = L.bytes();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        format: Le(S.format) ? P(S.format) : I.IMAGE_FORMAT_UNSPECIFIED,
        image: Le(S.image) ? jn(S.image) : new Uint8Array()
      };
    },
    toJSON(S) {
      const M = {};
      return S.format !== void 0 && (M.format = $(S.format)), S.image !== void 0 && (M.image = Zn(S.image !== void 0 ? S.image : new Uint8Array())), M;
    },
    fromPartial(S) {
      var M, L;
      const we = gr();
      return we.format = (M = S.format) !== null && M !== void 0 ? M : I.IMAGE_FORMAT_UNSPECIFIED, we.image = (L = S.image) !== null && L !== void 0 ? L : new Uint8Array(), we;
    }
  };
  function br() {
    return { collectionId: "", projectId: "" };
  }
  a.GetProjectBroadcastStatusRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = br();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), M;
    },
    fromPartial(S) {
      var M, L;
      const we = br();
      return we.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", we.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", we;
    }
  };
  function Sr() {
    return { status: void 0 };
  }
  a.GetProjectBroadcastStatusResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.status !== void 0 && a.ProjectBroadcastStatus.encode(S.status, M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Sr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.status = a.ProjectBroadcastStatus.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { status: Le(S.status) ? a.ProjectBroadcastStatus.fromJSON(S.status) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.status !== void 0 && (M.status = S.status ? a.ProjectBroadcastStatus.toJSON(S.status) : void 0), M;
    },
    fromPartial(S) {
      const M = Sr();
      return M.status = S.status !== void 0 && S.status !== null ? a.ProjectBroadcastStatus.fromPartial(S.status) : void 0, M;
    }
  };
  function _r() {
    return { collectionId: "", projectId: "" };
  }
  a.StartProjectWebRtcRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = _r();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), M;
    },
    fromPartial(S) {
      var M, L;
      const we = _r();
      return we.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", we.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", we;
    }
  };
  function Er() {
    return {};
  }
  a.StartProjectWebRtcResponse = {
    encode(S, M = c.default.Writer.create()) {
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Er();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return Er();
    }
  };
  function wr() {
    return { collectionId: "", projectId: "" };
  }
  a.StopProjectWebRtcRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = wr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), M;
    },
    fromPartial(S) {
      var M, L;
      const we = wr();
      return we.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", we.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", we;
    }
  };
  function Tr() {
    return {};
  }
  a.StopProjectWebRtcResponse = {
    encode(S, M = c.default.Writer.create()) {
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Tr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return Tr();
    }
  };
  function Ir() {
    return {
      collectionId: "",
      projectId: "",
      metadata: void 0,
      address: void 0,
      enabled: void 0,
      timeout: void 0
    };
  }
  a.CreateDestinationRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.metadata !== void 0 && p.Value.encode(p.Value.wrap(S.metadata), M.uint32(26).fork()).ldelim(), S.address !== void 0 && a.DestinationAddress.encode(S.address, M.uint32(42).fork()).ldelim(), S.enabled !== void 0 && M.uint32(48).bool(S.enabled), S.timeout !== void 0 && M.uint32(56).uint32(S.timeout), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Ir();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.metadata = p.Value.unwrap(p.Value.decode(L, L.uint32()));
            break;
          case 5:
            oe.address = a.DestinationAddress.decode(L, L.uint32());
            break;
          case 6:
            oe.enabled = L.bool();
            break;
          case 7:
            oe.timeout = L.uint32();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        metadata: Le(S == null ? void 0 : S.metadata) ? S.metadata : void 0,
        address: Le(S.address) ? a.DestinationAddress.fromJSON(S.address) : void 0,
        enabled: Le(S.enabled) ? !!S.enabled : void 0,
        timeout: Le(S.timeout) ? Number(S.timeout) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.metadata !== void 0 && (M.metadata = S.metadata), S.address !== void 0 && (M.address = S.address ? a.DestinationAddress.toJSON(S.address) : void 0), S.enabled !== void 0 && (M.enabled = S.enabled), S.timeout !== void 0 && (M.timeout = Math.round(S.timeout)), M;
    },
    fromPartial(S) {
      var M, L, we, oe, Pe;
      const bt = Ir();
      return bt.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", bt.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", bt.metadata = (we = S.metadata) !== null && we !== void 0 ? we : void 0, bt.address = S.address !== void 0 && S.address !== null ? a.DestinationAddress.fromPartial(S.address) : void 0, bt.enabled = (oe = S.enabled) !== null && oe !== void 0 ? oe : void 0, bt.timeout = (Pe = S.timeout) !== null && Pe !== void 0 ? Pe : void 0, bt;
    }
  };
  function kr() {
    return { destination: void 0 };
  }
  a.CreateDestinationResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.destination !== void 0 && a.Destination.encode(S.destination, M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = kr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.destination = a.Destination.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { destination: Le(S.destination) ? a.Destination.fromJSON(S.destination) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.destination !== void 0 && (M.destination = S.destination ? a.Destination.toJSON(S.destination) : void 0), M;
    },
    fromPartial(S) {
      const M = kr();
      return M.destination = S.destination !== void 0 && S.destination !== null ? a.Destination.fromPartial(S.destination) : void 0, M;
    }
  };
  function Rr() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  a.GetDestinationRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.destinationId !== "" && M.uint32(26).string(S.destinationId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Rr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.destinationId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        destinationId: Le(S.destinationId) ? String(S.destinationId) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.destinationId !== void 0 && (M.destinationId = S.destinationId), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = Rr();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", oe.destinationId = (we = S.destinationId) !== null && we !== void 0 ? we : "", oe;
    }
  };
  function Cr() {
    return { destination: void 0 };
  }
  a.GetDestinationResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.destination !== void 0 && a.Destination.encode(S.destination, M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Cr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.destination = a.Destination.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { destination: Le(S.destination) ? a.Destination.fromJSON(S.destination) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.destination !== void 0 && (M.destination = S.destination ? a.Destination.toJSON(S.destination) : void 0), M;
    },
    fromPartial(S) {
      const M = Cr();
      return M.destination = S.destination !== void 0 && S.destination !== null ? a.Destination.fromPartial(S.destination) : void 0, M;
    }
  };
  function Pr() {
    return { collectionId: "", projectId: "", destinationId: "", force: void 0 };
  }
  a.DeleteDestinationRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.destinationId !== "" && M.uint32(26).string(S.destinationId), S.force !== void 0 && M.uint32(32).bool(S.force), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Pr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.destinationId = L.string();
            break;
          case 4:
            oe.force = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        destinationId: Le(S.destinationId) ? String(S.destinationId) : "",
        force: Le(S.force) ? !!S.force : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.destinationId !== void 0 && (M.destinationId = S.destinationId), S.force !== void 0 && (M.force = S.force), M;
    },
    fromPartial(S) {
      var M, L, we, oe;
      const Pe = Pr();
      return Pe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", Pe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", Pe.destinationId = (we = S.destinationId) !== null && we !== void 0 ? we : "", Pe.force = (oe = S.force) !== null && oe !== void 0 ? oe : void 0, Pe;
    }
  };
  function Or() {
    return { broadcastUpdated: !1 };
  }
  a.DeleteDestinationResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.broadcastUpdated === !0 && M.uint32(8).bool(S.broadcastUpdated), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Or();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.broadcastUpdated = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { broadcastUpdated: Le(S.broadcastUpdated) ? !!S.broadcastUpdated : !1 };
    },
    toJSON(S) {
      const M = {};
      return S.broadcastUpdated !== void 0 && (M.broadcastUpdated = S.broadcastUpdated), M;
    },
    fromPartial(S) {
      var M;
      const L = Or();
      return L.broadcastUpdated = (M = S.broadcastUpdated) !== null && M !== void 0 ? M : !1, L;
    }
  };
  function Mr() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      updateMask: void 0,
      metadata: void 0,
      address: void 0,
      enabled: void 0,
      timeout: void 0
    };
  }
  a.UpdateDestinationRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.destinationId !== "" && M.uint32(26).string(S.destinationId), S.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(S.updateMask), M.uint32(34).fork()).ldelim(), S.metadata !== void 0 && p.Value.encode(p.Value.wrap(S.metadata), M.uint32(42).fork()).ldelim(), S.address !== void 0 && a.DestinationAddress.encode(S.address, M.uint32(50).fork()).ldelim(), S.enabled !== void 0 && M.uint32(56).bool(S.enabled), S.timeout !== void 0 && M.uint32(64).uint32(S.timeout), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Mr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.destinationId = L.string();
            break;
          case 4:
            oe.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(L, L.uint32()));
            break;
          case 5:
            oe.metadata = p.Value.unwrap(p.Value.decode(L, L.uint32()));
            break;
          case 6:
            oe.address = a.DestinationAddress.decode(L, L.uint32());
            break;
          case 7:
            oe.enabled = L.bool();
            break;
          case 8:
            oe.timeout = L.uint32();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        destinationId: Le(S.destinationId) ? String(S.destinationId) : "",
        updateMask: Le(S.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(S.updateMask)) : void 0,
        metadata: Le(S == null ? void 0 : S.metadata) ? S.metadata : void 0,
        address: Le(S.address) ? a.DestinationAddress.fromJSON(S.address) : void 0,
        enabled: Le(S.enabled) ? !!S.enabled : void 0,
        timeout: Le(S.timeout) ? Number(S.timeout) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.destinationId !== void 0 && (M.destinationId = S.destinationId), S.updateMask !== void 0 && (M.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(S.updateMask))), S.metadata !== void 0 && (M.metadata = S.metadata), S.address !== void 0 && (M.address = S.address ? a.DestinationAddress.toJSON(S.address) : void 0), S.enabled !== void 0 && (M.enabled = S.enabled), S.timeout !== void 0 && (M.timeout = Math.round(S.timeout)), M;
    },
    fromPartial(S) {
      var M, L, we, oe, Pe, bt, At;
      const Dt = Mr();
      return Dt.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", Dt.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", Dt.destinationId = (we = S.destinationId) !== null && we !== void 0 ? we : "", Dt.updateMask = (oe = S.updateMask) !== null && oe !== void 0 ? oe : void 0, Dt.metadata = (Pe = S.metadata) !== null && Pe !== void 0 ? Pe : void 0, Dt.address = S.address !== void 0 && S.address !== null ? a.DestinationAddress.fromPartial(S.address) : void 0, Dt.enabled = (bt = S.enabled) !== null && bt !== void 0 ? bt : void 0, Dt.timeout = (At = S.timeout) !== null && At !== void 0 ? At : void 0, Dt;
    }
  };
  function Nr() {
    return { destination: void 0, broadcastUpdated: !1 };
  }
  a.UpdateDestinationResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.destination !== void 0 && a.Destination.encode(S.destination, M.uint32(10).fork()).ldelim(), S.broadcastUpdated === !0 && M.uint32(16).bool(S.broadcastUpdated), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Nr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.destination = a.Destination.decode(L, L.uint32());
            break;
          case 2:
            oe.broadcastUpdated = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        destination: Le(S.destination) ? a.Destination.fromJSON(S.destination) : void 0,
        broadcastUpdated: Le(S.broadcastUpdated) ? !!S.broadcastUpdated : !1
      };
    },
    toJSON(S) {
      const M = {};
      return S.destination !== void 0 && (M.destination = S.destination ? a.Destination.toJSON(S.destination) : void 0), S.broadcastUpdated !== void 0 && (M.broadcastUpdated = S.broadcastUpdated), M;
    },
    fromPartial(S) {
      var M;
      const L = Nr();
      return L.destination = S.destination !== void 0 && S.destination !== null ? a.Destination.fromPartial(S.destination) : void 0, L.broadcastUpdated = (M = S.broadcastUpdated) !== null && M !== void 0 ? M : !1, L;
    }
  };
  function Ar() {
    return { collectionId: "", metadata: void 0, address: void 0, preview: void 0 };
  }
  a.CreateSourceRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.metadata !== void 0 && p.Value.encode(p.Value.wrap(S.metadata), M.uint32(18).fork()).ldelim(), S.address !== void 0 && a.SourceAddress.encode(S.address, M.uint32(26).fork()).ldelim(), S.preview !== void 0 && a.PreviewAddress.encode(S.preview, M.uint32(34).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Ar();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.metadata = p.Value.unwrap(p.Value.decode(L, L.uint32()));
            break;
          case 3:
            oe.address = a.SourceAddress.decode(L, L.uint32());
            break;
          case 4:
            oe.preview = a.PreviewAddress.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        metadata: Le(S == null ? void 0 : S.metadata) ? S.metadata : void 0,
        address: Le(S.address) ? a.SourceAddress.fromJSON(S.address) : void 0,
        preview: Le(S.preview) ? a.PreviewAddress.fromJSON(S.preview) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.metadata !== void 0 && (M.metadata = S.metadata), S.address !== void 0 && (M.address = S.address ? a.SourceAddress.toJSON(S.address) : void 0), S.preview !== void 0 && (M.preview = S.preview ? a.PreviewAddress.toJSON(S.preview) : void 0), M;
    },
    fromPartial(S) {
      var M, L;
      const we = Ar();
      return we.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", we.metadata = (L = S.metadata) !== null && L !== void 0 ? L : void 0, we.address = S.address !== void 0 && S.address !== null ? a.SourceAddress.fromPartial(S.address) : void 0, we.preview = S.preview !== void 0 && S.preview !== null ? a.PreviewAddress.fromPartial(S.preview) : void 0, we;
    }
  };
  function $r() {
    return { source: void 0 };
  }
  a.CreateSourceResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.source !== void 0 && a.Source.encode(S.source, M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = $r();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.source = a.Source.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { source: Le(S.source) ? a.Source.fromJSON(S.source) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.source !== void 0 && (M.source = S.source ? a.Source.toJSON(S.source) : void 0), M;
    },
    fromPartial(S) {
      const M = $r();
      return M.source = S.source !== void 0 && S.source !== null ? a.Source.fromPartial(S.source) : void 0, M;
    }
  };
  function Dr() {
    return { collectionId: "", sourceId: "", force: void 0 };
  }
  a.DeleteSourceRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.sourceId !== "" && M.uint32(18).string(S.sourceId), S.force !== void 0 && M.uint32(24).bool(S.force), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Dr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.sourceId = L.string();
            break;
          case 3:
            oe.force = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : "",
        force: Le(S.force) ? !!S.force : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), S.force !== void 0 && (M.force = S.force), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = Dr();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.sourceId = (L = S.sourceId) !== null && L !== void 0 ? L : "", oe.force = (we = S.force) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function Lr() {
    return { projectIdsUpdated: [] };
  }
  a.DeleteSourceResponse = {
    encode(S, M = c.default.Writer.create()) {
      for (const L of S.projectIdsUpdated)
        M.uint32(26).string(L);
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Lr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 3:
            oe.projectIdsUpdated.push(L.string());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        projectIdsUpdated: Array.isArray(S == null ? void 0 : S.projectIdsUpdated) ? S.projectIdsUpdated.map((M) => String(M)) : []
      };
    },
    toJSON(S) {
      const M = {};
      return S.projectIdsUpdated ? M.projectIdsUpdated = S.projectIdsUpdated.map((L) => L) : M.projectIdsUpdated = [], M;
    },
    fromPartial(S) {
      var M;
      const L = Lr();
      return L.projectIdsUpdated = ((M = S.projectIdsUpdated) === null || M === void 0 ? void 0 : M.map((we) => we)) || [], L;
    }
  };
  function Br() {
    return { collectionId: "", projectId: "", sourceId: "", trigger: void 0 };
  }
  a.AddSourceToProjectRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.sourceId !== "" && M.uint32(26).string(S.sourceId), S.trigger !== void 0 && a.SourceTrigger.encode(S.trigger, M.uint32(34).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Br();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.sourceId = L.string();
            break;
          case 4:
            oe.trigger = a.SourceTrigger.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : "",
        trigger: Le(S.trigger) ? a.SourceTrigger.fromJSON(S.trigger) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), S.trigger !== void 0 && (M.trigger = S.trigger ? a.SourceTrigger.toJSON(S.trigger) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = Br();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", oe.sourceId = (we = S.sourceId) !== null && we !== void 0 ? we : "", oe.trigger = S.trigger !== void 0 && S.trigger !== null ? a.SourceTrigger.fromPartial(S.trigger) : void 0, oe;
    }
  };
  function xr() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.AddSourceToProjectResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.project !== void 0 && a.Project.encode(S.project, M.uint32(10).fork()).ldelim(), S.broadcastUpdated === !0 && M.uint32(16).bool(S.broadcastUpdated), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = xr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.project = a.Project.decode(L, L.uint32());
            break;
          case 2:
            oe.broadcastUpdated = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        project: Le(S.project) ? a.Project.fromJSON(S.project) : void 0,
        broadcastUpdated: Le(S.broadcastUpdated) ? !!S.broadcastUpdated : !1
      };
    },
    toJSON(S) {
      const M = {};
      return S.project !== void 0 && (M.project = S.project ? a.Project.toJSON(S.project) : void 0), S.broadcastUpdated !== void 0 && (M.broadcastUpdated = S.broadcastUpdated), M;
    },
    fromPartial(S) {
      var M;
      const L = xr();
      return L.project = S.project !== void 0 && S.project !== null ? a.Project.fromPartial(S.project) : void 0, L.broadcastUpdated = (M = S.broadcastUpdated) !== null && M !== void 0 ? M : !1, L;
    }
  };
  function Ur() {
    return { collectionId: "", projectId: "", sourceId: "", updateMask: void 0, trigger: void 0 };
  }
  a.UpdateSourceInProjectRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.sourceId !== "" && M.uint32(26).string(S.sourceId), S.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(S.updateMask), M.uint32(34).fork()).ldelim(), S.trigger !== void 0 && a.SourceTrigger.encode(S.trigger, M.uint32(42).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Ur();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.sourceId = L.string();
            break;
          case 4:
            oe.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(L, L.uint32()));
            break;
          case 5:
            oe.trigger = a.SourceTrigger.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : "",
        updateMask: Le(S.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(S.updateMask)) : void 0,
        trigger: Le(S.trigger) ? a.SourceTrigger.fromJSON(S.trigger) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), S.updateMask !== void 0 && (M.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(S.updateMask))), S.trigger !== void 0 && (M.trigger = S.trigger ? a.SourceTrigger.toJSON(S.trigger) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we, oe;
      const Pe = Ur();
      return Pe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", Pe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", Pe.sourceId = (we = S.sourceId) !== null && we !== void 0 ? we : "", Pe.updateMask = (oe = S.updateMask) !== null && oe !== void 0 ? oe : void 0, Pe.trigger = S.trigger !== void 0 && S.trigger !== null ? a.SourceTrigger.fromPartial(S.trigger) : void 0, Pe;
    }
  };
  function Fr() {
    return { project: void 0 };
  }
  a.UpdateSourceInProjectResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.project !== void 0 && a.Project.encode(S.project, M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Fr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.project = a.Project.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { project: Le(S.project) ? a.Project.fromJSON(S.project) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.project !== void 0 && (M.project = S.project ? a.Project.toJSON(S.project) : void 0), M;
    },
    fromPartial(S) {
      const M = Fr();
      return M.project = S.project !== void 0 && S.project !== null ? a.Project.fromPartial(S.project) : void 0, M;
    }
  };
  function qr() {
    return { collectionId: "", sourceId: "" };
  }
  a.GetSourceRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.sourceId !== "" && M.uint32(26).string(S.sourceId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = qr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 3:
            oe.sourceId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), M;
    },
    fromPartial(S) {
      var M, L;
      const we = qr();
      return we.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", we.sourceId = (L = S.sourceId) !== null && L !== void 0 ? L : "", we;
    }
  };
  function Jr() {
    return { source: void 0 };
  }
  a.GetSourceResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.source !== void 0 && a.Source.encode(S.source, M.uint32(10).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Jr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.source = a.Source.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { source: Le(S.source) ? a.Source.fromJSON(S.source) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.source !== void 0 && (M.source = S.source ? a.Source.toJSON(S.source) : void 0), M;
    },
    fromPartial(S) {
      const M = Jr();
      return M.source = S.source !== void 0 && S.source !== null ? a.Source.fromPartial(S.source) : void 0, M;
    }
  };
  function Vr() {
    return { collectionId: "" };
  }
  a.GetSourcesRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Vr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { collectionId: Le(S.collectionId) ? String(S.collectionId) : "" };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), M;
    },
    fromPartial(S) {
      var M;
      const L = Vr();
      return L.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", L;
    }
  };
  function Gr() {
    return { sources: [] };
  }
  a.GetSourcesResponse = {
    encode(S, M = c.default.Writer.create()) {
      for (const L of S.sources)
        a.Source.encode(L, M.uint32(10).fork()).ldelim();
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Gr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.sources.push(a.Source.decode(L, L.uint32()));
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { sources: Array.isArray(S == null ? void 0 : S.sources) ? S.sources.map((M) => a.Source.fromJSON(M)) : [] };
    },
    toJSON(S) {
      const M = {};
      return S.sources ? M.sources = S.sources.map((L) => L ? a.Source.toJSON(L) : void 0) : M.sources = [], M;
    },
    fromPartial(S) {
      var M;
      const L = Gr();
      return L.sources = ((M = S.sources) === null || M === void 0 ? void 0 : M.map((we) => a.Source.fromPartial(we))) || [], L;
    }
  };
  function Wr() {
    return {
      collectionId: "",
      sourceId: "",
      updateMask: void 0,
      metadata: void 0,
      address: void 0,
      preview: void 0
    };
  }
  a.UpdateSourceRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.sourceId !== "" && M.uint32(26).string(S.sourceId), S.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(S.updateMask), M.uint32(34).fork()).ldelim(), S.metadata !== void 0 && p.Value.encode(p.Value.wrap(S.metadata), M.uint32(42).fork()).ldelim(), S.address !== void 0 && a.SourceAddress.encode(S.address, M.uint32(50).fork()).ldelim(), S.preview !== void 0 && a.PreviewAddress.encode(S.preview, M.uint32(58).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Wr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 3:
            oe.sourceId = L.string();
            break;
          case 4:
            oe.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(L, L.uint32()));
            break;
          case 5:
            oe.metadata = p.Value.unwrap(p.Value.decode(L, L.uint32()));
            break;
          case 6:
            oe.address = a.SourceAddress.decode(L, L.uint32());
            break;
          case 7:
            oe.preview = a.PreviewAddress.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : "",
        updateMask: Le(S.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(S.updateMask)) : void 0,
        metadata: Le(S == null ? void 0 : S.metadata) ? S.metadata : void 0,
        address: Le(S.address) ? a.SourceAddress.fromJSON(S.address) : void 0,
        preview: Le(S.preview) ? a.PreviewAddress.fromJSON(S.preview) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), S.updateMask !== void 0 && (M.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(S.updateMask))), S.metadata !== void 0 && (M.metadata = S.metadata), S.address !== void 0 && (M.address = S.address ? a.SourceAddress.toJSON(S.address) : void 0), S.preview !== void 0 && (M.preview = S.preview ? a.PreviewAddress.toJSON(S.preview) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we, oe;
      const Pe = Wr();
      return Pe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", Pe.sourceId = (L = S.sourceId) !== null && L !== void 0 ? L : "", Pe.updateMask = (we = S.updateMask) !== null && we !== void 0 ? we : void 0, Pe.metadata = (oe = S.metadata) !== null && oe !== void 0 ? oe : void 0, Pe.address = S.address !== void 0 && S.address !== null ? a.SourceAddress.fromPartial(S.address) : void 0, Pe.preview = S.preview !== void 0 && S.preview !== null ? a.PreviewAddress.fromPartial(S.preview) : void 0, Pe;
    }
  };
  function Hr() {
    return { source: void 0, broadcastUpdated: !1 };
  }
  a.UpdateSourceResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.source !== void 0 && a.Source.encode(S.source, M.uint32(10).fork()).ldelim(), S.broadcastUpdated === !0 && M.uint32(16).bool(S.broadcastUpdated), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Hr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.source = a.Source.decode(L, L.uint32());
            break;
          case 2:
            oe.broadcastUpdated = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        source: Le(S.source) ? a.Source.fromJSON(S.source) : void 0,
        broadcastUpdated: Le(S.broadcastUpdated) ? !!S.broadcastUpdated : !1
      };
    },
    toJSON(S) {
      const M = {};
      return S.source !== void 0 && (M.source = S.source ? a.Source.toJSON(S.source) : void 0), S.broadcastUpdated !== void 0 && (M.broadcastUpdated = S.broadcastUpdated), M;
    },
    fromPartial(S) {
      var M;
      const L = Hr();
      return L.source = S.source !== void 0 && S.source !== null ? a.Source.fromPartial(S.source) : void 0, L.broadcastUpdated = (M = S.broadcastUpdated) !== null && M !== void 0 ? M : !1, L;
    }
  };
  function Kr() {
    return { collectionId: "", projectId: "", sourceId: "", force: void 0 };
  }
  a.RemoveSourceFromProjectRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.sourceId !== "" && M.uint32(26).string(S.sourceId), S.force !== void 0 && M.uint32(32).bool(S.force), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Kr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.sourceId = L.string();
            break;
          case 4:
            oe.force = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : "",
        force: Le(S.force) ? !!S.force : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), S.force !== void 0 && (M.force = S.force), M;
    },
    fromPartial(S) {
      var M, L, we, oe;
      const Pe = Kr();
      return Pe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", Pe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", Pe.sourceId = (we = S.sourceId) !== null && we !== void 0 ? we : "", Pe.force = (oe = S.force) !== null && oe !== void 0 ? oe : void 0, Pe;
    }
  };
  function Yr() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.RemoveSourceFromProjectResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.project !== void 0 && a.Project.encode(S.project, M.uint32(10).fork()).ldelim(), S.broadcastUpdated === !0 && M.uint32(16).bool(S.broadcastUpdated), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Yr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.project = a.Project.decode(L, L.uint32());
            break;
          case 2:
            oe.broadcastUpdated = L.bool();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        project: Le(S.project) ? a.Project.fromJSON(S.project) : void 0,
        broadcastUpdated: Le(S.broadcastUpdated) ? !!S.broadcastUpdated : !1
      };
    },
    toJSON(S) {
      const M = {};
      return S.project !== void 0 && (M.project = S.project ? a.Project.toJSON(S.project) : void 0), S.broadcastUpdated !== void 0 && (M.broadcastUpdated = S.broadcastUpdated), M;
    },
    fromPartial(S) {
      var M;
      const L = Yr();
      return L.project = S.project !== void 0 && S.project !== null ? a.Project.fromPartial(S.project) : void 0, L.broadcastUpdated = (M = S.broadcastUpdated) !== null && M !== void 0 ? M : !1, L;
    }
  };
  function jr() {
    return { collectionId: "", sourceId: "", accessToken: void 0 };
  }
  a.GetSourcePlaylistRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.sourceId !== "" && M.uint32(26).string(S.sourceId), S.accessToken !== void 0 && M.uint32(34).string(S.accessToken), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = jr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 3:
            oe.sourceId = L.string();
            break;
          case 4:
            oe.accessToken = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : "",
        accessToken: Le(S.accessToken) ? String(S.accessToken) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), S.accessToken !== void 0 && (M.accessToken = S.accessToken), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = jr();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.sourceId = (L = S.sourceId) !== null && L !== void 0 ? L : "", oe.accessToken = (we = S.accessToken) !== null && we !== void 0 ? we : void 0, oe;
    }
  };
  function Zr() {
    return { manifest: "" };
  }
  a.GetSourcePlaylistResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.manifest !== "" && M.uint32(10).string(S.manifest), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Zr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.manifest = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { manifest: Le(S.manifest) ? String(S.manifest) : "" };
    },
    toJSON(S) {
      const M = {};
      return S.manifest !== void 0 && (M.manifest = S.manifest), M;
    },
    fromPartial(S) {
      var M;
      const L = Zr();
      return L.manifest = (M = S.manifest) !== null && M !== void 0 ? M : "", L;
    }
  };
  function Xr() {
    return { serviceUserId: "", displayName: void 0, role: void 0, maxDuration: void 0 };
  }
  a.CreateAccessTokenRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.serviceUserId !== "" && M.uint32(10).string(S.serviceUserId), S.displayName !== void 0 && M.uint32(34).string(S.displayName), S.role !== void 0 && M.uint32(16).int32(Ge(S.role)), S.maxDuration !== void 0 && M.uint32(24).uint32(S.maxDuration), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Xr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.serviceUserId = L.string();
            break;
          case 4:
            oe.displayName = L.string();
            break;
          case 2:
            oe.role = yt(L.int32());
            break;
          case 3:
            oe.maxDuration = L.uint32();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        serviceUserId: Le(S.serviceUserId) ? String(S.serviceUserId) : "",
        displayName: Le(S.displayName) ? String(S.displayName) : void 0,
        role: Le(S.role) ? yt(S.role) : void 0,
        maxDuration: Le(S.maxDuration) ? Number(S.maxDuration) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.serviceUserId !== void 0 && (M.serviceUserId = S.serviceUserId), S.displayName !== void 0 && (M.displayName = S.displayName), S.role !== void 0 && (M.role = S.role !== void 0 ? Xe(S.role) : void 0), S.maxDuration !== void 0 && (M.maxDuration = Math.round(S.maxDuration)), M;
    },
    fromPartial(S) {
      var M, L, we, oe;
      const Pe = Xr();
      return Pe.serviceUserId = (M = S.serviceUserId) !== null && M !== void 0 ? M : "", Pe.displayName = (L = S.displayName) !== null && L !== void 0 ? L : void 0, Pe.role = (we = S.role) !== null && we !== void 0 ? we : void 0, Pe.maxDuration = (oe = S.maxDuration) !== null && oe !== void 0 ? oe : void 0, Pe;
    }
  };
  function Qr() {
    return { accessToken: "" };
  }
  a.CreateAccessTokenResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.accessToken !== "" && M.uint32(10).string(S.accessToken), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Qr();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.accessToken = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { accessToken: Le(S.accessToken) ? String(S.accessToken) : "" };
    },
    toJSON(S) {
      const M = {};
      return S.accessToken !== void 0 && (M.accessToken = S.accessToken), M;
    },
    fromPartial(S) {
      var M;
      const L = Qr();
      return L.accessToken = (M = S.accessToken) !== null && M !== void 0 ? M : "", L;
    }
  };
  function en() {
    return { displayName: "", serviceUserId: void 0 };
  }
  a.GuestAccessTokenDirect = {
    encode(S, M = c.default.Writer.create()) {
      return S.displayName !== "" && M.uint32(10).string(S.displayName), S.serviceUserId !== void 0 && M.uint32(18).string(S.serviceUserId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = en();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.displayName = L.string();
            break;
          case 2:
            oe.serviceUserId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        displayName: Le(S.displayName) ? String(S.displayName) : "",
        serviceUserId: Le(S.serviceUserId) ? String(S.serviceUserId) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.displayName !== void 0 && (M.displayName = S.displayName), S.serviceUserId !== void 0 && (M.serviceUserId = S.serviceUserId), M;
    },
    fromPartial(S) {
      var M, L;
      const we = en();
      return we.displayName = (M = S.displayName) !== null && M !== void 0 ? M : "", we.serviceUserId = (L = S.serviceUserId) !== null && L !== void 0 ? L : void 0, we;
    }
  };
  function tn() {
    return { maxDuration: void 0 };
  }
  a.GuestAccessTokenExchange = {
    encode(S, M = c.default.Writer.create()) {
      return S.maxDuration !== void 0 && M.uint32(8).uint32(S.maxDuration), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = tn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.maxDuration = L.uint32();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { maxDuration: Le(S.maxDuration) ? Number(S.maxDuration) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.maxDuration !== void 0 && (M.maxDuration = Math.round(S.maxDuration)), M;
    },
    fromPartial(S) {
      var M;
      const L = tn();
      return L.maxDuration = (M = S.maxDuration) !== null && M !== void 0 ? M : void 0, L;
    }
  };
  function rn() {
    return { direct: void 0, exchange: void 0 };
  }
  a.GuestAccessToken = {
    encode(S, M = c.default.Writer.create()) {
      return S.direct !== void 0 && a.GuestAccessTokenDirect.encode(S.direct, M.uint32(10).fork()).ldelim(), S.exchange !== void 0 && a.GuestAccessTokenExchange.encode(S.exchange, M.uint32(18).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = rn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.direct = a.GuestAccessTokenDirect.decode(L, L.uint32());
            break;
          case 2:
            oe.exchange = a.GuestAccessTokenExchange.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        direct: Le(S.direct) ? a.GuestAccessTokenDirect.fromJSON(S.direct) : void 0,
        exchange: Le(S.exchange) ? a.GuestAccessTokenExchange.fromJSON(S.exchange) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.direct !== void 0 && (M.direct = S.direct ? a.GuestAccessTokenDirect.toJSON(S.direct) : void 0), S.exchange !== void 0 && (M.exchange = S.exchange ? a.GuestAccessTokenExchange.toJSON(S.exchange) : void 0), M;
    },
    fromPartial(S) {
      const M = rn();
      return M.direct = S.direct !== void 0 && S.direct !== null ? a.GuestAccessTokenDirect.fromPartial(S.direct) : void 0, M.exchange = S.exchange !== void 0 && S.exchange !== null ? a.GuestAccessTokenExchange.fromPartial(S.exchange) : void 0, M;
    }
  };
  function nn() {
    return {
      collectionId: "",
      projectId: "",
      maxDuration: void 0,
      role: Fe.ROLE_UNSPECIFIED,
      token: void 0,
      url: void 0
    };
  }
  a.CreateGuestAccessTokenRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.maxDuration !== void 0 && M.uint32(24).uint32(S.maxDuration), S.role !== Fe.ROLE_UNSPECIFIED && M.uint32(32).int32(Ge(S.role)), S.token !== void 0 && a.GuestAccessToken.encode(S.token, M.uint32(42).fork()).ldelim(), S.url !== void 0 && M.uint32(50).string(S.url), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = nn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.maxDuration = L.uint32();
            break;
          case 4:
            oe.role = yt(L.int32());
            break;
          case 5:
            oe.token = a.GuestAccessToken.decode(L, L.uint32());
            break;
          case 6:
            oe.url = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        maxDuration: Le(S.maxDuration) ? Number(S.maxDuration) : void 0,
        role: Le(S.role) ? yt(S.role) : Fe.ROLE_UNSPECIFIED,
        token: Le(S.token) ? a.GuestAccessToken.fromJSON(S.token) : void 0,
        url: Le(S.url) ? String(S.url) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.maxDuration !== void 0 && (M.maxDuration = Math.round(S.maxDuration)), S.role !== void 0 && (M.role = Xe(S.role)), S.token !== void 0 && (M.token = S.token ? a.GuestAccessToken.toJSON(S.token) : void 0), S.url !== void 0 && (M.url = S.url), M;
    },
    fromPartial(S) {
      var M, L, we, oe, Pe;
      const bt = nn();
      return bt.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", bt.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", bt.maxDuration = (we = S.maxDuration) !== null && we !== void 0 ? we : void 0, bt.role = (oe = S.role) !== null && oe !== void 0 ? oe : Fe.ROLE_UNSPECIFIED, bt.token = S.token !== void 0 && S.token !== null ? a.GuestAccessToken.fromPartial(S.token) : void 0, bt.url = (Pe = S.url) !== null && Pe !== void 0 ? Pe : void 0, bt;
    }
  };
  function an() {
    return { accessToken: "", url: void 0 };
  }
  a.CreateGuestAccessTokenResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.accessToken !== "" && M.uint32(10).string(S.accessToken), S.url !== void 0 && M.uint32(18).string(S.url), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = an();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.accessToken = L.string();
            break;
          case 2:
            oe.url = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        accessToken: Le(S.accessToken) ? String(S.accessToken) : "",
        url: Le(S.url) ? String(S.url) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.accessToken !== void 0 && (M.accessToken = S.accessToken), S.url !== void 0 && (M.url = S.url), M;
    },
    fromPartial(S) {
      var M, L;
      const we = an();
      return we.accessToken = (M = S.accessToken) !== null && M !== void 0 ? M : "", we.url = (L = S.url) !== null && L !== void 0 ? L : void 0, we;
    }
  };
  function sn() {
    return { collectionId: "", projectId: "", displayName: "" };
  }
  a.CreateWebRtcAccessTokenRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.displayName !== "" && M.uint32(26).string(S.displayName), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = sn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.displayName = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        displayName: Le(S.displayName) ? String(S.displayName) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.displayName !== void 0 && (M.displayName = S.displayName), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = sn();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", oe.displayName = (we = S.displayName) !== null && we !== void 0 ? we : "", oe;
    }
  };
  function un() {
    return { webrtcAccess: void 0 };
  }
  a.CreateWebRtcAccessTokenResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.webrtcAccess !== void 0 && a.WebRtcAccess.encode(S.webrtcAccess, M.uint32(18).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = un();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 2:
            oe.webrtcAccess = a.WebRtcAccess.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { webrtcAccess: Le(S.webrtcAccess) ? a.WebRtcAccess.fromJSON(S.webrtcAccess) : void 0 };
    },
    toJSON(S) {
      const M = {};
      return S.webrtcAccess !== void 0 && (M.webrtcAccess = S.webrtcAccess ? a.WebRtcAccess.toJSON(S.webrtcAccess) : void 0), M;
    },
    fromPartial(S) {
      const M = un();
      return M.webrtcAccess = S.webrtcAccess !== void 0 && S.webrtcAccess !== null ? a.WebRtcAccess.fromPartial(S.webrtcAccess) : void 0, M;
    }
  };
  function dn() {
    return {};
  }
  a.RefreshAccessTokenRequest = {
    encode(S, M = c.default.Writer.create()) {
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = dn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return dn();
    }
  };
  function cn() {
    return {};
  }
  a.RefreshAccessTokenResponse = {
    encode(S, M = c.default.Writer.create()) {
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = cn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return cn();
    }
  };
  function ln() {
    return { collectionId: "", projectId: "", code: "", url: "", autoDelete: void 0 };
  }
  a.GuestCode = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.code !== "" && M.uint32(26).string(S.code), S.url !== "" && M.uint32(34).string(S.url), S.autoDelete !== void 0 && _.Timestamp.encode(Ht(S.autoDelete), M.uint32(42).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = ln();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.code = L.string();
            break;
          case 4:
            oe.url = L.string();
            break;
          case 5:
            oe.autoDelete = zt(_.Timestamp.decode(L, L.uint32()));
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        code: Le(S.code) ? String(S.code) : "",
        url: Le(S.url) ? String(S.url) : "",
        autoDelete: Le(S.autoDelete) ? String(S.autoDelete) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.code !== void 0 && (M.code = S.code), S.url !== void 0 && (M.url = S.url), S.autoDelete !== void 0 && (M.autoDelete = S.autoDelete), M;
    },
    fromPartial(S) {
      var M, L, we, oe, Pe;
      const bt = ln();
      return bt.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", bt.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", bt.code = (we = S.code) !== null && we !== void 0 ? we : "", bt.url = (oe = S.url) !== null && oe !== void 0 ? oe : "", bt.autoDelete = (Pe = S.autoDelete) !== null && Pe !== void 0 ? Pe : void 0, bt;
    }
  };
  function fn() {
    return { serviceId: "", code: "" };
  }
  a.GuestCodeRedirectRequest = {
    encode(S, M = c.default.Writer.create()) {
      return S.serviceId !== "" && M.uint32(10).string(S.serviceId), S.code !== "" && M.uint32(18).string(S.code), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = fn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.serviceId = L.string();
            break;
          case 2:
            oe.code = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        serviceId: Le(S.serviceId) ? String(S.serviceId) : "",
        code: Le(S.code) ? String(S.code) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.serviceId !== void 0 && (M.serviceId = S.serviceId), S.code !== void 0 && (M.code = S.code), M;
    },
    fromPartial(S) {
      var M, L;
      const we = fn();
      return we.serviceId = (M = S.serviceId) !== null && M !== void 0 ? M : "", we.code = (L = S.code) !== null && L !== void 0 ? L : "", we;
    }
  };
  function hn() {
    return {};
  }
  a.GuestCodeRedirectResponse = {
    encode(S, M = c.default.Writer.create()) {
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = hn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return hn();
    }
  };
  function pn() {
    return { alg: "", kty: "", use: "", kid: "", e: "", n: "" };
  }
  a.JsonWebKey = {
    encode(S, M = c.default.Writer.create()) {
      return S.alg !== "" && M.uint32(10).string(S.alg), S.kty !== "" && M.uint32(18).string(S.kty), S.use !== "" && M.uint32(26).string(S.use), S.kid !== "" && M.uint32(34).string(S.kid), S.e !== "" && M.uint32(42).string(S.e), S.n !== "" && M.uint32(50).string(S.n), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = pn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.alg = L.string();
            break;
          case 2:
            oe.kty = L.string();
            break;
          case 3:
            oe.use = L.string();
            break;
          case 4:
            oe.kid = L.string();
            break;
          case 5:
            oe.e = L.string();
            break;
          case 6:
            oe.n = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        alg: Le(S.alg) ? String(S.alg) : "",
        kty: Le(S.kty) ? String(S.kty) : "",
        use: Le(S.use) ? String(S.use) : "",
        kid: Le(S.kid) ? String(S.kid) : "",
        e: Le(S.e) ? String(S.e) : "",
        n: Le(S.n) ? String(S.n) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.alg !== void 0 && (M.alg = S.alg), S.kty !== void 0 && (M.kty = S.kty), S.use !== void 0 && (M.use = S.use), S.kid !== void 0 && (M.kid = S.kid), S.e !== void 0 && (M.e = S.e), S.n !== void 0 && (M.n = S.n), M;
    },
    fromPartial(S) {
      var M, L, we, oe, Pe, bt;
      const At = pn();
      return At.alg = (M = S.alg) !== null && M !== void 0 ? M : "", At.kty = (L = S.kty) !== null && L !== void 0 ? L : "", At.use = (we = S.use) !== null && we !== void 0 ? we : "", At.kid = (oe = S.kid) !== null && oe !== void 0 ? oe : "", At.e = (Pe = S.e) !== null && Pe !== void 0 ? Pe : "", At.n = (bt = S.n) !== null && bt !== void 0 ? bt : "", At;
    }
  };
  function mn() {
    return {};
  }
  a.GetJsonWebKeySetRequest = {
    encode(S, M = c.default.Writer.create()) {
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = mn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return mn();
    }
  };
  function vn() {
    return { keys: [] };
  }
  a.GetJsonWebKeySetResponse = {
    encode(S, M = c.default.Writer.create()) {
      for (const L of S.keys)
        a.JsonWebKey.encode(L, M.uint32(10).fork()).ldelim();
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = vn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.keys.push(a.JsonWebKey.decode(L, L.uint32()));
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { keys: Array.isArray(S == null ? void 0 : S.keys) ? S.keys.map((M) => a.JsonWebKey.fromJSON(M)) : [] };
    },
    toJSON(S) {
      const M = {};
      return S.keys ? M.keys = S.keys.map((L) => L ? a.JsonWebKey.toJSON(L) : void 0) : M.keys = [], M;
    },
    fromPartial(S) {
      var M;
      const L = vn();
      return L.keys = ((M = S.keys) === null || M === void 0 ? void 0 : M.map((we) => a.JsonWebKey.fromPartial(we))) || [], L;
    }
  };
  function yn() {
    return {};
  }
  a.GetTestTokenRequest = {
    encode(S, M = c.default.Writer.create()) {
      return M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = yn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {};
    },
    toJSON(S) {
      return {};
    },
    fromPartial(S) {
      return yn();
    }
  };
  function gn() {
    return { accessToken: "" };
  }
  a.GetTestTokenResponse = {
    encode(S, M = c.default.Writer.create()) {
      return S.accessToken !== "" && M.uint32(10).string(S.accessToken), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = gn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.accessToken = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { accessToken: Le(S.accessToken) ? String(S.accessToken) : "" };
    },
    toJSON(S) {
      const M = {};
      return S.accessToken !== void 0 && (M.accessToken = S.accessToken), M;
    },
    fromPartial(S) {
      var M;
      const L = gn();
      return L.accessToken = (M = S.accessToken) !== null && M !== void 0 ? M : "", L;
    }
  };
  function Sn() {
    return { collectionId: "", projectId: "", destinationId: "", destination: void 0 };
  }
  a.DestinationCreateEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.destinationId !== "" && M.uint32(26).string(S.destinationId), S.destination !== void 0 && a.Destination.encode(S.destination, M.uint32(34).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Sn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.destinationId = L.string();
            break;
          case 4:
            oe.destination = a.Destination.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        destinationId: Le(S.destinationId) ? String(S.destinationId) : "",
        destination: Le(S.destination) ? a.Destination.fromJSON(S.destination) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.destinationId !== void 0 && (M.destinationId = S.destinationId), S.destination !== void 0 && (M.destination = S.destination ? a.Destination.toJSON(S.destination) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = Sn();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", oe.destinationId = (we = S.destinationId) !== null && we !== void 0 ? we : "", oe.destination = S.destination !== void 0 && S.destination !== null ? a.Destination.fromPartial(S.destination) : void 0, oe;
    }
  };
  function _n() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  a.DestinationDeleteEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.destinationId !== "" && M.uint32(26).string(S.destinationId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = _n();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.destinationId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        destinationId: Le(S.destinationId) ? String(S.destinationId) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.destinationId !== void 0 && (M.destinationId = S.destinationId), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = _n();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", oe.destinationId = (we = S.destinationId) !== null && we !== void 0 ? we : "", oe;
    }
  };
  function En() {
    return { collectionId: "", projectId: "", destinationId: "", updateMask: [], destination: void 0 };
  }
  a.DestinationUpdateEvent = {
    encode(S, M = c.default.Writer.create()) {
      S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.destinationId !== "" && M.uint32(26).string(S.destinationId);
      for (const L of S.updateMask)
        M.uint32(34).string(L);
      return S.destination !== void 0 && a.Destination.encode(S.destination, M.uint32(42).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = En();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.destinationId = L.string();
            break;
          case 4:
            oe.updateMask.push(L.string());
            break;
          case 5:
            oe.destination = a.Destination.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        destinationId: Le(S.destinationId) ? String(S.destinationId) : "",
        updateMask: Array.isArray(S == null ? void 0 : S.updateMask) ? S.updateMask.map((M) => String(M)) : [],
        destination: Le(S.destination) ? a.Destination.fromJSON(S.destination) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.destinationId !== void 0 && (M.destinationId = S.destinationId), S.updateMask ? M.updateMask = S.updateMask.map((L) => L) : M.updateMask = [], S.destination !== void 0 && (M.destination = S.destination ? a.Destination.toJSON(S.destination) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we, oe;
      const Pe = En();
      return Pe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", Pe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", Pe.destinationId = (we = S.destinationId) !== null && we !== void 0 ? we : "", Pe.updateMask = ((oe = S.updateMask) === null || oe === void 0 ? void 0 : oe.map((bt) => bt)) || [], Pe.destination = S.destination !== void 0 && S.destination !== null ? a.Destination.fromPartial(S.destination) : void 0, Pe;
    }
  };
  function wn() {
    return { collectionId: "", projectId: "", destinationId: "", connect: void 0 };
  }
  a.DestinationStateEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.destinationId !== "" && M.uint32(26).string(S.destinationId), S.connect !== void 0 && M.uint32(32).int32(ue(S.connect)), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = wn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.destinationId = L.string();
            break;
          case 4:
            oe.connect = J(L.int32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        destinationId: Le(S.destinationId) ? String(S.destinationId) : "",
        connect: Le(S.connect) ? J(S.connect) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.destinationId !== void 0 && (M.destinationId = S.destinationId), S.connect !== void 0 && (M.connect = S.connect !== void 0 ? Ee(S.connect) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we, oe;
      const Pe = wn();
      return Pe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", Pe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", Pe.destinationId = (we = S.destinationId) !== null && we !== void 0 ? we : "", Pe.connect = (oe = S.connect) !== null && oe !== void 0 ? oe : void 0, Pe;
    }
  };
  function Tn() {
    return { collectionId: "", projectId: "", project: void 0 };
  }
  a.ProjectCreateEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.project !== void 0 && a.Project.encode(S.project, M.uint32(26).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Tn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.project = a.Project.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        project: Le(S.project) ? a.Project.fromJSON(S.project) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.project !== void 0 && (M.project = S.project ? a.Project.toJSON(S.project) : void 0), M;
    },
    fromPartial(S) {
      var M, L;
      const we = Tn();
      return we.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", we.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", we.project = S.project !== void 0 && S.project !== null ? a.Project.fromPartial(S.project) : void 0, we;
    }
  };
  function In() {
    return { collectionId: "", projectId: "" };
  }
  a.ProjectDeleteEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = In();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), M;
    },
    fromPartial(S) {
      var M, L;
      const we = In();
      return we.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", we.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", we;
    }
  };
  function kn() {
    return { collectionId: "", projectId: "", updateMask: [], project: void 0 };
  }
  a.ProjectUpdateEvent = {
    encode(S, M = c.default.Writer.create()) {
      S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId);
      for (const L of S.updateMask)
        M.uint32(26).string(L);
      return S.project !== void 0 && a.Project.encode(S.project, M.uint32(34).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = kn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.updateMask.push(L.string());
            break;
          case 4:
            oe.project = a.Project.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        updateMask: Array.isArray(S == null ? void 0 : S.updateMask) ? S.updateMask.map((M) => String(M)) : [],
        project: Le(S.project) ? a.Project.fromJSON(S.project) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.updateMask ? M.updateMask = S.updateMask.map((L) => L) : M.updateMask = [], S.project !== void 0 && (M.project = S.project ? a.Project.toJSON(S.project) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = kn();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", oe.updateMask = ((we = S.updateMask) === null || we === void 0 ? void 0 : we.map((Pe) => Pe)) || [], oe.project = S.project !== void 0 && S.project !== null ? a.Project.fromPartial(S.project) : void 0, oe;
    }
  };
  function Rn() {
    return { collectionId: "", projectId: "", broadcastId: "", phase: void 0, error: void 0 };
  }
  a.ProjectBroadcastStateEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.broadcastId !== "" && M.uint32(26).string(S.broadcastId), S.phase !== void 0 && M.uint32(32).int32(ye(S.phase)), S.error !== void 0 && M.uint32(40).int32(We(S.error)), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Rn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.broadcastId = L.string();
            break;
          case 4:
            oe.phase = Ie(L.int32());
            break;
          case 5:
            oe.error = ge(L.int32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        broadcastId: Le(S.broadcastId) ? String(S.broadcastId) : "",
        phase: Le(S.phase) ? Ie(S.phase) : void 0,
        error: Le(S.error) ? ge(S.error) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.broadcastId !== void 0 && (M.broadcastId = S.broadcastId), S.phase !== void 0 && (M.phase = S.phase !== void 0 ? $e(S.phase) : void 0), S.error !== void 0 && (M.error = S.error !== void 0 ? Te(S.error) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we, oe, Pe;
      const bt = Rn();
      return bt.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", bt.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", bt.broadcastId = (we = S.broadcastId) !== null && we !== void 0 ? we : "", bt.phase = (oe = S.phase) !== null && oe !== void 0 ? oe : void 0, bt.error = (Pe = S.error) !== null && Pe !== void 0 ? Pe : void 0, bt;
    }
  };
  function Cn() {
    return { collectionId: "", collection: void 0 };
  }
  a.CollectionCreateEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.collection !== void 0 && a.Collection.encode(S.collection, M.uint32(18).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Cn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.collection = a.Collection.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        collection: Le(S.collection) ? a.Collection.fromJSON(S.collection) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.collection !== void 0 && (M.collection = S.collection ? a.Collection.toJSON(S.collection) : void 0), M;
    },
    fromPartial(S) {
      var M;
      const L = Cn();
      return L.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", L.collection = S.collection !== void 0 && S.collection !== null ? a.Collection.fromPartial(S.collection) : void 0, L;
    }
  };
  function Pn() {
    return { collectionId: "" };
  }
  a.CollectionDeleteEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Pn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return { collectionId: Le(S.collectionId) ? String(S.collectionId) : "" };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), M;
    },
    fromPartial(S) {
      var M;
      const L = Pn();
      return L.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", L;
    }
  };
  function On() {
    return { collectionId: "", updateMask: [], collection: void 0 };
  }
  a.CollectionUpdateEvent = {
    encode(S, M = c.default.Writer.create()) {
      S.collectionId !== "" && M.uint32(10).string(S.collectionId);
      for (const L of S.updateMask)
        M.uint32(18).string(L);
      return S.collection !== void 0 && a.Collection.encode(S.collection, M.uint32(26).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = On();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.updateMask.push(L.string());
            break;
          case 3:
            oe.collection = a.Collection.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        updateMask: Array.isArray(S == null ? void 0 : S.updateMask) ? S.updateMask.map((M) => String(M)) : [],
        collection: Le(S.collection) ? a.Collection.fromJSON(S.collection) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.updateMask ? M.updateMask = S.updateMask.map((L) => L) : M.updateMask = [], S.collection !== void 0 && (M.collection = S.collection ? a.Collection.toJSON(S.collection) : void 0), M;
    },
    fromPartial(S) {
      var M, L;
      const we = On();
      return we.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", we.updateMask = ((L = S.updateMask) === null || L === void 0 ? void 0 : L.map((oe) => oe)) || [], we.collection = S.collection !== void 0 && S.collection !== null ? a.Collection.fromPartial(S.collection) : void 0, we;
    }
  };
  function Mn() {
    return { collectionId: "", sourceId: "", source: void 0 };
  }
  a.SourceCreateEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.sourceId !== "" && M.uint32(18).string(S.sourceId), S.source !== void 0 && a.Source.encode(S.source, M.uint32(26).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Mn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.sourceId = L.string();
            break;
          case 3:
            oe.source = a.Source.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : "",
        source: Le(S.source) ? a.Source.fromJSON(S.source) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), S.source !== void 0 && (M.source = S.source ? a.Source.toJSON(S.source) : void 0), M;
    },
    fromPartial(S) {
      var M, L;
      const we = Mn();
      return we.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", we.sourceId = (L = S.sourceId) !== null && L !== void 0 ? L : "", we.source = S.source !== void 0 && S.source !== null ? a.Source.fromPartial(S.source) : void 0, we;
    }
  };
  function Nn() {
    return { collectionId: "", sourceId: "" };
  }
  a.SourceDeleteEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.sourceId !== "" && M.uint32(18).string(S.sourceId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Nn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.sourceId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), M;
    },
    fromPartial(S) {
      var M, L;
      const we = Nn();
      return we.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", we.sourceId = (L = S.sourceId) !== null && L !== void 0 ? L : "", we;
    }
  };
  function An() {
    return { collectionId: "", sourceId: "", updateMask: [], source: void 0 };
  }
  a.SourceUpdateEvent = {
    encode(S, M = c.default.Writer.create()) {
      S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.sourceId !== "" && M.uint32(18).string(S.sourceId);
      for (const L of S.updateMask)
        M.uint32(26).string(L);
      return S.source !== void 0 && a.Source.encode(S.source, M.uint32(34).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = An();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.sourceId = L.string();
            break;
          case 3:
            oe.updateMask.push(L.string());
            break;
          case 4:
            oe.source = a.Source.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : "",
        updateMask: Array.isArray(S == null ? void 0 : S.updateMask) ? S.updateMask.map((M) => String(M)) : [],
        source: Le(S.source) ? a.Source.fromJSON(S.source) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), S.updateMask ? M.updateMask = S.updateMask.map((L) => L) : M.updateMask = [], S.source !== void 0 && (M.source = S.source ? a.Source.toJSON(S.source) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = An();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.sourceId = (L = S.sourceId) !== null && L !== void 0 ? L : "", oe.updateMask = ((we = S.updateMask) === null || we === void 0 ? void 0 : we.map((Pe) => Pe)) || [], oe.source = S.source !== void 0 && S.source !== null ? a.Source.fromPartial(S.source) : void 0, oe;
    }
  };
  function $n() {
    return { collectionId: "", sourceId: "", projectId: "", source: void 0 };
  }
  a.SourceAddEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.sourceId !== "" && M.uint32(18).string(S.sourceId), S.projectId !== "" && M.uint32(26).string(S.projectId), S.source !== void 0 && a.Source.encode(S.source, M.uint32(34).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = $n();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.sourceId = L.string();
            break;
          case 3:
            oe.projectId = L.string();
            break;
          case 4:
            oe.source = a.Source.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        source: Le(S.source) ? a.Source.fromJSON(S.source) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), S.projectId !== void 0 && (M.projectId = S.projectId), S.source !== void 0 && (M.source = S.source ? a.Source.toJSON(S.source) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = $n();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.sourceId = (L = S.sourceId) !== null && L !== void 0 ? L : "", oe.projectId = (we = S.projectId) !== null && we !== void 0 ? we : "", oe.source = S.source !== void 0 && S.source !== null ? a.Source.fromPartial(S.source) : void 0, oe;
    }
  };
  function Dn() {
    return { collectionId: "", sourceId: "", projectId: "" };
  }
  a.SourceRemoveEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.sourceId !== "" && M.uint32(18).string(S.sourceId), S.projectId !== "" && M.uint32(26).string(S.projectId), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Dn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.sourceId = L.string();
            break;
          case 3:
            oe.projectId = L.string();
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : ""
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), S.projectId !== void 0 && (M.projectId = S.projectId), M;
    },
    fromPartial(S) {
      var M, L, we;
      const oe = Dn();
      return oe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", oe.sourceId = (L = S.sourceId) !== null && L !== void 0 ? L : "", oe.projectId = (we = S.projectId) !== null && we !== void 0 ? we : "", oe;
    }
  };
  function Ln() {
    return { collectionId: "", projectId: "", sourceId: "", connect: void 0 };
  }
  a.SourceStateEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collectionId !== "" && M.uint32(10).string(S.collectionId), S.projectId !== "" && M.uint32(18).string(S.projectId), S.sourceId !== "" && M.uint32(26).string(S.sourceId), S.connect !== void 0 && M.uint32(32).int32(ue(S.connect)), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Ln();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collectionId = L.string();
            break;
          case 2:
            oe.projectId = L.string();
            break;
          case 3:
            oe.sourceId = L.string();
            break;
          case 4:
            oe.connect = J(L.int32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collectionId: Le(S.collectionId) ? String(S.collectionId) : "",
        projectId: Le(S.projectId) ? String(S.projectId) : "",
        sourceId: Le(S.sourceId) ? String(S.sourceId) : "",
        connect: Le(S.connect) ? J(S.connect) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collectionId !== void 0 && (M.collectionId = S.collectionId), S.projectId !== void 0 && (M.projectId = S.projectId), S.sourceId !== void 0 && (M.sourceId = S.sourceId), S.connect !== void 0 && (M.connect = S.connect !== void 0 ? Ee(S.connect) : void 0), M;
    },
    fromPartial(S) {
      var M, L, we, oe;
      const Pe = Ln();
      return Pe.collectionId = (M = S.collectionId) !== null && M !== void 0 ? M : "", Pe.projectId = (L = S.projectId) !== null && L !== void 0 ? L : "", Pe.sourceId = (we = S.sourceId) !== null && we !== void 0 ? we : "", Pe.connect = (oe = S.connect) !== null && oe !== void 0 ? oe : void 0, Pe;
    }
  };
  function Bn() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.CollectionEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.create !== void 0 && a.CollectionCreateEvent.encode(S.create, M.uint32(10).fork()).ldelim(), S.update !== void 0 && a.CollectionUpdateEvent.encode(S.update, M.uint32(18).fork()).ldelim(), S.delete !== void 0 && a.CollectionDeleteEvent.encode(S.delete, M.uint32(26).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Bn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.create = a.CollectionCreateEvent.decode(L, L.uint32());
            break;
          case 2:
            oe.update = a.CollectionUpdateEvent.decode(L, L.uint32());
            break;
          case 3:
            oe.delete = a.CollectionDeleteEvent.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        create: Le(S.create) ? a.CollectionCreateEvent.fromJSON(S.create) : void 0,
        update: Le(S.update) ? a.CollectionUpdateEvent.fromJSON(S.update) : void 0,
        delete: Le(S.delete) ? a.CollectionDeleteEvent.fromJSON(S.delete) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.create !== void 0 && (M.create = S.create ? a.CollectionCreateEvent.toJSON(S.create) : void 0), S.update !== void 0 && (M.update = S.update ? a.CollectionUpdateEvent.toJSON(S.update) : void 0), S.delete !== void 0 && (M.delete = S.delete ? a.CollectionDeleteEvent.toJSON(S.delete) : void 0), M;
    },
    fromPartial(S) {
      const M = Bn();
      return M.create = S.create !== void 0 && S.create !== null ? a.CollectionCreateEvent.fromPartial(S.create) : void 0, M.update = S.update !== void 0 && S.update !== null ? a.CollectionUpdateEvent.fromPartial(S.update) : void 0, M.delete = S.delete !== void 0 && S.delete !== null ? a.CollectionDeleteEvent.fromPartial(S.delete) : void 0, M;
    }
  };
  function xn() {
    return { create: void 0, update: void 0, delete: void 0, state: void 0 };
  }
  a.DestinationEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.create !== void 0 && a.DestinationCreateEvent.encode(S.create, M.uint32(10).fork()).ldelim(), S.update !== void 0 && a.DestinationUpdateEvent.encode(S.update, M.uint32(18).fork()).ldelim(), S.delete !== void 0 && a.DestinationDeleteEvent.encode(S.delete, M.uint32(26).fork()).ldelim(), S.state !== void 0 && a.DestinationStateEvent.encode(S.state, M.uint32(34).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = xn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.create = a.DestinationCreateEvent.decode(L, L.uint32());
            break;
          case 2:
            oe.update = a.DestinationUpdateEvent.decode(L, L.uint32());
            break;
          case 3:
            oe.delete = a.DestinationDeleteEvent.decode(L, L.uint32());
            break;
          case 4:
            oe.state = a.DestinationStateEvent.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        create: Le(S.create) ? a.DestinationCreateEvent.fromJSON(S.create) : void 0,
        update: Le(S.update) ? a.DestinationUpdateEvent.fromJSON(S.update) : void 0,
        delete: Le(S.delete) ? a.DestinationDeleteEvent.fromJSON(S.delete) : void 0,
        state: Le(S.state) ? a.DestinationStateEvent.fromJSON(S.state) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.create !== void 0 && (M.create = S.create ? a.DestinationCreateEvent.toJSON(S.create) : void 0), S.update !== void 0 && (M.update = S.update ? a.DestinationUpdateEvent.toJSON(S.update) : void 0), S.delete !== void 0 && (M.delete = S.delete ? a.DestinationDeleteEvent.toJSON(S.delete) : void 0), S.state !== void 0 && (M.state = S.state ? a.DestinationStateEvent.toJSON(S.state) : void 0), M;
    },
    fromPartial(S) {
      const M = xn();
      return M.create = S.create !== void 0 && S.create !== null ? a.DestinationCreateEvent.fromPartial(S.create) : void 0, M.update = S.update !== void 0 && S.update !== null ? a.DestinationUpdateEvent.fromPartial(S.update) : void 0, M.delete = S.delete !== void 0 && S.delete !== null ? a.DestinationDeleteEvent.fromPartial(S.delete) : void 0, M.state = S.state !== void 0 && S.state !== null ? a.DestinationStateEvent.fromPartial(S.state) : void 0, M;
    }
  };
  function Un() {
    return { create: void 0, update: void 0, delete: void 0, state: void 0 };
  }
  a.ProjectEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.create !== void 0 && a.ProjectCreateEvent.encode(S.create, M.uint32(10).fork()).ldelim(), S.update !== void 0 && a.ProjectUpdateEvent.encode(S.update, M.uint32(18).fork()).ldelim(), S.delete !== void 0 && a.ProjectDeleteEvent.encode(S.delete, M.uint32(26).fork()).ldelim(), S.state !== void 0 && a.ProjectBroadcastStateEvent.encode(S.state, M.uint32(34).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Un();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.create = a.ProjectCreateEvent.decode(L, L.uint32());
            break;
          case 2:
            oe.update = a.ProjectUpdateEvent.decode(L, L.uint32());
            break;
          case 3:
            oe.delete = a.ProjectDeleteEvent.decode(L, L.uint32());
            break;
          case 4:
            oe.state = a.ProjectBroadcastStateEvent.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        create: Le(S.create) ? a.ProjectCreateEvent.fromJSON(S.create) : void 0,
        update: Le(S.update) ? a.ProjectUpdateEvent.fromJSON(S.update) : void 0,
        delete: Le(S.delete) ? a.ProjectDeleteEvent.fromJSON(S.delete) : void 0,
        state: Le(S.state) ? a.ProjectBroadcastStateEvent.fromJSON(S.state) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.create !== void 0 && (M.create = S.create ? a.ProjectCreateEvent.toJSON(S.create) : void 0), S.update !== void 0 && (M.update = S.update ? a.ProjectUpdateEvent.toJSON(S.update) : void 0), S.delete !== void 0 && (M.delete = S.delete ? a.ProjectDeleteEvent.toJSON(S.delete) : void 0), S.state !== void 0 && (M.state = S.state ? a.ProjectBroadcastStateEvent.toJSON(S.state) : void 0), M;
    },
    fromPartial(S) {
      const M = Un();
      return M.create = S.create !== void 0 && S.create !== null ? a.ProjectCreateEvent.fromPartial(S.create) : void 0, M.update = S.update !== void 0 && S.update !== null ? a.ProjectUpdateEvent.fromPartial(S.update) : void 0, M.delete = S.delete !== void 0 && S.delete !== null ? a.ProjectDeleteEvent.fromPartial(S.delete) : void 0, M.state = S.state !== void 0 && S.state !== null ? a.ProjectBroadcastStateEvent.fromPartial(S.state) : void 0, M;
    }
  };
  function Fn() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      add: void 0,
      remove: void 0,
      state: void 0
    };
  }
  a.SourceEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.create !== void 0 && a.SourceCreateEvent.encode(S.create, M.uint32(10).fork()).ldelim(), S.update !== void 0 && a.SourceUpdateEvent.encode(S.update, M.uint32(18).fork()).ldelim(), S.delete !== void 0 && a.SourceDeleteEvent.encode(S.delete, M.uint32(26).fork()).ldelim(), S.add !== void 0 && a.SourceAddEvent.encode(S.add, M.uint32(34).fork()).ldelim(), S.remove !== void 0 && a.SourceRemoveEvent.encode(S.remove, M.uint32(42).fork()).ldelim(), S.state !== void 0 && a.SourceStateEvent.encode(S.state, M.uint32(50).fork()).ldelim(), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = Fn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.create = a.SourceCreateEvent.decode(L, L.uint32());
            break;
          case 2:
            oe.update = a.SourceUpdateEvent.decode(L, L.uint32());
            break;
          case 3:
            oe.delete = a.SourceDeleteEvent.decode(L, L.uint32());
            break;
          case 4:
            oe.add = a.SourceAddEvent.decode(L, L.uint32());
            break;
          case 5:
            oe.remove = a.SourceRemoveEvent.decode(L, L.uint32());
            break;
          case 6:
            oe.state = a.SourceStateEvent.decode(L, L.uint32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        create: Le(S.create) ? a.SourceCreateEvent.fromJSON(S.create) : void 0,
        update: Le(S.update) ? a.SourceUpdateEvent.fromJSON(S.update) : void 0,
        delete: Le(S.delete) ? a.SourceDeleteEvent.fromJSON(S.delete) : void 0,
        add: Le(S.add) ? a.SourceAddEvent.fromJSON(S.add) : void 0,
        remove: Le(S.remove) ? a.SourceRemoveEvent.fromJSON(S.remove) : void 0,
        state: Le(S.state) ? a.SourceStateEvent.fromJSON(S.state) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.create !== void 0 && (M.create = S.create ? a.SourceCreateEvent.toJSON(S.create) : void 0), S.update !== void 0 && (M.update = S.update ? a.SourceUpdateEvent.toJSON(S.update) : void 0), S.delete !== void 0 && (M.delete = S.delete ? a.SourceDeleteEvent.toJSON(S.delete) : void 0), S.add !== void 0 && (M.add = S.add ? a.SourceAddEvent.toJSON(S.add) : void 0), S.remove !== void 0 && (M.remove = S.remove ? a.SourceRemoveEvent.toJSON(S.remove) : void 0), S.state !== void 0 && (M.state = S.state ? a.SourceStateEvent.toJSON(S.state) : void 0), M;
    },
    fromPartial(S) {
      const M = Fn();
      return M.create = S.create !== void 0 && S.create !== null ? a.SourceCreateEvent.fromPartial(S.create) : void 0, M.update = S.update !== void 0 && S.update !== null ? a.SourceUpdateEvent.fromPartial(S.update) : void 0, M.delete = S.delete !== void 0 && S.delete !== null ? a.SourceDeleteEvent.fromPartial(S.delete) : void 0, M.add = S.add !== void 0 && S.add !== null ? a.SourceAddEvent.fromPartial(S.add) : void 0, M.remove = S.remove !== void 0 && S.remove !== null ? a.SourceRemoveEvent.fromPartial(S.remove) : void 0, M.state = S.state !== void 0 && S.state !== null ? a.SourceStateEvent.fromPartial(S.state) : void 0, M;
    }
  };
  function qn() {
    return {
      collection: void 0,
      destination: void 0,
      project: void 0,
      source: void 0,
      unspecified: void 0
    };
  }
  a.LiveEvent = {
    encode(S, M = c.default.Writer.create()) {
      return S.collection !== void 0 && a.CollectionEvent.encode(S.collection, M.uint32(10).fork()).ldelim(), S.destination !== void 0 && a.DestinationEvent.encode(S.destination, M.uint32(18).fork()).ldelim(), S.project !== void 0 && a.ProjectEvent.encode(S.project, M.uint32(26).fork()).ldelim(), S.source !== void 0 && a.SourceEvent.encode(S.source, M.uint32(34).fork()).ldelim(), S.unspecified !== void 0 && M.uint32(40).int32((0, p.nullValueToNumber)(S.unspecified)), M;
    },
    decode(S, M) {
      const L = S instanceof c.default.Reader ? S : new c.default.Reader(S);
      let we = M === void 0 ? L.len : L.pos + M;
      const oe = qn();
      for (; L.pos < we; ) {
        const Pe = L.uint32();
        switch (Pe >>> 3) {
          case 1:
            oe.collection = a.CollectionEvent.decode(L, L.uint32());
            break;
          case 2:
            oe.destination = a.DestinationEvent.decode(L, L.uint32());
            break;
          case 3:
            oe.project = a.ProjectEvent.decode(L, L.uint32());
            break;
          case 4:
            oe.source = a.SourceEvent.decode(L, L.uint32());
            break;
          case 5:
            oe.unspecified = (0, p.nullValueFromJSON)(L.int32());
            break;
          default:
            L.skipType(Pe & 7);
            break;
        }
      }
      return oe;
    },
    fromJSON(S) {
      return {
        collection: Le(S.collection) ? a.CollectionEvent.fromJSON(S.collection) : void 0,
        destination: Le(S.destination) ? a.DestinationEvent.fromJSON(S.destination) : void 0,
        project: Le(S.project) ? a.ProjectEvent.fromJSON(S.project) : void 0,
        source: Le(S.source) ? a.SourceEvent.fromJSON(S.source) : void 0,
        unspecified: Le(S.unspecified) ? (0, p.nullValueFromJSON)(S.unspecified) : void 0
      };
    },
    toJSON(S) {
      const M = {};
      return S.collection !== void 0 && (M.collection = S.collection ? a.CollectionEvent.toJSON(S.collection) : void 0), S.destination !== void 0 && (M.destination = S.destination ? a.DestinationEvent.toJSON(S.destination) : void 0), S.project !== void 0 && (M.project = S.project ? a.ProjectEvent.toJSON(S.project) : void 0), S.source !== void 0 && (M.source = S.source ? a.SourceEvent.toJSON(S.source) : void 0), S.unspecified !== void 0 && (M.unspecified = S.unspecified !== void 0 ? (0, p.nullValueToJSON)(S.unspecified) : void 0), M;
    },
    fromPartial(S) {
      var M;
      const L = qn();
      return L.collection = S.collection !== void 0 && S.collection !== null ? a.CollectionEvent.fromPartial(S.collection) : void 0, L.destination = S.destination !== void 0 && S.destination !== null ? a.DestinationEvent.fromPartial(S.destination) : void 0, L.project = S.project !== void 0 && S.project !== null ? a.ProjectEvent.fromPartial(S.project) : void 0, L.source = S.source !== void 0 && S.source !== null ? a.SourceEvent.fromPartial(S.source) : void 0, L.unspecified = (M = S.unspecified) !== null && M !== void 0 ? M : void 0, L;
    }
  };
  class Vn {
    constructor(M, L) {
      this.service = (L == null ? void 0 : L.service) || "live.v21.CollectionService", this.rpc = M, this.CreateCollection = this.CreateCollection.bind(this), this.GetCollection = this.GetCollection.bind(this), this.GetCollections = this.GetCollections.bind(this), this.UpdateCollection = this.UpdateCollection.bind(this), this.DeleteCollection = this.DeleteCollection.bind(this);
    }
    CreateCollection(M) {
      const L = a.CreateCollectionRequest.encode(M).finish();
      return this.rpc.request(this.service, "CreateCollection", L).then((oe) => a.CreateCollectionResponse.decode(new c.default.Reader(oe)));
    }
    GetCollection(M) {
      const L = a.GetCollectionRequest.encode(M).finish();
      return this.rpc.request(this.service, "GetCollection", L).then((oe) => a.GetCollectionResponse.decode(new c.default.Reader(oe)));
    }
    GetCollections(M) {
      const L = a.GetCollectionsRequest.encode(M).finish();
      return this.rpc.request(this.service, "GetCollections", L).then((oe) => a.GetCollectionsResponse.decode(new c.default.Reader(oe)));
    }
    UpdateCollection(M) {
      const L = a.UpdateCollectionRequest.encode(M).finish();
      return this.rpc.request(this.service, "UpdateCollection", L).then((oe) => a.UpdateCollectionResponse.decode(new c.default.Reader(oe)));
    }
    DeleteCollection(M) {
      const L = a.DeleteCollectionRequest.encode(M).finish();
      return this.rpc.request(this.service, "DeleteCollection", L).then((oe) => a.DeleteCollectionResponse.decode(new c.default.Reader(oe)));
    }
  }
  a.CollectionServiceClientImpl = Vn, a.CollectionServiceDefinition = {
    name: "CollectionService",
    fullName: "live.v21.CollectionService",
    methods: {
      /**
       * Create Collection
       *
       * Create a new collection of related projects and collection live sources
       */
      createCollection: {
        name: "CreateCollection",
        requestType: a.CreateCollectionRequest,
        requestStream: !1,
        responseType: a.CreateCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Collection
       *
       * Get an existing collection of related projects and collection live
       * sources
       */
      getCollection: {
        name: "GetCollection",
        requestType: a.GetCollectionRequest,
        requestStream: !1,
        responseType: a.GetCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Collections
       *
       * Get all collections owned by the user
       */
      getCollections: {
        name: "GetCollections",
        requestType: a.GetCollectionsRequest,
        requestStream: !1,
        responseType: a.GetCollectionsResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Collection
       *
       * Update select collection document data
       */
      updateCollection: {
        name: "UpdateCollection",
        requestType: a.UpdateCollectionRequest,
        requestStream: !1,
        responseType: a.UpdateCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Collection
       *
       * Delete a collection of related projects and collection live sources
       */
      deleteCollection: {
        name: "DeleteCollection",
        requestType: a.DeleteCollectionRequest,
        requestStream: !1,
        responseType: a.DeleteCollectionResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Gn {
    constructor(M, L) {
      this.service = (L == null ? void 0 : L.service) || "live.v21.ProjectService", this.rpc = M, this.CreateProject = this.CreateProject.bind(this), this.GetProject = this.GetProject.bind(this), this.DeleteProject = this.DeleteProject.bind(this), this.UpdateProject = this.UpdateProject.bind(this), this.StartProjectBroadcast = this.StartProjectBroadcast.bind(this), this.StopProjectBroadcast = this.StopProjectBroadcast.bind(this), this.StartProjectWebRtc = this.StartProjectWebRtc.bind(this), this.StopProjectWebRtc = this.StopProjectWebRtc.bind(this), this.GetProjectBroadcastSnapshot = this.GetProjectBroadcastSnapshot.bind(this), this.GetProjectBroadcastStatus = this.GetProjectBroadcastStatus.bind(this);
    }
    CreateProject(M) {
      const L = a.CreateProjectRequest.encode(M).finish();
      return this.rpc.request(this.service, "CreateProject", L).then((oe) => a.CreateProjectResponse.decode(new c.default.Reader(oe)));
    }
    GetProject(M) {
      const L = a.GetProjectRequest.encode(M).finish();
      return this.rpc.request(this.service, "GetProject", L).then((oe) => a.GetProjectResponse.decode(new c.default.Reader(oe)));
    }
    DeleteProject(M) {
      const L = a.DeleteProjectRequest.encode(M).finish();
      return this.rpc.request(this.service, "DeleteProject", L).then((oe) => a.DeleteProjectResponse.decode(new c.default.Reader(oe)));
    }
    UpdateProject(M) {
      const L = a.UpdateProjectRequest.encode(M).finish();
      return this.rpc.request(this.service, "UpdateProject", L).then((oe) => a.UpdateProjectResponse.decode(new c.default.Reader(oe)));
    }
    StartProjectBroadcast(M) {
      const L = a.StartProjectBroadcastRequest.encode(M).finish();
      return this.rpc.request(this.service, "StartProjectBroadcast", L).then((oe) => a.StartProjectBroadcastResponse.decode(new c.default.Reader(oe)));
    }
    StopProjectBroadcast(M) {
      const L = a.StopProjectBroadcastRequest.encode(M).finish();
      return this.rpc.request(this.service, "StopProjectBroadcast", L).then((oe) => a.StopProjectBroadcastResponse.decode(new c.default.Reader(oe)));
    }
    StartProjectWebRtc(M) {
      const L = a.StartProjectWebRtcRequest.encode(M).finish();
      return this.rpc.request(this.service, "StartProjectWebRtc", L).then((oe) => a.StartProjectWebRtcResponse.decode(new c.default.Reader(oe)));
    }
    StopProjectWebRtc(M) {
      const L = a.StopProjectWebRtcRequest.encode(M).finish();
      return this.rpc.request(this.service, "StopProjectWebRtc", L).then((oe) => a.StopProjectWebRtcResponse.decode(new c.default.Reader(oe)));
    }
    GetProjectBroadcastSnapshot(M) {
      const L = a.GetProjectBroadcastSnapshotRequest.encode(M).finish();
      return this.rpc.request(this.service, "GetProjectBroadcastSnapshot", L).then((oe) => a.GetProjectBroadcastSnapshotResponse.decode(new c.default.Reader(oe)));
    }
    GetProjectBroadcastStatus(M) {
      const L = a.GetProjectBroadcastStatusRequest.encode(M).finish();
      return this.rpc.request(this.service, "GetProjectBroadcastStatus", L).then((oe) => a.GetProjectBroadcastStatusResponse.decode(new c.default.Reader(oe)));
    }
  }
  a.ProjectServiceClientImpl = Gn, a.ProjectServiceDefinition = {
    name: "ProjectService",
    fullName: "live.v21.ProjectService",
    methods: {
      /**
       * Create Project
       *
       * Create a new project
       */
      createProject: {
        name: "CreateProject",
        requestType: a.CreateProjectRequest,
        requestStream: !1,
        responseType: a.CreateProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Project
       *
       * Get an existing project
       */
      getProject: {
        name: "GetProject",
        requestType: a.GetProjectRequest,
        requestStream: !1,
        responseType: a.GetProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Project
       *
       * Delete a project
       */
      deleteProject: {
        name: "DeleteProject",
        requestType: a.DeleteProjectRequest,
        requestStream: !1,
        responseType: a.DeleteProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Project
       *
       * Updates a project
       */
      updateProject: {
        name: "UpdateProject",
        requestType: a.UpdateProjectRequest,
        requestStream: !1,
        responseType: a.UpdateProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Start Broadcast
       *
       * Start broadcasting a project
       */
      startProjectBroadcast: {
        name: "StartProjectBroadcast",
        requestType: a.StartProjectBroadcastRequest,
        requestStream: !1,
        responseType: a.StartProjectBroadcastResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Stop Broadcast
       *
       * Stop broadcasting a project
       */
      stopProjectBroadcast: {
        name: "StopProjectBroadcast",
        requestType: a.StopProjectBroadcastRequest,
        requestStream: !1,
        responseType: a.StopProjectBroadcastResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Start WebRTC
       *
       * Start WebRTC services
       */
      startProjectWebRtc: {
        name: "StartProjectWebRtc",
        requestType: a.StartProjectWebRtcRequest,
        requestStream: !1,
        responseType: a.StartProjectWebRtcResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Stop WebRTC
       *
       * Stop WebRTC services
       */
      stopProjectWebRtc: {
        name: "StopProjectWebRtc",
        requestType: a.StopProjectWebRtcRequest,
        requestStream: !1,
        responseType: a.StopProjectWebRtcResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Snapshot
       *
       * Get a snapshot of the current output frame of the broadcast
       */
      getProjectBroadcastSnapshot: {
        name: "GetProjectBroadcastSnapshot",
        requestType: a.GetProjectBroadcastSnapshotRequest,
        requestStream: !1,
        responseType: a.GetProjectBroadcastSnapshotResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Broadcast Status
       *
       * Get the broadcast status of the project
       */
      getProjectBroadcastStatus: {
        name: "GetProjectBroadcastStatus",
        requestType: a.GetProjectBroadcastStatusRequest,
        requestStream: !1,
        responseType: a.GetProjectBroadcastStatusResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Wn {
    constructor(M, L) {
      this.service = (L == null ? void 0 : L.service) || "live.v21.DestinationService", this.rpc = M, this.CreateDestination = this.CreateDestination.bind(this), this.GetDestination = this.GetDestination.bind(this), this.UpdateDestination = this.UpdateDestination.bind(this), this.DeleteDestination = this.DeleteDestination.bind(this);
    }
    CreateDestination(M) {
      const L = a.CreateDestinationRequest.encode(M).finish();
      return this.rpc.request(this.service, "CreateDestination", L).then((oe) => a.CreateDestinationResponse.decode(new c.default.Reader(oe)));
    }
    GetDestination(M) {
      const L = a.GetDestinationRequest.encode(M).finish();
      return this.rpc.request(this.service, "GetDestination", L).then((oe) => a.GetDestinationResponse.decode(new c.default.Reader(oe)));
    }
    UpdateDestination(M) {
      const L = a.UpdateDestinationRequest.encode(M).finish();
      return this.rpc.request(this.service, "UpdateDestination", L).then((oe) => a.UpdateDestinationResponse.decode(new c.default.Reader(oe)));
    }
    DeleteDestination(M) {
      const L = a.DeleteDestinationRequest.encode(M).finish();
      return this.rpc.request(this.service, "DeleteDestination", L).then((oe) => a.DeleteDestinationResponse.decode(new c.default.Reader(oe)));
    }
  }
  a.DestinationServiceClientImpl = Wn, a.DestinationServiceDefinition = {
    name: "DestinationService",
    fullName: "live.v21.DestinationService",
    methods: {
      /**
       * Create Destination
       *
       * Create a new Destination
       */
      createDestination: {
        name: "CreateDestination",
        requestType: a.CreateDestinationRequest,
        requestStream: !1,
        responseType: a.CreateDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Destination
       *
       * Get an existing Destination.
       */
      getDestination: {
        name: "GetDestination",
        requestType: a.GetDestinationRequest,
        requestStream: !1,
        responseType: a.GetDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Destination
       *
       * Update a destination
       */
      updateDestination: {
        name: "UpdateDestination",
        requestType: a.UpdateDestinationRequest,
        requestStream: !1,
        responseType: a.UpdateDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Destination
       *
       * Delete a destination
       */
      deleteDestination: {
        name: "DeleteDestination",
        requestType: a.DeleteDestinationRequest,
        requestStream: !1,
        responseType: a.DeleteDestinationResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Hn {
    constructor(M, L) {
      this.service = (L == null ? void 0 : L.service) || "live.v21.SourceService", this.rpc = M, this.CreateSource = this.CreateSource.bind(this), this.DeleteSource = this.DeleteSource.bind(this), this.UpdateSource = this.UpdateSource.bind(this), this.UpdateSourceInProject = this.UpdateSourceInProject.bind(this), this.GetSource = this.GetSource.bind(this), this.GetSources = this.GetSources.bind(this), this.AddSourceToProject = this.AddSourceToProject.bind(this), this.RemoveSourceFromProject = this.RemoveSourceFromProject.bind(this), this.GetSourcePlaylist = this.GetSourcePlaylist.bind(this);
    }
    CreateSource(M) {
      const L = a.CreateSourceRequest.encode(M).finish();
      return this.rpc.request(this.service, "CreateSource", L).then((oe) => a.CreateSourceResponse.decode(new c.default.Reader(oe)));
    }
    DeleteSource(M) {
      const L = a.DeleteSourceRequest.encode(M).finish();
      return this.rpc.request(this.service, "DeleteSource", L).then((oe) => a.DeleteSourceResponse.decode(new c.default.Reader(oe)));
    }
    UpdateSource(M) {
      const L = a.UpdateSourceRequest.encode(M).finish();
      return this.rpc.request(this.service, "UpdateSource", L).then((oe) => a.UpdateSourceResponse.decode(new c.default.Reader(oe)));
    }
    UpdateSourceInProject(M) {
      const L = a.UpdateSourceInProjectRequest.encode(M).finish();
      return this.rpc.request(this.service, "UpdateSourceInProject", L).then((oe) => a.UpdateSourceInProjectResponse.decode(new c.default.Reader(oe)));
    }
    GetSource(M) {
      const L = a.GetSourceRequest.encode(M).finish();
      return this.rpc.request(this.service, "GetSource", L).then((oe) => a.GetSourceResponse.decode(new c.default.Reader(oe)));
    }
    GetSources(M) {
      const L = a.GetSourcesRequest.encode(M).finish();
      return this.rpc.request(this.service, "GetSources", L).then((oe) => a.GetSourcesResponse.decode(new c.default.Reader(oe)));
    }
    AddSourceToProject(M) {
      const L = a.AddSourceToProjectRequest.encode(M).finish();
      return this.rpc.request(this.service, "AddSourceToProject", L).then((oe) => a.AddSourceToProjectResponse.decode(new c.default.Reader(oe)));
    }
    RemoveSourceFromProject(M) {
      const L = a.RemoveSourceFromProjectRequest.encode(M).finish();
      return this.rpc.request(this.service, "RemoveSourceFromProject", L).then((oe) => a.RemoveSourceFromProjectResponse.decode(new c.default.Reader(oe)));
    }
    GetSourcePlaylist(M) {
      const L = a.GetSourcePlaylistRequest.encode(M).finish();
      return this.rpc.request(this.service, "GetSourcePlaylist", L).then((oe) => l.HttpBody.decode(new c.default.Reader(oe)));
    }
  }
  a.SourceServiceClientImpl = Hn, a.SourceServiceDefinition = {
    name: "SourceService",
    fullName: "live.v21.SourceService",
    methods: {
      /**
       * Create Collection Live Source
       *
       * Create a new live source in a collection
       * ### Permissions
       * * scope: `SCOPE_VAPI_CREATE`
       */
      createSource: {
        name: "CreateSource",
        requestType: a.CreateSourceRequest,
        requestStream: !1,
        responseType: a.CreateSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Live Source
       *
       * Deletes a live source from a collection
       */
      deleteSource: {
        name: "DeleteSource",
        requestType: a.DeleteSourceRequest,
        requestStream: !1,
        responseType: a.DeleteSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Source
       *
       * Update attributes of the Source.
       */
      updateSource: {
        name: "UpdateSource",
        requestType: a.UpdateSourceRequest,
        requestStream: !1,
        responseType: a.UpdateSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Source
       *
       * Update attributes of the Source.
       */
      updateSourceInProject: {
        name: "UpdateSourceInProject",
        requestType: a.UpdateSourceInProjectRequest,
        requestStream: !1,
        responseType: a.UpdateSourceInProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Source
       *
       * Get an existing source in a project
       */
      getSource: {
        name: "GetSource",
        requestType: a.GetSourceRequest,
        requestStream: !1,
        responseType: a.GetSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Source
       *
       * Get existing sources in a collection
       */
      getSources: {
        name: "GetSources",
        requestType: a.GetSourcesRequest,
        requestStream: !1,
        responseType: a.GetSourcesResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Add Source to Project
       *
       * Add a source to a project
       */
      addSourceToProject: {
        name: "AddSourceToProject",
        requestType: a.AddSourceToProjectRequest,
        requestStream: !1,
        responseType: a.AddSourceToProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Source From Project
       *
       * Removes a source from a project.
       */
      removeSourceFromProject: {
        name: "RemoveSourceFromProject",
        requestType: a.RemoveSourceFromProjectRequest,
        requestStream: !1,
        responseType: a.RemoveSourceFromProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get the HLS playlist for a source.
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      getSourcePlaylist: {
        name: "GetSourcePlaylist",
        requestType: a.GetSourcePlaylistRequest,
        requestStream: !1,
        responseType: l.HttpBody,
        responseStream: !1,
        options: {}
      }
    }
  };
  class zn {
    constructor(M, L) {
      this.service = (L == null ? void 0 : L.service) || "live.v21.BackendAuthenticationService", this.rpc = M, this.CreateAccessToken = this.CreateAccessToken.bind(this);
    }
    CreateAccessToken(M) {
      const L = a.CreateAccessTokenRequest.encode(M).finish();
      return this.rpc.request(this.service, "CreateAccessToken", L).then((oe) => a.CreateAccessTokenResponse.decode(new c.default.Reader(oe)));
    }
  }
  a.BackendAuthenticationServiceClientImpl = zn, a.BackendAuthenticationServiceDefinition = {
    name: "BackendAuthenticationService",
    fullName: "live.v21.BackendAuthenticationService",
    methods: {
      /**
       * Create Access Token
       *
       * Create an access token for a session host
       */
      createAccessToken: {
        name: "CreateAccessToken",
        requestType: a.CreateAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateAccessTokenResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Kn {
    constructor(M, L) {
      this.service = (L == null ? void 0 : L.service) || "live.v21.AuthenticationService", this.rpc = M, this.CreateGuestAccessToken = this.CreateGuestAccessToken.bind(this), this.RefreshAccessToken = this.RefreshAccessToken.bind(this), this.CreateWebRtcAccessToken = this.CreateWebRtcAccessToken.bind(this);
    }
    CreateGuestAccessToken(M) {
      const L = a.CreateGuestAccessTokenRequest.encode(M).finish();
      return this.rpc.request(this.service, "CreateGuestAccessToken", L).then((oe) => a.CreateGuestAccessTokenResponse.decode(new c.default.Reader(oe)));
    }
    RefreshAccessToken(M) {
      const L = a.RefreshAccessTokenRequest.encode(M).finish();
      return this.rpc.request(this.service, "RefreshAccessToken", L).then((oe) => a.RefreshAccessTokenResponse.decode(new c.default.Reader(oe)));
    }
    CreateWebRtcAccessToken(M) {
      const L = a.CreateWebRtcAccessTokenRequest.encode(M).finish();
      return this.rpc.request(this.service, "CreateWebRtcAccessToken", L).then((oe) => a.CreateWebRtcAccessTokenResponse.decode(new c.default.Reader(oe)));
    }
  }
  a.AuthenticationServiceClientImpl = Kn, a.AuthenticationServiceDefinition = {
    name: "AuthenticationService",
    fullName: "live.v21.AuthenticationService",
    methods: {
      /**
       * Create Guest Access Token
       *
       * Create an access token for a guest
       */
      createGuestAccessToken: {
        name: "CreateGuestAccessToken",
        requestType: a.CreateGuestAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateGuestAccessTokenResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Refresh Access Token
       *
       * Forcibly refresh an access token prior to expiration
       */
      refreshAccessToken: {
        name: "RefreshAccessToken",
        requestType: a.RefreshAccessTokenRequest,
        requestStream: !1,
        responseType: a.RefreshAccessTokenResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create WebRTC Access Token
       *
       * Create a WebRTC Access Token
       */
      createWebRtcAccessToken: {
        name: "CreateWebRtcAccessToken",
        requestType: a.CreateWebRtcAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateWebRtcAccessTokenResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Yn {
    constructor(M, L) {
      this.service = (L == null ? void 0 : L.service) || "live.v21.PublicAuthenticationService", this.rpc = M, this.GetJsonWebKeySet = this.GetJsonWebKeySet.bind(this), this.GuestCodeRedirect = this.GuestCodeRedirect.bind(this);
    }
    GetJsonWebKeySet(M) {
      const L = a.GetJsonWebKeySetRequest.encode(M).finish();
      return this.rpc.request(this.service, "GetJsonWebKeySet", L).then((oe) => a.GetJsonWebKeySetResponse.decode(new c.default.Reader(oe)));
    }
    GuestCodeRedirect(M) {
      const L = a.GuestCodeRedirectRequest.encode(M).finish();
      return this.rpc.request(this.service, "GuestCodeRedirect", L).then((oe) => a.GuestCodeRedirectResponse.decode(new c.default.Reader(oe)));
    }
  }
  a.PublicAuthenticationServiceClientImpl = Yn, a.PublicAuthenticationServiceDefinition = {
    name: "PublicAuthenticationService",
    fullName: "live.v21.PublicAuthenticationService",
    methods: {
      /**
       * Get Public Keys
       *
       * Get public keys used to sign access tokens
       */
      getJsonWebKeySet: {
        name: "GetJsonWebKeySet",
        requestType: a.GetJsonWebKeySetRequest,
        requestStream: !1,
        responseType: a.GetJsonWebKeySetResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Exchange Guest Access Token
       *
       * Exchange a guest access token with updated user identifiers
       */
      guestCodeRedirect: {
        name: "GuestCodeRedirect",
        requestType: a.GuestCodeRedirectRequest,
        requestStream: !1,
        responseType: a.GuestCodeRedirectResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var It = (() => {
    if (typeof It < "u")
      return It;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function jn(S) {
    if (It.Buffer)
      return Uint8Array.from(It.Buffer.from(S, "base64"));
    {
      const M = It.atob(S), L = new Uint8Array(M.length);
      for (let we = 0; we < M.length; ++we)
        L[we] = M.charCodeAt(we);
      return L;
    }
  }
  function Zn(S) {
    if (It.Buffer)
      return It.Buffer.from(S).toString("base64");
    {
      const M = [];
      return S.forEach((L) => {
        M.push(String.fromCharCode(L));
      }), It.btoa(M.join(""));
    }
  }
  function Ht(S) {
    const M = new Date(S), L = M.getTime() / 1e3, we = M.getTime() % 1e3 * 1e6;
    return { seconds: L, nanos: we };
  }
  function zt(S) {
    let M = S.seconds * 1e3;
    return M += S.nanos / 1e6, new Date(M).toISOString();
  }
  function Le(S) {
    return S != null;
  }
})(api$2);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(j, ee, X, ie) {
    ie === void 0 && (ie = X);
    var Q = Object.getOwnPropertyDescriptor(ee, X);
    (!Q || ("get" in Q ? !ee.__esModule : Q.writable || Q.configurable)) && (Q = { enumerable: !0, get: function() {
      return ee[X];
    } }), Object.defineProperty(j, ie, Q);
  } : function(j, ee, X, ie) {
    ie === void 0 && (ie = X), j[ie] = ee[X];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(j, ee) {
    Object.defineProperty(j, "default", { enumerable: !0, value: ee });
  } : function(j, ee) {
    j.default = ee;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(j, ee, X, ie) {
    var Q = arguments.length, ne = Q < 3 ? ee : ie === null ? ie = Object.getOwnPropertyDescriptor(ee, X) : ie, Z;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      ne = Reflect.decorate(j, ee, X, ie);
    else
      for (var de = j.length - 1; de >= 0; de--)
        (Z = j[de]) && (ne = (Q < 3 ? Z(ne) : Q > 3 ? Z(ee, X, ne) : Z(ee, X)) || ne);
    return Q > 3 && ne && Object.defineProperty(ee, X, ne), ne;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(j) {
    if (j && j.__esModule)
      return j;
    var ee = {};
    if (j != null)
      for (var X in j)
        X !== "default" && Object.prototype.hasOwnProperty.call(j, X) && u(ee, j, X);
    return c(ee, j), ee;
  }, p = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function(j, ee) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
      return Reflect.metadata(j, ee);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LiveApi = void 0;
  const _ = v(lib$1), I = api$3, P = v(api$2), $ = decorator, F = "LiveApi";
  class H extends I.ApiClient {
    constructor(ee, X, ie, Q, ne, Z, de) {
      super(ee, ie, Z, F, de), this.handlers = {}, this.eventApi = X, this.accessTokenRefreshCallback = Q, this.publicAuthentication = this.clientFactory.create(P.PublicAuthenticationServiceDefinition, this.channel), ne != null && (this.backendAuthentication = this.clientFactory.create(P.BackendAuthenticationServiceDefinition, this.channel, {
        "*": { metadata: _.Metadata({ "X-Api-Key": ne }) }
      })), this.eventApi.on("event", { name: `${H.LIVEAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: !0, allowedSessionEvents: [`${H.LIVEAPI_EVENT_PREFIX}:EVENT_TYPE_PROJECT:EVENT_SUB_TYPE_STATE`] }, this.eventCallback.bind(this));
    }
    /**
    * Register an event handler
    *
    * @param type Type of event
    * @param handler
    */
    on(ee, X) {
      var ie;
      this.handlers[ee] = (ie = this.handlers[ee]) !== null && ie !== void 0 ? ie : [], this.handlers[ee].push(X);
    }
    /**
     * Unregister an event handler
     *
     * @param type Type of event
     * @param handler
     */
    off(ee, X) {
      this.handlers[ee] = this.handlers[ee].filter((ie) => ie !== X);
    }
    emitToHandlers(ee, X, ie) {
      var Q;
      for (const ne of (Q = this.handlers[ee]) !== null && Q !== void 0 ? Q : [])
        ne(Object.values(ie).find((Z) => !!Z), X);
    }
    async subscribeToCollection(ee) {
      await this.eventApi.subscribe(`${H.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: ee } });
    }
    async unsubscribeFromCollection(ee) {
      await this.eventApi.unsubscribe(`${H.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: ee } });
    }
    async subscribeToProject(ee, X) {
      await this.eventApi.subscribe(`${H.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: ee, projectId: X } });
    }
    async unsubscribeFromProject(ee, X) {
      await this.eventApi.unsubscribe(`${H.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: ee, projectId: X } });
    }
    eventCallback(ee) {
      let ie = ee.name.split(`${H.LIVEAPI_EVENT_PREFIX}:`)[1].split(":"), Q = P.eventTypeFromJSON(ie[0]), ne = P.eventSubTypeFromJSON(ie[1]);
      this.log.info("processing event: " + Q + "/" + ne), H.liveApiEventMap[Q] && this.emitToHandlers(Q, ne, ee.payload);
    }
    _setup(ee) {
      let X = this;
      ee.onHeader = function(ie) {
        let Q = ie.get("Authorization");
        if (Q != null) {
          const ne = Q.split(" ");
          if (ne.length == 2 && ne[0] == "Bearer") {
            let Z = ne[1];
            X.log.info("received refresh token"), X.accessTokenRefreshCallback(Z);
          }
        }
      }, this.collection = this.clientFactory.create(P.CollectionServiceDefinition, this.channel, {
        "*": ee
      }), this.project = this.clientFactory.create(P.ProjectServiceDefinition, this.channel, {
        "*": ee
      }), this.source = this.clientFactory.create(P.SourceServiceDefinition, this.channel, {
        "*": ee
      }), this.destination = this.clientFactory.create(P.DestinationServiceDefinition, this.channel, {
        "*": ee
      }), this.authentication = this.clientFactory.create(P.AuthenticationServiceDefinition, this.channel, {
        "*": ee
      });
    }
  }
  H.LIVEAPI_EVENT_PREFIX = "apistream:live", l([
    (0, $.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], H.prototype, "collection", void 0), l([
    (0, $.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], H.prototype, "project", void 0), l([
    (0, $.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], H.prototype, "source", void 0), l([
    (0, $.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], H.prototype, "destination", void 0), l([
    (0, $.RequiresSdkAuthentication)(),
    p("design:type", Object)
  ], H.prototype, "authentication", void 0), a.LiveApi = H, function(j) {
    j.liveApiEventMap = {
      [P.EventType.EVENT_TYPE_COLLECTION]: "collection",
      [P.EventType.EVENT_TYPE_PROJECT]: "project",
      [P.EventType.EVENT_TYPE_SOURCE]: "source",
      [P.EventType.EVENT_TYPE_DESTINATION]: "destination",
      [P.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified"
    };
  }(H = a.LiveApi || (a.LiveApi = {}));
})(liveapi);
var eventapi = {}, dist$1 = {}, api$1 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(a, u) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, l) {
    c.__proto__ = l;
  } || function(c, l) {
    for (var v in l)
      l.hasOwnProperty(v) && (c[v] = l[v]);
  }, extendStatics(a, u);
};
function __extends(a, u) {
  extendStatics(a, u);
  function c() {
    this.constructor = a;
  }
  a.prototype = u === null ? Object.create(u) : (c.prototype = u.prototype, new c());
}
function isFunction$3(a) {
  return typeof a == "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = !1, config$3 = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(a) {
    if (a) {
      var u = /* @__PURE__ */ new Error();
      "" + u.stack;
    }
    _enable_super_gross_mode_that_will_cause_bad_things = a;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError(a) {
  setTimeout(function() {
    throw a;
  }, 0);
}
var empty$3 = {
  closed: !0,
  next: function(a) {
  },
  error: function(a) {
    if (config$3.useDeprecatedSynchronousErrorHandling)
      throw a;
    hostReportError(a);
  },
  complete: function() {
  }
}, isArray$5 = /* @__PURE__ */ function() {
  return Array.isArray || function(a) {
    return a && typeof a.length == "number";
  };
}();
function isObject$9(a) {
  return a !== null && typeof a == "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function a(u) {
    return Error.call(this), this.message = u ? u.length + ` errors occurred during unsubscription:
` + u.map(function(c, l) {
      return l + 1 + ") " + c.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = u, this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), UnsubscriptionError = UnsubscriptionErrorImpl, Subscription = /* @__PURE__ */ function() {
  function a(u) {
    this.closed = !1, this._parentOrParents = null, this._subscriptions = null, u && (this._ctorUnsubscribe = !0, this._unsubscribe = u);
  }
  return a.prototype.unsubscribe = function() {
    var u;
    if (!this.closed) {
      var c = this, l = c._parentOrParents, v = c._ctorUnsubscribe, p = c._unsubscribe, _ = c._subscriptions;
      if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, l instanceof a)
        l.remove(this);
      else if (l !== null)
        for (var I = 0; I < l.length; ++I) {
          var P = l[I];
          P.remove(this);
        }
      if (isFunction$3(p)) {
        v && (this._unsubscribe = void 0);
        try {
          p.call(this);
        } catch (H) {
          u = H instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(H.errors) : [H];
        }
      }
      if (isArray$5(_))
        for (var I = -1, $ = _.length; ++I < $; ) {
          var F = _[I];
          if (isObject$9(F))
            try {
              F.unsubscribe();
            } catch (j) {
              u = u || [], j instanceof UnsubscriptionError ? u = u.concat(flattenUnsubscriptionErrors(j.errors)) : u.push(j);
            }
        }
      if (u)
        throw new UnsubscriptionError(u);
    }
  }, a.prototype.add = function(u) {
    var c = u;
    if (!u)
      return a.EMPTY;
    switch (typeof u) {
      case "function":
        c = new a(u);
      case "object":
        if (c === this || c.closed || typeof c.unsubscribe != "function")
          return c;
        if (this.closed)
          return c.unsubscribe(), c;
        if (!(c instanceof a)) {
          var l = c;
          c = new a(), c._subscriptions = [l];
        }
        break;
      default:
        throw new Error("unrecognized teardown " + u + " added to Subscription.");
    }
    var v = c._parentOrParents;
    if (v === null)
      c._parentOrParents = this;
    else if (v instanceof a) {
      if (v === this)
        return c;
      c._parentOrParents = [v, this];
    } else if (v.indexOf(this) === -1)
      v.push(this);
    else
      return c;
    var p = this._subscriptions;
    return p === null ? this._subscriptions = [c] : p.push(c), c;
  }, a.prototype.remove = function(u) {
    var c = this._subscriptions;
    if (c) {
      var l = c.indexOf(u);
      l !== -1 && c.splice(l, 1);
    }
  }, a.EMPTY = function(u) {
    return u.closed = !0, u;
  }(new a()), a;
}();
function flattenUnsubscriptionErrors(a) {
  return a.reduce(function(u, c) {
    return u.concat(c instanceof UnsubscriptionError ? c.errors : c);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol == "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}(), Subscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this) || this;
    switch (p.syncErrorValue = null, p.syncErrorThrown = !1, p.syncErrorThrowable = !1, p.isStopped = !1, arguments.length) {
      case 0:
        p.destination = empty$3;
        break;
      case 1:
        if (!c) {
          p.destination = empty$3;
          break;
        }
        if (typeof c == "object") {
          c instanceof u ? (p.syncErrorThrowable = c.syncErrorThrowable, p.destination = c, c.add(p)) : (p.syncErrorThrowable = !0, p.destination = new SafeSubscriber(p, c));
          break;
        }
      default:
        p.syncErrorThrowable = !0, p.destination = new SafeSubscriber(p, c, l, v);
        break;
    }
    return p;
  }
  return u.prototype[rxSubscriber] = function() {
    return this;
  }, u.create = function(c, l, v) {
    var p = new u(c, l, v);
    return p.syncErrorThrowable = !1, p;
  }, u.prototype.next = function(c) {
    this.isStopped || this._next(c);
  }, u.prototype.error = function(c) {
    this.isStopped || (this.isStopped = !0, this._error(c));
  }, u.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, u.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, a.prototype.unsubscribe.call(this));
  }, u.prototype._next = function(c) {
    this.destination.next(c);
  }, u.prototype._error = function(c) {
    this.destination.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.destination.complete(), this.unsubscribe();
  }, u.prototype._unsubscribeAndRecycle = function() {
    var c = this._parentOrParents;
    return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = c, this;
  }, u;
}(Subscription), SafeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this) || this;
    _._parentSubscriber = c;
    var I, P = _;
    return isFunction$3(l) ? I = l : l && (I = l.next, v = l.error, p = l.complete, l !== empty$3 && (P = Object.create(l), isFunction$3(P.unsubscribe) && _.add(P.unsubscribe.bind(P)), P.unsubscribe = _.unsubscribe.bind(_))), _._context = P, _._next = I, _._error = v, _._complete = p, _;
  }
  return u.prototype.next = function(c) {
    if (!this.isStopped && this._next) {
      var l = this._parentSubscriber;
      !config$3.useDeprecatedSynchronousErrorHandling || !l.syncErrorThrowable ? this.__tryOrUnsub(this._next, c) : this.__tryOrSetError(l, this._next, c) && this.unsubscribe();
    }
  }, u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this._parentSubscriber, v = config$3.useDeprecatedSynchronousErrorHandling;
      if (this._error)
        !v || !l.syncErrorThrowable ? (this.__tryOrUnsub(this._error, c), this.unsubscribe()) : (this.__tryOrSetError(l, this._error, c), this.unsubscribe());
      else if (l.syncErrorThrowable)
        v ? (l.syncErrorValue = c, l.syncErrorThrown = !0) : hostReportError(c), this.unsubscribe();
      else {
        if (this.unsubscribe(), v)
          throw c;
        hostReportError(c);
      }
    }
  }, u.prototype.complete = function() {
    var c = this;
    if (!this.isStopped) {
      var l = this._parentSubscriber;
      if (this._complete) {
        var v = function() {
          return c._complete.call(c._context);
        };
        !config$3.useDeprecatedSynchronousErrorHandling || !l.syncErrorThrowable ? (this.__tryOrUnsub(v), this.unsubscribe()) : (this.__tryOrSetError(l, v), this.unsubscribe());
      } else
        this.unsubscribe();
    }
  }, u.prototype.__tryOrUnsub = function(c, l) {
    try {
      c.call(this._context, l);
    } catch (v) {
      if (this.unsubscribe(), config$3.useDeprecatedSynchronousErrorHandling)
        throw v;
      hostReportError(v);
    }
  }, u.prototype.__tryOrSetError = function(c, l, v) {
    if (!config$3.useDeprecatedSynchronousErrorHandling)
      throw new Error("bad call");
    try {
      l.call(this._context, v);
    } catch (p) {
      return config$3.useDeprecatedSynchronousErrorHandling ? (c.syncErrorValue = p, c.syncErrorThrown = !0, !0) : (hostReportError(p), !0);
    }
    return !1;
  }, u.prototype._unsubscribe = function() {
    var c = this._parentSubscriber;
    this._context = null, this._parentSubscriber = null, c.unsubscribe();
  }, u;
}(Subscriber);
function canReportError(a) {
  for (; a; ) {
    var u = a, c = u.closed, l = u.destination, v = u.isStopped;
    if (c || v)
      return !1;
    l && l instanceof Subscriber ? a = l : a = null;
  }
  return !0;
}
function toSubscriber(a, u, c) {
  if (a) {
    if (a instanceof Subscriber)
      return a;
    if (a[rxSubscriber])
      return a[rxSubscriber]();
  }
  return !a && !u && !c ? new Subscriber(empty$3) : new Subscriber(a, u, c);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function identity$1(a) {
  return a;
}
function pipe$2() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return pipeFromArray(a);
}
function pipeFromArray(a) {
  return a.length === 0 ? identity$1 : a.length === 1 ? a[0] : function(c) {
    return a.reduce(function(l, v) {
      return v(l);
    }, c);
  };
}
var Observable = /* @__PURE__ */ function() {
  function a(u) {
    this._isScalar = !1, u && (this._subscribe = u);
  }
  return a.prototype.lift = function(u) {
    var c = new a();
    return c.source = this, c.operator = u, c;
  }, a.prototype.subscribe = function(u, c, l) {
    var v = this.operator, p = toSubscriber(u, c, l);
    if (v ? p.add(v.call(p, this.source)) : p.add(this.source || config$3.useDeprecatedSynchronousErrorHandling && !p.syncErrorThrowable ? this._subscribe(p) : this._trySubscribe(p)), config$3.useDeprecatedSynchronousErrorHandling && p.syncErrorThrowable && (p.syncErrorThrowable = !1, p.syncErrorThrown))
      throw p.syncErrorValue;
    return p;
  }, a.prototype._trySubscribe = function(u) {
    try {
      return this._subscribe(u);
    } catch (c) {
      config$3.useDeprecatedSynchronousErrorHandling && (u.syncErrorThrown = !0, u.syncErrorValue = c), canReportError(u) ? u.error(c) : console.warn(c);
    }
  }, a.prototype.forEach = function(u, c) {
    var l = this;
    return c = getPromiseCtor(c), new c(function(v, p) {
      var _;
      _ = l.subscribe(function(I) {
        try {
          u(I);
        } catch (P) {
          p(P), _ && _.unsubscribe();
        }
      }, p, v);
    });
  }, a.prototype._subscribe = function(u) {
    var c = this.source;
    return c && c.subscribe(u);
  }, a.prototype[observable] = function() {
    return this;
  }, a.prototype.pipe = function() {
    for (var u = [], c = 0; c < arguments.length; c++)
      u[c] = arguments[c];
    return u.length === 0 ? this : pipeFromArray(u)(this);
  }, a.prototype.toPromise = function(u) {
    var c = this;
    return u = getPromiseCtor(u), new u(function(l, v) {
      var p;
      c.subscribe(function(_) {
        return p = _;
      }, function(_) {
        return v(_);
      }, function() {
        return l(p);
      });
    });
  }, a.create = function(u) {
    return new a(u);
  }, a;
}();
function getPromiseCtor(a) {
  if (a || (a = Promise), !a)
    throw new Error("no Promise impl found");
  return a;
}
var subscribeToArray = function(a) {
  return function(u) {
    for (var c = 0, l = a.length; c < l && !u.closed; c++)
      u.next(a[c]);
    u.complete();
  };
}, subscribeToPromise = function(a) {
  return function(u) {
    return a.then(function(c) {
      u.closed || (u.next(c), u.complete());
    }, function(c) {
      return u.error(c);
    }).then(null, hostReportError), u;
  };
};
function getSymbolIterator() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator(), subscribeToIterable = function(a) {
  return function(u) {
    var c = a[iterator]();
    do {
      var l = void 0;
      try {
        l = c.next();
      } catch (v) {
        return u.error(v), u;
      }
      if (l.done) {
        u.complete();
        break;
      }
      if (u.next(l.value), u.closed)
        break;
    } while (!0);
    return typeof c.return == "function" && u.add(function() {
      c.return && c.return();
    }), u;
  };
}, subscribeToObservable = function(a) {
  return function(u) {
    var c = a[observable]();
    if (typeof c.subscribe != "function")
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    return c.subscribe(u);
  };
}, isArrayLike$2 = function(a) {
  return a && typeof a.length == "number" && typeof a != "function";
};
function isPromise(a) {
  return !!a && typeof a.subscribe != "function" && typeof a.then == "function";
}
var subscribeTo = function(a) {
  if (a && typeof a[observable] == "function")
    return subscribeToObservable(a);
  if (isArrayLike$2(a))
    return subscribeToArray(a);
  if (isPromise(a))
    return subscribeToPromise(a);
  if (a && typeof a[iterator] == "function")
    return subscribeToIterable(a);
  var u = isObject$9(a) ? "an invalid object" : "'" + a + "'", c = "You provided " + u + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
  throw new TypeError(c);
}, SimpleInnerSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l.parent = c, l;
  }
  return u.prototype._next = function(c) {
    this.parent.notifyNext(c);
  }, u.prototype._error = function(c) {
    this.parent.notifyError(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.notifyComplete(), this.unsubscribe();
  }, u;
}(Subscriber), SimpleOuterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyError = function(c) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function() {
    this.destination.complete();
  }, u;
}(Subscriber);
function innerSubscribe(a, u) {
  if (!u.closed) {
    if (a instanceof Observable)
      return a.subscribe(u);
    var c;
    try {
      c = subscribeTo(a)(u);
    } catch (l) {
      u.error(l);
    }
    return c;
  }
}
function audit(a) {
  return function(c) {
    return c.lift(new AuditOperator(a));
  };
}
var AuditOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.durationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new AuditSubscriber(u, this.durationSelector));
  }, a;
}(), AuditSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.durationSelector = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    if (this.value = c, this.hasValue = !0, !this.throttled) {
      var l = void 0;
      try {
        var v = this.durationSelector;
        l = v(c);
      } catch (_) {
        return this.destination.error(_);
      }
      var p = innerSubscribe(l, new SimpleInnerSubscriber(this));
      !p || p.closed ? this.clearThrottle() : this.add(this.throttled = p);
    }
  }, u.prototype.clearThrottle = function() {
    var c = this, l = c.value, v = c.hasValue, p = c.throttled;
    p && (this.remove(p), this.throttled = void 0, p.unsubscribe()), v && (this.value = void 0, this.hasValue = !1, this.destination.next(l));
  }, u.prototype.notifyNext = function() {
    this.clearThrottle();
  }, u.prototype.notifyComplete = function() {
    this.clearThrottle();
  }, u;
}(SimpleOuterSubscriber), Action = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    return a.call(this) || this;
  }
  return u.prototype.schedule = function(c, l) {
    return this;
  }, u;
}(Subscription), AsyncAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v.pending = !1, v;
  }
  return u.prototype.schedule = function(c, l) {
    if (l === void 0 && (l = 0), this.closed)
      return this;
    this.state = c;
    var v = this.id, p = this.scheduler;
    return v != null && (this.id = this.recycleAsyncId(p, v, l)), this.pending = !0, this.delay = l, this.id = this.id || this.requestAsyncId(p, this.id, l), this;
  }, u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), setInterval(c.flush.bind(c, this), v);
  }, u.prototype.recycleAsyncId = function(c, l, v) {
    if (v === void 0 && (v = 0), v !== null && this.delay === v && this.pending === !1)
      return l;
    clearInterval(l);
  }, u.prototype.execute = function(c, l) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var v = this._execute(c, l);
    if (v)
      return v;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, u.prototype._execute = function(c, l) {
    var v = !1, p = void 0;
    try {
      this.work(c);
    } catch (_) {
      v = !0, p = !!_ && _ || new Error(_);
    }
    if (v)
      return this.unsubscribe(), p;
  }, u.prototype._unsubscribe = function() {
    var c = this.id, l = this.scheduler, v = l.actions, p = v.indexOf(this);
    this.work = null, this.state = null, this.pending = !1, this.scheduler = null, p !== -1 && v.splice(p, 1), c != null && (this.id = this.recycleAsyncId(l, c, null)), this.delay = null;
  }, u;
}(Action), Scheduler = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = a.now), this.SchedulerAction = u, this.now = c;
  }
  return a.prototype.schedule = function(u, c, l) {
    return c === void 0 && (c = 0), new this.SchedulerAction(this, u).schedule(l, c);
  }, a.now = function() {
    return Date.now();
  }, a;
}(), AsyncScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    l === void 0 && (l = Scheduler.now);
    var v = a.call(this, c, function() {
      return u.delegate && u.delegate !== v ? u.delegate.now() : l();
    }) || this;
    return v.actions = [], v.active = !1, v.scheduled = void 0, v;
  }
  return u.prototype.schedule = function(c, l, v) {
    return l === void 0 && (l = 0), u.delegate && u.delegate !== this ? u.delegate.schedule(c, l, v) : a.prototype.schedule.call(this, c, l, v);
  }, u.prototype.flush = function(c) {
    var l = this.actions;
    if (this.active) {
      l.push(c);
      return;
    }
    var v;
    this.active = !0;
    do
      if (v = c.execute(c.state, c.delay))
        break;
    while (c = l.shift());
    if (this.active = !1, v) {
      for (; c = l.shift(); )
        c.unsubscribe();
      throw v;
    }
  }, u;
}(Scheduler), asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction), async$1 = asyncScheduler;
function isNumeric(a) {
  return !isArray$5(a) && a - parseFloat(a) + 1 >= 0;
}
function isScheduler(a) {
  return a && typeof a.schedule == "function";
}
function timer(a, u, c) {
  a === void 0 && (a = 0);
  var l = -1;
  return isNumeric(u) ? l = Number(u) < 1 && 1 || Number(u) : isScheduler(u) && (c = u), isScheduler(c) || (c = async$1), new Observable(function(v) {
    var p = isNumeric(a) ? a : +a - c.now();
    return c.schedule(dispatch$1, p, {
      index: 0,
      period: l,
      subscriber: v
    });
  });
}
function dispatch$1(a) {
  var u = a.index, c = a.period, l = a.subscriber;
  if (l.next(u), !l.closed) {
    if (c === -1)
      return l.complete();
    a.index = u + 1, this.schedule(a, c);
  }
}
function auditTime(a, u) {
  return u === void 0 && (u = async$1), audit(function() {
    return timer(a, u);
  });
}
function buffer$2(a) {
  return function(c) {
    return c.lift(new BufferOperator(a));
  };
}
var BufferOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingNotifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferSubscriber(u, this.closingNotifier));
  }, a;
}(), BufferSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.buffer = [], v.add(innerSubscribe(l, new SimpleInnerSubscriber(v))), v;
  }
  return u.prototype._next = function(c) {
    this.buffer.push(c);
  }, u.prototype.notifyNext = function() {
    var c = this.buffer;
    this.buffer = [], this.destination.next(c);
  }, u;
}(SimpleOuterSubscriber);
function bufferCount(a, u) {
  return u === void 0 && (u = null), function(l) {
    return l.lift(new BufferCountOperator(a, u));
  };
}
var BufferCountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.bufferSize = u, this.startBufferEvery = c, !c || u === c ? this.subscriberClass = BufferCountSubscriber : this.subscriberClass = BufferSkipCountSubscriber;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new this.subscriberClass(u, this.bufferSize, this.startBufferEvery));
  }, a;
}(), BufferCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.bufferSize = l, v.buffer = [], v;
  }
  return u.prototype._next = function(c) {
    var l = this.buffer;
    l.push(c), l.length == this.bufferSize && (this.destination.next(l), this.buffer = []);
  }, u.prototype._complete = function() {
    var c = this.buffer;
    c.length > 0 && this.destination.next(c), a.prototype._complete.call(this);
  }, u;
}(Subscriber), BufferSkipCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.bufferSize = l, p.startBufferEvery = v, p.buffers = [], p.count = 0, p;
  }
  return u.prototype._next = function(c) {
    var l = this, v = l.bufferSize, p = l.startBufferEvery, _ = l.buffers, I = l.count;
    this.count++, I % p === 0 && _.push([]);
    for (var P = _.length; P--; ) {
      var $ = _[P];
      $.push(c), $.length === v && (_.splice(P, 1), this.destination.next($));
    }
  }, u.prototype._complete = function() {
    for (var c = this, l = c.buffers, v = c.destination; l.length > 0; ) {
      var p = l.shift();
      p.length > 0 && v.next(p);
    }
    a.prototype._complete.call(this);
  }, u;
}(Subscriber);
function bufferTime(a) {
  var u = arguments.length, c = async$1;
  isScheduler(arguments[arguments.length - 1]) && (c = arguments[arguments.length - 1], u--);
  var l = null;
  u >= 2 && (l = arguments[1]);
  var v = Number.POSITIVE_INFINITY;
  return u >= 3 && (v = arguments[2]), function(_) {
    return _.lift(new BufferTimeOperator(a, l, v, c));
  };
}
var BufferTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.bufferTimeSpan = u, this.bufferCreationInterval = c, this.maxBufferSize = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferTimeSubscriber(u, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  }, a;
}(), Context = /* @__PURE__ */ function() {
  function a() {
    this.buffer = [];
  }
  return a;
}(), BufferTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var I = a.call(this, c) || this;
    I.bufferTimeSpan = l, I.bufferCreationInterval = v, I.maxBufferSize = p, I.scheduler = _, I.contexts = [];
    var P = I.openContext();
    if (I.timespanOnly = v == null || v < 0, I.timespanOnly) {
      var $ = { subscriber: I, context: P, bufferTimeSpan: l };
      I.add(P.closeAction = _.schedule(dispatchBufferTimeSpanOnly, l, $));
    } else {
      var F = { subscriber: I, context: P }, H = { bufferTimeSpan: l, bufferCreationInterval: v, subscriber: I, scheduler: _ };
      I.add(P.closeAction = _.schedule(dispatchBufferClose, l, F)), I.add(_.schedule(dispatchBufferCreation, v, H));
    }
    return I;
  }
  return u.prototype._next = function(c) {
    for (var l = this.contexts, v = l.length, p, _ = 0; _ < v; _++) {
      var I = l[_], P = I.buffer;
      P.push(c), P.length == this.maxBufferSize && (p = I);
    }
    p && this.onBufferFull(p);
  }, u.prototype._error = function(c) {
    this.contexts.length = 0, a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    for (var c = this, l = c.contexts, v = c.destination; l.length > 0; ) {
      var p = l.shift();
      v.next(p.buffer);
    }
    a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    this.contexts = null;
  }, u.prototype.onBufferFull = function(c) {
    this.closeContext(c);
    var l = c.closeAction;
    if (l.unsubscribe(), this.remove(l), !this.closed && this.timespanOnly) {
      c = this.openContext();
      var v = this.bufferTimeSpan, p = { subscriber: this, context: c, bufferTimeSpan: v };
      this.add(c.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, v, p));
    }
  }, u.prototype.openContext = function() {
    var c = new Context();
    return this.contexts.push(c), c;
  }, u.prototype.closeContext = function(c) {
    this.destination.next(c.buffer);
    var l = this.contexts, v = l ? l.indexOf(c) : -1;
    v >= 0 && l.splice(l.indexOf(c), 1);
  }, u;
}(Subscriber);
function dispatchBufferTimeSpanOnly(a) {
  var u = a.subscriber, c = a.context;
  c && u.closeContext(c), u.closed || (a.context = u.openContext(), a.context.closeAction = this.schedule(a, a.bufferTimeSpan));
}
function dispatchBufferCreation(a) {
  var u = a.bufferCreationInterval, c = a.bufferTimeSpan, l = a.subscriber, v = a.scheduler, p = l.openContext(), _ = this;
  l.closed || (l.add(p.closeAction = v.schedule(dispatchBufferClose, c, { subscriber: l, context: p })), _.schedule(a, u));
}
function dispatchBufferClose(a) {
  var u = a.subscriber, c = a.context;
  u.closeContext(c);
}
var InnerSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this) || this;
    return p.parent = c, p.outerValue = l, p.outerIndex = v, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    this.parent.notifyNext(this.outerValue, c, this.outerIndex, this.index++, this);
  }, u.prototype._error = function(c) {
    this.parent.notifyError(c, this), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.notifyComplete(this), this.unsubscribe();
  }, u;
}(Subscriber);
function subscribeToResult(a, u, c, l, v) {
  if (v === void 0 && (v = new InnerSubscriber(a, c, l)), !v.closed)
    return u instanceof Observable ? u.subscribe(v) : subscribeTo(u)(v);
}
var OuterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.notifyNext = function(c, l, v, p, _) {
    this.destination.next(l);
  }, u.prototype.notifyError = function(c, l) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function(c) {
    this.destination.complete();
  }, u;
}(Subscriber);
function bufferToggle(a, u) {
  return function(l) {
    return l.lift(new BufferToggleOperator(a, u));
  };
}
var BufferToggleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.openings = u, this.closingSelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferToggleSubscriber(u, this.openings, this.closingSelector));
  }, a;
}(), BufferToggleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.closingSelector = v, p.contexts = [], p.add(subscribeToResult(p, l)), p;
  }
  return u.prototype._next = function(c) {
    for (var l = this.contexts, v = l.length, p = 0; p < v; p++)
      l[p].buffer.push(c);
  }, u.prototype._error = function(c) {
    for (var l = this.contexts; l.length > 0; ) {
      var v = l.shift();
      v.subscription.unsubscribe(), v.buffer = null, v.subscription = null;
    }
    this.contexts = null, a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    for (var c = this.contexts; c.length > 0; ) {
      var l = c.shift();
      this.destination.next(l.buffer), l.subscription.unsubscribe(), l.buffer = null, l.subscription = null;
    }
    this.contexts = null, a.prototype._complete.call(this);
  }, u.prototype.notifyNext = function(c, l) {
    c ? this.closeBuffer(c) : this.openBuffer(l);
  }, u.prototype.notifyComplete = function(c) {
    this.closeBuffer(c.context);
  }, u.prototype.openBuffer = function(c) {
    try {
      var l = this.closingSelector, v = l.call(this, c);
      v && this.trySubscribe(v);
    } catch (p) {
      this._error(p);
    }
  }, u.prototype.closeBuffer = function(c) {
    var l = this.contexts;
    if (l && c) {
      var v = c.buffer, p = c.subscription;
      this.destination.next(v), l.splice(l.indexOf(c), 1), this.remove(p), p.unsubscribe();
    }
  }, u.prototype.trySubscribe = function(c) {
    var l = this.contexts, v = [], p = new Subscription(), _ = { buffer: v, subscription: p };
    l.push(_);
    var I = subscribeToResult(this, c, _);
    !I || I.closed ? this.closeBuffer(_) : (I.context = _, this.add(I), p.add(I));
  }, u;
}(OuterSubscriber);
function bufferWhen(a) {
  return function(u) {
    return u.lift(new BufferWhenOperator(a));
  };
}
var BufferWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferWhenSubscriber(u, this.closingSelector));
  }, a;
}(), BufferWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.closingSelector = l, v.subscribing = !1, v.openBuffer(), v;
  }
  return u.prototype._next = function(c) {
    this.buffer.push(c);
  }, u.prototype._complete = function() {
    var c = this.buffer;
    c && this.destination.next(c), a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    this.buffer = void 0, this.subscribing = !1;
  }, u.prototype.notifyNext = function() {
    this.openBuffer();
  }, u.prototype.notifyComplete = function() {
    this.subscribing ? this.complete() : this.openBuffer();
  }, u.prototype.openBuffer = function() {
    var c = this.closingSubscription;
    c && (this.remove(c), c.unsubscribe());
    var l = this.buffer;
    this.buffer && this.destination.next(l), this.buffer = [];
    var v;
    try {
      var p = this.closingSelector;
      v = p();
    } catch (_) {
      return this.error(_);
    }
    c = new Subscription(), this.closingSubscription = c, this.add(c), this.subscribing = !0, c.add(innerSubscribe(v, new SimpleInnerSubscriber(this))), this.subscribing = !1;
  }, u;
}(SimpleOuterSubscriber);
function catchError(a) {
  return function(c) {
    var l = new CatchOperator(a), v = c.lift(l);
    return l.caught = v;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.selector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CatchSubscriber(u, this.selector, this.caught));
  }, a;
}(), CatchSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.selector = l, p.caught = v, p;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = void 0;
      try {
        l = this.selector(c, this.caught);
      } catch (_) {
        a.prototype.error.call(this, _);
        return;
      }
      this._unsubscribeAndRecycle();
      var v = new SimpleInnerSubscriber(this);
      this.add(v);
      var p = innerSubscribe(l, v);
      p !== v && this.add(p);
    }
  }, u;
}(SimpleOuterSubscriber);
function scheduleArray(a, u) {
  return new Observable(function(c) {
    var l = new Subscription(), v = 0;
    return l.add(u.schedule(function() {
      if (v === a.length) {
        c.complete();
        return;
      }
      c.next(a[v++]), c.closed || l.add(this.schedule());
    })), l;
  });
}
function fromArray$1(a, u) {
  return u ? scheduleArray(a, u) : new Observable(subscribeToArray(a));
}
var NONE = {}, CombineLatestOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.resultSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CombineLatestSubscriber(u, this.resultSelector));
  }, a;
}(), CombineLatestSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.resultSelector = l, v.active = 0, v.values = [], v.observables = [], v;
  }
  return u.prototype._next = function(c) {
    this.values.push(NONE), this.observables.push(c);
  }, u.prototype._complete = function() {
    var c = this.observables, l = c.length;
    if (l === 0)
      this.destination.complete();
    else {
      this.active = l, this.toRespond = l;
      for (var v = 0; v < l; v++) {
        var p = c[v];
        this.add(subscribeToResult(this, p, void 0, v));
      }
    }
  }, u.prototype.notifyComplete = function(c) {
    (this.active -= 1) === 0 && this.destination.complete();
  }, u.prototype.notifyNext = function(c, l, v) {
    var p = this.values, _ = p[v], I = this.toRespond ? _ === NONE ? --this.toRespond : this.toRespond : 0;
    p[v] = l, I === 0 && (this.resultSelector ? this._tryResultSelector(p) : this.destination.next(p.slice()));
  }, u.prototype._tryResultSelector = function(c) {
    var l;
    try {
      l = this.resultSelector.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function combineAll(a) {
  return function(u) {
    return u.lift(new CombineLatestOperator(a));
  };
}
function scheduleObservable(a, u) {
  return new Observable(function(c) {
    var l = new Subscription();
    return l.add(u.schedule(function() {
      var v = a[observable]();
      l.add(v.subscribe({
        next: function(p) {
          l.add(u.schedule(function() {
            return c.next(p);
          }));
        },
        error: function(p) {
          l.add(u.schedule(function() {
            return c.error(p);
          }));
        },
        complete: function() {
          l.add(u.schedule(function() {
            return c.complete();
          }));
        }
      }));
    })), l;
  });
}
function schedulePromise(a, u) {
  return new Observable(function(c) {
    var l = new Subscription();
    return l.add(u.schedule(function() {
      return a.then(function(v) {
        l.add(u.schedule(function() {
          c.next(v), l.add(u.schedule(function() {
            return c.complete();
          }));
        }));
      }, function(v) {
        l.add(u.schedule(function() {
          return c.error(v);
        }));
      });
    })), l;
  });
}
function scheduleIterable(a, u) {
  if (!a)
    throw new Error("Iterable cannot be null");
  return new Observable(function(c) {
    var l = new Subscription(), v;
    return l.add(function() {
      v && typeof v.return == "function" && v.return();
    }), l.add(u.schedule(function() {
      v = a[iterator](), l.add(u.schedule(function() {
        if (!c.closed) {
          var p, _;
          try {
            var I = v.next();
            p = I.value, _ = I.done;
          } catch (P) {
            c.error(P);
            return;
          }
          _ ? c.complete() : (c.next(p), this.schedule());
        }
      }));
    })), l;
  });
}
function isInteropObservable(a) {
  return a && typeof a[observable] == "function";
}
function isIterable(a) {
  return a && typeof a[iterator] == "function";
}
function scheduled(a, u) {
  if (a != null) {
    if (isInteropObservable(a))
      return scheduleObservable(a, u);
    if (isPromise(a))
      return schedulePromise(a, u);
    if (isArrayLike$2(a))
      return scheduleArray(a, u);
    if (isIterable(a) || typeof a == "string")
      return scheduleIterable(a, u);
  }
  throw new TypeError((a !== null && typeof a || a) + " is not observable");
}
function from(a, u) {
  return u ? scheduled(a, u) : a instanceof Observable ? a : new Observable(subscribeTo(a));
}
function combineLatest() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = null;
  return typeof a[a.length - 1] == "function" && (c = a.pop()), a.length === 1 && isArray$5(a[0]) && (a = a[0].slice()), function(l) {
    return l.lift.call(from([l].concat(a)), new CombineLatestOperator(c));
  };
}
function of$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return isScheduler(c) ? (a.pop(), scheduleArray(a, c)) : fromArray$1(a);
}
function map(a, u) {
  return function(l) {
    if (typeof a != "function")
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    return l.lift(new MapOperator(a, u));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.project = u, this.thisArg = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MapSubscriber(u, this.project, this.thisArg));
  }, a;
}(), MapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.project = l, p.count = 0, p.thisArg = v || p, p;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.project.call(this.thisArg, c, this.count++);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(Subscriber);
function mergeMap(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), typeof u == "function" ? function(l) {
    return l.pipe(mergeMap(function(v, p) {
      return from(a(v, p)).pipe(map(function(_, I) {
        return u(v, _, p, I);
      }));
    }, c));
  } : (typeof u == "number" && (c = u), function(l) {
    return l.lift(new MergeMapOperator(a, c));
  });
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = Number.POSITIVE_INFINITY), this.project = u, this.concurrent = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MergeMapSubscriber(u, this.project, this.concurrent));
  }, a;
}(), MergeMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    v === void 0 && (v = Number.POSITIVE_INFINITY);
    var p = a.call(this, c) || this;
    return p.project = l, p.concurrent = v, p.hasCompleted = !1, p.buffer = [], p.active = 0, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    this.active < this.concurrent ? this._tryNext(c) : this.buffer.push(c);
  }, u.prototype._tryNext = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (p) {
      this.destination.error(p);
      return;
    }
    this.active++, this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var p = innerSubscribe(c, l);
    p !== l && v.add(p);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c.length > 0 ? this._next(c.shift()) : this.active === 0 && this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber), flatMap = mergeMap;
function mergeAll(a) {
  return a === void 0 && (a = Number.POSITIVE_INFINITY), mergeMap(identity$1, a);
}
function concatAll() {
  return mergeAll(1);
}
function concat$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return concatAll()(of$1.apply(void 0, a));
}
function concat() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return c.lift.call(concat$1.apply(void 0, [c].concat(a)));
  };
}
function concatMap(a, u) {
  return mergeMap(a, u, 1);
}
function concatMapTo(a, u) {
  return concatMap(function() {
    return a;
  }, u);
}
function count(a) {
  return function(u) {
    return u.lift(new CountOperator(a, u));
  };
}
var CountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CountSubscriber(u, this.predicate, this.source));
  }, a;
}(), CountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.source = v, p.count = 0, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    this.predicate ? this._tryPredicate(c) : this.count++;
  }, u.prototype._tryPredicate = function(c) {
    var l;
    try {
      l = this.predicate(c, this.index++, this.source);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l && this.count++;
  }, u.prototype._complete = function() {
    this.destination.next(this.count), this.destination.complete();
  }, u;
}(Subscriber);
function debounce$1(a) {
  return function(u) {
    return u.lift(new DebounceOperator(a));
  };
}
var DebounceOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.durationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DebounceSubscriber(u, this.durationSelector));
  }, a;
}(), DebounceSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.durationSelector = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    try {
      var l = this.durationSelector.call(this, c);
      l && this._tryNext(c, l);
    } catch (v) {
      this.destination.error(v);
    }
  }, u.prototype._complete = function() {
    this.emitValue(), this.destination.complete();
  }, u.prototype._tryNext = function(c, l) {
    var v = this.durationSubscription;
    this.value = c, this.hasValue = !0, v && (v.unsubscribe(), this.remove(v)), v = innerSubscribe(l, new SimpleInnerSubscriber(this)), v && !v.closed && this.add(this.durationSubscription = v);
  }, u.prototype.notifyNext = function() {
    this.emitValue();
  }, u.prototype.notifyComplete = function() {
    this.emitValue();
  }, u.prototype.emitValue = function() {
    if (this.hasValue) {
      var c = this.value, l = this.durationSubscription;
      l && (this.durationSubscription = void 0, l.unsubscribe(), this.remove(l)), this.value = void 0, this.hasValue = !1, a.prototype._next.call(this, c);
    }
  }, u;
}(SimpleOuterSubscriber);
function debounceTime(a, u) {
  return u === void 0 && (u = async$1), function(c) {
    return c.lift(new DebounceTimeOperator(a, u));
  };
}
var DebounceTimeOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.dueTime = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DebounceTimeSubscriber(u, this.dueTime, this.scheduler));
  }, a;
}(), DebounceTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.dueTime = l, p.scheduler = v, p.debouncedSubscription = null, p.lastValue = null, p.hasValue = !1, p;
  }
  return u.prototype._next = function(c) {
    this.clearDebounce(), this.lastValue = c, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
  }, u.prototype._complete = function() {
    this.debouncedNext(), this.destination.complete();
  }, u.prototype.debouncedNext = function() {
    if (this.clearDebounce(), this.hasValue) {
      var c = this.lastValue;
      this.lastValue = null, this.hasValue = !1, this.destination.next(c);
    }
  }, u.prototype.clearDebounce = function() {
    var c = this.debouncedSubscription;
    c !== null && (this.remove(c), c.unsubscribe(), this.debouncedSubscription = null);
  }, u;
}(Subscriber);
function dispatchNext$1(a) {
  a.debouncedNext();
}
function defaultIfEmpty(a) {
  return a === void 0 && (a = null), function(u) {
    return u.lift(new DefaultIfEmptyOperator(a));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.defaultValue = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DefaultIfEmptySubscriber(u, this.defaultValue));
  }, a;
}(), DefaultIfEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.defaultValue = l, v.isEmpty = !0, v;
  }
  return u.prototype._next = function(c) {
    this.isEmpty = !1, this.destination.next(c);
  }, u.prototype._complete = function() {
    this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete();
  }, u;
}(Subscriber);
function isDate$1(a) {
  return a instanceof Date && !isNaN(+a);
}
var EMPTY = /* @__PURE__ */ new Observable(function(a) {
  return a.complete();
});
function empty$2(a) {
  return a ? emptyScheduled(a) : EMPTY;
}
function emptyScheduled(a) {
  return new Observable(function(u) {
    return a.schedule(function() {
      return u.complete();
    });
  });
}
function throwError(a, u) {
  return u ? new Observable(function(c) {
    return u.schedule(dispatch, 0, { error: a, subscriber: c });
  }) : new Observable(function(c) {
    return c.error(a);
  });
}
function dispatch(a) {
  var u = a.error, c = a.subscriber;
  c.error(u);
}
var Notification = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.kind = u, this.value = c, this.error = l, this.hasValue = u === "N";
  }
  return a.prototype.observe = function(u) {
    switch (this.kind) {
      case "N":
        return u.next && u.next(this.value);
      case "E":
        return u.error && u.error(this.error);
      case "C":
        return u.complete && u.complete();
    }
  }, a.prototype.do = function(u, c, l) {
    var v = this.kind;
    switch (v) {
      case "N":
        return u && u(this.value);
      case "E":
        return c && c(this.error);
      case "C":
        return l && l();
    }
  }, a.prototype.accept = function(u, c, l) {
    return u && typeof u.next == "function" ? this.observe(u) : this.do(u, c, l);
  }, a.prototype.toObservable = function() {
    var u = this.kind;
    switch (u) {
      case "N":
        return of$1(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty$2();
    }
    throw new Error("unexpected notification kind value");
  }, a.createNext = function(u) {
    return typeof u < "u" ? new a("N", u) : a.undefinedValueNotification;
  }, a.createError = function(u) {
    return new a("E", void 0, u);
  }, a.createComplete = function() {
    return a.completeNotification;
  }, a.completeNotification = new a("C"), a.undefinedValueNotification = new a("N", void 0), a;
}();
function delay(a, u) {
  u === void 0 && (u = async$1);
  var c = isDate$1(a), l = c ? +a - u.now() : Math.abs(a);
  return function(v) {
    return v.lift(new DelayOperator(l, u));
  };
}
var DelayOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.delay = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DelaySubscriber(u, this.delay, this.scheduler));
  }, a;
}(), DelaySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.delay = l, p.scheduler = v, p.queue = [], p.active = !1, p.errored = !1, p;
  }
  return u.dispatch = function(c) {
    for (var l = c.source, v = l.queue, p = c.scheduler, _ = c.destination; v.length > 0 && v[0].time - p.now() <= 0; )
      v.shift().notification.observe(_);
    if (v.length > 0) {
      var I = Math.max(0, v[0].time - p.now());
      this.schedule(c, I);
    } else
      this.unsubscribe(), l.active = !1;
  }, u.prototype._schedule = function(c) {
    this.active = !0;
    var l = this.destination;
    l.add(c.schedule(u.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler: c
    }));
  }, u.prototype.scheduleNotification = function(c) {
    if (this.errored !== !0) {
      var l = this.scheduler, v = new DelayMessage(l.now() + this.delay, c);
      this.queue.push(v), this.active === !1 && this._schedule(l);
    }
  }, u.prototype._next = function(c) {
    this.scheduleNotification(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    this.errored = !0, this.queue = [], this.destination.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.scheduleNotification(Notification.createComplete()), this.unsubscribe();
  }, u;
}(Subscriber), DelayMessage = /* @__PURE__ */ function() {
  function a(u, c) {
    this.time = u, this.notification = c;
  }
  return a;
}();
function delayWhen(a, u) {
  return u ? function(c) {
    return new SubscriptionDelayObservable(c, u).lift(new DelayWhenOperator(a));
  } : function(c) {
    return c.lift(new DelayWhenOperator(a));
  };
}
var DelayWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.delayDurationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DelayWhenSubscriber(u, this.delayDurationSelector));
  }, a;
}(), DelayWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.delayDurationSelector = l, v.completed = !1, v.delayNotifierSubscriptions = [], v.index = 0, v;
  }
  return u.prototype.notifyNext = function(c, l, v, p, _) {
    this.destination.next(c), this.removeSubscription(_), this.tryComplete();
  }, u.prototype.notifyError = function(c, l) {
    this._error(c);
  }, u.prototype.notifyComplete = function(c) {
    var l = this.removeSubscription(c);
    l && this.destination.next(l), this.tryComplete();
  }, u.prototype._next = function(c) {
    var l = this.index++;
    try {
      var v = this.delayDurationSelector(c, l);
      v && this.tryDelay(v, c);
    } catch (p) {
      this.destination.error(p);
    }
  }, u.prototype._complete = function() {
    this.completed = !0, this.tryComplete(), this.unsubscribe();
  }, u.prototype.removeSubscription = function(c) {
    c.unsubscribe();
    var l = this.delayNotifierSubscriptions.indexOf(c);
    return l !== -1 && this.delayNotifierSubscriptions.splice(l, 1), c.outerValue;
  }, u.prototype.tryDelay = function(c, l) {
    var v = subscribeToResult(this, c, l);
    if (v && !v.closed) {
      var p = this.destination;
      p.add(v), this.delayNotifierSubscriptions.push(v);
    }
  }, u.prototype.tryComplete = function() {
    this.completed && this.delayNotifierSubscriptions.length === 0 && this.destination.complete();
  }, u;
}(OuterSubscriber), SubscriptionDelayObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.source = c, v.subscriptionDelay = l, v;
  }
  return u.prototype._subscribe = function(c) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(c, this.source));
  }, u;
}(Observable), SubscriptionDelaySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.parent = c, v.source = l, v.sourceSubscribed = !1, v;
  }
  return u.prototype._next = function(c) {
    this.subscribeToSource();
  }, u.prototype._error = function(c) {
    this.unsubscribe(), this.parent.error(c);
  }, u.prototype._complete = function() {
    this.unsubscribe(), this.subscribeToSource();
  }, u.prototype.subscribeToSource = function() {
    this.sourceSubscribed || (this.sourceSubscribed = !0, this.unsubscribe(), this.source.subscribe(this.parent));
  }, u;
}(Subscriber);
function dematerialize() {
  return function(u) {
    return u.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DeMaterializeSubscriber(u));
  }, a;
}(), DeMaterializeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype._next = function(c) {
    c.observe(this.destination);
  }, u;
}(Subscriber);
function distinct(a, u) {
  return function(c) {
    return c.lift(new DistinctOperator(a, u));
  };
}
var DistinctOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.keySelector = u, this.flushes = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DistinctSubscriber(u, this.keySelector, this.flushes));
  }, a;
}(), DistinctSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.keySelector = l, p.values = /* @__PURE__ */ new Set(), v && p.add(innerSubscribe(v, new SimpleInnerSubscriber(p))), p;
  }
  return u.prototype.notifyNext = function() {
    this.values.clear();
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype._next = function(c) {
    this.keySelector ? this._useKeySelector(c) : this._finalizeNext(c, c);
  }, u.prototype._useKeySelector = function(c) {
    var l, v = this.destination;
    try {
      l = this.keySelector(c);
    } catch (p) {
      v.error(p);
      return;
    }
    this._finalizeNext(l, c);
  }, u.prototype._finalizeNext = function(c, l) {
    var v = this.values;
    v.has(c) || (v.add(c), this.destination.next(l));
  }, u;
}(SimpleOuterSubscriber);
function distinctUntilChanged(a, u) {
  return function(c) {
    return c.lift(new DistinctUntilChangedOperator(a, u));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.compare = u, this.keySelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DistinctUntilChangedSubscriber(u, this.compare, this.keySelector));
  }, a;
}(), DistinctUntilChangedSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.keySelector = v, p.hasKey = !1, typeof l == "function" && (p.compare = l), p;
  }
  return u.prototype.compare = function(c, l) {
    return c === l;
  }, u.prototype._next = function(c) {
    var l;
    try {
      var v = this.keySelector;
      l = v ? v(c) : c;
    } catch (I) {
      return this.destination.error(I);
    }
    var p = !1;
    if (this.hasKey)
      try {
        var _ = this.compare;
        p = _(this.key, l);
      } catch (I) {
        return this.destination.error(I);
      }
    else
      this.hasKey = !0;
    p || (this.key = l, this.destination.next(c));
  }, u;
}(Subscriber);
function distinctUntilKeyChanged(a, u) {
  return distinctUntilChanged(function(c, l) {
    return u ? u(c[a], l[a]) : c[a] === l[a];
  });
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
function filter(a, u) {
  return function(l) {
    return l.lift(new FilterOperator(a, u));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.thisArg = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FilterSubscriber(u, this.predicate, this.thisArg));
  }, a;
}(), FilterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.thisArg = v, p.count = 0, p;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.predicate.call(this.thisArg, c, this.count++);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l && this.destination.next(c);
  }, u;
}(Subscriber), EmptyErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), EmptyError = EmptyErrorImpl;
function throwIfEmpty(a) {
  return a === void 0 && (a = defaultErrorFactory), function(u) {
    return u.lift(new ThrowIfEmptyOperator(a));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.errorFactory = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrowIfEmptySubscriber(u, this.errorFactory));
  }, a;
}(), ThrowIfEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.errorFactory = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    this.hasValue = !0, this.destination.next(c);
  }, u.prototype._complete = function() {
    if (this.hasValue)
      return this.destination.complete();
    var c = void 0;
    try {
      c = this.errorFactory();
    } catch (l) {
      c = l;
    }
    this.destination.error(c);
  }, u;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take(a) {
  return function(u) {
    return a === 0 ? empty$2() : u.lift(new TakeOperator(a));
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this.total = u, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeSubscriber(u, this.total));
  }, a;
}(), TakeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.total, v = ++this.count;
    v <= l && (this.destination.next(c), v === l && (this.destination.complete(), this.unsubscribe()));
  }, u;
}(Subscriber);
function elementAt(a, u) {
  if (a < 0)
    throw new ArgumentOutOfRangeError();
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(filter(function(v, p) {
      return p === a;
    }), take(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
function endWith() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return concat$1(c, of$1.apply(void 0, a));
  };
}
function every$1(a, u) {
  return function(c) {
    return c.lift(new EveryOperator(a, u, c));
  };
}
var EveryOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.predicate = u, this.thisArg = c, this.source = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new EverySubscriber(u, this.predicate, this.thisArg, this.source));
  }, a;
}(), EverySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.predicate = l, _.thisArg = v, _.source = p, _.index = 0, _.thisArg = v || _, _;
  }
  return u.prototype.notifyComplete = function(c) {
    this.destination.next(c), this.destination.complete();
  }, u.prototype._next = function(c) {
    var l = !1;
    try {
      l = this.predicate.call(this.thisArg, c, this.index++, this.source);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l || this.notifyComplete(!1);
  }, u.prototype._complete = function() {
    this.notifyComplete(!0);
  }, u;
}(Subscriber);
function exhaust() {
  return function(a) {
    return a.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SwitchFirstSubscriber(u));
  }, a;
}(), SwitchFirstSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasCompleted = !1, l.hasSubscription = !1, l;
  }
  return u.prototype._next = function(c) {
    this.hasSubscription || (this.hasSubscription = !0, this.add(innerSubscribe(c, new SimpleInnerSubscriber(this))));
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete();
  }, u.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function exhaustMap(a, u) {
  return u ? function(c) {
    return c.pipe(exhaustMap(function(l, v) {
      return from(a(l, v)).pipe(map(function(p, _) {
        return u(l, p, v, _);
      }));
    }));
  } : function(c) {
    return c.lift(new ExhaustMapOperator(a));
  };
}
var ExhaustMapOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.project = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ExhaustMapSubscriber(u, this.project));
  }, a;
}(), ExhaustMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.project = l, v.hasSubscription = !1, v.hasCompleted = !1, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    this.hasSubscription || this.tryNext(c);
  }, u.prototype.tryNext = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (p) {
      this.destination.error(p);
      return;
    }
    this.hasSubscription = !0, this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var p = innerSubscribe(c, l);
    p !== l && v.add(p);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyError = function(c) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function expand(a, u, c) {
  return u === void 0 && (u = Number.POSITIVE_INFINITY), u = (u || 0) < 1 ? Number.POSITIVE_INFINITY : u, function(l) {
    return l.lift(new ExpandOperator(a, u, c));
  };
}
var ExpandOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.project = u, this.concurrent = c, this.scheduler = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ExpandSubscriber(u, this.project, this.concurrent, this.scheduler));
  }, a;
}(), ExpandSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.project = l, _.concurrent = v, _.scheduler = p, _.index = 0, _.active = 0, _.hasCompleted = !1, v < Number.POSITIVE_INFINITY && (_.buffer = []), _;
  }
  return u.dispatch = function(c) {
    var l = c.subscriber, v = c.result, p = c.value, _ = c.index;
    l.subscribeToProjection(v, p, _);
  }, u.prototype._next = function(c) {
    var l = this.destination;
    if (l.closed) {
      this._complete();
      return;
    }
    var v = this.index++;
    if (this.active < this.concurrent) {
      l.next(c);
      try {
        var p = this.project, _ = p(c, v);
        if (!this.scheduler)
          this.subscribeToProjection(_, c, v);
        else {
          var I = { subscriber: this, result: _, value: c, index: v }, P = this.destination;
          P.add(this.scheduler.schedule(u.dispatch, 0, I));
        }
      } catch ($) {
        l.error($);
      }
    } else
      this.buffer.push(c);
  }, u.prototype.subscribeToProjection = function(c, l, v) {
    this.active++;
    var p = this.destination;
    p.add(innerSubscribe(c, new SimpleInnerSubscriber(this)));
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasCompleted && this.active === 0 && this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this._next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c && c.length > 0 && this._next(c.shift()), this.hasCompleted && this.active === 0 && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function finalize(a) {
  return function(u) {
    return u.lift(new FinallyOperator(a));
  };
}
var FinallyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.callback = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FinallySubscriber(u, this.callback));
  }, a;
}(), FinallySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.add(new Subscription(l)), v;
  }
  return u;
}(Subscriber);
function find$2(a, u) {
  if (typeof a != "function")
    throw new TypeError("predicate is not a function");
  return function(c) {
    return c.lift(new FindValueOperator(a, c, !1, u));
  };
}
var FindValueOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.predicate = u, this.source = c, this.yieldIndex = l, this.thisArg = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FindValueSubscriber(u, this.predicate, this.source, this.yieldIndex, this.thisArg));
  }, a;
}(), FindValueSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var I = a.call(this, c) || this;
    return I.predicate = l, I.source = v, I.yieldIndex = p, I.thisArg = _, I.index = 0, I;
  }
  return u.prototype.notifyComplete = function(c) {
    var l = this.destination;
    l.next(c), l.complete(), this.unsubscribe();
  }, u.prototype._next = function(c) {
    var l = this, v = l.predicate, p = l.thisArg, _ = this.index++;
    try {
      var I = v.call(p || this, c, _, this.source);
      I && this.notifyComplete(this.yieldIndex ? _ : c);
    } catch (P) {
      this.destination.error(P);
    }
  }, u.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  }, u;
}(Subscriber);
function findIndex(a, u) {
  return function(c) {
    return c.lift(new FindValueOperator(a, c, !0, u));
  };
}
function first(a, u) {
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(a ? filter(function(v, p) {
      return a(v, p, l);
    }) : identity$1, take(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl, SubjectSubscription = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.subject = c, v.subscriber = l, v.closed = !1, v;
  }
  return u.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.closed = !0;
      var c = this.subject, l = c.observers;
      if (this.subject = null, !(!l || l.length === 0 || c.isStopped || c.closed)) {
        var v = l.indexOf(this.subscriber);
        v !== -1 && l.splice(v, 1);
      }
    }
  }, u;
}(Subscription), SubjectSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.destination = c, l;
  }
  return u;
}(Subscriber), Subject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a.call(this) || this;
    return c.observers = [], c.closed = !1, c.isStopped = !1, c.hasError = !1, c.thrownError = null, c;
  }
  return u.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  }, u.prototype.lift = function(c) {
    var l = new AnonymousSubject(this, this);
    return l.operator = c, l;
  }, u.prototype.next = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (!this.isStopped)
      for (var l = this.observers, v = l.length, p = l.slice(), _ = 0; _ < v; _++)
        p[_].next(c);
  }, u.prototype.error = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.hasError = !0, this.thrownError = c, this.isStopped = !0;
    for (var l = this.observers, v = l.length, p = l.slice(), _ = 0; _ < v; _++)
      p[_].error(c);
    this.observers.length = 0;
  }, u.prototype.complete = function() {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.isStopped = !0;
    for (var c = this.observers, l = c.length, v = c.slice(), p = 0; p < l; p++)
      v[p].complete();
    this.observers.length = 0;
  }, u.prototype.unsubscribe = function() {
    this.isStopped = !0, this.closed = !0, this.observers = null;
  }, u.prototype._trySubscribe = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return a.prototype._trySubscribe.call(this, c);
  }, u.prototype._subscribe = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this.hasError ? (c.error(this.thrownError), Subscription.EMPTY) : this.isStopped ? (c.complete(), Subscription.EMPTY) : (this.observers.push(c), new SubjectSubscription(this, c));
  }, u.prototype.asObservable = function() {
    var c = new Observable();
    return c.source = this, c;
  }, u.create = function(c, l) {
    return new AnonymousSubject(c, l);
  }, u;
}(Observable), AnonymousSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.destination = c, v.source = l, v;
  }
  return u.prototype.next = function(c) {
    var l = this.destination;
    l && l.next && l.next(c);
  }, u.prototype.error = function(c) {
    var l = this.destination;
    l && l.error && this.destination.error(c);
  }, u.prototype.complete = function() {
    var c = this.destination;
    c && c.complete && this.destination.complete();
  }, u.prototype._subscribe = function(c) {
    var l = this.source;
    return l ? this.source.subscribe(c) : Subscription.EMPTY;
  }, u;
}(Subject);
function groupBy(a, u, c, l) {
  return function(v) {
    return v.lift(new GroupByOperator(a, u, c, l));
  };
}
var GroupByOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.keySelector = u, this.elementSelector = c, this.durationSelector = l, this.subjectSelector = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new GroupBySubscriber(u, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  }, a;
}(), GroupBySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var I = a.call(this, c) || this;
    return I.keySelector = l, I.elementSelector = v, I.durationSelector = p, I.subjectSelector = _, I.groups = null, I.attemptedToUnsubscribe = !1, I.count = 0, I;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.keySelector(c);
    } catch (v) {
      this.error(v);
      return;
    }
    this._group(c, l);
  }, u.prototype._group = function(c, l) {
    var v = this.groups;
    v || (v = this.groups = /* @__PURE__ */ new Map());
    var p = v.get(l), _;
    if (this.elementSelector)
      try {
        _ = this.elementSelector(c);
      } catch ($) {
        this.error($);
      }
    else
      _ = c;
    if (!p) {
      p = this.subjectSelector ? this.subjectSelector() : new Subject(), v.set(l, p);
      var I = new GroupedObservable(l, p, this);
      if (this.destination.next(I), this.durationSelector) {
        var P = void 0;
        try {
          P = this.durationSelector(new GroupedObservable(l, p));
        } catch ($) {
          this.error($);
          return;
        }
        this.add(P.subscribe(new GroupDurationSubscriber(l, p, this)));
      }
    }
    p.closed || p.next(_);
  }, u.prototype._error = function(c) {
    var l = this.groups;
    l && (l.forEach(function(v, p) {
      v.error(c);
    }), l.clear()), this.destination.error(c);
  }, u.prototype._complete = function() {
    var c = this.groups;
    c && (c.forEach(function(l, v) {
      l.complete();
    }), c.clear()), this.destination.complete();
  }, u.prototype.removeGroup = function(c) {
    this.groups.delete(c);
  }, u.prototype.unsubscribe = function() {
    this.closed || (this.attemptedToUnsubscribe = !0, this.count === 0 && a.prototype.unsubscribe.call(this));
  }, u;
}(Subscriber), GroupDurationSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, l) || this;
    return p.key = c, p.group = l, p.parent = v, p;
  }
  return u.prototype._next = function(c) {
    this.complete();
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.parent, v = c.key;
    this.key = this.parent = null, l && l.removeGroup(v);
  }, u;
}(Subscriber), GroupedObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this) || this;
    return p.key = c, p.groupSubject = l, p.refCountSubscription = v, p;
  }
  return u.prototype._subscribe = function(c) {
    var l = new Subscription(), v = this, p = v.refCountSubscription, _ = v.groupSubject;
    return p && !p.closed && l.add(new InnerRefCountSubscription(p)), l.add(_.subscribe(c)), l;
  }, u;
}(Observable), InnerRefCountSubscription = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l.parent = c, c.count++, l;
  }
  return u.prototype.unsubscribe = function() {
    var c = this.parent;
    !c.closed && !this.closed && (a.prototype.unsubscribe.call(this), c.count -= 1, c.count === 0 && c.attemptedToUnsubscribe && c.unsubscribe());
  }, u;
}(Subscription);
function ignoreElements() {
  return function(u) {
    return u.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new IgnoreElementsSubscriber(u));
  }, a;
}(), IgnoreElementsSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype._next = function(c) {
  }, u;
}(Subscriber);
function isEmpty() {
  return function(a) {
    return a.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new IsEmptySubscriber(u));
  }, a;
}(), IsEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype.notifyComplete = function(c) {
    var l = this.destination;
    l.next(c), l.complete();
  }, u.prototype._next = function(c) {
    this.notifyComplete(!1);
  }, u.prototype._complete = function() {
    this.notifyComplete(!0);
  }, u;
}(Subscriber);
function takeLast(a) {
  return function(c) {
    return a === 0 ? empty$2() : c.lift(new TakeLastOperator(a));
  };
}
var TakeLastOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this.total = u, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeLastSubscriber(u, this.total));
  }, a;
}(), TakeLastSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.ring = new Array(), v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.ring, v = this.total, p = this.count++;
    if (l.length < v)
      l.push(c);
    else {
      var _ = p % v;
      l[_] = c;
    }
  }, u.prototype._complete = function() {
    var c = this.destination, l = this.count;
    if (l > 0)
      for (var v = this.count >= this.total ? this.total : this.count, p = this.ring, _ = 0; _ < v; _++) {
        var I = l++ % v;
        c.next(p[I]);
      }
    c.complete();
  }, u;
}(Subscriber);
function last$1(a, u) {
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(a ? filter(function(v, p) {
      return a(v, p, l);
    }) : identity$1, takeLast(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mapTo(a) {
  return function(u) {
    return u.lift(new MapToOperator(a));
  };
}
var MapToOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.value = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MapToSubscriber(u, this.value));
  }, a;
}(), MapToSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.value = l, v;
  }
  return u.prototype._next = function(c) {
    this.destination.next(this.value);
  }, u;
}(Subscriber);
function materialize() {
  return function(u) {
    return u.lift(new MaterializeOperator());
  };
}
var MaterializeOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MaterializeSubscriber(u));
  }, a;
}(), MaterializeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype._next = function(c) {
    this.destination.next(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    var l = this.destination;
    l.next(Notification.createError(c)), l.complete();
  }, u.prototype._complete = function() {
    var c = this.destination;
    c.next(Notification.createComplete()), c.complete();
  }, u;
}(Subscriber);
function scan(a, u) {
  var c = !1;
  return arguments.length >= 2 && (c = !0), function(v) {
    return v.lift(new ScanOperator(a, u, c));
  };
}
var ScanOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    l === void 0 && (l = !1), this.accumulator = u, this.seed = c, this.hasSeed = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ScanSubscriber(u, this.accumulator, this.seed, this.hasSeed));
  }, a;
}(), ScanSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.accumulator = l, _._seed = v, _.hasSeed = p, _.index = 0, _;
  }
  return Object.defineProperty(u.prototype, "seed", {
    get: function() {
      return this._seed;
    },
    set: function(c) {
      this.hasSeed = !0, this._seed = c;
    },
    enumerable: !0,
    configurable: !0
  }), u.prototype._next = function(c) {
    if (!this.hasSeed)
      this.seed = c, this.destination.next(c);
    else
      return this._tryNext(c);
  }, u.prototype._tryNext = function(c) {
    var l = this.index++, v;
    try {
      v = this.accumulator(this.seed, c, l);
    } catch (p) {
      this.destination.error(p);
    }
    this.seed = v, this.destination.next(v);
  }, u;
}(Subscriber);
function reduce(a, u) {
  return arguments.length >= 2 ? function(l) {
    return pipe$2(scan(a, u), takeLast(1), defaultIfEmpty(u))(l);
  } : function(l) {
    return pipe$2(scan(function(v, p, _) {
      return a(v, p, _ + 1);
    }), takeLast(1))(l);
  };
}
function max$1(a) {
  var u = typeof a == "function" ? function(c, l) {
    return a(c, l) > 0 ? c : l;
  } : function(c, l) {
    return c > l ? c : l;
  };
  return reduce(u);
}
function merge$2() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = Number.POSITIVE_INFINITY, l = null, v = a[a.length - 1];
  return isScheduler(v) ? (l = a.pop(), a.length > 1 && typeof a[a.length - 1] == "number" && (c = a.pop())) : typeof v == "number" && (c = a.pop()), l === null && a.length === 1 && a[0] instanceof Observable ? a[0] : mergeAll(c)(fromArray$1(a, l));
}
function merge$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return c.lift.call(merge$2.apply(void 0, [c].concat(a)));
  };
}
function mergeMapTo(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), typeof u == "function" ? mergeMap(function() {
    return a;
  }, u, c) : (typeof u == "number" && (c = u), mergeMap(function() {
    return a;
  }, c));
}
function mergeScan(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), function(l) {
    return l.lift(new MergeScanOperator(a, u, c));
  };
}
var MergeScanOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.accumulator = u, this.seed = c, this.concurrent = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MergeScanSubscriber(u, this.accumulator, this.seed, this.concurrent));
  }, a;
}(), MergeScanSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.accumulator = l, _.acc = v, _.concurrent = p, _.hasValue = !1, _.hasCompleted = !1, _.buffer = [], _.active = 0, _.index = 0, _;
  }
  return u.prototype._next = function(c) {
    if (this.active < this.concurrent) {
      var l = this.index++, v = this.destination, p = void 0;
      try {
        var _ = this.accumulator;
        p = _(this.acc, c, l);
      } catch (I) {
        return v.error(I);
      }
      this.active++, this._innerSub(p);
    } else
      this.buffer.push(c);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var p = innerSubscribe(c, l);
    p !== l && v.add(p);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete()), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    var l = this.destination;
    this.acc = c, this.hasValue = !0, l.next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c.length > 0 ? this._next(c.shift()) : this.active === 0 && this.hasCompleted && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete());
  }, u;
}(SimpleOuterSubscriber);
function min(a) {
  var u = typeof a == "function" ? function(c, l) {
    return a(c, l) < 0 ? c : l;
  } : function(c, l) {
    return c < l ? c : l;
  };
  return reduce(u);
}
function refCount() {
  return function(u) {
    return u.lift(new RefCountOperator(u));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.connectable = u;
  }
  return a.prototype.call = function(u, c) {
    var l = this.connectable;
    l._refCount++;
    var v = new RefCountSubscriber(u, l), p = c.subscribe(v);
    return v.closed || (v.connection = l.connect()), p;
  }, a;
}(), RefCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.connectable = l, v;
  }
  return u.prototype._unsubscribe = function() {
    var c = this.connectable;
    if (!c) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var l = c._refCount;
    if (l <= 0) {
      this.connection = null;
      return;
    }
    if (c._refCount = l - 1, l > 1) {
      this.connection = null;
      return;
    }
    var v = this.connection, p = c._connection;
    this.connection = null, p && (!v || p === v) && p.unsubscribe();
  }, u;
}(Subscriber), ConnectableObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.source = c, v.subjectFactory = l, v._refCount = 0, v._isComplete = !1, v;
  }
  return u.prototype._subscribe = function(c) {
    return this.getSubject().subscribe(c);
  }, u.prototype.getSubject = function() {
    var c = this._subject;
    return (!c || c.isStopped) && (this._subject = this.subjectFactory()), this._subject;
  }, u.prototype.connect = function() {
    var c = this._connection;
    return c || (this._isComplete = !1, c = this._connection = new Subscription(), c.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this))), c.closed && (this._connection = null, c = Subscription.EMPTY)), c;
  }, u.prototype.refCount = function() {
    return refCount()(this);
  }, u;
}(Observable), connectableObservableDescriptor = /* @__PURE__ */ function() {
  var a = ConnectableObservable.prototype;
  return {
    operator: { value: null },
    _refCount: { value: 0, writable: !0 },
    _subject: { value: null, writable: !0 },
    _connection: { value: null, writable: !0 },
    _subscribe: { value: a._subscribe },
    _isComplete: { value: a._isComplete, writable: !0 },
    getSubject: { value: a.getSubject },
    connect: { value: a.connect },
    refCount: { value: a.refCount }
  };
}(), ConnectableSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.connectable = l, v;
  }
  return u.prototype._error = function(c) {
    this._unsubscribe(), a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    this.connectable._isComplete = !0, this._unsubscribe(), a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    var c = this.connectable;
    if (c) {
      this.connectable = null;
      var l = c._connection;
      c._refCount = 0, c._subject = null, c._connection = null, l && l.unsubscribe();
    }
  }, u;
}(SubjectSubscriber);
function multicast(a, u) {
  return function(l) {
    var v;
    if (typeof a == "function" ? v = a : v = function() {
      return a;
    }, typeof u == "function")
      return l.lift(new MulticastOperator(v, u));
    var p = Object.create(l, connectableObservableDescriptor);
    return p.source = l, p.subjectFactory = v, p;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.subjectFactory = u, this.selector = c;
  }
  return a.prototype.call = function(u, c) {
    var l = this.selector, v = this.subjectFactory(), p = l(v).subscribe(u);
    return p.add(c.subscribe(v)), p;
  }, a;
}();
function observeOn(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new ObserveOnOperator(a, u));
  };
}
var ObserveOnOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = 0), this.scheduler = u, this.delay = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ObserveOnSubscriber(u, this.scheduler, this.delay));
  }, a;
}(), ObserveOnSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    v === void 0 && (v = 0);
    var p = a.call(this, c) || this;
    return p.scheduler = l, p.delay = v, p;
  }
  return u.dispatch = function(c) {
    var l = c.notification, v = c.destination;
    l.observe(v), this.unsubscribe();
  }, u.prototype.scheduleMessage = function(c) {
    var l = this.destination;
    l.add(this.scheduler.schedule(u.dispatch, this.delay, new ObserveOnMessage(c, this.destination)));
  }, u.prototype._next = function(c) {
    this.scheduleMessage(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    this.scheduleMessage(Notification.createError(c)), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete()), this.unsubscribe();
  }, u;
}(Subscriber), ObserveOnMessage = /* @__PURE__ */ function() {
  function a(u, c) {
    this.notification = u, this.destination = c;
  }
  return a;
}();
function onErrorResumeNext() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return a.length === 1 && isArray$5(a[0]) && (a = a[0]), function(c) {
    return c.lift(new OnErrorResumeNextOperator(a));
  };
}
var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.nextSources = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new OnErrorResumeNextSubscriber(u, this.nextSources));
  }, a;
}(), OnErrorResumeNextSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.destination = c, v.nextSources = l, v;
  }
  return u.prototype.notifyError = function() {
    this.subscribeToNextSource();
  }, u.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  }, u.prototype._error = function(c) {
    this.subscribeToNextSource(), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.subscribeToNextSource(), this.unsubscribe();
  }, u.prototype.subscribeToNextSource = function() {
    var c = this.nextSources.shift();
    if (c) {
      var l = new SimpleInnerSubscriber(this), v = this.destination;
      v.add(l);
      var p = innerSubscribe(c, l);
      p !== l && v.add(p);
    } else
      this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function pairwise() {
  return function(a) {
    return a.lift(new PairwiseOperator());
  };
}
var PairwiseOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new PairwiseSubscriber(u));
  }, a;
}(), PairwiseSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasPrev = !1, l;
  }
  return u.prototype._next = function(c) {
    var l;
    this.hasPrev ? l = [this.prev, c] : this.hasPrev = !0, this.prev = c, l && this.destination.next(l);
  }, u;
}(Subscriber);
function not(a, u) {
  function c() {
    return !c.pred.apply(c.thisArg, arguments);
  }
  return c.pred = a, c.thisArg = u, c;
}
function partition(a, u) {
  return function(c) {
    return [
      filter(a, u)(c),
      filter(not(a, u))(c)
    ];
  };
}
function pluck() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a.length;
  if (c === 0)
    throw new Error("list of properties cannot be empty.");
  return function(l) {
    return map(plucker(a, c))(l);
  };
}
function plucker(a, u) {
  var c = function(l) {
    for (var v = l, p = 0; p < u; p++) {
      var _ = v != null ? v[a[p]] : void 0;
      if (_ !== void 0)
        v = _;
      else
        return;
    }
    return v;
  };
  return c;
}
function publish(a) {
  return a ? multicast(function() {
    return new Subject();
  }, a) : multicast(new Subject());
}
var BehaviorSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l._value = c, l;
  }
  return Object.defineProperty(u.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !0,
    configurable: !0
  }), u.prototype._subscribe = function(c) {
    var l = a.prototype._subscribe.call(this, c);
    return l && !l.closed && c.next(this._value), l;
  }, u.prototype.getValue = function() {
    if (this.hasError)
      throw this.thrownError;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this._value;
  }, u.prototype.next = function(c) {
    a.prototype.next.call(this, this._value = c);
  }, u;
}(Subject);
function publishBehavior(a) {
  return function(u) {
    return multicast(new BehaviorSubject(a))(u);
  };
}
var AsyncSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c.value = null, c.hasNext = !1, c.hasCompleted = !1, c;
  }
  return u.prototype._subscribe = function(c) {
    return this.hasError ? (c.error(this.thrownError), Subscription.EMPTY) : this.hasCompleted && this.hasNext ? (c.next(this.value), c.complete(), Subscription.EMPTY) : a.prototype._subscribe.call(this, c);
  }, u.prototype.next = function(c) {
    this.hasCompleted || (this.value = c, this.hasNext = !0);
  }, u.prototype.error = function(c) {
    this.hasCompleted || a.prototype.error.call(this, c);
  }, u.prototype.complete = function() {
    this.hasCompleted = !0, this.hasNext && a.prototype.next.call(this, this.value), a.prototype.complete.call(this);
  }, u;
}(Subject);
function publishLast() {
  return function(a) {
    return multicast(new AsyncSubject())(a);
  };
}
var QueueAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v;
  }
  return u.prototype.schedule = function(c, l) {
    return l === void 0 && (l = 0), l > 0 ? a.prototype.schedule.call(this, c, l) : (this.delay = l, this.state = c, this.scheduler.flush(this), this);
  }, u.prototype.execute = function(c, l) {
    return l > 0 || this.closed ? a.prototype.execute.call(this, c, l) : this._execute(c, l);
  }, u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), v !== null && v > 0 || v === null && this.delay > 0 ? a.prototype.requestAsyncId.call(this, c, l, v) : c.flush(this);
  }, u;
}(AsyncAction), QueueScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u;
}(AsyncScheduler), queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction), queue$1 = queueScheduler, ReplaySubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    c === void 0 && (c = Number.POSITIVE_INFINITY), l === void 0 && (l = Number.POSITIVE_INFINITY);
    var p = a.call(this) || this;
    return p.scheduler = v, p._events = [], p._infiniteTimeWindow = !1, p._bufferSize = c < 1 ? 1 : c, p._windowTime = l < 1 ? 1 : l, l === Number.POSITIVE_INFINITY ? (p._infiniteTimeWindow = !0, p.next = p.nextInfiniteTimeWindow) : p.next = p.nextTimeWindow, p;
  }
  return u.prototype.nextInfiniteTimeWindow = function(c) {
    if (!this.isStopped) {
      var l = this._events;
      l.push(c), l.length > this._bufferSize && l.shift();
    }
    a.prototype.next.call(this, c);
  }, u.prototype.nextTimeWindow = function(c) {
    this.isStopped || (this._events.push(new ReplayEvent(this._getNow(), c)), this._trimBufferThenGetEvents()), a.prototype.next.call(this, c);
  }, u.prototype._subscribe = function(c) {
    var l = this._infiniteTimeWindow, v = l ? this._events : this._trimBufferThenGetEvents(), p = this.scheduler, _ = v.length, I;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (this.isStopped || this.hasError ? I = Subscription.EMPTY : (this.observers.push(c), I = new SubjectSubscription(this, c)), p && c.add(c = new ObserveOnSubscriber(c, p)), l)
      for (var P = 0; P < _ && !c.closed; P++)
        c.next(v[P]);
    else
      for (var P = 0; P < _ && !c.closed; P++)
        c.next(v[P].value);
    return this.hasError ? c.error(this.thrownError) : this.isStopped && c.complete(), I;
  }, u.prototype._getNow = function() {
    return (this.scheduler || queue$1).now();
  }, u.prototype._trimBufferThenGetEvents = function() {
    for (var c = this._getNow(), l = this._bufferSize, v = this._windowTime, p = this._events, _ = p.length, I = 0; I < _ && !(c - p[I].time < v); )
      I++;
    return _ > l && (I = Math.max(I, _ - l)), I > 0 && p.splice(0, I), p;
  }, u;
}(Subject), ReplayEvent = /* @__PURE__ */ function() {
  function a(u, c) {
    this.time = u, this.value = c;
  }
  return a;
}();
function publishReplay(a, u, c, l) {
  c && typeof c != "function" && (l = c);
  var v = typeof c == "function" ? c : void 0, p = new ReplaySubject(a, u, l);
  return function(_) {
    return multicast(function() {
      return p;
    }, v)(_);
  };
}
function race$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  if (a.length === 1)
    if (isArray$5(a[0]))
      a = a[0];
    else
      return a[0];
  return fromArray$1(a, void 0).lift(new RaceOperator());
}
var RaceOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RaceSubscriber(u));
  }, a;
}(), RaceSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasFirst = !1, l.observables = [], l.subscriptions = [], l;
  }
  return u.prototype._next = function(c) {
    this.observables.push(c);
  }, u.prototype._complete = function() {
    var c = this.observables, l = c.length;
    if (l === 0)
      this.destination.complete();
    else {
      for (var v = 0; v < l && !this.hasFirst; v++) {
        var p = c[v], _ = subscribeToResult(this, p, void 0, v);
        this.subscriptions && this.subscriptions.push(_), this.add(_);
      }
      this.observables = null;
    }
  }, u.prototype.notifyNext = function(c, l, v) {
    if (!this.hasFirst) {
      this.hasFirst = !0;
      for (var p = 0; p < this.subscriptions.length; p++)
        if (p !== v) {
          var _ = this.subscriptions[p];
          _.unsubscribe(), this.remove(_);
        }
      this.subscriptions = null;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function race() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(l) {
    return a.length === 1 && isArray$5(a[0]) && (a = a[0]), l.lift.call(race$1.apply(void 0, [l].concat(a)));
  };
}
function repeat(a) {
  return a === void 0 && (a = -1), function(u) {
    return a === 0 ? empty$2() : a < 0 ? u.lift(new RepeatOperator(-1, u)) : u.lift(new RepeatOperator(a - 1, u));
  };
}
var RepeatOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.count = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RepeatSubscriber(u, this.count, this.source));
  }, a;
}(), RepeatSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.count = l, p.source = v, p;
  }
  return u.prototype.complete = function() {
    if (!this.isStopped) {
      var c = this, l = c.source, v = c.count;
      if (v === 0)
        return a.prototype.complete.call(this);
      v > -1 && (this.count = v - 1), l.subscribe(this._unsubscribeAndRecycle());
    }
  }, u;
}(Subscriber);
function repeatWhen(a) {
  return function(u) {
    return u.lift(new RepeatWhenOperator(a));
  };
}
var RepeatWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RepeatWhenSubscriber(u, this.notifier, c));
  }, a;
}(), RepeatWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.notifier = l, p.source = v, p.sourceIsBeingSubscribedTo = !0, p;
  }
  return u.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = !0, this.source.subscribe(this);
  }, u.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === !1)
      return a.prototype.complete.call(this);
  }, u.prototype.complete = function() {
    if (this.sourceIsBeingSubscribedTo = !1, !this.isStopped) {
      if (this.retries || this.subscribeToRetries(), !this.retriesSubscription || this.retriesSubscription.closed)
        return a.prototype.complete.call(this);
      this._unsubscribeAndRecycle(), this.notifications.next(void 0);
    }
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.notifications, v = c.retriesSubscription;
    l && (l.unsubscribe(), this.notifications = void 0), v && (v.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, u.prototype._unsubscribeAndRecycle = function() {
    var c = this._unsubscribe;
    return this._unsubscribe = null, a.prototype._unsubscribeAndRecycle.call(this), this._unsubscribe = c, this;
  }, u.prototype.subscribeToRetries = function() {
    this.notifications = new Subject();
    var c;
    try {
      var l = this.notifier;
      c = l(this.notifications);
    } catch {
      return a.prototype.complete.call(this);
    }
    this.retries = c, this.retriesSubscription = innerSubscribe(c, new SimpleInnerSubscriber(this));
  }, u;
}(SimpleOuterSubscriber);
function retry(a) {
  return a === void 0 && (a = -1), function(u) {
    return u.lift(new RetryOperator(a, u));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.count = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RetrySubscriber(u, this.count, this.source));
  }, a;
}(), RetrySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.count = l, p.source = v, p;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this, v = l.source, p = l.count;
      if (p === 0)
        return a.prototype.error.call(this, c);
      p > -1 && (this.count = p - 1), v.subscribe(this._unsubscribeAndRecycle());
    }
  }, u;
}(Subscriber);
function retryWhen(a) {
  return function(u) {
    return u.lift(new RetryWhenOperator(a, u));
  };
}
var RetryWhenOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.notifier = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RetryWhenSubscriber(u, this.notifier, this.source));
  }, a;
}(), RetryWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.notifier = l, p.source = v, p;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this.errors, v = this.retries, p = this.retriesSubscription;
      if (v)
        this.errors = void 0, this.retriesSubscription = void 0;
      else {
        l = new Subject();
        try {
          var _ = this.notifier;
          v = _(l);
        } catch (I) {
          return a.prototype.error.call(this, I);
        }
        p = innerSubscribe(v, new SimpleInnerSubscriber(this));
      }
      this._unsubscribeAndRecycle(), this.errors = l, this.retries = v, this.retriesSubscription = p, l.next(c);
    }
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.errors, v = c.retriesSubscription;
    l && (l.unsubscribe(), this.errors = void 0), v && (v.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, u.prototype.notifyNext = function() {
    var c = this._unsubscribe;
    this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = c, this.source.subscribe(this);
  }, u;
}(SimpleOuterSubscriber);
function sample(a) {
  return function(u) {
    return u.lift(new SampleOperator(a));
  };
}
var SampleOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new SampleSubscriber(u), v = c.subscribe(l);
    return v.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(l))), v;
  }, a;
}(), SampleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c.hasValue = !1, c;
  }
  return u.prototype._next = function(c) {
    this.value = c, this.hasValue = !0;
  }, u.prototype.notifyNext = function() {
    this.emitValue();
  }, u.prototype.notifyComplete = function() {
    this.emitValue();
  }, u.prototype.emitValue = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.value));
  }, u;
}(SimpleOuterSubscriber);
function sampleTime(a, u) {
  return u === void 0 && (u = async$1), function(c) {
    return c.lift(new SampleTimeOperator(a, u));
  };
}
var SampleTimeOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.period = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SampleTimeSubscriber(u, this.period, this.scheduler));
  }, a;
}(), SampleTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.period = l, p.scheduler = v, p.hasValue = !1, p.add(v.schedule(dispatchNotification, l, { subscriber: p, period: l })), p;
  }
  return u.prototype._next = function(c) {
    this.lastValue = c, this.hasValue = !0;
  }, u.prototype.notifyNext = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.lastValue));
  }, u;
}(Subscriber);
function dispatchNotification(a) {
  var u = a.subscriber, c = a.period;
  u.notifyNext(), this.schedule(a, c);
}
function sequenceEqual(a, u) {
  return function(c) {
    return c.lift(new SequenceEqualOperator(a, u));
  };
}
var SequenceEqualOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.compareTo = u, this.comparator = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SequenceEqualSubscriber(u, this.compareTo, this.comparator));
  }, a;
}(), SequenceEqualSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.compareTo = l, p.comparator = v, p._a = [], p._b = [], p._oneComplete = !1, p.destination.add(l.subscribe(new SequenceEqualCompareToSubscriber(c, p))), p;
  }
  return u.prototype._next = function(c) {
    this._oneComplete && this._b.length === 0 ? this.emit(!1) : (this._a.push(c), this.checkValues());
  }, u.prototype._complete = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0, this.unsubscribe();
  }, u.prototype.checkValues = function() {
    for (var c = this, l = c._a, v = c._b, p = c.comparator; l.length > 0 && v.length > 0; ) {
      var _ = l.shift(), I = v.shift(), P = !1;
      try {
        P = p ? p(_, I) : _ === I;
      } catch ($) {
        this.destination.error($);
      }
      P || this.emit(!1);
    }
  }, u.prototype.emit = function(c) {
    var l = this.destination;
    l.next(c), l.complete();
  }, u.prototype.nextB = function(c) {
    this._oneComplete && this._a.length === 0 ? this.emit(!1) : (this._b.push(c), this.checkValues());
  }, u.prototype.completeB = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0;
  }, u;
}(Subscriber), SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.parent = l, v;
  }
  return u.prototype._next = function(c) {
    this.parent.nextB(c);
  }, u.prototype._error = function(c) {
    this.parent.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.completeB(), this.unsubscribe();
  }, u;
}(Subscriber);
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(a) {
    return refCount()(multicast(shareSubjectFactory)(a));
  };
}
function shareReplay(a, u, c) {
  var l;
  return a && typeof a == "object" ? l = a : l = {
    bufferSize: a,
    windowTime: u,
    refCount: !1,
    scheduler: c
  }, function(v) {
    return v.lift(shareReplayOperator(l));
  };
}
function shareReplayOperator(a) {
  var u = a.bufferSize, c = u === void 0 ? Number.POSITIVE_INFINITY : u, l = a.windowTime, v = l === void 0 ? Number.POSITIVE_INFINITY : l, p = a.refCount, _ = a.scheduler, I, P = 0, $, F = !1, H = !1;
  return function(ee) {
    P++;
    var X;
    !I || F ? (F = !1, I = new ReplaySubject(c, v, _), X = I.subscribe(this), $ = ee.subscribe({
      next: function(ie) {
        I.next(ie);
      },
      error: function(ie) {
        F = !0, I.error(ie);
      },
      complete: function() {
        H = !0, $ = void 0, I.complete();
      }
    }), H && ($ = void 0)) : X = I.subscribe(this), this.add(function() {
      P--, X.unsubscribe(), X = void 0, $ && !H && p && P === 0 && ($.unsubscribe(), $ = void 0, I = void 0);
    });
  };
}
function single(a) {
  return function(u) {
    return u.lift(new SingleOperator(a, u));
  };
}
var SingleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SingleSubscriber(u, this.predicate, this.source));
  }, a;
}(), SingleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.source = v, p.seenValue = !1, p.index = 0, p;
  }
  return u.prototype.applySingleValue = function(c) {
    this.seenValue ? this.destination.error("Sequence contains more than one element") : (this.seenValue = !0, this.singleValue = c);
  }, u.prototype._next = function(c) {
    var l = this.index++;
    this.predicate ? this.tryNext(c, l) : this.applySingleValue(c);
  }, u.prototype.tryNext = function(c, l) {
    try {
      this.predicate(c, l, this.source) && this.applySingleValue(c);
    } catch (v) {
      this.destination.error(v);
    }
  }, u.prototype._complete = function() {
    var c = this.destination;
    this.index > 0 ? (c.next(this.seenValue ? this.singleValue : void 0), c.complete()) : c.error(new EmptyError());
  }, u;
}(Subscriber);
function skip(a) {
  return function(u) {
    return u.lift(new SkipOperator(a));
  };
}
var SkipOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.total = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipSubscriber(u, this.total));
  }, a;
}(), SkipSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    ++this.count > this.total && this.destination.next(c);
  }, u;
}(Subscriber);
function skipLast(a) {
  return function(u) {
    return u.lift(new SkipLastOperator(a));
  };
}
var SkipLastOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this._skipCount = u, this._skipCount < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return this._skipCount === 0 ? c.subscribe(new Subscriber(u)) : c.subscribe(new SkipLastSubscriber(u, this._skipCount));
  }, a;
}(), SkipLastSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v._skipCount = l, v._count = 0, v._ring = new Array(l), v;
  }
  return u.prototype._next = function(c) {
    var l = this._skipCount, v = this._count++;
    if (v < l)
      this._ring[v] = c;
    else {
      var p = v % l, _ = this._ring, I = _[p];
      _[p] = c, this.destination.next(I);
    }
  }, u;
}(Subscriber);
function skipUntil(a) {
  return function(u) {
    return u.lift(new SkipUntilOperator(a));
  };
}
var SkipUntilOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipUntilSubscriber(u, this.notifier));
  }, a;
}(), SkipUntilSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    v.hasValue = !1;
    var p = new SimpleInnerSubscriber(v);
    v.add(p), v.innerSubscription = p;
    var _ = innerSubscribe(l, p);
    return _ !== p && (v.add(_), v.innerSubscription = _), v;
  }
  return u.prototype._next = function(c) {
    this.hasValue && a.prototype._next.call(this, c);
  }, u.prototype.notifyNext = function() {
    this.hasValue = !0, this.innerSubscription && this.innerSubscription.unsubscribe();
  }, u.prototype.notifyComplete = function() {
  }, u;
}(SimpleOuterSubscriber);
function skipWhile(a) {
  return function(u) {
    return u.lift(new SkipWhileOperator(a));
  };
}
var SkipWhileOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.predicate = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipWhileSubscriber(u, this.predicate));
  }, a;
}(), SkipWhileSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.predicate = l, v.skipping = !0, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.destination;
    this.skipping && this.tryCallPredicate(c), this.skipping || l.next(c);
  }, u.prototype.tryCallPredicate = function(c) {
    try {
      var l = this.predicate(c, this.index++);
      this.skipping = !!l;
    } catch (v) {
      this.destination.error(v);
    }
  }, u;
}(Subscriber);
function startWith() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return isScheduler(c) ? (a.pop(), function(l) {
    return concat$1(a, l, c);
  }) : function(l) {
    return concat$1(a, l);
  };
}
var nextHandle = 1, RESOLVED = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}(), activeHandles = {};
function findAndClearHandle(a) {
  return a in activeHandles ? (delete activeHandles[a], !0) : !1;
}
var Immediate = {
  setImmediate: function(a) {
    var u = nextHandle++;
    return activeHandles[u] = !0, RESOLVED.then(function() {
      return findAndClearHandle(u) && a();
    }), u;
  },
  clearImmediate: function(a) {
    findAndClearHandle(a);
  }
}, AsapAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v;
  }
  return u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), v !== null && v > 0 ? a.prototype.requestAsyncId.call(this, c, l, v) : (c.actions.push(this), c.scheduled || (c.scheduled = Immediate.setImmediate(c.flush.bind(c, null))));
  }, u.prototype.recycleAsyncId = function(c, l, v) {
    if (v === void 0 && (v = 0), v !== null && v > 0 || v === null && this.delay > 0)
      return a.prototype.recycleAsyncId.call(this, c, l, v);
    c.actions.length === 0 && (Immediate.clearImmediate(l), c.scheduled = void 0);
  }, u;
}(AsyncAction), AsapScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.flush = function(c) {
    this.active = !0, this.scheduled = void 0;
    var l = this.actions, v, p = -1, _ = l.length;
    c = c || l.shift();
    do
      if (v = c.execute(c.state, c.delay))
        break;
    while (++p < _ && (c = l.shift()));
    if (this.active = !1, v) {
      for (; ++p < _ && (c = l.shift()); )
        c.unsubscribe();
      throw v;
    }
  }, u;
}(AsyncScheduler), asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction), asap = asapScheduler, SubscribeOnObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    l === void 0 && (l = 0), v === void 0 && (v = asap);
    var p = a.call(this) || this;
    return p.source = c, p.delayTime = l, p.scheduler = v, (!isNumeric(l) || l < 0) && (p.delayTime = 0), (!v || typeof v.schedule != "function") && (p.scheduler = asap), p;
  }
  return u.create = function(c, l, v) {
    return l === void 0 && (l = 0), v === void 0 && (v = asap), new u(c, l, v);
  }, u.dispatch = function(c) {
    var l = c.source, v = c.subscriber;
    return this.add(l.subscribe(v));
  }, u.prototype._subscribe = function(c) {
    var l = this.delayTime, v = this.source, p = this.scheduler;
    return p.schedule(u.dispatch, l, {
      source: v,
      subscriber: c
    });
  }, u;
}(Observable);
function subscribeOn(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new SubscribeOnOperator(a, u));
  };
}
var SubscribeOnOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.scheduler = u, this.delay = c;
  }
  return a.prototype.call = function(u, c) {
    return new SubscribeOnObservable(c, this.delay, this.scheduler).subscribe(u);
  }, a;
}();
function switchMap(a, u) {
  return typeof u == "function" ? function(c) {
    return c.pipe(switchMap(function(l, v) {
      return from(a(l, v)).pipe(map(function(p, _) {
        return u(l, p, v, _);
      }));
    }));
  } : function(c) {
    return c.lift(new SwitchMapOperator(a));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.project = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SwitchMapSubscriber(u, this.project));
  }, a;
}(), SwitchMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.project = l, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (p) {
      this.destination.error(p);
      return;
    }
    this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = this.innerSubscription;
    l && l.unsubscribe();
    var v = new SimpleInnerSubscriber(this), p = this.destination;
    p.add(v), this.innerSubscription = innerSubscribe(c, v), this.innerSubscription !== v && p.add(this.innerSubscription);
  }, u.prototype._complete = function() {
    var c = this.innerSubscription;
    (!c || c.closed) && a.prototype._complete.call(this), this.unsubscribe();
  }, u.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  }, u.prototype.notifyComplete = function() {
    this.innerSubscription = void 0, this.isStopped && a.prototype._complete.call(this);
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u;
}(SimpleOuterSubscriber);
function switchAll() {
  return switchMap(identity$1);
}
function switchMapTo(a, u) {
  return u ? switchMap(function() {
    return a;
  }, u) : switchMap(function() {
    return a;
  });
}
function takeUntil(a) {
  return function(u) {
    return u.lift(new TakeUntilOperator(a));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new TakeUntilSubscriber(u), v = innerSubscribe(this.notifier, new SimpleInnerSubscriber(l));
    return v && !l.seenValue ? (l.add(v), c.subscribe(l)) : l;
  }, a;
}(), TakeUntilSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.seenValue = !1, l;
  }
  return u.prototype.notifyNext = function() {
    this.seenValue = !0, this.complete();
  }, u.prototype.notifyComplete = function() {
  }, u;
}(SimpleOuterSubscriber);
function takeWhile(a, u) {
  return u === void 0 && (u = !1), function(c) {
    return c.lift(new TakeWhileOperator(a, u));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.inclusive = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeWhileSubscriber(u, this.predicate, this.inclusive));
  }, a;
}(), TakeWhileSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.predicate = l, p.inclusive = v, p.index = 0, p;
  }
  return u.prototype._next = function(c) {
    var l = this.destination, v;
    try {
      v = this.predicate(c, this.index++);
    } catch (p) {
      l.error(p);
      return;
    }
    this.nextOrComplete(c, v);
  }, u.prototype.nextOrComplete = function(c, l) {
    var v = this.destination;
    l ? v.next(c) : (this.inclusive && v.next(c), v.complete());
  }, u;
}(Subscriber);
function noop$6() {
}
function tap(a, u, c) {
  return function(v) {
    return v.lift(new DoOperator(a, u, c));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.nextOrObserver = u, this.error = c, this.complete = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TapSubscriber(u, this.nextOrObserver, this.error, this.complete));
  }, a;
}(), TapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _._tapNext = noop$6, _._tapError = noop$6, _._tapComplete = noop$6, _._tapError = v || noop$6, _._tapComplete = p || noop$6, isFunction$3(l) ? (_._context = _, _._tapNext = l) : l && (_._context = l, _._tapNext = l.next || noop$6, _._tapError = l.error || noop$6, _._tapComplete = l.complete || noop$6), _;
  }
  return u.prototype._next = function(c) {
    try {
      this._tapNext.call(this._context, c);
    } catch (l) {
      this.destination.error(l);
      return;
    }
    this.destination.next(c);
  }, u.prototype._error = function(c) {
    try {
      this._tapError.call(this._context, c);
    } catch (l) {
      this.destination.error(l);
      return;
    }
    this.destination.error(c);
  }, u.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (c) {
      this.destination.error(c);
      return;
    }
    return this.destination.complete();
  }, u;
}(Subscriber), defaultThrottleConfig = {
  leading: !0,
  trailing: !1
};
function throttle(a, u) {
  return u === void 0 && (u = defaultThrottleConfig), function(c) {
    return c.lift(new ThrottleOperator(a, !!u.leading, !!u.trailing));
  };
}
var ThrottleOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.durationSelector = u, this.leading = c, this.trailing = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrottleSubscriber(u, this.durationSelector, this.leading, this.trailing));
  }, a;
}(), ThrottleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p) {
    var _ = a.call(this, c) || this;
    return _.destination = c, _.durationSelector = l, _._leading = v, _._trailing = p, _._hasValue = !1, _;
  }
  return u.prototype._next = function(c) {
    this._hasValue = !0, this._sendValue = c, this._throttled || (this._leading ? this.send() : this.throttle(c));
  }, u.prototype.send = function() {
    var c = this, l = c._hasValue, v = c._sendValue;
    l && (this.destination.next(v), this.throttle(v)), this._hasValue = !1, this._sendValue = void 0;
  }, u.prototype.throttle = function(c) {
    var l = this.tryDurationSelector(c);
    l && this.add(this._throttled = innerSubscribe(l, new SimpleInnerSubscriber(this)));
  }, u.prototype.tryDurationSelector = function(c) {
    try {
      return this.durationSelector(c);
    } catch (l) {
      return this.destination.error(l), null;
    }
  }, u.prototype.throttlingDone = function() {
    var c = this, l = c._throttled, v = c._trailing;
    l && l.unsubscribe(), this._throttled = void 0, v && this.send();
  }, u.prototype.notifyNext = function() {
    this.throttlingDone();
  }, u.prototype.notifyComplete = function() {
    this.throttlingDone();
  }, u;
}(SimpleOuterSubscriber);
function throttleTime(a, u, c) {
  return u === void 0 && (u = async$1), c === void 0 && (c = defaultThrottleConfig), function(l) {
    return l.lift(new ThrottleTimeOperator(a, u, c.leading, c.trailing));
  };
}
var ThrottleTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.duration = u, this.scheduler = c, this.leading = l, this.trailing = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrottleTimeSubscriber(u, this.duration, this.scheduler, this.leading, this.trailing));
  }, a;
}(), ThrottleTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var I = a.call(this, c) || this;
    return I.duration = l, I.scheduler = v, I.leading = p, I.trailing = _, I._hasTrailingValue = !1, I._trailingValue = null, I;
  }
  return u.prototype._next = function(c) {
    this.throttled ? this.trailing && (this._trailingValue = c, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this })), this.leading ? this.destination.next(c) : this.trailing && (this._trailingValue = c, this._hasTrailingValue = !0));
  }, u.prototype._complete = function() {
    this._hasTrailingValue ? (this.destination.next(this._trailingValue), this.destination.complete()) : this.destination.complete();
  }, u.prototype.clearThrottle = function() {
    var c = this.throttled;
    c && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = !1), c.unsubscribe(), this.remove(c), this.throttled = null);
  }, u;
}(Subscriber);
function dispatchNext(a) {
  var u = a.subscriber;
  u.clearThrottle();
}
function defer(a) {
  return new Observable(function(u) {
    var c;
    try {
      c = a();
    } catch (v) {
      u.error(v);
      return;
    }
    var l = c ? from(c) : empty$2();
    return l.subscribe(u);
  });
}
function timeInterval(a) {
  return a === void 0 && (a = async$1), function(u) {
    return defer(function() {
      return u.pipe(scan(function(c, l) {
        var v = c.current;
        return { value: l, current: a.now(), last: v };
      }, { current: a.now(), value: void 0, last: void 0 }), map(function(c) {
        var l = c.current, v = c.last, p = c.value;
        return new TimeInterval(p, l - v);
      }));
    });
  };
}
var TimeInterval = /* @__PURE__ */ function() {
  function a(u, c) {
    this.value = u, this.interval = c;
  }
  return a;
}(), TimeoutErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), TimeoutError = TimeoutErrorImpl;
function timeoutWith(a, u, c) {
  return c === void 0 && (c = async$1), function(l) {
    var v = isDate$1(a), p = v ? +a - c.now() : Math.abs(a);
    return l.lift(new TimeoutWithOperator(p, v, u, c));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.waitFor = u, this.absoluteTimeout = c, this.withObservable = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TimeoutWithSubscriber(u, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  }, a;
}(), TimeoutWithSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var I = a.call(this, c) || this;
    return I.absoluteTimeout = l, I.waitFor = v, I.withObservable = p, I.scheduler = _, I.scheduleTimeout(), I;
  }
  return u.dispatchTimeout = function(c) {
    var l = c.withObservable;
    c._unsubscribeAndRecycle(), c.add(innerSubscribe(l, new SimpleInnerSubscriber(c)));
  }, u.prototype.scheduleTimeout = function() {
    var c = this.action;
    c ? this.action = c.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(u.dispatchTimeout, this.waitFor, this));
  }, u.prototype._next = function(c) {
    this.absoluteTimeout || this.scheduleTimeout(), a.prototype._next.call(this, c);
  }, u.prototype._unsubscribe = function() {
    this.action = void 0, this.scheduler = null, this.withObservable = null;
  }, u;
}(SimpleOuterSubscriber);
function timeout(a, u) {
  return u === void 0 && (u = async$1), timeoutWith(a, throwError(new TimeoutError()), u);
}
function timestamp$1(a) {
  return a === void 0 && (a = async$1), map(function(u) {
    return new Timestamp$1(u, a.now());
  });
}
var Timestamp$1 = /* @__PURE__ */ function() {
  function a(u, c) {
    this.value = u, this.timestamp = c;
  }
  return a;
}();
function toArrayReducer(a, u, c) {
  return c === 0 ? [u] : (a.push(u), a);
}
function toArray$2() {
  return reduce(toArrayReducer, []);
}
function window$1(a) {
  return function(c) {
    return c.lift(new WindowOperator$1(a));
  };
}
var WindowOperator$1 = /* @__PURE__ */ function() {
  function a(u) {
    this.windowBoundaries = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new WindowSubscriber$1(u), v = c.subscribe(l);
    return v.closed || l.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(l))), v;
  }, a;
}(), WindowSubscriber$1 = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.window = new Subject(), c.next(l.window), l;
  }
  return u.prototype.notifyNext = function() {
    this.openWindow();
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype.notifyComplete = function() {
    this._complete();
  }, u.prototype._next = function(c) {
    this.window.next(c);
  }, u.prototype._error = function(c) {
    this.window.error(c), this.destination.error(c);
  }, u.prototype._complete = function() {
    this.window.complete(), this.destination.complete();
  }, u.prototype._unsubscribe = function() {
    this.window = null;
  }, u.prototype.openWindow = function() {
    var c = this.window;
    c && c.complete();
    var l = this.destination, v = this.window = new Subject();
    l.next(v);
  }, u;
}(SimpleOuterSubscriber);
function windowCount(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new WindowCountOperator(a, u));
  };
}
var WindowCountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.windowSize = u, this.startWindowEvery = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowCountSubscriber(u, this.windowSize, this.startWindowEvery));
  }, a;
}(), WindowCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.destination = c, p.windowSize = l, p.startWindowEvery = v, p.windows = [new Subject()], p.count = 0, c.next(p.windows[0]), p;
  }
  return u.prototype._next = function(c) {
    for (var l = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize, v = this.destination, p = this.windowSize, _ = this.windows, I = _.length, P = 0; P < I && !this.closed; P++)
      _[P].next(c);
    var $ = this.count - p + 1;
    if ($ >= 0 && $ % l === 0 && !this.closed && _.shift().complete(), ++this.count % l === 0 && !this.closed) {
      var F = new Subject();
      _.push(F), v.next(F);
    }
  }, u.prototype._error = function(c) {
    var l = this.windows;
    if (l)
      for (; l.length > 0 && !this.closed; )
        l.shift().error(c);
    this.destination.error(c);
  }, u.prototype._complete = function() {
    var c = this.windows;
    if (c)
      for (; c.length > 0 && !this.closed; )
        c.shift().complete();
    this.destination.complete();
  }, u.prototype._unsubscribe = function() {
    this.count = 0, this.windows = null;
  }, u;
}(Subscriber);
function windowTime(a) {
  var u = async$1, c = null, l = Number.POSITIVE_INFINITY;
  return isScheduler(arguments[3]) && (u = arguments[3]), isScheduler(arguments[2]) ? u = arguments[2] : isNumeric(arguments[2]) && (l = Number(arguments[2])), isScheduler(arguments[1]) ? u = arguments[1] : isNumeric(arguments[1]) && (c = Number(arguments[1])), function(p) {
    return p.lift(new WindowTimeOperator(a, c, l, u));
  };
}
var WindowTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.windowTimeSpan = u, this.windowCreationInterval = c, this.maxWindowSize = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowTimeSubscriber(u, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  }, a;
}(), CountedSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c._numberOfNextedValues = 0, c;
  }
  return u.prototype.next = function(c) {
    this._numberOfNextedValues++, a.prototype.next.call(this, c);
  }, Object.defineProperty(u.prototype, "numberOfNextedValues", {
    get: function() {
      return this._numberOfNextedValues;
    },
    enumerable: !0,
    configurable: !0
  }), u;
}(Subject), WindowTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, p, _) {
    var I = a.call(this, c) || this;
    I.destination = c, I.windowTimeSpan = l, I.windowCreationInterval = v, I.maxWindowSize = p, I.scheduler = _, I.windows = [];
    var P = I.openWindow();
    if (v !== null && v >= 0) {
      var $ = { subscriber: I, window: P, context: null }, F = { windowTimeSpan: l, windowCreationInterval: v, subscriber: I, scheduler: _ };
      I.add(_.schedule(dispatchWindowClose, l, $)), I.add(_.schedule(dispatchWindowCreation, v, F));
    } else {
      var H = { subscriber: I, window: P, windowTimeSpan: l };
      I.add(_.schedule(dispatchWindowTimeSpanOnly, l, H));
    }
    return I;
  }
  return u.prototype._next = function(c) {
    for (var l = this.windows, v = l.length, p = 0; p < v; p++) {
      var _ = l[p];
      _.closed || (_.next(c), _.numberOfNextedValues >= this.maxWindowSize && this.closeWindow(_));
    }
  }, u.prototype._error = function(c) {
    for (var l = this.windows; l.length > 0; )
      l.shift().error(c);
    this.destination.error(c);
  }, u.prototype._complete = function() {
    for (var c = this.windows; c.length > 0; ) {
      var l = c.shift();
      l.closed || l.complete();
    }
    this.destination.complete();
  }, u.prototype.openWindow = function() {
    var c = new CountedSubject();
    this.windows.push(c);
    var l = this.destination;
    return l.next(c), c;
  }, u.prototype.closeWindow = function(c) {
    c.complete();
    var l = this.windows;
    l.splice(l.indexOf(c), 1);
  }, u;
}(Subscriber);
function dispatchWindowTimeSpanOnly(a) {
  var u = a.subscriber, c = a.windowTimeSpan, l = a.window;
  l && u.closeWindow(l), a.window = u.openWindow(), this.schedule(a, c);
}
function dispatchWindowCreation(a) {
  var u = a.windowTimeSpan, c = a.subscriber, l = a.scheduler, v = a.windowCreationInterval, p = c.openWindow(), _ = this, I = { action: _, subscription: null }, P = { subscriber: c, window: p, context: I };
  I.subscription = l.schedule(dispatchWindowClose, u, P), _.add(I.subscription), _.schedule(a, v);
}
function dispatchWindowClose(a) {
  var u = a.subscriber, c = a.window, l = a.context;
  l && l.action && l.subscription && l.action.remove(l.subscription), u.closeWindow(c);
}
function windowToggle(a, u) {
  return function(c) {
    return c.lift(new WindowToggleOperator(a, u));
  };
}
var WindowToggleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.openings = u, this.closingSelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowToggleSubscriber(u, this.openings, this.closingSelector));
  }, a;
}(), WindowToggleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.openings = l, p.closingSelector = v, p.contexts = [], p.add(p.openSubscription = subscribeToResult(p, l, l)), p;
  }
  return u.prototype._next = function(c) {
    var l = this.contexts;
    if (l)
      for (var v = l.length, p = 0; p < v; p++)
        l[p].window.next(c);
  }, u.prototype._error = function(c) {
    var l = this.contexts;
    if (this.contexts = null, l)
      for (var v = l.length, p = -1; ++p < v; ) {
        var _ = l[p];
        _.window.error(c), _.subscription.unsubscribe();
      }
    a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    var c = this.contexts;
    if (this.contexts = null, c)
      for (var l = c.length, v = -1; ++v < l; ) {
        var p = c[v];
        p.window.complete(), p.subscription.unsubscribe();
      }
    a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    var c = this.contexts;
    if (this.contexts = null, c)
      for (var l = c.length, v = -1; ++v < l; ) {
        var p = c[v];
        p.window.unsubscribe(), p.subscription.unsubscribe();
      }
  }, u.prototype.notifyNext = function(c, l, v, p, _) {
    if (c === this.openings) {
      var I = void 0;
      try {
        var P = this.closingSelector;
        I = P(l);
      } catch (ee) {
        return this.error(ee);
      }
      var $ = new Subject(), F = new Subscription(), H = { window: $, subscription: F };
      this.contexts.push(H);
      var j = subscribeToResult(this, I, H);
      j.closed ? this.closeWindow(this.contexts.length - 1) : (j.context = H, F.add(j)), this.destination.next($);
    } else
      this.closeWindow(this.contexts.indexOf(c));
  }, u.prototype.notifyError = function(c) {
    this.error(c);
  }, u.prototype.notifyComplete = function(c) {
    c !== this.openSubscription && this.closeWindow(this.contexts.indexOf(c.context));
  }, u.prototype.closeWindow = function(c) {
    if (c !== -1) {
      var l = this.contexts, v = l[c], p = v.window, _ = v.subscription;
      l.splice(c, 1), p.complete(), _.unsubscribe();
    }
  }, u;
}(OuterSubscriber);
function windowWhen(a) {
  return function(c) {
    return c.lift(new WindowOperator(a));
  };
}
var WindowOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowSubscriber(u, this.closingSelector));
  }, a;
}(), WindowSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.destination = c, v.closingSelector = l, v.openWindow(), v;
  }
  return u.prototype.notifyNext = function(c, l, v, p, _) {
    this.openWindow(_);
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype.notifyComplete = function(c) {
    this.openWindow(c);
  }, u.prototype._next = function(c) {
    this.window.next(c);
  }, u.prototype._error = function(c) {
    this.window.error(c), this.destination.error(c), this.unsubscribeClosingNotification();
  }, u.prototype._complete = function() {
    this.window.complete(), this.destination.complete(), this.unsubscribeClosingNotification();
  }, u.prototype.unsubscribeClosingNotification = function() {
    this.closingNotification && this.closingNotification.unsubscribe();
  }, u.prototype.openWindow = function(c) {
    c === void 0 && (c = null), c && (this.remove(c), c.unsubscribe());
    var l = this.window;
    l && l.complete();
    var v = this.window = new Subject();
    this.destination.next(v);
    var p;
    try {
      var _ = this.closingSelector;
      p = _();
    } catch (I) {
      this.destination.error(I), this.window.error(I);
      return;
    }
    this.add(this.closingNotification = subscribeToResult(this, p));
  }, u;
}(OuterSubscriber);
function withLatestFrom() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    var l;
    typeof a[a.length - 1] == "function" && (l = a.pop());
    var v = a;
    return c.lift(new WithLatestFromOperator(v, l));
  };
}
var WithLatestFromOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.observables = u, this.project = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WithLatestFromSubscriber(u, this.observables, this.project));
  }, a;
}(), WithLatestFromSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    p.observables = l, p.project = v, p.toRespond = [];
    var _ = l.length;
    p.values = new Array(_);
    for (var I = 0; I < _; I++)
      p.toRespond.push(I);
    for (var I = 0; I < _; I++) {
      var P = l[I];
      p.add(subscribeToResult(p, P, void 0, I));
    }
    return p;
  }
  return u.prototype.notifyNext = function(c, l, v) {
    this.values[v] = l;
    var p = this.toRespond;
    if (p.length > 0) {
      var _ = p.indexOf(v);
      _ !== -1 && p.splice(_, 1);
    }
  }, u.prototype.notifyComplete = function() {
  }, u.prototype._next = function(c) {
    if (this.toRespond.length === 0) {
      var l = [c].concat(this.values);
      this.project ? this._tryProject(l) : this.destination.next(l);
    }
  }, u.prototype._tryProject = function(c) {
    var l;
    try {
      l = this.project.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function zip$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return typeof c == "function" && a.pop(), fromArray$1(a, void 0).lift(new ZipOperator(c));
}
var ZipOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.resultSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ZipSubscriber(u, this.resultSelector));
  }, a;
}(), ZipSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.resultSelector = l, p.iterators = [], p.active = 0, p.resultSelector = typeof l == "function" ? l : void 0, p;
  }
  return u.prototype._next = function(c) {
    var l = this.iterators;
    isArray$5(c) ? l.push(new StaticArrayIterator(c)) : typeof c[iterator] == "function" ? l.push(new StaticIterator(c[iterator]())) : l.push(new ZipBufferIterator(this.destination, this, c));
  }, u.prototype._complete = function() {
    var c = this.iterators, l = c.length;
    if (this.unsubscribe(), l === 0) {
      this.destination.complete();
      return;
    }
    this.active = l;
    for (var v = 0; v < l; v++) {
      var p = c[v];
      if (p.stillUnsubscribed) {
        var _ = this.destination;
        _.add(p.subscribe());
      } else
        this.active--;
    }
  }, u.prototype.notifyInactive = function() {
    this.active--, this.active === 0 && this.destination.complete();
  }, u.prototype.checkIterators = function() {
    for (var c = this.iterators, l = c.length, v = this.destination, p = 0; p < l; p++) {
      var _ = c[p];
      if (typeof _.hasValue == "function" && !_.hasValue())
        return;
    }
    for (var I = !1, P = [], p = 0; p < l; p++) {
      var _ = c[p], $ = _.next();
      if (_.hasCompleted() && (I = !0), $.done) {
        v.complete();
        return;
      }
      P.push($.value);
    }
    this.resultSelector ? this._tryresultSelector(P) : v.next(P), I && v.complete();
  }, u.prototype._tryresultSelector = function(c) {
    var l;
    try {
      l = this.resultSelector.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(Subscriber), StaticIterator = /* @__PURE__ */ function() {
  function a(u) {
    this.iterator = u, this.nextResult = u.next();
  }
  return a.prototype.hasValue = function() {
    return !0;
  }, a.prototype.next = function() {
    var u = this.nextResult;
    return this.nextResult = this.iterator.next(), u;
  }, a.prototype.hasCompleted = function() {
    var u = this.nextResult;
    return !!(u && u.done);
  }, a;
}(), StaticArrayIterator = /* @__PURE__ */ function() {
  function a(u) {
    this.array = u, this.index = 0, this.length = 0, this.length = u.length;
  }
  return a.prototype[iterator] = function() {
    return this;
  }, a.prototype.next = function(u) {
    var c = this.index++, l = this.array;
    return c < this.length ? { value: l[c], done: !1 } : { value: null, done: !0 };
  }, a.prototype.hasValue = function() {
    return this.array.length > this.index;
  }, a.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  }, a;
}(), ZipBufferIterator = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var p = a.call(this, c) || this;
    return p.parent = l, p.observable = v, p.stillUnsubscribed = !0, p.buffer = [], p.isComplete = !1, p;
  }
  return u.prototype[iterator] = function() {
    return this;
  }, u.prototype.next = function() {
    var c = this.buffer;
    return c.length === 0 && this.isComplete ? { value: null, done: !0 } : { value: c.shift(), done: !1 };
  }, u.prototype.hasValue = function() {
    return this.buffer.length > 0;
  }, u.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  }, u.prototype.notifyComplete = function() {
    this.buffer.length > 0 ? (this.isComplete = !0, this.parent.notifyInactive()) : this.destination.complete();
  }, u.prototype.notifyNext = function(c) {
    this.buffer.push(c), this.parent.checkIterators();
  }, u.prototype.subscribe = function() {
    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
  }, u;
}(SimpleOuterSubscriber);
function zip() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(l) {
    return l.lift.call(zip$1.apply(void 0, [l].concat(a)));
  };
}
function zipAll(a) {
  return function(u) {
    return u.lift(new ZipOperator(a));
  };
}
const operators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audit,
  auditTime,
  buffer: buffer$2,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  concat,
  concatAll,
  concatMap,
  concatMapTo,
  count,
  debounce: debounce$1,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every: every$1,
  exhaust,
  exhaustMap,
  expand,
  filter,
  finalize,
  find: find$2,
  findIndex,
  first,
  flatMap,
  groupBy,
  ignoreElements,
  isEmpty,
  last: last$1,
  map,
  mapTo,
  materialize,
  max: max$1,
  merge: merge$1,
  mergeAll,
  mergeMap,
  mergeMapTo,
  mergeScan,
  min,
  multicast,
  observeOn,
  onErrorResumeNext,
  pairwise,
  partition,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  reduce,
  refCount,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  sample,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp: timestamp$1,
  toArray: toArray$2,
  window: window$1,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll
}, Symbol.toStringTag, { value: "Module" })), require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(operators);
var struct = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(Z, de, he, pe) {
    pe === void 0 && (pe = he), Object.defineProperty(Z, pe, { enumerable: !0, get: function() {
      return de[he];
    } });
  } : function(Z, de, he, pe) {
    pe === void 0 && (pe = he), Z[pe] = de[he];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(Z, de) {
    Object.defineProperty(Z, "default", { enumerable: !0, value: de });
  } : function(Z, de) {
    Z.default = de;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(Z) {
    if (Z && Z.__esModule)
      return Z;
    var de = {};
    if (Z != null)
      for (var he in Z)
        he !== "default" && Object.hasOwnProperty.call(Z, he) && u(de, Z, he);
    return c(de, Z), de;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(Z) {
    return Z && Z.__esModule ? Z : { default: Z };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal);
  a.protobufPackage = "google.protobuf";
  var I;
  (function(Z) {
    Z.NULL_VALUE = "NULL_VALUE";
  })(I = a.NullValue || (a.NullValue = {}));
  function P(Z) {
    switch (Z) {
      case 0:
      case "NULL_VALUE":
        return I.NULL_VALUE;
      default:
        throw new ie.Error("Unrecognized enum value " + Z + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = P;
  function $(Z) {
    switch (Z) {
      case I.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  a.nullValueToJSON = $;
  function F(Z) {
    switch (Z) {
      case I.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  a.nullValueToNumber = F;
  function H() {
    return { fields: {} };
  }
  a.Struct = {
    encode(Z, de = _.Writer.create()) {
      return Object.entries(Z.fields).forEach(([he, pe]) => {
        pe !== void 0 && a.Struct_FieldsEntry.encode({ key: he, value: pe }, de.uint32(10).fork()).ldelim();
      }), de;
    },
    decode(Z, de) {
      const he = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let pe = de === void 0 ? he.len : he.pos + de;
      const be = H();
      for (; he.pos < pe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            const _e = a.Struct_FieldsEntry.decode(he, he.uint32());
            _e.value !== void 0 && (be.fields[_e.key] = _e.value);
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(Z) {
      return {
        fields: Q(Z.fields) ? Object.entries(Z.fields).reduce((de, [he, pe]) => (de[he] = pe, de), {}) : {}
      };
    },
    toJSON(Z) {
      const de = {};
      return de.fields = {}, Z.fields && Object.entries(Z.fields).forEach(([he, pe]) => {
        de.fields[he] = pe;
      }), de;
    },
    fromPartial(Z) {
      var de;
      const he = H();
      return he.fields = Object.entries((de = Z.fields) !== null && de !== void 0 ? de : {}).reduce((pe, [be, ke]) => (ke !== void 0 && (pe[be] = ke), pe), {}), he;
    },
    wrap(Z) {
      const de = H();
      return Z !== void 0 && Object.keys(Z).forEach((he) => {
        de.fields[he] = Z[he];
      }), de;
    },
    unwrap(Z) {
      const de = {};
      return Object.keys(Z.fields).forEach((he) => {
        de[he] = Z.fields[he];
      }), de;
    }
  };
  function j() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(Z, de = _.Writer.create()) {
      return Z.key !== "" && de.uint32(10).string(Z.key), Z.value !== void 0 && a.Value.encode(a.Value.wrap(Z.value), de.uint32(18).fork()).ldelim(), de;
    },
    decode(Z, de) {
      const he = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let pe = de === void 0 ? he.len : he.pos + de;
      const be = j();
      for (; he.pos < pe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            be.key = he.string();
            break;
          case 2:
            be.value = a.Value.unwrap(a.Value.decode(he, he.uint32()));
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(Z) {
      return {
        key: ne(Z.key) ? String(Z.key) : "",
        value: ne(Z == null ? void 0 : Z.value) ? Z.value : void 0
      };
    },
    toJSON(Z) {
      const de = {};
      return Z.key !== void 0 && (de.key = Z.key), Z.value !== void 0 && (de.value = Z.value), de;
    },
    fromPartial(Z) {
      var de, he;
      const pe = j();
      return pe.key = (de = Z.key) !== null && de !== void 0 ? de : "", pe.value = (he = Z.value) !== null && he !== void 0 ? he : void 0, pe;
    }
  };
  function ee() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(Z, de = _.Writer.create()) {
      return Z.nullValue !== void 0 && de.uint32(8).int32(F(Z.nullValue)), Z.numberValue !== void 0 && de.uint32(17).double(Z.numberValue), Z.stringValue !== void 0 && de.uint32(26).string(Z.stringValue), Z.boolValue !== void 0 && de.uint32(32).bool(Z.boolValue), Z.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(Z.structValue), de.uint32(42).fork()).ldelim(), Z.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(Z.listValue), de.uint32(50).fork()).ldelim(), de;
    },
    decode(Z, de) {
      const he = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let pe = de === void 0 ? he.len : he.pos + de;
      const be = ee();
      for (; he.pos < pe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            be.nullValue = P(he.int32());
            break;
          case 2:
            be.numberValue = he.double();
            break;
          case 3:
            be.stringValue = he.string();
            break;
          case 4:
            be.boolValue = he.bool();
            break;
          case 5:
            be.structValue = a.Struct.unwrap(a.Struct.decode(he, he.uint32()));
            break;
          case 6:
            be.listValue = a.ListValue.unwrap(a.ListValue.decode(he, he.uint32()));
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(Z) {
      return {
        nullValue: ne(Z.nullValue) ? P(Z.nullValue) : void 0,
        numberValue: ne(Z.numberValue) ? Number(Z.numberValue) : void 0,
        stringValue: ne(Z.stringValue) ? String(Z.stringValue) : void 0,
        boolValue: ne(Z.boolValue) ? !!Z.boolValue : void 0,
        structValue: Q(Z.structValue) ? Z.structValue : void 0,
        listValue: Array.isArray(Z.listValue) ? [...Z.listValue] : void 0
      };
    },
    toJSON(Z) {
      const de = {};
      return Z.nullValue !== void 0 && (de.nullValue = Z.nullValue !== void 0 ? $(Z.nullValue) : void 0), Z.numberValue !== void 0 && (de.numberValue = Z.numberValue), Z.stringValue !== void 0 && (de.stringValue = Z.stringValue), Z.boolValue !== void 0 && (de.boolValue = Z.boolValue), Z.structValue !== void 0 && (de.structValue = Z.structValue), Z.listValue !== void 0 && (de.listValue = Z.listValue), de;
    },
    fromPartial(Z) {
      var de, he, pe, be, ke, _e;
      const q = ee();
      return q.nullValue = (de = Z.nullValue) !== null && de !== void 0 ? de : void 0, q.numberValue = (he = Z.numberValue) !== null && he !== void 0 ? he : void 0, q.stringValue = (pe = Z.stringValue) !== null && pe !== void 0 ? pe : void 0, q.boolValue = (be = Z.boolValue) !== null && be !== void 0 ? be : void 0, q.structValue = (ke = Z.structValue) !== null && ke !== void 0 ? ke : void 0, q.listValue = (_e = Z.listValue) !== null && _e !== void 0 ? _e : void 0, q;
    },
    wrap(Z) {
      const de = ee();
      if (Z === null)
        de.nullValue = I.NULL_VALUE;
      else if (typeof Z == "boolean")
        de.boolValue = Z;
      else if (typeof Z == "number")
        de.numberValue = Z;
      else if (typeof Z == "string")
        de.stringValue = Z;
      else if (Array.isArray(Z))
        de.listValue = Z;
      else if (typeof Z == "object")
        de.structValue = Z;
      else if (typeof Z < "u")
        throw new Error("Unsupported any value type: " + typeof Z);
      return de;
    },
    unwrap(Z) {
      if ((Z == null ? void 0 : Z.stringValue) !== void 0)
        return Z.stringValue;
      if ((Z == null ? void 0 : Z.numberValue) !== void 0)
        return Z.numberValue;
      if ((Z == null ? void 0 : Z.boolValue) !== void 0)
        return Z.boolValue;
      if ((Z == null ? void 0 : Z.structValue) !== void 0)
        return Z.structValue;
      if ((Z == null ? void 0 : Z.listValue) !== void 0)
        return Z.listValue;
      if ((Z == null ? void 0 : Z.nullValue) !== void 0)
        return null;
    }
  };
  function X() {
    return { values: [] };
  }
  a.ListValue = {
    encode(Z, de = _.Writer.create()) {
      for (const he of Z.values)
        a.Value.encode(a.Value.wrap(he), de.uint32(10).fork()).ldelim();
      return de;
    },
    decode(Z, de) {
      const he = Z instanceof _.Reader ? Z : new _.Reader(Z);
      let pe = de === void 0 ? he.len : he.pos + de;
      const be = X();
      for (; he.pos < pe; ) {
        const ke = he.uint32();
        switch (ke >>> 3) {
          case 1:
            be.values.push(a.Value.unwrap(a.Value.decode(he, he.uint32())));
            break;
          default:
            he.skipType(ke & 7);
            break;
        }
      }
      return be;
    },
    fromJSON(Z) {
      return {
        values: Array.isArray(Z == null ? void 0 : Z.values) ? [...Z.values] : []
      };
    },
    toJSON(Z) {
      const de = {};
      return Z.values ? de.values = Z.values.map((he) => he) : de.values = [], de;
    },
    fromPartial(Z) {
      var de;
      const he = X();
      return he.values = ((de = Z.values) === null || de === void 0 ? void 0 : de.map((pe) => pe)) || [], he;
    },
    wrap(Z) {
      const de = X();
      return de.values = Z ?? [], de;
    },
    unwrap(Z) {
      return Z.values;
    }
  };
  var ie = (() => {
    if (typeof ie < "u")
      return ie;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function Q(Z) {
    return typeof Z == "object" && Z !== null;
  }
  function ne(Z) {
    return Z != null;
  }
})(struct);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(q, z, C, b) {
    b === void 0 && (b = C), Object.defineProperty(q, b, { enumerable: !0, get: function() {
      return z[C];
    } });
  } : function(q, z, C, b) {
    b === void 0 && (b = C), q[b] = z[C];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(q, z) {
    Object.defineProperty(q, "default", { enumerable: !0, value: z });
  } : function(q, z) {
    q.default = z;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(q) {
    if (q && q.__esModule)
      return q;
    var z = {};
    if (q != null)
      for (var C in q)
        C !== "default" && Object.hasOwnProperty.call(q, C) && u(z, q, C);
    return c(z, q), z;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(q) {
    return q && q.__esModule ? q : { default: q };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.EventServiceDefinition = a.EventServiceClientImpl = a.EventsStreamResponse = a.EventsStreamRequest = a.EventsStreamReconnectRequest = a.EventsStreamError = a.SubscribePayload = a.PublishEventResponse = a.PublishEventRequest = a.EventTarget = a.eventsStreamMessageTypeToNumber = a.eventsStreamMessageTypeToJSON = a.eventsStreamMessageTypeFromJSON = a.EventsStreamMessageType = a.protobufPackage = void 0;
  const p = v(umdExports), _ = l(minimal), I = require$$2$1, P = struct;
  a.protobufPackage = "apis.event.v2";
  var $;
  (function(q) {
    q.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED = "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED", q.EVENTS_STREAM_MESSAGE_TYPE_PING = "EVENTS_STREAM_MESSAGE_TYPE_PING", q.EVENTS_STREAM_MESSAGE_TYPE_ERROR = "EVENTS_STREAM_MESSAGE_TYPE_ERROR", q.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED = "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED", q.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED = "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED", q.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED = "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
  })($ = a.EventsStreamMessageType || (a.EventsStreamMessageType = {}));
  function F(q) {
    switch (q) {
      case 0:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED":
        return $.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED;
      case 1:
      case "EVENTS_STREAM_MESSAGE_TYPE_PING":
        return $.EVENTS_STREAM_MESSAGE_TYPE_PING;
      case 2:
      case "EVENTS_STREAM_MESSAGE_TYPE_ERROR":
        return $.EVENTS_STREAM_MESSAGE_TYPE_ERROR;
      case 3:
      case "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED":
        return $.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED;
      case 4:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED":
        return $.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED;
      case 5:
      case "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED":
        return $.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED;
      default:
        throw new be.Error("Unrecognized enum value " + q + " for enum EventsStreamMessageType");
    }
  }
  a.eventsStreamMessageTypeFromJSON = F;
  function H(q) {
    switch (q) {
      case $.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED";
      case $.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return "EVENTS_STREAM_MESSAGE_TYPE_PING";
      case $.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return "EVENTS_STREAM_MESSAGE_TYPE_ERROR";
      case $.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED";
      case $.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED";
      case $.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
      default:
        return "UNKNOWN";
    }
  }
  a.eventsStreamMessageTypeToJSON = H;
  function j(q) {
    switch (q) {
      case $.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return 0;
      case $.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return 1;
      case $.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return 2;
      case $.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return 3;
      case $.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return 4;
      case $.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return 5;
      default:
        return 0;
    }
  }
  a.eventsStreamMessageTypeToNumber = j;
  function ee() {
    return { collectionId: void 0, projectId: void 0, layoutId: void 0 };
  }
  a.EventTarget = {
    encode(q, z = _.Writer.create()) {
      return q.collectionId !== void 0 && z.uint32(42).string(q.collectionId), q.projectId !== void 0 && z.uint32(34).string(q.projectId), q.layoutId !== void 0 && z.uint32(10).string(q.layoutId), z;
    },
    decode(q, z) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = ee();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 5:
            E.collectionId = C.string();
            break;
          case 4:
            E.projectId = C.string();
            break;
          case 1:
            E.layoutId = C.string();
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        collectionId: _e(q.collectionId) ? String(q.collectionId) : void 0,
        projectId: _e(q.projectId) ? String(q.projectId) : void 0,
        layoutId: _e(q.layoutId) ? String(q.layoutId) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.collectionId !== void 0 && (z.collectionId = q.collectionId), q.projectId !== void 0 && (z.projectId = q.projectId), q.layoutId !== void 0 && (z.layoutId = q.layoutId), z;
    },
    fromPartial(q) {
      var z, C, b;
      const E = ee();
      return E.collectionId = (z = q.collectionId) !== null && z !== void 0 ? z : void 0, E.projectId = (C = q.projectId) !== null && C !== void 0 ? C : void 0, E.layoutId = (b = q.layoutId) !== null && b !== void 0 ? b : void 0, E;
    }
  };
  function X() {
    return {
      name: "",
      payload: void 0,
      requestMetadata: void 0,
      target: void 0
    };
  }
  a.PublishEventRequest = {
    encode(q, z = _.Writer.create()) {
      return q.name !== "" && z.uint32(10).string(q.name), q.payload !== void 0 && P.Struct.encode(P.Struct.wrap(q.payload), z.uint32(18).fork()).ldelim(), q.requestMetadata !== void 0 && P.Value.encode(P.Value.wrap(q.requestMetadata), z.uint32(34).fork()).ldelim(), q.target !== void 0 && a.EventTarget.encode(q.target, z.uint32(26).fork()).ldelim(), z;
    },
    decode(q, z) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = X();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.name = C.string();
            break;
          case 2:
            E.payload = P.Struct.unwrap(P.Struct.decode(C, C.uint32()));
            break;
          case 4:
            E.requestMetadata = P.Value.unwrap(P.Value.decode(C, C.uint32()));
            break;
          case 3:
            E.target = a.EventTarget.decode(C, C.uint32());
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: _e(q.name) ? String(q.name) : "",
        payload: ke(q.payload) ? q.payload : void 0,
        requestMetadata: _e(q == null ? void 0 : q.requestMetadata) ? q.requestMetadata : void 0,
        target: _e(q.target) ? a.EventTarget.fromJSON(q.target) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.name !== void 0 && (z.name = q.name), q.payload !== void 0 && (z.payload = q.payload), q.requestMetadata !== void 0 && (z.requestMetadata = q.requestMetadata), q.target !== void 0 && (z.target = q.target ? a.EventTarget.toJSON(q.target) : void 0), z;
    },
    fromPartial(q) {
      var z, C, b;
      const E = X();
      return E.name = (z = q.name) !== null && z !== void 0 ? z : "", E.payload = (C = q.payload) !== null && C !== void 0 ? C : void 0, E.requestMetadata = (b = q.requestMetadata) !== null && b !== void 0 ? b : void 0, E.target = q.target !== void 0 && q.target !== null ? a.EventTarget.fromPartial(q.target) : void 0, E;
    }
  };
  function ie() {
    return {
      name: "",
      payload: void 0,
      target: void 0,
      requestMetadata: void 0,
      id: ""
    };
  }
  a.PublishEventResponse = {
    encode(q, z = _.Writer.create()) {
      return q.name !== "" && z.uint32(10).string(q.name), q.payload !== void 0 && P.Struct.encode(P.Struct.wrap(q.payload), z.uint32(18).fork()).ldelim(), q.target !== void 0 && a.EventTarget.encode(q.target, z.uint32(26).fork()).ldelim(), q.requestMetadata !== void 0 && P.Value.encode(P.Value.wrap(q.requestMetadata), z.uint32(34).fork()).ldelim(), q.id !== "" && z.uint32(42).string(q.id), z;
    },
    decode(q, z) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = ie();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.name = C.string();
            break;
          case 2:
            E.payload = P.Struct.unwrap(P.Struct.decode(C, C.uint32()));
            break;
          case 3:
            E.target = a.EventTarget.decode(C, C.uint32());
            break;
          case 4:
            E.requestMetadata = P.Value.unwrap(P.Value.decode(C, C.uint32()));
            break;
          case 5:
            E.id = C.string();
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: _e(q.name) ? String(q.name) : "",
        payload: ke(q.payload) ? q.payload : void 0,
        target: _e(q.target) ? a.EventTarget.fromJSON(q.target) : void 0,
        requestMetadata: _e(q == null ? void 0 : q.requestMetadata) ? q.requestMetadata : void 0,
        id: _e(q.id) ? String(q.id) : ""
      };
    },
    toJSON(q) {
      const z = {};
      return q.name !== void 0 && (z.name = q.name), q.payload !== void 0 && (z.payload = q.payload), q.target !== void 0 && (z.target = q.target ? a.EventTarget.toJSON(q.target) : void 0), q.requestMetadata !== void 0 && (z.requestMetadata = q.requestMetadata), q.id !== void 0 && (z.id = q.id), z;
    },
    fromPartial(q) {
      var z, C, b, E;
      const k = ie();
      return k.name = (z = q.name) !== null && z !== void 0 ? z : "", k.payload = (C = q.payload) !== null && C !== void 0 ? C : void 0, k.target = q.target !== void 0 && q.target !== null ? a.EventTarget.fromPartial(q.target) : void 0, k.requestMetadata = (b = q.requestMetadata) !== null && b !== void 0 ? b : void 0, k.id = (E = q.id) !== null && E !== void 0 ? E : "", k;
    }
  };
  function Q() {
    return { name: "", target: void 0 };
  }
  a.SubscribePayload = {
    encode(q, z = _.Writer.create()) {
      return q.name !== "" && z.uint32(10).string(q.name), q.target !== void 0 && a.EventTarget.encode(q.target, z.uint32(18).fork()).ldelim(), z;
    },
    decode(q, z) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = Q();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.name = C.string();
            break;
          case 2:
            E.target = a.EventTarget.decode(C, C.uint32());
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: _e(q.name) ? String(q.name) : "",
        target: _e(q.target) ? a.EventTarget.fromJSON(q.target) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.name !== void 0 && (z.name = q.name), q.target !== void 0 && (z.target = q.target ? a.EventTarget.toJSON(q.target) : void 0), z;
    },
    fromPartial(q) {
      var z;
      const C = Q();
      return C.name = (z = q.name) !== null && z !== void 0 ? z : "", C.target = q.target !== void 0 && q.target !== null ? a.EventTarget.fromPartial(q.target) : void 0, C;
    }
  };
  function ne() {
    return { code: 0, message: "" };
  }
  a.EventsStreamError = {
    encode(q, z = _.Writer.create()) {
      return q.code !== 0 && z.uint32(8).int32(q.code), q.message !== "" && z.uint32(18).string(q.message), z;
    },
    decode(q, z) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = ne();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.code = C.int32();
            break;
          case 2:
            E.message = C.string();
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        code: _e(q.code) ? Number(q.code) : 0,
        message: _e(q.message) ? String(q.message) : ""
      };
    },
    toJSON(q) {
      const z = {};
      return q.code !== void 0 && (z.code = Math.round(q.code)), q.message !== void 0 && (z.message = q.message), z;
    },
    fromPartial(q) {
      var z, C;
      const b = ne();
      return b.code = (z = q.code) !== null && z !== void 0 ? z : 0, b.message = (C = q.message) !== null && C !== void 0 ? C : "", b;
    }
  };
  function Z() {
    return { reauthenticate: !1, beforeTimestamp: "" };
  }
  a.EventsStreamReconnectRequest = {
    encode(q, z = _.Writer.create()) {
      return q.reauthenticate === !0 && z.uint32(8).bool(q.reauthenticate), q.beforeTimestamp !== "" && z.uint32(18).string(q.beforeTimestamp), z;
    },
    decode(q, z) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = Z();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.reauthenticate = C.bool();
            break;
          case 2:
            E.beforeTimestamp = C.string();
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        reauthenticate: _e(q.reauthenticate) ? !!q.reauthenticate : !1,
        beforeTimestamp: _e(q.beforeTimestamp) ? String(q.beforeTimestamp) : ""
      };
    },
    toJSON(q) {
      const z = {};
      return q.reauthenticate !== void 0 && (z.reauthenticate = q.reauthenticate), q.beforeTimestamp !== void 0 && (z.beforeTimestamp = q.beforeTimestamp), z;
    },
    fromPartial(q) {
      var z, C;
      const b = Z();
      return b.reauthenticate = (z = q.reauthenticate) !== null && z !== void 0 ? z : !1, b.beforeTimestamp = (C = q.beforeTimestamp) !== null && C !== void 0 ? C : "", b;
    }
  };
  function de() {
    return {
      correlationId: void 0,
      subscribe: void 0,
      unsubscribe: void 0,
      publish: void 0,
      ping: void 0
    };
  }
  a.EventsStreamRequest = {
    encode(q, z = _.Writer.create()) {
      return q.correlationId !== void 0 && z.uint32(10).string(q.correlationId), q.subscribe !== void 0 && a.SubscribePayload.encode(q.subscribe, z.uint32(802).fork()).ldelim(), q.unsubscribe !== void 0 && a.SubscribePayload.encode(q.unsubscribe, z.uint32(810).fork()).ldelim(), q.publish !== void 0 && a.PublishEventRequest.encode(q.publish, z.uint32(818).fork()).ldelim(), q.ping !== void 0 && z.uint32(826).string(q.ping), z;
    },
    decode(q, z) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = de();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.correlationId = C.string();
            break;
          case 100:
            E.subscribe = a.SubscribePayload.decode(C, C.uint32());
            break;
          case 101:
            E.unsubscribe = a.SubscribePayload.decode(C, C.uint32());
            break;
          case 102:
            E.publish = a.PublishEventRequest.decode(C, C.uint32());
            break;
          case 103:
            E.ping = C.string();
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        correlationId: _e(q.correlationId) ? String(q.correlationId) : void 0,
        subscribe: _e(q.subscribe) ? a.SubscribePayload.fromJSON(q.subscribe) : void 0,
        unsubscribe: _e(q.unsubscribe) ? a.SubscribePayload.fromJSON(q.unsubscribe) : void 0,
        publish: _e(q.publish) ? a.PublishEventRequest.fromJSON(q.publish) : void 0,
        ping: _e(q.ping) ? String(q.ping) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.correlationId !== void 0 && (z.correlationId = q.correlationId), q.subscribe !== void 0 && (z.subscribe = q.subscribe ? a.SubscribePayload.toJSON(q.subscribe) : void 0), q.unsubscribe !== void 0 && (z.unsubscribe = q.unsubscribe ? a.SubscribePayload.toJSON(q.unsubscribe) : void 0), q.publish !== void 0 && (z.publish = q.publish ? a.PublishEventRequest.toJSON(q.publish) : void 0), q.ping !== void 0 && (z.ping = q.ping), z;
    },
    fromPartial(q) {
      var z, C;
      const b = de();
      return b.correlationId = (z = q.correlationId) !== null && z !== void 0 ? z : void 0, b.subscribe = q.subscribe !== void 0 && q.subscribe !== null ? a.SubscribePayload.fromPartial(q.subscribe) : void 0, b.unsubscribe = q.unsubscribe !== void 0 && q.unsubscribe !== null ? a.SubscribePayload.fromPartial(q.unsubscribe) : void 0, b.publish = q.publish !== void 0 && q.publish !== null ? a.PublishEventRequest.fromPartial(q.publish) : void 0, b.ping = (C = q.ping) !== null && C !== void 0 ? C : void 0, b;
    }
  };
  function he() {
    return {
      correlationId: void 0,
      sessionId: void 0,
      event: void 0,
      pong: void 0,
      error: void 0,
      subscribed: void 0,
      unsubscribed: void 0,
      published: void 0,
      reconnectBefore: void 0
    };
  }
  a.EventsStreamResponse = {
    encode(q, z = _.Writer.create()) {
      return q.correlationId !== void 0 && z.uint32(18).string(q.correlationId), q.sessionId !== void 0 && z.uint32(26).string(q.sessionId), q.event !== void 0 && a.PublishEventResponse.encode(q.event, z.uint32(802).fork()).ldelim(), q.pong !== void 0 && z.uint32(1602).string(q.pong), q.error !== void 0 && a.EventsStreamError.encode(q.error, z.uint32(1610).fork()).ldelim(), q.subscribed !== void 0 && a.SubscribePayload.encode(q.subscribed, z.uint32(1618).fork()).ldelim(), q.unsubscribed !== void 0 && a.SubscribePayload.encode(q.unsubscribed, z.uint32(1626).fork()).ldelim(), q.published !== void 0 && a.PublishEventResponse.encode(q.published, z.uint32(1634).fork()).ldelim(), q.reconnectBefore !== void 0 && a.EventsStreamReconnectRequest.encode(q.reconnectBefore, z.uint32(1642).fork()).ldelim(), z;
    },
    decode(q, z) {
      const C = q instanceof _.Reader ? q : new _.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = he();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 2:
            E.correlationId = C.string();
            break;
          case 3:
            E.sessionId = C.string();
            break;
          case 100:
            E.event = a.PublishEventResponse.decode(C, C.uint32());
            break;
          case 200:
            E.pong = C.string();
            break;
          case 201:
            E.error = a.EventsStreamError.decode(C, C.uint32());
            break;
          case 202:
            E.subscribed = a.SubscribePayload.decode(C, C.uint32());
            break;
          case 203:
            E.unsubscribed = a.SubscribePayload.decode(C, C.uint32());
            break;
          case 204:
            E.published = a.PublishEventResponse.decode(C, C.uint32());
            break;
          case 205:
            E.reconnectBefore = a.EventsStreamReconnectRequest.decode(C, C.uint32());
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        correlationId: _e(q.correlationId) ? String(q.correlationId) : void 0,
        sessionId: _e(q.sessionId) ? String(q.sessionId) : void 0,
        event: _e(q.event) ? a.PublishEventResponse.fromJSON(q.event) : void 0,
        pong: _e(q.pong) ? String(q.pong) : void 0,
        error: _e(q.error) ? a.EventsStreamError.fromJSON(q.error) : void 0,
        subscribed: _e(q.subscribed) ? a.SubscribePayload.fromJSON(q.subscribed) : void 0,
        unsubscribed: _e(q.unsubscribed) ? a.SubscribePayload.fromJSON(q.unsubscribed) : void 0,
        published: _e(q.published) ? a.PublishEventResponse.fromJSON(q.published) : void 0,
        reconnectBefore: _e(q.reconnectBefore) ? a.EventsStreamReconnectRequest.fromJSON(q.reconnectBefore) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.correlationId !== void 0 && (z.correlationId = q.correlationId), q.sessionId !== void 0 && (z.sessionId = q.sessionId), q.event !== void 0 && (z.event = q.event ? a.PublishEventResponse.toJSON(q.event) : void 0), q.pong !== void 0 && (z.pong = q.pong), q.error !== void 0 && (z.error = q.error ? a.EventsStreamError.toJSON(q.error) : void 0), q.subscribed !== void 0 && (z.subscribed = q.subscribed ? a.SubscribePayload.toJSON(q.subscribed) : void 0), q.unsubscribed !== void 0 && (z.unsubscribed = q.unsubscribed ? a.SubscribePayload.toJSON(q.unsubscribed) : void 0), q.published !== void 0 && (z.published = q.published ? a.PublishEventResponse.toJSON(q.published) : void 0), q.reconnectBefore !== void 0 && (z.reconnectBefore = q.reconnectBefore ? a.EventsStreamReconnectRequest.toJSON(q.reconnectBefore) : void 0), z;
    },
    fromPartial(q) {
      var z, C, b;
      const E = he();
      return E.correlationId = (z = q.correlationId) !== null && z !== void 0 ? z : void 0, E.sessionId = (C = q.sessionId) !== null && C !== void 0 ? C : void 0, E.event = q.event !== void 0 && q.event !== null ? a.PublishEventResponse.fromPartial(q.event) : void 0, E.pong = (b = q.pong) !== null && b !== void 0 ? b : void 0, E.error = q.error !== void 0 && q.error !== null ? a.EventsStreamError.fromPartial(q.error) : void 0, E.subscribed = q.subscribed !== void 0 && q.subscribed !== null ? a.SubscribePayload.fromPartial(q.subscribed) : void 0, E.unsubscribed = q.unsubscribed !== void 0 && q.unsubscribed !== null ? a.SubscribePayload.fromPartial(q.unsubscribed) : void 0, E.published = q.published !== void 0 && q.published !== null ? a.PublishEventResponse.fromPartial(q.published) : void 0, E.reconnectBefore = q.reconnectBefore !== void 0 && q.reconnectBefore !== null ? a.EventsStreamReconnectRequest.fromPartial(q.reconnectBefore) : void 0, E;
    }
  };
  class pe {
    constructor(z) {
      this.rpc = z, this.Stream = this.Stream.bind(this), this.Publish = this.Publish.bind(this);
    }
    Stream(z) {
      const C = z.pipe(I.map((E) => a.EventsStreamRequest.encode(E).finish()));
      return this.rpc.bidirectionalStreamingRequest("apis.event.v2.EventService", "Stream", C).pipe(I.map((E) => a.EventsStreamResponse.decode(new _.Reader(E))));
    }
    Publish(z) {
      const C = a.PublishEventRequest.encode(z).finish();
      return this.rpc.request("apis.event.v2.EventService", "Publish", C).then((E) => a.PublishEventResponse.decode(new _.Reader(E)));
    }
  }
  a.EventServiceClientImpl = pe, a.EventServiceDefinition = {
    name: "EventService",
    fullName: "apis.event.v2.EventService",
    methods: {
      /**
       * Stream Events
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      stream: {
        name: "Stream",
        requestType: a.EventsStreamRequest,
        requestStream: !0,
        responseType: a.EventsStreamResponse,
        responseStream: !0,
        options: {}
      },
      /**
       * Publish Event
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      publish: {
        name: "Publish",
        requestType: a.PublishEventRequest,
        requestStream: !1,
        responseType: a.PublishEventResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var be = (() => {
    if (typeof be < "u")
      return be;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  _.util.Long !== p.default && (_.util.Long = p.default, _.configure());
  function ke(q) {
    return typeof q == "object" && q !== null;
  }
  function _e(q) {
    return q != null;
  }
})(api$1);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(l, v, p, _) {
    _ === void 0 && (_ = p), Object.defineProperty(l, _, { enumerable: !0, get: function() {
      return v[p];
    } });
  } : function(l, v, p, _) {
    _ === void 0 && (_ = p), l[_] = v[p];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(l, v) {
    for (var p in l)
      p !== "default" && !v.hasOwnProperty(p) && u(v, l, p);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.eventsApiSupportedEvents = a.eventsApiEventRpcCalls = void 0, c(api$1, a), a.eventsApiEventRpcCalls = {
    ping: "pong",
    publish: "published",
    subscribe: "subscribed",
    unsubscribe: "unsubscribed"
  }, a.eventsApiSupportedEvents = [...Object.values(a.eventsApiEventRpcCalls), "error", "event", "reconnectBefore"];
})(dist$1);
var ws = null;
typeof WebSocket < "u" ? ws = WebSocket : typeof MozWebSocket < "u" ? ws = MozWebSocket : typeof commonjsGlobal$1 < "u" ? ws = commonjsGlobal$1.WebSocket || commonjsGlobal$1.MozWebSocket : typeof window < "u" ? ws = window.WebSocket || window.MozWebSocket : typeof self < "u" && (ws = self.WebSocket || self.MozWebSocket);
var browser$e = ws, matcher = { exports: {} }, escapeStringRegexp$1 = (a) => {
  if (typeof a != "string")
    throw new TypeError("Expected a string");
  return a.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
const escapeStringRegexp = escapeStringRegexp$1, regexpCache = /* @__PURE__ */ new Map();
function sanitizeArray(a, u) {
  if (!Array.isArray(a))
    switch (typeof a) {
      case "string":
        a = [a];
        break;
      case "undefined":
        a = [];
        break;
      default:
        throw new TypeError(`Expected '${u}' to be a string or an array, but got a type of '${typeof a}'`);
    }
  return a.filter((c) => {
    if (typeof c != "string") {
      if (typeof c > "u")
        return !1;
      throw new TypeError(`Expected '${u}' to be an array of strings, but found a type of '${typeof c}' in the array`);
    }
    return !0;
  });
}
function makeRegexp(a, u) {
  u = {
    caseSensitive: !1,
    ...u
  };
  const c = a + JSON.stringify(u);
  if (regexpCache.has(c))
    return regexpCache.get(c);
  const l = a[0] === "!";
  l && (a = a.slice(1)), a = escapeStringRegexp(a).replace(/\\\*/g, "[\\s\\S]*");
  const v = new RegExp(`^${a}$`, u.caseSensitive ? "" : "i");
  return v.negated = l, regexpCache.set(c, v), v;
}
matcher.exports = (a, u, c) => {
  if (a = sanitizeArray(a, "inputs"), u = sanitizeArray(u, "patterns"), u.length === 0)
    return [];
  const l = u[0][0] === "!";
  u = u.map((p) => makeRegexp(p, c));
  const v = [];
  for (const p of a) {
    let _ = l;
    for (const I of u)
      I.test(p) && (_ = !I.negated);
    _ && v.push(p);
  }
  return v;
};
matcher.exports.isMatch = (a, u, c) => (a = sanitizeArray(a, "inputs"), u = sanitizeArray(u, "patterns"), u.length === 0 ? !1 : a.some((l) => u.every((v) => {
  const p = makeRegexp(v, c), _ = p.test(l);
  return p.negated ? !_ : _;
})));
var matcherExports = matcher.exports, __createBinding$1 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar$1 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$1(u, a, c);
  return __setModuleDefault$1(u, a), u;
}, __importDefault$8 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(eventapi, "__esModule", { value: !0 });
eventapi.EventApi = void 0;
const EventApiModel = __importStar$1(dist$1), isomorphic_ws_1 = __importDefault$8(browser$e), uuid_1 = require$$1$4, NiceGrpc = __importStar$1(lib$1), matcher_1 = matcherExports, api_1 = api$3, clientVersion = version$4, WS_PING_INTERVAL = 2e4, WS_PING_TIMEOUT = 1e4, WS_RECONNECT_DELAY = 2e3, WS_MAX_BADAUTH_ATTEMPTS = 3, LOG_CATEGORY = "EventApi";
class EventApi extends api_1.ApiClient {
  constructor(u, c, l, v, p, _) {
    super(u, c, v, LOG_CATEGORY, p, _), this.websocketServer = l, this.subscriptions = /* @__PURE__ */ new Set(), this.eventHandlers = {}, this.calls = {}, this.messageQueue = [], this.websocketReady = !1, this.reconnectionAttempts = 0, this.badAuthentication = !1, this.eventsClient = null;
  }
  /**
   * Publish a custom event
   *
   * note: if this session has an established stream, all custom
   * events will use that transport.
   *
   * @param request
   * @returns
   */
  publish(...u) {
    return this.websocketReady ? this.call("publish", u[0]) : this.eventsClient.publish(...u);
  }
  /**
   * Open the connection
   */
  connect() {
    if (!this.ws) {
      this.cleanup();
      const u = this.accessToken, c = [`version=${clientVersion}`, `sessionid=${this.sessionId}`];
      this.sdkVersion && c.push(`sdkversion=${this.sdkVersion}`), this.ws = new isomorphic_ws_1.default(`${this.websocketServer}/stream?${c.join("&")}`, [
        "Bearer",
        this.accessToken
      ]);
      let l;
      this.ws.addEventListener("message", (v) => {
        const p = JSON.parse(v.data.toString()), _ = p.result;
        if (p.error && (l = p.error, this.handleEvent("error", {
          error: {
            code: p.code,
            message: p.message
          }
        }), ["You do not have permission to this resource", "You do not have permission to this resource"].includes(p.message) && (this.badAuthentication = !0)), !_)
          return;
        _.reconnectBefore && _.reconnectBefore.reauthenticate && this.accessToken === u && (this.badAuthentication = !0);
        const I = EventApiModel.eventsApiSupportedEvents.find((P) => !!_[P]);
        I && this.handleEvent(I, _);
      }), this.ws.addEventListener("open", () => {
        this.log.info("websocket connected"), this.call("ping", "hello", { timeout: WS_PING_TIMEOUT, skipQueue: !0 }).then(() => {
          this.ready();
        }).catch((v) => {
          !l && v.message !== "Stream connection closed" && this.disconnect("hello timeout");
        });
      }), this.ws.addEventListener("close", (v) => {
        var p;
        l ? this.reconnect(`${(p = l == null ? void 0 : l.message) !== null && p !== void 0 ? p : "unknown"}`) : this.reconnect(`closed - ${v.reason || v.code}`);
      }), this.ws.addEventListener("error", (v) => {
        l = v;
      });
    }
  }
  /**
   * Subscribe to an event
   *
   * note: if a connection does not exist, one will be established.
   *
   * @param type
   * @param payload
   */
  async subscribe(u, c = {}) {
    return this.call("subscribe", { name: u, ...c }).then(() => {
      this.subscriptions.add(JSON.stringify({ name: u, ...c }));
    });
  }
  /**
   * Unsubscribe from an event
   * @param type
   * @param payload
   */
  async unsubscribe(u, c = {}) {
    this.subscriptions.delete(JSON.stringify({ name: u, payload: c })), await this.call("unsubscribe", { name: u, ...c });
  }
  on(u, c, l) {
    const v = l || c, p = {
      ignoreSessionEvents: !1,
      allowedSessionEvents: [],
      ...l ? c : {}
    };
    this.eventHandlers[u] || (this.eventHandlers[u] = []), this.eventHandlers[u].push({
      ...p,
      handler: v
    });
  }
  off(u, c, l) {
    var v;
    const p = l || c, _ = {
      ignoreSessionEvents: !1,
      allowedSessionEvents: [],
      ...l ? c : {}
    };
    this.eventHandlers[u] = ((v = this.eventHandlers[u]) !== null && v !== void 0 ? v : []).filter((I) => !(I.ignoreSessionEvents === _.ignoreSessionEvents && I.allowedSessionEvents === _.allowedSessionEvents && I.handler === p && I.name === _.name));
  }
  /**
   * Disconnect the websocket connection
   */
  disconnect(u) {
    this.log.warn(`disconnected from events reason=${u}`), Object.values(this.calls).forEach((c) => {
      clearTimeout(c.timeout), c.reject(new Error("Stream connection closed"));
    }), this.calls = {}, this.cleanup();
  }
  _setup(u) {
    this.eventsClient = this.clientFactory.create(EventApiModel.EventServiceDefinition, this.channel, {
      "*": u
    }), this.badAuthentication && (this.badAuthentication = !1, this.reconnectionAttempts = 0, this.reconnect("updated token"));
  }
  /**
   * Called when the websocket is ready.
   */
  ready() {
    this.reconnectionAttempts = 0, this.badAuthentication = !1, this.websocketReady = !0, this.handleEvent("connected", { connected: void 0 });
    for (const u of this.subscriptions.values())
      this.send({ subscribe: JSON.parse(u), correlationId: (0, uuid_1.v4)() });
    for (const u of this.messageQueue)
      this.send(u);
    this.messageQueue = [], this.pingLoop = setInterval(() => {
      this.ping();
    }, WS_PING_INTERVAL);
  }
  ping() {
    this.call("ping", `${+/* @__PURE__ */ new Date()}`, { timeout: WS_PING_TIMEOUT }).catch(() => {
      this.reconnect("connection stalled");
    });
  }
  /**
   * Reconnect event stream
   *
   * @param reason Rec
   */
  reconnect(u) {
    this.disconnect(u), this.reconnectTimeout = setTimeout(() => {
      if (this.reconnectionAttempts++, this.badAuthentication && this.reconnectionAttempts >= WS_MAX_BADAUTH_ATTEMPTS) {
        this.log.warn("Maximum number of reconnection attempts reached with bad authentication, please re-authenticate the SDK");
        return;
      }
      this.connect();
    }, WS_RECONNECT_DELAY);
  }
  /**
   * Send a raw message to the websocket.
   *
   * @param data
   */
  send(u) {
    this.ws && this.ws.readyState === this.ws.OPEN ? this.ws.send(JSON.stringify(u)) : this.log.warn("Message sent to a disconnected stream");
  }
  /**
   * Process a stream event
   *
   * @param name the name of the event
   * @param payload the full event stream payload
   *
   * @returns void
   */
  handleEvent(u, c) {
    var l;
    if (this.calls[c.correlationId]) {
      const v = EventApiModel.eventsApiEventRpcCalls[this.calls[c.correlationId].method] === u, p = !!c.error;
      if (v || p) {
        this.resolveCall(u, c);
        return;
      }
    }
    for (const v of (l = this.eventHandlers[u]) !== null && l !== void 0 ? l : []) {
      if (u === "event" && c.event) {
        if (c.sessionId === this.sessionId && v.ignoreSessionEvents && !v.allowedSessionEvents.includes(c.event.name)) {
          this.log.trace("ignoring user event from self: " + c.event.name + ", payload.sessionId=" + c.sessionId + ", this.sessionId");
          continue;
        }
        if (v.name && !(0, matcher_1.isMatch)(c.event.name, v.name))
          continue;
        if (this.eventLogCallback) {
          let p, _ = c.event.name, I;
          if (c.event.name.startsWith(EventApi.APISTREAM_EVENT_PREFIX)) {
            let P = c.event.name.split(":");
            P.length == 4 && (p = P[1], _ = P[2], I = P[3]), this.eventLogCallback(p, _, I, c);
          }
        }
      } else if (c.sessionId === this.sessionId && v.ignoreSessionEvents) {
        this.log.trace("ignoring event from self: " + c.event.name + ", payload.sessionId=" + c.sessionId + ", this.sessionId");
        continue;
      }
      this.log.trace("processing event: payload.sessionId=" + c.sessionId + ", this.sessionId"), v.handler(c ? c[u] : void 0, { isFromCurrentSession: c.sessionId === this.sessionId });
    }
  }
  /**
   * Make an RPC call
   *
   * Initiates an async request via the stream. A correlationId is generated and used to track
   * responses and errors. A handler is registered
   *
   * @param method request method to call
   * @param payload payload to send
   * @param opts timeout
   * @returns
   */
  async call(u, c, l = { timeout: 2e4, skipQueue: !1 }) {
    this.ws || this.connect();
    const v = (0, uuid_1.v4)();
    return new Promise((p, _) => {
      const I = setTimeout(() => {
        delete this.calls[v], _(new Error("Request timed out"));
      }, l.timeout);
      this.calls[v] = { resolve: p, reject: _, timeout: I, method: u }, this.websocketReady || l.skipQueue ? this.send({ [u]: c, correlationId: v }) : this.messageQueue.push({ [u]: c, correlationId: v });
    });
  }
  /**
   * Handler for `.call()`
   *
   * Handle response events for a socket call.
   *
   * @param name name of responding event
   * @param payload payload of the event
   * @returns void
   */
  resolveCall(u, c) {
    const l = this.calls[c.correlationId];
    if (l) {
      if (clearTimeout(l.timeout), delete this.calls[c.correlationId], u === "error" && c.error) {
        l.reject(new NiceGrpc.ClientError("error", c.error.code, c.error.message));
        return;
      }
      l.resolve(c[u]);
    }
  }
  /**
   * Cleanup connection
   *
   * This cleans up the local state for a given websocket connection.
   */
  cleanup() {
    clearTimeout(this.pingLoop), clearTimeout(this.reconnectTimeout), this.websocketReady = !1, this.ws && (this.ws.onclose = function() {
    }, this.ws.close(), this.ws = null);
  }
}
eventapi.EventApi = EventApi;
EventApi.APISTREAM_EVENT_PREFIX = "apistream";
var livekit = {}, __importDefault$7 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(livekit, "__esModule", { value: !0 });
livekit.LiveKitUtils = void 0;
const jwt_decode_1 = __importDefault$7(require$$0$3);
class LiveKitUtils {
  static decodeJwt(u) {
    return (0, jwt_decode_1.default)(u, { header: !1 });
  }
  static isRoomAdmin(u) {
    return LiveKitUtils.decodeJwt(u).video.roomAdmin;
  }
  static getRoomName(u) {
    return LiveKitUtils.decodeJwt(u).video.room;
  }
}
livekit.LiveKitUtils = LiveKitUtils;
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(_e, q, z, C) {
    C === void 0 && (C = z);
    var b = Object.getOwnPropertyDescriptor(q, z);
    (!b || ("get" in b ? !q.__esModule : b.writable || b.configurable)) && (b = { enumerable: !0, get: function() {
      return q[z];
    } }), Object.defineProperty(_e, C, b);
  } : function(_e, q, z, C) {
    C === void 0 && (C = z), _e[C] = q[z];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(_e, q) {
    Object.defineProperty(_e, "default", { enumerable: !0, value: q });
  } : function(_e, q) {
    _e.default = q;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(_e) {
    if (_e && _e.__esModule)
      return _e;
    var q = {};
    if (_e != null)
      for (var z in _e)
        z !== "default" && Object.prototype.hasOwnProperty.call(_e, z) && u(q, _e, z);
    return c(q, _e), q;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(_e) {
    return _e && _e.__esModule ? _e : { default: _e };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ApiStream = a.LiveKitUtils = a.EventApiModel = a.LayoutApiModel = a.LiveApiModel = void 0;
  const p = v(require$$0$3), _ = require$$1$4, I = require$$2$2, P = layoutapi, $ = liveapi, F = eventapi, H = l(api$2);
  a.LiveApiModel = H;
  const j = l(dist$2);
  a.LayoutApiModel = j;
  const ee = l(dist$1);
  a.EventApiModel = ee;
  const X = livekit;
  Object.defineProperty(a, "LiveKitUtils", { enumerable: !0, get: function() {
    return X.LiveKitUtils;
  } });
  const ie = logger, Q = version$4, ne = {
    dev: "http://127.0.0.1:8081",
    stage: "https://live.silly.horse/grpcweb/live/v2",
    prod: "https://live.api.stream/grpcweb/live/v2"
  }, Z = {
    dev: "https://live.silly.horse/grpcweb/layout/v2",
    stage: "https://live.silly.horse/grpcweb/layout/v2",
    prod: "https://live.api.stream/grpcweb/layout/v2"
  }, de = {
    dev: "wss://live.silly.horse/event/v2",
    stage: "wss://live.silly.horse/event/v2",
    prod: "wss://live.api.stream/event/v2"
  }, he = {
    dev: "https://live.silly.horse/grpcweb/event/v2",
    stage: "https://live.silly.horse/grpcweb/event/v2",
    prod: "https://live.api.stream/grpcweb/event/v2"
  }, pe = {
    dev: "wss://live.silly.horse/webrtc/v2",
    stage: "wss://live.silly.horse/webrtc/v2",
    prod: "wss://live.api.stream/webrtc/v2"
  }, be = {
    dev: "https://live.silly.horse/webrtc/v2",
    stage: "https://live.silly.horse/webrtc/v2",
    prod: "https://live.api.stream/webrtc/v2"
  };
  class ke {
    /**
     * Create an ApiStream API Client
     */
    constructor(q = {}) {
      var z;
      const C = {
        env: "prod",
        logLevel: "Warn",
        ...q
      };
      this.env = C.env;
      let b = (0, _.v4)();
      C.sessionId != null && (b = C.sessionId), this.log = ie.logger.getCategory("ApiStream"), this.setLogLevel(C.env == "dev" ? "Trace" : C.logLevel);
      const E = (z = C.overrideEndpoints) !== null && z !== void 0 ? z : {};
      E.liveApiServer == null && (E.liveApiServer = ne[this.env]), E.layoutApiServer == null && (E.layoutApiServer = Z[this.env]), E.eventApiServer == null && (E.eventApiServer = he[this.env]), E.eventApiWebSocketServer == null && (E.eventApiWebSocketServer = de[this.env]), this.eventApi = new F.EventApi(b, E.eventApiServer, E.eventApiWebSocketServer, C.sdkVersion, C.apiLogCallback, C.eventLogCallback), this.layoutApi = new P.LayoutApi(b, this.eventApi, E.layoutApiServer, C.sdkVersion, C.apiLogCallback), this.liveApi = new $.LiveApi(b, this.eventApi, E.liveApiServer, this.setAccessToken.bind(this), C.apiKey, C.sdkVersion, C.apiLogCallback), this.eventApi.on("reconnectBefore", (k) => {
        k.reauthenticate && this.liveApi.authentication.refreshAccessToken({}).catch(() => {
        });
      }), this.log.info("api.stream: sessionid=" + b + ", version=" + Q + ", sdkVersion=" + C.sdkVersion);
    }
    /**
     * Returns the live api client
     *
     * @returns the live api client
     */
    LiveApi() {
      return this.liveApi;
    }
    /**
     * Returns the layout api client
     *
     * @returns the layout api client
     */
    LayoutApi() {
      return this.layoutApi;
    }
    /**
     * Returns the layout api client
     *
     * @returns the layout api client
     */
    EventApi() {
      return this.eventApi;
    }
    setLogLevel(q) {
      try {
        let z = I.LogLevel.toLogLevel(q);
        ie.logger.updateRuntimeSettings({
          level: z
        });
      } catch {
        this.log.warn(`unknown logging level ${q}`);
      }
    }
    setAccessToken(q) {
      this.decodedAccessToken = ke.decodeAccessToken(q), this.log.debug("setting accessToken", q, this.decodedAccessToken), this.layoutApi.setAccessToken(q), this.liveApi.setAccessToken(q), this.eventApi.setAccessToken(q);
    }
    getAccessToken() {
      return this.decodedAccessToken;
    }
    /**
     * Are we running as a guest role?
     *
     * @returns {(ApiStream.GuestProject | null)} return the active project if running as a guest role
     */
    getGuestProject() {
      return this.decodedAccessToken.guestControl;
    }
    /**
     * Initialize the api library and check if we are running inside of the rendering engine
     * @async
     * @param {string} accessToken - a valid ApiStream access token
     * @returns {(ApiStream.GuestProject | null)} if we are operating inside of the rendering engine, this is the active project
     */
    async load(q) {
      if (q == null && typeof window < "u") {
        let z = this.parseQuery();
        z.get(ke.ACCESS_TOKEN_QUERY_PARAM) != null && (q = z.get(ke.ACCESS_TOKEN_QUERY_PARAM));
      }
      return q != null && (this.setAccessToken(q), this.decodedAccessToken.guestControl != null) ? (this.log.info("loading guest token and exchanging"), await this.LiveApi().authentication.refreshAccessToken({}), this.log.info("auto-loading project = " + JSON.stringify(this.decodedAccessToken.guestControl)), this.decodedAccessToken.guestControl) : null;
    }
    /**
     * get the signaling address of the appropriate livekit webrtc server
     *
     * @param {boolean} admin - if true, return the admin (vs. client) address
     * @returns {string} the address of the appropriate livekit webrtc server
     */
    getLiveKitServer(q = !1) {
      return q ? be[this.env] : pe[this.env];
    }
    parseQuery() {
      let q = window.location.search, z = /* @__PURE__ */ new Map(), C = (q[0] === "?" ? q.substr(1) : q).split("&");
      for (let b = 0; b < C.length; b++) {
        let E = C[b].split("=");
        E.length == 2 && (z.set(decodeURIComponent(E[0]), decodeURIComponent(E[1] || "")), this.log.debug(`found query param: ${decodeURIComponent(E[0])}=${decodeURIComponent(E[1] || "")}`));
      }
      return z;
    }
    static decodeAccessToken(q) {
      let z = (0, p.default)(q, { header: !1 }), C = {
        serviceUserId: z.user.serviceUserId,
        userId: z.user.userId,
        displayName: z.user.displayName,
        trial: z.user.trial,
        demo: z.user.demo
      };
      return z.guestControl != null && (C.guestControl = {
        collectionId: z.guestControl.collectionId,
        projectId: z.guestControl.projectId,
        role: H.roleFromJSON(z.guestControl.role)
      }), C;
    }
  }
  a.ApiStream = ke, ke.ACCESS_TOKEN_QUERY_PARAM = "at";
})(lib$2);
const config$2 = (a) => ({
  defaults: {
    previewTokenDuration: 1e3 * 60 * 60,
    guestTokenDuration: 1e3 * 60 * 60 * 12,
    transforms: {
      RoomParticipant: "LS-Room-Participant",
      Image: "LS-Image",
      Banner: "LS-Banner",
      Text: "LS-Text"
    }
  }
});
var fastDeepEqual = function a(u, c) {
  if (u === c)
    return !0;
  if (u && c && typeof u == "object" && typeof c == "object") {
    if (u.constructor !== c.constructor)
      return !1;
    var l, v, p;
    if (Array.isArray(u)) {
      if (l = u.length, l != c.length)
        return !1;
      for (v = l; v-- !== 0; )
        if (!a(u[v], c[v]))
          return !1;
      return !0;
    }
    if (u.constructor === RegExp)
      return u.source === c.source && u.flags === c.flags;
    if (u.valueOf !== Object.prototype.valueOf)
      return u.valueOf() === c.valueOf();
    if (u.toString !== Object.prototype.toString)
      return u.toString() === c.toString();
    if (p = Object.keys(u), l = p.length, l !== Object.keys(c).length)
      return !1;
    for (v = l; v-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(c, p[v]))
        return !1;
    for (v = l; v-- !== 0; ) {
      var _ = p[v];
      if (!a(u[_], c[_]))
        return !1;
    }
    return !0;
  }
  return u !== u && c !== c;
};
const deepEqual = /* @__PURE__ */ getDefaultExportFromCjs$2(fastDeepEqual), global$1 = globalThis || void 0 || self;
var freeGlobal = typeof global$1 == "object" && global$1 && global$1.Object === Object && global$1, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), Symbol$1 = root.Symbol, objectProto$m = Object.prototype, hasOwnProperty$f = objectProto$m.hasOwnProperty, nativeObjectToString$1 = objectProto$m.toString, symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(a) {
  var u = hasOwnProperty$f.call(a, symToStringTag$1), c = a[symToStringTag$1];
  try {
    a[symToStringTag$1] = void 0;
    var l = !0;
  } catch {
  }
  var v = nativeObjectToString$1.call(a);
  return l && (u ? a[symToStringTag$1] = c : delete a[symToStringTag$1]), v;
}
var objectProto$l = Object.prototype, nativeObjectToString = objectProto$l.toString;
function objectToString$7(a) {
  return nativeObjectToString.call(a);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(a) {
  return a == null ? a === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(a) ? getRawTag(a) : objectToString$7(a);
}
function isObjectLike$7(a) {
  return a != null && typeof a == "object";
}
var symbolTag$6 = "[object Symbol]";
function isSymbol$3(a) {
  return typeof a == "symbol" || isObjectLike$7(a) && baseGetTag(a) == symbolTag$6;
}
function arrayMap$1(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length, v = Array(l); ++c < l; )
    v[c] = u(a[c], c, a);
  return v;
}
var isArray$4 = Array.isArray, INFINITY$4 = 1 / 0, symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString(a) {
  if (typeof a == "string")
    return a;
  if (isArray$4(a))
    return arrayMap$1(a, baseToString) + "";
  if (isSymbol$3(a))
    return symbolToString ? symbolToString.call(a) : "";
  var u = a + "";
  return u == "0" && 1 / a == -INFINITY$4 ? "-0" : u;
}
var reWhitespace = /\s/;
function trimmedEndIndex(a) {
  for (var u = a.length; u-- && reWhitespace.test(a.charAt(u)); )
    ;
  return u;
}
var reTrimStart = /^\s+/;
function baseTrim(a) {
  return a && a.slice(0, trimmedEndIndex(a) + 1).replace(reTrimStart, "");
}
function isObject$8(a) {
  var u = typeof a;
  return a != null && (u == "object" || u == "function");
}
var NAN$3 = NaN, reIsBadHex$3 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$3 = /^0b[01]+$/i, reIsOctal$3 = /^0o[0-7]+$/i, freeParseInt$3 = parseInt;
function toNumber$3(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$3(a))
    return NAN$3;
  if (isObject$8(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$8(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = baseTrim(a);
  var c = reIsBinary$3.test(a);
  return c || reIsOctal$3.test(a) ? freeParseInt$3(a.slice(2), c ? 2 : 8) : reIsBadHex$3.test(a) ? NAN$3 : +a;
}
function identity(a) {
  return a;
}
var asyncTag = "[object AsyncFunction]", funcTag$3 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(a) {
  if (!isObject$8(a))
    return !1;
  var u = baseGetTag(a);
  return u == funcTag$3 || u == genTag$2 || u == asyncTag || u == proxyTag;
}
var coreJsData = root["__core-js_shared__"], maskSrcKey = function() {
  var a = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return a ? "Symbol(src)_1." + a : "";
}();
function isMasked(a) {
  return !!maskSrcKey && maskSrcKey in a;
}
var funcProto$3 = Function.prototype, funcToString$3 = funcProto$3.toString;
function toSource(a) {
  if (a != null) {
    try {
      return funcToString$3.call(a);
    } catch {
    }
    try {
      return a + "";
    } catch {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto$2 = Function.prototype, objectProto$k = Object.prototype, funcToString$2 = funcProto$2.toString, hasOwnProperty$e = objectProto$k.hasOwnProperty, reIsNative = RegExp(
  "^" + funcToString$2.call(hasOwnProperty$e).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(a) {
  if (!isObject$8(a) || isMasked(a))
    return !1;
  var u = isFunction$2(a) ? reIsNative : reIsHostCtor;
  return u.test(toSource(a));
}
function getValue(a, u) {
  return a == null ? void 0 : a[u];
}
function getNative(a, u) {
  var c = getValue(a, u);
  return baseIsNative(c) ? c : void 0;
}
var WeakMap$2 = getNative(root, "WeakMap"), objectCreate = Object.create, baseCreate = /* @__PURE__ */ function() {
  function a() {
  }
  return function(u) {
    if (!isObject$8(u))
      return {};
    if (objectCreate)
      return objectCreate(u);
    a.prototype = u;
    var c = new a();
    return a.prototype = void 0, c;
  };
}();
function apply(a, u, c) {
  switch (c.length) {
    case 0:
      return a.call(u);
    case 1:
      return a.call(u, c[0]);
    case 2:
      return a.call(u, c[0], c[1]);
    case 3:
      return a.call(u, c[0], c[1], c[2]);
  }
  return a.apply(u, c);
}
function copyArray(a, u) {
  var c = -1, l = a.length;
  for (u || (u = Array(l)); ++c < l; )
    u[c] = a[c];
  return u;
}
var HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
function shortOut(a) {
  var u = 0, c = 0;
  return function() {
    var l = nativeNow(), v = HOT_SPAN - (l - c);
    if (c = l, v > 0) {
      if (++u >= HOT_COUNT)
        return arguments[0];
    } else
      u = 0;
    return a.apply(void 0, arguments);
  };
}
function constant(a) {
  return function() {
    return a;
  };
}
var defineProperty = function() {
  try {
    var a = getNative(Object, "defineProperty");
    return a({}, "", {}), a;
  } catch {
  }
}(), baseSetToString = defineProperty ? function(a, u) {
  return defineProperty(a, "toString", {
    configurable: !0,
    enumerable: !1,
    value: constant(u),
    writable: !0
  });
} : identity;
const baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
function arrayEach(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l && u(a[c], c, a) !== !1; )
    ;
  return a;
}
function baseFindIndex$1(a, u, c, l) {
  for (var v = a.length, p = c + (l ? 1 : -1); l ? p-- : ++p < v; )
    if (u(a[p], p, a))
      return p;
  return -1;
}
function baseIsNaN$1(a) {
  return a !== a;
}
function strictIndexOf(a, u, c) {
  for (var l = c - 1, v = a.length; ++l < v; )
    if (a[l] === u)
      return l;
  return -1;
}
function baseIndexOf$1(a, u, c) {
  return u === u ? strictIndexOf(a, u, c) : baseFindIndex$1(a, baseIsNaN$1, c);
}
var MAX_SAFE_INTEGER$2 = 9007199254740991, reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$1(a, u) {
  var c = typeof a;
  return u = u ?? MAX_SAFE_INTEGER$2, !!u && (c == "number" || c != "symbol" && reIsUint$1.test(a)) && a > -1 && a % 1 == 0 && a < u;
}
function baseAssignValue(a, u, c) {
  u == "__proto__" && defineProperty ? defineProperty(a, u, {
    configurable: !0,
    enumerable: !0,
    value: c,
    writable: !0
  }) : a[u] = c;
}
function eq(a, u) {
  return a === u || a !== a && u !== u;
}
var objectProto$j = Object.prototype, hasOwnProperty$d = objectProto$j.hasOwnProperty;
function assignValue(a, u, c) {
  var l = a[u];
  (!(hasOwnProperty$d.call(a, u) && eq(l, c)) || c === void 0 && !(u in a)) && baseAssignValue(a, u, c);
}
function copyObject(a, u, c, l) {
  var v = !c;
  c || (c = {});
  for (var p = -1, _ = u.length; ++p < _; ) {
    var I = u[p], P = l ? l(c[I], a[I], I, c, a) : void 0;
    P === void 0 && (P = a[I]), v ? baseAssignValue(c, I, P) : assignValue(c, I, P);
  }
  return c;
}
var nativeMax$2 = Math.max;
function overRest(a, u, c) {
  return u = nativeMax$2(u === void 0 ? a.length - 1 : u, 0), function() {
    for (var l = arguments, v = -1, p = nativeMax$2(l.length - u, 0), _ = Array(p); ++v < p; )
      _[v] = l[u + v];
    v = -1;
    for (var I = Array(u + 1); ++v < u; )
      I[v] = l[v];
    return I[u] = c(_), apply(a, this, I);
  };
}
function baseRest(a, u) {
  return setToString(overRest(a, u, identity), a + "");
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$1(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= MAX_SAFE_INTEGER$1;
}
function isArrayLike$1(a) {
  return a != null && isLength$1(a.length) && !isFunction$2(a);
}
function isIterateeCall(a, u, c) {
  if (!isObject$8(c))
    return !1;
  var l = typeof u;
  return (l == "number" ? isArrayLike$1(c) && isIndex$1(u, c.length) : l == "string" && u in c) ? eq(c[u], a) : !1;
}
var objectProto$i = Object.prototype;
function isPrototype$1(a) {
  var u = a && a.constructor, c = typeof u == "function" && u.prototype || objectProto$i;
  return a === c;
}
function baseTimes$1(a, u) {
  for (var c = -1, l = Array(a); ++c < a; )
    l[c] = u(c);
  return l;
}
var argsTag$4 = "[object Arguments]";
function baseIsArguments(a) {
  return isObjectLike$7(a) && baseGetTag(a) == argsTag$4;
}
var objectProto$h = Object.prototype, hasOwnProperty$c = objectProto$h.hasOwnProperty, propertyIsEnumerable$2 = objectProto$h.propertyIsEnumerable, isArguments$2 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(a) {
  return isObjectLike$7(a) && hasOwnProperty$c.call(a, "callee") && !propertyIsEnumerable$2.call(a, "callee");
};
function stubFalse() {
  return !1;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module, moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2, Buffer$N = moduleExports$2 ? root.Buffer : void 0, nativeIsBuffer = Buffer$N ? Buffer$N.isBuffer : void 0, isBuffer$1 = nativeIsBuffer || stubFalse, argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$4 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", mapTag$5 = "[object Map]", numberTag$4 = "[object Number]", objectTag$5 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$5 = "[object String]", weakMapTag$2 = "[object WeakMap]", arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]", typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0;
typedArrayTags[argsTag$3] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$4] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$4] = typedArrayTags[objectTag$5] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$5] = typedArrayTags[weakMapTag$2] = !1;
function baseIsTypedArray(a) {
  return isObjectLike$7(a) && isLength$1(a.length) && !!typedArrayTags[baseGetTag(a)];
}
function baseUnary(a) {
  return function(u) {
    return a(u);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module, moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1, freeProcess = moduleExports$1 && freeGlobal.process, nodeUtil = function() {
  try {
    var a = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    return a || freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch {
  }
}(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray$1 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, objectProto$g = Object.prototype, hasOwnProperty$b = objectProto$g.hasOwnProperty;
function arrayLikeKeys$1(a, u) {
  var c = isArray$4(a), l = !c && isArguments$2(a), v = !c && !l && isBuffer$1(a), p = !c && !l && !v && isTypedArray$1(a), _ = c || l || v || p, I = _ ? baseTimes$1(a.length, String) : [], P = I.length;
  for (var $ in a)
    (u || hasOwnProperty$b.call(a, $)) && !(_ && // Safari 9 has enumerable `arguments.length` in strict mode.
    ($ == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    v && ($ == "offset" || $ == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    p && ($ == "buffer" || $ == "byteLength" || $ == "byteOffset") || // Skip index properties.
    isIndex$1($, P))) && I.push($);
  return I;
}
function overArg$2(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var nativeKeys$1 = overArg$2(Object.keys, Object), objectProto$f = Object.prototype, hasOwnProperty$a = objectProto$f.hasOwnProperty;
function baseKeys$1(a) {
  if (!isPrototype$1(a))
    return nativeKeys$1(a);
  var u = [];
  for (var c in Object(a))
    hasOwnProperty$a.call(a, c) && c != "constructor" && u.push(c);
  return u;
}
function keys$2(a) {
  return isArrayLike$1(a) ? arrayLikeKeys$1(a) : baseKeys$1(a);
}
function nativeKeysIn(a) {
  var u = [];
  if (a != null)
    for (var c in Object(a))
      u.push(c);
  return u;
}
var objectProto$e = Object.prototype, hasOwnProperty$9 = objectProto$e.hasOwnProperty;
function baseKeysIn(a) {
  if (!isObject$8(a))
    return nativeKeysIn(a);
  var u = isPrototype$1(a), c = [];
  for (var l in a)
    l == "constructor" && (u || !hasOwnProperty$9.call(a, l)) || c.push(l);
  return c;
}
function keysIn(a) {
  return isArrayLike$1(a) ? arrayLikeKeys$1(a, !0) : baseKeysIn(a);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(a, u) {
  if (isArray$4(a))
    return !1;
  var c = typeof a;
  return c == "number" || c == "symbol" || c == "boolean" || a == null || isSymbol$3(a) ? !0 : reIsPlainProp.test(a) || !reIsDeepProp.test(a) || u != null && a in Object(u);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
}
function hashDelete(a) {
  var u = this.has(a) && delete this.__data__[a];
  return this.size -= u ? 1 : 0, u;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__", objectProto$d = Object.prototype, hasOwnProperty$8 = objectProto$d.hasOwnProperty;
function hashGet(a) {
  var u = this.__data__;
  if (nativeCreate) {
    var c = u[a];
    return c === HASH_UNDEFINED$2 ? void 0 : c;
  }
  return hasOwnProperty$8.call(u, a) ? u[a] : void 0;
}
var objectProto$c = Object.prototype, hasOwnProperty$7 = objectProto$c.hasOwnProperty;
function hashHas(a) {
  var u = this.__data__;
  return nativeCreate ? u[a] !== void 0 : hasOwnProperty$7.call(u, a);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(a, u) {
  var c = this.__data__;
  return this.size += this.has(a) ? 0 : 1, c[a] = nativeCreate && u === void 0 ? HASH_UNDEFINED$1 : u, this;
}
function Hash$8(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
Hash$8.prototype.clear = hashClear;
Hash$8.prototype.delete = hashDelete;
Hash$8.prototype.get = hashGet;
Hash$8.prototype.has = hashHas;
Hash$8.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [], this.size = 0;
}
function assocIndexOf(a, u) {
  for (var c = a.length; c--; )
    if (eq(a[c][0], u))
      return c;
  return -1;
}
var arrayProto$1 = Array.prototype, splice$1 = arrayProto$1.splice;
function listCacheDelete(a) {
  var u = this.__data__, c = assocIndexOf(u, a);
  if (c < 0)
    return !1;
  var l = u.length - 1;
  return c == l ? u.pop() : splice$1.call(u, c, 1), --this.size, !0;
}
function listCacheGet(a) {
  var u = this.__data__, c = assocIndexOf(u, a);
  return c < 0 ? void 0 : u[c][1];
}
function listCacheHas(a) {
  return assocIndexOf(this.__data__, a) > -1;
}
function listCacheSet(a, u) {
  var c = this.__data__, l = assocIndexOf(c, a);
  return l < 0 ? (++this.size, c.push([a, u])) : c[l][1] = u, this;
}
function ListCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0, this.__data__ = {
    hash: new Hash$8(),
    map: new (Map$1 || ListCache)(),
    string: new Hash$8()
  };
}
function isKeyable(a) {
  var u = typeof a;
  return u == "string" || u == "number" || u == "symbol" || u == "boolean" ? a !== "__proto__" : a === null;
}
function getMapData(a, u) {
  var c = a.__data__;
  return isKeyable(u) ? c[typeof u == "string" ? "string" : "hash"] : c.map;
}
function mapCacheDelete(a) {
  var u = getMapData(this, a).delete(a);
  return this.size -= u ? 1 : 0, u;
}
function mapCacheGet(a) {
  return getMapData(this, a).get(a);
}
function mapCacheHas(a) {
  return getMapData(this, a).has(a);
}
function mapCacheSet(a, u) {
  var c = getMapData(this, a), l = c.size;
  return c.set(a, u), this.size += c.size == l ? 0 : 1, this;
}
function MapCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$2 = "Expected a function";
function memoize(a, u) {
  if (typeof a != "function" || u != null && typeof u != "function")
    throw new TypeError(FUNC_ERROR_TEXT$2);
  var c = function() {
    var l = arguments, v = u ? u.apply(this, l) : l[0], p = c.cache;
    if (p.has(v))
      return p.get(v);
    var _ = a.apply(this, l);
    return c.cache = p.set(v, _) || p, _;
  };
  return c.cache = new (memoize.Cache || MapCache)(), c;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(a) {
  var u = memoize(a, function(l) {
    return c.size === MAX_MEMOIZE_SIZE && c.clear(), l;
  }), c = u.cache;
  return u;
}
var rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar$1 = /\\(\\)?/g, stringToPath$1 = memoizeCapped(function(a) {
  var u = [];
  return a.charCodeAt(0) === 46 && u.push(""), a.replace(rePropName$1, function(c, l, v, p) {
    u.push(v ? p.replace(reEscapeChar$1, "$1") : l || c);
  }), u;
});
function toString$3(a) {
  return a == null ? "" : baseToString(a);
}
function castPath(a, u) {
  return isArray$4(a) ? a : isKey(a, u) ? [a] : stringToPath$1(toString$3(a));
}
var INFINITY$3 = 1 / 0;
function toKey(a) {
  if (typeof a == "string" || isSymbol$3(a))
    return a;
  var u = a + "";
  return u == "0" && 1 / a == -INFINITY$3 ? "-0" : u;
}
function baseGet(a, u) {
  u = castPath(u, a);
  for (var c = 0, l = u.length; a != null && c < l; )
    a = a[toKey(u[c++])];
  return c && c == l ? a : void 0;
}
function get(a, u, c) {
  var l = a == null ? void 0 : baseGet(a, u);
  return l === void 0 ? c : l;
}
function arrayPush(a, u) {
  for (var c = -1, l = u.length, v = a.length; ++c < l; )
    a[v + c] = u[c];
  return a;
}
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable(a) {
  return isArray$4(a) || isArguments$2(a) || !!(spreadableSymbol && a && a[spreadableSymbol]);
}
function baseFlatten(a, u, c, l, v) {
  var p = -1, _ = a.length;
  for (c || (c = isFlattenable), v || (v = []); ++p < _; ) {
    var I = a[p];
    u > 0 && c(I) ? u > 1 ? baseFlatten(I, u - 1, c, l, v) : arrayPush(v, I) : l || (v[v.length] = I);
  }
  return v;
}
function flatten(a) {
  var u = a == null ? 0 : a.length;
  return u ? baseFlatten(a, 1) : [];
}
function flatRest(a) {
  return setToString(overRest(a, void 0, flatten), a + "");
}
var getPrototype$1 = overArg$2(Object.getPrototypeOf, Object);
const getPrototype$2 = getPrototype$1;
var objectTag$4 = "[object Object]", funcProto$1 = Function.prototype, objectProto$b = Object.prototype, funcToString$1 = funcProto$1.toString, hasOwnProperty$6 = objectProto$b.hasOwnProperty, objectCtorString$1 = funcToString$1.call(Object);
function isPlainObject$3(a) {
  if (!isObjectLike$7(a) || baseGetTag(a) != objectTag$4)
    return !1;
  var u = getPrototype$2(a);
  if (u === null)
    return !0;
  var c = hasOwnProperty$6.call(u, "constructor") && u.constructor;
  return typeof c == "function" && c instanceof c && funcToString$1.call(c) == objectCtorString$1;
}
function baseSlice(a, u, c) {
  var l = -1, v = a.length;
  u < 0 && (u = -u > v ? 0 : v + u), c = c > v ? v : c, c < 0 && (c += v), v = u > c ? 0 : c - u >>> 0, u >>>= 0;
  for (var p = Array(v); ++l < v; )
    p[l] = a[l + u];
  return p;
}
function castSlice(a, u, c) {
  var l = a.length;
  return c = c === void 0 ? l : c, !u && c >= l ? a : baseSlice(a, u, c);
}
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f", rsZWJ$2 = "\\u200d", reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
function hasUnicode(a) {
  return reHasUnicode.test(a);
}
function asciiToArray(a) {
  return a.split("");
}
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f", rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d", reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")", reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
function unicodeToArray(a) {
  return a.match(reUnicode) || [];
}
function stringToArray(a) {
  return hasUnicode(a) ? unicodeToArray(a) : asciiToArray(a);
}
function createCaseFirst(a) {
  return function(u) {
    u = toString$3(u);
    var c = hasUnicode(u) ? stringToArray(u) : void 0, l = c ? c[0] : u.charAt(0), v = c ? castSlice(c, 1).join("") : u.slice(1);
    return l[a]() + v;
  };
}
var upperFirst = createCaseFirst("toUpperCase");
function capitalize(a) {
  return upperFirst(toString$3(a).toLowerCase());
}
function arrayReduce(a, u, c, l) {
  var v = -1, p = a == null ? 0 : a.length;
  for (l && p && (c = a[++v]); ++v < p; )
    c = u(c, a[v], v, a);
  return c;
}
function basePropertyOf(a) {
  return function(u) {
    return a == null ? void 0 : a[u];
  };
}
var deburredLetters = {
  // Latin-1 Supplement block.
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "C",
  : "c",
  : "D",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "N",
  : "n",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "Y",
  : "y",
  : "y",
  : "Ae",
  : "ae",
  : "Th",
  : "th",
  : "ss",
  // Latin Extended-A block.
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "C",
  : "C",
  : "C",
  : "C",
  : "c",
  : "c",
  : "c",
  : "c",
  : "D",
  : "D",
  : "d",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "G",
  : "G",
  : "G",
  : "G",
  : "g",
  : "g",
  : "g",
  : "g",
  : "H",
  : "H",
  : "h",
  : "h",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "J",
  : "j",
  : "K",
  : "k",
  : "k",
  : "L",
  : "L",
  : "L",
  : "L",
  : "L",
  : "l",
  : "l",
  : "l",
  : "l",
  : "l",
  : "N",
  : "N",
  : "N",
  : "N",
  : "n",
  : "n",
  : "n",
  : "n",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "R",
  : "R",
  : "R",
  : "r",
  : "r",
  : "r",
  : "S",
  : "S",
  : "S",
  : "S",
  : "s",
  : "s",
  : "s",
  : "s",
  : "T",
  : "T",
  : "T",
  : "t",
  : "t",
  : "t",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "W",
  : "w",
  : "Y",
  : "y",
  : "Y",
  : "Z",
  : "Z",
  : "Z",
  : "z",
  : "z",
  : "z",
  : "IJ",
  : "ij",
  : "Oe",
  : "oe",
  : "'n",
  : "s"
}, deburrLetter = basePropertyOf(deburredLetters);
const deburrLetter$1 = deburrLetter;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsCombo$1 = "[" + rsComboRange$1 + "]", reComboMark = RegExp(rsCombo$1, "g");
function deburr(a) {
  return a = toString$3(a), a && a.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
}
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(a) {
  return a.match(reAsciiWord) || [];
}
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(a) {
  return reHasUnicodeWord.test(a);
}
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos$1 = "[']", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(a) {
  return a.match(reUnicodeWord) || [];
}
function words(a, u, c) {
  return a = toString$3(a), u = c ? void 0 : u, u === void 0 ? hasUnicodeWord(a) ? unicodeWords(a) : asciiWords(a) : a.match(u) || [];
}
var rsApos = "[']", reApos = RegExp(rsApos, "g");
function createCompounder(a) {
  return function(u) {
    return arrayReduce(words(deburr(u).replace(reApos, "")), a, "");
  };
}
var camelCase$2 = createCompounder(function(a, u, c) {
  return u = u.toLowerCase(), a + (c ? capitalize(u) : u);
});
const camelCase$3 = camelCase$2;
function stackClear() {
  this.__data__ = new ListCache(), this.size = 0;
}
function stackDelete(a) {
  var u = this.__data__, c = u.delete(a);
  return this.size = u.size, c;
}
function stackGet(a) {
  return this.__data__.get(a);
}
function stackHas(a) {
  return this.__data__.has(a);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(a, u) {
  var c = this.__data__;
  if (c instanceof ListCache) {
    var l = c.__data__;
    if (!Map$1 || l.length < LARGE_ARRAY_SIZE - 1)
      return l.push([a, u]), this.size = ++c.size, this;
    c = this.__data__ = new MapCache(l);
  }
  return c.set(a, u), this.size = c.size, this;
}
function Stack(a) {
  var u = this.__data__ = new ListCache(a);
  this.size = u.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(a, u) {
  return a && copyObject(u, keys$2(u), a);
}
function baseAssignIn(a, u) {
  return a && copyObject(u, keysIn(u), a);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, Buffer$M = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer$M ? Buffer$M.allocUnsafe : void 0;
function cloneBuffer(a, u) {
  if (u)
    return a.slice();
  var c = a.length, l = allocUnsafe ? allocUnsafe(c) : new a.constructor(c);
  return a.copy(l), l;
}
function arrayFilter(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length, v = 0, p = []; ++c < l; ) {
    var _ = a[c];
    u(_, c, a) && (p[v++] = _);
  }
  return p;
}
function stubArray() {
  return [];
}
var objectProto$a = Object.prototype, propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable, nativeGetSymbols$1 = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols$1 ? function(a) {
  return a == null ? [] : (a = Object(a), arrayFilter(nativeGetSymbols$1(a), function(u) {
    return propertyIsEnumerable$1.call(a, u);
  }));
} : stubArray;
function copySymbols(a, u) {
  return copyObject(a, getSymbols(a), u);
}
var nativeGetSymbols = Object.getOwnPropertySymbols, getSymbolsIn = nativeGetSymbols ? function(a) {
  for (var u = []; a; )
    arrayPush(u, getSymbols(a)), a = getPrototype$2(a);
  return u;
} : stubArray;
function copySymbolsIn(a, u) {
  return copyObject(a, getSymbolsIn(a), u);
}
function baseGetAllKeys(a, u, c) {
  var l = u(a);
  return isArray$4(a) ? l : arrayPush(l, c(a));
}
function getAllKeys(a) {
  return baseGetAllKeys(a, keys$2, getSymbols);
}
function getAllKeysIn(a) {
  return baseGetAllKeys(a, keysIn, getSymbolsIn);
}
var DataView$1 = getNative(root, "DataView"), Promise$1 = getNative(root, "Promise"), Set$1 = getNative(root, "Set"), mapTag$4 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]", dataViewTag$3 = "[object DataView]", dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$2), getTag = baseGetTag;
(DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) && (getTag = function(a) {
  var u = baseGetTag(a), c = u == objectTag$3 ? a.constructor : void 0, l = c ? toSource(c) : "";
  if (l)
    switch (l) {
      case dataViewCtorString:
        return dataViewTag$3;
      case mapCtorString:
        return mapTag$4;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag$4;
      case weakMapCtorString:
        return weakMapTag$1;
    }
  return u;
});
const getTag$1 = getTag;
var objectProto$9 = Object.prototype, hasOwnProperty$5 = objectProto$9.hasOwnProperty;
function initCloneArray(a) {
  var u = a.length, c = new a.constructor(u);
  return u && typeof a[0] == "string" && hasOwnProperty$5.call(a, "index") && (c.index = a.index, c.input = a.input), c;
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(a) {
  var u = new a.constructor(a.byteLength);
  return new Uint8Array$1(u).set(new Uint8Array$1(a)), u;
}
function cloneDataView(a, u) {
  var c = u ? cloneArrayBuffer(a.buffer) : a.buffer;
  return new a.constructor(c, a.byteOffset, a.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(a) {
  var u = new a.constructor(a.source, reFlags.exec(a));
  return u.lastIndex = a.lastIndex, u;
}
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(a) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(a)) : {};
}
function cloneTypedArray(a, u) {
  var c = u ? cloneArrayBuffer(a.buffer) : a.buffer;
  return new a.constructor(c, a.byteOffset, a.length);
}
var boolTag$3 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$4 = "[object String]", symbolTag$5 = "[object Symbol]", arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(a, u, c) {
  var l = a.constructor;
  switch (u) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(a);
    case boolTag$3:
    case dateTag$2:
      return new l(+a);
    case dataViewTag$2:
      return cloneDataView(a, c);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(a, c);
    case mapTag$3:
      return new l();
    case numberTag$3:
    case stringTag$4:
      return new l(a);
    case regexpTag$2:
      return cloneRegExp(a);
    case setTag$3:
      return new l();
    case symbolTag$5:
      return cloneSymbol(a);
  }
}
function initCloneObject(a) {
  return typeof a.constructor == "function" && !isPrototype$1(a) ? baseCreate(getPrototype$2(a)) : {};
}
var mapTag$2 = "[object Map]";
function baseIsMap(a) {
  return isObjectLike$7(a) && getTag$1(a) == mapTag$2;
}
var nodeIsMap = nodeUtil && nodeUtil.isMap, isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap, setTag$2 = "[object Set]";
function baseIsSet(a) {
  return isObjectLike$7(a) && getTag$1(a) == setTag$2;
}
var nodeIsSet = nodeUtil && nodeUtil.isSet, isSet$2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, CLONE_DEEP_FLAG$3 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4, argsTag$2 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$3 = "[object String]", symbolTag$4 = "[object Symbol]", weakMapTag = "[object WeakMap]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", cloneableTags = {};
cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$2] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$2] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$3] = cloneableTags[symbolTag$4] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0;
cloneableTags[errorTag$1] = cloneableTags[funcTag$1] = cloneableTags[weakMapTag] = !1;
function baseClone(a, u, c, l, v, p) {
  var _, I = u & CLONE_DEEP_FLAG$3, P = u & CLONE_FLAT_FLAG$1, $ = u & CLONE_SYMBOLS_FLAG$2;
  if (c && (_ = v ? c(a, l, v, p) : c(a)), _ !== void 0)
    return _;
  if (!isObject$8(a))
    return a;
  var F = isArray$4(a);
  if (F) {
    if (_ = initCloneArray(a), !I)
      return copyArray(a, _);
  } else {
    var H = getTag$1(a), j = H == funcTag$1 || H == genTag$1;
    if (isBuffer$1(a))
      return cloneBuffer(a, I);
    if (H == objectTag$2 || H == argsTag$2 || j && !v) {
      if (_ = P || j ? {} : initCloneObject(a), !I)
        return P ? copySymbolsIn(a, baseAssignIn(_, a)) : copySymbols(a, baseAssign(_, a));
    } else {
      if (!cloneableTags[H])
        return v ? a : {};
      _ = initCloneByTag(a, H, I);
    }
  }
  p || (p = new Stack());
  var ee = p.get(a);
  if (ee)
    return ee;
  p.set(a, _), isSet$2(a) ? a.forEach(function(Q) {
    _.add(baseClone(Q, u, c, Q, a, p));
  }) : isMap(a) && a.forEach(function(Q, ne) {
    _.set(ne, baseClone(Q, u, c, ne, a, p));
  });
  var X = $ ? P ? getAllKeysIn : getAllKeys : P ? keysIn : keys$2, ie = F ? void 0 : X(a);
  return arrayEach(ie || a, function(Q, ne) {
    ie && (ne = Q, Q = a[ne]), assignValue(_, ne, baseClone(Q, u, c, ne, a, p));
  }), _;
}
var CLONE_DEEP_FLAG$2 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep$1(a) {
  return baseClone(a, CLONE_DEEP_FLAG$2 | CLONE_SYMBOLS_FLAG$1);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(a) {
  return this.__data__.set(a, HASH_UNDEFINED), this;
}
function setCacheHas(a) {
  return this.__data__.has(a);
}
function SetCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.__data__ = new MapCache(); ++u < c; )
    this.add(a[u]);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l; )
    if (u(a[c], c, a))
      return !0;
  return !1;
}
function cacheHas(a, u) {
  return a.has(u);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(a, u, c, l, v, p) {
  var _ = c & COMPARE_PARTIAL_FLAG$5, I = a.length, P = u.length;
  if (I != P && !(_ && P > I))
    return !1;
  var $ = p.get(a), F = p.get(u);
  if ($ && F)
    return $ == u && F == a;
  var H = -1, j = !0, ee = c & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  for (p.set(a, u), p.set(u, a); ++H < I; ) {
    var X = a[H], ie = u[H];
    if (l)
      var Q = _ ? l(ie, X, H, u, a, p) : l(X, ie, H, a, u, p);
    if (Q !== void 0) {
      if (Q)
        continue;
      j = !1;
      break;
    }
    if (ee) {
      if (!arraySome(u, function(ne, Z) {
        if (!cacheHas(ee, Z) && (X === ne || v(X, ne, c, l, p)))
          return ee.push(Z);
      })) {
        j = !1;
        break;
      }
    } else if (!(X === ie || v(X, ie, c, l, p))) {
      j = !1;
      break;
    }
  }
  return p.delete(a), p.delete(u), j;
}
function mapToArray(a) {
  var u = -1, c = Array(a.size);
  return a.forEach(function(l, v) {
    c[++u] = [v, l];
  }), c;
}
function setToArray(a) {
  var u = -1, c = Array(a.size);
  return a.forEach(function(l) {
    c[++u] = l;
  }), c;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2, boolTag$1 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag$1 = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag$2 = "[object String]", symbolTag$3 = "[object Symbol]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(a, u, c, l, v, p, _) {
  switch (c) {
    case dataViewTag:
      if (a.byteLength != u.byteLength || a.byteOffset != u.byteOffset)
        return !1;
      a = a.buffer, u = u.buffer;
    case arrayBufferTag:
      return !(a.byteLength != u.byteLength || !p(new Uint8Array$1(a), new Uint8Array$1(u)));
    case boolTag$1:
    case dateTag:
    case numberTag$1:
      return eq(+a, +u);
    case errorTag:
      return a.name == u.name && a.message == u.message;
    case regexpTag:
    case stringTag$2:
      return a == u + "";
    case mapTag:
      var I = mapToArray;
    case setTag:
      var P = l & COMPARE_PARTIAL_FLAG$4;
      if (I || (I = setToArray), a.size != u.size && !P)
        return !1;
      var $ = _.get(a);
      if ($)
        return $ == u;
      l |= COMPARE_UNORDERED_FLAG$2, _.set(a, u);
      var F = equalArrays(I(a), I(u), l, v, p, _);
      return _.delete(a), F;
    case symbolTag$3:
      if (symbolValueOf)
        return symbolValueOf.call(a) == symbolValueOf.call(u);
  }
  return !1;
}
var COMPARE_PARTIAL_FLAG$3 = 1, objectProto$8 = Object.prototype, hasOwnProperty$4 = objectProto$8.hasOwnProperty;
function equalObjects(a, u, c, l, v, p) {
  var _ = c & COMPARE_PARTIAL_FLAG$3, I = getAllKeys(a), P = I.length, $ = getAllKeys(u), F = $.length;
  if (P != F && !_)
    return !1;
  for (var H = P; H--; ) {
    var j = I[H];
    if (!(_ ? j in u : hasOwnProperty$4.call(u, j)))
      return !1;
  }
  var ee = p.get(a), X = p.get(u);
  if (ee && X)
    return ee == u && X == a;
  var ie = !0;
  p.set(a, u), p.set(u, a);
  for (var Q = _; ++H < P; ) {
    j = I[H];
    var ne = a[j], Z = u[j];
    if (l)
      var de = _ ? l(Z, ne, j, u, a, p) : l(ne, Z, j, a, u, p);
    if (!(de === void 0 ? ne === Z || v(ne, Z, c, l, p) : de)) {
      ie = !1;
      break;
    }
    Q || (Q = j == "constructor");
  }
  if (ie && !Q) {
    var he = a.constructor, pe = u.constructor;
    he != pe && "constructor" in a && "constructor" in u && !(typeof he == "function" && he instanceof he && typeof pe == "function" && pe instanceof pe) && (ie = !1);
  }
  return p.delete(a), p.delete(u), ie;
}
var COMPARE_PARTIAL_FLAG$2 = 1, argsTag$1 = "[object Arguments]", arrayTag = "[object Array]", objectTag$1 = "[object Object]", objectProto$7 = Object.prototype, hasOwnProperty$3 = objectProto$7.hasOwnProperty;
function baseIsEqualDeep(a, u, c, l, v, p) {
  var _ = isArray$4(a), I = isArray$4(u), P = _ ? arrayTag : getTag$1(a), $ = I ? arrayTag : getTag$1(u);
  P = P == argsTag$1 ? objectTag$1 : P, $ = $ == argsTag$1 ? objectTag$1 : $;
  var F = P == objectTag$1, H = $ == objectTag$1, j = P == $;
  if (j && isBuffer$1(a)) {
    if (!isBuffer$1(u))
      return !1;
    _ = !0, F = !1;
  }
  if (j && !F)
    return p || (p = new Stack()), _ || isTypedArray$1(a) ? equalArrays(a, u, c, l, v, p) : equalByTag(a, u, P, c, l, v, p);
  if (!(c & COMPARE_PARTIAL_FLAG$2)) {
    var ee = F && hasOwnProperty$3.call(a, "__wrapped__"), X = H && hasOwnProperty$3.call(u, "__wrapped__");
    if (ee || X) {
      var ie = ee ? a.value() : a, Q = X ? u.value() : u;
      return p || (p = new Stack()), v(ie, Q, c, l, p);
    }
  }
  return j ? (p || (p = new Stack()), equalObjects(a, u, c, l, v, p)) : !1;
}
function baseIsEqual(a, u, c, l, v) {
  return a === u ? !0 : a == null || u == null || !isObjectLike$7(a) && !isObjectLike$7(u) ? a !== a && u !== u : baseIsEqualDeep(a, u, c, l, baseIsEqual, v);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(a, u, c, l) {
  var v = c.length, p = v, _ = !l;
  if (a == null)
    return !p;
  for (a = Object(a); v--; ) {
    var I = c[v];
    if (_ && I[2] ? I[1] !== a[I[0]] : !(I[0] in a))
      return !1;
  }
  for (; ++v < p; ) {
    I = c[v];
    var P = I[0], $ = a[P], F = I[1];
    if (_ && I[2]) {
      if ($ === void 0 && !(P in a))
        return !1;
    } else {
      var H = new Stack();
      if (l)
        var j = l($, F, P, a, u, H);
      if (!(j === void 0 ? baseIsEqual(F, $, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, l, H) : j))
        return !1;
    }
  }
  return !0;
}
function isStrictComparable(a) {
  return a === a && !isObject$8(a);
}
function getMatchData(a) {
  for (var u = keys$2(a), c = u.length; c--; ) {
    var l = u[c], v = a[l];
    u[c] = [l, v, isStrictComparable(v)];
  }
  return u;
}
function matchesStrictComparable(a, u) {
  return function(c) {
    return c == null ? !1 : c[a] === u && (u !== void 0 || a in Object(c));
  };
}
function baseMatches(a) {
  var u = getMatchData(a);
  return u.length == 1 && u[0][2] ? matchesStrictComparable(u[0][0], u[0][1]) : function(c) {
    return c === a || baseIsMatch(c, a, u);
  };
}
function baseHasIn(a, u) {
  return a != null && u in Object(a);
}
function hasPath(a, u, c) {
  u = castPath(u, a);
  for (var l = -1, v = u.length, p = !1; ++l < v; ) {
    var _ = toKey(u[l]);
    if (!(p = a != null && c(a, _)))
      break;
    a = a[_];
  }
  return p || ++l != v ? p : (v = a == null ? 0 : a.length, !!v && isLength$1(v) && isIndex$1(_, v) && (isArray$4(a) || isArguments$2(a)));
}
function hasIn(a, u) {
  return a != null && hasPath(a, u, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(a, u) {
  return isKey(a) && isStrictComparable(u) ? matchesStrictComparable(toKey(a), u) : function(c) {
    var l = get(c, a);
    return l === void 0 && l === u ? hasIn(c, a) : baseIsEqual(u, l, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(a) {
  return function(u) {
    return u == null ? void 0 : u[a];
  };
}
function basePropertyDeep(a) {
  return function(u) {
    return baseGet(u, a);
  };
}
function property(a) {
  return isKey(a) ? baseProperty(toKey(a)) : basePropertyDeep(a);
}
function baseIteratee(a) {
  return typeof a == "function" ? a : a == null ? identity : typeof a == "object" ? isArray$4(a) ? baseMatchesProperty(a[0], a[1]) : baseMatches(a) : property(a);
}
function createBaseFor(a) {
  return function(u, c, l) {
    for (var v = -1, p = Object(u), _ = l(u), I = _.length; I--; ) {
      var P = _[a ? I : ++v];
      if (c(p[P], P, p) === !1)
        break;
    }
    return u;
  };
}
var baseFor = createBaseFor();
const baseFor$1 = baseFor;
function baseForOwn(a, u) {
  return a && baseFor$1(a, u, keys$2);
}
function createBaseEach(a, u) {
  return function(c, l) {
    if (c == null)
      return c;
    if (!isArrayLike$1(c))
      return a(c, l);
    for (var v = c.length, p = u ? v : -1, _ = Object(c); (u ? p-- : ++p < v) && l(_[p], p, _) !== !1; )
      ;
    return c;
  };
}
var baseEach = createBaseEach(baseForOwn), now = function() {
  return root.Date.now();
}, FUNC_ERROR_TEXT$1 = "Expected a function", nativeMax$1 = Math.max, nativeMin = Math.min;
function debounce(a, u, c) {
  var l, v, p, _, I, P, $ = 0, F = !1, H = !1, j = !0;
  if (typeof a != "function")
    throw new TypeError(FUNC_ERROR_TEXT$1);
  u = toNumber$3(u) || 0, isObject$8(c) && (F = !!c.leading, H = "maxWait" in c, p = H ? nativeMax$1(toNumber$3(c.maxWait) || 0, u) : p, j = "trailing" in c ? !!c.trailing : j);
  function ee(be) {
    var ke = l, _e = v;
    return l = v = void 0, $ = be, _ = a.apply(_e, ke), _;
  }
  function X(be) {
    return $ = be, I = setTimeout(ne, u), F ? ee(be) : _;
  }
  function ie(be) {
    var ke = be - P, _e = be - $, q = u - ke;
    return H ? nativeMin(q, p - _e) : q;
  }
  function Q(be) {
    var ke = be - P, _e = be - $;
    return P === void 0 || ke >= u || ke < 0 || H && _e >= p;
  }
  function ne() {
    var be = now();
    if (Q(be))
      return Z(be);
    I = setTimeout(ne, ie(be));
  }
  function Z(be) {
    return I = void 0, j && l ? ee(be) : (l = v = void 0, _);
  }
  function de() {
    I !== void 0 && clearTimeout(I), $ = 0, l = P = v = I = void 0;
  }
  function he() {
    return I === void 0 ? _ : Z(now());
  }
  function pe() {
    var be = now(), ke = Q(be);
    if (l = arguments, v = this, P = be, ke) {
      if (I === void 0)
        return X(P);
      if (H)
        return clearTimeout(I), I = setTimeout(ne, u), ee(P);
    }
    return I === void 0 && (I = setTimeout(ne, u)), _;
  }
  return pe.cancel = de, pe.flush = he, pe;
}
function last(a) {
  var u = a == null ? 0 : a.length;
  return u ? a[u - 1] : void 0;
}
function arrayEvery(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l; )
    if (!u(a[c], c, a))
      return !1;
  return !0;
}
function baseEvery(a, u) {
  var c = !0;
  return baseEach(a, function(l, v, p) {
    return c = !!u(l, v, p), c;
  }), c;
}
function every(a, u, c) {
  var l = isArray$4(a) ? arrayEvery : baseEvery;
  return c && isIterateeCall(a, u, c) && (u = void 0), l(a, baseIteratee(u));
}
function baseMap(a, u) {
  var c = -1, l = isArrayLike$1(a) ? Array(a.length) : [];
  return baseEach(a, function(v, p, _) {
    l[++c] = u(v, p, _);
  }), l;
}
function parent(a, u) {
  return u.length < 2 ? a : baseGet(a, baseSlice(u, 0, -1));
}
function isEqual(a, u) {
  return baseIsEqual(a, u);
}
function isMatch(a, u) {
  return a === u || baseIsMatch(a, u, getMatchData(u));
}
var CLONE_DEEP_FLAG$1 = 1;
function iteratee(a) {
  return baseIteratee(typeof a == "function" ? a : baseClone(a, CLONE_DEEP_FLAG$1));
}
var kebabCase = createCompounder(function(a, u, c) {
  return a + (c ? "-" : "") + u.toLowerCase();
});
const kebabCase$1 = kebabCase;
function baseUnset(a, u) {
  return u = castPath(u, a), a = parent(a, u), a == null || delete a[toKey(last(u))];
}
function customOmitClone(a) {
  return isPlainObject$3(a) ? void 0 : a;
}
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, omit = flatRest(function(a, u) {
  var c = {};
  if (a == null)
    return c;
  var l = !1;
  u = arrayMap$1(u, function(p) {
    return p = castPath(p, a), l || (l = p.length > 1), p;
  }), copyObject(a, getAllKeysIn(a), c), l && (c = baseClone(c, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
  for (var v = u.length; v--; )
    baseUnset(c, u[v]);
  return c;
});
function baseSet(a, u, c, l) {
  if (!isObject$8(a))
    return a;
  u = castPath(u, a);
  for (var v = -1, p = u.length, _ = p - 1, I = a; I != null && ++v < p; ) {
    var P = toKey(u[v]), $ = c;
    if (P === "__proto__" || P === "constructor" || P === "prototype")
      return a;
    if (v != _) {
      var F = I[P];
      $ = l ? l(F, P, I) : void 0, $ === void 0 && ($ = isObject$8(F) ? F : isIndex$1(u[v + 1]) ? [] : {});
    }
    assignValue(I, P, $), I = I[P];
  }
  return a;
}
function basePickBy(a, u, c) {
  for (var l = -1, v = u.length, p = {}; ++l < v; ) {
    var _ = u[l], I = baseGet(a, _);
    c(I, _) && baseSet(p, castPath(_, a), I);
  }
  return p;
}
function baseSortBy(a, u) {
  var c = a.length;
  for (a.sort(u); c--; )
    a[c] = a[c].value;
  return a;
}
function compareAscending(a, u) {
  if (a !== u) {
    var c = a !== void 0, l = a === null, v = a === a, p = isSymbol$3(a), _ = u !== void 0, I = u === null, P = u === u, $ = isSymbol$3(u);
    if (!I && !$ && !p && a > u || p && _ && P && !I && !$ || l && _ && P || !c && P || !v)
      return 1;
    if (!l && !p && !$ && a < u || $ && c && v && !l && !p || I && c && v || !_ && v || !P)
      return -1;
  }
  return 0;
}
function compareMultiple(a, u, c) {
  for (var l = -1, v = a.criteria, p = u.criteria, _ = v.length, I = c.length; ++l < _; ) {
    var P = compareAscending(v[l], p[l]);
    if (P) {
      if (l >= I)
        return P;
      var $ = c[l];
      return P * ($ == "desc" ? -1 : 1);
    }
  }
  return a.index - u.index;
}
function baseOrderBy(a, u, c) {
  u.length ? u = arrayMap$1(u, function(p) {
    return isArray$4(p) ? function(_) {
      return baseGet(_, p.length === 1 ? p[0] : p);
    } : p;
  }) : u = [identity];
  var l = -1;
  u = arrayMap$1(u, baseUnary(baseIteratee));
  var v = baseMap(a, function(p, _, I) {
    var P = arrayMap$1(u, function($) {
      return $(p);
    });
    return { criteria: P, index: ++l, value: p };
  });
  return baseSortBy(v, function(p, _) {
    return compareMultiple(p, _, c);
  });
}
function basePick(a, u) {
  return basePickBy(a, u, function(c, l) {
    return hasIn(a, l);
  });
}
var pick = flatRest(function(a, u) {
  return a == null ? {} : basePick(a, u);
});
const pick$1 = pick;
function baseIndexOfWith(a, u, c, l) {
  for (var v = c - 1, p = a.length; ++v < p; )
    if (l(a[v], u))
      return v;
  return -1;
}
var arrayProto = Array.prototype, splice = arrayProto.splice;
function basePullAll(a, u, c, l) {
  var v = l ? baseIndexOfWith : baseIndexOf$1, p = -1, _ = u.length, I = a;
  for (a === u && (u = copyArray(u)), c && (I = arrayMap$1(a, baseUnary(c))); ++p < _; )
    for (var P = 0, $ = u[p], F = c ? c($) : $; (P = v(I, F, P, l)) > -1; )
      I !== a && splice.call(I, P, 1), splice.call(a, P, 1);
  return a;
}
function pullAll(a, u) {
  return a && a.length && u && u.length ? basePullAll(a, u) : a;
}
var pull$1 = baseRest(pullAll), sortBy = baseRest(function(a, u) {
  if (a == null)
    return [];
  var c = u.length;
  return c > 1 && isIterateeCall(a, u[0], u[1]) ? u = [] : c > 2 && isIterateeCall(u[0], u[1], u[2]) && (u = [u[0]]), baseOrderBy(a, baseFlatten(u, 1), []);
});
const sortBy$1 = sortBy, convert = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(a) {
    if (a == null)
      return ok;
    if (typeof a == "function")
      return castFactory(a);
    if (typeof a == "object")
      return Array.isArray(a) ? anyFactory(a) : propsFactory(a);
    if (typeof a == "string")
      return typeFactory(a);
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(a) {
  const u = [];
  let c = -1;
  for (; ++c < a.length; )
    u[c] = convert(a[c]);
  return castFactory(l);
  function l(...v) {
    let p = -1;
    for (; ++p < u.length; )
      if (u[p].apply(this, v))
        return !0;
    return !1;
  }
}
function propsFactory(a) {
  const u = (
    /** @type {Record<string, unknown>} */
    a
  );
  return castFactory(c);
  function c(l) {
    const v = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      l
    );
    let p;
    for (p in a)
      if (v[p] !== u[p])
        return !1;
    return !0;
  }
}
function typeFactory(a) {
  return castFactory(u);
  function u(c) {
    return c && c.type === a;
  }
}
function castFactory(a) {
  return u;
  function u(c, l, v) {
    return !!(looksLikeANode(c) && a.call(
      this,
      c,
      typeof l == "number" ? l : void 0,
      v || void 0
    ));
  }
}
function ok() {
  return !0;
}
function looksLikeANode(a) {
  return a !== null && typeof a == "object" && "type" in a;
}
function color$1(a) {
  return a;
}
const empty$1 = [], CONTINUE = !0, EXIT = !1, SKIP = "skip";
function visitParents(a, u, c, l) {
  let v;
  typeof u == "function" && typeof c != "function" ? (l = c, c = u) : v = u;
  const p = convert(v), _ = l ? -1 : 1;
  I(a, void 0, [])();
  function I(P, $, F) {
    const H = (
      /** @type {Record<string, unknown>} */
      P && typeof P == "object" ? P : {}
    );
    if (typeof H.type == "string") {
      const ee = (
        // `hast`
        typeof H.tagName == "string" ? H.tagName : (
          // `xast`
          typeof H.name == "string" ? H.name : void 0
        )
      );
      Object.defineProperty(j, "name", {
        value: "node (" + (P.type + (ee ? "<" + ee + ">" : "")) + ")"
      });
    }
    return j;
    function j() {
      let ee = empty$1, X, ie, Q;
      if ((!u || p(P, $, F[F.length - 1] || void 0)) && (ee = toResult(c(P, F)), ee[0] === EXIT))
        return ee;
      if ("children" in P && P.children) {
        const ne = (
          /** @type {UnistParent} */
          P
        );
        if (ne.children && ee[0] !== SKIP)
          for (ie = (l ? ne.children.length : -1) + _, Q = F.concat(ne); ie > -1 && ie < ne.children.length; ) {
            const Z = ne.children[ie];
            if (X = I(Z, ie, Q)(), X[0] === EXIT)
              return X;
            ie = typeof X[1] == "number" ? X[1] : ie + _;
          }
      }
      return ee;
    }
  }
}
function toResult(a) {
  return Array.isArray(a) ? a : typeof a == "number" ? [CONTINUE, a] : a == null ? empty$1 : [a];
}
function visit(a, u, c, l) {
  let v, p, _;
  typeof u == "function" && typeof c != "function" ? (p = void 0, _ = u, v = c) : (p = u, _ = c, v = l), visitParents(a, p, I, v);
  function I(P, $) {
    const F = $[$.length - 1], H = F ? F.children.indexOf(P) : void 0;
    return _(P, H, F);
  }
}
const generateId = () => (Math.random() * 1e20).toString(36), insertAt$1 = (a = 0, u, c, l = !1) => [...c.slice(0, a), ...[u].flat(), ...c.slice(l ? a + 1 : a)], replaceItem$1 = (a, u, c) => {
  a = typeof a == "function" ? a : (v) => v === a;
  const l = c.findIndex(a);
  return l < 0 ? c : insertAt$1(l, u, c, !0);
}, swapIndex = (a, u, c) => {
  if (!c[a] || !c[u])
    return c;
  c = [...c];
  const l = c[a];
  return c[a] = c[u], c[u] = l, c;
}, swapItems = (a, u, c) => {
  const l = c.findIndex((p) => p === a), v = c.findIndex((p) => p === u);
  return l < 0 || v < 0 ? c : swapIndex(l, v, c);
}, toDataNode$1 = (a) => a ? {
  id: a.id,
  props: a.props,
  childIds: (a.children || []).map((u) => u.id)
} : null, toSceneNode = (a) => ({
  id: a.id,
  props: a.props,
  children: []
}), toSceneTree = (a, u) => {
  const c = a.find((v) => v.id === u);
  if (!c)
    return null;
  const l = c.childIds;
  return {
    id: c.id,
    props: c.props,
    children: l.map((v) => toSceneTree(a, v)).filter(Boolean)
  };
}, forEachDown$1 = (a, u) => {
  u(a), (a.children || []).forEach((l) => forEachDown$1(l, (v, p) => {
    u(v, p || a);
  }));
}, mapDown = (a, u) => {
  const c = u(a);
  return {
    ...c,
    children: ((c == null ? void 0 : c.children) || (a == null ? void 0 : a.children) || []).map((l) => mapDown(l, u))
  };
}, mapDownAsync = async (a, u) => {
  const c = (a == null ? void 0 : a.children) ?? [];
  return {
    ...await u(a),
    children: await Promise.all(c.map((l) => mapDownAsync(l, u)))
  };
}, getElementAttributes = (a) => Object.values(a.attributes).reduce((u, c) => ({
  ...u,
  [c.name]: c.value
}), {}), asArray = (a) => isArray$4(a) ? a : [a], sizeToNum = (a, u) => typeof a == "number" ? a : typeof a == "string" ? a.indexOf("%") > -1 ? parseFloat(a) / 100 * u : parseFloat(a) : 0, asSize = (a) => typeof a == "number" ? a + "px" : typeof a == "string" ? a.indexOf("%") > -1 ? parseFloat(a) + "%" : a : "0px", asDuration = (a) => typeof a == "string" ? a : typeof a == "number" ? a + "ms" : "0ms", find$1 = (a, u) => {
  if (!a)
    throw new Error("requires a tree to search");
  if (!u)
    throw new Error("requires a condition");
  const c = iteratee(u);
  let l;
  return visit(a, function(v) {
    if (c(v))
      return l = v, !1;
  }), l;
}, findAll = (a, u) => {
  if (!a)
    throw new Error("requires a tree to search");
  if (!u)
    throw new Error("requires a condition");
  const c = iteratee(u);
  let l = [];
  return visit(a, function(v) {
    c(v) && l.push(v);
  }), l;
}, lookupDevice = (a, u) => {
  const c = a.find((v) => v.label === u && v.kind === "videoinput"), l = a.find((v) => v.label === `Monitor of ${u}` && v.kind === "audioinput");
  if (c && l)
    return {
      videoDevice: c,
      audioDevice: l
    };
  if (c) {
    if (c.label === "Logitech BRIO (046d:085e)") {
      const v = a.find((p) => (
        /*(device.groupId === videoDevice.groupId) &&*/
        p.kind === "audioinput" && p.label === "Loopback Audio 2 (Virtual)"
      ));
      return {
        videoDevice: c,
        audioDevice: v
      };
    }
    if (c.label === "OBS Virtual Camera (m-de:vice)") {
      const v = a.find((p) => (
        /*(device.groupId === videoDevice.groupId) &&*/
        p.kind === "audioinput" && p.label === "Loopback Audio (Virtual)"
      ));
      return {
        videoDevice: c,
        audioDevice: v
      };
    }
    return {
      videoDevice: c,
      audioDevice: null
    };
  }
  return null;
}, connectDevice = async (a) => {
  const u = await navigator.mediaDevices.enumerateDevices(), c = lookupDevice(u, a);
  if (c) {
    const l = {
      video: {
        width: 999999,
        height: 999999,
        deviceId: {
          exact: c.videoDevice.deviceId
        }
      }
    };
    c.audioDevice && (l.audio = {
      autoGainControl: !1,
      channelCount: 2,
      echoCancellation: !1,
      // @ts-ignore: https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/latency
      latency: 0,
      noiseSuppression: !1,
      sampleRate: 128e3,
      sampleSize: 16,
      deviceId: {
        exact: c.audioDevice.deviceId
      }
    });
    const v = await navigator.mediaDevices.getUserMedia(l);
    if (v)
      return v;
    console.warn(`No stream found for source ${a}.`);
  } else
    console.warn(`No device found for source ${a}.`);
}, values$1 = (a) => Array.from(a.values()), Logic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  asArray,
  asDuration,
  asSize,
  camelCase: camelCase$3,
  cloneDeep: cloneDeep$1,
  connectDevice,
  debounce,
  deepEqual,
  every,
  find: find$1,
  findAll,
  forEachDown: forEachDown$1,
  generateId,
  getElementAttributes,
  insertAt: insertAt$1,
  isArray: isArray$4,
  isEqual,
  kebabCase: kebabCase$1,
  lookupDevice,
  mapDown,
  mapDownAsync,
  omit,
  pick: pick$1,
  pull: pull$1,
  replaceItem: replaceItem$1,
  sizeToNum,
  sortBy: sortBy$1,
  swapIndex,
  swapItems,
  toDataNode: toDataNode$1,
  toSceneNode,
  toSceneTree,
  values: values$1
}, Symbol.toStringTag, { value: "Module" }));
function getDefaultExportFromCjs$1(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var browser$d = { exports: {} }, process = browser$d.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(a) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(a, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(a, 0);
  try {
    return cachedSetTimeout(a, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, a, 0);
    } catch {
      return cachedSetTimeout.call(this, a, 0);
    }
  }
}
function runClearTimeout(a) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(a);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(a);
  try {
    return cachedClearTimeout(a);
  } catch {
    try {
      return cachedClearTimeout.call(null, a);
    } catch {
      return cachedClearTimeout.call(this, a);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var a = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var u = queue.length; u; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < u; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, u = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(a);
  }
}
process.nextTick = function(a) {
  var u = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var c = 1; c < arguments.length; c++)
      u[c - 1] = arguments[c];
  queue.push(new Item(a, u)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(a, u) {
  this.fun = a, this.array = u;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$5() {
}
process.on = noop$5;
process.addListener = noop$5;
process.once = noop$5;
process.off = noop$5;
process.removeListener = noop$5;
process.removeAllListeners = noop$5;
process.emit = noop$5;
process.prependListener = noop$5;
process.prependOnceListener = noop$5;
process.listeners = function(a) {
  return [];
};
process.binding = function(a) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(a) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$d.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports$1);
function _mergeNamespaces(a, u) {
  return u.forEach(function(c) {
    c && typeof c != "string" && !Array.isArray(c) && Object.keys(c).forEach(function(l) {
      if (l !== "default" && !(l in a)) {
        var v = Object.getOwnPropertyDescriptor(c, l);
        Object.defineProperty(a, l, v.get ? v : {
          enumerable: !0,
          get: function() {
            return c[l];
          }
        });
      }
    });
  }), Object.freeze(a);
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global$1 < "u" ? global$1 : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var loglevel$1 = { exports: {} };
(function(a) {
  (function(u, c) {
    a.exports ? a.exports = c() : u.log = c();
  })(commonjsGlobal, function() {
    var u = function() {
    }, c = "undefined", l = typeof window !== c && typeof window.navigator !== c && /Trident\/|MSIE /.test(window.navigator.userAgent), v = ["trace", "debug", "info", "warn", "error"];
    function p(ie, Q) {
      var ne = ie[Q];
      if (typeof ne.bind == "function")
        return ne.bind(ie);
      try {
        return Function.prototype.bind.call(ne, ie);
      } catch {
        return function() {
          return Function.prototype.apply.apply(ne, [ie, arguments]);
        };
      }
    }
    function _() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function I(ie) {
      return ie === "debug" && (ie = "log"), typeof console === c ? !1 : ie === "trace" && l ? _ : console[ie] !== void 0 ? p(console, ie) : console.log !== void 0 ? p(console, "log") : u;
    }
    function P(ie, Q) {
      for (var ne = 0; ne < v.length; ne++) {
        var Z = v[ne];
        this[Z] = ne < ie ? u : this.methodFactory(Z, ie, Q);
      }
      this.log = this.debug;
    }
    function $(ie, Q, ne) {
      return function() {
        typeof console !== c && (P.call(this, Q, ne), this[ie].apply(this, arguments));
      };
    }
    function F(ie, Q, ne) {
      return I(ie) || $.apply(this, arguments);
    }
    function H(ie, Q, ne) {
      var Z = this, de;
      Q = Q ?? "WARN";
      var he = "loglevel";
      typeof ie == "string" ? he += ":" + ie : typeof ie == "symbol" && (he = void 0);
      function pe(q) {
        var z = (v[q] || "silent").toUpperCase();
        if (!(typeof window === c || !he)) {
          try {
            window.localStorage[he] = z;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(he) + "=" + z + ";";
          } catch {
          }
        }
      }
      function be() {
        var q;
        if (!(typeof window === c || !he)) {
          try {
            q = window.localStorage[he];
          } catch {
          }
          if (typeof q === c)
            try {
              var z = window.document.cookie, C = z.indexOf(encodeURIComponent(he) + "=");
              C !== -1 && (q = /^([^;]+)/.exec(z.slice(C))[1]);
            } catch {
            }
          return Z.levels[q] === void 0 && (q = void 0), q;
        }
      }
      function ke() {
        if (!(typeof window === c || !he)) {
          try {
            window.localStorage.removeItem(he);
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(he) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      Z.name = ie, Z.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, Z.methodFactory = ne || F, Z.getLevel = function() {
        return de;
      }, Z.setLevel = function(q, z) {
        if (typeof q == "string" && Z.levels[q.toUpperCase()] !== void 0 && (q = Z.levels[q.toUpperCase()]), typeof q == "number" && q >= 0 && q <= Z.levels.SILENT) {
          if (de = q, z !== !1 && pe(q), P.call(Z, q, ie), typeof console === c && q < Z.levels.SILENT)
            return "No console available for logging";
        } else
          throw "log.setLevel() called with invalid level: " + q;
      }, Z.setDefaultLevel = function(q) {
        Q = q, be() || Z.setLevel(q, !1);
      }, Z.resetLevel = function() {
        Z.setLevel(Q, !1), ke();
      }, Z.enableAll = function(q) {
        Z.setLevel(Z.levels.TRACE, q);
      }, Z.disableAll = function(q) {
        Z.setLevel(Z.levels.SILENT, q);
      };
      var _e = be();
      _e == null && (_e = Q), Z.setLevel(_e, !1);
    }
    var j = new H(), ee = {};
    j.getLogger = function(Q) {
      if (typeof Q != "symbol" && typeof Q != "string" || Q === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var ne = ee[Q];
      return ne || (ne = ee[Q] = new H(Q, j.getLevel(), j.methodFactory)), ne;
    };
    var X = typeof window !== c ? window.log : void 0;
    return j.noConflict = function() {
      return typeof window !== c && window.log === j && (window.log = X), j;
    }, j.getLoggers = function() {
      return ee;
    }, j.default = j, j;
  });
})(loglevel$1);
var loglevelExports$1 = loglevel$1.exports, LogLevel;
(function(a) {
  a[a.trace = 0] = "trace", a[a.debug = 1] = "debug", a[a.info = 2] = "info", a[a.warn = 3] = "warn", a[a.error = 4] = "error", a[a.silent = 5] = "silent";
})(LogLevel || (LogLevel = {}));
var LoggerNames;
(function(a) {
  a.Default = "livekit", a.Room = "livekit-room", a.Participant = "livekit-participant", a.Track = "livekit-track", a.Publication = "livekit-track-publication", a.Engine = "livekit-engine", a.Signal = "livekit-signal", a.PCManager = "livekit-pc-manager", a.PCTransport = "livekit-pc-transport", a.E2EE = "lk-e2ee";
})(LoggerNames || (LoggerNames = {}));
let livekitLogger = loglevelExports$1.getLogger("livekit");
livekitLogger.setDefaultLevel(LogLevel.info);
function getLogger(a) {
  const u = loglevelExports$1.getLogger(a);
  return u.setDefaultLevel(livekitLogger.getLevel()), u;
}
function setLogLevel(a, u) {
  u && loglevelExports$1.getLogger(u).setLevel(a);
  for (const c of Object.entries(loglevelExports$1.getLoggers()).filter((l) => {
    let [v] = l;
    return v.startsWith("livekit");
  }).map((l) => {
    let [, v] = l;
    return v;
  }))
    c.setLevel(a);
}
loglevelExports$1.getLogger("lk-e2ee");
function assert$k(a, u) {
  if (!a)
    throw new Error(u);
}
const FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
function assertInt32(a) {
  if (typeof a != "number")
    throw new Error("invalid int 32: " + typeof a);
  if (!Number.isInteger(a) || a > INT32_MAX || a < INT32_MIN)
    throw new Error("invalid int 32: " + a);
}
function assertUInt32(a) {
  if (typeof a != "number")
    throw new Error("invalid uint 32: " + typeof a);
  if (!Number.isInteger(a) || a > UINT32_MAX || a < 0)
    throw new Error("invalid uint 32: " + a);
}
function assertFloat32(a) {
  if (typeof a != "number")
    throw new Error("invalid float 32: " + typeof a);
  if (Number.isFinite(a) && (a > FLOAT32_MAX || a < FLOAT32_MIN))
    throw new Error("invalid float 32: " + a);
}
const enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
function getEnumType(a) {
  const u = a[enumTypeSymbol];
  return assert$k(u, "missing enum type on enum object"), u;
}
function setEnumType(a, u, c, l) {
  a[enumTypeSymbol] = makeEnumType(u, c.map((v) => ({
    no: v.no,
    name: v.name,
    localName: a[v.no]
  })));
}
function makeEnumType(a, u, c) {
  const l = /* @__PURE__ */ Object.create(null), v = /* @__PURE__ */ Object.create(null), p = [];
  for (const _ of u) {
    const I = normalizeEnumValue(_);
    p.push(I), l[_.name] = I, v[_.no] = I;
  }
  return {
    typeName: a,
    values: p,
    // We do not surface options at this time
    // options: opt?.options ?? Object.create(null),
    findName(_) {
      return l[_];
    },
    findNumber(_) {
      return v[_];
    }
  };
}
function makeEnum(a, u, c) {
  const l = {};
  for (const v of u) {
    const p = normalizeEnumValue(v);
    l[p.localName] = p.no, l[p.no] = p.localName;
  }
  return setEnumType(l, a, u), l;
}
function normalizeEnumValue(a) {
  return "localName" in a ? a : Object.assign(Object.assign({}, a), {
    localName: a.name
  });
}
class Message {
  /**
   * Compare with a message of the same type.
   */
  equals(u) {
    return this.getType().runtime.util.equals(this.getType(), this, u);
  }
  /**
   * Create a deep copy.
   */
  clone() {
    return this.getType().runtime.util.clone(this);
  }
  /**
   * Parse from binary data, merging fields.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  fromBinary(u, c) {
    const l = this.getType(), v = l.runtime.bin, p = v.makeReadOptions(c);
    return v.readMessage(this, p.readerFactory(u), u.byteLength, p), this;
  }
  /**
   * Parse a message from a JSON value.
   */
  fromJson(u, c) {
    const l = this.getType(), v = l.runtime.json, p = v.makeReadOptions(c);
    return v.readMessage(l, u, p, this), this;
  }
  /**
   * Parse a message from a JSON string.
   */
  fromJsonString(u, c) {
    let l;
    try {
      l = JSON.parse(u);
    } catch (v) {
      throw new Error("cannot decode ".concat(this.getType().typeName, " from JSON: ").concat(v instanceof Error ? v.message : String(v)));
    }
    return this.fromJson(l, c);
  }
  /**
   * Serialize the message to binary data.
   */
  toBinary(u) {
    const c = this.getType(), l = c.runtime.bin, v = l.makeWriteOptions(u), p = v.writerFactory();
    return l.writeMessage(this, p, v), p.finish();
  }
  /**
   * Serialize the message to a JSON value, a JavaScript value that can be
   * passed to JSON.stringify().
   */
  toJson(u) {
    const c = this.getType(), l = c.runtime.json, v = l.makeWriteOptions(u);
    return l.writeMessage(this, v);
  }
  /**
   * Serialize the message to a JSON string.
   */
  toJsonString(u) {
    var c;
    const l = this.toJson(u);
    return JSON.stringify(l, null, (c = u == null ? void 0 : u.prettySpaces) !== null && c !== void 0 ? c : 0);
  }
  /**
   * Override for serialization behavior. This will be invoked when calling
   * JSON.stringify on this message (i.e. JSON.stringify(msg)).
   *
   * Note that this will not serialize google.protobuf.Any with a packed
   * message because the protobuf JSON format specifies that it needs to be
   * unpacked, and this is only possible with a type registry to look up the
   * message type.  As a result, attempting to serialize a message with this
   * type will throw an Error.
   *
   * This method is protected because you should not need to invoke it
   * directly -- instead use JSON.stringify or toJsonString for
   * stringified JSON.  Alternatively, if actual JSON is desired, you should
   * use toJson.
   */
  toJSON() {
    return this.toJson({
      emitDefaultValues: !0
    });
  }
  /**
   * Retrieve the MessageType of this message - a singleton that represents
   * the protobuf message declaration and provides metadata for reflection-
   * based operations.
   */
  getType() {
    return Object.getPrototypeOf(this).constructor;
  }
}
function makeMessageType(a, u, c, l) {
  var v;
  const p = (v = l == null ? void 0 : l.localName) !== null && v !== void 0 ? v : u.substring(u.lastIndexOf(".") + 1), _ = {
    [p]: function(I) {
      a.util.initFields(this), a.util.initPartial(I, this);
    }
  }[p];
  return Object.setPrototypeOf(_.prototype, new Message()), Object.assign(_, {
    runtime: a,
    typeName: u,
    fields: a.util.newFieldList(c),
    fromBinary(I, P) {
      return new _().fromBinary(I, P);
    },
    fromJson(I, P) {
      return new _().fromJson(I, P);
    },
    fromJsonString(I, P) {
      return new _().fromJsonString(I, P);
    },
    equals(I, P) {
      return a.util.equals(_, I, P);
    }
  }), _;
}
function makeProtoRuntime(a, u, c, l) {
  return {
    syntax: a,
    json: u,
    bin: c,
    util: l,
    makeMessageType(v, p, _) {
      return makeMessageType(this, v, p, _);
    },
    makeEnum,
    makeEnumType,
    getEnumType
  };
}
var ScalarType;
(function(a) {
  a[a.DOUBLE = 1] = "DOUBLE", a[a.FLOAT = 2] = "FLOAT", a[a.INT64 = 3] = "INT64", a[a.UINT64 = 4] = "UINT64", a[a.INT32 = 5] = "INT32", a[a.FIXED64 = 6] = "FIXED64", a[a.FIXED32 = 7] = "FIXED32", a[a.BOOL = 8] = "BOOL", a[a.STRING = 9] = "STRING", a[a.BYTES = 12] = "BYTES", a[a.UINT32 = 13] = "UINT32", a[a.SFIXED32 = 15] = "SFIXED32", a[a.SFIXED64 = 16] = "SFIXED64", a[a.SINT32 = 17] = "SINT32", a[a.SINT64 = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(a) {
  a[a.BIGINT = 0] = "BIGINT", a[a.STRING = 1] = "STRING";
})(LongType || (LongType = {}));
function varint64read() {
  let a = 0, u = 0;
  for (let l = 0; l < 28; l += 7) {
    let v = this.buf[this.pos++];
    if (a |= (v & 127) << l, !(v & 128))
      return this.assertBounds(), [a, u];
  }
  let c = this.buf[this.pos++];
  if (a |= (c & 15) << 28, u = (c & 112) >> 4, !(c & 128))
    return this.assertBounds(), [a, u];
  for (let l = 3; l <= 31; l += 7) {
    let v = this.buf[this.pos++];
    if (u |= (v & 127) << l, !(v & 128))
      return this.assertBounds(), [a, u];
  }
  throw new Error("invalid varint");
}
function varint64write(a, u, c) {
  for (let p = 0; p < 28; p = p + 7) {
    const _ = a >>> p, I = !(!(_ >>> 7) && u == 0), P = (I ? _ | 128 : _) & 255;
    if (c.push(P), !I)
      return;
  }
  const l = a >>> 28 & 15 | (u & 7) << 4, v = !!(u >> 3);
  if (c.push((v ? l | 128 : l) & 255), !!v) {
    for (let p = 3; p < 31; p = p + 7) {
      const _ = u >>> p, I = !!(_ >>> 7), P = (I ? _ | 128 : _) & 255;
      if (c.push(P), !I)
        return;
    }
    c.push(u >>> 31 & 1);
  }
}
const TWO_PWR_32_DBL = 4294967296;
function int64FromString(a) {
  const u = a[0] === "-";
  u && (a = a.slice(1));
  const c = 1e6;
  let l = 0, v = 0;
  function p(_, I) {
    const P = Number(a.slice(_, I));
    v *= c, l = l * c + P, l >= TWO_PWR_32_DBL && (v = v + (l / TWO_PWR_32_DBL | 0), l = l % TWO_PWR_32_DBL);
  }
  return p(-24, -18), p(-18, -12), p(-12, -6), p(-6), u ? negate(l, v) : newBits(l, v);
}
function int64ToString(a, u) {
  let c = newBits(a, u);
  const l = c.hi & 2147483648;
  l && (c = negate(c.lo, c.hi));
  const v = uInt64ToString(c.lo, c.hi);
  return l ? "-" + v : v;
}
function uInt64ToString(a, u) {
  if ({
    lo: a,
    hi: u
  } = toUnsigned(a, u), u <= 2097151)
    return String(TWO_PWR_32_DBL * u + a);
  const c = a & 16777215, l = (a >>> 24 | u << 8) & 16777215, v = u >> 16 & 65535;
  let p = c + l * 6777216 + v * 6710656, _ = l + v * 8147497, I = v * 2;
  const P = 1e7;
  return p >= P && (_ += Math.floor(p / P), p %= P), _ >= P && (I += Math.floor(_ / P), _ %= P), I.toString() + decimalFrom1e7WithLeadingZeros(_) + decimalFrom1e7WithLeadingZeros(p);
}
function toUnsigned(a, u) {
  return {
    lo: a >>> 0,
    hi: u >>> 0
  };
}
function newBits(a, u) {
  return {
    lo: a | 0,
    hi: u | 0
  };
}
function negate(a, u) {
  return u = ~u, a ? a = ~a + 1 : u += 1, newBits(a, u);
}
const decimalFrom1e7WithLeadingZeros = (a) => {
  const u = String(a);
  return "0000000".slice(u.length) + u;
};
function varint32write(a, u) {
  if (a >= 0) {
    for (; a > 127; )
      u.push(a & 127 | 128), a = a >>> 7;
    u.push(a);
  } else {
    for (let c = 0; c < 9; c++)
      u.push(a & 127 | 128), a = a >> 7;
    u.push(1);
  }
}
function varint32read() {
  let a = this.buf[this.pos++], u = a & 127;
  if (!(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 7, !(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 14, !(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 21, !(a & 128))
    return this.assertBounds(), u;
  a = this.buf[this.pos++], u |= (a & 15) << 28;
  for (let c = 5; a & 128 && c < 10; c++)
    a = this.buf[this.pos++];
  if (a & 128)
    throw new Error("invalid varint");
  return this.assertBounds(), u >>> 0;
}
function makeInt64Support() {
  const a = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof a.getBigInt64 == "function" && typeof a.getBigUint64 == "function" && typeof a.setBigInt64 == "function" && typeof a.setBigUint64 == "function" && (typeof process$1 != "object" || typeof process$1.env != "object" || process$1.env.BUF_BIGINT_DISABLE !== "1")) {
    const v = BigInt("-9223372036854775808"), p = BigInt("9223372036854775807"), _ = BigInt("0"), I = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(P) {
        const $ = typeof P == "bigint" ? P : BigInt(P);
        if ($ > p || $ < v)
          throw new Error("int64 invalid: ".concat(P));
        return $;
      },
      uParse(P) {
        const $ = typeof P == "bigint" ? P : BigInt(P);
        if ($ > I || $ < _)
          throw new Error("uint64 invalid: ".concat(P));
        return $;
      },
      enc(P) {
        return a.setBigInt64(0, this.parse(P), !0), {
          lo: a.getInt32(0, !0),
          hi: a.getInt32(4, !0)
        };
      },
      uEnc(P) {
        return a.setBigInt64(0, this.uParse(P), !0), {
          lo: a.getInt32(0, !0),
          hi: a.getInt32(4, !0)
        };
      },
      dec(P, $) {
        return a.setInt32(0, P, !0), a.setInt32(4, $, !0), a.getBigInt64(0, !0);
      },
      uDec(P, $) {
        return a.setInt32(0, P, !0), a.setInt32(4, $, !0), a.getBigUint64(0, !0);
      }
    };
  }
  const c = (v) => assert$k(/^-?[0-9]+$/.test(v), "int64 invalid: ".concat(v)), l = (v) => assert$k(/^[0-9]+$/.test(v), "uint64 invalid: ".concat(v));
  return {
    zero: "0",
    supported: !1,
    parse(v) {
      return typeof v != "string" && (v = v.toString()), c(v), v;
    },
    uParse(v) {
      return typeof v != "string" && (v = v.toString()), l(v), v;
    },
    enc(v) {
      return typeof v != "string" && (v = v.toString()), c(v), int64FromString(v);
    },
    uEnc(v) {
      return typeof v != "string" && (v = v.toString()), l(v), int64FromString(v);
    },
    dec(v, p) {
      return int64ToString(v, p);
    },
    uDec(v, p) {
      return uInt64ToString(v, p);
    }
  };
}
const protoInt64 = makeInt64Support();
var WireType;
(function(a) {
  a[a.Varint = 0] = "Varint", a[a.Bit64 = 1] = "Bit64", a[a.LengthDelimited = 2] = "LengthDelimited", a[a.StartGroup = 3] = "StartGroup", a[a.EndGroup = 4] = "EndGroup", a[a.Bit32 = 5] = "Bit32";
})(WireType || (WireType = {}));
class BinaryWriter {
  constructor(u) {
    this.stack = [], this.textEncoder = u ?? new TextEncoder(), this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let u = 0;
    for (let v = 0; v < this.chunks.length; v++)
      u += this.chunks[v].length;
    let c = new Uint8Array(u), l = 0;
    for (let v = 0; v < this.chunks.length; v++)
      c.set(this.chunks[v], l), l += this.chunks[v].length;
    return this.chunks = [], c;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({
      chunks: this.chunks,
      buf: this.buf
    }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let u = this.finish(), c = this.stack.pop();
    if (!c)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = c.chunks, this.buf = c.buf, this.uint32(u.byteLength), this.raw(u);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(u, c) {
    return this.uint32((u << 3 | c) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(u) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(u), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(u) {
    for (assertUInt32(u); u > 127; )
      this.buf.push(u & 127 | 128), u = u >>> 7;
    return this.buf.push(u), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(u) {
    return assertInt32(u), varint32write(u, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(u) {
    return this.buf.push(u ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(u) {
    return this.uint32(u.byteLength), this.raw(u);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(u) {
    let c = this.textEncoder.encode(u);
    return this.uint32(c.byteLength), this.raw(c);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(u) {
    assertFloat32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setFloat32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(u) {
    let c = new Uint8Array(8);
    return new DataView(c.buffer).setFloat64(0, u, !0), this.raw(c);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(u) {
    assertUInt32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setUint32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(u) {
    assertInt32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setInt32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(u) {
    return assertInt32(u), u = (u << 1 ^ u >> 31) >>> 0, varint32write(u, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(u) {
    let c = new Uint8Array(8), l = new DataView(c.buffer), v = protoInt64.enc(u);
    return l.setInt32(0, v.lo, !0), l.setInt32(4, v.hi, !0), this.raw(c);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(u) {
    let c = new Uint8Array(8), l = new DataView(c.buffer), v = protoInt64.uEnc(u);
    return l.setInt32(0, v.lo, !0), l.setInt32(4, v.hi, !0), this.raw(c);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(u) {
    let c = protoInt64.enc(u);
    return varint64write(c.lo, c.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(u) {
    let c = protoInt64.enc(u), l = c.hi >> 31, v = c.lo << 1 ^ l, p = (c.hi << 1 | c.lo >>> 31) ^ l;
    return varint64write(v, p, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(u) {
    let c = protoInt64.uEnc(u);
    return varint64write(c.lo, c.hi, this.buf), this;
  }
}
class BinaryReader {
  constructor(u, c) {
    this.varint64 = varint64read, this.uint32 = varint32read, this.buf = u, this.len = u.length, this.pos = 0, this.view = new DataView(u.buffer, u.byteOffset, u.byteLength), this.textDecoder = c ?? new TextDecoder();
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let u = this.uint32(), c = u >>> 3, l = u & 7;
    if (c <= 0 || l < 0 || l > 5)
      throw new Error("illegal tag: field no " + c + " wire type " + l);
    return [c, l];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(u) {
    let c = this.pos;
    switch (u) {
      case WireType.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let l = this.uint32();
        this.pos += l;
        break;
      case WireType.StartGroup:
        let v;
        for (; (v = this.tag()[1]) !== WireType.EndGroup; )
          this.skip(v);
        break;
      default:
        throw new Error("cant skip wire type " + u);
    }
    return this.assertBounds(), this.buf.subarray(c, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let u = this.uint32();
    return u >>> 1 ^ -(u & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [u, c] = this.varint64(), l = -(u & 1);
    return u = (u >>> 1 | (c & 1) << 31) ^ l, c = c >>> 1 ^ l, protoInt64.dec(u, c);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [u, c] = this.varint64();
    return u !== 0 || c !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let u = this.uint32(), c = this.pos;
    return this.pos += u, this.assertBounds(), this.buf.subarray(c, c + u);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
}
function wrapField(a, u) {
  return u instanceof Message || !a.fieldWrapper ? u : a.fieldWrapper.wrapField(u);
}
ScalarType.DOUBLE, ScalarType.FLOAT, ScalarType.INT64, ScalarType.UINT64, ScalarType.INT32, ScalarType.UINT32, ScalarType.BOOL, ScalarType.STRING, ScalarType.BYTES;
function scalarEquals(a, u, c) {
  if (u === c)
    return !0;
  if (a == ScalarType.BYTES) {
    if (!(u instanceof Uint8Array) || !(c instanceof Uint8Array) || u.length !== c.length)
      return !1;
    for (let l = 0; l < u.length; l++)
      if (u[l] !== c[l])
        return !1;
    return !0;
  }
  switch (a) {
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return u == c;
  }
  return !1;
}
function scalarDefaultValue(a, u) {
  switch (a) {
    case ScalarType.BOOL:
      return !1;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return u == 0 ? protoInt64.zero : "0";
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
function scalarTypeInfo(a, u) {
  const c = u === void 0;
  let l = WireType.Varint, v = u === 0;
  switch (a) {
    case ScalarType.STRING:
      v = c || !u.length, l = WireType.LengthDelimited;
      break;
    case ScalarType.BOOL:
      v = u === !1;
      break;
    case ScalarType.DOUBLE:
      l = WireType.Bit64;
      break;
    case ScalarType.FLOAT:
      l = WireType.Bit32;
      break;
    case ScalarType.INT64:
      v = c || u == 0;
      break;
    case ScalarType.UINT64:
      v = c || u == 0;
      break;
    case ScalarType.FIXED64:
      v = c || u == 0, l = WireType.Bit64;
      break;
    case ScalarType.BYTES:
      v = c || !u.byteLength, l = WireType.LengthDelimited;
      break;
    case ScalarType.FIXED32:
      l = WireType.Bit32;
      break;
    case ScalarType.SFIXED32:
      l = WireType.Bit32;
      break;
    case ScalarType.SFIXED64:
      v = c || u == 0, l = WireType.Bit64;
      break;
    case ScalarType.SINT64:
      v = c || u == 0;
      break;
  }
  const p = ScalarType[a].toLowerCase();
  return [l, p, c || v];
}
const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields"), readDefaults = {
  readUnknownFields: !0,
  readerFactory: (a) => new BinaryReader(a)
}, writeDefaults = {
  writeUnknownFields: !0,
  writerFactory: () => new BinaryWriter()
};
function makeReadOptions$1(a) {
  return a ? Object.assign(Object.assign({}, readDefaults), a) : readDefaults;
}
function makeWriteOptions$1(a) {
  return a ? Object.assign(Object.assign({}, writeDefaults), a) : writeDefaults;
}
function makeBinaryFormatCommon() {
  return {
    makeReadOptions: makeReadOptions$1,
    makeWriteOptions: makeWriteOptions$1,
    listUnknownFields(a) {
      var u;
      return (u = a[unknownFieldsSymbol]) !== null && u !== void 0 ? u : [];
    },
    discardUnknownFields(a) {
      delete a[unknownFieldsSymbol];
    },
    writeUnknownFields(a, u) {
      const l = a[unknownFieldsSymbol];
      if (l)
        for (const v of l)
          u.tag(v.no, v.wireType).raw(v.data);
    },
    onUnknownField(a, u, c, l) {
      const v = a;
      Array.isArray(v[unknownFieldsSymbol]) || (v[unknownFieldsSymbol] = []), v[unknownFieldsSymbol].push({
        no: u,
        wireType: c,
        data: l
      });
    },
    readMessage(a, u, c, l) {
      const v = a.getType(), p = c === void 0 ? u.len : u.pos + c;
      for (; u.pos < p; ) {
        const [_, I] = u.tag(), P = v.fields.find(_);
        if (!P) {
          const j = u.skip(I);
          l.readUnknownFields && this.onUnknownField(a, _, I, j);
          continue;
        }
        let $ = a, F = P.repeated, H = P.localName;
        switch (P.oneof && ($ = $[P.oneof.localName], $.case != H && delete $.value, $.case = H, H = "value"), P.kind) {
          case "scalar":
          case "enum":
            const j = P.kind == "enum" ? ScalarType.INT32 : P.T;
            let ee = readScalar$1;
            if (P.kind == "scalar" && P.L > 0 && (ee = readScalarLTString), F) {
              let ne = $[H];
              if (I == WireType.LengthDelimited && j != ScalarType.STRING && j != ScalarType.BYTES) {
                let Z = u.uint32() + u.pos;
                for (; u.pos < Z; )
                  ne.push(ee(u, j));
              } else
                ne.push(ee(u, j));
            } else
              $[H] = ee(u, j);
            break;
          case "message":
            const X = P.T;
            F ? $[H].push(readMessageField(u, new X(), l)) : $[H] instanceof Message ? readMessageField(u, $[H], l) : ($[H] = readMessageField(u, new X(), l), X.fieldWrapper && !P.oneof && !P.repeated && ($[H] = X.fieldWrapper.unwrapField($[H])));
            break;
          case "map":
            let [ie, Q] = readMapEntry(P, u, l);
            $[H][ie] = Q;
            break;
        }
      }
    }
  };
}
function readMessageField(a, u, c) {
  return u.getType().runtime.bin.readMessage(u, a, a.uint32(), c), u;
}
function readMapEntry(a, u, c) {
  const l = u.uint32(), v = u.pos + l;
  let p, _;
  for (; u.pos < v; ) {
    let [I] = u.tag();
    switch (I) {
      case 1:
        p = readScalar$1(u, a.K);
        break;
      case 2:
        switch (a.V.kind) {
          case "scalar":
            _ = readScalar$1(u, a.V.T);
            break;
          case "enum":
            _ = u.int32();
            break;
          case "message":
            _ = readMessageField(u, new a.V.T(), c);
            break;
        }
        break;
    }
  }
  if (p === void 0) {
    let I = scalarDefaultValue(a.K, LongType.BIGINT);
    p = a.K == ScalarType.BOOL ? I.toString() : I;
  }
  if (typeof p != "string" && typeof p != "number" && (p = p.toString()), _ === void 0)
    switch (a.V.kind) {
      case "scalar":
        _ = scalarDefaultValue(a.V.T, LongType.BIGINT);
        break;
      case "enum":
        _ = 0;
        break;
      case "message":
        _ = new a.V.T();
        break;
    }
  return [p, _];
}
function readScalarLTString(a, u) {
  const c = readScalar$1(a, u);
  return typeof c == "bigint" ? c.toString() : c;
}
function readScalar$1(a, u) {
  switch (u) {
    case ScalarType.STRING:
      return a.string();
    case ScalarType.BOOL:
      return a.bool();
    case ScalarType.DOUBLE:
      return a.double();
    case ScalarType.FLOAT:
      return a.float();
    case ScalarType.INT32:
      return a.int32();
    case ScalarType.INT64:
      return a.int64();
    case ScalarType.UINT64:
      return a.uint64();
    case ScalarType.FIXED64:
      return a.fixed64();
    case ScalarType.BYTES:
      return a.bytes();
    case ScalarType.FIXED32:
      return a.fixed32();
    case ScalarType.SFIXED32:
      return a.sfixed32();
    case ScalarType.SFIXED64:
      return a.sfixed64();
    case ScalarType.SINT64:
      return a.sint64();
    case ScalarType.UINT32:
      return a.uint32();
    case ScalarType.SINT32:
      return a.sint32();
  }
}
function writeMapEntry(a, u, c, l, v) {
  a.tag(c.no, WireType.LengthDelimited), a.fork();
  let p = l;
  switch (c.K) {
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      p = Number.parseInt(l);
      break;
    case ScalarType.BOOL:
      assert$k(l == "true" || l == "false"), p = l == "true";
      break;
  }
  switch (writeScalar$1(a, c.K, 1, p, !0), c.V.kind) {
    case "scalar":
      writeScalar$1(a, c.V.T, 2, v, !0);
      break;
    case "enum":
      writeScalar$1(a, ScalarType.INT32, 2, v, !0);
      break;
    case "message":
      writeMessageField(a, u, c.V.T, 2, v);
      break;
  }
  a.join();
}
function writeMessageField(a, u, c, l, v) {
  if (v !== void 0) {
    const p = wrapField(c, v);
    a.tag(l, WireType.LengthDelimited).bytes(p.toBinary(u));
  }
}
function writeScalar$1(a, u, c, l, v) {
  let [p, _, I] = scalarTypeInfo(u, l);
  (!I || v) && a.tag(c, p)[_](l);
}
function writePacked(a, u, c, l) {
  if (!l.length)
    return;
  a.tag(c, WireType.LengthDelimited).fork();
  let [, v] = scalarTypeInfo(u);
  for (let p = 0; p < l.length; p++)
    a[v](l[p]);
  a.join();
}
function makeBinaryFormatProto3() {
  return Object.assign(Object.assign({}, makeBinaryFormatCommon()), {
    writeMessage(a, u, c) {
      const l = a.getType();
      for (const v of l.fields.byNumber()) {
        let p, _ = v.repeated, I = v.localName;
        if (v.oneof) {
          const P = a[v.oneof.localName];
          if (P.case !== I)
            continue;
          p = P.value;
        } else
          p = a[I];
        switch (v.kind) {
          case "scalar":
          case "enum":
            let P = v.kind == "enum" ? ScalarType.INT32 : v.T;
            if (_)
              if (v.packed)
                writePacked(u, P, v.no, p);
              else
                for (const $ of p)
                  writeScalar$1(u, P, v.no, $, !0);
            else
              p !== void 0 && writeScalar$1(u, P, v.no, p, !!v.oneof || v.opt);
            break;
          case "message":
            if (_)
              for (const $ of p)
                writeMessageField(u, c, v.T, v.no, $);
            else
              writeMessageField(u, c, v.T, v.no, p);
            break;
          case "map":
            for (const [$, F] of Object.entries(p))
              writeMapEntry(u, c, v, $, F);
            break;
        }
      }
      return c.writeUnknownFields && this.writeUnknownFields(a, u), u;
    }
  });
}
let encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), decTable = [];
for (let a = 0; a < encTable.length; a++)
  decTable[encTable[a].charCodeAt(0)] = a;
decTable[45] = encTable.indexOf("+");
decTable[95] = encTable.indexOf("/");
const protoBase64 = {
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  dec(a) {
    let u = a.length * 3 / 4;
    a[a.length - 2] == "=" ? u -= 2 : a[a.length - 1] == "=" && (u -= 1);
    let c = new Uint8Array(u), l = 0, v = 0, p, _ = 0;
    for (let I = 0; I < a.length; I++) {
      if (p = decTable[a.charCodeAt(I)], p === void 0)
        switch (a[I]) {
          case "=":
            v = 0;
          case `
`:
          case "\r":
          case "	":
          case " ":
            continue;
          default:
            throw Error("invalid base64 string.");
        }
      switch (v) {
        case 0:
          _ = p, v = 1;
          break;
        case 1:
          c[l++] = _ << 2 | (p & 48) >> 4, _ = p, v = 2;
          break;
        case 2:
          c[l++] = (_ & 15) << 4 | (p & 60) >> 2, _ = p, v = 3;
          break;
        case 3:
          c[l++] = (_ & 3) << 6 | p, v = 0;
          break;
      }
    }
    if (v == 1)
      throw Error("invalid base64 string.");
    return c.subarray(0, l);
  },
  /**
   * Encode a byte array to a base64 string.
   */
  enc(a) {
    let u = "", c = 0, l, v = 0;
    for (let p = 0; p < a.length; p++)
      switch (l = a[p], c) {
        case 0:
          u += encTable[l >> 2], v = (l & 3) << 4, c = 1;
          break;
        case 1:
          u += encTable[v | l >> 4], v = (l & 15) << 2, c = 2;
          break;
        case 2:
          u += encTable[v | l >> 6], u += encTable[l & 63], c = 0;
          break;
      }
    return c && (u += encTable[v], u += "=", c == 1 && (u += "=")), u;
  }
}, jsonReadDefaults = {
  ignoreUnknownFields: !1
}, jsonWriteDefaults = {
  emitDefaultValues: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1,
  prettySpaces: 0
};
function makeReadOptions(a) {
  return a ? Object.assign(Object.assign({}, jsonReadDefaults), a) : jsonReadDefaults;
}
function makeWriteOptions(a) {
  return a ? Object.assign(Object.assign({}, jsonWriteDefaults), a) : jsonWriteDefaults;
}
function makeJsonFormatCommon(a) {
  const u = a(writeEnum, writeScalar);
  return {
    makeReadOptions,
    makeWriteOptions,
    readMessage(c, l, v, p) {
      if (l == null || Array.isArray(l) || typeof l != "object")
        throw new Error("cannot decode message ".concat(c.typeName, " from JSON: ").concat(this.debug(l)));
      p = p ?? new c();
      const _ = {};
      for (const [I, P] of Object.entries(l)) {
        const $ = c.fields.findJsonName(I);
        if (!$) {
          if (!v.ignoreUnknownFields)
            throw new Error("cannot decode message ".concat(c.typeName, ' from JSON: key "').concat(I, '" is unknown'));
          continue;
        }
        let F = $.localName, H = p;
        if ($.oneof) {
          if (P === null && $.kind == "scalar")
            continue;
          const j = _[$.oneof.localName];
          if (j)
            throw new Error("cannot decode message ".concat(c.typeName, ' from JSON: multiple keys for oneof "').concat($.oneof.name, '" present: "').concat(j, '", "').concat(I, '"'));
          _[$.oneof.localName] = I, H = H[$.oneof.localName] = {
            case: F
          }, F = "value";
        }
        if ($.repeated) {
          if (P === null)
            continue;
          if (!Array.isArray(P))
            throw new Error("cannot decode field ".concat(c.typeName, ".").concat($.name, " from JSON: ").concat(this.debug(P)));
          const j = H[F];
          for (const ee of P) {
            if (ee === null)
              throw new Error("cannot decode field ".concat(c.typeName, ".").concat($.name, " from JSON: ").concat(this.debug(ee)));
            let X;
            switch ($.kind) {
              case "message":
                X = $.T.fromJson(ee, v);
                break;
              case "enum":
                if (X = readEnum($.T, ee, v.ignoreUnknownFields), X === void 0)
                  continue;
                break;
              case "scalar":
                try {
                  X = readScalar($.T, ee, $.L);
                } catch (ie) {
                  let Q = "cannot decode field ".concat(c.typeName, ".").concat($.name, " from JSON: ").concat(this.debug(ee));
                  throw ie instanceof Error && ie.message.length > 0 && (Q += ": ".concat(ie.message)), new Error(Q);
                }
                break;
            }
            j.push(X);
          }
        } else if ($.kind == "map") {
          if (P === null)
            continue;
          if (Array.isArray(P) || typeof P != "object")
            throw new Error("cannot decode field ".concat(c.typeName, ".").concat($.name, " from JSON: ").concat(this.debug(P)));
          const j = H[F];
          for (const [ee, X] of Object.entries(P)) {
            if (X === null)
              throw new Error("cannot decode field ".concat(c.typeName, ".").concat($.name, " from JSON: map value null"));
            let ie;
            switch ($.V.kind) {
              case "message":
                ie = $.V.T.fromJson(X, v);
                break;
              case "enum":
                if (ie = readEnum($.V.T, X, v.ignoreUnknownFields), ie === void 0)
                  continue;
                break;
              case "scalar":
                try {
                  ie = readScalar($.V.T, X, LongType.BIGINT);
                } catch (Q) {
                  let ne = "cannot decode map value for field ".concat(c.typeName, ".").concat($.name, " from JSON: ").concat(this.debug(P));
                  throw Q instanceof Error && Q.message.length > 0 && (ne += ": ".concat(Q.message)), new Error(ne);
                }
                break;
            }
            try {
              j[readScalar($.K, $.K == ScalarType.BOOL ? ee == "true" ? !0 : ee == "false" ? !1 : ee : ee, LongType.BIGINT).toString()] = ie;
            } catch (Q) {
              let ne = "cannot decode map key for field ".concat(c.typeName, ".").concat($.name, " from JSON: ").concat(this.debug(P));
              throw Q instanceof Error && Q.message.length > 0 && (ne += ": ".concat(Q.message)), new Error(ne);
            }
          }
        } else
          switch ($.kind) {
            case "message":
              const j = $.T;
              if (P === null && j.typeName != "google.protobuf.Value") {
                if ($.oneof)
                  throw new Error("cannot decode field ".concat(c.typeName, ".").concat($.name, ' from JSON: null is invalid for oneof field "').concat(I, '"'));
                continue;
              }
              H[F] instanceof Message ? H[F].fromJson(P, v) : (H[F] = j.fromJson(P, v), j.fieldWrapper && !$.oneof && (H[F] = j.fieldWrapper.unwrapField(H[F])));
              break;
            case "enum":
              const ee = readEnum($.T, P, v.ignoreUnknownFields);
              ee !== void 0 && (H[F] = ee);
              break;
            case "scalar":
              try {
                H[F] = readScalar($.T, P, $.L);
              } catch (X) {
                let ie = "cannot decode field ".concat(c.typeName, ".").concat($.name, " from JSON: ").concat(this.debug(P));
                throw X instanceof Error && X.message.length > 0 && (ie += ": ".concat(X.message)), new Error(ie);
              }
              break;
          }
      }
      return p;
    },
    writeMessage(c, l) {
      const v = c.getType(), p = {};
      let _;
      try {
        for (const I of v.fields.byMember()) {
          let P;
          if (I.kind == "oneof") {
            const $ = c[I.localName];
            if ($.value === void 0)
              continue;
            if (_ = I.findField($.case), !_)
              throw "oneof case not found: " + $.case;
            P = u(_, $.value, l);
          } else
            _ = I, P = u(_, c[_.localName], l);
          P !== void 0 && (p[l.useProtoFieldName ? _.name : _.jsonName] = P);
        }
      } catch (I) {
        const P = _ ? "cannot encode field ".concat(v.typeName, ".").concat(_.name, " to JSON") : "cannot encode message ".concat(v.typeName, " to JSON"), $ = I instanceof Error ? I.message : String(I);
        throw new Error(P + ($.length > 0 ? ": ".concat($) : ""));
      }
      return p;
    },
    readScalar,
    writeScalar,
    debug: debugJsonValue
  };
}
function debugJsonValue(a) {
  if (a === null)
    return "null";
  switch (typeof a) {
    case "object":
      return Array.isArray(a) ? "array" : "object";
    case "string":
      return a.length > 100 ? "string" : '"'.concat(a.split('"').join('\\"'), '"');
    default:
      return String(a);
  }
}
function readScalar(a, u, c) {
  switch (a) {
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      if (u === null)
        return 0;
      if (u === "NaN")
        return Number.NaN;
      if (u === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (u === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (u === "" || typeof u == "string" && u.trim().length !== u.length || typeof u != "string" && typeof u != "number")
        break;
      const l = Number(u);
      if (Number.isNaN(l) || !Number.isFinite(l))
        break;
      return a == ScalarType.FLOAT && assertFloat32(l), l;
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.UINT32:
      if (u === null)
        return 0;
      let v;
      if (typeof u == "number" ? v = u : typeof u == "string" && u.length > 0 && u.trim().length === u.length && (v = Number(u)), v === void 0)
        break;
      return a == ScalarType.UINT32 ? assertUInt32(v) : assertInt32(v), v;
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (u === null)
        return protoInt64.zero;
      if (typeof u != "number" && typeof u != "string")
        break;
      const p = protoInt64.parse(u);
      return c ? p.toString() : p;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (u === null)
        return protoInt64.zero;
      if (typeof u != "number" && typeof u != "string")
        break;
      const _ = protoInt64.uParse(u);
      return c ? _.toString() : _;
    case ScalarType.BOOL:
      if (u === null)
        return !1;
      if (typeof u != "boolean")
        break;
      return u;
    case ScalarType.STRING:
      if (u === null)
        return "";
      if (typeof u != "string")
        break;
      try {
        encodeURIComponent(u);
      } catch {
        throw new Error("invalid UTF8");
      }
      return u;
    case ScalarType.BYTES:
      if (u === null || u === "")
        return new Uint8Array(0);
      if (typeof u != "string")
        break;
      return protoBase64.dec(u);
  }
  throw new Error();
}
function readEnum(a, u, c) {
  if (u === null)
    return 0;
  switch (typeof u) {
    case "number":
      if (Number.isInteger(u))
        return u;
      break;
    case "string":
      const l = a.findName(u);
      if (l || c)
        return l == null ? void 0 : l.no;
      break;
  }
  throw new Error("cannot decode enum ".concat(a.typeName, " from JSON: ").concat(debugJsonValue(u)));
}
function writeEnum(a, u, c, l) {
  var v;
  if (u === void 0)
    return u;
  if (u === 0 && !c)
    return;
  if (l)
    return u;
  if (a.typeName == "google.protobuf.NullValue")
    return null;
  const p = a.findNumber(u);
  return (v = p == null ? void 0 : p.name) !== null && v !== void 0 ? v : u;
}
function writeScalar(a, u, c) {
  if (u !== void 0)
    switch (a) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        return assert$k(typeof u == "number"), u != 0 || c ? u : void 0;
      case ScalarType.FLOAT:
      case ScalarType.DOUBLE:
        return assert$k(typeof u == "number"), Number.isNaN(u) ? "NaN" : u === Number.POSITIVE_INFINITY ? "Infinity" : u === Number.NEGATIVE_INFINITY ? "-Infinity" : u !== 0 || c ? u : void 0;
      case ScalarType.STRING:
        return assert$k(typeof u == "string"), u.length > 0 || c ? u : void 0;
      case ScalarType.BOOL:
        return assert$k(typeof u == "boolean"), u || c ? u : void 0;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return assert$k(typeof u == "bigint" || typeof u == "string" || typeof u == "number"), c || u != 0 ? u.toString(10) : void 0;
      case ScalarType.BYTES:
        return assert$k(u instanceof Uint8Array), c || u.byteLength > 0 ? protoBase64.enc(u) : void 0;
    }
}
function makeJsonFormatProto3() {
  return makeJsonFormatCommon((a, u) => function(l, v, p) {
    if (l.kind == "map") {
      const _ = {};
      switch (l.V.kind) {
        case "scalar":
          for (const [P, $] of Object.entries(v)) {
            const F = u(l.V.T, $, !0);
            assert$k(F !== void 0), _[P.toString()] = F;
          }
          break;
        case "message":
          for (const [P, $] of Object.entries(v))
            _[P.toString()] = $.toJson(p);
          break;
        case "enum":
          const I = l.V.T;
          for (const [P, $] of Object.entries(v)) {
            assert$k($ === void 0 || typeof $ == "number");
            const F = a(I, $, !0, p.enumAsInteger);
            assert$k(F !== void 0), _[P.toString()] = F;
          }
          break;
      }
      return p.emitDefaultValues || Object.keys(_).length > 0 ? _ : void 0;
    } else if (l.repeated) {
      const _ = [];
      switch (l.kind) {
        case "scalar":
          for (let I = 0; I < v.length; I++)
            _.push(u(l.T, v[I], !0));
          break;
        case "enum":
          for (let I = 0; I < v.length; I++)
            _.push(a(l.T, v[I], !0, p.enumAsInteger));
          break;
        case "message":
          for (let I = 0; I < v.length; I++)
            _.push(wrapField(l.T, v[I]).toJson(p));
          break;
      }
      return p.emitDefaultValues || _.length > 0 ? _ : void 0;
    } else
      switch (l.kind) {
        case "scalar":
          return u(l.T, v, !!l.oneof || l.opt || p.emitDefaultValues);
        case "enum":
          return a(l.T, v, !!l.oneof || l.opt || p.emitDefaultValues, p.enumAsInteger);
        case "message":
          return v !== void 0 ? wrapField(l.T, v).toJson(p) : void 0;
      }
  });
}
function makeUtilCommon() {
  return {
    setEnumType,
    initPartial(a, u) {
      if (a === void 0)
        return;
      const c = u.getType();
      for (const l of c.fields.byMember()) {
        const v = l.localName, p = u, _ = a;
        if (_[v] !== void 0)
          switch (l.kind) {
            case "oneof":
              const I = _[v].case;
              if (I === void 0)
                continue;
              const P = l.findField(I);
              let $ = _[v].value;
              P && P.kind == "message" && !($ instanceof P.T) ? $ = new P.T($) : P && P.kind === "scalar" && P.T === ScalarType.BYTES && ($ = toU8Arr($)), p[v] = {
                case: I,
                value: $
              };
              break;
            case "scalar":
            case "enum":
              let F = _[v];
              l.T === ScalarType.BYTES && (F = l.repeated ? F.map(toU8Arr) : toU8Arr(F)), p[v] = F;
              break;
            case "map":
              switch (l.V.kind) {
                case "scalar":
                case "enum":
                  if (l.V.T === ScalarType.BYTES)
                    for (const [ee, X] of Object.entries(_[v]))
                      p[v][ee] = toU8Arr(X);
                  else
                    Object.assign(p[v], _[v]);
                  break;
                case "message":
                  const j = l.V.T;
                  for (const ee of Object.keys(_[v])) {
                    let X = _[v][ee];
                    j.fieldWrapper || (X = new j(X)), p[v][ee] = X;
                  }
                  break;
              }
              break;
            case "message":
              const H = l.T;
              if (l.repeated)
                p[v] = _[v].map((j) => j instanceof H ? j : new H(j));
              else if (_[v] !== void 0) {
                const j = _[v];
                H.fieldWrapper ? /* We can't use BytesValue.typeName as that will create a circular import */ H.typeName === "google.protobuf.BytesValue" ? p[v] = toU8Arr(j) : p[v] = j : p[v] = j instanceof H ? j : new H(j);
              }
              break;
          }
      }
    },
    equals(a, u, c) {
      return u === c ? !0 : !u || !c ? !1 : a.fields.byMember().every((l) => {
        const v = u[l.localName], p = c[l.localName];
        if (l.repeated) {
          if (v.length !== p.length)
            return !1;
          switch (l.kind) {
            case "message":
              return v.every((_, I) => l.T.equals(_, p[I]));
            case "scalar":
              return v.every((_, I) => scalarEquals(l.T, _, p[I]));
            case "enum":
              return v.every((_, I) => scalarEquals(ScalarType.INT32, _, p[I]));
          }
          throw new Error("repeated cannot contain ".concat(l.kind));
        }
        switch (l.kind) {
          case "message":
            return l.T.equals(v, p);
          case "enum":
            return scalarEquals(ScalarType.INT32, v, p);
          case "scalar":
            return scalarEquals(l.T, v, p);
          case "oneof":
            if (v.case !== p.case)
              return !1;
            const _ = l.findField(v.case);
            if (_ === void 0)
              return !0;
            switch (_.kind) {
              case "message":
                return _.T.equals(v.value, p.value);
              case "enum":
                return scalarEquals(ScalarType.INT32, v.value, p.value);
              case "scalar":
                return scalarEquals(_.T, v.value, p.value);
            }
            throw new Error("oneof cannot contain ".concat(_.kind));
          case "map":
            const I = Object.keys(v).concat(Object.keys(p));
            switch (l.V.kind) {
              case "message":
                const P = l.V.T;
                return I.every((F) => P.equals(v[F], p[F]));
              case "enum":
                return I.every((F) => scalarEquals(ScalarType.INT32, v[F], p[F]));
              case "scalar":
                const $ = l.V.T;
                return I.every((F) => scalarEquals($, v[F], p[F]));
            }
            break;
        }
      });
    },
    clone(a) {
      const u = a.getType(), c = new u(), l = c;
      for (const v of u.fields.byMember()) {
        const p = a[v.localName];
        let _;
        if (v.repeated)
          _ = p.map(cloneSingularField);
        else if (v.kind == "map") {
          _ = l[v.localName];
          for (const [I, P] of Object.entries(p))
            _[I] = cloneSingularField(P);
        } else
          v.kind == "oneof" ? _ = v.findField(p.case) ? {
            case: p.case,
            value: cloneSingularField(p.value)
          } : {
            case: void 0
          } : _ = cloneSingularField(p);
        l[v.localName] = _;
      }
      return c;
    }
  };
}
function cloneSingularField(a) {
  if (a === void 0)
    return a;
  if (a instanceof Message)
    return a.clone();
  if (a instanceof Uint8Array) {
    const u = new Uint8Array(a.byteLength);
    return u.set(a), u;
  }
  return a;
}
function toU8Arr(a) {
  return a instanceof Uint8Array ? a : new Uint8Array(a);
}
class InternalFieldList {
  constructor(u, c) {
    this._fields = u, this._normalizer = c;
  }
  findJsonName(u) {
    if (!this.jsonNames) {
      const c = {};
      for (const l of this.list())
        c[l.jsonName] = c[l.name] = l;
      this.jsonNames = c;
    }
    return this.jsonNames[u];
  }
  find(u) {
    if (!this.numbers) {
      const c = {};
      for (const l of this.list())
        c[l.no] = l;
      this.numbers = c;
    }
    return this.numbers[u];
  }
  list() {
    return this.all || (this.all = this._normalizer(this._fields)), this.all;
  }
  byNumber() {
    return this.numbersAsc || (this.numbersAsc = this.list().concat().sort((u, c) => u.no - c.no)), this.numbersAsc;
  }
  byMember() {
    if (!this.members) {
      this.members = [];
      const u = this.members;
      let c;
      for (const l of this.list())
        l.oneof ? l.oneof !== c && (c = l.oneof, u.push(c)) : u.push(l);
    }
    return this.members;
  }
}
function localFieldName(a, u) {
  const c = protoCamelCase(a);
  return u ? c : safeObjectProperty(safeMessageProperty(c));
}
function localOneofName(a) {
  return localFieldName(a, !1);
}
const fieldJsonName = protoCamelCase;
function protoCamelCase(a) {
  let u = !1;
  const c = [];
  for (let l = 0; l < a.length; l++) {
    let v = a.charAt(l);
    switch (v) {
      case "_":
        u = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        c.push(v), u = !1;
        break;
      default:
        u && (u = !1, v = v.toUpperCase()), c.push(v);
        break;
    }
  }
  return c.join("");
}
const reservedObjectProperties = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]), reservedMessageProperties = /* @__PURE__ */ new Set([
  // names reserved by the runtime
  "getType",
  "clone",
  "equals",
  "fromBinary",
  "fromJson",
  "fromJsonString",
  "toBinary",
  "toJson",
  "toJsonString",
  // names reserved by the runtime for the future
  "toObject"
]), fallback = (a) => "".concat(a, "$"), safeMessageProperty = (a) => reservedMessageProperties.has(a) ? fallback(a) : a, safeObjectProperty = (a) => reservedObjectProperties.has(a) ? fallback(a) : a;
class InternalOneofInfo {
  constructor(u) {
    this.kind = "oneof", this.repeated = !1, this.packed = !1, this.opt = !1, this.default = void 0, this.fields = [], this.name = u, this.localName = localOneofName(u);
  }
  addField(u) {
    assert$k(u.oneof === this, "field ".concat(u.name, " not one of ").concat(this.name)), this.fields.push(u);
  }
  findField(u) {
    if (!this._lookup) {
      this._lookup = /* @__PURE__ */ Object.create(null);
      for (let c = 0; c < this.fields.length; c++)
        this._lookup[this.fields[c].localName] = this.fields[c];
    }
    return this._lookup[u];
  }
}
const proto3 = makeProtoRuntime("proto3", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {
  newFieldList(a) {
    return new InternalFieldList(a, normalizeFieldInfosProto3);
  },
  initFields(a) {
    for (const u of a.getType().fields.byMember()) {
      if (u.opt)
        continue;
      const c = u.localName, l = a;
      if (u.repeated) {
        l[c] = [];
        continue;
      }
      switch (u.kind) {
        case "oneof":
          l[c] = {
            case: void 0
          };
          break;
        case "enum":
          l[c] = 0;
          break;
        case "map":
          l[c] = {};
          break;
        case "scalar":
          l[c] = scalarDefaultValue(u.T, u.L);
          break;
      }
    }
  }
}));
function normalizeFieldInfosProto3(a) {
  var u, c, l, v;
  const p = [];
  let _;
  for (const I of typeof a == "function" ? a() : a) {
    const P = I;
    if (P.localName = localFieldName(I.name, I.oneof !== void 0), P.jsonName = (u = I.jsonName) !== null && u !== void 0 ? u : fieldJsonName(I.name), P.repeated = (c = I.repeated) !== null && c !== void 0 ? c : !1, I.kind == "scalar" && (P.L = (l = I.L) !== null && l !== void 0 ? l : LongType.BIGINT), P.packed = (v = I.packed) !== null && v !== void 0 ? v : I.kind == "enum" || I.kind == "scalar" && I.T != ScalarType.BYTES && I.T != ScalarType.STRING, I.oneof !== void 0) {
      const $ = typeof I.oneof == "string" ? I.oneof : I.oneof.name;
      (!_ || _.name != $) && (_ = new InternalOneofInfo($)), P.oneof = _, _.addField(P);
    }
    p.push(P);
  }
  return p;
}
class Timestamp extends Message {
  constructor(u) {
    super(), this.seconds = protoInt64.zero, this.nanos = 0, proto3.util.initPartial(u, this);
  }
  fromJson(u, c) {
    if (typeof u != "string")
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: ".concat(proto3.json.debug(u)));
    const l = u.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!l)
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    const v = Date.parse(l[1] + "-" + l[2] + "-" + l[3] + "T" + l[4] + ":" + l[5] + ":" + l[6] + (l[8] ? l[8] : "Z"));
    if (Number.isNaN(v))
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    if (v < Date.parse("0001-01-01T00:00:00Z") || v > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    return this.seconds = protoInt64.parse(v / 1e3), this.nanos = 0, l[7] && (this.nanos = parseInt("1" + l[7] + "0".repeat(9 - l[7].length)) - 1e9), this;
  }
  toJson(u) {
    const c = Number(this.seconds) * 1e3;
    if (c < Date.parse("0001-01-01T00:00:00Z") || c > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    if (this.nanos < 0)
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative");
    let l = "Z";
    if (this.nanos > 0) {
      const v = (this.nanos + 1e9).toString().substring(1);
      v.substring(3) === "000000" ? l = "." + v.substring(0, 3) + "Z" : v.substring(6) === "000" ? l = "." + v.substring(0, 6) + "Z" : l = "." + v + "Z";
    }
    return new Date(c).toISOString().replace(".000Z", l);
  }
  toDate() {
    return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
  }
  static now() {
    return Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  static fromDate(u) {
    const c = u.getTime();
    return new Timestamp({
      seconds: protoInt64.parse(Math.floor(c / 1e3)),
      nanos: c % 1e3 * 1e6
    });
  }
  static fromBinary(u, c) {
    return new Timestamp().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Timestamp().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Timestamp().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Timestamp, u, c);
  }
}
Timestamp.runtime = proto3;
Timestamp.typeName = "google.protobuf.Timestamp";
Timestamp.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "seconds",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "nanos",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
var AudioCodec$1;
(function(a) {
  a[a.DEFAULT_AC = 0] = "DEFAULT_AC", a[a.OPUS = 1] = "OPUS", a[a.AAC = 2] = "AAC";
})(AudioCodec$1 || (AudioCodec$1 = {}));
proto3.util.setEnumType(AudioCodec$1, "livekit.AudioCodec", [{
  no: 0,
  name: "DEFAULT_AC"
}, {
  no: 1,
  name: "OPUS"
}, {
  no: 2,
  name: "AAC"
}]);
var VideoCodec$1;
(function(a) {
  a[a.DEFAULT_VC = 0] = "DEFAULT_VC", a[a.H264_BASELINE = 1] = "H264_BASELINE", a[a.H264_MAIN = 2] = "H264_MAIN", a[a.H264_HIGH = 3] = "H264_HIGH", a[a.VP8 = 4] = "VP8";
})(VideoCodec$1 || (VideoCodec$1 = {}));
proto3.util.setEnumType(VideoCodec$1, "livekit.VideoCodec", [{
  no: 0,
  name: "DEFAULT_VC"
}, {
  no: 1,
  name: "H264_BASELINE"
}, {
  no: 2,
  name: "H264_MAIN"
}, {
  no: 3,
  name: "H264_HIGH"
}, {
  no: 4,
  name: "VP8"
}]);
var ImageCodec;
(function(a) {
  a[a.IC_DEFAULT = 0] = "IC_DEFAULT", a[a.IC_JPEG = 1] = "IC_JPEG";
})(ImageCodec || (ImageCodec = {}));
proto3.util.setEnumType(ImageCodec, "livekit.ImageCodec", [{
  no: 0,
  name: "IC_DEFAULT"
}, {
  no: 1,
  name: "IC_JPEG"
}]);
var TrackType;
(function(a) {
  a[a.AUDIO = 0] = "AUDIO", a[a.VIDEO = 1] = "VIDEO", a[a.DATA = 2] = "DATA";
})(TrackType || (TrackType = {}));
proto3.util.setEnumType(TrackType, "livekit.TrackType", [{
  no: 0,
  name: "AUDIO"
}, {
  no: 1,
  name: "VIDEO"
}, {
  no: 2,
  name: "DATA"
}]);
var TrackSource;
(function(a) {
  a[a.UNKNOWN = 0] = "UNKNOWN", a[a.CAMERA = 1] = "CAMERA", a[a.MICROPHONE = 2] = "MICROPHONE", a[a.SCREEN_SHARE = 3] = "SCREEN_SHARE", a[a.SCREEN_SHARE_AUDIO = 4] = "SCREEN_SHARE_AUDIO";
})(TrackSource || (TrackSource = {}));
proto3.util.setEnumType(TrackSource, "livekit.TrackSource", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "CAMERA"
}, {
  no: 2,
  name: "MICROPHONE"
}, {
  no: 3,
  name: "SCREEN_SHARE"
}, {
  no: 4,
  name: "SCREEN_SHARE_AUDIO"
}]);
var VideoQuality$1;
(function(a) {
  a[a.LOW = 0] = "LOW", a[a.MEDIUM = 1] = "MEDIUM", a[a.HIGH = 2] = "HIGH", a[a.OFF = 3] = "OFF";
})(VideoQuality$1 || (VideoQuality$1 = {}));
proto3.util.setEnumType(VideoQuality$1, "livekit.VideoQuality", [{
  no: 0,
  name: "LOW"
}, {
  no: 1,
  name: "MEDIUM"
}, {
  no: 2,
  name: "HIGH"
}, {
  no: 3,
  name: "OFF"
}]);
var ConnectionQuality$1;
(function(a) {
  a[a.POOR = 0] = "POOR", a[a.GOOD = 1] = "GOOD", a[a.EXCELLENT = 2] = "EXCELLENT", a[a.LOST = 3] = "LOST";
})(ConnectionQuality$1 || (ConnectionQuality$1 = {}));
proto3.util.setEnumType(ConnectionQuality$1, "livekit.ConnectionQuality", [{
  no: 0,
  name: "POOR"
}, {
  no: 1,
  name: "GOOD"
}, {
  no: 2,
  name: "EXCELLENT"
}, {
  no: 3,
  name: "LOST"
}]);
var ClientConfigSetting;
(function(a) {
  a[a.UNSET = 0] = "UNSET", a[a.DISABLED = 1] = "DISABLED", a[a.ENABLED = 2] = "ENABLED";
})(ClientConfigSetting || (ClientConfigSetting = {}));
proto3.util.setEnumType(ClientConfigSetting, "livekit.ClientConfigSetting", [{
  no: 0,
  name: "UNSET"
}, {
  no: 1,
  name: "DISABLED"
}, {
  no: 2,
  name: "ENABLED"
}]);
var DisconnectReason;
(function(a) {
  a[a.UNKNOWN_REASON = 0] = "UNKNOWN_REASON", a[a.CLIENT_INITIATED = 1] = "CLIENT_INITIATED", a[a.DUPLICATE_IDENTITY = 2] = "DUPLICATE_IDENTITY", a[a.SERVER_SHUTDOWN = 3] = "SERVER_SHUTDOWN", a[a.PARTICIPANT_REMOVED = 4] = "PARTICIPANT_REMOVED", a[a.ROOM_DELETED = 5] = "ROOM_DELETED", a[a.STATE_MISMATCH = 6] = "STATE_MISMATCH", a[a.JOIN_FAILURE = 7] = "JOIN_FAILURE", a[a.MIGRATION = 8] = "MIGRATION", a[a.SIGNAL_CLOSE = 9] = "SIGNAL_CLOSE";
})(DisconnectReason || (DisconnectReason = {}));
proto3.util.setEnumType(DisconnectReason, "livekit.DisconnectReason", [{
  no: 0,
  name: "UNKNOWN_REASON"
}, {
  no: 1,
  name: "CLIENT_INITIATED"
}, {
  no: 2,
  name: "DUPLICATE_IDENTITY"
}, {
  no: 3,
  name: "SERVER_SHUTDOWN"
}, {
  no: 4,
  name: "PARTICIPANT_REMOVED"
}, {
  no: 5,
  name: "ROOM_DELETED"
}, {
  no: 6,
  name: "STATE_MISMATCH"
}, {
  no: 7,
  name: "JOIN_FAILURE"
}, {
  no: 8,
  name: "MIGRATION"
}, {
  no: 9,
  name: "SIGNAL_CLOSE"
}]);
var ReconnectReason;
(function(a) {
  a[a.RR_UNKNOWN = 0] = "RR_UNKNOWN", a[a.RR_SIGNAL_DISCONNECTED = 1] = "RR_SIGNAL_DISCONNECTED", a[a.RR_PUBLISHER_FAILED = 2] = "RR_PUBLISHER_FAILED", a[a.RR_SUBSCRIBER_FAILED = 3] = "RR_SUBSCRIBER_FAILED", a[a.RR_SWITCH_CANDIDATE = 4] = "RR_SWITCH_CANDIDATE";
})(ReconnectReason || (ReconnectReason = {}));
proto3.util.setEnumType(ReconnectReason, "livekit.ReconnectReason", [{
  no: 0,
  name: "RR_UNKNOWN"
}, {
  no: 1,
  name: "RR_SIGNAL_DISCONNECTED"
}, {
  no: 2,
  name: "RR_PUBLISHER_FAILED"
}, {
  no: 3,
  name: "RR_SUBSCRIBER_FAILED"
}, {
  no: 4,
  name: "RR_SWITCH_CANDIDATE"
}]);
var SubscriptionError;
(function(a) {
  a[a.SE_UNKNOWN = 0] = "SE_UNKNOWN", a[a.SE_CODEC_UNSUPPORTED = 1] = "SE_CODEC_UNSUPPORTED", a[a.SE_TRACK_NOTFOUND = 2] = "SE_TRACK_NOTFOUND";
})(SubscriptionError || (SubscriptionError = {}));
proto3.util.setEnumType(SubscriptionError, "livekit.SubscriptionError", [{
  no: 0,
  name: "SE_UNKNOWN"
}, {
  no: 1,
  name: "SE_CODEC_UNSUPPORTED"
}, {
  no: 2,
  name: "SE_TRACK_NOTFOUND"
}]);
let Room$1 = class Gt extends Message {
  constructor(u) {
    super(), this.sid = "", this.name = "", this.emptyTimeout = 0, this.maxParticipants = 0, this.creationTime = protoInt64.zero, this.turnPassword = "", this.enabledCodecs = [], this.metadata = "", this.numParticipants = 0, this.numPublishers = 0, this.activeRecording = !1, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new Gt().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Gt().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Gt().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Gt, u, c);
  }
};
Room$1.runtime = proto3;
Room$1.typeName = "livekit.Room";
Room$1.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "empty_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "max_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "creation_time",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 6,
  name: "turn_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "enabled_codecs",
  kind: "message",
  T: Codec,
  repeated: !0
}, {
  no: 8,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "num_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "num_publishers",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 10,
  name: "active_recording",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "version",
  kind: "message",
  T: TimedVersion
}]);
class Codec extends Message {
  constructor(u) {
    super(), this.mime = "", this.fmtpLine = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new Codec().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Codec().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Codec().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Codec, u, c);
  }
}
Codec.runtime = proto3;
Codec.typeName = "livekit.Codec";
Codec.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "mime",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "fmtp_line",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class PlayoutDelay extends Message {
  constructor(u) {
    super(), this.enabled = !1, this.min = 0, this.max = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new PlayoutDelay().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new PlayoutDelay().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new PlayoutDelay().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(PlayoutDelay, u, c);
  }
}
PlayoutDelay.runtime = proto3;
PlayoutDelay.typeName = "livekit.PlayoutDelay";
PlayoutDelay.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "enabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "min",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "max",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
class ParticipantPermission extends Message {
  constructor(u) {
    super(), this.canSubscribe = !1, this.canPublish = !1, this.canPublishData = !1, this.canPublishSources = [], this.hidden = !1, this.recorder = !1, this.canUpdateMetadata = !1, this.agent = !1, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ParticipantPermission().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ParticipantPermission().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ParticipantPermission().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ParticipantPermission, u, c);
  }
}
ParticipantPermission.runtime = proto3;
ParticipantPermission.typeName = "livekit.ParticipantPermission";
ParticipantPermission.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "can_subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "can_publish",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "can_publish_data",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "can_publish_sources",
  kind: "enum",
  T: proto3.getEnumType(TrackSource),
  repeated: !0
}, {
  no: 7,
  name: "hidden",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "recorder",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 10,
  name: "can_update_metadata",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 11,
  name: "agent",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
class ParticipantInfo extends Message {
  constructor(u) {
    super(), this.sid = "", this.identity = "", this.state = ParticipantInfo_State.JOINING, this.tracks = [], this.metadata = "", this.joinedAt = protoInt64.zero, this.name = "", this.version = 0, this.region = "", this.isPublisher = !1, this.kind = ParticipantInfo_Kind.STANDARD, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ParticipantInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ParticipantInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ParticipantInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ParticipantInfo, u, c);
  }
}
ParticipantInfo.runtime = proto3;
ParticipantInfo.typeName = "livekit.ParticipantInfo";
ParticipantInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: proto3.getEnumType(ParticipantInfo_State)
}, {
  no: 4,
  name: "tracks",
  kind: "message",
  T: TrackInfo,
  repeated: !0
}, {
  no: 5,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "joined_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 9,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "version",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "permission",
  kind: "message",
  T: ParticipantPermission
}, {
  no: 12,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "is_publisher",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(ParticipantInfo_Kind)
}]);
var ParticipantInfo_State;
(function(a) {
  a[a.JOINING = 0] = "JOINING", a[a.JOINED = 1] = "JOINED", a[a.ACTIVE = 2] = "ACTIVE", a[a.DISCONNECTED = 3] = "DISCONNECTED";
})(ParticipantInfo_State || (ParticipantInfo_State = {}));
proto3.util.setEnumType(ParticipantInfo_State, "livekit.ParticipantInfo.State", [{
  no: 0,
  name: "JOINING"
}, {
  no: 1,
  name: "JOINED"
}, {
  no: 2,
  name: "ACTIVE"
}, {
  no: 3,
  name: "DISCONNECTED"
}]);
var ParticipantInfo_Kind;
(function(a) {
  a[a.STANDARD = 0] = "STANDARD", a[a.INGRESS = 1] = "INGRESS", a[a.EGRESS = 2] = "EGRESS", a[a.SIP = 3] = "SIP", a[a.AGENT = 4] = "AGENT";
})(ParticipantInfo_Kind || (ParticipantInfo_Kind = {}));
proto3.util.setEnumType(ParticipantInfo_Kind, "livekit.ParticipantInfo.Kind", [{
  no: 0,
  name: "STANDARD"
}, {
  no: 1,
  name: "INGRESS"
}, {
  no: 2,
  name: "EGRESS"
}, {
  no: 3,
  name: "SIP"
}, {
  no: 4,
  name: "AGENT"
}]);
class Encryption extends Message {
  constructor(u) {
    super(), proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new Encryption().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Encryption().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Encryption().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Encryption, u, c);
  }
}
Encryption.runtime = proto3;
Encryption.typeName = "livekit.Encryption";
Encryption.fields = proto3.util.newFieldList(() => []);
var Encryption_Type;
(function(a) {
  a[a.NONE = 0] = "NONE", a[a.GCM = 1] = "GCM", a[a.CUSTOM = 2] = "CUSTOM";
})(Encryption_Type || (Encryption_Type = {}));
proto3.util.setEnumType(Encryption_Type, "livekit.Encryption.Type", [{
  no: 0,
  name: "NONE"
}, {
  no: 1,
  name: "GCM"
}, {
  no: 2,
  name: "CUSTOM"
}]);
class SimulcastCodecInfo extends Message {
  constructor(u) {
    super(), this.mimeType = "", this.mid = "", this.cid = "", this.layers = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SimulcastCodecInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SimulcastCodecInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SimulcastCodecInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SimulcastCodecInfo, u, c);
  }
}
SimulcastCodecInfo.runtime = proto3;
SimulcastCodecInfo.typeName = "livekit.SimulcastCodecInfo";
SimulcastCodecInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}]);
class TrackInfo extends Message {
  constructor(u) {
    super(), this.sid = "", this.type = TrackType.AUDIO, this.name = "", this.muted = !1, this.width = 0, this.height = 0, this.simulcast = !1, this.disableDtx = !1, this.source = TrackSource.UNKNOWN, this.layers = [], this.mimeType = "", this.mid = "", this.codecs = [], this.stereo = !1, this.disableRed = !1, this.encryption = Encryption_Type.NONE, this.stream = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new TrackInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new TrackInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new TrackInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(TrackInfo, u, c);
  }
}
TrackInfo.runtime = proto3;
TrackInfo.typeName = "livekit.TrackInfo";
TrackInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(TrackType)
}, {
  no: 3,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "simulcast",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 10,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}, {
  no: 11,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "codecs",
  kind: "message",
  T: SimulcastCodecInfo,
  repeated: !0
}, {
  no: 14,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 15,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 16,
  name: "encryption",
  kind: "enum",
  T: proto3.getEnumType(Encryption_Type)
}, {
  no: 17,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 18,
  name: "version",
  kind: "message",
  T: TimedVersion
}]);
class VideoLayer extends Message {
  constructor(u) {
    super(), this.quality = VideoQuality$1.LOW, this.width = 0, this.height = 0, this.bitrate = 0, this.ssrc = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new VideoLayer().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new VideoLayer().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new VideoLayer().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(VideoLayer, u, c);
  }
}
VideoLayer.runtime = proto3;
VideoLayer.typeName = "livekit.VideoLayer";
VideoLayer.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 2,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "ssrc",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
class DataPacket extends Message {
  constructor(u) {
    super(), this.kind = DataPacket_Kind.RELIABLE, this.value = {
      case: void 0
    }, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new DataPacket().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new DataPacket().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new DataPacket().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(DataPacket, u, c);
  }
}
DataPacket.runtime = proto3;
DataPacket.typeName = "livekit.DataPacket";
DataPacket.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(DataPacket_Kind)
}, {
  no: 2,
  name: "user",
  kind: "message",
  T: UserPacket,
  oneof: "value"
}, {
  no: 3,
  name: "speaker",
  kind: "message",
  T: ActiveSpeakerUpdate,
  oneof: "value"
}]);
var DataPacket_Kind;
(function(a) {
  a[a.RELIABLE = 0] = "RELIABLE", a[a.LOSSY = 1] = "LOSSY";
})(DataPacket_Kind || (DataPacket_Kind = {}));
proto3.util.setEnumType(DataPacket_Kind, "livekit.DataPacket.Kind", [{
  no: 0,
  name: "RELIABLE"
}, {
  no: 1,
  name: "LOSSY"
}]);
class ActiveSpeakerUpdate extends Message {
  constructor(u) {
    super(), this.speakers = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ActiveSpeakerUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ActiveSpeakerUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ActiveSpeakerUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ActiveSpeakerUpdate, u, c);
  }
}
ActiveSpeakerUpdate.runtime = proto3;
ActiveSpeakerUpdate.typeName = "livekit.ActiveSpeakerUpdate";
ActiveSpeakerUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: SpeakerInfo,
  repeated: !0
}]);
class SpeakerInfo extends Message {
  constructor(u) {
    super(), this.sid = "", this.level = 0, this.active = !1, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SpeakerInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SpeakerInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SpeakerInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SpeakerInfo, u, c);
  }
}
SpeakerInfo.runtime = proto3;
SpeakerInfo.typeName = "livekit.SpeakerInfo";
SpeakerInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "level",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}, {
  no: 3,
  name: "active",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
class UserPacket extends Message {
  constructor(u) {
    super(), this.participantSid = "", this.participantIdentity = "", this.payload = new Uint8Array(0), this.destinationSids = [], this.destinationIdentities = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new UserPacket().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new UserPacket().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new UserPacket().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(UserPacket, u, c);
  }
}
UserPacket.runtime = proto3;
UserPacket.typeName = "livekit.UserPacket";
UserPacket.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "payload",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 3,
  name: "destination_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 6,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "topic",
  kind: "scalar",
  T: 9,
  opt: !0
}]);
class ParticipantTracks extends Message {
  constructor(u) {
    super(), this.participantSid = "", this.trackSids = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ParticipantTracks().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ParticipantTracks().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ParticipantTracks().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ParticipantTracks, u, c);
  }
}
ParticipantTracks.runtime = proto3;
ParticipantTracks.typeName = "livekit.ParticipantTracks";
ParticipantTracks.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}]);
class ServerInfo extends Message {
  constructor(u) {
    super(), this.edition = ServerInfo_Edition.Standard, this.version = "", this.protocol = 0, this.region = "", this.nodeId = "", this.debugInfo = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ServerInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ServerInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ServerInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ServerInfo, u, c);
  }
}
ServerInfo.runtime = proto3;
ServerInfo.typeName = "livekit.ServerInfo";
ServerInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "edition",
  kind: "enum",
  T: proto3.getEnumType(ServerInfo_Edition)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "node_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "debug_info",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var ServerInfo_Edition;
(function(a) {
  a[a.Standard = 0] = "Standard", a[a.Cloud = 1] = "Cloud";
})(ServerInfo_Edition || (ServerInfo_Edition = {}));
proto3.util.setEnumType(ServerInfo_Edition, "livekit.ServerInfo.Edition", [{
  no: 0,
  name: "Standard"
}, {
  no: 1,
  name: "Cloud"
}]);
class ClientInfo extends Message {
  constructor(u) {
    super(), this.sdk = ClientInfo_SDK.UNKNOWN, this.version = "", this.protocol = 0, this.os = "", this.osVersion = "", this.deviceModel = "", this.browser = "", this.browserVersion = "", this.address = "", this.network = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ClientInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ClientInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ClientInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ClientInfo, u, c);
  }
}
ClientInfo.runtime = proto3;
ClientInfo.typeName = "livekit.ClientInfo";
ClientInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "sdk",
  kind: "enum",
  T: proto3.getEnumType(ClientInfo_SDK)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "os",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "os_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "device_model",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "browser",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "browser_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "address",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "network",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var ClientInfo_SDK;
(function(a) {
  a[a.UNKNOWN = 0] = "UNKNOWN", a[a.JS = 1] = "JS", a[a.SWIFT = 2] = "SWIFT", a[a.ANDROID = 3] = "ANDROID", a[a.FLUTTER = 4] = "FLUTTER", a[a.GO = 5] = "GO", a[a.UNITY = 6] = "UNITY", a[a.REACT_NATIVE = 7] = "REACT_NATIVE", a[a.RUST = 8] = "RUST", a[a.PYTHON = 9] = "PYTHON", a[a.CPP = 10] = "CPP";
})(ClientInfo_SDK || (ClientInfo_SDK = {}));
proto3.util.setEnumType(ClientInfo_SDK, "livekit.ClientInfo.SDK", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "JS"
}, {
  no: 2,
  name: "SWIFT"
}, {
  no: 3,
  name: "ANDROID"
}, {
  no: 4,
  name: "FLUTTER"
}, {
  no: 5,
  name: "GO"
}, {
  no: 6,
  name: "UNITY"
}, {
  no: 7,
  name: "REACT_NATIVE"
}, {
  no: 8,
  name: "RUST"
}, {
  no: 9,
  name: "PYTHON"
}, {
  no: 10,
  name: "CPP"
}]);
class ClientConfiguration extends Message {
  constructor(u) {
    super(), this.resumeConnection = ClientConfigSetting.UNSET, this.forceRelay = ClientConfigSetting.UNSET, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ClientConfiguration().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ClientConfiguration().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ClientConfiguration().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ClientConfiguration, u, c);
  }
}
ClientConfiguration.runtime = proto3;
ClientConfiguration.typeName = "livekit.ClientConfiguration";
ClientConfiguration.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "video",
  kind: "message",
  T: VideoConfiguration
}, {
  no: 2,
  name: "screen",
  kind: "message",
  T: VideoConfiguration
}, {
  no: 3,
  name: "resume_connection",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}, {
  no: 4,
  name: "disabled_codecs",
  kind: "message",
  T: DisabledCodecs
}, {
  no: 5,
  name: "force_relay",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}]);
class VideoConfiguration extends Message {
  constructor(u) {
    super(), this.hardwareEncoder = ClientConfigSetting.UNSET, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new VideoConfiguration().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new VideoConfiguration().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new VideoConfiguration().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(VideoConfiguration, u, c);
  }
}
VideoConfiguration.runtime = proto3;
VideoConfiguration.typeName = "livekit.VideoConfiguration";
VideoConfiguration.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "hardware_encoder",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}]);
class DisabledCodecs extends Message {
  constructor(u) {
    super(), this.codecs = [], this.publish = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new DisabledCodecs().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new DisabledCodecs().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new DisabledCodecs().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(DisabledCodecs, u, c);
  }
}
DisabledCodecs.runtime = proto3;
DisabledCodecs.typeName = "livekit.DisabledCodecs";
DisabledCodecs.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "codecs",
  kind: "message",
  T: Codec,
  repeated: !0
}, {
  no: 2,
  name: "publish",
  kind: "message",
  T: Codec,
  repeated: !0
}]);
class RTPDrift extends Message {
  constructor(u) {
    super(), this.duration = 0, this.startTimestamp = protoInt64.zero, this.endTimestamp = protoInt64.zero, this.rtpClockTicks = protoInt64.zero, this.driftSamples = protoInt64.zero, this.driftMs = 0, this.clockRate = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new RTPDrift().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new RTPDrift().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new RTPDrift().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(RTPDrift, u, c);
  }
}
RTPDrift.runtime = proto3;
RTPDrift.typeName = "livekit.RTPDrift";
RTPDrift.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "start_time",
  kind: "message",
  T: Timestamp
}, {
  no: 2,
  name: "end_time",
  kind: "message",
  T: Timestamp
}, {
  no: 3,
  name: "duration",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 4,
  name: "start_timestamp",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 5,
  name: "end_timestamp",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 6,
  name: "rtp_clock_ticks",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 7,
  name: "drift_samples",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 8,
  name: "drift_ms",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 9,
  name: "clock_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}]);
class RTPStats extends Message {
  constructor(u) {
    super(), this.duration = 0, this.packets = 0, this.packetRate = 0, this.bytes = protoInt64.zero, this.headerBytes = protoInt64.zero, this.bitrate = 0, this.packetsLost = 0, this.packetLossRate = 0, this.packetLossPercentage = 0, this.packetsDuplicate = 0, this.packetDuplicateRate = 0, this.bytesDuplicate = protoInt64.zero, this.headerBytesDuplicate = protoInt64.zero, this.bitrateDuplicate = 0, this.packetsPadding = 0, this.packetPaddingRate = 0, this.bytesPadding = protoInt64.zero, this.headerBytesPadding = protoInt64.zero, this.bitratePadding = 0, this.packetsOutOfOrder = 0, this.frames = 0, this.frameRate = 0, this.jitterCurrent = 0, this.jitterMax = 0, this.gapHistogram = {}, this.nacks = 0, this.nackAcks = 0, this.nackMisses = 0, this.nackRepeated = 0, this.plis = 0, this.firs = 0, this.rttCurrent = 0, this.rttMax = 0, this.keyFrames = 0, this.layerLockPlis = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new RTPStats().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new RTPStats().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new RTPStats().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(RTPStats, u, c);
  }
}
RTPStats.runtime = proto3;
RTPStats.typeName = "livekit.RTPStats";
RTPStats.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "start_time",
  kind: "message",
  T: Timestamp
}, {
  no: 2,
  name: "end_time",
  kind: "message",
  T: Timestamp
}, {
  no: 3,
  name: "duration",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 4,
  name: "packets",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "packet_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 6,
  name: "bytes",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 39,
  name: "header_bytes",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 7,
  name: "bitrate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 8,
  name: "packets_lost",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 9,
  name: "packet_loss_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 10,
  name: "packet_loss_percentage",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}, {
  no: 11,
  name: "packets_duplicate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 12,
  name: "packet_duplicate_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 13,
  name: "bytes_duplicate",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 40,
  name: "header_bytes_duplicate",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 14,
  name: "bitrate_duplicate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 15,
  name: "packets_padding",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 16,
  name: "packet_padding_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 17,
  name: "bytes_padding",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 41,
  name: "header_bytes_padding",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 18,
  name: "bitrate_padding",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 19,
  name: "packets_out_of_order",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 20,
  name: "frames",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 21,
  name: "frame_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 22,
  name: "jitter_current",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 23,
  name: "jitter_max",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 24,
  name: "gap_histogram",
  kind: "map",
  K: 5,
  V: {
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }
}, {
  no: 25,
  name: "nacks",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 37,
  name: "nack_acks",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 26,
  name: "nack_misses",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 38,
  name: "nack_repeated",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 27,
  name: "plis",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 28,
  name: "last_pli",
  kind: "message",
  T: Timestamp
}, {
  no: 29,
  name: "firs",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 30,
  name: "last_fir",
  kind: "message",
  T: Timestamp
}, {
  no: 31,
  name: "rtt_current",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 32,
  name: "rtt_max",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 33,
  name: "key_frames",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 34,
  name: "last_key_frame",
  kind: "message",
  T: Timestamp
}, {
  no: 35,
  name: "layer_lock_plis",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 36,
  name: "last_layer_lock_pli",
  kind: "message",
  T: Timestamp
}, {
  no: 44,
  name: "packet_drift",
  kind: "message",
  T: RTPDrift
}, {
  no: 45,
  name: "report_drift",
  kind: "message",
  T: RTPDrift
}]);
class TimedVersion extends Message {
  constructor(u) {
    super(), this.unixMicro = protoInt64.zero, this.ticks = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new TimedVersion().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new TimedVersion().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new TimedVersion().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(TimedVersion, u, c);
  }
}
TimedVersion.runtime = proto3;
TimedVersion.typeName = "livekit.TimedVersion";
TimedVersion.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "unix_micro",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "ticks",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
const maxRetryDelay = 7e3, DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];
class DefaultReconnectPolicy {
  constructor(u) {
    this._retryDelays = u !== void 0 ? [...u] : DEFAULT_RETRY_DELAYS_IN_MS;
  }
  nextRetryDelayInMs(u) {
    if (u.retryCount >= this._retryDelays.length)
      return null;
    const c = this._retryDelays[u.retryCount];
    return u.retryCount <= 1 ? c : c + Math.random() * 1e3;
  }
}
function __awaiter$3(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function I(F) {
      try {
        $(l.next(F));
      } catch (H) {
        _(H);
      }
    }
    function P(F) {
      try {
        $(l.throw(F));
      } catch (H) {
        _(H);
      }
    }
    function $(F) {
      F.done ? p(F.value) : v(F.value).then(I, P);
    }
    $((l = l.apply(a, u || [])).next());
  });
}
function __values(a) {
  var u = typeof Symbol == "function" && Symbol.iterator, c = u && a[u], l = 0;
  if (c)
    return c.call(a);
  if (a && typeof a.length == "number")
    return {
      next: function() {
        return a && l >= a.length && (a = void 0), { value: a && a[l++], done: !a };
      }
    };
  throw new TypeError(u ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __asyncValues(a) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var u = a[Symbol.asyncIterator], c;
  return u ? u.call(a) : (a = typeof __values == "function" ? __values(a) : a[Symbol.iterator](), c = {}, l("next"), l("throw"), l("return"), c[Symbol.asyncIterator] = function() {
    return this;
  }, c);
  function l(p) {
    c[p] = a[p] && function(_) {
      return new Promise(function(I, P) {
        _ = a[p](_), v(I, P, _.done, _.value);
      });
    };
  }
  function v(p, _, I, P) {
    Promise.resolve(P).then(function($) {
      p({ value: $, done: I });
    }, _);
  }
}
typeof SuppressedError == "function" && SuppressedError;
var events$2 = { exports: {} }, R$1 = typeof Reflect == "object" ? Reflect : null, ReflectApply$1 = R$1 && typeof R$1.apply == "function" ? R$1.apply : function a(u, c, l) {
  return Function.prototype.apply.call(u, c, l);
}, ReflectOwnKeys$1;
R$1 && typeof R$1.ownKeys == "function" ? ReflectOwnKeys$1 = R$1.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys$1 = function(u) {
  return Object.getOwnPropertyNames(u).concat(Object.getOwnPropertySymbols(u));
} : ReflectOwnKeys$1 = function(u) {
  return Object.getOwnPropertyNames(u);
};
function ProcessEmitWarning$1(a) {
  console && console.warn && console.warn(a);
}
var NumberIsNaN$1 = Number.isNaN || function a(u) {
  return u !== u;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events$2.exports = EventEmitter$1;
events$2.exports.once = once$7;
EventEmitter$1.EventEmitter = EventEmitter$1;
EventEmitter$1.prototype._events = void 0;
EventEmitter$1.prototype._eventsCount = 0;
EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners$1 = 10;
function checkListener$1(a) {
  if (typeof a != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof a);
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners$1;
  },
  set: function(a) {
    if (typeof a != "number" || a < 0 || NumberIsNaN$1(a))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + a + ".");
    defaultMaxListeners$1 = a;
  }
});
EventEmitter$1.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$1.prototype.setMaxListeners = function a(u) {
  if (typeof u != "number" || u < 0 || NumberIsNaN$1(u))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + u + ".");
  return this._maxListeners = u, this;
};
function _getMaxListeners$1(a) {
  return a._maxListeners === void 0 ? EventEmitter$1.defaultMaxListeners : a._maxListeners;
}
EventEmitter$1.prototype.getMaxListeners = function a() {
  return _getMaxListeners$1(this);
};
EventEmitter$1.prototype.emit = function a(u) {
  for (var c = [], l = 1; l < arguments.length; l++)
    c.push(arguments[l]);
  var v = u === "error", p = this._events;
  if (p !== void 0)
    v = v && p.error === void 0;
  else if (!v)
    return !1;
  if (v) {
    var _;
    if (c.length > 0 && (_ = c[0]), _ instanceof Error)
      throw _;
    var I = new Error("Unhandled error." + (_ ? " (" + _.message + ")" : ""));
    throw I.context = _, I;
  }
  var P = p[u];
  if (P === void 0)
    return !1;
  if (typeof P == "function")
    ReflectApply$1(P, this, c);
  else
    for (var $ = P.length, F = arrayClone$1(P, $), l = 0; l < $; ++l)
      ReflectApply$1(F[l], this, c);
  return !0;
};
function _addListener$1(a, u, c, l) {
  var v, p, _;
  if (checkListener$1(c), p = a._events, p === void 0 ? (p = a._events = /* @__PURE__ */ Object.create(null), a._eventsCount = 0) : (p.newListener !== void 0 && (a.emit("newListener", u, c.listener ? c.listener : c), p = a._events), _ = p[u]), _ === void 0)
    _ = p[u] = c, ++a._eventsCount;
  else if (typeof _ == "function" ? _ = p[u] = l ? [c, _] : [_, c] : l ? _.unshift(c) : _.push(c), v = _getMaxListeners$1(a), v > 0 && _.length > v && !_.warned) {
    _.warned = !0;
    var I = new Error("Possible EventEmitter memory leak detected. " + _.length + " " + String(u) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    I.name = "MaxListenersExceededWarning", I.emitter = a, I.type = u, I.count = _.length, ProcessEmitWarning$1(I);
  }
  return a;
}
EventEmitter$1.prototype.addListener = function a(u, c) {
  return _addListener$1(this, u, c, !1);
};
EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
EventEmitter$1.prototype.prependListener = function a(u, c) {
  return _addListener$1(this, u, c, !0);
};
function onceWrapper$1() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap$1(a, u, c) {
  var l = {
    fired: !1,
    wrapFn: void 0,
    target: a,
    type: u,
    listener: c
  }, v = onceWrapper$1.bind(l);
  return v.listener = c, l.wrapFn = v, v;
}
EventEmitter$1.prototype.once = function a(u, c) {
  return checkListener$1(c), this.on(u, _onceWrap$1(this, u, c)), this;
};
EventEmitter$1.prototype.prependOnceListener = function a(u, c) {
  return checkListener$1(c), this.prependListener(u, _onceWrap$1(this, u, c)), this;
};
EventEmitter$1.prototype.removeListener = function a(u, c) {
  var l, v, p, _, I;
  if (checkListener$1(c), v = this._events, v === void 0)
    return this;
  if (l = v[u], l === void 0)
    return this;
  if (l === c || l.listener === c)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete v[u], v.removeListener && this.emit("removeListener", u, l.listener || c));
  else if (typeof l != "function") {
    for (p = -1, _ = l.length - 1; _ >= 0; _--)
      if (l[_] === c || l[_].listener === c) {
        I = l[_].listener, p = _;
        break;
      }
    if (p < 0)
      return this;
    p === 0 ? l.shift() : spliceOne$1(l, p), l.length === 1 && (v[u] = l[0]), v.removeListener !== void 0 && this.emit("removeListener", u, I || c);
  }
  return this;
};
EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
EventEmitter$1.prototype.removeAllListeners = function a(u) {
  var c, l, v;
  if (l = this._events, l === void 0)
    return this;
  if (l.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : l[u] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete l[u]), this;
  if (arguments.length === 0) {
    var p = Object.keys(l), _;
    for (v = 0; v < p.length; ++v)
      _ = p[v], _ !== "removeListener" && this.removeAllListeners(_);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (c = l[u], typeof c == "function")
    this.removeListener(u, c);
  else if (c !== void 0)
    for (v = c.length - 1; v >= 0; v--)
      this.removeListener(u, c[v]);
  return this;
};
function _listeners$1(a, u, c) {
  var l = a._events;
  if (l === void 0)
    return [];
  var v = l[u];
  return v === void 0 ? [] : typeof v == "function" ? c ? [v.listener || v] : [v] : c ? unwrapListeners$1(v) : arrayClone$1(v, v.length);
}
EventEmitter$1.prototype.listeners = function a(u) {
  return _listeners$1(this, u, !0);
};
EventEmitter$1.prototype.rawListeners = function a(u) {
  return _listeners$1(this, u, !1);
};
EventEmitter$1.listenerCount = function(a, u) {
  return typeof a.listenerCount == "function" ? a.listenerCount(u) : listenerCount$1.call(a, u);
};
EventEmitter$1.prototype.listenerCount = listenerCount$1;
function listenerCount$1(a) {
  var u = this._events;
  if (u !== void 0) {
    var c = u[a];
    if (typeof c == "function")
      return 1;
    if (c !== void 0)
      return c.length;
  }
  return 0;
}
EventEmitter$1.prototype.eventNames = function a() {
  return this._eventsCount > 0 ? ReflectOwnKeys$1(this._events) : [];
};
function arrayClone$1(a, u) {
  for (var c = new Array(u), l = 0; l < u; ++l)
    c[l] = a[l];
  return c;
}
function spliceOne$1(a, u) {
  for (; u + 1 < a.length; u++)
    a[u] = a[u + 1];
  a.pop();
}
function unwrapListeners$1(a) {
  for (var u = new Array(a.length), c = 0; c < u.length; ++c)
    u[c] = a[c].listener || a[c];
  return u;
}
function once$7(a, u) {
  return new Promise(function(c, l) {
    function v(_) {
      a.removeListener(u, p), l(_);
    }
    function p() {
      typeof a.removeListener == "function" && a.removeListener("error", v), c([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener$1(a, u, p, {
      once: !0
    }), u !== "error" && addErrorHandlerIfEventEmitter$1(a, v, {
      once: !0
    });
  });
}
function addErrorHandlerIfEventEmitter$1(a, u, c) {
  typeof a.on == "function" && eventTargetAgnosticAddListener$1(a, "error", u, c);
}
function eventTargetAgnosticAddListener$1(a, u, c, l) {
  if (typeof a.on == "function")
    l.once ? a.once(u, c) : a.on(u, c);
  else if (typeof a.addEventListener == "function")
    a.addEventListener(u, function v(p) {
      l.once && a.removeEventListener(u, v), c(p);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof a);
}
var eventsExports$1 = events$2.exports;
let logDisabled_ = !0, deprecationWarnings_ = !0;
function extractVersion(a, u, c) {
  const l = a.match(u);
  return l && l.length >= c && parseInt(l[c], 10);
}
function wrapPeerConnectionEvent(a, u, c) {
  if (!a.RTCPeerConnection)
    return;
  const l = a.RTCPeerConnection.prototype, v = l.addEventListener;
  l.addEventListener = function(_, I) {
    if (_ !== u)
      return v.apply(this, arguments);
    const P = ($) => {
      const F = c($);
      F && (I.handleEvent ? I.handleEvent(F) : I(F));
    };
    return this._eventMap = this._eventMap || {}, this._eventMap[u] || (this._eventMap[u] = /* @__PURE__ */ new Map()), this._eventMap[u].set(I, P), v.apply(this, [_, P]);
  };
  const p = l.removeEventListener;
  l.removeEventListener = function(_, I) {
    if (_ !== u || !this._eventMap || !this._eventMap[u])
      return p.apply(this, arguments);
    if (!this._eventMap[u].has(I))
      return p.apply(this, arguments);
    const P = this._eventMap[u].get(I);
    return this._eventMap[u].delete(I), this._eventMap[u].size === 0 && delete this._eventMap[u], Object.keys(this._eventMap).length === 0 && delete this._eventMap, p.apply(this, [_, P]);
  }, Object.defineProperty(l, "on" + u, {
    get() {
      return this["_on" + u];
    },
    set(_) {
      this["_on" + u] && (this.removeEventListener(u, this["_on" + u]), delete this["_on" + u]), _ && this.addEventListener(u, this["_on" + u] = _);
    },
    enumerable: !0,
    configurable: !0
  });
}
function disableLog(a) {
  return typeof a != "boolean" ? new Error("Argument type: " + typeof a + ". Please use a boolean.") : (logDisabled_ = a, a ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function disableWarnings(a) {
  return typeof a != "boolean" ? new Error("Argument type: " + typeof a + ". Please use a boolean.") : (deprecationWarnings_ = !a, "adapter.js deprecation warnings " + (a ? "disabled" : "enabled"));
}
function log$1() {
  if (typeof window == "object") {
    if (logDisabled_)
      return;
    typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments);
  }
}
function deprecated(a, u) {
  deprecationWarnings_ && console.warn(a + " is deprecated, please use " + u + " instead.");
}
function detectBrowser(a) {
  const u = {
    browser: null,
    version: null
  };
  if (typeof a > "u" || !a.navigator || !a.navigator.userAgent)
    return u.browser = "Not a browser.", u;
  const {
    navigator: c
  } = a;
  if (c.mozGetUserMedia)
    u.browser = "firefox", u.version = extractVersion(c.userAgent, /Firefox\/(\d+)\./, 1);
  else if (c.webkitGetUserMedia || a.isSecureContext === !1 && a.webkitRTCPeerConnection)
    u.browser = "chrome", u.version = extractVersion(c.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  else if (a.RTCPeerConnection && c.userAgent.match(/AppleWebKit\/(\d+)\./))
    u.browser = "safari", u.version = extractVersion(c.userAgent, /AppleWebKit\/(\d+)\./, 1), u.supportsUnifiedPlan = a.RTCRtpTransceiver && "currentDirection" in a.RTCRtpTransceiver.prototype;
  else
    return u.browser = "Not a supported browser.", u;
  return u;
}
function isObject$7(a) {
  return Object.prototype.toString.call(a) === "[object Object]";
}
function compactObject(a) {
  return isObject$7(a) ? Object.keys(a).reduce(function(u, c) {
    const l = isObject$7(a[c]), v = l ? compactObject(a[c]) : a[c], p = l && !Object.keys(v).length;
    return v === void 0 || p ? u : Object.assign(u, {
      [c]: v
    });
  }, {}) : a;
}
function walkStats(a, u, c) {
  !u || c.has(u.id) || (c.set(u.id, u), Object.keys(u).forEach((l) => {
    l.endsWith("Id") ? walkStats(a, a.get(u[l]), c) : l.endsWith("Ids") && u[l].forEach((v) => {
      walkStats(a, a.get(v), c);
    });
  }));
}
function filterStats(a, u, c) {
  const l = c ? "outbound-rtp" : "inbound-rtp", v = /* @__PURE__ */ new Map();
  if (u === null)
    return v;
  const p = [];
  return a.forEach((_) => {
    _.type === "track" && _.trackIdentifier === u.id && p.push(_);
  }), p.forEach((_) => {
    a.forEach((I) => {
      I.type === l && I.trackId === _.id && walkStats(a, I, v);
    });
  }), v;
}
const logging = log$1;
function shimGetUserMedia$2(a, u) {
  const c = a && a.navigator;
  if (!c.mediaDevices)
    return;
  const l = function(I) {
    if (typeof I != "object" || I.mandatory || I.optional)
      return I;
    const P = {};
    return Object.keys(I).forEach(($) => {
      if ($ === "require" || $ === "advanced" || $ === "mediaSource")
        return;
      const F = typeof I[$] == "object" ? I[$] : {
        ideal: I[$]
      };
      F.exact !== void 0 && typeof F.exact == "number" && (F.min = F.max = F.exact);
      const H = function(j, ee) {
        return j ? j + ee.charAt(0).toUpperCase() + ee.slice(1) : ee === "deviceId" ? "sourceId" : ee;
      };
      if (F.ideal !== void 0) {
        P.optional = P.optional || [];
        let j = {};
        typeof F.ideal == "number" ? (j[H("min", $)] = F.ideal, P.optional.push(j), j = {}, j[H("max", $)] = F.ideal, P.optional.push(j)) : (j[H("", $)] = F.ideal, P.optional.push(j));
      }
      F.exact !== void 0 && typeof F.exact != "number" ? (P.mandatory = P.mandatory || {}, P.mandatory[H("", $)] = F.exact) : ["min", "max"].forEach((j) => {
        F[j] !== void 0 && (P.mandatory = P.mandatory || {}, P.mandatory[H(j, $)] = F[j]);
      });
    }), I.advanced && (P.optional = (P.optional || []).concat(I.advanced)), P;
  }, v = function(I, P) {
    if (u.version >= 61)
      return P(I);
    if (I = JSON.parse(JSON.stringify(I)), I && typeof I.audio == "object") {
      const $ = function(F, H, j) {
        H in F && !(j in F) && (F[j] = F[H], delete F[H]);
      };
      I = JSON.parse(JSON.stringify(I)), $(I.audio, "autoGainControl", "googAutoGainControl"), $(I.audio, "noiseSuppression", "googNoiseSuppression"), I.audio = l(I.audio);
    }
    if (I && typeof I.video == "object") {
      let $ = I.video.facingMode;
      $ = $ && (typeof $ == "object" ? $ : {
        ideal: $
      });
      const F = u.version < 66;
      if ($ && ($.exact === "user" || $.exact === "environment" || $.ideal === "user" || $.ideal === "environment") && !(c.mediaDevices.getSupportedConstraints && c.mediaDevices.getSupportedConstraints().facingMode && !F)) {
        delete I.video.facingMode;
        let H;
        if ($.exact === "environment" || $.ideal === "environment" ? H = ["back", "rear"] : ($.exact === "user" || $.ideal === "user") && (H = ["front"]), H)
          return c.mediaDevices.enumerateDevices().then((j) => {
            j = j.filter((X) => X.kind === "videoinput");
            let ee = j.find((X) => H.some((ie) => X.label.toLowerCase().includes(ie)));
            return !ee && j.length && H.includes("back") && (ee = j[j.length - 1]), ee && (I.video.deviceId = $.exact ? {
              exact: ee.deviceId
            } : {
              ideal: ee.deviceId
            }), I.video = l(I.video), logging("chrome: " + JSON.stringify(I)), P(I);
          });
      }
      I.video = l(I.video);
    }
    return logging("chrome: " + JSON.stringify(I)), P(I);
  }, p = function(I) {
    return u.version >= 64 ? I : {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[I.name] || I.name,
      message: I.message,
      constraint: I.constraint || I.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  }, _ = function(I, P, $) {
    v(I, (F) => {
      c.webkitGetUserMedia(F, P, (H) => {
        $ && $(p(H));
      });
    });
  };
  if (c.getUserMedia = _.bind(c), c.mediaDevices.getUserMedia) {
    const I = c.mediaDevices.getUserMedia.bind(c.mediaDevices);
    c.mediaDevices.getUserMedia = function(P) {
      return v(P, ($) => I($).then((F) => {
        if ($.audio && !F.getAudioTracks().length || $.video && !F.getVideoTracks().length)
          throw F.getTracks().forEach((H) => {
            H.stop();
          }), new DOMException("", "NotFoundError");
        return F;
      }, (F) => Promise.reject(p(F))));
    };
  }
}
function shimGetDisplayMedia$1(a, u) {
  if (!(a.navigator.mediaDevices && "getDisplayMedia" in a.navigator.mediaDevices) && a.navigator.mediaDevices) {
    if (typeof u != "function") {
      console.error("shimGetDisplayMedia: getSourceId argument is not a function");
      return;
    }
    a.navigator.mediaDevices.getDisplayMedia = function(l) {
      return u(l).then((v) => {
        const p = l.video && l.video.width, _ = l.video && l.video.height, I = l.video && l.video.frameRate;
        return l.video = {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: v,
            maxFrameRate: I || 3
          }
        }, p && (l.video.mandatory.maxWidth = p), _ && (l.video.mandatory.maxHeight = _), a.navigator.mediaDevices.getUserMedia(l);
      });
    };
  }
}
function shimMediaStream(a) {
  a.MediaStream = a.MediaStream || a.webkitMediaStream;
}
function shimOnTrack$1(a) {
  if (typeof a == "object" && a.RTCPeerConnection && !("ontrack" in a.RTCPeerConnection.prototype)) {
    Object.defineProperty(a.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(c) {
        this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = c);
      },
      enumerable: !0,
      configurable: !0
    });
    const u = a.RTCPeerConnection.prototype.setRemoteDescription;
    a.RTCPeerConnection.prototype.setRemoteDescription = function() {
      return this._ontrackpoly || (this._ontrackpoly = (l) => {
        l.stream.addEventListener("addtrack", (v) => {
          let p;
          a.RTCPeerConnection.prototype.getReceivers ? p = this.getReceivers().find((I) => I.track && I.track.id === v.track.id) : p = {
            track: v.track
          };
          const _ = new Event("track");
          _.track = v.track, _.receiver = p, _.transceiver = {
            receiver: p
          }, _.streams = [l.stream], this.dispatchEvent(_);
        }), l.stream.getTracks().forEach((v) => {
          let p;
          a.RTCPeerConnection.prototype.getReceivers ? p = this.getReceivers().find((I) => I.track && I.track.id === v.id) : p = {
            track: v
          };
          const _ = new Event("track");
          _.track = v, _.receiver = p, _.transceiver = {
            receiver: p
          }, _.streams = [l.stream], this.dispatchEvent(_);
        });
      }, this.addEventListener("addstream", this._ontrackpoly)), u.apply(this, arguments);
    };
  } else
    wrapPeerConnectionEvent(a, "track", (u) => (u.transceiver || Object.defineProperty(u, "transceiver", {
      value: {
        receiver: u.receiver
      }
    }), u));
}
function shimGetSendersWithDtmf(a) {
  if (typeof a == "object" && a.RTCPeerConnection && !("getSenders" in a.RTCPeerConnection.prototype) && "createDTMFSender" in a.RTCPeerConnection.prototype) {
    const u = function(v, p) {
      return {
        track: p,
        get dtmf() {
          return this._dtmf === void 0 && (p.kind === "audio" ? this._dtmf = v.createDTMFSender(p) : this._dtmf = null), this._dtmf;
        },
        _pc: v
      };
    };
    if (!a.RTCPeerConnection.prototype.getSenders) {
      a.RTCPeerConnection.prototype.getSenders = function() {
        return this._senders = this._senders || [], this._senders.slice();
      };
      const v = a.RTCPeerConnection.prototype.addTrack;
      a.RTCPeerConnection.prototype.addTrack = function(I, P) {
        let $ = v.apply(this, arguments);
        return $ || ($ = u(this, I), this._senders.push($)), $;
      };
      const p = a.RTCPeerConnection.prototype.removeTrack;
      a.RTCPeerConnection.prototype.removeTrack = function(I) {
        p.apply(this, arguments);
        const P = this._senders.indexOf(I);
        P !== -1 && this._senders.splice(P, 1);
      };
    }
    const c = a.RTCPeerConnection.prototype.addStream;
    a.RTCPeerConnection.prototype.addStream = function(p) {
      this._senders = this._senders || [], c.apply(this, [p]), p.getTracks().forEach((_) => {
        this._senders.push(u(this, _));
      });
    };
    const l = a.RTCPeerConnection.prototype.removeStream;
    a.RTCPeerConnection.prototype.removeStream = function(p) {
      this._senders = this._senders || [], l.apply(this, [p]), p.getTracks().forEach((_) => {
        const I = this._senders.find((P) => P.track === _);
        I && this._senders.splice(this._senders.indexOf(I), 1);
      });
    };
  } else if (typeof a == "object" && a.RTCPeerConnection && "getSenders" in a.RTCPeerConnection.prototype && "createDTMFSender" in a.RTCPeerConnection.prototype && a.RTCRtpSender && !("dtmf" in a.RTCRtpSender.prototype)) {
    const u = a.RTCPeerConnection.prototype.getSenders;
    a.RTCPeerConnection.prototype.getSenders = function() {
      const l = u.apply(this, []);
      return l.forEach((v) => v._pc = this), l;
    }, Object.defineProperty(a.RTCRtpSender.prototype, "dtmf", {
      get() {
        return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
      }
    });
  }
}
function shimGetStats(a) {
  if (!a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    const [l, v, p] = arguments;
    if (arguments.length > 0 && typeof l == "function")
      return u.apply(this, arguments);
    if (u.length === 0 && (arguments.length === 0 || typeof l != "function"))
      return u.apply(this, []);
    const _ = function(P) {
      const $ = {};
      return P.result().forEach((H) => {
        const j = {
          id: H.id,
          timestamp: H.timestamp,
          type: {
            localcandidate: "local-candidate",
            remotecandidate: "remote-candidate"
          }[H.type] || H.type
        };
        H.names().forEach((ee) => {
          j[ee] = H.stat(ee);
        }), $[j.id] = j;
      }), $;
    }, I = function(P) {
      return new Map(Object.keys(P).map(($) => [$, P[$]]));
    };
    if (arguments.length >= 2) {
      const P = function($) {
        v(I(_($)));
      };
      return u.apply(this, [P, l]);
    }
    return new Promise((P, $) => {
      u.apply(this, [function(F) {
        P(I(_(F)));
      }, $]);
    }).then(v, p);
  };
}
function shimSenderReceiverGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender && a.RTCRtpReceiver))
    return;
  if (!("getStats" in a.RTCRtpSender.prototype)) {
    const c = a.RTCPeerConnection.prototype.getSenders;
    c && (a.RTCPeerConnection.prototype.getSenders = function() {
      const p = c.apply(this, []);
      return p.forEach((_) => _._pc = this), p;
    });
    const l = a.RTCPeerConnection.prototype.addTrack;
    l && (a.RTCPeerConnection.prototype.addTrack = function() {
      const p = l.apply(this, arguments);
      return p._pc = this, p;
    }), a.RTCRtpSender.prototype.getStats = function() {
      const p = this;
      return this._pc.getStats().then((_) => (
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        filterStats(_, p.track, !0)
      ));
    };
  }
  if (!("getStats" in a.RTCRtpReceiver.prototype)) {
    const c = a.RTCPeerConnection.prototype.getReceivers;
    c && (a.RTCPeerConnection.prototype.getReceivers = function() {
      const v = c.apply(this, []);
      return v.forEach((p) => p._pc = this), v;
    }), wrapPeerConnectionEvent(a, "track", (l) => (l.receiver._pc = l.srcElement, l)), a.RTCRtpReceiver.prototype.getStats = function() {
      const v = this;
      return this._pc.getStats().then((p) => filterStats(p, v.track, !1));
    };
  }
  if (!("getStats" in a.RTCRtpSender.prototype && "getStats" in a.RTCRtpReceiver.prototype))
    return;
  const u = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    if (arguments.length > 0 && arguments[0] instanceof a.MediaStreamTrack) {
      const l = arguments[0];
      let v, p, _;
      return this.getSenders().forEach((I) => {
        I.track === l && (v ? _ = !0 : v = I);
      }), this.getReceivers().forEach((I) => (I.track === l && (p ? _ = !0 : p = I), I.track === l)), _ || v && p ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : v ? v.getStats() : p ? p.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
    }
    return u.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(a) {
  a.RTCPeerConnection.prototype.getLocalStreams = function() {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((_) => this._shimmedLocalStreams[_][0]);
  };
  const u = a.RTCPeerConnection.prototype.addTrack;
  a.RTCPeerConnection.prototype.addTrack = function(_, I) {
    if (!I)
      return u.apply(this, arguments);
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const P = u.apply(this, arguments);
    return this._shimmedLocalStreams[I.id] ? this._shimmedLocalStreams[I.id].indexOf(P) === -1 && this._shimmedLocalStreams[I.id].push(P) : this._shimmedLocalStreams[I.id] = [I, P], P;
  };
  const c = a.RTCPeerConnection.prototype.addStream;
  a.RTCPeerConnection.prototype.addStream = function(_) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {}, _.getTracks().forEach(($) => {
      if (this.getSenders().find((H) => H.track === $))
        throw new DOMException("Track already exists.", "InvalidAccessError");
    });
    const I = this.getSenders();
    c.apply(this, arguments);
    const P = this.getSenders().filter(($) => I.indexOf($) === -1);
    this._shimmedLocalStreams[_.id] = [_].concat(P);
  };
  const l = a.RTCPeerConnection.prototype.removeStream;
  a.RTCPeerConnection.prototype.removeStream = function(_) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[_.id], l.apply(this, arguments);
  };
  const v = a.RTCPeerConnection.prototype.removeTrack;
  a.RTCPeerConnection.prototype.removeTrack = function(_) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, _ && Object.keys(this._shimmedLocalStreams).forEach((I) => {
      const P = this._shimmedLocalStreams[I].indexOf(_);
      P !== -1 && this._shimmedLocalStreams[I].splice(P, 1), this._shimmedLocalStreams[I].length === 1 && delete this._shimmedLocalStreams[I];
    }), v.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrack(a, u) {
  if (!a.RTCPeerConnection)
    return;
  if (a.RTCPeerConnection.prototype.addTrack && u.version >= 65)
    return shimAddTrackRemoveTrackWithNative(a);
  const c = a.RTCPeerConnection.prototype.getLocalStreams;
  a.RTCPeerConnection.prototype.getLocalStreams = function() {
    const F = c.apply(this);
    return this._reverseStreams = this._reverseStreams || {}, F.map((H) => this._reverseStreams[H.id]);
  };
  const l = a.RTCPeerConnection.prototype.addStream;
  a.RTCPeerConnection.prototype.addStream = function(F) {
    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, F.getTracks().forEach((H) => {
      if (this.getSenders().find((ee) => ee.track === H))
        throw new DOMException("Track already exists.", "InvalidAccessError");
    }), !this._reverseStreams[F.id]) {
      const H = new a.MediaStream(F.getTracks());
      this._streams[F.id] = H, this._reverseStreams[H.id] = F, F = H;
    }
    l.apply(this, [F]);
  };
  const v = a.RTCPeerConnection.prototype.removeStream;
  a.RTCPeerConnection.prototype.removeStream = function(F) {
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, v.apply(this, [this._streams[F.id] || F]), delete this._reverseStreams[this._streams[F.id] ? this._streams[F.id].id : F.id], delete this._streams[F.id];
  }, a.RTCPeerConnection.prototype.addTrack = function(F, H) {
    if (this.signalingState === "closed")
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    const j = [].slice.call(arguments, 1);
    if (j.length !== 1 || !j[0].getTracks().find((ie) => ie === F))
      throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
    if (this.getSenders().find((ie) => ie.track === F))
      throw new DOMException("Track already exists.", "InvalidAccessError");
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
    const X = this._streams[H.id];
    if (X)
      X.addTrack(F), Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    else {
      const ie = new a.MediaStream([F]);
      this._streams[H.id] = ie, this._reverseStreams[ie.id] = H, this.addStream(ie);
    }
    return this.getSenders().find((ie) => ie.track === F);
  };
  function p($, F) {
    let H = F.sdp;
    return Object.keys($._reverseStreams || []).forEach((j) => {
      const ee = $._reverseStreams[j], X = $._streams[ee.id];
      H = H.replace(new RegExp(X.id, "g"), ee.id);
    }), new RTCSessionDescription({
      type: F.type,
      sdp: H
    });
  }
  function _($, F) {
    let H = F.sdp;
    return Object.keys($._reverseStreams || []).forEach((j) => {
      const ee = $._reverseStreams[j], X = $._streams[ee.id];
      H = H.replace(new RegExp(ee.id, "g"), X.id);
    }), new RTCSessionDescription({
      type: F.type,
      sdp: H
    });
  }
  ["createOffer", "createAnswer"].forEach(function($) {
    const F = a.RTCPeerConnection.prototype[$], H = {
      [$]() {
        const j = arguments;
        return arguments.length && typeof arguments[0] == "function" ? F.apply(this, [(X) => {
          const ie = p(this, X);
          j[0].apply(null, [ie]);
        }, (X) => {
          j[1] && j[1].apply(null, X);
        }, arguments[2]]) : F.apply(this, arguments).then((X) => p(this, X));
      }
    };
    a.RTCPeerConnection.prototype[$] = H[$];
  });
  const I = a.RTCPeerConnection.prototype.setLocalDescription;
  a.RTCPeerConnection.prototype.setLocalDescription = function() {
    return !arguments.length || !arguments[0].type ? I.apply(this, arguments) : (arguments[0] = _(this, arguments[0]), I.apply(this, arguments));
  };
  const P = Object.getOwnPropertyDescriptor(a.RTCPeerConnection.prototype, "localDescription");
  Object.defineProperty(a.RTCPeerConnection.prototype, "localDescription", {
    get() {
      const $ = P.get.apply(this);
      return $.type === "" ? $ : p(this, $);
    }
  }), a.RTCPeerConnection.prototype.removeTrack = function(F) {
    if (this.signalingState === "closed")
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    if (!F._pc)
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    if (!(F._pc === this))
      throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
    this._streams = this._streams || {};
    let j;
    Object.keys(this._streams).forEach((ee) => {
      this._streams[ee].getTracks().find((ie) => F.track === ie) && (j = this._streams[ee]);
    }), j && (j.getTracks().length === 1 ? this.removeStream(this._reverseStreams[j.id]) : j.removeTrack(F.track), this.dispatchEvent(new Event("negotiationneeded")));
  };
}
function shimPeerConnection$1(a, u) {
  !a.RTCPeerConnection && a.webkitRTCPeerConnection && (a.RTCPeerConnection = a.webkitRTCPeerConnection), a.RTCPeerConnection && u.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(c) {
    const l = a.RTCPeerConnection.prototype[c], v = {
      [c]() {
        return arguments[0] = new (c === "addIceCandidate" ? a.RTCIceCandidate : a.RTCSessionDescription)(arguments[0]), l.apply(this, arguments);
      }
    };
    a.RTCPeerConnection.prototype[c] = v[c];
  });
}
function fixNegotiationNeeded(a, u) {
  wrapPeerConnectionEvent(a, "negotiationneeded", (c) => {
    const l = c.target;
    if (!((u.version < 72 || l.getConfiguration && l.getConfiguration().sdpSemantics === "plan-b") && l.signalingState !== "stable"))
      return c;
  });
}
var chromeShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fixNegotiationNeeded,
  shimAddTrackRemoveTrack,
  shimAddTrackRemoveTrackWithNative,
  shimGetDisplayMedia: shimGetDisplayMedia$1,
  shimGetSendersWithDtmf,
  shimGetStats,
  shimGetUserMedia: shimGetUserMedia$2,
  shimMediaStream,
  shimOnTrack: shimOnTrack$1,
  shimPeerConnection: shimPeerConnection$1,
  shimSenderReceiverGetStats
});
function shimGetUserMedia$1(a, u) {
  const c = a && a.navigator, l = a && a.MediaStreamTrack;
  if (c.getUserMedia = function(v, p, _) {
    deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), c.mediaDevices.getUserMedia(v).then(p, _);
  }, !(u.version > 55 && "autoGainControl" in c.mediaDevices.getSupportedConstraints())) {
    const v = function(_, I, P) {
      I in _ && !(P in _) && (_[P] = _[I], delete _[I]);
    }, p = c.mediaDevices.getUserMedia.bind(c.mediaDevices);
    if (c.mediaDevices.getUserMedia = function(_) {
      return typeof _ == "object" && typeof _.audio == "object" && (_ = JSON.parse(JSON.stringify(_)), v(_.audio, "autoGainControl", "mozAutoGainControl"), v(_.audio, "noiseSuppression", "mozNoiseSuppression")), p(_);
    }, l && l.prototype.getSettings) {
      const _ = l.prototype.getSettings;
      l.prototype.getSettings = function() {
        const I = _.apply(this, arguments);
        return v(I, "mozAutoGainControl", "autoGainControl"), v(I, "mozNoiseSuppression", "noiseSuppression"), I;
      };
    }
    if (l && l.prototype.applyConstraints) {
      const _ = l.prototype.applyConstraints;
      l.prototype.applyConstraints = function(I) {
        return this.kind === "audio" && typeof I == "object" && (I = JSON.parse(JSON.stringify(I)), v(I, "autoGainControl", "mozAutoGainControl"), v(I, "noiseSuppression", "mozNoiseSuppression")), _.apply(this, [I]);
      };
    }
  }
}
function shimGetDisplayMedia(a, u) {
  a.navigator.mediaDevices && "getDisplayMedia" in a.navigator.mediaDevices || a.navigator.mediaDevices && (a.navigator.mediaDevices.getDisplayMedia = function(l) {
    if (!(l && l.video)) {
      const v = new DOMException("getDisplayMedia without video constraints is undefined");
      return v.name = "NotFoundError", v.code = 8, Promise.reject(v);
    }
    return l.video === !0 ? l.video = {
      mediaSource: u
    } : l.video.mediaSource = u, a.navigator.mediaDevices.getUserMedia(l);
  });
}
function shimOnTrack(a) {
  typeof a == "object" && a.RTCTrackEvent && "receiver" in a.RTCTrackEvent.prototype && !("transceiver" in a.RTCTrackEvent.prototype) && Object.defineProperty(a.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function shimPeerConnection(a, u) {
  if (typeof a != "object" || !(a.RTCPeerConnection || a.mozRTCPeerConnection))
    return;
  !a.RTCPeerConnection && a.mozRTCPeerConnection && (a.RTCPeerConnection = a.mozRTCPeerConnection), u.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(v) {
    const p = a.RTCPeerConnection.prototype[v], _ = {
      [v]() {
        return arguments[0] = new (v === "addIceCandidate" ? a.RTCIceCandidate : a.RTCSessionDescription)(arguments[0]), p.apply(this, arguments);
      }
    };
    a.RTCPeerConnection.prototype[v] = _[v];
  });
  const c = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  }, l = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    const [p, _, I] = arguments;
    return l.apply(this, [p || null]).then((P) => {
      if (u.version < 53 && !_)
        try {
          P.forEach(($) => {
            $.type = c[$.type] || $.type;
          });
        } catch ($) {
          if ($.name !== "TypeError")
            throw $;
          P.forEach((F, H) => {
            P.set(H, Object.assign({}, F, {
              type: c[F.type] || F.type
            }));
          });
        }
      return P;
    }).then(_, I);
  };
}
function shimSenderGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender) || a.RTCRtpSender && "getStats" in a.RTCRtpSender.prototype)
    return;
  const u = a.RTCPeerConnection.prototype.getSenders;
  u && (a.RTCPeerConnection.prototype.getSenders = function() {
    const v = u.apply(this, []);
    return v.forEach((p) => p._pc = this), v;
  });
  const c = a.RTCPeerConnection.prototype.addTrack;
  c && (a.RTCPeerConnection.prototype.addTrack = function() {
    const v = c.apply(this, arguments);
    return v._pc = this, v;
  }), a.RTCRtpSender.prototype.getStats = function() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function shimReceiverGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender) || a.RTCRtpSender && "getStats" in a.RTCRtpReceiver.prototype)
    return;
  const u = a.RTCPeerConnection.prototype.getReceivers;
  u && (a.RTCPeerConnection.prototype.getReceivers = function() {
    const l = u.apply(this, []);
    return l.forEach((v) => v._pc = this), l;
  }), wrapPeerConnectionEvent(a, "track", (c) => (c.receiver._pc = c.srcElement, c)), a.RTCRtpReceiver.prototype.getStats = function() {
    return this._pc.getStats(this.track);
  };
}
function shimRemoveStream(a) {
  !a.RTCPeerConnection || "removeStream" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.removeStream = function(c) {
    deprecated("removeStream", "removeTrack"), this.getSenders().forEach((l) => {
      l.track && c.getTracks().includes(l.track) && this.removeTrack(l);
    });
  });
}
function shimRTCDataChannel(a) {
  a.DataChannel && !a.RTCDataChannel && (a.RTCDataChannel = a.DataChannel);
}
function shimAddTransceiver(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.addTransceiver;
  u && (a.RTCPeerConnection.prototype.addTransceiver = function() {
    this.setParametersPromises = [];
    let l = arguments[1] && arguments[1].sendEncodings;
    l === void 0 && (l = []), l = [...l];
    const v = l.length > 0;
    v && l.forEach((_) => {
      if ("rid" in _ && !/^[a-z0-9]{0,16}$/i.test(_.rid))
        throw new TypeError("Invalid RID value provided.");
      if ("scaleResolutionDownBy" in _ && !(parseFloat(_.scaleResolutionDownBy) >= 1))
        throw new RangeError("scale_resolution_down_by must be >= 1.0");
      if ("maxFramerate" in _ && !(parseFloat(_.maxFramerate) >= 0))
        throw new RangeError("max_framerate must be >= 0.0");
    });
    const p = u.apply(this, arguments);
    if (v) {
      const {
        sender: _
      } = p, I = _.getParameters();
      (!("encodings" in I) || // Avoid being fooled by patched getParameters() below.
      I.encodings.length === 1 && Object.keys(I.encodings[0]).length === 0) && (I.encodings = l, _.sendEncodings = l, this.setParametersPromises.push(_.setParameters(I).then(() => {
        delete _.sendEncodings;
      }).catch(() => {
        delete _.sendEncodings;
      })));
    }
    return p;
  });
}
function shimGetParameters(a) {
  if (!(typeof a == "object" && a.RTCRtpSender))
    return;
  const u = a.RTCRtpSender.prototype.getParameters;
  u && (a.RTCRtpSender.prototype.getParameters = function() {
    const l = u.apply(this, arguments);
    return "encodings" in l || (l.encodings = [].concat(this.sendEncodings || [{}])), l;
  });
}
function shimCreateOffer(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.createOffer;
  a.RTCPeerConnection.prototype.createOffer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => u.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : u.apply(this, arguments);
  };
}
function shimCreateAnswer(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.createAnswer;
  a.RTCPeerConnection.prototype.createAnswer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => u.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : u.apply(this, arguments);
  };
}
var firefoxShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAddTransceiver,
  shimCreateAnswer,
  shimCreateOffer,
  shimGetDisplayMedia,
  shimGetParameters,
  shimGetUserMedia: shimGetUserMedia$1,
  shimOnTrack,
  shimPeerConnection,
  shimRTCDataChannel,
  shimReceiverGetStats,
  shimRemoveStream,
  shimSenderGetStats
});
function shimLocalStreamsAPI(a) {
  if (!(typeof a != "object" || !a.RTCPeerConnection)) {
    if ("getLocalStreams" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this._localStreams || (this._localStreams = []), this._localStreams;
    }), !("addStream" in a.RTCPeerConnection.prototype)) {
      const u = a.RTCPeerConnection.prototype.addTrack;
      a.RTCPeerConnection.prototype.addStream = function(l) {
        this._localStreams || (this._localStreams = []), this._localStreams.includes(l) || this._localStreams.push(l), l.getAudioTracks().forEach((v) => u.call(this, v, l)), l.getVideoTracks().forEach((v) => u.call(this, v, l));
      }, a.RTCPeerConnection.prototype.addTrack = function(l) {
        for (var v = arguments.length, p = new Array(v > 1 ? v - 1 : 0), _ = 1; _ < v; _++)
          p[_ - 1] = arguments[_];
        return p && p.forEach((I) => {
          this._localStreams ? this._localStreams.includes(I) || this._localStreams.push(I) : this._localStreams = [I];
        }), u.apply(this, arguments);
      };
    }
    "removeStream" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.removeStream = function(c) {
      this._localStreams || (this._localStreams = []);
      const l = this._localStreams.indexOf(c);
      if (l === -1)
        return;
      this._localStreams.splice(l, 1);
      const v = c.getTracks();
      this.getSenders().forEach((p) => {
        v.includes(p.track) && this.removeTrack(p);
      });
    });
  }
}
function shimRemoteStreamsAPI(a) {
  if (!(typeof a != "object" || !a.RTCPeerConnection) && ("getRemoteStreams" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this._remoteStreams ? this._remoteStreams : [];
  }), !("onaddstream" in a.RTCPeerConnection.prototype))) {
    Object.defineProperty(a.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(c) {
        this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = c), this.addEventListener("track", this._onaddstreampoly = (l) => {
          l.streams.forEach((v) => {
            if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(v))
              return;
            this._remoteStreams.push(v);
            const p = new Event("addstream");
            p.stream = v, this.dispatchEvent(p);
          });
        });
      }
    });
    const u = a.RTCPeerConnection.prototype.setRemoteDescription;
    a.RTCPeerConnection.prototype.setRemoteDescription = function() {
      const l = this;
      return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(v) {
        v.streams.forEach((p) => {
          if (l._remoteStreams || (l._remoteStreams = []), l._remoteStreams.indexOf(p) >= 0)
            return;
          l._remoteStreams.push(p);
          const _ = new Event("addstream");
          _.stream = p, l.dispatchEvent(_);
        });
      }), u.apply(l, arguments);
    };
  }
}
function shimCallbacksAPI(a) {
  if (typeof a != "object" || !a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection.prototype, c = u.createOffer, l = u.createAnswer, v = u.setLocalDescription, p = u.setRemoteDescription, _ = u.addIceCandidate;
  u.createOffer = function($, F) {
    const H = arguments.length >= 2 ? arguments[2] : arguments[0], j = c.apply(this, [H]);
    return F ? (j.then($, F), Promise.resolve()) : j;
  }, u.createAnswer = function($, F) {
    const H = arguments.length >= 2 ? arguments[2] : arguments[0], j = l.apply(this, [H]);
    return F ? (j.then($, F), Promise.resolve()) : j;
  };
  let I = function(P, $, F) {
    const H = v.apply(this, [P]);
    return F ? (H.then($, F), Promise.resolve()) : H;
  };
  u.setLocalDescription = I, I = function(P, $, F) {
    const H = p.apply(this, [P]);
    return F ? (H.then($, F), Promise.resolve()) : H;
  }, u.setRemoteDescription = I, I = function(P, $, F) {
    const H = _.apply(this, [P]);
    return F ? (H.then($, F), Promise.resolve()) : H;
  }, u.addIceCandidate = I;
}
function shimGetUserMedia(a) {
  const u = a && a.navigator;
  if (u.mediaDevices && u.mediaDevices.getUserMedia) {
    const c = u.mediaDevices, l = c.getUserMedia.bind(c);
    u.mediaDevices.getUserMedia = (v) => l(shimConstraints(v));
  }
  !u.getUserMedia && u.mediaDevices && u.mediaDevices.getUserMedia && (u.getUserMedia = (function(l, v, p) {
    u.mediaDevices.getUserMedia(l).then(v, p);
  }).bind(u));
}
function shimConstraints(a) {
  return a && a.video !== void 0 ? Object.assign({}, a, {
    video: compactObject(a.video)
  }) : a;
}
function shimRTCIceServerUrls(a) {
  if (!a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection;
  a.RTCPeerConnection = function(l, v) {
    if (l && l.iceServers) {
      const p = [];
      for (let _ = 0; _ < l.iceServers.length; _++) {
        let I = l.iceServers[_];
        I.urls === void 0 && I.url ? (deprecated("RTCIceServer.url", "RTCIceServer.urls"), I = JSON.parse(JSON.stringify(I)), I.urls = I.url, delete I.url, p.push(I)) : p.push(l.iceServers[_]);
      }
      l.iceServers = p;
    }
    return new u(l, v);
  }, a.RTCPeerConnection.prototype = u.prototype, "generateCertificate" in u && Object.defineProperty(a.RTCPeerConnection, "generateCertificate", {
    get() {
      return u.generateCertificate;
    }
  });
}
function shimTrackEventTransceiver(a) {
  typeof a == "object" && a.RTCTrackEvent && "receiver" in a.RTCTrackEvent.prototype && !("transceiver" in a.RTCTrackEvent.prototype) && Object.defineProperty(a.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function shimCreateOfferLegacy(a) {
  const u = a.RTCPeerConnection.prototype.createOffer;
  a.RTCPeerConnection.prototype.createOffer = function(l) {
    if (l) {
      typeof l.offerToReceiveAudio < "u" && (l.offerToReceiveAudio = !!l.offerToReceiveAudio);
      const v = this.getTransceivers().find((_) => _.receiver.track.kind === "audio");
      l.offerToReceiveAudio === !1 && v ? v.direction === "sendrecv" ? v.setDirection ? v.setDirection("sendonly") : v.direction = "sendonly" : v.direction === "recvonly" && (v.setDirection ? v.setDirection("inactive") : v.direction = "inactive") : l.offerToReceiveAudio === !0 && !v && this.addTransceiver("audio", {
        direction: "recvonly"
      }), typeof l.offerToReceiveVideo < "u" && (l.offerToReceiveVideo = !!l.offerToReceiveVideo);
      const p = this.getTransceivers().find((_) => _.receiver.track.kind === "video");
      l.offerToReceiveVideo === !1 && p ? p.direction === "sendrecv" ? p.setDirection ? p.setDirection("sendonly") : p.direction = "sendonly" : p.direction === "recvonly" && (p.setDirection ? p.setDirection("inactive") : p.direction = "inactive") : l.offerToReceiveVideo === !0 && !p && this.addTransceiver("video", {
        direction: "recvonly"
      });
    }
    return u.apply(this, arguments);
  };
}
function shimAudioContext(a) {
  typeof a != "object" || a.AudioContext || (a.AudioContext = a.webkitAudioContext);
}
var safariShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAudioContext,
  shimCallbacksAPI,
  shimConstraints,
  shimCreateOfferLegacy,
  shimGetUserMedia,
  shimLocalStreamsAPI,
  shimRTCIceServerUrls,
  shimRemoteStreamsAPI,
  shimTrackEventTransceiver
}), sdp$1 = { exports: {} };
(function(a) {
  const u = {};
  u.generateIdentifier = function() {
    return Math.random().toString(36).substring(2, 12);
  }, u.localCName = u.generateIdentifier(), u.splitLines = function(c) {
    return c.trim().split(`
`).map((l) => l.trim());
  }, u.splitSections = function(c) {
    return c.split(`
m=`).map((v, p) => (p > 0 ? "m=" + v : v).trim() + `\r
`);
  }, u.getDescription = function(c) {
    const l = u.splitSections(c);
    return l && l[0];
  }, u.getMediaSections = function(c) {
    const l = u.splitSections(c);
    return l.shift(), l;
  }, u.matchPrefix = function(c, l) {
    return u.splitLines(c).filter((v) => v.indexOf(l) === 0);
  }, u.parseCandidate = function(c) {
    let l;
    c.indexOf("a=candidate:") === 0 ? l = c.substring(12).split(" ") : l = c.substring(10).split(" ");
    const v = {
      foundation: l[0],
      component: {
        1: "rtp",
        2: "rtcp"
      }[l[1]] || l[1],
      protocol: l[2].toLowerCase(),
      priority: parseInt(l[3], 10),
      ip: l[4],
      address: l[4],
      // address is an alias for ip.
      port: parseInt(l[5], 10),
      // skip parts[6] == 'typ'
      type: l[7]
    };
    for (let p = 8; p < l.length; p += 2)
      switch (l[p]) {
        case "raddr":
          v.relatedAddress = l[p + 1];
          break;
        case "rport":
          v.relatedPort = parseInt(l[p + 1], 10);
          break;
        case "tcptype":
          v.tcpType = l[p + 1];
          break;
        case "ufrag":
          v.ufrag = l[p + 1], v.usernameFragment = l[p + 1];
          break;
        default:
          v[l[p]] === void 0 && (v[l[p]] = l[p + 1]);
          break;
      }
    return v;
  }, u.writeCandidate = function(c) {
    const l = [];
    l.push(c.foundation);
    const v = c.component;
    v === "rtp" ? l.push(1) : v === "rtcp" ? l.push(2) : l.push(v), l.push(c.protocol.toUpperCase()), l.push(c.priority), l.push(c.address || c.ip), l.push(c.port);
    const p = c.type;
    return l.push("typ"), l.push(p), p !== "host" && c.relatedAddress && c.relatedPort && (l.push("raddr"), l.push(c.relatedAddress), l.push("rport"), l.push(c.relatedPort)), c.tcpType && c.protocol.toLowerCase() === "tcp" && (l.push("tcptype"), l.push(c.tcpType)), (c.usernameFragment || c.ufrag) && (l.push("ufrag"), l.push(c.usernameFragment || c.ufrag)), "candidate:" + l.join(" ");
  }, u.parseIceOptions = function(c) {
    return c.substring(14).split(" ");
  }, u.parseRtpMap = function(c) {
    let l = c.substring(9).split(" ");
    const v = {
      payloadType: parseInt(l.shift(), 10)
      // was: id
    };
    return l = l[0].split("/"), v.name = l[0], v.clockRate = parseInt(l[1], 10), v.channels = l.length === 3 ? parseInt(l[2], 10) : 1, v.numChannels = v.channels, v;
  }, u.writeRtpMap = function(c) {
    let l = c.payloadType;
    c.preferredPayloadType !== void 0 && (l = c.preferredPayloadType);
    const v = c.channels || c.numChannels || 1;
    return "a=rtpmap:" + l + " " + c.name + "/" + c.clockRate + (v !== 1 ? "/" + v : "") + `\r
`;
  }, u.parseExtmap = function(c) {
    const l = c.substring(9).split(" ");
    return {
      id: parseInt(l[0], 10),
      direction: l[0].indexOf("/") > 0 ? l[0].split("/")[1] : "sendrecv",
      uri: l[1],
      attributes: l.slice(2).join(" ")
    };
  }, u.writeExtmap = function(c) {
    return "a=extmap:" + (c.id || c.preferredId) + (c.direction && c.direction !== "sendrecv" ? "/" + c.direction : "") + " " + c.uri + (c.attributes ? " " + c.attributes : "") + `\r
`;
  }, u.parseFmtp = function(c) {
    const l = {};
    let v;
    const p = c.substring(c.indexOf(" ") + 1).split(";");
    for (let _ = 0; _ < p.length; _++)
      v = p[_].trim().split("="), l[v[0].trim()] = v[1];
    return l;
  }, u.writeFmtp = function(c) {
    let l = "", v = c.payloadType;
    if (c.preferredPayloadType !== void 0 && (v = c.preferredPayloadType), c.parameters && Object.keys(c.parameters).length) {
      const p = [];
      Object.keys(c.parameters).forEach((_) => {
        c.parameters[_] !== void 0 ? p.push(_ + "=" + c.parameters[_]) : p.push(_);
      }), l += "a=fmtp:" + v + " " + p.join(";") + `\r
`;
    }
    return l;
  }, u.parseRtcpFb = function(c) {
    const l = c.substring(c.indexOf(" ") + 1).split(" ");
    return {
      type: l.shift(),
      parameter: l.join(" ")
    };
  }, u.writeRtcpFb = function(c) {
    let l = "", v = c.payloadType;
    return c.preferredPayloadType !== void 0 && (v = c.preferredPayloadType), c.rtcpFeedback && c.rtcpFeedback.length && c.rtcpFeedback.forEach((p) => {
      l += "a=rtcp-fb:" + v + " " + p.type + (p.parameter && p.parameter.length ? " " + p.parameter : "") + `\r
`;
    }), l;
  }, u.parseSsrcMedia = function(c) {
    const l = c.indexOf(" "), v = {
      ssrc: parseInt(c.substring(7, l), 10)
    }, p = c.indexOf(":", l);
    return p > -1 ? (v.attribute = c.substring(l + 1, p), v.value = c.substring(p + 1)) : v.attribute = c.substring(l + 1), v;
  }, u.parseSsrcGroup = function(c) {
    const l = c.substring(13).split(" ");
    return {
      semantics: l.shift(),
      ssrcs: l.map((v) => parseInt(v, 10))
    };
  }, u.getMid = function(c) {
    const l = u.matchPrefix(c, "a=mid:")[0];
    if (l)
      return l.substring(6);
  }, u.parseFingerprint = function(c) {
    const l = c.substring(14).split(" ");
    return {
      algorithm: l[0].toLowerCase(),
      // algorithm is case-sensitive in Edge.
      value: l[1].toUpperCase()
      // the definition is upper-case in RFC 4572.
    };
  }, u.getDtlsParameters = function(c, l) {
    return {
      role: "auto",
      fingerprints: u.matchPrefix(c + l, "a=fingerprint:").map(u.parseFingerprint)
    };
  }, u.writeDtlsParameters = function(c, l) {
    let v = "a=setup:" + l + `\r
`;
    return c.fingerprints.forEach((p) => {
      v += "a=fingerprint:" + p.algorithm + " " + p.value + `\r
`;
    }), v;
  }, u.parseCryptoLine = function(c) {
    const l = c.substring(9).split(" ");
    return {
      tag: parseInt(l[0], 10),
      cryptoSuite: l[1],
      keyParams: l[2],
      sessionParams: l.slice(3)
    };
  }, u.writeCryptoLine = function(c) {
    return "a=crypto:" + c.tag + " " + c.cryptoSuite + " " + (typeof c.keyParams == "object" ? u.writeCryptoKeyParams(c.keyParams) : c.keyParams) + (c.sessionParams ? " " + c.sessionParams.join(" ") : "") + `\r
`;
  }, u.parseCryptoKeyParams = function(c) {
    if (c.indexOf("inline:") !== 0)
      return null;
    const l = c.substring(7).split("|");
    return {
      keyMethod: "inline",
      keySalt: l[0],
      lifeTime: l[1],
      mkiValue: l[2] ? l[2].split(":")[0] : void 0,
      mkiLength: l[2] ? l[2].split(":")[1] : void 0
    };
  }, u.writeCryptoKeyParams = function(c) {
    return c.keyMethod + ":" + c.keySalt + (c.lifeTime ? "|" + c.lifeTime : "") + (c.mkiValue && c.mkiLength ? "|" + c.mkiValue + ":" + c.mkiLength : "");
  }, u.getCryptoParameters = function(c, l) {
    return u.matchPrefix(c + l, "a=crypto:").map(u.parseCryptoLine);
  }, u.getIceParameters = function(c, l) {
    const v = u.matchPrefix(c + l, "a=ice-ufrag:")[0], p = u.matchPrefix(c + l, "a=ice-pwd:")[0];
    return v && p ? {
      usernameFragment: v.substring(12),
      password: p.substring(10)
    } : null;
  }, u.writeIceParameters = function(c) {
    let l = "a=ice-ufrag:" + c.usernameFragment + `\r
a=ice-pwd:` + c.password + `\r
`;
    return c.iceLite && (l += `a=ice-lite\r
`), l;
  }, u.parseRtpParameters = function(c) {
    const l = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: [],
      rtcp: []
    }, p = u.splitLines(c)[0].split(" ");
    l.profile = p[2];
    for (let I = 3; I < p.length; I++) {
      const P = p[I], $ = u.matchPrefix(c, "a=rtpmap:" + P + " ")[0];
      if ($) {
        const F = u.parseRtpMap($), H = u.matchPrefix(c, "a=fmtp:" + P + " ");
        switch (F.parameters = H.length ? u.parseFmtp(H[0]) : {}, F.rtcpFeedback = u.matchPrefix(c, "a=rtcp-fb:" + P + " ").map(u.parseRtcpFb), l.codecs.push(F), F.name.toUpperCase()) {
          case "RED":
          case "ULPFEC":
            l.fecMechanisms.push(F.name.toUpperCase());
            break;
        }
      }
    }
    u.matchPrefix(c, "a=extmap:").forEach((I) => {
      l.headerExtensions.push(u.parseExtmap(I));
    });
    const _ = u.matchPrefix(c, "a=rtcp-fb:* ").map(u.parseRtcpFb);
    return l.codecs.forEach((I) => {
      _.forEach((P) => {
        I.rtcpFeedback.find((F) => F.type === P.type && F.parameter === P.parameter) || I.rtcpFeedback.push(P);
      });
    }), l;
  }, u.writeRtpDescription = function(c, l) {
    let v = "";
    v += "m=" + c + " ", v += l.codecs.length > 0 ? "9" : "0", v += " " + (l.profile || "UDP/TLS/RTP/SAVPF") + " ", v += l.codecs.map((_) => _.preferredPayloadType !== void 0 ? _.preferredPayloadType : _.payloadType).join(" ") + `\r
`, v += `c=IN IP4 0.0.0.0\r
`, v += `a=rtcp:9 IN IP4 0.0.0.0\r
`, l.codecs.forEach((_) => {
      v += u.writeRtpMap(_), v += u.writeFmtp(_), v += u.writeRtcpFb(_);
    });
    let p = 0;
    return l.codecs.forEach((_) => {
      _.maxptime > p && (p = _.maxptime);
    }), p > 0 && (v += "a=maxptime:" + p + `\r
`), l.headerExtensions && l.headerExtensions.forEach((_) => {
      v += u.writeExtmap(_);
    }), v;
  }, u.parseRtpEncodingParameters = function(c) {
    const l = [], v = u.parseRtpParameters(c), p = v.fecMechanisms.indexOf("RED") !== -1, _ = v.fecMechanisms.indexOf("ULPFEC") !== -1, I = u.matchPrefix(c, "a=ssrc:").map((j) => u.parseSsrcMedia(j)).filter((j) => j.attribute === "cname"), P = I.length > 0 && I[0].ssrc;
    let $;
    const F = u.matchPrefix(c, "a=ssrc-group:FID").map((j) => j.substring(17).split(" ").map((X) => parseInt(X, 10)));
    F.length > 0 && F[0].length > 1 && F[0][0] === P && ($ = F[0][1]), v.codecs.forEach((j) => {
      if (j.name.toUpperCase() === "RTX" && j.parameters.apt) {
        let ee = {
          ssrc: P,
          codecPayloadType: parseInt(j.parameters.apt, 10)
        };
        P && $ && (ee.rtx = {
          ssrc: $
        }), l.push(ee), p && (ee = JSON.parse(JSON.stringify(ee)), ee.fec = {
          ssrc: P,
          mechanism: _ ? "red+ulpfec" : "red"
        }, l.push(ee));
      }
    }), l.length === 0 && P && l.push({
      ssrc: P
    });
    let H = u.matchPrefix(c, "b=");
    return H.length && (H[0].indexOf("b=TIAS:") === 0 ? H = parseInt(H[0].substring(7), 10) : H[0].indexOf("b=AS:") === 0 ? H = parseInt(H[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8 : H = void 0, l.forEach((j) => {
      j.maxBitrate = H;
    })), l;
  }, u.parseRtcpParameters = function(c) {
    const l = {}, v = u.matchPrefix(c, "a=ssrc:").map((I) => u.parseSsrcMedia(I)).filter((I) => I.attribute === "cname")[0];
    v && (l.cname = v.value, l.ssrc = v.ssrc);
    const p = u.matchPrefix(c, "a=rtcp-rsize");
    l.reducedSize = p.length > 0, l.compound = p.length === 0;
    const _ = u.matchPrefix(c, "a=rtcp-mux");
    return l.mux = _.length > 0, l;
  }, u.writeRtcpParameters = function(c) {
    let l = "";
    return c.reducedSize && (l += `a=rtcp-rsize\r
`), c.mux && (l += `a=rtcp-mux\r
`), c.ssrc !== void 0 && c.cname && (l += "a=ssrc:" + c.ssrc + " cname:" + c.cname + `\r
`), l;
  }, u.parseMsid = function(c) {
    let l;
    const v = u.matchPrefix(c, "a=msid:");
    if (v.length === 1)
      return l = v[0].substring(7).split(" "), {
        stream: l[0],
        track: l[1]
      };
    const p = u.matchPrefix(c, "a=ssrc:").map((_) => u.parseSsrcMedia(_)).filter((_) => _.attribute === "msid");
    if (p.length > 0)
      return l = p[0].value.split(" "), {
        stream: l[0],
        track: l[1]
      };
  }, u.parseSctpDescription = function(c) {
    const l = u.parseMLine(c), v = u.matchPrefix(c, "a=max-message-size:");
    let p;
    v.length > 0 && (p = parseInt(v[0].substring(19), 10)), isNaN(p) && (p = 65536);
    const _ = u.matchPrefix(c, "a=sctp-port:");
    if (_.length > 0)
      return {
        port: parseInt(_[0].substring(12), 10),
        protocol: l.fmt,
        maxMessageSize: p
      };
    const I = u.matchPrefix(c, "a=sctpmap:");
    if (I.length > 0) {
      const P = I[0].substring(10).split(" ");
      return {
        port: parseInt(P[0], 10),
        protocol: P[1],
        maxMessageSize: p
      };
    }
  }, u.writeSctpDescription = function(c, l) {
    let v = [];
    return c.protocol !== "DTLS/SCTP" ? v = ["m=" + c.kind + " 9 " + c.protocol + " " + l.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + l.port + `\r
`] : v = ["m=" + c.kind + " 9 " + c.protocol + " " + l.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + l.port + " " + l.protocol + ` 65535\r
`], l.maxMessageSize !== void 0 && v.push("a=max-message-size:" + l.maxMessageSize + `\r
`), v.join("");
  }, u.generateSessionId = function() {
    return Math.random().toString().substr(2, 22);
  }, u.writeSessionBoilerplate = function(c, l, v) {
    let p;
    const _ = l !== void 0 ? l : 2;
    return c ? p = c : p = u.generateSessionId(), `v=0\r
o=` + (v || "thisisadapterortc") + " " + p + " " + _ + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`;
  }, u.getDirection = function(c, l) {
    const v = u.splitLines(c);
    for (let p = 0; p < v.length; p++)
      switch (v[p]) {
        case "a=sendrecv":
        case "a=sendonly":
        case "a=recvonly":
        case "a=inactive":
          return v[p].substring(2);
      }
    return l ? u.getDirection(l) : "sendrecv";
  }, u.getKind = function(c) {
    return u.splitLines(c)[0].split(" ")[0].substring(2);
  }, u.isRejected = function(c) {
    return c.split(" ", 2)[1] === "0";
  }, u.parseMLine = function(c) {
    const v = u.splitLines(c)[0].substring(2).split(" ");
    return {
      kind: v[0],
      port: parseInt(v[1], 10),
      protocol: v[2],
      fmt: v.slice(3).join(" ")
    };
  }, u.parseOLine = function(c) {
    const v = u.matchPrefix(c, "o=")[0].substring(2).split(" ");
    return {
      username: v[0],
      sessionId: v[1],
      sessionVersion: parseInt(v[2], 10),
      netType: v[3],
      addressType: v[4],
      address: v[5]
    };
  }, u.isValidSDP = function(c) {
    if (typeof c != "string" || c.length === 0)
      return !1;
    const l = u.splitLines(c);
    for (let v = 0; v < l.length; v++)
      if (l[v].length < 2 || l[v].charAt(1) !== "=")
        return !1;
    return !0;
  }, a.exports = u;
})(sdp$1);
var sdpExports = sdp$1.exports, SDPUtils = /* @__PURE__ */ getDefaultExportFromCjs(sdpExports), sdp = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: SDPUtils
}, [sdpExports]);
function shimRTCIceCandidate(a) {
  if (!a.RTCIceCandidate || a.RTCIceCandidate && "foundation" in a.RTCIceCandidate.prototype)
    return;
  const u = a.RTCIceCandidate;
  a.RTCIceCandidate = function(l) {
    if (typeof l == "object" && l.candidate && l.candidate.indexOf("a=") === 0 && (l = JSON.parse(JSON.stringify(l)), l.candidate = l.candidate.substring(2)), l.candidate && l.candidate.length) {
      const v = new u(l), p = SDPUtils.parseCandidate(l.candidate);
      for (const _ in p)
        _ in v || Object.defineProperty(v, _, {
          value: p[_]
        });
      return v.toJSON = function() {
        return {
          candidate: v.candidate,
          sdpMid: v.sdpMid,
          sdpMLineIndex: v.sdpMLineIndex,
          usernameFragment: v.usernameFragment
        };
      }, v;
    }
    return new u(l);
  }, a.RTCIceCandidate.prototype = u.prototype, wrapPeerConnectionEvent(a, "icecandidate", (c) => (c.candidate && Object.defineProperty(c, "candidate", {
    value: new a.RTCIceCandidate(c.candidate),
    writable: "false"
  }), c));
}
function shimRTCIceCandidateRelayProtocol(a) {
  !a.RTCIceCandidate || a.RTCIceCandidate && "relayProtocol" in a.RTCIceCandidate.prototype || wrapPeerConnectionEvent(a, "icecandidate", (u) => {
    if (u.candidate) {
      const c = SDPUtils.parseCandidate(u.candidate.candidate);
      c.type === "relay" && (u.candidate.relayProtocol = {
        0: "tls",
        1: "tcp",
        2: "udp"
      }[c.priority >> 24]);
    }
    return u;
  });
}
function shimMaxMessageSize(a, u) {
  if (!a.RTCPeerConnection)
    return;
  "sctp" in a.RTCPeerConnection.prototype || Object.defineProperty(a.RTCPeerConnection.prototype, "sctp", {
    get() {
      return typeof this._sctp > "u" ? null : this._sctp;
    }
  });
  const c = function(I) {
    if (!I || !I.sdp)
      return !1;
    const P = SDPUtils.splitSections(I.sdp);
    return P.shift(), P.some(($) => {
      const F = SDPUtils.parseMLine($);
      return F && F.kind === "application" && F.protocol.indexOf("SCTP") !== -1;
    });
  }, l = function(I) {
    const P = I.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (P === null || P.length < 2)
      return -1;
    const $ = parseInt(P[1], 10);
    return $ !== $ ? -1 : $;
  }, v = function(I) {
    let P = 65536;
    return u.browser === "firefox" && (u.version < 57 ? I === -1 ? P = 16384 : P = 2147483637 : u.version < 60 ? P = u.version === 57 ? 65535 : 65536 : P = 2147483637), P;
  }, p = function(I, P) {
    let $ = 65536;
    u.browser === "firefox" && u.version === 57 && ($ = 65535);
    const F = SDPUtils.matchPrefix(I.sdp, "a=max-message-size:");
    return F.length > 0 ? $ = parseInt(F[0].substring(19), 10) : u.browser === "firefox" && P !== -1 && ($ = 2147483637), $;
  }, _ = a.RTCPeerConnection.prototype.setRemoteDescription;
  a.RTCPeerConnection.prototype.setRemoteDescription = function() {
    if (this._sctp = null, u.browser === "chrome" && u.version >= 76) {
      const {
        sdpSemantics: P
      } = this.getConfiguration();
      P === "plan-b" && Object.defineProperty(this, "sctp", {
        get() {
          return typeof this._sctp > "u" ? null : this._sctp;
        },
        enumerable: !0,
        configurable: !0
      });
    }
    if (c(arguments[0])) {
      const P = l(arguments[0]), $ = v(P), F = p(arguments[0], P);
      let H;
      $ === 0 && F === 0 ? H = Number.POSITIVE_INFINITY : $ === 0 || F === 0 ? H = Math.max($, F) : H = Math.min($, F);
      const j = {};
      Object.defineProperty(j, "maxMessageSize", {
        get() {
          return H;
        }
      }), this._sctp = j;
    }
    return _.apply(this, arguments);
  };
}
function shimSendThrowTypeError(a) {
  if (!(a.RTCPeerConnection && "createDataChannel" in a.RTCPeerConnection.prototype))
    return;
  function u(l, v) {
    const p = l.send;
    l.send = function() {
      const I = arguments[0], P = I.length || I.size || I.byteLength;
      if (l.readyState === "open" && v.sctp && P > v.sctp.maxMessageSize)
        throw new TypeError("Message too large (can send a maximum of " + v.sctp.maxMessageSize + " bytes)");
      return p.apply(l, arguments);
    };
  }
  const c = a.RTCPeerConnection.prototype.createDataChannel;
  a.RTCPeerConnection.prototype.createDataChannel = function() {
    const v = c.apply(this, arguments);
    return u(v, this), v;
  }, wrapPeerConnectionEvent(a, "datachannel", (l) => (u(l.channel, l.target), l));
}
function shimConnectionState(a) {
  if (!a.RTCPeerConnection || "connectionState" in a.RTCPeerConnection.prototype)
    return;
  const u = a.RTCPeerConnection.prototype;
  Object.defineProperty(u, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(u, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(c) {
      this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), c && this.addEventListener("connectionstatechange", this._onconnectionstatechange = c);
    },
    enumerable: !0,
    configurable: !0
  }), ["setLocalDescription", "setRemoteDescription"].forEach((c) => {
    const l = u[c];
    u[c] = function() {
      return this._connectionstatechangepoly || (this._connectionstatechangepoly = (v) => {
        const p = v.target;
        if (p._lastConnectionState !== p.connectionState) {
          p._lastConnectionState = p.connectionState;
          const _ = new Event("connectionstatechange", v);
          p.dispatchEvent(_);
        }
        return v;
      }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), l.apply(this, arguments);
    };
  });
}
function removeExtmapAllowMixed(a, u) {
  if (!a.RTCPeerConnection || u.browser === "chrome" && u.version >= 71 || u.browser === "safari" && u.version >= 605)
    return;
  const c = a.RTCPeerConnection.prototype.setRemoteDescription;
  a.RTCPeerConnection.prototype.setRemoteDescription = function(v) {
    if (v && v.sdp && v.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
      const p = v.sdp.split(`
`).filter((_) => _.trim() !== "a=extmap-allow-mixed").join(`
`);
      a.RTCSessionDescription && v instanceof a.RTCSessionDescription ? arguments[0] = new a.RTCSessionDescription({
        type: v.type,
        sdp: p
      }) : v.sdp = p;
    }
    return c.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(a, u) {
  if (!(a.RTCPeerConnection && a.RTCPeerConnection.prototype))
    return;
  const c = a.RTCPeerConnection.prototype.addIceCandidate;
  !c || c.length === 0 || (a.RTCPeerConnection.prototype.addIceCandidate = function() {
    return arguments[0] ? (u.browser === "chrome" && u.version < 78 || u.browser === "firefox" && u.version < 68 || u.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : c.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
  });
}
function shimParameterlessSetLocalDescription(a, u) {
  if (!(a.RTCPeerConnection && a.RTCPeerConnection.prototype))
    return;
  const c = a.RTCPeerConnection.prototype.setLocalDescription;
  !c || c.length === 0 || (a.RTCPeerConnection.prototype.setLocalDescription = function() {
    let v = arguments[0] || {};
    if (typeof v != "object" || v.type && v.sdp)
      return c.apply(this, arguments);
    if (v = {
      type: v.type,
      sdp: v.sdp
    }, !v.type)
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          v.type = "offer";
          break;
        default:
          v.type = "answer";
          break;
      }
    return v.sdp || v.type !== "offer" && v.type !== "answer" ? c.apply(this, [v]) : (v.type === "offer" ? this.createOffer : this.createAnswer).apply(this).then((_) => c.apply(this, [_]));
  });
}
var commonShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  removeExtmapAllowMixed,
  shimAddIceCandidateNullOrEmpty,
  shimConnectionState,
  shimMaxMessageSize,
  shimParameterlessSetLocalDescription,
  shimRTCIceCandidate,
  shimRTCIceCandidateRelayProtocol,
  shimSendThrowTypeError
});
function adapterFactory() {
  let {
    window: a
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    shimChrome: !0,
    shimFirefox: !0,
    shimSafari: !0
  };
  const c = log$1, l = detectBrowser(a), v = {
    browserDetails: l,
    commonShim,
    extractVersion,
    disableLog,
    disableWarnings,
    // Expose sdp as a convenience. For production apps include directly.
    sdp
  };
  switch (l.browser) {
    case "chrome":
      if (!chromeShim || !shimPeerConnection$1 || !u.shimChrome)
        return c("Chrome shim is not included in this adapter release."), v;
      if (l.version === null)
        return c("Chrome shim can not determine version, not shimming."), v;
      c("adapter.js shimming chrome."), v.browserShim = chromeShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimGetUserMedia$2(a, l), shimMediaStream(a), shimPeerConnection$1(a, l), shimOnTrack$1(a), shimAddTrackRemoveTrack(a, l), shimGetSendersWithDtmf(a), shimGetStats(a), shimSenderReceiverGetStats(a), fixNegotiationNeeded(a, l), shimRTCIceCandidate(a), shimRTCIceCandidateRelayProtocol(a), shimConnectionState(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a), removeExtmapAllowMixed(a, l);
      break;
    case "firefox":
      if (!firefoxShim || !shimPeerConnection || !u.shimFirefox)
        return c("Firefox shim is not included in this adapter release."), v;
      c("adapter.js shimming firefox."), v.browserShim = firefoxShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimGetUserMedia$1(a, l), shimPeerConnection(a, l), shimOnTrack(a), shimRemoveStream(a), shimSenderGetStats(a), shimReceiverGetStats(a), shimRTCDataChannel(a), shimAddTransceiver(a), shimGetParameters(a), shimCreateOffer(a), shimCreateAnswer(a), shimRTCIceCandidate(a), shimConnectionState(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a);
      break;
    case "safari":
      if (!safariShim || !u.shimSafari)
        return c("Safari shim is not included in this adapter release."), v;
      c("adapter.js shimming safari."), v.browserShim = safariShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimRTCIceServerUrls(a), shimCreateOfferLegacy(a), shimCallbacksAPI(a), shimLocalStreamsAPI(a), shimRemoteStreamsAPI(a), shimTrackEventTransceiver(a), shimGetUserMedia(a), shimAudioContext(a), shimRTCIceCandidate(a), shimRTCIceCandidateRelayProtocol(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a), removeExtmapAllowMixed(a, l);
      break;
    default:
      c("Unsupported browser!");
      break;
  }
  return v;
}
adapterFactory({
  window: typeof window > "u" ? void 0 : window
});
const DECRYPTION_FAILURE_TOLERANCE = 10, E2EE_FLAG = "lk_e2ee", SALT = "LKFrameEncryptionKey", KEY_PROVIDER_DEFAULTS = {
  sharedKey: !1,
  ratchetSalt: SALT,
  ratchetWindowSize: 8,
  failureTolerance: DECRYPTION_FAILURE_TOLERANCE
};
var KeyProviderEvent;
(function(a) {
  a.SetKey = "setKey", a.RatchetRequest = "ratchetRequest", a.KeyRatcheted = "keyRatcheted";
})(KeyProviderEvent || (KeyProviderEvent = {}));
var KeyHandlerEvent;
(function(a) {
  a.KeyRatcheted = "keyRatcheted";
})(KeyHandlerEvent || (KeyHandlerEvent = {}));
var EncryptionEvent;
(function(a) {
  a.ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged", a.EncryptionError = "encryptionError";
})(EncryptionEvent || (EncryptionEvent = {}));
var CryptorEvent;
(function(a) {
  a.Error = "cryptorError";
})(CryptorEvent || (CryptorEvent = {}));
function isE2EESupported() {
  return isInsertableStreamSupported() || isScriptTransformSupported();
}
function isScriptTransformSupported() {
  return typeof window.RTCRtpScriptTransform < "u";
}
function isInsertableStreamSupported() {
  return typeof window.RTCRtpSender < "u" && // @ts-ignore
  typeof window.RTCRtpSender.prototype.createEncodedStreams < "u";
}
class BaseKeyProvider extends eventsExports$1.EventEmitter {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(), this.onKeyRatcheted = (c, l) => {
      livekitLogger.debug("key ratcheted event received", {
        material: c,
        keyIndex: l
      });
    }, this.keyInfoMap = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), u), this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);
  }
  /**
   * callback to invoke once a key has been set for a participant
   * @param key
   * @param participantIdentity
   * @param keyIndex
   */
  onSetEncryptionKey(u, c, l) {
    const v = {
      key: u,
      participantIdentity: c,
      keyIndex: l
    };
    this.keyInfoMap.set("".concat(c ?? "shared", "-").concat(l ?? 0), v), this.emit(KeyProviderEvent.SetKey, v);
  }
  getKeys() {
    return Array.from(this.keyInfoMap.values());
  }
  getOptions() {
    return this.options;
  }
  ratchetKey(u, c) {
    this.emit(KeyProviderEvent.RatchetRequest, u, c);
  }
}
class LivekitError extends Error {
  constructor(u, c) {
    super(c || "an error has occured"), this.code = u;
  }
}
class ConnectionError extends LivekitError {
  constructor(u, c, l) {
    super(1, u), this.status = l, this.reason = c;
  }
}
class DeviceUnsupportedError extends LivekitError {
  constructor(u) {
    super(21, u ?? "device is unsupported");
  }
}
class TrackInvalidError extends LivekitError {
  constructor(u) {
    super(20, u ?? "track is invalid");
  }
}
class UnsupportedServer extends LivekitError {
  constructor(u) {
    super(10, u ?? "unsupported server");
  }
}
class UnexpectedConnectionState extends LivekitError {
  constructor(u) {
    super(12, u ?? "unexpected connection state");
  }
}
class NegotiationError extends LivekitError {
  constructor(u) {
    super(13, u ?? "unable to negotiate");
  }
}
var MediaDeviceFailure;
(function(a) {
  a.PermissionDenied = "PermissionDenied", a.NotFound = "NotFound", a.DeviceInUse = "DeviceInUse", a.Other = "Other";
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
(function(a) {
  function u(c) {
    if (c && "name" in c)
      return c.name === "NotFoundError" || c.name === "DevicesNotFoundError" ? a.NotFound : c.name === "NotAllowedError" || c.name === "PermissionDeniedError" ? a.PermissionDenied : c.name === "NotReadableError" || c.name === "TrackStartError" ? a.DeviceInUse : a.Other;
  }
  a.getFailure = u;
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
var RoomEvent;
(function(a) {
  a.Connected = "connected", a.Reconnecting = "reconnecting", a.Reconnected = "reconnected", a.Disconnected = "disconnected", a.ConnectionStateChanged = "connectionStateChanged", a.MediaDevicesChanged = "mediaDevicesChanged", a.ParticipantConnected = "participantConnected", a.ParticipantDisconnected = "participantDisconnected", a.TrackPublished = "trackPublished", a.TrackSubscribed = "trackSubscribed", a.TrackSubscriptionFailed = "trackSubscriptionFailed", a.TrackUnpublished = "trackUnpublished", a.TrackUnsubscribed = "trackUnsubscribed", a.TrackMuted = "trackMuted", a.TrackUnmuted = "trackUnmuted", a.LocalTrackPublished = "localTrackPublished", a.LocalTrackUnpublished = "localTrackUnpublished", a.LocalAudioSilenceDetected = "localAudioSilenceDetected", a.ActiveSpeakersChanged = "activeSpeakersChanged", a.ParticipantMetadataChanged = "participantMetadataChanged", a.ParticipantNameChanged = "participantNameChanged", a.RoomMetadataChanged = "roomMetadataChanged", a.DataReceived = "dataReceived", a.ConnectionQualityChanged = "connectionQualityChanged", a.TrackStreamStateChanged = "trackStreamStateChanged", a.TrackSubscriptionPermissionChanged = "trackSubscriptionPermissionChanged", a.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged", a.AudioPlaybackStatusChanged = "audioPlaybackChanged", a.VideoPlaybackStatusChanged = "videoPlaybackChanged", a.MediaDevicesError = "mediaDevicesError", a.ParticipantPermissionsChanged = "participantPermissionsChanged", a.SignalConnected = "signalConnected", a.RecordingStatusChanged = "recordingStatusChanged", a.ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged", a.EncryptionError = "encryptionError", a.DCBufferStatusChanged = "dcBufferStatusChanged", a.ActiveDeviceChanged = "activeDeviceChanged";
})(RoomEvent || (RoomEvent = {}));
var ParticipantEvent;
(function(a) {
  a.TrackPublished = "trackPublished", a.TrackSubscribed = "trackSubscribed", a.TrackSubscriptionFailed = "trackSubscriptionFailed", a.TrackUnpublished = "trackUnpublished", a.TrackUnsubscribed = "trackUnsubscribed", a.TrackMuted = "trackMuted", a.TrackUnmuted = "trackUnmuted", a.LocalTrackPublished = "localTrackPublished", a.LocalTrackUnpublished = "localTrackUnpublished", a.ParticipantMetadataChanged = "participantMetadataChanged", a.ParticipantNameChanged = "participantNameChanged", a.DataReceived = "dataReceived", a.IsSpeakingChanged = "isSpeakingChanged", a.ConnectionQualityChanged = "connectionQualityChanged", a.TrackStreamStateChanged = "trackStreamStateChanged", a.TrackSubscriptionPermissionChanged = "trackSubscriptionPermissionChanged", a.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged", a.MediaDevicesError = "mediaDevicesError", a.AudioStreamAcquired = "audioStreamAcquired", a.ParticipantPermissionsChanged = "participantPermissionsChanged", a.PCTrackAdded = "pcTrackAdded";
})(ParticipantEvent || (ParticipantEvent = {}));
var EngineEvent;
(function(a) {
  a.TransportsCreated = "transportsCreated", a.Connected = "connected", a.Disconnected = "disconnected", a.Resuming = "resuming", a.Resumed = "resumed", a.Restarting = "restarting", a.Restarted = "restarted", a.SignalResumed = "signalResumed", a.SignalRestarted = "signalRestarted", a.Closing = "closing", a.MediaTrackAdded = "mediaTrackAdded", a.ActiveSpeakersUpdate = "activeSpeakersUpdate", a.DataPacketReceived = "dataPacketReceived", a.RTPVideoMapUpdate = "rtpVideoMapUpdate", a.DCBufferStatusChanged = "dcBufferStatusChanged", a.ParticipantUpdate = "participantUpdate", a.RoomUpdate = "roomUpdate", a.SpeakersChanged = "speakersChanged", a.StreamStateChanged = "streamStateChanged", a.ConnectionQualityUpdate = "connectionQualityUpdate", a.SubscriptionError = "subscriptionError", a.SubscriptionPermissionUpdate = "subscriptionPermissionUpdate", a.RemoteMute = "remoteMute", a.SubscribedQualityUpdate = "subscribedQualityUpdate", a.LocalTrackUnpublished = "localTrackUnpublished";
})(EngineEvent || (EngineEvent = {}));
var TrackEvent;
(function(a) {
  a.Message = "message", a.Muted = "muted", a.Unmuted = "unmuted", a.Restarted = "restarted", a.Ended = "ended", a.Subscribed = "subscribed", a.Unsubscribed = "unsubscribed", a.UpdateSettings = "updateSettings", a.UpdateSubscription = "updateSubscription", a.AudioPlaybackStarted = "audioPlaybackStarted", a.AudioPlaybackFailed = "audioPlaybackFailed", a.AudioSilenceDetected = "audioSilenceDetected", a.VisibilityChanged = "visibilityChanged", a.VideoDimensionsChanged = "videoDimensionsChanged", a.VideoPlaybackStarted = "videoPlaybackStarted", a.VideoPlaybackFailed = "videoPlaybackFailed", a.ElementAttached = "elementAttached", a.ElementDetached = "elementDetached", a.UpstreamPaused = "upstreamPaused", a.UpstreamResumed = "upstreamResumed", a.SubscriptionPermissionChanged = "subscriptionPermissionChanged", a.SubscriptionStatusChanged = "subscriptionStatusChanged", a.SubscriptionFailed = "subscriptionFailed";
})(TrackEvent || (TrackEvent = {}));
function r$1(a, u, c) {
  var l, v, p;
  u === void 0 && (u = 50), c === void 0 && (c = {});
  var _ = (l = c.isImmediate) != null && l, I = (v = c.callback) != null && v, P = c.maxWait, $ = Date.now(), F = [];
  function H() {
    if (P !== void 0) {
      var ee = Date.now() - $;
      if (ee + u >= P)
        return P - ee;
    }
    return u;
  }
  var j = function() {
    var ee = [].slice.call(arguments), X = this;
    return new Promise(function(ie, Q) {
      var ne = _ && p === void 0;
      if (p !== void 0 && clearTimeout(p), p = setTimeout(function() {
        if (p = void 0, $ = Date.now(), !_) {
          var de = a.apply(X, ee);
          I && I(de), F.forEach(function(he) {
            return (0, he.resolve)(de);
          }), F = [];
        }
      }, H()), ne) {
        var Z = a.apply(X, ee);
        return I && I(Z), ie(Z);
      }
      F.push({
        resolve: ie,
        reject: Q
      });
    });
  };
  return j.cancel = function(ee) {
    p !== void 0 && clearTimeout(p), F.forEach(function(X) {
      return (0, X.reject)(ee);
    }), F = [];
  }, j;
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
let browserDetails;
function getBrowser(a) {
  let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  if (typeof a > "u" && typeof navigator > "u")
    return;
  const c = (a ?? navigator.userAgent).toLowerCase();
  if (browserDetails === void 0 || u) {
    const l = browsersList.find((v) => {
      let {
        test: p
      } = v;
      return p.test(c);
    });
    browserDetails = l == null ? void 0 : l.describe(c);
  }
  return browserDetails;
}
const browsersList = [
  {
    test: /firefox|iceweasel|fxios/i,
    describe(a) {
      return {
        name: "Firefox",
        version: getMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, a),
        os: a.toLowerCase().includes("fxios") ? "iOS" : void 0
      };
    }
  },
  {
    test: /chrom|crios|crmo/i,
    describe(a) {
      return {
        name: "Chrome",
        version: getMatch(/(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i, a),
        os: a.toLowerCase().includes("crios") ? "iOS" : void 0
      };
    }
  },
  /* Safari */
  {
    test: /safari|applewebkit/i,
    describe(a) {
      return {
        name: "Safari",
        version: getMatch(commonVersionIdentifier, a),
        os: a.includes("mobile/") ? "iOS" : "macOS"
      };
    }
  }
];
function getMatch(a, u) {
  let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  const l = u.match(a);
  return l && l.length >= c && l[c] || "";
}
var version$1$1 = "2.0.1";
const version$3 = version$1$1, protocolVersion = 12;
class CriticalTimers {
}
CriticalTimers.setTimeout = function() {
  return setTimeout(...arguments);
};
CriticalTimers.setInterval = function() {
  return setInterval(...arguments);
};
CriticalTimers.clearTimeout = function() {
  return clearTimeout(...arguments);
};
CriticalTimers.clearInterval = function() {
  return clearInterval(...arguments);
};
class VideoPreset {
  constructor(u, c, l, v, p) {
    this.width = u, this.height = c, this.encoding = {
      maxBitrate: l,
      maxFramerate: v,
      priority: p
    };
  }
  get resolution() {
    return {
      width: this.width,
      height: this.height,
      frameRate: this.encoding.maxFramerate,
      aspectRatio: this.width / this.height
    };
  }
}
const backupCodecs = ["vp8", "h264"], videoCodecs = ["vp8", "h264", "vp9", "av1"];
function isBackupCodec(a) {
  return !!backupCodecs.find((u) => u === a);
}
var AudioPresets;
(function(a) {
  a.telephone = {
    maxBitrate: 12e3
  }, a.speech = {
    maxBitrate: 2e4
  }, a.music = {
    maxBitrate: 32e3
  }, a.musicStereo = {
    maxBitrate: 48e3
  }, a.musicHighQuality = {
    maxBitrate: 64e3
  }, a.musicHighQualityStereo = {
    maxBitrate: 96e3
  };
})(AudioPresets || (AudioPresets = {}));
const VideoPresets = {
  h90: new VideoPreset(160, 90, 9e4, 20),
  h180: new VideoPreset(320, 180, 16e4, 20),
  h216: new VideoPreset(384, 216, 18e4, 20),
  h360: new VideoPreset(640, 360, 45e4, 20),
  h540: new VideoPreset(960, 540, 8e5, 25),
  h720: new VideoPreset(1280, 720, 17e5, 30),
  h1080: new VideoPreset(1920, 1080, 3e6, 30),
  h1440: new VideoPreset(2560, 1440, 5e6, 30),
  h2160: new VideoPreset(3840, 2160, 8e6, 30)
}, VideoPresets43 = {
  h120: new VideoPreset(160, 120, 7e4, 20),
  h180: new VideoPreset(240, 180, 125e3, 20),
  h240: new VideoPreset(320, 240, 14e4, 20),
  h360: new VideoPreset(480, 360, 33e4, 20),
  h480: new VideoPreset(640, 480, 5e5, 20),
  h540: new VideoPreset(720, 540, 6e5, 25),
  h720: new VideoPreset(960, 720, 13e5, 30),
  h1080: new VideoPreset(1440, 1080, 23e5, 30),
  h1440: new VideoPreset(1920, 1440, 38e5, 30)
}, ScreenSharePresets = {
  h360fps3: new VideoPreset(640, 360, 2e5, 3, "medium"),
  h360fps15: new VideoPreset(640, 360, 4e5, 15, "medium"),
  h720fps5: new VideoPreset(1280, 720, 8e5, 5, "medium"),
  h720fps15: new VideoPreset(1280, 720, 15e5, 15, "medium"),
  h720fps30: new VideoPreset(1280, 720, 2e6, 30, "medium"),
  h1080fps15: new VideoPreset(1920, 1080, 25e5, 15, "medium"),
  h1080fps30: new VideoPreset(1920, 1080, 5e6, 30, "medium"),
  // original resolution, without resizing
  original: new VideoPreset(0, 0, 7e6, 30, "medium")
};
var SignalTarget;
(function(a) {
  a[a.PUBLISHER = 0] = "PUBLISHER", a[a.SUBSCRIBER = 1] = "SUBSCRIBER";
})(SignalTarget || (SignalTarget = {}));
proto3.util.setEnumType(SignalTarget, "livekit.SignalTarget", [{
  no: 0,
  name: "PUBLISHER"
}, {
  no: 1,
  name: "SUBSCRIBER"
}]);
var StreamState;
(function(a) {
  a[a.ACTIVE = 0] = "ACTIVE", a[a.PAUSED = 1] = "PAUSED";
})(StreamState || (StreamState = {}));
proto3.util.setEnumType(StreamState, "livekit.StreamState", [{
  no: 0,
  name: "ACTIVE"
}, {
  no: 1,
  name: "PAUSED"
}]);
var CandidateProtocol;
(function(a) {
  a[a.UDP = 0] = "UDP", a[a.TCP = 1] = "TCP", a[a.TLS = 2] = "TLS";
})(CandidateProtocol || (CandidateProtocol = {}));
proto3.util.setEnumType(CandidateProtocol, "livekit.CandidateProtocol", [{
  no: 0,
  name: "UDP"
}, {
  no: 1,
  name: "TCP"
}, {
  no: 2,
  name: "TLS"
}]);
class SignalRequest extends Message {
  constructor(u) {
    super(), this.message = {
      case: void 0
    }, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SignalRequest().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SignalRequest().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SignalRequest().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SignalRequest, u, c);
  }
}
SignalRequest.runtime = proto3;
SignalRequest.typeName = "livekit.SignalRequest";
SignalRequest.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "offer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 3,
  name: "trickle",
  kind: "message",
  T: TrickleRequest,
  oneof: "message"
}, {
  no: 4,
  name: "add_track",
  kind: "message",
  T: AddTrackRequest,
  oneof: "message"
}, {
  no: 5,
  name: "mute",
  kind: "message",
  T: MuteTrackRequest,
  oneof: "message"
}, {
  no: 6,
  name: "subscription",
  kind: "message",
  T: UpdateSubscription,
  oneof: "message"
}, {
  no: 7,
  name: "track_setting",
  kind: "message",
  T: UpdateTrackSettings,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: LeaveRequest,
  oneof: "message"
}, {
  no: 10,
  name: "update_layers",
  kind: "message",
  T: UpdateVideoLayers,
  oneof: "message"
}, {
  no: 11,
  name: "subscription_permission",
  kind: "message",
  T: SubscriptionPermission,
  oneof: "message"
}, {
  no: 12,
  name: "sync_state",
  kind: "message",
  T: SyncState,
  oneof: "message"
}, {
  no: 13,
  name: "simulate",
  kind: "message",
  T: SimulateScenario,
  oneof: "message"
}, {
  no: 14,
  name: "ping",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 15,
  name: "update_metadata",
  kind: "message",
  T: UpdateParticipantMetadata,
  oneof: "message"
}, {
  no: 16,
  name: "ping_req",
  kind: "message",
  T: Ping,
  oneof: "message"
}]);
class SignalResponse extends Message {
  constructor(u) {
    super(), this.message = {
      case: void 0
    }, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SignalResponse().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SignalResponse().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SignalResponse().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SignalResponse, u, c);
  }
}
SignalResponse.runtime = proto3;
SignalResponse.typeName = "livekit.SignalResponse";
SignalResponse.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "join",
  kind: "message",
  T: JoinResponse,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 3,
  name: "offer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 4,
  name: "trickle",
  kind: "message",
  T: TrickleRequest,
  oneof: "message"
}, {
  no: 5,
  name: "update",
  kind: "message",
  T: ParticipantUpdate,
  oneof: "message"
}, {
  no: 6,
  name: "track_published",
  kind: "message",
  T: TrackPublishedResponse,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: LeaveRequest,
  oneof: "message"
}, {
  no: 9,
  name: "mute",
  kind: "message",
  T: MuteTrackRequest,
  oneof: "message"
}, {
  no: 10,
  name: "speakers_changed",
  kind: "message",
  T: SpeakersChanged,
  oneof: "message"
}, {
  no: 11,
  name: "room_update",
  kind: "message",
  T: RoomUpdate,
  oneof: "message"
}, {
  no: 12,
  name: "connection_quality",
  kind: "message",
  T: ConnectionQualityUpdate,
  oneof: "message"
}, {
  no: 13,
  name: "stream_state_update",
  kind: "message",
  T: StreamStateUpdate,
  oneof: "message"
}, {
  no: 14,
  name: "subscribed_quality_update",
  kind: "message",
  T: SubscribedQualityUpdate,
  oneof: "message"
}, {
  no: 15,
  name: "subscription_permission_update",
  kind: "message",
  T: SubscriptionPermissionUpdate,
  oneof: "message"
}, {
  no: 16,
  name: "refresh_token",
  kind: "scalar",
  T: 9,
  oneof: "message"
}, {
  no: 17,
  name: "track_unpublished",
  kind: "message",
  T: TrackUnpublishedResponse,
  oneof: "message"
}, {
  no: 18,
  name: "pong",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 19,
  name: "reconnect",
  kind: "message",
  T: ReconnectResponse,
  oneof: "message"
}, {
  no: 20,
  name: "pong_resp",
  kind: "message",
  T: Pong,
  oneof: "message"
}, {
  no: 21,
  name: "subscription_response",
  kind: "message",
  T: SubscriptionResponse,
  oneof: "message"
}]);
class SimulcastCodec extends Message {
  constructor(u) {
    super(), this.codec = "", this.cid = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SimulcastCodec().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SimulcastCodec().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SimulcastCodec().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SimulcastCodec, u, c);
  }
}
SimulcastCodec.runtime = proto3;
SimulcastCodec.typeName = "livekit.SimulcastCodec";
SimulcastCodec.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class AddTrackRequest extends Message {
  constructor(u) {
    super(), this.cid = "", this.name = "", this.type = TrackType.AUDIO, this.width = 0, this.height = 0, this.muted = !1, this.disableDtx = !1, this.source = TrackSource.UNKNOWN, this.layers = [], this.simulcastCodecs = [], this.sid = "", this.stereo = !1, this.disableRed = !1, this.encryption = Encryption_Type.NONE, this.stream = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new AddTrackRequest().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new AddTrackRequest().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new AddTrackRequest().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(AddTrackRequest, u, c);
  }
}
AddTrackRequest.runtime = proto3;
AddTrackRequest.typeName = "livekit.AddTrackRequest";
AddTrackRequest.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(TrackType)
}, {
  no: 4,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 9,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}, {
  no: 10,
  name: "simulcast_codecs",
  kind: "message",
  T: SimulcastCodec,
  repeated: !0
}, {
  no: 11,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "encryption",
  kind: "enum",
  T: proto3.getEnumType(Encryption_Type)
}, {
  no: 15,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class TrickleRequest extends Message {
  constructor(u) {
    super(), this.candidateInit = "", this.target = SignalTarget.PUBLISHER, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new TrickleRequest().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new TrickleRequest().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new TrickleRequest().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(TrickleRequest, u, c);
  }
}
TrickleRequest.runtime = proto3;
TrickleRequest.typeName = "livekit.TrickleRequest";
TrickleRequest.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "candidateInit",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "target",
  kind: "enum",
  T: proto3.getEnumType(SignalTarget)
}]);
class MuteTrackRequest extends Message {
  constructor(u) {
    super(), this.sid = "", this.muted = !1, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new MuteTrackRequest().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new MuteTrackRequest().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new MuteTrackRequest().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(MuteTrackRequest, u, c);
  }
}
MuteTrackRequest.runtime = proto3;
MuteTrackRequest.typeName = "livekit.MuteTrackRequest";
MuteTrackRequest.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
class JoinResponse extends Message {
  constructor(u) {
    super(), this.otherParticipants = [], this.serverVersion = "", this.iceServers = [], this.subscriberPrimary = !1, this.alternativeUrl = "", this.serverRegion = "", this.pingTimeout = 0, this.pingInterval = 0, this.sifTrailer = new Uint8Array(0), proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new JoinResponse().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new JoinResponse().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new JoinResponse().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(JoinResponse, u, c);
  }
}
JoinResponse.runtime = proto3;
JoinResponse.typeName = "livekit.JoinResponse";
JoinResponse.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "room",
  kind: "message",
  T: Room$1
}, {
  no: 2,
  name: "participant",
  kind: "message",
  T: ParticipantInfo
}, {
  no: 3,
  name: "other_participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: !0
}, {
  no: 4,
  name: "server_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "ice_servers",
  kind: "message",
  T: ICEServer,
  repeated: !0
}, {
  no: 6,
  name: "subscriber_primary",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "alternative_url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "client_configuration",
  kind: "message",
  T: ClientConfiguration
}, {
  no: 9,
  name: "server_region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "ping_timeout",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 11,
  name: "ping_interval",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 12,
  name: "server_info",
  kind: "message",
  T: ServerInfo
}, {
  no: 13,
  name: "sif_trailer",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}]);
class ReconnectResponse extends Message {
  constructor(u) {
    super(), this.iceServers = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ReconnectResponse().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ReconnectResponse().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ReconnectResponse().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ReconnectResponse, u, c);
  }
}
ReconnectResponse.runtime = proto3;
ReconnectResponse.typeName = "livekit.ReconnectResponse";
ReconnectResponse.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "ice_servers",
  kind: "message",
  T: ICEServer,
  repeated: !0
}, {
  no: 2,
  name: "client_configuration",
  kind: "message",
  T: ClientConfiguration
}]);
class TrackPublishedResponse extends Message {
  constructor(u) {
    super(), this.cid = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new TrackPublishedResponse().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new TrackPublishedResponse().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new TrackPublishedResponse().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(TrackPublishedResponse, u, c);
  }
}
TrackPublishedResponse.runtime = proto3;
TrackPublishedResponse.typeName = "livekit.TrackPublishedResponse";
TrackPublishedResponse.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track",
  kind: "message",
  T: TrackInfo
}]);
class TrackUnpublishedResponse extends Message {
  constructor(u) {
    super(), this.trackSid = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new TrackUnpublishedResponse().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new TrackUnpublishedResponse().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new TrackUnpublishedResponse().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(TrackUnpublishedResponse, u, c);
  }
}
TrackUnpublishedResponse.runtime = proto3;
TrackUnpublishedResponse.typeName = "livekit.TrackUnpublishedResponse";
TrackUnpublishedResponse.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class SessionDescription extends Message {
  constructor(u) {
    super(), this.type = "", this.sdp = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SessionDescription().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SessionDescription().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SessionDescription().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SessionDescription, u, c);
  }
}
SessionDescription.runtime = proto3;
SessionDescription.typeName = "livekit.SessionDescription";
SessionDescription.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "sdp",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class ParticipantUpdate extends Message {
  constructor(u) {
    super(), this.participants = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ParticipantUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ParticipantUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ParticipantUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ParticipantUpdate, u, c);
  }
}
ParticipantUpdate.runtime = proto3;
ParticipantUpdate.typeName = "livekit.ParticipantUpdate";
ParticipantUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: !0
}]);
class UpdateSubscription extends Message {
  constructor(u) {
    super(), this.trackSids = [], this.subscribe = !1, this.participantTracks = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new UpdateSubscription().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new UpdateSubscription().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new UpdateSubscription().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(UpdateSubscription, u, c);
  }
}
UpdateSubscription.runtime = proto3;
UpdateSubscription.typeName = "livekit.UpdateSubscription";
UpdateSubscription.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "participant_tracks",
  kind: "message",
  T: ParticipantTracks,
  repeated: !0
}]);
class UpdateTrackSettings extends Message {
  constructor(u) {
    super(), this.trackSids = [], this.disabled = !1, this.quality = VideoQuality$1.LOW, this.width = 0, this.height = 0, this.fps = 0, this.priority = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new UpdateTrackSettings().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new UpdateTrackSettings().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new UpdateTrackSettings().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(UpdateTrackSettings, u, c);
  }
}
UpdateTrackSettings.runtime = proto3;
UpdateTrackSettings.typeName = "livekit.UpdateTrackSettings";
UpdateTrackSettings.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "disabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "fps",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 8,
  name: "priority",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
class LeaveRequest extends Message {
  constructor(u) {
    super(), this.canReconnect = !1, this.reason = DisconnectReason.UNKNOWN_REASON, this.action = LeaveRequest_Action.DISCONNECT, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new LeaveRequest().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new LeaveRequest().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new LeaveRequest().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(LeaveRequest, u, c);
  }
}
LeaveRequest.runtime = proto3;
LeaveRequest.typeName = "livekit.LeaveRequest";
LeaveRequest.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "can_reconnect",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "reason",
  kind: "enum",
  T: proto3.getEnumType(DisconnectReason)
}, {
  no: 3,
  name: "action",
  kind: "enum",
  T: proto3.getEnumType(LeaveRequest_Action)
}, {
  no: 4,
  name: "regions",
  kind: "message",
  T: RegionSettings
}]);
var LeaveRequest_Action;
(function(a) {
  a[a.DISCONNECT = 0] = "DISCONNECT", a[a.RESUME = 1] = "RESUME", a[a.RECONNECT = 2] = "RECONNECT";
})(LeaveRequest_Action || (LeaveRequest_Action = {}));
proto3.util.setEnumType(LeaveRequest_Action, "livekit.LeaveRequest.Action", [{
  no: 0,
  name: "DISCONNECT"
}, {
  no: 1,
  name: "RESUME"
}, {
  no: 2,
  name: "RECONNECT"
}]);
class UpdateVideoLayers extends Message {
  constructor(u) {
    super(), this.trackSid = "", this.layers = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new UpdateVideoLayers().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new UpdateVideoLayers().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new UpdateVideoLayers().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(UpdateVideoLayers, u, c);
  }
}
UpdateVideoLayers.runtime = proto3;
UpdateVideoLayers.typeName = "livekit.UpdateVideoLayers";
UpdateVideoLayers.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}]);
class UpdateParticipantMetadata extends Message {
  constructor(u) {
    super(), this.metadata = "", this.name = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new UpdateParticipantMetadata().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new UpdateParticipantMetadata().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new UpdateParticipantMetadata().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(UpdateParticipantMetadata, u, c);
  }
}
UpdateParticipantMetadata.runtime = proto3;
UpdateParticipantMetadata.typeName = "livekit.UpdateParticipantMetadata";
UpdateParticipantMetadata.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class ICEServer extends Message {
  constructor(u) {
    super(), this.urls = [], this.username = "", this.credential = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ICEServer().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ICEServer().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ICEServer().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ICEServer, u, c);
  }
}
ICEServer.runtime = proto3;
ICEServer.typeName = "livekit.ICEServer";
ICEServer.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "credential",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class SpeakersChanged extends Message {
  constructor(u) {
    super(), this.speakers = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SpeakersChanged().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SpeakersChanged().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SpeakersChanged().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SpeakersChanged, u, c);
  }
}
SpeakersChanged.runtime = proto3;
SpeakersChanged.typeName = "livekit.SpeakersChanged";
SpeakersChanged.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: SpeakerInfo,
  repeated: !0
}]);
class RoomUpdate extends Message {
  constructor(u) {
    super(), proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new RoomUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new RoomUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new RoomUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(RoomUpdate, u, c);
  }
}
RoomUpdate.runtime = proto3;
RoomUpdate.typeName = "livekit.RoomUpdate";
RoomUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "room",
  kind: "message",
  T: Room$1
}]);
class ConnectionQualityInfo extends Message {
  constructor(u) {
    super(), this.participantSid = "", this.quality = ConnectionQuality$1.POOR, this.score = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ConnectionQualityInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ConnectionQualityInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ConnectionQualityInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ConnectionQualityInfo, u, c);
  }
}
ConnectionQualityInfo.runtime = proto3;
ConnectionQualityInfo.typeName = "livekit.ConnectionQualityInfo";
ConnectionQualityInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(ConnectionQuality$1)
}, {
  no: 3,
  name: "score",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}]);
class ConnectionQualityUpdate extends Message {
  constructor(u) {
    super(), this.updates = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ConnectionQualityUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ConnectionQualityUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ConnectionQualityUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ConnectionQualityUpdate, u, c);
  }
}
ConnectionQualityUpdate.runtime = proto3;
ConnectionQualityUpdate.typeName = "livekit.ConnectionQualityUpdate";
ConnectionQualityUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "updates",
  kind: "message",
  T: ConnectionQualityInfo,
  repeated: !0
}]);
class StreamStateInfo extends Message {
  constructor(u) {
    super(), this.participantSid = "", this.trackSid = "", this.state = StreamState.ACTIVE, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new StreamStateInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new StreamStateInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new StreamStateInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(StreamStateInfo, u, c);
  }
}
StreamStateInfo.runtime = proto3;
StreamStateInfo.typeName = "livekit.StreamStateInfo";
StreamStateInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: proto3.getEnumType(StreamState)
}]);
class StreamStateUpdate extends Message {
  constructor(u) {
    super(), this.streamStates = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new StreamStateUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new StreamStateUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new StreamStateUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(StreamStateUpdate, u, c);
  }
}
StreamStateUpdate.runtime = proto3;
StreamStateUpdate.typeName = "livekit.StreamStateUpdate";
StreamStateUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "stream_states",
  kind: "message",
  T: StreamStateInfo,
  repeated: !0
}]);
class SubscribedQuality extends Message {
  constructor(u) {
    super(), this.quality = VideoQuality$1.LOW, this.enabled = !1, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SubscribedQuality().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SubscribedQuality().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SubscribedQuality().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SubscribedQuality, u, c);
  }
}
SubscribedQuality.runtime = proto3;
SubscribedQuality.typeName = "livekit.SubscribedQuality";
SubscribedQuality.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 2,
  name: "enabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
class SubscribedCodec extends Message {
  constructor(u) {
    super(), this.codec = "", this.qualities = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SubscribedCodec().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SubscribedCodec().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SubscribedCodec().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SubscribedCodec, u, c);
  }
}
SubscribedCodec.runtime = proto3;
SubscribedCodec.typeName = "livekit.SubscribedCodec";
SubscribedCodec.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "qualities",
  kind: "message",
  T: SubscribedQuality,
  repeated: !0
}]);
class SubscribedQualityUpdate extends Message {
  constructor(u) {
    super(), this.trackSid = "", this.subscribedQualities = [], this.subscribedCodecs = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SubscribedQualityUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SubscribedQualityUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SubscribedQualityUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SubscribedQualityUpdate, u, c);
  }
}
SubscribedQualityUpdate.runtime = proto3;
SubscribedQualityUpdate.typeName = "livekit.SubscribedQualityUpdate";
SubscribedQualityUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "subscribed_qualities",
  kind: "message",
  T: SubscribedQuality,
  repeated: !0
}, {
  no: 3,
  name: "subscribed_codecs",
  kind: "message",
  T: SubscribedCodec,
  repeated: !0
}]);
class TrackPermission extends Message {
  constructor(u) {
    super(), this.participantSid = "", this.allTracks = !1, this.trackSids = [], this.participantIdentity = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new TrackPermission().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new TrackPermission().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new TrackPermission().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(TrackPermission, u, c);
  }
}
TrackPermission.runtime = proto3;
TrackPermission.typeName = "livekit.TrackPermission";
TrackPermission.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "all_tracks",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class SubscriptionPermission extends Message {
  constructor(u) {
    super(), this.allParticipants = !1, this.trackPermissions = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SubscriptionPermission().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SubscriptionPermission().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SubscriptionPermission().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SubscriptionPermission, u, c);
  }
}
SubscriptionPermission.runtime = proto3;
SubscriptionPermission.typeName = "livekit.SubscriptionPermission";
SubscriptionPermission.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "all_participants",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "track_permissions",
  kind: "message",
  T: TrackPermission,
  repeated: !0
}]);
class SubscriptionPermissionUpdate extends Message {
  constructor(u) {
    super(), this.participantSid = "", this.trackSid = "", this.allowed = !1, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SubscriptionPermissionUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SubscriptionPermissionUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SubscriptionPermissionUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SubscriptionPermissionUpdate, u, c);
  }
}
SubscriptionPermissionUpdate.runtime = proto3;
SubscriptionPermissionUpdate.typeName = "livekit.SubscriptionPermissionUpdate";
SubscriptionPermissionUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "allowed",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
class SyncState extends Message {
  constructor(u) {
    super(), this.publishTracks = [], this.dataChannels = [], this.trackSidsDisabled = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SyncState().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SyncState().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SyncState().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SyncState, u, c);
  }
}
SyncState.runtime = proto3;
SyncState.typeName = "livekit.SyncState";
SyncState.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "answer",
  kind: "message",
  T: SessionDescription
}, {
  no: 2,
  name: "subscription",
  kind: "message",
  T: UpdateSubscription
}, {
  no: 3,
  name: "publish_tracks",
  kind: "message",
  T: TrackPublishedResponse,
  repeated: !0
}, {
  no: 4,
  name: "data_channels",
  kind: "message",
  T: DataChannelInfo,
  repeated: !0
}, {
  no: 5,
  name: "offer",
  kind: "message",
  T: SessionDescription
}, {
  no: 6,
  name: "track_sids_disabled",
  kind: "scalar",
  T: 9,
  repeated: !0
}]);
class DataChannelInfo extends Message {
  constructor(u) {
    super(), this.label = "", this.id = 0, this.target = SignalTarget.PUBLISHER, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new DataChannelInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new DataChannelInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new DataChannelInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(DataChannelInfo, u, c);
  }
}
DataChannelInfo.runtime = proto3;
DataChannelInfo.typeName = "livekit.DataChannelInfo";
DataChannelInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "label",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "id",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "target",
  kind: "enum",
  T: proto3.getEnumType(SignalTarget)
}]);
class SimulateScenario extends Message {
  constructor(u) {
    super(), this.scenario = {
      case: void 0
    }, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SimulateScenario().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SimulateScenario().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SimulateScenario().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SimulateScenario, u, c);
  }
}
SimulateScenario.runtime = proto3;
SimulateScenario.typeName = "livekit.SimulateScenario";
SimulateScenario.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "speaker_update",
  kind: "scalar",
  T: 5,
  oneof: "scenario"
}, {
  no: 2,
  name: "node_failure",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 3,
  name: "migration",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 4,
  name: "server_leave",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 5,
  name: "switch_candidate_protocol",
  kind: "enum",
  T: proto3.getEnumType(CandidateProtocol),
  oneof: "scenario"
}, {
  no: 6,
  name: "subscriber_bandwidth",
  kind: "scalar",
  T: 3,
  oneof: "scenario"
}, {
  no: 7,
  name: "disconnect_signal_on_resume",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 8,
  name: "disconnect_signal_on_resume_no_messages",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}]);
class Ping extends Message {
  constructor(u) {
    super(), this.timestamp = protoInt64.zero, this.rtt = protoInt64.zero, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new Ping().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Ping().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Ping().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Ping, u, c);
  }
}
Ping.runtime = proto3;
Ping.typeName = "livekit.Ping";
Ping.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "rtt",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]);
class Pong extends Message {
  constructor(u) {
    super(), this.lastPingTimestamp = protoInt64.zero, this.timestamp = protoInt64.zero, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new Pong().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Pong().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Pong().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Pong, u, c);
  }
}
Pong.runtime = proto3;
Pong.typeName = "livekit.Pong";
Pong.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "last_ping_timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]);
class RegionSettings extends Message {
  constructor(u) {
    super(), this.regions = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new RegionSettings().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new RegionSettings().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new RegionSettings().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(RegionSettings, u, c);
  }
}
RegionSettings.runtime = proto3;
RegionSettings.typeName = "livekit.RegionSettings";
RegionSettings.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "regions",
  kind: "message",
  T: RegionInfo,
  repeated: !0
}]);
class RegionInfo extends Message {
  constructor(u) {
    super(), this.region = "", this.url = "", this.distance = protoInt64.zero, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new RegionInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new RegionInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new RegionInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(RegionInfo, u, c);
  }
}
RegionInfo.runtime = proto3;
RegionInfo.typeName = "livekit.RegionInfo";
RegionInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "distance",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]);
class SubscriptionResponse extends Message {
  constructor(u) {
    super(), this.trackSid = "", this.err = SubscriptionError.SE_UNKNOWN, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SubscriptionResponse().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SubscriptionResponse().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SubscriptionResponse().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SubscriptionResponse, u, c);
  }
}
SubscriptionResponse.runtime = proto3;
SubscriptionResponse.typeName = "livekit.SubscriptionResponse";
SubscriptionResponse.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "err",
  kind: "enum",
  T: proto3.getEnumType(SubscriptionError)
}]);
function cloneDeep(a) {
  if (!(typeof a > "u"))
    return typeof structuredClone == "function" ? structuredClone(a) : JSON.parse(JSON.stringify(a));
}
const BACKGROUND_REACTION_DELAY = 5e3, recycledElements = [];
var VideoQuality;
(function(a) {
  a[a.LOW = 0] = "LOW", a[a.MEDIUM = 1] = "MEDIUM", a[a.HIGH = 2] = "HIGH";
})(VideoQuality || (VideoQuality = {}));
class Track extends eventsExports$1.EventEmitter {
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var v;
    super(), this.attachedElements = [], this.isMuted = !1, this.streamState = Track.StreamState.Active, this.isInBackground = !1, this._currentBitrate = 0, this.log = livekitLogger, this.appVisibilityChangedListener = () => {
      this.backgroundTimeout && clearTimeout(this.backgroundTimeout), document.visibilityState === "hidden" ? this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY) : this.handleAppVisibilityChanged();
    }, this.log = getLogger((v = l.loggerName) !== null && v !== void 0 ? v : LoggerNames.Track), this.loggerContextCb = l.loggerContextCb, this.setMaxListeners(100), this.kind = c, this._mediaStreamTrack = u, this._mediaStreamID = u.id, this.source = Track.Source.Unknown;
  }
  get logContext() {
    var u;
    return Object.assign(Object.assign({}, (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)), getLogContextFromTrack(this));
  }
  /** current receive bits per second */
  get currentBitrate() {
    return this._currentBitrate;
  }
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /**
   * @internal
   * used for keep mediaStream's first id, since it's id might change
   * if we disable/enable a track
   */
  get mediaStreamID() {
    return this._mediaStreamID;
  }
  attach(u) {
    let c = "audio";
    this.kind === Track.Kind.Video && (c = "video"), this.attachedElements.length === 0 && Track.Kind.Video && this.addAppVisibilityListener(), u || (c === "audio" && (recycledElements.forEach((p) => {
      p.parentElement === null && !u && (u = p);
    }), u && recycledElements.splice(recycledElements.indexOf(u), 1)), u || (u = document.createElement(c))), this.attachedElements.includes(u) || this.attachedElements.push(u), attachToElement(this.mediaStreamTrack, u);
    const l = u.srcObject.getTracks(), v = l.some((p) => p.kind === "audio");
    return u.play().then(() => {
      this.emit(v ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);
    }).catch((p) => {
      p.name === "NotAllowedError" ? this.emit(v ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, p) : p.name === "AbortError" ? livekitLogger.debug("".concat(v ? "audio" : "video", " playback aborted, likely due to new play request")) : livekitLogger.warn("could not playback ".concat(v ? "audio" : "video"), p), v && u && l.some((_) => _.kind === "video") && p.name === "NotAllowedError" && (u.muted = !0, u.play().catch(() => {
      }));
    }), this.emit(TrackEvent.ElementAttached, u), u;
  }
  detach(u) {
    try {
      if (u) {
        detachTrack(this.mediaStreamTrack, u);
        const l = this.attachedElements.indexOf(u);
        return l >= 0 && (this.attachedElements.splice(l, 1), this.recycleElement(u), this.emit(TrackEvent.ElementDetached, u)), u;
      }
      const c = [];
      return this.attachedElements.forEach((l) => {
        detachTrack(this.mediaStreamTrack, l), c.push(l), this.recycleElement(l), this.emit(TrackEvent.ElementDetached, l);
      }), this.attachedElements = [], c;
    } finally {
      this.attachedElements.length === 0 && this.removeAppVisibilityListener();
    }
  }
  stop() {
    this.stopMonitor(), this._mediaStreamTrack.stop();
  }
  enable() {
    this._mediaStreamTrack.enabled = !0;
  }
  disable() {
    this._mediaStreamTrack.enabled = !1;
  }
  /* @internal */
  stopMonitor() {
    this.monitorInterval && clearInterval(this.monitorInterval);
  }
  /** @internal */
  updateLoggerOptions(u) {
    u.loggerName && (this.log = getLogger(u.loggerName)), u.loggerContextCb && (this.loggerContextCb = u.loggerContextCb);
  }
  recycleElement(u) {
    if (u instanceof HTMLAudioElement) {
      let c = !0;
      u.pause(), recycledElements.forEach((l) => {
        l.parentElement || (c = !1);
      }), c && recycledElements.push(u);
    }
  }
  handleAppVisibilityChanged() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.isInBackground = document.visibilityState === "hidden";
    });
  }
  addAppVisibilityListener() {
    isWeb() ? (this.isInBackground = document.visibilityState === "hidden", document.addEventListener("visibilitychange", this.appVisibilityChangedListener)) : this.isInBackground = !1;
  }
  removeAppVisibilityListener() {
    isWeb() && document.removeEventListener("visibilitychange", this.appVisibilityChangedListener);
  }
}
function attachToElement(a, u) {
  let c;
  u.srcObject instanceof MediaStream ? c = u.srcObject : c = new MediaStream();
  let l;
  a.kind === "audio" ? l = c.getAudioTracks() : l = c.getVideoTracks(), l.includes(a) || (l.forEach((v) => {
    c.removeTrack(v);
  }), c.addTrack(a)), (!isSafari() || !(u instanceof HTMLVideoElement)) && (u.autoplay = !0), u.muted = c.getAudioTracks().length === 0, u instanceof HTMLVideoElement && (u.playsInline = !0), u.srcObject !== c && (u.srcObject = c, (isSafari() || isFireFox()) && u instanceof HTMLVideoElement && setTimeout(() => {
    u.srcObject = c, u.play().catch(() => {
    });
  }, 0));
}
function detachTrack(a, u) {
  if (u.srcObject instanceof MediaStream) {
    const c = u.srcObject;
    c.removeTrack(a), c.getTracks().length > 0 ? u.srcObject = c : u.srcObject = null;
  }
}
(function(a) {
  let u;
  (function($) {
    $.Audio = "audio", $.Video = "video", $.Unknown = "unknown";
  })(u = a.Kind || (a.Kind = {}));
  let c;
  (function($) {
    $.Camera = "camera", $.Microphone = "microphone", $.ScreenShare = "screen_share", $.ScreenShareAudio = "screen_share_audio", $.Unknown = "unknown";
  })(c = a.Source || (a.Source = {}));
  let l;
  (function($) {
    $.Active = "active", $.Paused = "paused", $.Unknown = "unknown";
  })(l = a.StreamState || (a.StreamState = {}));
  function v($) {
    switch ($) {
      case u.Audio:
        return TrackType.AUDIO;
      case u.Video:
        return TrackType.VIDEO;
      default:
        return TrackType.DATA;
    }
  }
  a.kindToProto = v;
  function p($) {
    switch ($) {
      case TrackType.AUDIO:
        return u.Audio;
      case TrackType.VIDEO:
        return u.Video;
      default:
        return u.Unknown;
    }
  }
  a.kindFromProto = p;
  function _($) {
    switch ($) {
      case c.Camera:
        return TrackSource.CAMERA;
      case c.Microphone:
        return TrackSource.MICROPHONE;
      case c.ScreenShare:
        return TrackSource.SCREEN_SHARE;
      case c.ScreenShareAudio:
        return TrackSource.SCREEN_SHARE_AUDIO;
      default:
        return TrackSource.UNKNOWN;
    }
  }
  a.sourceToProto = _;
  function I($) {
    switch ($) {
      case TrackSource.CAMERA:
        return c.Camera;
      case TrackSource.MICROPHONE:
        return c.Microphone;
      case TrackSource.SCREEN_SHARE:
        return c.ScreenShare;
      case TrackSource.SCREEN_SHARE_AUDIO:
        return c.ScreenShareAudio;
      default:
        return c.Unknown;
    }
  }
  a.sourceFromProto = I;
  function P($) {
    switch ($) {
      case StreamState.ACTIVE:
        return l.Active;
      case StreamState.PAUSED:
        return l.Paused;
      default:
        return l.Unknown;
    }
  }
  a.streamStateFromProto = P;
})(Track || (Track = {}));
function mergeDefaultOptions(a, u, c) {
  var l;
  const v = (l = cloneDeep(a)) !== null && l !== void 0 ? l : {};
  return v.audio === !0 && (v.audio = {}), v.video === !0 && (v.video = {}), v.audio && mergeObjectWithoutOverwriting(v.audio, u), v.video && mergeObjectWithoutOverwriting(v.video, c), v;
}
function mergeObjectWithoutOverwriting(a, u) {
  return Object.keys(u).forEach((c) => {
    a[c] === void 0 && (a[c] = u[c]);
  }), a;
}
function constraintsForOptions(a) {
  const u = {};
  if (a.video)
    if (typeof a.video == "object") {
      const c = {}, l = c, v = a.video;
      Object.keys(v).forEach((p) => {
        switch (p) {
          case "resolution":
            mergeObjectWithoutOverwriting(l, v.resolution);
            break;
          default:
            l[p] = v[p];
        }
      }), u.video = c;
    } else
      u.video = a.video;
  else
    u.video = !1;
  return a.audio ? typeof a.audio == "object" ? u.audio = a.audio : u.audio = !0 : u.audio = !1, u;
}
function detectSilence(a) {
  let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  return __awaiter$3(this, void 0, void 0, function* () {
    const c = getNewAudioContext();
    if (c) {
      const l = c.createAnalyser();
      l.fftSize = 2048;
      const v = l.frequencyBinCount, p = new Uint8Array(v);
      c.createMediaStreamSource(new MediaStream([a.mediaStreamTrack])).connect(l), yield sleep(u), l.getByteTimeDomainData(p);
      const I = p.some((P) => P !== 128 && P !== 0);
      return c.close(), !I;
    }
    return !1;
  });
}
function getNewAudioContext() {
  const a = (
    // @ts-ignore
    typeof window < "u" && (window.AudioContext || window.webkitAudioContext)
  );
  if (a)
    return new a({
      latencyHint: "interactive"
    });
}
function sourceToKind(a) {
  return a === Track.Source.Microphone ? "audioinput" : a === Track.Source.Camera ? "videoinput" : void 0;
}
function screenCaptureToDisplayMediaStreamOptions(a) {
  var u, c;
  let l = (u = a.video) !== null && u !== void 0 ? u : !0;
  return a.resolution && a.resolution.width > 0 && a.resolution.height > 0 && (l = typeof l == "boolean" ? {} : l, isSafari() ? l = Object.assign(Object.assign({}, l), {
    width: {
      max: a.resolution.width
    },
    height: {
      max: a.resolution.height
    },
    frameRate: a.resolution.frameRate
  }) : l = Object.assign(Object.assign({}, l), {
    width: {
      ideal: a.resolution.width
    },
    height: {
      ideal: a.resolution.height
    },
    frameRate: a.resolution.frameRate
  })), {
    audio: (c = a.audio) !== null && c !== void 0 ? c : !1,
    video: l,
    // @ts-expect-error support for experimental display media features
    controller: a.controller,
    selfBrowserSurface: a.selfBrowserSurface,
    surfaceSwitching: a.surfaceSwitching,
    systemAudio: a.systemAudio
  };
}
function mimeTypeToVideoCodecString(a) {
  const u = a.split("/")[1].toLowerCase();
  if (!videoCodecs.includes(u))
    throw Error("Video codec not supported: ".concat(u));
  return u;
}
function getTrackPublicationInfo(a) {
  const u = [];
  return a.forEach((c) => {
    c.track !== void 0 && u.push(new TrackPublishedResponse({
      cid: c.track.mediaStreamID,
      track: c.trackInfo
    }));
  }), u;
}
function getLogContextFromTrack(a) {
  return a instanceof Track ? {
    trackSid: a.sid,
    trackSource: a.source,
    trackMuted: a.isMuted,
    trackEnabled: a.mediaStreamTrack.enabled,
    trackKind: a.kind
  } : {
    trackSid: a.trackSid,
    trackName: a.trackName,
    track: a.track ? getLogContextFromTrack(a.track) : void 0,
    trackEnabled: a.isEnabled,
    trackEncrypted: a.isEncrypted,
    trackMimeType: a.mimeType
  };
}
const separator = "|", ddExtensionURI = "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";
function unpackStreamId(a) {
  const u = a.split(separator);
  return u.length > 1 ? [u[0], a.substr(u[0].length + 1)] : [a, ""];
}
function sleep(a) {
  return __awaiter$3(this, void 0, void 0, function* () {
    return new Promise((u) => CriticalTimers.setTimeout(u, a));
  });
}
function supportsTransceiver() {
  return "addTransceiver" in RTCPeerConnection.prototype;
}
function supportsAddTrack() {
  return "addTrack" in RTCPeerConnection.prototype;
}
function supportsAV1() {
  if (!("getCapabilities" in RTCRtpSender) || isSafari())
    return !1;
  const a = RTCRtpSender.getCapabilities("video");
  let u = !1;
  if (a) {
    for (const c of a.codecs)
      if (c.mimeType === "video/AV1") {
        u = !0;
        break;
      }
  }
  return u;
}
function supportsVP9() {
  if (!("getCapabilities" in RTCRtpSender) || isFireFox())
    return !1;
  if (isSafari()) {
    const c = getBrowser();
    if (c != null && c.version && compareVersions(c.version, "16") < 0)
      return !1;
  }
  const a = RTCRtpSender.getCapabilities("video");
  let u = !1;
  if (a) {
    for (const c of a.codecs)
      if (c.mimeType === "video/VP9") {
        u = !0;
        break;
      }
  }
  return u;
}
function isSVCCodec(a) {
  return a === "av1" || a === "vp9";
}
function supportsSetSinkId(a) {
  return document ? (a || (a = document.createElement("audio")), "setSinkId" in a) : !1;
}
const setCodecPreferencesVersions = {
  Chrome: "100",
  Safari: "15",
  Firefox: "100"
};
function supportsSetCodecPreferences(a) {
  if (!isWeb() || !("setCodecPreferences" in a))
    return !1;
  const u = getBrowser();
  if (!(u != null && u.name) || !u.version)
    return !1;
  const c = setCodecPreferencesVersions[u.name];
  return c ? compareVersions(u.version, c) >= 0 : !1;
}
function isFireFox() {
  var a;
  return ((a = getBrowser()) === null || a === void 0 ? void 0 : a.name) === "Firefox";
}
function isSafari() {
  var a;
  return ((a = getBrowser()) === null || a === void 0 ? void 0 : a.name) === "Safari";
}
function isSafari17() {
  const a = getBrowser();
  return (a == null ? void 0 : a.name) === "Safari" && a.version.startsWith("17.");
}
function isMobile() {
  return isWeb() ? /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent) : !1;
}
function isWeb() {
  return typeof document < "u";
}
function isReactNative() {
  return navigator.product == "ReactNative";
}
function isCloud(a) {
  return a.hostname.endsWith(".livekit.cloud") || a.hostname.endsWith(".livekit.run");
}
function getLKReactNativeInfo() {
  if (global$1 && global$1.LiveKitReactNativeGlobal)
    return global$1.LiveKitReactNativeGlobal;
}
function getReactNativeOs() {
  if (!isReactNative())
    return;
  let a = getLKReactNativeInfo();
  if (a)
    return a.platform;
}
function getDevicePixelRatio() {
  if (isWeb())
    return window.devicePixelRatio;
  if (isReactNative()) {
    let a = getLKReactNativeInfo();
    if (a)
      return a.devicePixelRatio;
  }
  return 1;
}
function compareVersions(a, u) {
  const c = a.split("."), l = u.split("."), v = Math.min(c.length, l.length);
  for (let p = 0; p < v; ++p) {
    const _ = parseInt(c[p], 10), I = parseInt(l[p], 10);
    if (_ > I)
      return 1;
    if (_ < I)
      return -1;
    if (p === v - 1 && _ === I)
      return 0;
  }
  return a === "" && u !== "" ? -1 : u === "" ? 1 : c.length == l.length ? 0 : c.length < l.length ? -1 : 1;
}
function roDispatchCallback(a) {
  for (const u of a)
    u.target.handleResize(u);
}
function ioDispatchCallback(a) {
  for (const u of a)
    u.target.handleVisibilityChanged(u);
}
let resizeObserver = null;
const getResizeObserver = () => (resizeObserver || (resizeObserver = new ResizeObserver(roDispatchCallback)), resizeObserver);
let intersectionObserver = null;
const getIntersectionObserver = () => (intersectionObserver || (intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
  root: null,
  rootMargin: "0px"
})), intersectionObserver);
function getClientInfo() {
  var a;
  const u = new ClientInfo({
    sdk: ClientInfo_SDK.JS,
    protocol: protocolVersion,
    version: version$3
  });
  return isReactNative() && (u.os = (a = getReactNativeOs()) !== null && a !== void 0 ? a : ""), u;
}
function createDummyVideoStreamTrack() {
  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16, c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  const v = document.createElement("canvas");
  v.width = a, v.height = u;
  const p = v.getContext("2d");
  p == null || p.fillRect(0, 0, v.width, v.height), l && p && (p.beginPath(), p.arc(a / 2, u / 2, 50, 0, Math.PI * 2, !0), p.closePath(), p.fillStyle = "grey", p.fill());
  const _ = v.captureStream(), [I] = _.getTracks();
  if (!I)
    throw Error("Could not get empty media stream video track");
  return I.enabled = c, I;
}
let emptyAudioStreamTrack;
function getEmptyAudioStreamTrack() {
  if (!emptyAudioStreamTrack) {
    const a = new AudioContext(), u = a.createOscillator(), c = a.createGain();
    c.gain.setValueAtTime(0, 0);
    const l = a.createMediaStreamDestination();
    if (u.connect(c), c.connect(l), u.start(), [emptyAudioStreamTrack] = l.stream.getAudioTracks(), !emptyAudioStreamTrack)
      throw Error("Could not get empty media stream audio track");
    emptyAudioStreamTrack.enabled = !1;
  }
  return emptyAudioStreamTrack.clone();
}
class Future {
  constructor(u, c) {
    this.onFinally = c, this.promise = new Promise((l, v) => __awaiter$3(this, void 0, void 0, function* () {
      this.resolve = l, this.reject = v, u && (yield u(l, v));
    })).finally(() => {
      var l;
      return (l = this.onFinally) === null || l === void 0 ? void 0 : l.call(this);
    });
  }
}
class Mutex {
  constructor() {
    this._locking = Promise.resolve(), this._locks = 0;
  }
  isLocked() {
    return this._locks > 0;
  }
  lock() {
    this._locks += 1;
    let u;
    const c = new Promise((v) => u = () => {
      this._locks -= 1, v();
    }), l = this._locking.then(() => u);
    return this._locking = this._locking.then(() => c), l;
  }
}
function isVideoCodec(a) {
  return videoCodecs.includes(a);
}
function unwrapConstraint(a) {
  if (typeof a == "string")
    return a;
  if (Array.isArray(a))
    return a[0];
  if (a.exact)
    return Array.isArray(a.exact) ? a.exact[0] : a.exact;
  if (a.ideal)
    return Array.isArray(a.ideal) ? a.ideal[0] : a.ideal;
  throw Error("could not unwrap constraint");
}
function toWebsocketUrl(a) {
  return a.startsWith("http") ? a.replace(/^(http)/, "ws") : a;
}
function toHttpUrl(a) {
  return a.startsWith("ws") ? a.replace(/^(ws)/, "http") : a;
}
const defaultId = "default";
class DeviceManager {
  static getInstance() {
    return this.instance === void 0 && (this.instance = new DeviceManager()), this.instance;
  }
  getDevices(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    var l;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (((l = DeviceManager.userMediaPromiseMap) === null || l === void 0 ? void 0 : l.size) > 0) {
        livekitLogger.debug("awaiting getUserMedia promise");
        try {
          u ? yield DeviceManager.userMediaPromiseMap.get(u) : yield Promise.all(DeviceManager.userMediaPromiseMap.values());
        } catch {
          livekitLogger.warn("error waiting for media permissons");
        }
      }
      let v = yield navigator.mediaDevices.enumerateDevices();
      if (c && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363
      !(isSafari() && this.hasDeviceInUse(u)) && (v.length === 0 || v.some((_) => {
        const I = _.label === "", P = u ? _.kind === u : !0;
        return I && P;
      }))) {
        const _ = {
          video: u !== "audioinput" && u !== "audiooutput",
          audio: u !== "videoinput"
        }, I = yield navigator.mediaDevices.getUserMedia(_);
        v = yield navigator.mediaDevices.enumerateDevices(), I.getTracks().forEach((P) => {
          P.stop();
        });
      }
      return u && (v = v.filter((p) => p.kind === u)), v;
    });
  }
  normalizeDeviceId(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (c !== defaultId)
        return c;
      const p = (yield this.getDevices(u)).find((_) => _.groupId === l && _.deviceId !== defaultId);
      return p == null ? void 0 : p.deviceId;
    });
  }
  hasDeviceInUse(u) {
    return u ? DeviceManager.userMediaPromiseMap.has(u) : DeviceManager.userMediaPromiseMap.size > 0;
  }
}
DeviceManager.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
DeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();
const defaultDimensionsTimeout = 1e3;
class LocalTrack extends Track {
  get constraints() {
    return this._constraints;
  }
  /**
   *
   * @param mediaTrack
   * @param kind
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c, l) {
    let v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, p = arguments.length > 4 ? arguments[4] : void 0;
    super(u, c, p), this._isUpstreamPaused = !1, this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug("track mute bounce got cancelled by an unmute event", this.logContext)), this.debouncedTrackMuteHandler = r$1(() => __awaiter$3(this, void 0, void 0, function* () {
      yield this.pauseUpstream();
    }), 5e3), this.handleTrackUnmuteEvent = () => __awaiter$3(this, void 0, void 0, function* () {
      this.debouncedTrackMuteHandler.cancel("unmute"), yield this.resumeUpstream();
    }), this.handleEnded = () => {
      this.isInBackground && (this.reacquireTrack = !0), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent), this.emit(TrackEvent.Ended, this);
    }, this.reacquireTrack = !1, this.providedByUser = v, this.muteLock = new Mutex(), this.pauseUpstreamLock = new Mutex(), this.processorLock = new Mutex(), this.setMediaStreamTrack(u, !0), this._constraints = u.getConstraints(), l && (this._constraints = l);
  }
  get id() {
    return this._mediaStreamTrack.id;
  }
  get dimensions() {
    if (this.kind !== Track.Kind.Video)
      return;
    const {
      width: u,
      height: c
    } = this._mediaStreamTrack.getSettings();
    if (u && c)
      return {
        width: u,
        height: c
      };
  }
  get isUpstreamPaused() {
    return this._isUpstreamPaused;
  }
  get isUserProvided() {
    return this.providedByUser;
  }
  get mediaStreamTrack() {
    var u, c;
    return (c = (u = this.processor) === null || u === void 0 ? void 0 : u.processedTrack) !== null && c !== void 0 ? c : this._mediaStreamTrack;
  }
  setMediaStreamTrack(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (u === this._mediaStreamTrack && !c)
        return;
      this._mediaStreamTrack && (this.attachedElements.forEach((v) => {
        detachTrack(this._mediaStreamTrack, v);
      }), this.debouncedTrackMuteHandler.cancel("new-track"), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent)), this.mediaStream = new MediaStream([u]), u && (u.addEventListener("ended", this.handleEnded), u.addEventListener("mute", this.handleTrackMuteEvent), u.addEventListener("unmute", this.handleTrackUnmuteEvent), this._constraints = u.getConstraints());
      let l;
      if (this.processor && u && this.processorElement) {
        if (this.log.debug("restarting processor", this.logContext), this.kind === "unknown")
          throw TypeError("cannot set processor on track of unknown kind");
        attachToElement(u, this.processorElement), this.processorElement.muted = !0, yield this.processor.restart({
          track: u,
          kind: this.kind,
          element: this.processorElement
        }), l = this.processor.processedTrack;
      }
      this.sender && (yield this.sender.replaceTrack(l ?? u)), !this.providedByUser && this._mediaStreamTrack !== u && this._mediaStreamTrack.stop(), this._mediaStreamTrack = u, u && (this._mediaStreamTrack.enabled = !this.isMuted, yield this.resumeUpstream(), this.attachedElements.forEach((v) => {
        attachToElement(l ?? u, v);
      }));
    });
  }
  waitForDimensions() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDimensionsTimeout;
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.kind === Track.Kind.Audio)
        throw new Error("cannot get dimensions for audio tracks");
      ((c = getBrowser()) === null || c === void 0 ? void 0 : c.os) === "iOS" && (yield sleep(10));
      const l = Date.now();
      for (; Date.now() - l < u; ) {
        const v = this.dimensions;
        if (v)
          return v;
        yield sleep(50);
      }
      throw new TrackInvalidError("unable to get track dimensions after timeout");
    });
  }
  /**
   * @returns DeviceID of the device that is currently being used for this track
   */
  getDeviceId() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.source === Track.Source.ScreenShare)
        return;
      const {
        deviceId: u,
        groupId: c
      } = this._mediaStreamTrack.getSettings(), l = this.kind === Track.Kind.Audio ? "audioinput" : "videoinput";
      return DeviceManager.getInstance().normalizeDeviceId(l, u, c);
    });
  }
  mute() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.setTrackMuted(!0), this;
    });
  }
  unmute() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.setTrackMuted(!1), this;
    });
  }
  replaceTrack(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.sender)
        throw new TrackInvalidError("unable to replace an unpublished track");
      return this.log.debug("replace MediaStreamTrack", this.logContext), yield this.setMediaStreamTrack(u), this.providedByUser = c, this.processor && (yield this.stopProcessor()), this;
    });
  }
  restart(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      u || (u = this._constraints), this.log.debug("restarting track with constraints", Object.assign(Object.assign({}, this.logContext), {
        constraints: u
      }));
      const c = {
        audio: !1,
        video: !1
      };
      this.kind === Track.Kind.Video ? c.video = u : c.audio = u, this.attachedElements.forEach((p) => {
        detachTrack(this.mediaStreamTrack, p);
      }), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.stop();
      const v = (yield navigator.mediaDevices.getUserMedia(c)).getTracks()[0];
      return v.addEventListener("ended", this.handleEnded), this.log.debug("re-acquired MediaStreamTrack", this.logContext), yield this.setMediaStreamTrack(v), this._constraints = u, this.emit(TrackEvent.Restarted, this), this;
    });
  }
  setTrackMuted(u) {
    this.log.debug("setting ".concat(this.kind, " track ").concat(u ? "muted" : "unmuted"), this.logContext), !(this.isMuted === u && this._mediaStreamTrack.enabled !== u) && (this.isMuted = u, this._mediaStreamTrack.enabled = !u, this.emit(u ? TrackEvent.Muted : TrackEvent.Unmuted, this));
  }
  get needsReAcquisition() {
    return this._mediaStreamTrack.readyState !== "live" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), isMobile() && (this.log.debug("visibility changed, is in Background: ".concat(this.isInBackground), this.logContext), !this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted && (this.log.debug("track needs to be reacquired, restarting ".concat(this.source), this.logContext), yield this.restart(), this.reacquireTrack = !1));
    });
  }
  stop() {
    var u;
    super.stop(), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent), (u = this.processor) === null || u === void 0 || u.destroy(), this.processor = void 0;
  }
  /**
   * pauses publishing to the server without disabling the local MediaStreamTrack
   * this is used to display a user's own video locally while pausing publishing to
   * the server.
   * this API is unsupported on Safari < 12 due to a bug
   **/
  pauseUpstream() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !0)
          return;
        if (!this.sender) {
          this.log.warn("unable to pause upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = !0, this.emit(TrackEvent.UpstreamPaused, this);
        const c = getBrowser();
        if ((c == null ? void 0 : c.name) === "Safari" && compareVersions(c.version, "12.0") < 0)
          throw new DeviceUnsupportedError("pauseUpstream is not supported on Safari < 12.");
        yield this.sender.replaceTrack(null);
      } finally {
        u();
      }
    });
  }
  resumeUpstream() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !1)
          return;
        if (!this.sender) {
          this.log.warn("unable to resume upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = !1, this.emit(TrackEvent.UpstreamResumed, this), yield this.sender.replaceTrack(this._mediaStreamTrack);
      } finally {
        u();
      }
    });
  }
  /**
   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return !((u = this.sender) === null || u === void 0) && u.getStats ? yield this.sender.getStats() : void 0;
    });
  }
  /**
   * Sets a processor on this track.
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   *
   * @param processor
   * @param showProcessedStreamLocally
   * @returns
   */
  setProcessor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    var l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      const p = yield this.processorLock.lock();
      try {
        if (this.log.debug("setting up processor", this.logContext), this.processor && (yield this.stopProcessor()), this.kind === "unknown")
          throw TypeError("cannot set processor on track of unknown kind");
        this.processorElement = (l = this.processorElement) !== null && l !== void 0 ? l : document.createElement(this.kind), attachToElement(this._mediaStreamTrack, this.processorElement), this.processorElement.muted = !0, this.processorElement.play().catch((I) => this.log.error("failed to play processor element", Object.assign(Object.assign({}, this.logContext), {
          error: I
        })));
        const _ = {
          kind: this.kind,
          track: this._mediaStreamTrack,
          element: this.processorElement
        };
        if (yield u.init(_), this.processor = u, this.processor.processedTrack) {
          for (const I of this.attachedElements)
            I !== this.processorElement && c && (detachTrack(this._mediaStreamTrack, I), attachToElement(this.processor.processedTrack, I));
          yield (v = this.sender) === null || v === void 0 ? void 0 : v.replaceTrack(this.processor.processedTrack);
        }
      } finally {
        p();
      }
    });
  }
  getProcessor() {
    return this.processor;
  }
  /**
   * Stops the track processor
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   * @returns
   */
  stopProcessor() {
    var u, c;
    return __awaiter$3(this, void 0, void 0, function* () {
      this.processor && (this.log.debug("stopping processor", this.logContext), (u = this.processor.processedTrack) === null || u === void 0 || u.stop(), yield this.processor.destroy(), this.processor = void 0, (c = this.processorElement) === null || c === void 0 || c.remove(), this.processorElement = void 0, yield this.restart());
    });
  }
}
class E2EEManager extends eventsExports$1.EventEmitter {
  constructor(u) {
    super(), this.onWorkerMessage = (c) => {
      var l, v;
      const {
        kind: p,
        data: _
      } = c.data;
      switch (p) {
        case "error":
          livekitLogger.error(_.error.message), this.emit(EncryptionEvent.EncryptionError, _.error);
          break;
        case "initAck":
          _.enabled && this.keyProvider.getKeys().forEach((I) => {
            this.postKey(I);
          });
          break;
        case "enable":
          if (this.encryptionEnabled !== _.enabled && _.participantIdentity === ((l = this.room) === null || l === void 0 ? void 0 : l.localParticipant.identity))
            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, _.enabled, this.room.localParticipant), this.encryptionEnabled = _.enabled;
          else if (_.participantIdentity) {
            const I = (v = this.room) === null || v === void 0 ? void 0 : v.getParticipantByIdentity(_.participantIdentity);
            if (!I)
              throw TypeError("couldn't set encryption status, participant not found".concat(_.participantIdentity));
            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, _.enabled, I);
          }
          this.encryptionEnabled && this.keyProvider.getKeys().forEach((I) => {
            this.postKey(I);
          });
          break;
        case "ratchetKey":
          this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, _.material, _.keyIndex);
          break;
      }
    }, this.onWorkerError = (c) => {
      livekitLogger.error("e2ee worker encountered an error:", {
        error: c.error
      }), this.emit(EncryptionEvent.EncryptionError, c.error);
    }, this.keyProvider = u.keyProvider, this.worker = u.worker, this.encryptionEnabled = !1;
  }
  /**
   * @internal
   */
  setup(u) {
    if (!isE2EESupported())
      throw new DeviceUnsupportedError("tried to setup end-to-end encryption on an unsupported browser");
    if (livekitLogger.info("setting up e2ee"), u !== this.room) {
      this.room = u, this.setupEventListeners(u, this.keyProvider);
      const c = {
        kind: "init",
        data: {
          keyProviderOptions: this.keyProvider.getOptions()
        }
      };
      this.worker && (livekitLogger.info("initializing worker", {
        worker: this.worker
      }), this.worker.onmessage = this.onWorkerMessage, this.worker.onerror = this.onWorkerError, this.worker.postMessage(c));
    }
  }
  /**
   * @internal
   */
  setParticipantCryptorEnabled(u, c) {
    livekitLogger.debug("set e2ee to ".concat(u, " for participant ").concat(c)), this.postEnable(u, c);
  }
  /**
   * @internal
   */
  setSifTrailer(u) {
    !u || u.length === 0 ? livekitLogger.warn("ignoring server sent trailer as it's empty") : this.postSifTrailer(u);
  }
  setupEngine(u) {
    u.on(EngineEvent.RTPVideoMapUpdate, (c) => {
      this.postRTPMap(c);
    });
  }
  setupEventListeners(u, c) {
    u.on(RoomEvent.TrackPublished, (l, v) => this.setParticipantCryptorEnabled(l.trackInfo.encryption !== Encryption_Type.NONE, v.identity)), u.on(RoomEvent.ConnectionStateChanged, (l) => {
      l === ConnectionState.Connected && u.remoteParticipants.forEach((v) => {
        v.trackPublications.forEach((p) => {
          this.setParticipantCryptorEnabled(p.trackInfo.encryption !== Encryption_Type.NONE, v.identity);
        });
      });
    }).on(RoomEvent.TrackUnsubscribed, (l, v, p) => {
      var _;
      const I = {
        kind: "removeTransform",
        data: {
          participantIdentity: p.identity,
          trackId: l.mediaStreamID
        }
      };
      (_ = this.worker) === null || _ === void 0 || _.postMessage(I);
    }).on(RoomEvent.TrackSubscribed, (l, v, p) => {
      this.setupE2EEReceiver(l, p.identity, v.trackInfo);
    }).on(RoomEvent.SignalConnected, () => {
      if (!this.room)
        throw new TypeError("expected room to be present on signal connect");
      this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity), c.getKeys().forEach((l) => {
        this.postKey(l);
      });
    }), u.localParticipant.on(ParticipantEvent.LocalTrackPublished, (l) => __awaiter$3(this, void 0, void 0, function* () {
      this.setupE2EESender(l.track, l.track.sender);
    })), c.on(KeyProviderEvent.SetKey, (l) => this.postKey(l)).on(KeyProviderEvent.RatchetRequest, (l, v) => this.postRatchetRequest(l, v));
  }
  postRatchetRequest(u, c) {
    if (!this.worker)
      throw Error("could not ratchet key, worker is missing");
    const l = {
      kind: "ratchetRequest",
      data: {
        participantIdentity: u,
        keyIndex: c
      }
    };
    this.worker.postMessage(l);
  }
  postKey(u) {
    let {
      key: c,
      participantIdentity: l,
      keyIndex: v
    } = u;
    var p;
    if (!this.worker)
      throw Error("could not set key, worker is missing");
    const _ = {
      kind: "setKey",
      data: {
        participantIdentity: l,
        isPublisher: l === ((p = this.room) === null || p === void 0 ? void 0 : p.localParticipant.identity),
        key: c,
        keyIndex: v
      }
    };
    this.worker.postMessage(_);
  }
  postEnable(u, c) {
    if (this.worker) {
      const l = {
        kind: "enable",
        data: {
          enabled: u,
          participantIdentity: c
        }
      };
      this.worker.postMessage(l);
    } else
      throw new ReferenceError("failed to enable e2ee, worker is not ready");
  }
  postRTPMap(u) {
    var c;
    if (!this.worker)
      throw TypeError("could not post rtp map, worker is missing");
    if (!(!((c = this.room) === null || c === void 0) && c.localParticipant.identity))
      throw TypeError("could not post rtp map, local participant identity is missing");
    const l = {
      kind: "setRTPMap",
      data: {
        map: u,
        participantIdentity: this.room.localParticipant.identity
      }
    };
    this.worker.postMessage(l);
  }
  postSifTrailer(u) {
    if (!this.worker)
      throw Error("could not post SIF trailer, worker is missing");
    const c = {
      kind: "setSifTrailer",
      data: {
        trailer: u
      }
    };
    this.worker.postMessage(c);
  }
  setupE2EEReceiver(u, c, l) {
    if (u.receiver) {
      if (!(l != null && l.mimeType) || l.mimeType === "")
        throw new TypeError("MimeType missing from trackInfo, cannot set up E2EE cryptor");
      this.handleReceiver(u.receiver, u.mediaStreamID, c, u.kind === "video" ? mimeTypeToVideoCodecString(l.mimeType) : void 0);
    }
  }
  setupE2EESender(u, c) {
    if (!(u instanceof LocalTrack) || !c) {
      c || livekitLogger.warn("early return because sender is not ready");
      return;
    }
    this.handleSender(c, u.mediaStreamID, void 0);
  }
  /**
   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
   * a frame decoder.
   *
   */
  handleReceiver(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.worker) {
        if (isScriptTransformSupported()) {
          const p = {
            kind: "decode",
            participantIdentity: l,
            trackId: c,
            codec: v
          };
          u.transform = new RTCRtpScriptTransform(this.worker, p);
        } else {
          if (E2EE_FLAG in u && v) {
            const P = {
              kind: "updateCodec",
              data: {
                trackId: c,
                codec: v,
                participantIdentity: l
              }
            };
            this.worker.postMessage(P);
            return;
          }
          let p = u.writableStream, _ = u.readableStream;
          if (!p || !_) {
            const P = u.createEncodedStreams();
            u.writableStream = P.writable, p = P.writable, u.readableStream = P.readable, _ = P.readable;
          }
          const I = {
            kind: "decode",
            data: {
              readableStream: _,
              writableStream: p,
              trackId: c,
              codec: v,
              participantIdentity: l
            }
          };
          this.worker.postMessage(I, [_, p]);
        }
        u[E2EE_FLAG] = !0;
      }
    });
  }
  /**
   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject
   * a frame encoder.
   *
   */
  handleSender(u, c, l) {
    var v;
    if (!(E2EE_FLAG in u || !this.worker)) {
      if (!(!((v = this.room) === null || v === void 0) && v.localParticipant.identity) || this.room.localParticipant.identity === "")
        throw TypeError("local identity needs to be known in order to set up encrypted sender");
      if (isScriptTransformSupported()) {
        livekitLogger.info("initialize script transform");
        const p = {
          kind: "encode",
          participantIdentity: this.room.localParticipant.identity,
          trackId: c,
          codec: l
        };
        u.transform = new RTCRtpScriptTransform(this.worker, p);
      } else {
        livekitLogger.info("initialize encoded streams");
        const p = u.createEncodedStreams(), _ = {
          kind: "encode",
          data: {
            readableStream: p.readable,
            writableStream: p.writable,
            codec: l,
            trackId: c,
            participantIdentity: this.room.localParticipant.identity
          }
        };
        this.worker.postMessage(_, [p.readable, p.writable]);
      }
      u[E2EE_FLAG] = !0;
    }
  }
}
var QueueTaskStatus;
(function(a) {
  a[a.WAITING = 0] = "WAITING", a[a.RUNNING = 1] = "RUNNING", a[a.COMPLETED = 2] = "COMPLETED";
})(QueueTaskStatus || (QueueTaskStatus = {}));
class AsyncQueue {
  constructor() {
    this.pendingTasks = /* @__PURE__ */ new Map(), this.taskMutex = new Mutex(), this.nextTaskIndex = 0;
  }
  run(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = {
        id: this.nextTaskIndex++,
        enqueuedAt: Date.now(),
        status: QueueTaskStatus.WAITING
      };
      this.pendingTasks.set(c.id, c);
      const l = yield this.taskMutex.lock();
      try {
        return c.executedAt = Date.now(), c.status = QueueTaskStatus.RUNNING, yield u();
      } finally {
        c.status = QueueTaskStatus.COMPLETED, this.pendingTasks.delete(c.id), l();
      }
    });
  }
  flush() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.run(() => __awaiter$3(this, void 0, void 0, function* () {
      }));
    });
  }
  snapshot() {
    return Array.from(this.pendingTasks.values());
  }
}
const passThroughQueueSignals = ["syncState", "trickle", "offer", "answer", "simulate", "leave"];
function canPassThroughQueue(a) {
  const u = passThroughQueueSignals.indexOf(a.case) >= 0;
  return livekitLogger.trace("request allowed to bypass queue:", {
    canPass: u,
    req: a
  }), u;
}
var SignalConnectionState;
(function(a) {
  a[a.CONNECTING = 0] = "CONNECTING", a[a.CONNECTED = 1] = "CONNECTED", a[a.RECONNECTING = 2] = "RECONNECTING", a[a.DISCONNECTING = 3] = "DISCONNECTING", a[a.DISCONNECTED = 4] = "DISCONNECTED";
})(SignalConnectionState || (SignalConnectionState = {}));
class SignalClient {
  get currentState() {
    return this.state;
  }
  get isDisconnected() {
    return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;
  }
  get isEstablishingConnection() {
    return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;
  }
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var l;
    this.rtt = 0, this.state = SignalConnectionState.DISCONNECTED, this.log = livekitLogger, this.resetCallbacks = () => {
      this.onAnswer = void 0, this.onLeave = void 0, this.onLocalTrackPublished = void 0, this.onLocalTrackUnpublished = void 0, this.onNegotiateRequested = void 0, this.onOffer = void 0, this.onRemoteMuteChanged = void 0, this.onSubscribedQualityUpdate = void 0, this.onTokenRefresh = void 0, this.onTrickle = void 0, this.onClose = void 0;
    }, this.log = getLogger((l = c.loggerName) !== null && l !== void 0 ? l : LoggerNames.Signal), this.loggerContextCb = c.loggerContextCb, this.useJSON = u, this.requestQueue = new AsyncQueue(), this.queuedRequests = [], this.closingLock = new Mutex(), this.connectionLock = new Mutex(), this.state = SignalConnectionState.DISCONNECTED;
  }
  get logContext() {
    var u, c;
    return (c = (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)) !== null && c !== void 0 ? c : {};
  }
  join(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.state = SignalConnectionState.CONNECTING, this.options = l, yield this.connect(u, c, l, v);
    });
  }
  reconnect(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.options) {
        this.log.warn("attempted to reconnect without signal options being set, ignoring", this.logContext);
        return;
      }
      return this.state = SignalConnectionState.RECONNECTING, this.clearPingInterval(), yield this.connect(u, c, Object.assign(Object.assign({}, this.options), {
        reconnect: !0,
        sid: l,
        reconnectReason: v
      }));
    });
  }
  connect(u, c, l, v) {
    this.connectOptions = l, u = toWebsocketUrl(u), u = u.replace(/\/$/, ""), u += "/rtc";
    const p = getClientInfo(), _ = createConnectionParams(c, p, l);
    return new Promise((I, P) => __awaiter$3(this, void 0, void 0, function* () {
      const $ = yield this.connectionLock.lock();
      try {
        const F = () => __awaiter$3(this, void 0, void 0, function* () {
          this.close(), clearTimeout(H), P(new ConnectionError("room connection has been cancelled (signal)"));
        }), H = setTimeout(() => {
          this.close(), P(new ConnectionError("room connection has timed out (signal)"));
        }, l.websocketTimeout);
        v != null && v.aborted && F(), v == null || v.addEventListener("abort", F), this.log.debug("connecting to ".concat(u + _), this.logContext), this.ws && (yield this.close(!1)), this.ws = new WebSocket(u + _), this.ws.binaryType = "arraybuffer", this.ws.onopen = () => {
          clearTimeout(H);
        }, this.ws.onerror = (j) => __awaiter$3(this, void 0, void 0, function* () {
          if (this.state !== SignalConnectionState.CONNECTED) {
            clearTimeout(H);
            try {
              const ee = yield fetch("http".concat(u.substring(2), "/validate").concat(_));
              if (ee.status.toFixed(0).startsWith("4")) {
                const X = yield ee.text();
                P(new ConnectionError(X, 0, ee.status));
              } else
                P(new ConnectionError("Internal error", 2, ee.status));
            } catch {
              P(new ConnectionError(
                "server was not reachable",
                1
                /* ConnectionErrorReason.ServerUnreachable */
              ));
            }
            return;
          }
          this.handleWSError(j);
        }), this.ws.onmessage = (j) => __awaiter$3(this, void 0, void 0, function* () {
          var ee, X, ie, Q;
          let ne;
          if (typeof j.data == "string") {
            const Z = JSON.parse(j.data);
            ne = SignalResponse.fromJson(Z);
          } else if (j.data instanceof ArrayBuffer)
            ne = SignalResponse.fromBinary(new Uint8Array(j.data));
          else {
            this.log.error("could not decode websocket message: ".concat(typeof j.data), this.logContext);
            return;
          }
          if (this.state !== SignalConnectionState.CONNECTED) {
            let Z = !1;
            if (((ee = ne.message) === null || ee === void 0 ? void 0 : ee.case) === "join" ? (this.state = SignalConnectionState.CONNECTED, v == null || v.removeEventListener("abort", F), this.pingTimeoutDuration = ne.message.value.pingTimeout, this.pingIntervalDuration = ne.message.value.pingInterval, this.pingTimeoutDuration && this.pingTimeoutDuration > 0 && (this.log.debug("ping config", Object.assign(Object.assign({}, this.logContext), {
              timeout: this.pingTimeoutDuration,
              interval: this.pingIntervalDuration
            })), this.startPingInterval()), I(ne.message.value)) : this.state === SignalConnectionState.RECONNECTING && ne.message.case !== "leave" ? (this.state = SignalConnectionState.CONNECTED, v == null || v.removeEventListener("abort", F), this.startPingInterval(), ((X = ne.message) === null || X === void 0 ? void 0 : X.case) === "reconnect" ? I((ie = ne.message) === null || ie === void 0 ? void 0 : ie.value) : (I(), Z = !0)) : this.isEstablishingConnection && ne.message.case === "leave" ? P(new ConnectionError(
              "Received leave request while trying to (re)connect",
              4
              /* ConnectionErrorReason.LeaveRequest */
            )) : l.reconnect || P(new ConnectionError("did not receive join response, got ".concat((Q = ne.message) === null || Q === void 0 ? void 0 : Q.case, " instead"))), !Z)
              return;
          }
          this.signalLatency && (yield sleep(this.signalLatency)), this.handleSignalResponse(ne);
        }), this.ws.onclose = (j) => {
          this.isEstablishingConnection && P(new ConnectionError("Websocket got closed during a (re)connection attempt")), this.log.warn("websocket closed", Object.assign(Object.assign({}, this.logContext), {
            reason: j.reason,
            code: j.code,
            wasClean: j.wasClean,
            state: this.state
          })), this.handleOnClose(j.reason);
        };
      } finally {
        $();
      }
    }));
  }
  close() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.closingLock.lock();
      try {
        if (u && (this.state = SignalConnectionState.DISCONNECTING), this.ws) {
          this.ws.onmessage = null, this.ws.onopen = null, this.ws.onclose = null;
          const l = new Promise((v) => {
            this.ws ? this.ws.onclose = () => {
              v();
            } : v();
          });
          this.ws.readyState < this.ws.CLOSING && (this.ws.close(), yield Promise.race([l, sleep(250)])), this.ws = void 0;
        }
      } finally {
        u && (this.state = SignalConnectionState.DISCONNECTED), this.clearPingInterval(), c();
      }
    });
  }
  // initial offer after joining
  sendOffer(u) {
    this.log.debug("sending offer", Object.assign(Object.assign({}, this.logContext), {
      offerSdp: u.sdp
    })), this.sendRequest({
      case: "offer",
      value: toProtoSessionDescription(u)
    });
  }
  // answer a server-initiated offer
  sendAnswer(u) {
    return this.log.debug("sending answer", Object.assign(Object.assign({}, this.logContext), {
      answerSdp: u.sdp
    })), this.sendRequest({
      case: "answer",
      value: toProtoSessionDescription(u)
    });
  }
  sendIceCandidate(u, c) {
    return this.log.trace("sending ice candidate", Object.assign(Object.assign({}, this.logContext), {
      candidate: u
    })), this.sendRequest({
      case: "trickle",
      value: new TrickleRequest({
        candidateInit: JSON.stringify(u),
        target: c
      })
    });
  }
  sendMuteTrack(u, c) {
    return this.sendRequest({
      case: "mute",
      value: new MuteTrackRequest({
        sid: u,
        muted: c
      })
    });
  }
  sendAddTrack(u) {
    return this.sendRequest({
      case: "addTrack",
      value: u
    });
  }
  sendUpdateLocalMetadata(u, c) {
    return this.sendRequest({
      case: "updateMetadata",
      value: new UpdateParticipantMetadata({
        metadata: u,
        name: c
      })
    });
  }
  sendUpdateTrackSettings(u) {
    this.sendRequest({
      case: "trackSetting",
      value: u
    });
  }
  sendUpdateSubscription(u) {
    return this.sendRequest({
      case: "subscription",
      value: u
    });
  }
  sendSyncState(u) {
    return this.sendRequest({
      case: "syncState",
      value: u
    });
  }
  sendUpdateVideoLayers(u, c) {
    return this.sendRequest({
      case: "updateLayers",
      value: new UpdateVideoLayers({
        trackSid: u,
        layers: c
      })
    });
  }
  sendUpdateSubscriptionPermissions(u, c) {
    return this.sendRequest({
      case: "subscriptionPermission",
      value: new SubscriptionPermission({
        allParticipants: u,
        trackPermissions: c
      })
    });
  }
  sendSimulateScenario(u) {
    return this.sendRequest({
      case: "simulate",
      value: u
    });
  }
  sendPing() {
    return Promise.all([this.sendRequest({
      case: "ping",
      value: protoInt64.parse(Date.now())
    }), this.sendRequest({
      case: "pingReq",
      value: new Ping({
        timestamp: protoInt64.parse(Date.now()),
        rtt: protoInt64.parse(this.rtt)
      })
    })]);
  }
  sendLeave() {
    return this.sendRequest({
      case: "leave",
      value: new LeaveRequest({
        canReconnect: !1,
        reason: DisconnectReason.CLIENT_INITIATED
      })
    });
  }
  sendRequest(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!c && !canPassThroughQueue(u) && this.state === SignalConnectionState.RECONNECTING) {
        this.queuedRequests.push(() => __awaiter$3(this, void 0, void 0, function* () {
          yield this.sendRequest(u, !0);
        }));
        return;
      }
      if (c || (yield this.requestQueue.flush()), this.signalLatency && (yield sleep(this.signalLatency)), !this.ws || this.ws.readyState !== this.ws.OPEN) {
        this.log.error("cannot send signal request before connected, type: ".concat(u == null ? void 0 : u.case), this.logContext);
        return;
      }
      const v = new SignalRequest({
        message: u
      });
      try {
        this.useJSON ? this.ws.send(v.toJsonString()) : this.ws.send(v.toBinary());
      } catch (p) {
        this.log.error("error sending signal message", Object.assign(Object.assign({}, this.logContext), {
          error: p
        }));
      }
    });
  }
  handleSignalResponse(u) {
    var c, l;
    const v = u.message;
    if (v == null) {
      this.log.debug("received unsupported message", this.logContext);
      return;
    }
    let p = !1;
    if (v.case === "answer") {
      const _ = fromProtoSessionDescription(v.value);
      this.onAnswer && this.onAnswer(_);
    } else if (v.case === "offer") {
      const _ = fromProtoSessionDescription(v.value);
      this.onOffer && this.onOffer(_);
    } else if (v.case === "trickle") {
      const _ = JSON.parse(v.value.candidateInit);
      this.onTrickle && this.onTrickle(_, v.value.target);
    } else
      v.case === "update" ? this.onParticipantUpdate && this.onParticipantUpdate((c = v.value.participants) !== null && c !== void 0 ? c : []) : v.case === "trackPublished" ? this.onLocalTrackPublished && this.onLocalTrackPublished(v.value) : v.case === "speakersChanged" ? this.onSpeakersChanged && this.onSpeakersChanged((l = v.value.speakers) !== null && l !== void 0 ? l : []) : v.case === "leave" ? this.onLeave && this.onLeave(v.value) : v.case === "mute" ? this.onRemoteMuteChanged && this.onRemoteMuteChanged(v.value.sid, v.value.muted) : v.case === "roomUpdate" ? this.onRoomUpdate && v.value.room && this.onRoomUpdate(v.value.room) : v.case === "connectionQuality" ? this.onConnectionQuality && this.onConnectionQuality(v.value) : v.case === "streamStateUpdate" ? this.onStreamStateUpdate && this.onStreamStateUpdate(v.value) : v.case === "subscribedQualityUpdate" ? this.onSubscribedQualityUpdate && this.onSubscribedQualityUpdate(v.value) : v.case === "subscriptionPermissionUpdate" ? this.onSubscriptionPermissionUpdate && this.onSubscriptionPermissionUpdate(v.value) : v.case === "refreshToken" ? this.onTokenRefresh && this.onTokenRefresh(v.value) : v.case === "trackUnpublished" ? this.onLocalTrackUnpublished && this.onLocalTrackUnpublished(v.value) : v.case === "subscriptionResponse" ? this.onSubscriptionError && this.onSubscriptionError(v.value) : v.case === "pong" || (v.case === "pongResp" ? (this.rtt = Date.now() - Number.parseInt(v.value.lastPingTimestamp.toString()), this.resetPingTimeout(), p = !0) : this.log.debug("unsupported message", Object.assign(Object.assign({}, this.logContext), {
        msgCase: v.case
      })));
    p || this.resetPingTimeout();
  }
  setReconnected() {
    for (; this.queuedRequests.length > 0; ) {
      const u = this.queuedRequests.shift();
      u && this.requestQueue.run(u);
    }
  }
  handleOnClose(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.state === SignalConnectionState.DISCONNECTED)
        return;
      const c = this.onClose;
      yield this.close(), this.log.debug("websocket connection closed: ".concat(u), Object.assign(Object.assign({}, this.logContext), {
        reason: u
      })), c && c(u);
    });
  }
  handleWSError(u) {
    this.log.error("websocket error", Object.assign(Object.assign({}, this.logContext), {
      error: u
    }));
  }
  /**
   * Resets the ping timeout and starts a new timeout.
   * Call this after receiving a pong message
   */
  resetPingTimeout() {
    if (this.clearPingTimeout(), !this.pingTimeoutDuration) {
      this.log.warn("ping timeout duration not set", this.logContext);
      return;
    }
    this.pingTimeout = CriticalTimers.setTimeout(() => {
      this.log.warn("ping timeout triggered. last pong received at: ".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()), this.logContext), this.handleOnClose("ping timeout");
    }, this.pingTimeoutDuration * 1e3);
  }
  /**
   * Clears ping timeout (does not start a new timeout)
   */
  clearPingTimeout() {
    this.pingTimeout && CriticalTimers.clearTimeout(this.pingTimeout);
  }
  startPingInterval() {
    if (this.clearPingInterval(), this.resetPingTimeout(), !this.pingIntervalDuration) {
      this.log.warn("ping interval duration not set", this.logContext);
      return;
    }
    this.log.debug("start ping interval", this.logContext), this.pingInterval = CriticalTimers.setInterval(() => {
      this.sendPing();
    }, this.pingIntervalDuration * 1e3);
  }
  clearPingInterval() {
    this.log.debug("clearing ping interval", this.logContext), this.clearPingTimeout(), this.pingInterval && CriticalTimers.clearInterval(this.pingInterval);
  }
}
function fromProtoSessionDescription(a) {
  const u = {
    type: "offer",
    sdp: a.sdp
  };
  switch (a.type) {
    case "answer":
    case "offer":
    case "pranswer":
    case "rollback":
      u.type = a.type;
      break;
  }
  return u;
}
function toProtoSessionDescription(a) {
  return new SessionDescription({
    sdp: a.sdp,
    type: a.type
  });
}
function createConnectionParams(a, u, c) {
  var l;
  const v = new URLSearchParams();
  return v.set("access_token", a), c.reconnect && (v.set("reconnect", "1"), c.sid && v.set("sid", c.sid)), v.set("auto_subscribe", c.autoSubscribe ? "1" : "0"), v.set("sdk", isReactNative() ? "reactnative" : "js"), v.set("version", u.version), v.set("protocol", u.protocol.toString()), u.deviceModel && v.set("device_model", u.deviceModel), u.os && v.set("os", u.os), u.osVersion && v.set("os_version", u.osVersion), u.browser && v.set("browser", u.browser), u.browserVersion && v.set("browser_version", u.browserVersion), c.adaptiveStream && v.set("adaptive_stream", "1"), c.reconnectReason && v.set("reconnect_reason", c.reconnectReason.toString()), !((l = navigator.connection) === null || l === void 0) && l.type && v.set("network", navigator.connection.type), "?".concat(v.toString());
}
var parser$1 = {}, grammar$2 = { exports: {} }, grammar$1 = grammar$2.exports = {
  v: [{
    name: "version",
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: "origin",
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
    format: "%s %s %d %s IP%d %s"
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{
    name: "name"
  }],
  i: [{
    name: "description"
  }],
  u: [{
    name: "uri"
  }],
  e: [{
    name: "email"
  }],
  p: [{
    name: "phone"
  }],
  z: [{
    name: "timezones"
  }],
  // TODO: this one can actually be parsed properly...
  r: [{
    name: "repeats"
  }],
  // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: "timing",
    reg: /^(\d*) (\d*)/,
    names: ["start", "stop"],
    format: "%d %d"
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: "connection",
    reg: /^IN IP(\d) (\S*)/,
    names: ["version", "ip"],
    format: "IN IP%d %s"
  }],
  b: [{
    // b=AS:4000
    push: "bandwidth",
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ["type", "limit"],
    format: "%s:%s"
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ["type", "port", "protocol", "payloads"],
    format: "%s %d %s %s"
  }],
  a: [
    {
      // a=rtpmap:110 opus/48000/2
      push: "rtp",
      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ["payload", "codec", "rate", "encoding"],
      format: function(a) {
        return a.encoding ? "rtpmap:%d %s/%s/%s" : a.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
      }
    },
    {
      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      // a=fmtp:111 minptime=10; useinbandfec=1
      push: "fmtp",
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ["payload", "config"],
      format: "fmtp:%d %s"
    },
    {
      // a=control:streamid=0
      name: "control",
      reg: /^control:(.*)/,
      format: "control:%s"
    },
    {
      // a=rtcp:65179 IN IP4 193.84.77.194
      name: "rtcp",
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ["port", "netType", "ipVer", "address"],
      format: function(a) {
        return a.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
      }
    },
    {
      // a=rtcp-fb:98 trr-int 100
      push: "rtcpFbTrrInt",
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ["payload", "value"],
      format: "rtcp-fb:%s trr-int %d"
    },
    {
      // a=rtcp-fb:98 nack rpsi
      push: "rtcpFb",
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ["payload", "type", "subtype"],
      format: function(a) {
        return a.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
      }
    },
    {
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:1/recvonly URI-gps-string
      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
      push: "ext",
      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
      names: ["value", "direction", "encrypt-uri", "uri", "config"],
      format: function(a) {
        return "extmap:%d" + (a.direction ? "/%s" : "%v") + (a["encrypt-uri"] ? " %s" : "%v") + " %s" + (a.config ? " %s" : "");
      }
    },
    {
      // a=extmap-allow-mixed
      name: "extmapAllowMixed",
      reg: /^(extmap-allow-mixed)/
    },
    {
      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: "crypto",
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ["id", "suite", "config", "sessionConfig"],
      format: function(a) {
        return a.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
      }
    },
    {
      // a=setup:actpass
      name: "setup",
      reg: /^setup:(\w*)/,
      format: "setup:%s"
    },
    {
      // a=connection:new
      name: "connectionType",
      reg: /^connection:(new|existing)/,
      format: "connection:%s"
    },
    {
      // a=mid:1
      name: "mid",
      reg: /^mid:([^\s]*)/,
      format: "mid:%s"
    },
    {
      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: "msid",
      reg: /^msid:(.*)/,
      format: "msid:%s"
    },
    {
      // a=ptime:20
      name: "ptime",
      reg: /^ptime:(\d*(?:\.\d*)*)/,
      format: "ptime:%d"
    },
    {
      // a=maxptime:60
      name: "maxptime",
      reg: /^maxptime:(\d*(?:\.\d*)*)/,
      format: "maxptime:%d"
    },
    {
      // a=sendrecv
      name: "direction",
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
      // a=ice-lite
      name: "icelite",
      reg: /^(ice-lite)/
    },
    {
      // a=ice-ufrag:F7gI
      name: "iceUfrag",
      reg: /^ice-ufrag:(\S*)/,
      format: "ice-ufrag:%s"
    },
    {
      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: "icePwd",
      reg: /^ice-pwd:(\S*)/,
      format: "ice-pwd:%s"
    },
    {
      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: "fingerprint",
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ["type", "hash"],
      format: "fingerprint:%s %s"
    },
    {
      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push: "candidates",
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
      format: function(a) {
        var u = "candidate:%s %d %s %d %s %d typ %s";
        return u += a.raddr != null ? " raddr %s rport %d" : "%v%v", u += a.tcptype != null ? " tcptype %s" : "%v", a.generation != null && (u += " generation %d"), u += a["network-id"] != null ? " network-id %d" : "%v", u += a["network-cost"] != null ? " network-cost %d" : "%v", u;
      }
    },
    {
      // a=end-of-candidates (keep after the candidates line for readability)
      name: "endOfCandidates",
      reg: /^(end-of-candidates)/
    },
    {
      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: "remoteCandidates",
      reg: /^remote-candidates:(.*)/,
      format: "remote-candidates:%s"
    },
    {
      // a=ice-options:google-ice
      name: "iceOptions",
      reg: /^ice-options:(\S*)/,
      format: "ice-options:%s"
    },
    {
      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: "ssrcs",
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ["id", "attribute", "value"],
      format: function(a) {
        var u = "ssrc:%d";
        return a.attribute != null && (u += " %s", a.value != null && (u += ":%s")), u;
      }
    },
    {
      // a=ssrc-group:FEC 1 2
      // a=ssrc-group:FEC-FR 3004364195 1080772241
      push: "ssrcGroups",
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ["semantics", "ssrcs"],
      format: "ssrc-group:%s %s"
    },
    {
      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: "msidSemantic",
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ["semantic", "token"],
      format: "msid-semantic: %s %s"
      // space after ':' is not accidental
    },
    {
      // a=group:BUNDLE audio video
      push: "groups",
      reg: /^group:(\w*) (.*)/,
      names: ["type", "mids"],
      format: "group:%s %s"
    },
    {
      // a=rtcp-mux
      name: "rtcpMux",
      reg: /^(rtcp-mux)/
    },
    {
      // a=rtcp-rsize
      name: "rtcpRsize",
      reg: /^(rtcp-rsize)/
    },
    {
      // a=sctpmap:5000 webrtc-datachannel 1024
      name: "sctpmap",
      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
      names: ["sctpmapNumber", "app", "maxMessageSize"],
      format: function(a) {
        return a.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
      }
    },
    {
      // a=x-google-flag:conference
      name: "xGoogleFlag",
      reg: /^x-google-flag:([^\s]*)/,
      format: "x-google-flag:%s"
    },
    {
      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: "rids",
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ["id", "direction", "params"],
      format: function(a) {
        return a.params ? "rid:%s %s %s" : "rid:%s %s";
      }
    },
    {
      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      // a=imageattr:* send [x=800,y=640] recv *
      // a=imageattr:100 recv [x=320,y=240]
      push: "imageattrs",
      reg: new RegExp(
        // a=imageattr:97
        "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
      ),
      names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
      format: function(a) {
        return "imageattr:%s %s %s" + (a.dir2 ? " %s %s" : "");
      }
    },
    {
      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      // a=simulcast:recv 1;4,5 send 6;7
      name: "simulcast",
      reg: new RegExp(
        // a=simulcast:
        "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
      ),
      names: ["dir1", "list1", "dir2", "list2"],
      format: function(a) {
        return "simulcast:%s %s" + (a.dir2 ? " %s %s" : "");
      }
    },
    {
      // old simulcast draft 03 (implemented by Firefox)
      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      // a=simulcast: recv pt=97;98 send pt=97
      // a=simulcast: send rid=5;6;7 paused=6,7
      name: "simulcast_03",
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ["value"],
      format: "simulcast: %s"
    },
    {
      // a=framerate:25
      // a=framerate:29.97
      name: "framerate",
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: "framerate:%s"
    },
    {
      // RFC4570
      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
      name: "sourceFilter",
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
      format: "source-filter: %s %s %s %s %s"
    },
    {
      // a=bundle-only
      name: "bundleOnly",
      reg: /^(bundle-only)/
    },
    {
      // a=label:1
      name: "label",
      reg: /^label:(.+)/,
      format: "label:%s"
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
      name: "sctpPort",
      reg: /^sctp-port:(\d+)$/,
      format: "sctp-port:%s"
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
      name: "maxMessageSize",
      reg: /^max-message-size:(\d+)$/,
      format: "max-message-size:%s"
    },
    {
      // RFC7273
      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
      push: "tsRefClocks",
      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
      names: ["clksrc", "clksrcExt"],
      format: function(a) {
        return "ts-refclk:%s" + (a.clksrcExt != null ? "=%s" : "");
      }
    },
    {
      // RFC7273
      // a=mediaclk:direct=963214424
      name: "mediaClk",
      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
      names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
      format: function(a) {
        var u = "mediaclk:";
        return u += a.id != null ? "id=%s %s" : "%v%s", u += a.mediaClockValue != null ? "=%s" : "", u += a.rateNumerator != null ? " rate=%s" : "", u += a.rateDenominator != null ? "/%s" : "", u;
      }
    },
    {
      // a=keywds:keywords
      name: "keywords",
      reg: /^keywds:(.+)$/,
      format: "keywds:%s"
    },
    {
      // a=content:main
      name: "content",
      reg: /^content:(.+)/,
      format: "content:%s"
    },
    // BFCP https://tools.ietf.org/html/rfc4583
    {
      // a=floorctrl:c-s
      name: "bfcpFloorCtrl",
      reg: /^floorctrl:(c-only|s-only|c-s)/,
      format: "floorctrl:%s"
    },
    {
      // a=confid:1
      name: "bfcpConfId",
      reg: /^confid:(\d+)/,
      format: "confid:%s"
    },
    {
      // a=userid:1
      name: "bfcpUserId",
      reg: /^userid:(\d+)/,
      format: "userid:%s"
    },
    {
      // a=floorid:1
      name: "bfcpFloorId",
      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
      names: ["id", "mStream"],
      format: "floorid:%s mstrm:%s"
    },
    {
      // any a= that we don't understand is kept verbatim on media.invalid
      push: "invalid",
      names: ["value"]
    }
  ]
};
Object.keys(grammar$1).forEach(function(a) {
  var u = grammar$1[a];
  u.forEach(function(c) {
    c.reg || (c.reg = /(.*)/), c.format || (c.format = "%s");
  });
});
var grammarExports = grammar$2.exports;
(function(a) {
  var u = function(I) {
    return String(Number(I)) === I ? Number(I) : I;
  }, c = function(I, P, $, F) {
    if (F && !$)
      P[F] = u(I[1]);
    else
      for (var H = 0; H < $.length; H += 1)
        I[H + 1] != null && (P[$[H]] = u(I[H + 1]));
  }, l = function(I, P, $) {
    var F = I.name && I.names;
    I.push && !P[I.push] ? P[I.push] = [] : F && !P[I.name] && (P[I.name] = {});
    var H = I.push ? {} : (
      // blank object that will be pushed
      F ? P[I.name] : P
    );
    c($.match(I.reg), H, I.names, I.name), I.push && P[I.push].push(H);
  }, v = grammarExports, p = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
  a.parse = function(I) {
    var P = {}, $ = [], F = P;
    return I.split(/(\r\n|\r|\n)/).filter(p).forEach(function(H) {
      var j = H[0], ee = H.slice(2);
      j === "m" && ($.push({
        rtp: [],
        fmtp: []
      }), F = $[$.length - 1]);
      for (var X = 0; X < (v[j] || []).length; X += 1) {
        var ie = v[j][X];
        if (ie.reg.test(ee))
          return l(ie, F, ee);
      }
    }), P.media = $, P;
  };
  var _ = function(I, P) {
    var $ = P.split(/=(.+)/, 2);
    return $.length === 2 ? I[$[0]] = u($[1]) : $.length === 1 && P.length > 1 && (I[$[0]] = void 0), I;
  };
  a.parseParams = function(I) {
    return I.split(/;\s?/).reduce(_, {});
  }, a.parseFmtpConfig = a.parseParams, a.parsePayloads = function(I) {
    return I.toString().split(" ").map(Number);
  }, a.parseRemoteCandidates = function(I) {
    for (var P = [], $ = I.split(" ").map(u), F = 0; F < $.length; F += 3)
      P.push({
        component: $[F],
        ip: $[F + 1],
        port: $[F + 2]
      });
    return P;
  }, a.parseImageAttributes = function(I) {
    return I.split(" ").map(function(P) {
      return P.substring(1, P.length - 1).split(",").reduce(_, {});
    });
  }, a.parseSimulcastStreamList = function(I) {
    return I.split(";").map(function(P) {
      return P.split(",").map(function($) {
        var F, H = !1;
        return $[0] !== "~" ? F = u($) : (F = u($.substring(1, $.length)), H = !0), {
          scid: F,
          paused: H
        };
      });
    });
  };
})(parser$1);
var grammar = grammarExports, formatRegExp = /%[sdv%]/g, format = function(a) {
  var u = 1, c = arguments, l = c.length;
  return a.replace(formatRegExp, function(v) {
    if (u >= l)
      return v;
    var p = c[u];
    switch (u += 1, v) {
      case "%%":
        return "%";
      case "%s":
        return String(p);
      case "%d":
        return Number(p);
      case "%v":
        return "";
    }
  });
}, makeLine = function(a, u, c) {
  var l = u.format instanceof Function ? u.format(u.push ? c : c[u.name]) : u.format, v = [a + "=" + l];
  if (u.names)
    for (var p = 0; p < u.names.length; p += 1) {
      var _ = u.names[p];
      u.name ? v.push(c[u.name][_]) : v.push(c[u.names[p]]);
    }
  else
    v.push(c[u.name]);
  return format.apply(null, v);
}, defaultOuterOrder = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"], defaultInnerOrder = ["i", "c", "b", "a"], writer$1 = function(a, u) {
  u = u || {}, a.version == null && (a.version = 0), a.name == null && (a.name = " "), a.media.forEach(function(p) {
    p.payloads == null && (p.payloads = "");
  });
  var c = u.outerOrder || defaultOuterOrder, l = u.innerOrder || defaultInnerOrder, v = [];
  return c.forEach(function(p) {
    grammar[p].forEach(function(_) {
      _.name in a && a[_.name] != null ? v.push(makeLine(p, _, a)) : _.push in a && a[_.push] != null && a[_.push].forEach(function(I) {
        v.push(makeLine(p, _, I));
      });
    });
  }), a.media.forEach(function(p) {
    v.push(makeLine("m", grammar.m[0], p)), l.forEach(function(_) {
      grammar[_].forEach(function(I) {
        I.name in p && p[I.name] != null ? v.push(makeLine(_, I, p)) : I.push in p && p[I.push] != null && p[I.push].forEach(function(P) {
          v.push(makeLine(_, I, P));
        });
      });
    });
  }), v.join(`\r
`) + `\r
`;
}, parser = parser$1, writer = writer$1, write = writer, parse$2 = parser.parse;
const startBitrateForSVC = 0.7, PCEvents = {
  NegotiationStarted: "negotiationStarted",
  NegotiationComplete: "negotiationComplete",
  RTPVideoPayloadTypes: "rtpVideoPayloadTypes"
};
class PCTransport extends eventsExports$1.EventEmitter {
  get pc() {
    return this._pc || (this._pc = this.createPC()), this._pc;
  }
  constructor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var l;
    super(), this.log = livekitLogger, this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate = !1, this.trackBitrates = [], this.remoteStereoMids = [], this.remoteNackMids = [], this.negotiate = r$1((v) => __awaiter$3(this, void 0, void 0, function* () {
      this.emit(PCEvents.NegotiationStarted);
      try {
        yield this.createAndSendOffer();
      } catch (p) {
        if (v)
          v(p);
        else
          throw p;
      }
    }), 100), this.close = () => {
      this._pc && (this._pc.close(), this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.ondatachannel = null, this._pc.onnegotiationneeded = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ondatachannel = null, this._pc.ontrack = null, this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc = null);
    }, this.log = getLogger((l = c.loggerName) !== null && l !== void 0 ? l : LoggerNames.PCTransport), this.loggerOptions = c, this.config = u, this._pc = this.createPC();
  }
  createPC() {
    const u = new RTCPeerConnection(this.config);
    return u.onicecandidate = (c) => {
      var l;
      c.candidate && ((l = this.onIceCandidate) === null || l === void 0 || l.call(this, c.candidate));
    }, u.onicecandidateerror = (c) => {
      var l;
      (l = this.onIceCandidateError) === null || l === void 0 || l.call(this, c);
    }, u.oniceconnectionstatechange = () => {
      var c;
      (c = this.onIceConnectionStateChange) === null || c === void 0 || c.call(this, u.iceConnectionState);
    }, u.onsignalingstatechange = () => {
      var c;
      (c = this.onSignalingStatechange) === null || c === void 0 || c.call(this, u.signalingState);
    }, u.onconnectionstatechange = () => {
      var c;
      (c = this.onConnectionStateChange) === null || c === void 0 || c.call(this, u.connectionState);
    }, u.ondatachannel = (c) => {
      var l;
      (l = this.onDataChannel) === null || l === void 0 || l.call(this, c);
    }, u.ontrack = (c) => {
      var l;
      (l = this.onTrack) === null || l === void 0 || l.call(this, c);
    }, u;
  }
  get logContext() {
    var u, c;
    return Object.assign({}, (c = (u = this.loggerOptions).loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));
  }
  get isICEConnected() {
    return this._pc !== null && (this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed");
  }
  addIceCandidate(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.pc.remoteDescription && !this.restartingIce)
        return this.pc.addIceCandidate(u);
      this.pendingCandidates.push(u);
    });
  }
  setRemoteDescription(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      let l;
      if (u.type === "offer") {
        let {
          stereoMids: v,
          nackMids: p
        } = extractStereoAndNackAudioFromOffer(u);
        this.remoteStereoMids = v, this.remoteNackMids = p;
      } else if (u.type === "answer") {
        const v = parse$2((c = u.sdp) !== null && c !== void 0 ? c : "");
        v.media.forEach((p) => {
          p.type === "audio" && this.trackBitrates.some((_) => {
            if (!_.transceiver || p.mid != _.transceiver.mid)
              return !1;
            let I = 0;
            if (p.rtp.some(($) => $.codec.toUpperCase() === _.codec.toUpperCase() ? (I = $.payload, !0) : !1), I === 0)
              return !0;
            let P = !1;
            for (const $ of p.fmtp)
              if ($.payload === I) {
                $.config = $.config.split(";").filter((F) => !F.includes("maxaveragebitrate")).join(";"), _.maxbr > 0 && ($.config += ";maxaveragebitrate=".concat(_.maxbr * 1e3)), P = !0;
                break;
              }
            return P || _.maxbr > 0 && p.fmtp.push({
              payload: I,
              config: "maxaveragebitrate=".concat(_.maxbr * 1e3)
            }), !0;
          });
        }), l = write(v);
      }
      yield this.setMungedSDP(u, l, !0), this.pendingCandidates.forEach((v) => {
        this.pc.addIceCandidate(v);
      }), this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate ? (this.renegotiate = !1, yield this.createAndSendOffer()) : u.type === "answer" && (this.emit(PCEvents.NegotiationComplete), u.sdp && parse$2(u.sdp).media.forEach((p) => {
        p.type === "video" && this.emit(PCEvents.RTPVideoPayloadTypes, p.rtp);
      }));
    });
  }
  createAndSendOffer(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.onOffer === void 0)
        return;
      if (u != null && u.iceRestart && (this.log.debug("restarting ICE", this.logContext), this.restartingIce = !0), this._pc && this._pc.signalingState === "have-local-offer") {
        const p = this._pc.remoteDescription;
        if (u != null && u.iceRestart && p)
          yield this._pc.setRemoteDescription(p);
        else {
          this.renegotiate = !0;
          return;
        }
      } else if (!this._pc || this._pc.signalingState === "closed") {
        this.log.warn("could not createOffer with closed peer connection", this.logContext);
        return;
      }
      this.log.debug("starting to negotiate", this.logContext);
      const l = yield this.pc.createOffer(u), v = parse$2((c = l.sdp) !== null && c !== void 0 ? c : "");
      v.media.forEach((p) => {
        p.type === "audio" ? ensureAudioNackAndStereo(p, [], []) : p.type === "video" && (ensureVideoDDExtensionForSVC(p), this.trackBitrates.some((_) => {
          if (!p.msid || !_.cid || !p.msid.includes(_.cid))
            return !1;
          let I = 0;
          if (p.rtp.some(($) => $.codec.toUpperCase() === _.codec.toUpperCase() ? (I = $.payload, !0) : !1), I === 0)
            return !0;
          let P = !1;
          for (const $ of p.fmtp)
            if ($.payload === I) {
              $.config.includes("x-google-start-bitrate") || ($.config += ";x-google-start-bitrate=".concat(Math.round(_.maxbr * startBitrateForSVC))), $.config.includes("x-google-max-bitrate") || ($.config += ";x-google-max-bitrate=".concat(_.maxbr)), P = !0;
              break;
            }
          return P || p.fmtp.push({
            payload: I,
            config: "x-google-start-bitrate=".concat(Math.round(_.maxbr * startBitrateForSVC), ";x-google-max-bitrate=").concat(_.maxbr)
          }), !0;
        }));
      }), yield this.setMungedSDP(l, write(v)), this.onOffer(l);
    });
  }
  createAndSetAnswer() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.pc.createAnswer(), l = parse$2((u = c.sdp) !== null && u !== void 0 ? u : "");
      return l.media.forEach((v) => {
        v.type === "audio" && ensureAudioNackAndStereo(v, this.remoteStereoMids, this.remoteNackMids);
      }), yield this.setMungedSDP(c, write(l)), c;
    });
  }
  createDataChannel(u, c) {
    return this.pc.createDataChannel(u, c);
  }
  addTransceiver(u, c) {
    return this.pc.addTransceiver(u, c);
  }
  addTrack(u) {
    if (!this._pc)
      throw new UnexpectedConnectionState("PC closed, cannot add track");
    return this._pc.addTrack(u);
  }
  setTrackCodecBitrate(u) {
    this.trackBitrates.push(u);
  }
  setConfiguration(u) {
    var c;
    if (!this._pc)
      throw new UnexpectedConnectionState("PC closed, cannot configure");
    return (c = this._pc) === null || c === void 0 ? void 0 : c.setConfiguration(u);
  }
  canRemoveTrack() {
    var u;
    return !!(!((u = this._pc) === null || u === void 0) && u.removeTrack);
  }
  removeTrack(u) {
    var c;
    return (c = this._pc) === null || c === void 0 ? void 0 : c.removeTrack(u);
  }
  getConnectionState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.connectionState) !== null && c !== void 0 ? c : "closed";
  }
  getICEConnectionState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.iceConnectionState) !== null && c !== void 0 ? c : "closed";
  }
  getSignallingState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.signalingState) !== null && c !== void 0 ? c : "closed";
  }
  getTransceivers() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.getTransceivers()) !== null && c !== void 0 ? c : [];
  }
  getSenders() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.getSenders()) !== null && c !== void 0 ? c : [];
  }
  getLocalDescription() {
    var u;
    return (u = this._pc) === null || u === void 0 ? void 0 : u.localDescription;
  }
  getRemoteDescription() {
    var u;
    return (u = this.pc) === null || u === void 0 ? void 0 : u.remoteDescription;
  }
  getStats() {
    return this.pc.getStats();
  }
  getConnectedAddress() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this._pc)
        return;
      let c = "";
      const l = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map();
      if ((yield this._pc.getStats()).forEach((I) => {
        switch (I.type) {
          case "transport":
            c = I.selectedCandidatePairId;
            break;
          case "candidate-pair":
            c === "" && I.selected && (c = I.id), l.set(I.id, I);
            break;
          case "remote-candidate":
            v.set(I.id, "".concat(I.address, ":").concat(I.port));
            break;
        }
      }), c === "")
        return;
      const _ = (u = l.get(c)) === null || u === void 0 ? void 0 : u.remoteCandidateId;
      if (_ !== void 0)
        return v.get(_);
    });
  }
  setMungedSDP(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (c) {
        const v = u.sdp;
        u.sdp = c;
        try {
          this.log.debug("setting munged ".concat(l ? "remote" : "local", " description"), this.logContext), l ? yield this.pc.setRemoteDescription(u) : yield this.pc.setLocalDescription(u);
          return;
        } catch (p) {
          this.log.warn("not able to set ".concat(u.type, ", falling back to unmodified sdp"), Object.assign(Object.assign({}, this.logContext), {
            error: p,
            sdp: c
          })), u.sdp = v;
        }
      }
      try {
        l ? yield this.pc.setRemoteDescription(u) : yield this.pc.setLocalDescription(u);
      } catch (v) {
        let p = "unknown error";
        v instanceof Error ? p = v.message : typeof v == "string" && (p = v);
        const _ = {
          error: p,
          sdp: u.sdp
        };
        throw !l && this.pc.remoteDescription && (_.remoteSdp = this.pc.remoteDescription), this.log.error("unable to set ".concat(u.type), Object.assign(Object.assign({}, this.logContext), {
          fields: _
        })), new NegotiationError(p);
      }
    });
  }
}
function ensureAudioNackAndStereo(a, u, c) {
  let l = 0;
  a.rtp.some((v) => v.codec === "opus" ? (l = v.payload, !0) : !1), l > 0 && (a.rtcpFb || (a.rtcpFb = []), c.includes(a.mid) && !a.rtcpFb.some((v) => v.payload === l && v.type === "nack") && a.rtcpFb.push({
    payload: l,
    type: "nack"
  }), u.includes(a.mid) && a.fmtp.some((v) => v.payload === l ? (v.config.includes("stereo=1") || (v.config += ";stereo=1"), !0) : !1));
}
function ensureVideoDDExtensionForSVC(a) {
  var u, c, l, v;
  const p = (c = (u = a.rtp[0]) === null || u === void 0 ? void 0 : u.codec) === null || c === void 0 ? void 0 : c.toLowerCase();
  if (!isSVCCodec(p))
    return;
  let _ = 0;
  ((l = a.ext) === null || l === void 0 ? void 0 : l.some((P) => P.uri === ddExtensionURI ? !0 : (P.value > _ && (_ = P.value), !1))) || (v = a.ext) === null || v === void 0 || v.push({
    value: _ + 1,
    uri: ddExtensionURI
  });
}
function extractStereoAndNackAudioFromOffer(a) {
  var u;
  const c = [], l = [], v = parse$2((u = a.sdp) !== null && u !== void 0 ? u : "");
  let p = 0;
  return v.media.forEach((_) => {
    var I;
    _.type === "audio" && (_.rtp.some((P) => P.codec === "opus" ? (p = P.payload, !0) : !1), !((I = _.rtcpFb) === null || I === void 0) && I.some((P) => P.payload === p && P.type === "nack") && l.push(_.mid), _.fmtp.some((P) => P.payload === p ? (P.config.includes("sprop-stereo=1") && c.push(_.mid), !0) : !1));
  }), {
    stereoMids: c,
    nackMids: l
  };
}
const defaultVideoCodec = "vp8", publishDefaults = {
  audioPreset: AudioPresets.music,
  dtx: !0,
  red: !0,
  forceStereo: !1,
  simulcast: !0,
  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
  stopMicTrackOnMute: !1,
  videoCodec: defaultVideoCodec,
  backupCodec: !0
}, audioDefaults = {
  autoGainControl: !0,
  echoCancellation: !0,
  noiseSuppression: !0
}, videoDefaults = {
  resolution: VideoPresets.h720.resolution
}, roomOptionDefaults = {
  adaptiveStream: !1,
  dynacast: !1,
  stopLocalTrackOnUnpublish: !0,
  reconnectPolicy: new DefaultReconnectPolicy(),
  disconnectOnPageLeave: !0,
  webAudioMix: !0
}, roomConnectOptionDefaults = {
  autoSubscribe: !0,
  maxRetries: 1,
  peerConnectionTimeout: 15e3,
  websocketTimeout: 15e3
};
var PCTransportState;
(function(a) {
  a[a.NEW = 0] = "NEW", a[a.CONNECTING = 1] = "CONNECTING", a[a.CONNECTED = 2] = "CONNECTED", a[a.FAILED = 3] = "FAILED", a[a.CLOSING = 4] = "CLOSING", a[a.CLOSED = 5] = "CLOSED";
})(PCTransportState || (PCTransportState = {}));
class PCTransportManager {
  get needsPublisher() {
    return this.isPublisherConnectionRequired;
  }
  get needsSubscriber() {
    return this.isSubscriberConnectionRequired;
  }
  get currentState() {
    return this.state;
  }
  constructor(u, c, l) {
    var v;
    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout, this.log = livekitLogger, this.updateState = () => {
      var p;
      const _ = this.state, I = this.requiredTransports.map((P) => P.getConnectionState());
      I.every((P) => P === "connected") ? this.state = PCTransportState.CONNECTED : I.some((P) => P === "failed") ? this.state = PCTransportState.FAILED : I.some((P) => P === "connecting") ? this.state = PCTransportState.CONNECTING : I.every((P) => P === "closed") ? this.state = PCTransportState.CLOSED : I.some((P) => P === "closed") ? this.state = PCTransportState.CLOSING : I.every((P) => P === "new") && (this.state = PCTransportState.NEW), _ !== this.state && (this.log.debug("pc state change: from ".concat(PCTransportState[_], " to ").concat(PCTransportState[this.state]), this.logContext), (p = this.onStateChange) === null || p === void 0 || p.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState()));
    }, this.log = getLogger((v = l.loggerName) !== null && v !== void 0 ? v : LoggerNames.PCManager), this.loggerOptions = l, this.isPublisherConnectionRequired = !c, this.isSubscriberConnectionRequired = c, this.publisher = new PCTransport(u, l), this.subscriber = new PCTransport(u, l), this.publisher.onConnectionStateChange = this.updateState, this.subscriber.onConnectionStateChange = this.updateState, this.publisher.onIceConnectionStateChange = this.updateState, this.subscriber.onIceConnectionStateChange = this.updateState, this.publisher.onSignalingStatechange = this.updateState, this.subscriber.onSignalingStatechange = this.updateState, this.publisher.onIceCandidate = (p) => {
      var _;
      (_ = this.onIceCandidate) === null || _ === void 0 || _.call(this, p, SignalTarget.PUBLISHER);
    }, this.subscriber.onIceCandidate = (p) => {
      var _;
      (_ = this.onIceCandidate) === null || _ === void 0 || _.call(this, p, SignalTarget.SUBSCRIBER);
    }, this.subscriber.onDataChannel = (p) => {
      var _;
      (_ = this.onDataChannel) === null || _ === void 0 || _.call(this, p);
    }, this.subscriber.onTrack = (p) => {
      var _;
      (_ = this.onTrack) === null || _ === void 0 || _.call(this, p);
    }, this.publisher.onOffer = (p) => {
      var _;
      (_ = this.onPublisherOffer) === null || _ === void 0 || _.call(this, p);
    }, this.state = PCTransportState.NEW, this.connectionLock = new Mutex();
  }
  get logContext() {
    var u, c;
    return Object.assign({}, (c = (u = this.loggerOptions).loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));
  }
  requirePublisher() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.isPublisherConnectionRequired = u, this.updateState();
  }
  requireSubscriber() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.isSubscriberConnectionRequired = u, this.updateState();
  }
  createAndSendPublisherOffer(u) {
    return this.publisher.createAndSendOffer(u);
  }
  setPublisherAnswer(u) {
    return this.publisher.setRemoteDescription(u);
  }
  removeTrack(u) {
    return this.publisher.removeTrack(u);
  }
  close() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.publisher && this.publisher.getSignallingState() !== "closed") {
        const u = this.publisher;
        for (const c of u.getSenders())
          try {
            u.canRemoveTrack() && u.removeTrack(c);
          } catch (l) {
            this.log.warn("could not removeTrack", Object.assign(Object.assign({}, this.logContext), {
              error: l
            }));
          }
      }
      yield Promise.all([this.publisher.close(), this.subscriber.close()]), this.updateState();
    });
  }
  triggerIceRestart() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.subscriber.restartingIce = !0, this.needsPublisher && (yield this.createAndSendPublisherOffer({
        iceRestart: !0
      }));
    });
  }
  addIceCandidate(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      c === SignalTarget.PUBLISHER ? yield this.publisher.addIceCandidate(u) : yield this.subscriber.addIceCandidate(u);
    });
  }
  createSubscriberAnswerFromOffer(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.log.debug("received server offer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: u.type,
        sdp: u.sdp,
        signalingState: this.subscriber.getSignallingState().toString()
      })), yield this.subscriber.setRemoteDescription(u), yield this.subscriber.createAndSetAnswer();
    });
  }
  updateConfiguration(u, c) {
    this.publisher.setConfiguration(u), this.subscriber.setConfiguration(u), c && this.triggerIceRestart();
  }
  ensurePCTransportConnection(u, c) {
    var l;
    return __awaiter$3(this, void 0, void 0, function* () {
      const v = yield this.connectionLock.lock();
      try {
        this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== "connected" && this.publisher.getConnectionState() !== "connecting" && (this.log.debug("negotiation required, start negotiating", this.logContext), this.publisher.negotiate()), yield Promise.all((l = this.requiredTransports) === null || l === void 0 ? void 0 : l.map((p) => this.ensureTransportConnected(p, u, c)));
      } finally {
        v();
      }
    });
  }
  negotiate(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return new Promise((c, l) => __awaiter$3(this, void 0, void 0, function* () {
        const v = setTimeout(() => {
          l("negotiation timed out");
        }, this.peerConnectionTimeout), p = () => {
          clearTimeout(v), l("negotiation aborted");
        };
        u.signal.addEventListener("abort", p), this.publisher.once(PCEvents.NegotiationStarted, () => {
          u.signal.aborted || this.publisher.once(PCEvents.NegotiationComplete, () => {
            clearTimeout(v), c();
          });
        }), yield this.publisher.negotiate((_) => {
          clearTimeout(v), l(_);
        });
      }));
    });
  }
  addPublisherTransceiver(u, c) {
    return this.publisher.addTransceiver(u, c);
  }
  addPublisherTrack(u) {
    return this.publisher.addTrack(u);
  }
  createPublisherDataChannel(u, c) {
    return this.publisher.createDataChannel(u, c);
  }
  /**
   * Returns the first required transport's address if no explicit target is specified
   */
  getConnectedAddress(u) {
    return u === SignalTarget.PUBLISHER ? this.publisher.getConnectedAddress() : u === SignalTarget.SUBSCRIBER ? this.publisher.getConnectedAddress() : this.requiredTransports[0].getConnectedAddress();
  }
  get requiredTransports() {
    const u = [];
    return this.isPublisherConnectionRequired && u.push(this.publisher), this.isSubscriberConnectionRequired && u.push(this.subscriber), u;
  }
  ensureTransportConnected(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.peerConnectionTimeout;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (u.getConnectionState() !== "connected")
        return new Promise((p, _) => __awaiter$3(this, void 0, void 0, function* () {
          const I = () => {
            this.log.warn("abort transport connection", this.logContext), CriticalTimers.clearTimeout(P), _(new ConnectionError(
              "room connection has been cancelled",
              3
              /* ConnectionErrorReason.Cancelled */
            ));
          };
          c != null && c.signal.aborted && I(), c == null || c.signal.addEventListener("abort", I);
          const P = CriticalTimers.setTimeout(() => {
            c == null || c.signal.removeEventListener("abort", I), _(new ConnectionError("could not establish pc connection"));
          }, l);
          for (; this.state !== PCTransportState.CONNECTED; )
            if (yield sleep(50), c != null && c.signal.aborted) {
              _(new ConnectionError(
                "room connection has been cancelled",
                3
                /* ConnectionErrorReason.Cancelled */
              ));
              return;
            }
          CriticalTimers.clearTimeout(P), c == null || c.signal.removeEventListener("abort", I), p();
        }));
    });
  }
}
const lossyDataChannel = "_lossy", reliableDataChannel = "_reliable", minReconnectWait = 2 * 1e3, leaveReconnect = "leave-reconnect";
var PCState;
(function(a) {
  a[a.New = 0] = "New", a[a.Connected = 1] = "Connected", a[a.Disconnected = 2] = "Disconnected", a[a.Reconnecting = 3] = "Reconnecting", a[a.Closed = 4] = "Closed";
})(PCState || (PCState = {}));
class RTCEngine extends eventsExports$1.EventEmitter {
  get isClosed() {
    return this._isClosed;
  }
  get pendingReconnect() {
    return !!this.reconnectTimeout;
  }
  constructor(u) {
    var c;
    super(), this.options = u, this.rtcConfig = {}, this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout, this.fullReconnectOnNext = !1, this.subscriberPrimary = !1, this.pcState = PCState.New, this._isClosed = !0, this.pendingTrackResolvers = {}, this.reconnectAttempts = 0, this.reconnectStart = 0, this.attemptingReconnect = !1, this.joinAttempts = 0, this.maxJoinAttempts = 1, this.shouldFailNext = !1, this.log = livekitLogger, this.handleDataChannel = (l) => {
      let {
        channel: v
      } = l;
      return __awaiter$3(this, void 0, void 0, function* () {
        if (v) {
          if (v.label === reliableDataChannel)
            this.reliableDCSub = v;
          else if (v.label === lossyDataChannel)
            this.lossyDCSub = v;
          else
            return;
          this.log.debug("on data channel ".concat(v.id, ", ").concat(v.label), this.logContext), v.onmessage = this.handleDataMessage;
        }
      });
    }, this.handleDataMessage = (l) => __awaiter$3(this, void 0, void 0, function* () {
      var v, p;
      const _ = yield this.dataProcessLock.lock();
      try {
        let I;
        if (l.data instanceof ArrayBuffer)
          I = l.data;
        else if (l.data instanceof Blob)
          I = yield l.data.arrayBuffer();
        else {
          this.log.error("unsupported data type", Object.assign(Object.assign({}, this.logContext), {
            data: l.data
          }));
          return;
        }
        const P = DataPacket.fromBinary(new Uint8Array(I));
        ((v = P.value) === null || v === void 0 ? void 0 : v.case) === "speaker" ? this.emit(EngineEvent.ActiveSpeakersUpdate, P.value.value.speakers) : ((p = P.value) === null || p === void 0 ? void 0 : p.case) === "user" && this.emit(EngineEvent.DataPacketReceived, P.value.value, P.kind);
      } finally {
        _();
      }
    }), this.handleDataError = (l) => {
      const p = l.currentTarget.maxRetransmits === 0 ? "lossy" : "reliable";
      if (l instanceof ErrorEvent && l.error) {
        const {
          error: _
        } = l.error;
        this.log.error("DataChannel error on ".concat(p, ": ").concat(l.message), Object.assign(Object.assign({}, this.logContext), {
          error: _
        }));
      } else
        this.log.error("Unknown DataChannel error on ".concat(p), Object.assign(Object.assign({}, this.logContext), {
          event: l
        }));
    }, this.handleBufferedAmountLow = (l) => {
      const p = l.currentTarget.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;
      this.updateAndEmitDCBufferStatus(p);
    }, this.handleDisconnect = (l, v) => {
      if (this._isClosed)
        return;
      this.log.warn("".concat(l, " disconnected"), this.logContext), this.reconnectAttempts === 0 && (this.reconnectStart = Date.now());
      const p = (P) => {
        this.log.warn("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(P, "ms. giving up"), this.logContext), this.emit(EngineEvent.Disconnected), this.close();
      }, _ = Date.now() - this.reconnectStart;
      let I = this.getNextRetryDelay({
        elapsedMs: _,
        retryCount: this.reconnectAttempts
      });
      if (I === null) {
        p(_);
        return;
      }
      l === leaveReconnect && (I = 0), this.log.debug("reconnecting in ".concat(I, "ms"), this.logContext), this.clearReconnectTimeout(), this.token && this.regionUrlProvider && this.regionUrlProvider.updateToken(this.token), this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(v).finally(() => this.reconnectTimeout = void 0), I);
    }, this.waitForRestarted = () => new Promise((l, v) => {
      this.pcState === PCState.Connected && l();
      const p = () => {
        this.off(EngineEvent.Disconnected, _), l();
      }, _ = () => {
        this.off(EngineEvent.Restarted, p), v();
      };
      this.once(EngineEvent.Restarted, p), this.once(EngineEvent.Disconnected, _);
    }), this.updateAndEmitDCBufferStatus = (l) => {
      const v = this.isBufferStatusLow(l);
      typeof v < "u" && v !== this.dcBufferStatus.get(l) && (this.dcBufferStatus.set(l, v), this.emit(EngineEvent.DCBufferStatusChanged, v, l));
    }, this.isBufferStatusLow = (l) => {
      const v = this.dataChannelForKind(l);
      if (v)
        return v.bufferedAmount <= v.bufferedAmountLowThreshold;
    }, this.handleBrowserOnLine = () => {
      this.client.currentState === SignalConnectionState.RECONNECTING && (this.clearReconnectTimeout(), this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED));
    }, this.log = getLogger((c = u.loggerName) !== null && c !== void 0 ? c : LoggerNames.Engine), this.loggerOptions = {
      loggerName: u.loggerName,
      loggerContextCb: () => this.logContext
    }, this.client = new SignalClient(void 0, this.loggerOptions), this.client.signalLatency = this.options.expSignalLatency, this.reconnectPolicy = this.options.reconnectPolicy, this.registerOnLineListener(), this.closingLock = new Mutex(), this.dataProcessLock = new Mutex(), this.dcBufferStatus = /* @__PURE__ */ new Map([[DataPacket_Kind.LOSSY, !0], [DataPacket_Kind.RELIABLE, !0]]), this.client.onParticipantUpdate = (l) => this.emit(EngineEvent.ParticipantUpdate, l), this.client.onConnectionQuality = (l) => this.emit(EngineEvent.ConnectionQualityUpdate, l), this.client.onRoomUpdate = (l) => this.emit(EngineEvent.RoomUpdate, l), this.client.onSubscriptionError = (l) => this.emit(EngineEvent.SubscriptionError, l), this.client.onSubscriptionPermissionUpdate = (l) => this.emit(EngineEvent.SubscriptionPermissionUpdate, l), this.client.onSpeakersChanged = (l) => this.emit(EngineEvent.SpeakersChanged, l), this.client.onStreamStateUpdate = (l) => this.emit(EngineEvent.StreamStateChanged, l);
  }
  /** @internal */
  get logContext() {
    var u, c, l, v, p, _;
    return {
      room: (c = (u = this.latestJoinResponse) === null || u === void 0 ? void 0 : u.room) === null || c === void 0 ? void 0 : c.name,
      roomSid: (v = (l = this.latestJoinResponse) === null || l === void 0 ? void 0 : l.room) === null || v === void 0 ? void 0 : v.sid,
      identity: (_ = (p = this.latestJoinResponse) === null || p === void 0 ? void 0 : p.participant) === null || _ === void 0 ? void 0 : _.identity
    };
  }
  join(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.url = u, this.token = c, this.signalOpts = l, this.maxJoinAttempts = l.maxRetries;
      try {
        this.joinAttempts += 1, this.setupSignalClientCallbacks();
        const p = yield this.client.join(u, c, l, v);
        return this._isClosed = !1, this.latestJoinResponse = p, this.subscriberPrimary = p.subscriberPrimary, this.pcManager || (yield this.configure(p)), this.subscriberPrimary || this.negotiate(), this.clientConfiguration = p.clientConfiguration, p;
      } catch (p) {
        if (p instanceof ConnectionError && p.reason === 1 && (this.log.warn("Couldn't connect to server, attempt ".concat(this.joinAttempts, " of ").concat(this.maxJoinAttempts), this.logContext), this.joinAttempts < this.maxJoinAttempts))
          return this.join(u, c, l, v);
        throw p;
      }
    });
  }
  close() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield this.closingLock.lock();
      if (this.isClosed) {
        u();
        return;
      }
      try {
        this._isClosed = !0, this.emit(EngineEvent.Closing), this.removeAllListeners(), this.deregisterOnLineListener(), this.clearPendingReconnect(), yield this.cleanupPeerConnections(), yield this.cleanupClient();
      } finally {
        u();
      }
    });
  }
  cleanupPeerConnections() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield (u = this.pcManager) === null || u === void 0 ? void 0 : u.close(), this.pcManager = void 0;
      const c = (l) => {
        l && (l.close(), l.onbufferedamountlow = null, l.onclose = null, l.onclosing = null, l.onerror = null, l.onmessage = null, l.onopen = null);
      };
      c(this.lossyDC), c(this.lossyDCSub), c(this.reliableDC), c(this.reliableDCSub), this.lossyDC = void 0, this.lossyDCSub = void 0, this.reliableDC = void 0, this.reliableDCSub = void 0;
    });
  }
  cleanupClient() {
    return __awaiter$3(this, void 0, void 0, function* () {
      yield this.client.close(), this.client.resetCallbacks();
    });
  }
  addTrack(u) {
    if (this.pendingTrackResolvers[u.cid])
      throw new TrackInvalidError("a track with the same ID has already been published");
    return new Promise((c, l) => {
      const v = setTimeout(() => {
        delete this.pendingTrackResolvers[u.cid], l(new ConnectionError("publication of local track timed out, no response from server"));
      }, 1e4);
      this.pendingTrackResolvers[u.cid] = {
        resolve: (p) => {
          clearTimeout(v), c(p);
        },
        reject: () => {
          clearTimeout(v), l(new Error("Cancelled publication by calling unpublish"));
        }
      }, this.client.sendAddTrack(u);
    });
  }
  /**
   * Removes sender from PeerConnection, returning true if it was removed successfully
   * and a negotiation is necessary
   * @param sender
   * @returns
   */
  removeTrack(u) {
    if (u.track && this.pendingTrackResolvers[u.track.id]) {
      const {
        reject: c
      } = this.pendingTrackResolvers[u.track.id];
      c && c(), delete this.pendingTrackResolvers[u.track.id];
    }
    try {
      return this.pcManager.removeTrack(u), !0;
    } catch (c) {
      this.log.warn("failed to remove track", Object.assign(Object.assign({}, this.logContext), {
        error: c
      }));
    }
    return !1;
  }
  updateMuteStatus(u, c) {
    this.client.sendMuteTrack(u, c);
  }
  get dataSubscriberReadyState() {
    var u;
    return (u = this.reliableDCSub) === null || u === void 0 ? void 0 : u.readyState;
  }
  getConnectedServerAddress() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return (u = this.pcManager) === null || u === void 0 ? void 0 : u.getConnectedAddress();
    });
  }
  /* @internal */
  setRegionUrlProvider(u) {
    this.regionUrlProvider = u;
  }
  configure(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW)
        return;
      this.participantSid = (c = u.participant) === null || c === void 0 ? void 0 : c.sid;
      const l = this.makeRTCConfiguration(u);
      this.pcManager = new PCTransportManager(l, u.subscriberPrimary, this.loggerOptions), this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber), this.pcManager.onIceCandidate = (v, p) => {
        this.client.sendIceCandidate(v, p);
      }, this.pcManager.onPublisherOffer = (v) => {
        this.client.sendOffer(v);
      }, this.pcManager.onDataChannel = this.handleDataChannel, this.pcManager.onStateChange = (v, p, _) => __awaiter$3(this, void 0, void 0, function* () {
        if (this.log.debug("primary PC state changed ".concat(v), this.logContext), v === PCTransportState.CONNECTED) {
          const I = this.pcState === PCState.New;
          this.pcState = PCState.Connected, I && this.emit(EngineEvent.Connected, u);
        } else
          v === PCTransportState.FAILED && this.pcState === PCState.Connected && (this.pcState = PCState.Disconnected, this.handleDisconnect("peerconnection failed", _ === "failed" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED));
      }), this.pcManager.onTrack = (v) => {
        this.emit(EngineEvent.MediaTrackAdded, v.track, v.streams[0], v.receiver);
      }, this.createDataChannels();
    });
  }
  setupSignalClientCallbacks() {
    this.client.onAnswer = (u) => __awaiter$3(this, void 0, void 0, function* () {
      this.pcManager && (this.log.debug("received server answer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: u.type
      })), yield this.pcManager.setPublisherAnswer(u));
    }), this.client.onTrickle = (u, c) => {
      this.pcManager && (this.log.trace("got ICE candidate from peer", Object.assign(Object.assign({}, this.logContext), {
        candidate: u,
        target: c
      })), this.pcManager.addIceCandidate(u, c));
    }, this.client.onOffer = (u) => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        return;
      const c = yield this.pcManager.createSubscriberAnswerFromOffer(u);
      this.client.sendAnswer(c);
    }), this.client.onLocalTrackPublished = (u) => {
      var c;
      if (this.log.debug("received trackPublishedResponse", Object.assign(Object.assign({}, this.logContext), {
        cid: u.cid,
        track: (c = u.track) === null || c === void 0 ? void 0 : c.sid
      })), !this.pendingTrackResolvers[u.cid]) {
        this.log.error("missing track resolver for ".concat(u.cid), Object.assign(Object.assign({}, this.logContext), {
          cid: u.cid
        }));
        return;
      }
      const {
        resolve: l
      } = this.pendingTrackResolvers[u.cid];
      delete this.pendingTrackResolvers[u.cid], l(u.track);
    }, this.client.onLocalTrackUnpublished = (u) => {
      this.emit(EngineEvent.LocalTrackUnpublished, u);
    }, this.client.onTokenRefresh = (u) => {
      this.token = u;
    }, this.client.onRemoteMuteChanged = (u, c) => {
      this.emit(EngineEvent.RemoteMute, u, c);
    }, this.client.onSubscribedQualityUpdate = (u) => {
      this.emit(EngineEvent.SubscribedQualityUpdate, u);
    }, this.client.onClose = () => {
      this.handleDisconnect("signal", ReconnectReason.RR_SIGNAL_DISCONNECTED);
    }, this.client.onLeave = (u) => {
      u != null && u.canReconnect ? (this.fullReconnectOnNext = !0, this.handleDisconnect(leaveReconnect)) : (this.emit(EngineEvent.Disconnected, u == null ? void 0 : u.reason), this.close()), this.log.debug("client leave request", Object.assign(Object.assign({}, this.logContext), {
        reason: u == null ? void 0 : u.reason
      }));
    };
  }
  makeRTCConfiguration(u) {
    var c;
    const l = Object.assign({}, this.rtcConfig);
    if (!((c = this.signalOpts) === null || c === void 0) && c.e2eeEnabled && (this.log.debug("E2EE - setting up transports with insertable streams", this.logContext), l.encodedInsertableStreams = !0), u.iceServers && !l.iceServers) {
      const v = [];
      u.iceServers.forEach((p) => {
        const _ = {
          urls: p.urls
        };
        p.username && (_.username = p.username), p.credential && (_.credential = p.credential), v.push(_);
      }), l.iceServers = v;
    }
    return u.clientConfiguration && u.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED && (l.iceTransportPolicy = "relay"), l.sdpSemantics = "unified-plan", l.continualGatheringPolicy = "gather_continually", l;
  }
  createDataChannels() {
    this.pcManager && (this.lossyDC && (this.lossyDC.onmessage = null, this.lossyDC.onerror = null), this.reliableDC && (this.reliableDC.onmessage = null, this.reliableDC.onerror = null), this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {
      // will drop older packets that arrive
      ordered: !0,
      maxRetransmits: 0
    }), this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {
      ordered: !0
    }), this.lossyDC.onmessage = this.handleDataMessage, this.reliableDC.onmessage = this.handleDataMessage, this.lossyDC.onerror = this.handleDataError, this.reliableDC.onerror = this.handleDataError, this.lossyDC.bufferedAmountLowThreshold = 65535, this.reliableDC.bufferedAmountLowThreshold = 65535, this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow, this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow);
  }
  setPreferredCodec(u, c, l) {
    if (!("getCapabilities" in RTCRtpSender))
      return;
    const v = RTCRtpSender.getCapabilities(c);
    if (!v)
      return;
    this.log.debug("get sender capabilities", Object.assign(Object.assign({}, this.logContext), {
      cap: v
    }));
    const p = [], _ = [], I = [];
    v.codecs.forEach((P) => {
      const $ = P.mimeType.toLowerCase();
      if ($ === "audio/opus") {
        p.push(P);
        return;
      }
      if (!($ === "video/".concat(l))) {
        I.push(P);
        return;
      }
      if (l === "h264") {
        P.sdpFmtpLine && P.sdpFmtpLine.includes("profile-level-id=42e01f") ? p.push(P) : _.push(P);
        return;
      }
      p.push(P);
    }), supportsSetCodecPreferences(u) && u.setCodecPreferences(p.concat(_, I));
  }
  createSender(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (supportsTransceiver())
        return yield this.createTransceiverRTCRtpSender(u, c, l);
      if (supportsAddTrack())
        return this.log.warn("using add-track fallback", this.logContext), yield this.createRTCRtpSender(u.mediaStreamTrack);
      throw new UnexpectedConnectionState("Required webRTC APIs not supported on this device");
    });
  }
  createSimulcastSender(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (supportsTransceiver())
        return this.createSimulcastTransceiverSender(u, c, l, v);
      if (supportsAddTrack())
        return this.log.debug("using add-track fallback", this.logContext), this.createRTCRtpSender(u.mediaStreamTrack);
      throw new UnexpectedConnectionState("Cannot stream on this device");
    });
  }
  createTransceiverRTCRtpSender(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      const v = [];
      u.mediaStream && v.push(u.mediaStream);
      const p = {
        direction: "sendonly",
        streams: v
      };
      l && (p.sendEncodings = l);
      const _ = yield this.pcManager.addPublisherTransceiver(u.mediaStreamTrack, p);
      return u.kind === Track.Kind.Video && c.videoCodec && (this.setPreferredCodec(_, u.kind, c.videoCodec), u.codec = c.videoCodec), _.sender;
    });
  }
  createSimulcastTransceiverSender(u, c, l, v) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      const p = {
        direction: "sendonly"
      };
      v && (p.sendEncodings = v);
      const _ = yield this.pcManager.addPublisherTransceiver(c.mediaStreamTrack, p);
      if (l.videoCodec)
        return this.setPreferredCodec(_, u.kind, l.videoCodec), u.setSimulcastTrackSender(l.videoCodec, _.sender), _.sender;
    });
  }
  createRTCRtpSender(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      return this.pcManager.addPublisherTrack(u);
    });
  }
  attemptReconnect(u) {
    var c, l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this._isClosed) {
        if (this.attemptingReconnect) {
          livekitLogger.warn("already attempting reconnect, returning early", this.logContext);
          return;
        }
        (((c = this.clientConfiguration) === null || c === void 0 ? void 0 : c.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep
        // those connections cannot be resumed
        ((v = (l = this.pcManager) === null || l === void 0 ? void 0 : l.currentState) !== null && v !== void 0 ? v : PCTransportState.NEW) === PCTransportState.NEW) && (this.fullReconnectOnNext = !0);
        try {
          this.attemptingReconnect = !0, this.fullReconnectOnNext ? yield this.restartConnection() : yield this.resumeConnection(u), this.clearPendingReconnect(), this.fullReconnectOnNext = !1;
        } catch (p) {
          this.reconnectAttempts += 1;
          let _ = !0;
          p instanceof UnexpectedConnectionState ? (this.log.debug("received unrecoverable error", Object.assign(Object.assign({}, this.logContext), {
            error: p
          })), _ = !1) : p instanceof SignalReconnectError || (this.fullReconnectOnNext = !0), _ ? this.handleDisconnect("reconnect", ReconnectReason.RR_UNKNOWN) : (this.log.info("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(Date.now() - this.reconnectStart, "ms. giving up"), this.logContext), this.emit(EngineEvent.Disconnected), yield this.close());
        } finally {
          this.attemptingReconnect = !1;
        }
      }
    });
  }
  getNextRetryDelay(u) {
    try {
      return this.reconnectPolicy.nextRetryDelayInMs(u);
    } catch (c) {
      this.log.warn("encountered error in reconnect policy", Object.assign(Object.assign({}, this.logContext), {
        error: c
      }));
    }
    return null;
  }
  restartConnection(u) {
    var c, l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      try {
        if (!this.url || !this.token)
          throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
        this.log.info("reconnecting, attempt: ".concat(this.reconnectAttempts), this.logContext), this.emit(EngineEvent.Restarting), this.client.isDisconnected || (yield this.client.sendLeave()), yield this.cleanupPeerConnections(), yield this.cleanupClient();
        let p;
        try {
          if (!this.signalOpts)
            throw this.log.warn("attempted connection restart, without signal options present", this.logContext), new SignalReconnectError();
          p = yield this.join(u ?? this.url, this.token, this.signalOpts);
        } catch (_) {
          throw _ instanceof ConnectionError && _.reason === 0 ? new UnexpectedConnectionState("could not reconnect, token might be expired") : new SignalReconnectError();
        }
        if (this.shouldFailNext)
          throw this.shouldFailNext = !1, new Error("simulated failure");
        if (this.client.setReconnected(), this.emit(EngineEvent.SignalRestarted, p), yield this.waitForPCReconnected(), this.client.currentState !== SignalConnectionState.CONNECTED)
          throw new SignalReconnectError("Signal connection got severed during reconnect");
        (c = this.regionUrlProvider) === null || c === void 0 || c.resetAttempts(), this.emit(EngineEvent.Restarted);
      } catch (p) {
        const _ = yield (l = this.regionUrlProvider) === null || l === void 0 ? void 0 : l.getNextBestRegionUrl();
        if (_) {
          yield this.restartConnection(_);
          return;
        } else
          throw (v = this.regionUrlProvider) === null || v === void 0 || v.resetAttempts(), p;
      }
    });
  }
  resumeConnection(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.url || !this.token)
        throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher and subscriber connections unset");
      this.log.info("resuming signal connection, attempt ".concat(this.reconnectAttempts), this.logContext), this.emit(EngineEvent.Resuming);
      try {
        this.setupSignalClientCallbacks();
        const l = yield this.client.reconnect(this.url, this.token, this.participantSid, u);
        if (l) {
          const v = this.makeRTCConfiguration(l);
          this.pcManager.updateConfiguration(v);
        }
      } catch (l) {
        let v = "";
        throw l instanceof Error && (v = l.message, this.log.error(l.message, Object.assign(Object.assign({}, this.logContext), {
          error: l
        }))), l instanceof ConnectionError && l.reason === 0 ? new UnexpectedConnectionState("could not reconnect, token might be expired") : l instanceof ConnectionError && l.reason === 4 ? l : new SignalReconnectError(v);
      }
      if (this.emit(EngineEvent.SignalResumed), this.shouldFailNext)
        throw this.shouldFailNext = !1, new Error("simulated failure");
      if (yield this.pcManager.triggerIceRestart(), yield this.waitForPCReconnected(), this.client.currentState !== SignalConnectionState.CONNECTED)
        throw new SignalReconnectError("Signal connection got severed during reconnect");
      this.client.setReconnected(), ((c = this.reliableDC) === null || c === void 0 ? void 0 : c.readyState) === "open" && this.reliableDC.id === null && this.createDataChannels(), this.emit(EngineEvent.Resumed);
    });
  }
  waitForPCInitialConnection(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("PC manager is closed");
      yield this.pcManager.ensurePCTransportConnection(c, u);
    });
  }
  waitForPCReconnected() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.pcState = PCState.Reconnecting, this.log.debug("waiting for peer connection to reconnect", this.logContext);
      try {
        if (yield sleep(minReconnectWait), !this.pcManager)
          throw new UnexpectedConnectionState("PC manager is closed");
        yield this.pcManager.ensurePCTransportConnection(void 0, this.peerConnectionTimeout), this.pcState = PCState.Connected;
      } catch (u) {
        throw this.pcState = PCState.Disconnected, new ConnectionError("could not establish PC connection, ".concat(u.message));
      }
    });
  }
  /* @internal */
  sendDataPacket(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = u.toBinary();
      yield this.ensurePublisherConnected(c);
      const v = this.dataChannelForKind(c);
      v && v.send(l), this.updateAndEmitDCBufferStatus(c);
    });
  }
  /**
   * @internal
   */
  ensureDataTransportConnected(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;
    var l;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("PC manager is closed");
      const v = c ? this.pcManager.subscriber : this.pcManager.publisher, p = c ? "Subscriber" : "Publisher";
      if (!v)
        throw new ConnectionError("".concat(p, " connection not set"));
      !c && !this.pcManager.publisher.isICEConnected && this.pcManager.publisher.getICEConnectionState() !== "checking" && this.negotiate();
      const _ = this.dataChannelForKind(u, c);
      if ((_ == null ? void 0 : _.readyState) === "open")
        return;
      const I = (/* @__PURE__ */ new Date()).getTime() + this.peerConnectionTimeout;
      for (; (/* @__PURE__ */ new Date()).getTime() < I; ) {
        if (v.isICEConnected && ((l = this.dataChannelForKind(u, c)) === null || l === void 0 ? void 0 : l.readyState) === "open")
          return;
        yield sleep(50);
      }
      throw new ConnectionError("could not establish ".concat(p, " connection, state: ").concat(v.getICEConnectionState()));
    });
  }
  ensurePublisherConnected(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      yield this.ensureDataTransportConnected(u, !1);
    });
  }
  /* @internal */
  verifyTransport() {
    return !(!this.pcManager || this.pcManager.currentState !== PCTransportState.CONNECTED || !this.client.ws || this.client.ws.readyState === WebSocket.CLOSED);
  }
  /** @internal */
  negotiate() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return new Promise((u, c) => __awaiter$3(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          c(new NegotiationError("PC manager is closed"));
          return;
        }
        this.pcManager.requirePublisher();
        const l = new AbortController(), v = () => {
          l.abort(), this.log.debug("engine disconnected while negotiation was ongoing", this.logContext), u();
        };
        this.isClosed && c("cannot negotiate on closed engine"), this.on(EngineEvent.Closing, v), this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (p) => {
          const _ = /* @__PURE__ */ new Map();
          p.forEach((I) => {
            const P = I.codec.toLowerCase();
            isVideoCodec(P) && _.set(I.payload, P);
          }), this.emit(EngineEvent.RTPVideoMapUpdate, _);
        });
        try {
          yield this.pcManager.negotiate(l), u();
        } catch (p) {
          p instanceof NegotiationError && (this.fullReconnectOnNext = !0), this.handleDisconnect("negotiation", ReconnectReason.RR_UNKNOWN), c(p);
        } finally {
          this.off(EngineEvent.Closing, v);
        }
      }));
    });
  }
  dataChannelForKind(u, c) {
    if (c) {
      if (u === DataPacket_Kind.LOSSY)
        return this.lossyDCSub;
      if (u === DataPacket_Kind.RELIABLE)
        return this.reliableDCSub;
    } else {
      if (u === DataPacket_Kind.LOSSY)
        return this.lossyDC;
      if (u === DataPacket_Kind.RELIABLE)
        return this.reliableDC;
    }
  }
  /** @internal */
  sendSyncState(u, c) {
    var l, v;
    if (!this.pcManager) {
      this.log.warn("sync state cannot be sent without peer connection setup", this.logContext);
      return;
    }
    const p = this.pcManager.subscriber.getLocalDescription(), _ = this.pcManager.subscriber.getRemoteDescription(), I = (v = (l = this.signalOpts) === null || l === void 0 ? void 0 : l.autoSubscribe) !== null && v !== void 0 ? v : !0, P = new Array(), $ = new Array();
    u.forEach((F) => {
      F.isDesired !== I && P.push(F.trackSid), F.isEnabled || $.push(F.trackSid);
    }), this.client.sendSyncState(new SyncState({
      answer: p ? toProtoSessionDescription({
        sdp: p.sdp,
        type: p.type
      }) : void 0,
      offer: _ ? toProtoSessionDescription({
        sdp: _.sdp,
        type: _.type
      }) : void 0,
      subscription: new UpdateSubscription({
        trackSids: P,
        subscribe: !I,
        participantTracks: []
      }),
      publishTracks: getTrackPublicationInfo(c),
      dataChannels: this.dataChannelsInfo(),
      trackSidsDisabled: $
    }));
  }
  /* @internal */
  failNext() {
    this.shouldFailNext = !0;
  }
  dataChannelsInfo() {
    const u = [], c = (l, v) => {
      (l == null ? void 0 : l.id) !== void 0 && l.id !== null && u.push(new DataChannelInfo({
        label: l.label,
        id: l.id,
        target: v
      }));
    };
    return c(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER), c(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER), c(this.dataChannelForKind(DataPacket_Kind.LOSSY, !0), SignalTarget.SUBSCRIBER), c(this.dataChannelForKind(DataPacket_Kind.RELIABLE, !0), SignalTarget.SUBSCRIBER), u;
  }
  clearReconnectTimeout() {
    this.reconnectTimeout && CriticalTimers.clearTimeout(this.reconnectTimeout);
  }
  clearPendingReconnect() {
    this.clearReconnectTimeout(), this.reconnectAttempts = 0;
  }
  registerOnLineListener() {
    isWeb() && window.addEventListener("online", this.handleBrowserOnLine);
  }
  deregisterOnLineListener() {
    isWeb() && window.removeEventListener("online", this.handleBrowserOnLine);
  }
}
class SignalReconnectError extends Error {
}
class RegionUrlProvider {
  constructor(u, c) {
    this.lastUpdateAt = 0, this.settingsCacheTime = 3e3, this.attemptedRegions = [], this.serverUrl = new URL(u), this.token = c;
  }
  updateToken(u) {
    this.token = u;
  }
  isCloud() {
    return isCloud(this.serverUrl);
  }
  getServerUrl() {
    return this.serverUrl;
  }
  getNextBestRegionUrl(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.isCloud())
        throw Error("region availability is only supported for LiveKit Cloud domains");
      (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) && (this.regionSettings = yield this.fetchRegionSettings(u));
      const c = this.regionSettings.regions.filter((l) => !this.attemptedRegions.find((v) => v.url === l.url));
      if (c.length > 0) {
        const l = c[0];
        return this.attemptedRegions.push(l), livekitLogger.debug("next region: ".concat(l.region)), l.url;
      } else
        return null;
    });
  }
  resetAttempts() {
    this.attemptedRegions = [];
  }
  /* @internal */
  fetchRegionSettings(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield fetch("".concat(getCloudConfigUrl(this.serverUrl), "/regions"), {
        headers: {
          authorization: "Bearer ".concat(this.token)
        },
        signal: u
      });
      if (c.ok) {
        const l = yield c.json();
        return this.lastUpdateAt = Date.now(), l;
      } else
        throw new ConnectionError("Could not fetch region settings: ".concat(c.statusText), c.status === 401 ? 0 : void 0, c.status);
    });
  }
}
function getCloudConfigUrl(a) {
  return "".concat(a.protocol.replace("ws", "http"), "//").concat(a.host, "/settings");
}
const monitorFrequency = 2e3;
function computeBitrate(a, u) {
  if (!u)
    return 0;
  let c, l;
  return "bytesReceived" in a ? (c = a.bytesReceived, l = u.bytesReceived) : "bytesSent" in a && (c = a.bytesSent, l = u.bytesSent), c === void 0 || l === void 0 || a.timestamp === void 0 || u.timestamp === void 0 ? 0 : (c - l) * 8 * 1e3 / (a.timestamp - u.timestamp);
}
class LocalAudioTrack extends LocalTrack {
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, v = arguments.length > 3 ? arguments[3] : void 0, p = arguments.length > 4 ? arguments[4] : void 0;
    super(u, Track.Kind.Audio, c, l, p), this.stopOnMute = !1, this.monitorSender = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let _;
      try {
        _ = yield this.getSenderStats();
      } catch (I) {
        this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: I
        }));
        return;
      }
      _ && this.prevStats && (this._currentBitrate = computeBitrate(_, this.prevStats)), this.prevStats = _;
    }), this.audioContext = v, this.checkForSilence();
  }
  setDeviceId(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._constraints.deviceId === u ? !0 : (this._constraints.deviceId = u, this.isMuted || (yield this.restartTrack()), this.isMuted || unwrapConstraint(u) === this.mediaStreamTrack.getSettings().deviceId);
    });
  }
  mute() {
    const u = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided && (this.log.debug("stopping mic track", this.logContext), this._mediaStreamTrack.stop()), yield u.mute.call(this), this;
      } finally {
        c();
      }
    });
  }
  unmute() {
    const u = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        const l = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);
        return this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === "ended" || l) && !this.isUserProvided && (this.log.debug("reacquiring mic track", this.logContext), yield this.restartTrack()), yield u.unmute.call(this), this;
      } finally {
        c();
      }
    });
  }
  restartTrack(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let c;
      if (u) {
        const l = constraintsForOptions({
          audio: u
        });
        typeof l.audio != "boolean" && (c = l.audio);
      }
      yield this.restart(c);
    });
  }
  restart(u) {
    const c = Object.create(null, {
      restart: {
        get: () => super.restart
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = yield c.restart.call(this, u);
      return this.checkForSilence(), l;
    });
  }
  /* @internal */
  startMonitor() {
    isWeb() && (this.monitorInterval || (this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency)));
  }
  setProcessor(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = yield this.processorLock.lock();
      try {
        if (!this.audioContext)
          throw Error("Audio context needs to be set on LocalAudioTrack in order to enable processors");
        if (this.processor && (yield this.stopProcessor()), this.kind === "unknown")
          throw TypeError("cannot set processor on track of unknown kind");
        const v = {
          kind: this.kind,
          track: this._mediaStreamTrack,
          audioContext: this.audioContext
        };
        this.log.debug("setting up audio processor ".concat(u.name), this.logContext), yield u.init(v), this.processor = u, this.processor.processedTrack && (yield (c = this.sender) === null || c === void 0 ? void 0 : c.replaceTrack(this.processor.processedTrack));
      } finally {
        l();
      }
    });
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(u) {
    this.audioContext = u;
  }
  getSenderStats() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!(!((u = this.sender) === null || u === void 0) && u.getStats))
        return;
      const c = yield this.sender.getStats();
      let l;
      return c.forEach((v) => {
        v.type === "outbound-rtp" && (l = {
          type: "audio",
          streamId: v.id,
          packetsSent: v.packetsSent,
          packetsLost: v.packetsLost,
          bytesSent: v.bytesSent,
          timestamp: v.timestamp,
          roundTripTime: v.roundTripTime,
          jitter: v.jitter
        });
      }), l;
    });
  }
  checkForSilence() {
    return __awaiter$3(this, void 0, void 0, function* () {
      const u = yield detectSilence(this);
      return u && (this.isMuted || this.log.warn("silence detected on local audio track", this.logContext), this.emit(TrackEvent.AudioSilenceDetected)), u;
    });
  }
}
function mediaTrackToLocalTrack(a, u, c) {
  switch (a.kind) {
    case "audio":
      return new LocalAudioTrack(a, u, !1, void 0, c);
    case "video":
      return new LocalVideoTrack(a, u, !1, c);
    default:
      throw new TrackInvalidError("unsupported track type: ".concat(a.kind));
  }
}
const presets169 = Object.values(VideoPresets), presets43 = Object.values(VideoPresets43), presetsScreenShare = Object.values(ScreenSharePresets), defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360], defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360], computeDefaultScreenShareSimulcastPresets = (a) => [{
  scaleResolutionDownBy: 2,
  fps: a.encoding.maxFramerate
}].map((c) => {
  var l, v;
  return new VideoPreset(Math.floor(a.width / c.scaleResolutionDownBy), Math.floor(a.height / c.scaleResolutionDownBy), Math.max(15e4, Math.floor(a.encoding.maxBitrate / (Math.pow(c.scaleResolutionDownBy, 2) * (((l = a.encoding.maxFramerate) !== null && l !== void 0 ? l : 30) / ((v = c.fps) !== null && v !== void 0 ? v : 30))))), c.fps, a.encoding.priority);
}), videoRids = ["q", "h", "f"];
function computeVideoEncodings(a, u, c, l) {
  var v, p;
  let _ = l == null ? void 0 : l.videoEncoding;
  a && (_ = l == null ? void 0 : l.screenShareEncoding);
  const I = l == null ? void 0 : l.simulcast, P = l == null ? void 0 : l.scalabilityMode, $ = l == null ? void 0 : l.videoCodec;
  if (!_ && !I && !P || !u || !c)
    return [{}];
  _ || (_ = determineAppropriateEncoding(a, u, c, $), livekitLogger.debug("using video encoding", _));
  const F = new VideoPreset(u, c, _.maxBitrate, _.maxFramerate, _.priority);
  if (P && isSVCCodec($)) {
    livekitLogger.debug("using svc with scalabilityMode ".concat(P));
    const ee = new ScalabilityMode(P), X = [];
    if (ee.spatial > 3)
      throw new Error("unsupported scalabilityMode: ".concat(P));
    for (let ie = 0; ie < ee.spatial; ie += 1)
      X.push({
        rid: videoRids[2 - ie],
        maxBitrate: _.maxBitrate / Math.pow(3, ie),
        /* @ts-ignore */
        maxFramerate: F.encoding.maxFramerate
      });
    return X[0].scalabilityMode = P, livekitLogger.debug("encodings", X), X;
  }
  if (!I)
    return [_];
  let H = [];
  a ? H = (v = sortPresets(l == null ? void 0 : l.screenShareSimulcastLayers)) !== null && v !== void 0 ? v : defaultSimulcastLayers(a, F) : H = (p = sortPresets(l == null ? void 0 : l.videoSimulcastLayers)) !== null && p !== void 0 ? p : defaultSimulcastLayers(a, F);
  let j;
  if (H.length > 0) {
    const ee = H[0];
    H.length > 1 && ([, j] = H);
    const X = Math.max(u, c);
    if (X >= 960 && j)
      return encodingsFromPresets(u, c, [ee, j, F]);
    if (X >= 480)
      return encodingsFromPresets(u, c, [ee, F]);
  }
  return encodingsFromPresets(u, c, [F]);
}
function computeTrackBackupEncodings(a, u, c) {
  var l, v, p, _;
  if (!c.backupCodec || c.backupCodec === !0 || c.backupCodec.codec === c.videoCodec)
    return;
  u !== c.backupCodec.codec && livekitLogger.warn("requested a different codec than specified as backup", {
    serverRequested: u,
    backup: c.backupCodec.codec
  }), c.videoCodec = u, c.videoEncoding = c.backupCodec.encoding;
  const I = a.mediaStreamTrack.getSettings(), P = (l = I.width) !== null && l !== void 0 ? l : (v = a.dimensions) === null || v === void 0 ? void 0 : v.width, $ = (p = I.height) !== null && p !== void 0 ? p : (_ = a.dimensions) === null || _ === void 0 ? void 0 : _.height;
  return computeVideoEncodings(a.source === Track.Source.ScreenShare, P, $, c);
}
function determineAppropriateEncoding(a, u, c, l) {
  const v = presetsForResolution(a, u, c);
  let {
    encoding: p
  } = v[0];
  const _ = Math.max(u, c);
  for (let I = 0; I < v.length; I += 1) {
    const P = v[I];
    if (p = P.encoding, P.width >= _)
      break;
  }
  if (l)
    switch (l) {
      case "av1":
        p = Object.assign({}, p), p.maxBitrate = p.maxBitrate * 0.7;
        break;
      case "vp9":
        p = Object.assign({}, p), p.maxBitrate = p.maxBitrate * 0.85;
        break;
    }
  return p;
}
function presetsForResolution(a, u, c) {
  if (a)
    return presetsScreenShare;
  const l = u > c ? u / c : c / u;
  return Math.abs(l - 16 / 9) < Math.abs(l - 4 / 3) ? presets169 : presets43;
}
function defaultSimulcastLayers(a, u) {
  if (a)
    return computeDefaultScreenShareSimulcastPresets(u);
  const {
    width: c,
    height: l
  } = u, v = c > l ? c / l : l / c;
  return Math.abs(v - 16 / 9) < Math.abs(v - 4 / 3) ? defaultSimulcastPresets169 : defaultSimulcastPresets43;
}
function encodingsFromPresets(a, u, c) {
  const l = [];
  if (c.forEach((v, p) => {
    if (p >= videoRids.length)
      return;
    const _ = Math.min(a, u), P = {
      rid: videoRids[p],
      scaleResolutionDownBy: Math.max(1, _ / Math.min(v.width, v.height)),
      maxBitrate: v.encoding.maxBitrate
    };
    v.encoding.maxFramerate && (P.maxFramerate = v.encoding.maxFramerate);
    const $ = isFireFox() || p === 0;
    v.encoding.priority && $ && (P.priority = v.encoding.priority, P.networkPriority = v.encoding.priority), l.push(P);
  }), isReactNative() && getReactNativeOs() === "ios") {
    let v;
    l.forEach((_) => {
      v ? _.maxFramerate && _.maxFramerate > v && (v = _.maxFramerate) : v = _.maxFramerate;
    });
    let p = !0;
    l.forEach((_) => {
      var I;
      _.maxFramerate != v && (p && (p = !1, livekitLogger.info("Simulcast on iOS React-Native requires all encodings to share the same framerate.")), livekitLogger.info('Setting framerate of encoding "'.concat((I = _.rid) !== null && I !== void 0 ? I : "", '" to ').concat(v)), _.maxFramerate = v);
    });
  }
  return l;
}
function sortPresets(a) {
  if (a)
    return a.sort((u, c) => {
      const {
        encoding: l
      } = u, {
        encoding: v
      } = c;
      return l.maxBitrate > v.maxBitrate ? 1 : l.maxBitrate < v.maxBitrate ? -1 : l.maxBitrate === v.maxBitrate && l.maxFramerate && v.maxFramerate ? l.maxFramerate > v.maxFramerate ? 1 : -1 : 0;
    });
}
class ScalabilityMode {
  constructor(u) {
    const c = u.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
    if (!c)
      throw new Error("invalid scalability mode");
    if (this.spatial = parseInt(c[1]), this.temporal = parseInt(c[2]), c.length > 3)
      switch (c[3]) {
        case "h":
        case "_KEY":
        case "_KEY_SHIFT":
          this.suffix = c[3];
      }
  }
  toString() {
    var u;
    return "L".concat(this.spatial, "T").concat(this.temporal).concat((u = this.suffix) !== null && u !== void 0 ? u : "");
  }
}
const refreshSubscribedCodecAfterNewCodec = 5e3;
class LocalVideoTrack extends LocalTrack {
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, v = arguments.length > 3 ? arguments[3] : void 0;
    super(u, Track.Kind.Video, c, l, v), this.simulcastCodecs = /* @__PURE__ */ new Map(), this.monitorSender = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let p;
      try {
        p = yield this.getSenderStats();
      } catch (I) {
        this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: I
        }));
        return;
      }
      const _ = new Map(p.map((I) => [I.rid, I]));
      if (this.prevStats) {
        let I = 0;
        _.forEach((P, $) => {
          var F;
          const H = (F = this.prevStats) === null || F === void 0 ? void 0 : F.get($);
          I += computeBitrate(P, H);
        }), this._currentBitrate = I;
      }
      this.prevStats = _;
    }), this.senderLock = new Mutex();
  }
  get isSimulcast() {
    return !!(this.sender && this.sender.getParameters().encodings.length > 1);
  }
  /* @internal */
  startMonitor(u) {
    var c;
    if (this.signalClient = u, !isWeb())
      return;
    const l = (c = this.sender) === null || c === void 0 ? void 0 : c.getParameters();
    l && (this.encodings = l.encodings), !this.monitorInterval && (this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency));
  }
  stop() {
    this._mediaStreamTrack.getConstraints(), this.simulcastCodecs.forEach((u) => {
      u.mediaStreamTrack.stop();
    }), super.stop();
  }
  pauseUpstream() {
    const u = Object.create(null, {
      pauseUpstream: {
        get: () => super.pauseUpstream
      }
    });
    var c, l, v, p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.pauseUpstream.call(this);
      try {
        for (var I = !0, P = __asyncValues(this.simulcastCodecs.values()), $; $ = yield P.next(), c = $.done, !c; I = !0)
          p = $.value, I = !1, yield (_ = p.sender) === null || _ === void 0 ? void 0 : _.replaceTrack(null);
      } catch (F) {
        l = {
          error: F
        };
      } finally {
        try {
          !I && !c && (v = P.return) && (yield v.call(P));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  resumeUpstream() {
    const u = Object.create(null, {
      resumeUpstream: {
        get: () => super.resumeUpstream
      }
    });
    var c, l, v, p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.resumeUpstream.call(this);
      try {
        for (var I = !0, P = __asyncValues(this.simulcastCodecs.values()), $; $ = yield P.next(), c = $.done, !c; I = !0) {
          p = $.value, I = !1;
          const F = p;
          yield (_ = F.sender) === null || _ === void 0 ? void 0 : _.replaceTrack(F.mediaStreamTrack);
        }
      } catch (F) {
        l = {
          error: F
        };
      } finally {
        try {
          !I && !c && (v = P.return) && (yield v.call(P));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  mute() {
    const u = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.source === Track.Source.Camera && !this.isUserProvided && (this.log.debug("stopping camera track", this.logContext), this._mediaStreamTrack.stop()), yield u.mute.call(this), this;
      } finally {
        c();
      }
    });
  }
  unmute() {
    const u = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.source === Track.Source.Camera && !this.isUserProvided && (this.log.debug("reacquiring camera track", this.logContext), yield this.restartTrack()), yield u.unmute.call(this), this;
      } finally {
        c();
      }
    });
  }
  setTrackMuted(u) {
    super.setTrackMuted(u);
    for (const c of this.simulcastCodecs.values())
      c.mediaStreamTrack.enabled = !u;
  }
  getSenderStats() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!(!((u = this.sender) === null || u === void 0) && u.getStats))
        return [];
      const c = [], l = yield this.sender.getStats();
      return l.forEach((v) => {
        var p;
        if (v.type === "outbound-rtp") {
          const _ = {
            type: "video",
            streamId: v.id,
            frameHeight: v.frameHeight,
            frameWidth: v.frameWidth,
            firCount: v.firCount,
            pliCount: v.pliCount,
            nackCount: v.nackCount,
            packetsSent: v.packetsSent,
            bytesSent: v.bytesSent,
            framesSent: v.framesSent,
            timestamp: v.timestamp,
            rid: (p = v.rid) !== null && p !== void 0 ? p : v.id,
            retransmittedPacketsSent: v.retransmittedPacketsSent,
            qualityLimitationReason: v.qualityLimitationReason,
            qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges
          }, I = l.get(v.remoteId);
          I && (_.jitter = I.jitter, _.packetsLost = I.packetsLost, _.roundTripTime = I.roundTripTime), c.push(_);
        }
      }), c;
    });
  }
  setPublishingQuality(u) {
    const c = [];
    for (let l = VideoQuality.LOW; l <= VideoQuality.HIGH; l += 1)
      c.push(new SubscribedQuality({
        quality: l,
        enabled: l <= u
      }));
    this.log.debug("setting publishing quality. max quality ".concat(u), this.logContext), this.setPublishingLayers(c);
  }
  setDeviceId(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this._constraints.deviceId === u && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(u) ? !0 : (this._constraints.deviceId = u, this.isMuted || (yield this.restartTrack()), this.isMuted || unwrapConstraint(u) === this._mediaStreamTrack.getSettings().deviceId);
    });
  }
  restartTrack(u) {
    var c, l, v, p;
    return __awaiter$3(this, void 0, void 0, function* () {
      let _;
      if (u) {
        const F = constraintsForOptions({
          video: u
        });
        typeof F.video != "boolean" && (_ = F.video);
      }
      yield this.restart(_);
      try {
        for (var I = !0, P = __asyncValues(this.simulcastCodecs.values()), $; $ = yield P.next(), c = $.done, !c; I = !0) {
          p = $.value, I = !1;
          const F = p;
          F.sender && (F.mediaStreamTrack = this.mediaStreamTrack.clone(), yield F.sender.replaceTrack(F.mediaStreamTrack));
        }
      } catch (F) {
        l = {
          error: F
        };
      } finally {
        try {
          !I && !c && (v = P.return) && (yield v.call(P));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  setProcessor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const l = Object.create(null, {
      setProcessor: {
        get: () => super.setProcessor
      }
    });
    var v, p, _, I, P, $;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (yield l.setProcessor.call(this, u, c), !((P = this.processor) === null || P === void 0) && P.processedTrack)
        try {
          for (var F = !0, H = __asyncValues(this.simulcastCodecs.values()), j; j = yield H.next(), v = j.done, !v; F = !0)
            I = j.value, F = !1, yield ($ = I.sender) === null || $ === void 0 ? void 0 : $.replaceTrack(this.processor.processedTrack);
        } catch (ee) {
          p = {
            error: ee
          };
        } finally {
          try {
            !F && !v && (_ = H.return) && (yield _.call(H));
          } finally {
            if (p)
              throw p.error;
          }
        }
    });
  }
  addSimulcastTrack(u, c) {
    if (this.simulcastCodecs.has(u)) {
      this.log.error("".concat(u, " already added, skipping adding simulcast codec"), this.logContext);
      return;
    }
    const l = {
      codec: u,
      mediaStreamTrack: this.mediaStreamTrack.clone(),
      sender: void 0,
      encodings: c
    };
    return this.simulcastCodecs.set(u, l), l;
  }
  setSimulcastTrackSender(u, c) {
    const l = this.simulcastCodecs.get(u);
    l && (l.sender = c, setTimeout(() => {
      this.subscribedCodecs && this.setPublishingCodecs(this.subscribedCodecs);
    }, refreshSubscribedCodecAfterNewCodec));
  }
  /**
   * @internal
   * Sets codecs that should be publishing, returns new codecs that have not yet
   * been published
   */
  setPublishingCodecs(u) {
    var c, l, v, p, _, I, P;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.log.debug("setting publishing codecs", Object.assign(Object.assign({}, this.logContext), {
        codecs: u,
        currentCodec: this.codec
      })), !this.codec && u.length > 0)
        return yield this.setPublishingLayers(u[0].qualities), [];
      this.subscribedCodecs = u;
      const $ = [];
      try {
        for (c = !0, l = __asyncValues(u); v = yield l.next(), p = v.done, !p; c = !0) {
          P = v.value, c = !1;
          const F = P;
          if (!this.codec || this.codec === F.codec)
            yield this.setPublishingLayers(F.qualities);
          else {
            const H = this.simulcastCodecs.get(F.codec);
            if (this.log.debug("try setPublishingCodec for ".concat(F.codec), Object.assign(Object.assign({}, this.logContext), {
              simulcastCodecInfo: H
            })), !H || !H.sender) {
              for (const j of F.qualities)
                if (j.enabled) {
                  $.push(F.codec);
                  break;
                }
            } else
              H.encodings && (this.log.debug("try setPublishingLayersForSender ".concat(F.codec), this.logContext), yield setPublishingLayersForSender(H.sender, H.encodings, F.qualities, this.senderLock, this.log, this.logContext));
          }
        }
      } catch (F) {
        _ = {
          error: F
        };
      } finally {
        try {
          !c && !p && (I = l.return) && (yield I.call(l));
        } finally {
          if (_)
            throw _.error;
        }
      }
      return $;
    });
  }
  /**
   * @internal
   * Sets layers that should be publishing
   */
  setPublishingLayers(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.log.debug("setting publishing layers", Object.assign(Object.assign({}, this.logContext), {
        qualities: u
      })), !(!this.sender || !this.encodings) && (yield setPublishingLayersForSender(this.sender, this.encodings, u, this.senderLock, this.log, this.logContext));
    });
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), isMobile() && this.isInBackground && this.source === Track.Source.Camera && (this._mediaStreamTrack.enabled = !1);
    });
  }
}
function setPublishingLayersForSender(a, u, c, l, v, p) {
  return __awaiter$3(this, void 0, void 0, function* () {
    const _ = yield l.lock();
    v.debug("setPublishingLayersForSender", Object.assign(Object.assign({}, p), {
      sender: a,
      qualities: c,
      senderEncodings: u
    }));
    try {
      const I = a.getParameters(), {
        encodings: P
      } = I;
      if (!P)
        return;
      if (P.length !== u.length) {
        v.warn("cannot set publishing layers, encodings mismatch");
        return;
      }
      let $ = !1;
      !1 && P[0].scalabilityMode || P.forEach((H, j) => {
        var ee;
        let X = (ee = H.rid) !== null && ee !== void 0 ? ee : "";
        X === "" && (X = "q");
        const ie = videoQualityForRid(X), Q = c.find((ne) => ne.quality === ie);
        Q && H.active !== Q.enabled && ($ = !0, H.active = Q.enabled, v.debug("setting layer ".concat(Q.quality, " to ").concat(H.active ? "enabled" : "disabled"), p), isFireFox() && (Q.enabled ? (H.scaleResolutionDownBy = u[j].scaleResolutionDownBy, H.maxBitrate = u[j].maxBitrate, H.maxFrameRate = u[j].maxFrameRate) : (H.scaleResolutionDownBy = 4, H.maxBitrate = 10, H.maxFrameRate = 2)));
      }), $ && (I.encodings = P, v.debug("setting encodings", Object.assign(Object.assign({}, p), {
        encodings: I.encodings
      })), yield a.setParameters(I));
    } finally {
      _();
    }
  });
}
function videoQualityForRid(a) {
  switch (a) {
    case "f":
      return VideoQuality.HIGH;
    case "h":
      return VideoQuality.MEDIUM;
    case "q":
      return VideoQuality.LOW;
    default:
      return VideoQuality.HIGH;
  }
}
function videoLayersFromEncodings(a, u, c, l) {
  if (!c)
    return [new VideoLayer({
      quality: VideoQuality.HIGH,
      width: a,
      height: u,
      bitrate: 0,
      ssrc: 0
    })];
  if (l) {
    const v = c[0].scalabilityMode, p = new ScalabilityMode(v), _ = [];
    for (let I = 0; I < p.spatial; I += 1)
      _.push(new VideoLayer({
        quality: VideoQuality.HIGH - I,
        width: Math.ceil(a / Math.pow(2, I)),
        height: Math.ceil(u / Math.pow(2, I)),
        bitrate: c[0].maxBitrate ? Math.ceil(c[0].maxBitrate / Math.pow(3, I)) : 0,
        ssrc: 0
      }));
    return _;
  }
  return c.map((v) => {
    var p, _, I;
    const P = (p = v.scaleResolutionDownBy) !== null && p !== void 0 ? p : 1;
    let $ = videoQualityForRid((_ = v.rid) !== null && _ !== void 0 ? _ : "");
    return new VideoLayer({
      quality: $,
      width: Math.ceil(a / P),
      height: Math.ceil(u / P),
      bitrate: (I = v.maxBitrate) !== null && I !== void 0 ? I : 0,
      ssrc: 0
    });
  });
}
class RemoteTrack extends Track {
  constructor(u, c, l, v, p) {
    super(u, l, p), this.sid = c, this.receiver = v;
  }
  /** @internal */
  setMuted(u) {
    this.isMuted !== u && (this.isMuted = u, this._mediaStreamTrack.enabled = !u, this.emit(u ? TrackEvent.Muted : TrackEvent.Unmuted, this));
  }
  /** @internal */
  setMediaStream(u) {
    this.mediaStream = u;
    const c = (l) => {
      l.track === this._mediaStreamTrack && (u.removeEventListener("removetrack", c), this.receiver = void 0, this._currentBitrate = 0, this.emit(TrackEvent.Ended, this));
    };
    u.addEventListener("removetrack", c);
  }
  start() {
    this.startMonitor(), super.enable();
  }
  stop() {
    this.stopMonitor(), super.disable();
  }
  /**
   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return !((u = this.receiver) === null || u === void 0) && u.getStats ? yield this.receiver.getStats() : void 0;
    });
  }
  /* @internal */
  startMonitor() {
    this.monitorInterval || (this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency));
  }
}
class RemoteAudioTrack extends RemoteTrack {
  constructor(u, c, l, v, p, _) {
    super(u, c, Track.Kind.Audio, l, _), this.monitorReceiver = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const I = yield this.getReceiverStats();
      I && this.prevStats && this.receiver && (this._currentBitrate = computeBitrate(I, this.prevStats)), this.prevStats = I;
    }), this.audioContext = v, this.webAudioPluginNodes = [], p && (this.sinkId = p.deviceId);
  }
  /**
   * sets the volume for all attached audio elements
   */
  setVolume(u) {
    var c;
    for (const l of this.attachedElements)
      this.audioContext ? (c = this.gainNode) === null || c === void 0 || c.gain.setTargetAtTime(u, 0, 0.1) : l.volume = u;
    isReactNative() && this._mediaStreamTrack._setVolume(u), this.elementVolume = u;
  }
  /**
   * gets the volume of attached audio elements (loudest)
   */
  getVolume() {
    if (this.elementVolume)
      return this.elementVolume;
    if (isReactNative())
      return 1;
    let u = 0;
    return this.attachedElements.forEach((c) => {
      c.volume > u && (u = c.volume);
    }), u;
  }
  /**
   * calls setSinkId on all attached elements, if supported
   * @param deviceId audio output device
   */
  setSinkId(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.sinkId = u, yield Promise.all(this.attachedElements.map((c) => {
        if (supportsSetSinkId(c))
          return c.setSinkId(u);
      }));
    });
  }
  attach(u) {
    const c = this.attachedElements.length === 0;
    return u ? super.attach(u) : u = super.attach(), this.sinkId && supportsSetSinkId(u) && u.setSinkId(this.sinkId), this.audioContext && c && (this.log.debug("using audio context mapping", this.logContext), this.connectWebAudio(this.audioContext, u), u.volume = 0, u.muted = !0), this.elementVolume && this.setVolume(this.elementVolume), u;
  }
  detach(u) {
    let c;
    return u ? (c = super.detach(u), this.audioContext && (this.attachedElements.length > 0 ? this.connectWebAudio(this.audioContext, this.attachedElements[0]) : this.disconnectWebAudio())) : (c = super.detach(), this.disconnectWebAudio()), c;
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(u) {
    this.audioContext = u, u && this.attachedElements.length > 0 ? this.connectWebAudio(u, this.attachedElements[0]) : u || this.disconnectWebAudio();
  }
  /**
   * @internal
   * @experimental
   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.
   */
  setWebAudioPlugins(u) {
    this.webAudioPluginNodes = u, this.attachedElements.length > 0 && this.audioContext && this.connectWebAudio(this.audioContext, this.attachedElements[0]);
  }
  connectWebAudio(u, c) {
    this.disconnectWebAudio(), this.sourceNode = u.createMediaStreamSource(c.srcObject);
    let l = this.sourceNode;
    this.webAudioPluginNodes.forEach((v) => {
      l.connect(v), l = v;
    }), this.gainNode = u.createGain(), l.connect(this.gainNode), this.gainNode.connect(u.destination), this.elementVolume && this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1), u.state !== "running" && u.resume().then(() => {
      u.state !== "running" && this.emit(TrackEvent.AudioPlaybackFailed, new Error("Audio Context couldn't be started automatically"));
    }).catch((v) => {
      this.emit(TrackEvent.AudioPlaybackFailed, v);
    });
  }
  disconnectWebAudio() {
    var u, c;
    (u = this.gainNode) === null || u === void 0 || u.disconnect(), (c = this.sourceNode) === null || c === void 0 || c.disconnect(), this.gainNode = void 0, this.sourceNode = void 0;
  }
  getReceiverStats() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats)
        return;
      const u = yield this.receiver.getStats();
      let c;
      return u.forEach((l) => {
        l.type === "inbound-rtp" && (c = {
          type: "audio",
          timestamp: l.timestamp,
          jitter: l.jitter,
          bytesReceived: l.bytesReceived,
          concealedSamples: l.concealedSamples,
          concealmentEvents: l.concealmentEvents,
          silentConcealedSamples: l.silentConcealedSamples,
          silentConcealmentEvents: l.silentConcealmentEvents,
          totalAudioEnergy: l.totalAudioEnergy,
          totalSamplesDuration: l.totalSamplesDuration
        });
      }), c;
    });
  }
}
const REACTION_DELAY = 100;
class RemoteVideoTrack extends RemoteTrack {
  constructor(u, c, l, v, p) {
    super(u, c, Track.Kind.Video, l, p), this.elementInfos = [], this.monitorReceiver = () => __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const _ = yield this.getReceiverStats();
      _ && this.prevStats && this.receiver && (this._currentBitrate = computeBitrate(_, this.prevStats)), this.prevStats = _;
    }), this.debouncedHandleResize = r$1(() => {
      this.updateDimensions();
    }, REACTION_DELAY), this.adaptiveStreamSettings = v;
  }
  get isAdaptiveStream() {
    return this.adaptiveStreamSettings !== void 0;
  }
  /**
   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start
   */
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /** @internal */
  setMuted(u) {
    super.setMuted(u), this.attachedElements.forEach((c) => {
      u ? detachTrack(this._mediaStreamTrack, c) : attachToElement(this._mediaStreamTrack, c);
    });
  }
  attach(u) {
    if (u ? super.attach(u) : u = super.attach(), this.adaptiveStreamSettings && this.elementInfos.find((c) => c.element === u) === void 0) {
      const c = new HTMLElementInfo(u);
      this.observeElementInfo(c);
    }
    return u;
  }
  /**
   * Observe an ElementInfo for changes when adaptive streaming.
   * @param elementInfo
   * @internal
   */
  observeElementInfo(u) {
    this.adaptiveStreamSettings && this.elementInfos.find((c) => c === u) === void 0 ? (u.handleResize = () => {
      this.debouncedHandleResize();
    }, u.handleVisibilityChanged = () => {
      this.updateVisibility();
    }, this.elementInfos.push(u), u.observe(), this.debouncedHandleResize(), this.updateVisibility()) : this.log.warn("visibility resize observer not triggered", this.logContext);
  }
  /**
   * Stop observing an ElementInfo for changes.
   * @param elementInfo
   * @internal
   */
  stopObservingElementInfo(u) {
    if (!this.isAdaptiveStream) {
      this.log.warn("stopObservingElementInfo ignored", this.logContext);
      return;
    }
    const c = this.elementInfos.filter((l) => l === u);
    for (const l of c)
      l.stopObserving();
    this.elementInfos = this.elementInfos.filter((l) => l !== u), this.updateVisibility(), this.debouncedHandleResize();
  }
  detach(u) {
    let c = [];
    if (u)
      return this.stopObservingElement(u), super.detach(u);
    c = super.detach();
    for (const l of c)
      this.stopObservingElement(l);
    return c;
  }
  /** @internal */
  getDecoderImplementation() {
    var u;
    return (u = this.prevStats) === null || u === void 0 ? void 0 : u.decoderImplementation;
  }
  getReceiverStats() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats)
        return;
      const u = yield this.receiver.getStats();
      let c, l = "", v = /* @__PURE__ */ new Map();
      return u.forEach((p) => {
        p.type === "inbound-rtp" ? (l = p.codecId, c = {
          type: "video",
          framesDecoded: p.framesDecoded,
          framesDropped: p.framesDropped,
          framesReceived: p.framesReceived,
          packetsReceived: p.packetsReceived,
          packetsLost: p.packetsLost,
          frameWidth: p.frameWidth,
          frameHeight: p.frameHeight,
          pliCount: p.pliCount,
          firCount: p.firCount,
          nackCount: p.nackCount,
          jitter: p.jitter,
          timestamp: p.timestamp,
          bytesReceived: p.bytesReceived,
          decoderImplementation: p.decoderImplementation
        }) : p.type === "codec" && v.set(p.id, p);
      }), c && l !== "" && v.get(l) && (c.mimeType = v.get(l).mimeType), c;
    });
  }
  stopObservingElement(u) {
    const c = this.elementInfos.filter((l) => l.element === u);
    for (const l of c)
      this.stopObservingElementInfo(l);
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter$3(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), this.isAdaptiveStream && this.updateVisibility();
    });
  }
  updateVisibility() {
    var u, c;
    const l = this.elementInfos.reduce((I, P) => Math.max(I, P.visibilityChangedAt || 0), 0), v = !((c = (u = this.adaptiveStreamSettings) === null || u === void 0 ? void 0 : u.pauseVideoInBackground) !== null && c !== void 0) || c ? this.isInBackground : !1, p = this.elementInfos.some((I) => I.pictureInPicture), _ = this.elementInfos.some((I) => I.visible) && !v || p;
    if (this.lastVisible !== _) {
      if (!_ && Date.now() - l < REACTION_DELAY) {
        CriticalTimers.setTimeout(() => {
          this.updateVisibility();
        }, REACTION_DELAY);
        return;
      }
      this.lastVisible = _, this.emit(TrackEvent.VisibilityChanged, _, this);
    }
  }
  updateDimensions() {
    var u, c;
    let l = 0, v = 0;
    const p = this.getPixelDensity();
    for (const _ of this.elementInfos) {
      const I = _.width() * p, P = _.height() * p;
      I + P > l + v && (l = I, v = P);
    }
    ((u = this.lastDimensions) === null || u === void 0 ? void 0 : u.width) === l && ((c = this.lastDimensions) === null || c === void 0 ? void 0 : c.height) === v || (this.lastDimensions = {
      width: l,
      height: v
    }, this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this));
  }
  getPixelDensity() {
    var u;
    const c = (u = this.adaptiveStreamSettings) === null || u === void 0 ? void 0 : u.pixelDensity;
    return c === "screen" ? getDevicePixelRatio() : c || (getDevicePixelRatio() > 2 ? 2 : 1);
  }
}
class HTMLElementInfo {
  get visible() {
    return this.isPiP || this.isIntersecting;
  }
  get pictureInPicture() {
    return this.isPiP;
  }
  constructor(u, c) {
    this.onVisibilityChanged = (l) => {
      var v;
      const {
        target: p,
        isIntersecting: _
      } = l;
      p === this.element && (this.isIntersecting = _, this.visibilityChangedAt = Date.now(), (v = this.handleVisibilityChanged) === null || v === void 0 || v.call(this));
    }, this.onEnterPiP = () => {
      var l;
      this.isPiP = !0, (l = this.handleVisibilityChanged) === null || l === void 0 || l.call(this);
    }, this.onLeavePiP = () => {
      var l;
      this.isPiP = !1, (l = this.handleVisibilityChanged) === null || l === void 0 || l.call(this);
    }, this.element = u, this.isIntersecting = c ?? isElementInViewport(u), this.isPiP = isWeb() && document.pictureInPictureElement === u, this.visibilityChangedAt = 0;
  }
  width() {
    return this.element.clientWidth;
  }
  height() {
    return this.element.clientHeight;
  }
  observe() {
    this.isIntersecting = isElementInViewport(this.element), this.isPiP = document.pictureInPictureElement === this.element, this.element.handleResize = () => {
      var u;
      (u = this.handleResize) === null || u === void 0 || u.call(this);
    }, this.element.handleVisibilityChanged = this.onVisibilityChanged, getIntersectionObserver().observe(this.element), getResizeObserver().observe(this.element), this.element.addEventListener("enterpictureinpicture", this.onEnterPiP), this.element.addEventListener("leavepictureinpicture", this.onLeavePiP);
  }
  stopObserving() {
    var u, c;
    (u = getIntersectionObserver()) === null || u === void 0 || u.unobserve(this.element), (c = getResizeObserver()) === null || c === void 0 || c.unobserve(this.element), this.element.removeEventListener("enterpictureinpicture", this.onEnterPiP), this.element.removeEventListener("leavepictureinpicture", this.onLeavePiP);
  }
}
function isElementInViewport(a) {
  let u = a.offsetTop, c = a.offsetLeft;
  const l = a.offsetWidth, v = a.offsetHeight, {
    hidden: p
  } = a, {
    opacity: _,
    display: I
  } = getComputedStyle(a);
  for (; a.offsetParent; )
    a = a.offsetParent, u += a.offsetTop, c += a.offsetLeft;
  return u < window.pageYOffset + window.innerHeight && c < window.pageXOffset + window.innerWidth && u + v > window.pageYOffset && c + l > window.pageXOffset && !p && (_ !== "" ? parseFloat(_) > 0 : !0) && I !== "none";
}
class TrackPublication extends eventsExports$1.EventEmitter {
  constructor(u, c, l, v) {
    var p;
    super(), this.metadataMuted = !1, this.encryption = Encryption_Type.NONE, this.log = livekitLogger, this.handleMuted = () => {
      this.emit(TrackEvent.Muted);
    }, this.handleUnmuted = () => {
      this.emit(TrackEvent.Unmuted);
    }, this.log = getLogger((p = v == null ? void 0 : v.loggerName) !== null && p !== void 0 ? p : LoggerNames.Publication), this.loggerContextCb = this.loggerContextCb, this.setMaxListeners(100), this.kind = u, this.trackSid = c, this.trackName = l, this.source = Track.Source.Unknown;
  }
  /** @internal */
  setTrack(u) {
    this.track && (this.track.off(TrackEvent.Muted, this.handleMuted), this.track.off(TrackEvent.Unmuted, this.handleUnmuted)), this.track = u, u && (u.on(TrackEvent.Muted, this.handleMuted), u.on(TrackEvent.Unmuted, this.handleUnmuted));
  }
  get logContext() {
    var u;
    return Object.assign(Object.assign({}, (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)), getLogContextFromTrack(this));
  }
  get isMuted() {
    return this.metadataMuted;
  }
  get isEnabled() {
    return !0;
  }
  get isSubscribed() {
    return this.track !== void 0;
  }
  get isEncrypted() {
    return this.encryption !== Encryption_Type.NONE;
  }
  /**
   * an [AudioTrack] if this publication holds an audio track
   */
  get audioTrack() {
    if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack)
      return this.track;
  }
  /**
   * an [VideoTrack] if this publication holds a video track
   */
  get videoTrack() {
    if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack)
      return this.track;
  }
  /** @internal */
  updateInfo(u) {
    this.trackSid = u.sid, this.trackName = u.name, this.source = Track.sourceFromProto(u.source), this.mimeType = u.mimeType, this.kind === Track.Kind.Video && u.width > 0 && (this.dimensions = {
      width: u.width,
      height: u.height
    }, this.simulcasted = u.simulcast), this.encryption = u.encryption, this.trackInfo = u, this.log.debug("update publication info", Object.assign(Object.assign({}, this.logContext), {
      info: u
    }));
  }
}
(function(a) {
  (function(u) {
    u.Desired = "desired", u.Subscribed = "subscribed", u.Unsubscribed = "unsubscribed";
  })(a.SubscriptionStatus || (a.SubscriptionStatus = {})), function(u) {
    u.Allowed = "allowed", u.NotAllowed = "not_allowed";
  }(a.PermissionStatus || (a.PermissionStatus = {}));
})(TrackPublication || (TrackPublication = {}));
class LocalTrackPublication extends TrackPublication {
  get isUpstreamPaused() {
    var u;
    return (u = this.track) === null || u === void 0 ? void 0 : u.isUpstreamPaused;
  }
  constructor(u, c, l, v) {
    super(u, c.sid, c.name, v), this.track = void 0, this.handleTrackEnded = () => {
      this.emit(TrackEvent.Ended);
    }, this.updateInfo(c), this.setTrack(l);
  }
  setTrack(u) {
    this.track && this.track.off(TrackEvent.Ended, this.handleTrackEnded), super.setTrack(u), u && u.on(TrackEvent.Ended, this.handleTrackEnded);
  }
  get isMuted() {
    return this.track ? this.track.isMuted : super.isMuted;
  }
  get audioTrack() {
    return super.audioTrack;
  }
  get videoTrack() {
    return super.videoTrack;
  }
  /**
   * Mute the track associated with this publication
   */
  mute() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return (u = this.track) === null || u === void 0 ? void 0 : u.mute();
    });
  }
  /**
   * Unmute track associated with this publication
   */
  unmute() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      return (u = this.track) === null || u === void 0 ? void 0 : u.unmute();
    });
  }
  /**
   * Pauses the media stream track associated with this publication from being sent to the server
   * and signals "muted" event to other participants
   * Useful if you want to pause the stream without pausing the local media stream track
   */
  pauseUpstream() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield (u = this.track) === null || u === void 0 ? void 0 : u.pauseUpstream();
    });
  }
  /**
   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]
   * and signals "unmuted" event to other participants (unless the track is explicitly muted)
   */
  resumeUpstream() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield (u = this.track) === null || u === void 0 ? void 0 : u.resumeUpstream();
    });
  }
}
var ConnectionQuality;
(function(a) {
  a.Excellent = "excellent", a.Good = "good", a.Poor = "poor", a.Lost = "lost", a.Unknown = "unknown";
})(ConnectionQuality || (ConnectionQuality = {}));
function qualityFromProto(a) {
  switch (a) {
    case ConnectionQuality$1.EXCELLENT:
      return ConnectionQuality.Excellent;
    case ConnectionQuality$1.GOOD:
      return ConnectionQuality.Good;
    case ConnectionQuality$1.POOR:
      return ConnectionQuality.Poor;
    case ConnectionQuality$1.LOST:
      return ConnectionQuality.Lost;
    default:
      return ConnectionQuality.Unknown;
  }
}
class Participant extends eventsExports$1.EventEmitter {
  get logContext() {
    var u, c;
    return Object.assign(Object.assign({}, (c = (u = this.loggerOptions) === null || u === void 0 ? void 0 : u.loggerContextCb) === null || c === void 0 ? void 0 : c.call(u)), {
      participantSid: this.sid,
      participantId: this.identity
    });
  }
  get isEncrypted() {
    return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((u) => u.isEncrypted);
  }
  get isAgent() {
    var u, c;
    return (c = (u = this.permissions) === null || u === void 0 ? void 0 : u.agent) !== null && c !== void 0 ? c : !1;
  }
  /** @internal */
  constructor(u, c, l, v, p) {
    var _;
    super(), this.audioLevel = 0, this.isSpeaking = !1, this._connectionQuality = ConnectionQuality.Unknown, this.log = livekitLogger, this.log = getLogger((_ = p == null ? void 0 : p.loggerName) !== null && _ !== void 0 ? _ : LoggerNames.Participant), this.loggerOptions = p, this.setMaxListeners(100), this.sid = u, this.identity = c, this.name = l, this.metadata = v, this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map();
  }
  getTrackPublications() {
    return Array.from(this.trackPublications.values());
  }
  /**
   * Finds the first track that matches the source filter, for example, getting
   * the user's camera track with getTrackBySource(Track.Source.Camera).
   */
  getTrackPublication(u) {
    for (const [, c] of this.trackPublications)
      if (c.source === u)
        return c;
  }
  /**
   * Finds the first track that matches the track's name.
   */
  getTrackPublicationByName(u) {
    for (const [, c] of this.trackPublications)
      if (c.trackName === u)
        return c;
  }
  get connectionQuality() {
    return this._connectionQuality;
  }
  get isCameraEnabled() {
    var u;
    const c = this.getTrackPublication(Track.Source.Camera);
    return !(!((u = c == null ? void 0 : c.isMuted) !== null && u !== void 0) || u);
  }
  get isMicrophoneEnabled() {
    var u;
    const c = this.getTrackPublication(Track.Source.Microphone);
    return !(!((u = c == null ? void 0 : c.isMuted) !== null && u !== void 0) || u);
  }
  get isScreenShareEnabled() {
    return !!this.getTrackPublication(Track.Source.ScreenShare);
  }
  get isLocal() {
    return !1;
  }
  /** when participant joined the room */
  get joinedAt() {
    return this.participantInfo ? new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3) : /* @__PURE__ */ new Date();
  }
  /** @internal */
  updateInfo(u) {
    return this.participantInfo && this.participantInfo.sid === u.sid && this.participantInfo.version > u.version ? !1 : (this.identity = u.identity, this.sid = u.sid, this._setName(u.name), this._setMetadata(u.metadata), u.permission && this.setPermissions(u.permission), this.participantInfo = u, this.log.trace("update participant info", Object.assign(Object.assign({}, this.logContext), {
      info: u
    })), !0);
  }
  /**
   * Updates metadata from server
   **/
  _setMetadata(u) {
    const c = this.metadata !== u, l = this.metadata;
    this.metadata = u, c && this.emit(ParticipantEvent.ParticipantMetadataChanged, l);
  }
  _setName(u) {
    const c = this.name !== u;
    this.name = u, c && this.emit(ParticipantEvent.ParticipantNameChanged, u);
  }
  /** @internal */
  setPermissions(u) {
    var c, l, v, p, _;
    const I = this.permissions, P = u.canPublish !== ((c = this.permissions) === null || c === void 0 ? void 0 : c.canPublish) || u.canSubscribe !== ((l = this.permissions) === null || l === void 0 ? void 0 : l.canSubscribe) || u.canPublishData !== ((v = this.permissions) === null || v === void 0 ? void 0 : v.canPublishData) || u.hidden !== ((p = this.permissions) === null || p === void 0 ? void 0 : p.hidden) || u.recorder !== ((_ = this.permissions) === null || _ === void 0 ? void 0 : _.recorder) || u.canPublishSources.length !== this.permissions.canPublishSources.length || u.canPublishSources.some(($, F) => {
      var H;
      return $ !== ((H = this.permissions) === null || H === void 0 ? void 0 : H.canPublishSources[F]);
    });
    return this.permissions = u, P && this.emit(ParticipantEvent.ParticipantPermissionsChanged, I), P;
  }
  /** @internal */
  setIsSpeaking(u) {
    u !== this.isSpeaking && (this.isSpeaking = u, u && (this.lastSpokeAt = /* @__PURE__ */ new Date()), this.emit(ParticipantEvent.IsSpeakingChanged, u));
  }
  /** @internal */
  setConnectionQuality(u) {
    const c = this._connectionQuality;
    this._connectionQuality = qualityFromProto(u), c !== this._connectionQuality && this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);
  }
  /**
   * @internal
   */
  setAudioContext(u) {
    this.audioContext = u, this.audioTrackPublications.forEach((c) => (c.track instanceof RemoteAudioTrack || c.track instanceof LocalAudioTrack) && c.track.setAudioContext(u));
  }
  addTrackPublication(u) {
    u.on(TrackEvent.Muted, () => {
      this.emit(ParticipantEvent.TrackMuted, u);
    }), u.on(TrackEvent.Unmuted, () => {
      this.emit(ParticipantEvent.TrackUnmuted, u);
    });
    const c = u;
    switch (c.track && (c.track.sid = u.trackSid), this.trackPublications.set(u.trackSid, u), u.kind) {
      case Track.Kind.Audio:
        this.audioTrackPublications.set(u.trackSid, u);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.set(u.trackSid, u);
        break;
    }
  }
}
function trackPermissionToProto(a) {
  var u, c, l;
  if (!a.participantSid && !a.participantIdentity)
    throw new Error("Invalid track permission, must provide at least one of participantIdentity and participantSid");
  return new TrackPermission({
    participantIdentity: (u = a.participantIdentity) !== null && u !== void 0 ? u : "",
    participantSid: (c = a.participantSid) !== null && c !== void 0 ? c : "",
    allTracks: (l = a.allowAll) !== null && l !== void 0 ? l : !1,
    trackSids: a.allowedTrackSids || []
  });
}
class LocalParticipant extends Participant {
  /** @internal */
  constructor(u, c, l, v) {
    super(u, c, void 0, void 0, {
      loggerName: v.loggerName,
      loggerContextCb: () => this.engine.logContext
    }), this.pendingPublishing = /* @__PURE__ */ new Set(), this.pendingPublishPromises = /* @__PURE__ */ new Map(), this.participantTrackPermissions = [], this.allParticipantsAllowedToSubscribe = !0, this.encryptionType = Encryption_Type.NONE, this.handleReconnecting = () => {
      this.reconnectFuture || (this.reconnectFuture = new Future());
    }, this.handleReconnected = () => {
      var p, _;
      (_ = (p = this.reconnectFuture) === null || p === void 0 ? void 0 : p.resolve) === null || _ === void 0 || _.call(p), this.reconnectFuture = void 0, this.updateTrackSubscriptionPermissions();
    }, this.handleDisconnected = () => {
      var p, _;
      this.reconnectFuture && (this.reconnectFuture.promise.catch((I) => this.log.warn(I.message, this.logContext)), (_ = (p = this.reconnectFuture) === null || p === void 0 ? void 0 : p.reject) === null || _ === void 0 || _.call(p, "Got disconnected during reconnection attempt"), this.reconnectFuture = void 0);
    }, this.updateTrackSubscriptionPermissions = () => {
      this.log.debug("updating track subscription permissions", Object.assign(Object.assign({}, this.logContext), {
        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
        participantTrackPermissions: this.participantTrackPermissions
      })), this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p) => trackPermissionToProto(p)));
    }, this.onTrackUnmuted = (p) => {
      this.onTrackMuted(p, p.isUpstreamPaused);
    }, this.onTrackMuted = (p, _) => {
      if (_ === void 0 && (_ = !0), !p.sid) {
        this.log.error("could not update mute status for unpublished track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p)));
        return;
      }
      this.engine.updateMuteStatus(p.sid, _);
    }, this.onTrackUpstreamPaused = (p) => {
      this.log.debug("upstream paused", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), this.onTrackMuted(p, !0);
    }, this.onTrackUpstreamResumed = (p) => {
      this.log.debug("upstream resumed", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), this.onTrackMuted(p, p.isMuted);
    }, this.handleSubscribedQualityUpdate = (p) => __awaiter$3(this, void 0, void 0, function* () {
      var _, I, P, $, F, H;
      if (!(!((F = this.roomOptions) === null || F === void 0) && F.dynacast))
        return;
      const j = this.videoTrackPublications.get(p.trackSid);
      if (!j) {
        this.log.warn("received subscribed quality update for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: p.trackSid
        }));
        return;
      }
      if (p.subscribedCodecs.length > 0) {
        if (!j.videoTrack)
          return;
        const Q = yield j.videoTrack.setPublishingCodecs(p.subscribedCodecs);
        try {
          for (var ee = !0, X = __asyncValues(Q), ie; ie = yield X.next(), _ = ie.done, !_; ee = !0) {
            $ = ie.value, ee = !1;
            const ne = $;
            isBackupCodec(ne) && (this.log.debug("publish ".concat(ne, " for ").concat(j.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(j))), yield this.publishAdditionalCodecForTrack(j.videoTrack, ne, j.options));
          }
        } catch (ne) {
          I = {
            error: ne
          };
        } finally {
          try {
            !ee && !_ && (P = X.return) && (yield P.call(X));
          } finally {
            if (I)
              throw I.error;
          }
        }
      } else
        p.subscribedQualities.length > 0 && (yield (H = j.videoTrack) === null || H === void 0 ? void 0 : H.setPublishingLayers(p.subscribedQualities));
    }), this.handleLocalTrackUnpublished = (p) => {
      const _ = this.trackPublications.get(p.trackSid);
      if (!_) {
        this.log.warn("received unpublished event for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: p.trackSid
        }));
        return;
      }
      this.unpublishTrack(_.track);
    }, this.handleTrackEnded = (p) => __awaiter$3(this, void 0, void 0, function* () {
      if (p.source === Track.Source.ScreenShare || p.source === Track.Source.ScreenShareAudio)
        this.log.debug("unpublishing local track due to TrackEnded", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), this.unpublishTrack(p);
      else if (p.isUserProvided)
        yield p.mute();
      else if (p instanceof LocalAudioTrack || p instanceof LocalVideoTrack)
        try {
          if (isWeb())
            try {
              const _ = yield navigator == null ? void 0 : navigator.permissions.query({
                // the permission query for camera and microphone currently not supported in Safari and Firefox
                // @ts-ignore
                name: p.source === Track.Source.Camera ? "camera" : "microphone"
              });
              if (_ && _.state === "denied")
                throw this.log.warn("user has revoked access to ".concat(p.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), _.onchange = () => {
                  _.state !== "denied" && (p.isMuted || p.restartTrack(), _.onchange = null);
                }, new Error("GetUserMedia Permission denied");
            } catch {
            }
          p.isMuted || (this.log.debug("track ended, attempting to use a different device", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), yield p.restartTrack());
        } catch {
          this.log.warn("could not restart track, muting instead", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p))), yield p.mute();
        }
    }), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map(), this.engine = l, this.roomOptions = v, this.setupEngine(l), this.activeDeviceMap = /* @__PURE__ */ new Map();
  }
  get lastCameraError() {
    return this.cameraError;
  }
  get lastMicrophoneError() {
    return this.microphoneError;
  }
  get isE2EEEnabled() {
    return this.encryptionType !== Encryption_Type.NONE;
  }
  getTrackPublication(u) {
    const c = super.getTrackPublication(u);
    if (c)
      return c;
  }
  getTrackPublicationByName(u) {
    const c = super.getTrackPublicationByName(u);
    if (c)
      return c;
  }
  /**
   * @internal
   */
  setupEngine(u) {
    this.engine = u, this.engine.on(EngineEvent.RemoteMute, (c, l) => {
      const v = this.trackPublications.get(c);
      !v || !v.track || (l ? v.mute() : v.unmute());
    }), this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected);
  }
  /**
   * Sets and updates the metadata of the local participant.
   * The change does not take immediate effect.
   * If successful, a `ParticipantEvent.MetadataChanged` event will be emitted on the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * @param metadata
   */
  setMetadata(u) {
    var c;
    this.engine.client.sendUpdateLocalMetadata(u, (c = this.name) !== null && c !== void 0 ? c : "");
  }
  /**
   * Sets and updates the name of the local participant.
   * The change does not take immediate effect.
   * If successful, a `ParticipantEvent.ParticipantNameChanged` event will be emitted on the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * @param metadata
   */
  setName(u) {
    var c;
    this.engine.client.sendUpdateLocalMetadata((c = this.metadata) !== null && c !== void 0 ? c : "", u);
  }
  /**
   * Enable or disable a participant's camera track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setCameraEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.Camera, u, c, l);
  }
  /**
   * Enable or disable a participant's microphone track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setMicrophoneEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.Microphone, u, c, l);
  }
  /**
   * Start or stop sharing a participant's screen
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setScreenShareEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.ScreenShare, u, c, l);
  }
  /** @internal */
  setPermissions(u) {
    const c = this.permissions, l = super.setPermissions(u);
    return l && c && this.emit(ParticipantEvent.ParticipantPermissionsChanged, c), l;
  }
  /** @internal */
  setE2EEEnabled(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.encryptionType = u ? Encryption_Type.GCM : Encryption_Type.NONE, yield this.republishAllTracks(void 0, !1);
    });
  }
  setTrackEnabled(u, c, l, v) {
    var p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      this.log.debug("setTrackEnabled", Object.assign(Object.assign({}, this.logContext), {
        source: u,
        enabled: c
      }));
      let I = this.getTrackPublication(u);
      if (c)
        if (I)
          yield I.unmute();
        else {
          let P;
          if (this.pendingPublishing.has(u)) {
            this.log.info("skipping duplicate published source", Object.assign(Object.assign({}, this.logContext), {
              source: u
            }));
            return;
          }
          this.pendingPublishing.add(u);
          try {
            switch (u) {
              case Track.Source.Camera:
                P = yield this.createTracks({
                  video: (p = l) !== null && p !== void 0 ? p : !0
                });
                break;
              case Track.Source.Microphone:
                P = yield this.createTracks({
                  audio: (_ = l) !== null && _ !== void 0 ? _ : !0
                });
                break;
              case Track.Source.ScreenShare:
                P = yield this.createScreenTracks(Object.assign({}, l));
                break;
              default:
                throw new TrackInvalidError(u);
            }
            const $ = [];
            for (const H of P)
              this.log.info("publishing track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(H))), $.push(this.publishTrack(H, v));
            [I] = yield Promise.all($);
          } catch ($) {
            throw P == null || P.forEach((F) => {
              F.stop();
            }), $ instanceof Error && !($ instanceof TrackInvalidError) && this.emit(ParticipantEvent.MediaDevicesError, $), $;
          } finally {
            this.pendingPublishing.delete(u);
          }
        }
      else if (I && I.track)
        if (u === Track.Source.ScreenShare) {
          I = yield this.unpublishTrack(I.track);
          const P = this.getTrackPublication(Track.Source.ScreenShareAudio);
          P && P.track && this.unpublishTrack(P.track);
        } else
          yield I.mute();
      return I;
    });
  }
  /**
   * Publish both camera and microphone at the same time. This is useful for
   * displaying a single Permission Dialog box to the end user.
   */
  enableCameraAndMicrophone() {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (!(this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone))) {
        this.pendingPublishing.add(Track.Source.Camera), this.pendingPublishing.add(Track.Source.Microphone);
        try {
          const u = yield this.createTracks({
            audio: !0,
            video: !0
          });
          yield Promise.all(u.map((c) => this.publishTrack(c)));
        } finally {
          this.pendingPublishing.delete(Track.Source.Camera), this.pendingPublishing.delete(Track.Source.Microphone);
        }
      }
    });
  }
  /**
   * Create local camera and/or microphone tracks
   * @param options
   * @returns
   */
  createTracks(u) {
    var c, l;
    return __awaiter$3(this, void 0, void 0, function* () {
      const v = mergeDefaultOptions(u, (c = this.roomOptions) === null || c === void 0 ? void 0 : c.audioCaptureDefaults, (l = this.roomOptions) === null || l === void 0 ? void 0 : l.videoCaptureDefaults), p = constraintsForOptions(v);
      let _;
      try {
        _ = yield navigator.mediaDevices.getUserMedia(p);
      } catch (I) {
        throw I instanceof Error && (p.audio && (this.microphoneError = I), p.video && (this.cameraError = I)), I;
      }
      return p.audio && (this.microphoneError = void 0, this.emit(ParticipantEvent.AudioStreamAcquired)), p.video && (this.cameraError = void 0), _.getTracks().map((I) => {
        const P = I.kind === "audio";
        P ? u.audio : u.video;
        let $;
        const F = P ? p.audio : p.video;
        typeof F != "boolean" && ($ = F);
        const H = mediaTrackToLocalTrack(I, $, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        return H.kind === Track.Kind.Video ? H.source = Track.Source.Camera : H.kind === Track.Kind.Audio && (H.source = Track.Source.Microphone), H.mediaStream = _, H;
      });
    });
  }
  /**
   * Creates a screen capture tracks with getDisplayMedia().
   * A LocalVideoTrack is always created and returned.
   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
   */
  createScreenTracks(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (u === void 0 && (u = {}), navigator.mediaDevices.getDisplayMedia === void 0)
        throw new DeviceUnsupportedError("getDisplayMedia not supported");
      u.resolution === void 0 && !isSafari17() && (u.resolution = ScreenSharePresets.h1080fps30.resolution);
      const c = screenCaptureToDisplayMediaStreamOptions(u), l = yield navigator.mediaDevices.getDisplayMedia(c), v = l.getVideoTracks();
      if (v.length === 0)
        throw new TrackInvalidError("no video track found");
      const p = new LocalVideoTrack(v[0], void 0, !1, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      p.source = Track.Source.ScreenShare, u.contentHint && (p.mediaStreamTrack.contentHint = u.contentHint);
      const _ = [p];
      if (l.getAudioTracks().length > 0) {
        this.emit(ParticipantEvent.AudioStreamAcquired);
        const I = new LocalAudioTrack(l.getAudioTracks()[0], void 0, !1, this.audioContext, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        I.source = Track.Source.ScreenShareAudio, _.push(I);
      }
      return _;
    });
  }
  /**
   * Publish a new track to the room
   * @param track
   * @param options
   */
  publishTrack(u, c) {
    var l, v, p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      yield (l = this.reconnectFuture) === null || l === void 0 ? void 0 : l.promise, u instanceof LocalTrack && this.pendingPublishPromises.has(u) && (yield this.pendingPublishPromises.get(u));
      let I;
      if (u instanceof MediaStreamTrack)
        I = u.getConstraints();
      else {
        I = u.constraints;
        let ee;
        switch (u.source) {
          case Track.Source.Microphone:
            ee = "audioinput";
            break;
          case Track.Source.Camera:
            ee = "videoinput";
        }
        ee && this.activeDeviceMap.has(ee) && (I = Object.assign(Object.assign({}, I), {
          deviceId: this.activeDeviceMap.get(ee)
        }));
      }
      if (u instanceof MediaStreamTrack)
        switch (u.kind) {
          case "audio":
            u = new LocalAudioTrack(u, I, !0, this.audioContext, {
              loggerName: this.roomOptions.loggerName,
              loggerContextCb: () => this.logContext
            });
            break;
          case "video":
            u = new LocalVideoTrack(u, I, !0, {
              loggerName: this.roomOptions.loggerName,
              loggerContextCb: () => this.logContext
            });
            break;
          default:
            throw new TrackInvalidError("unsupported MediaStreamTrack kind ".concat(u.kind));
        }
      else
        u.updateLoggerOptions({
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
      u instanceof LocalAudioTrack && u.setAudioContext(this.audioContext);
      let P;
      if (this.trackPublications.forEach((ee) => {
        ee.track && ee.track === u && (P = ee);
      }), P)
        return this.log.warn("track has already been published, skipping", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(P))), P;
      const $ = "channelCount" in u.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount
      u.mediaStreamTrack.getSettings().channelCount === 2 || u.mediaStreamTrack.getConstraints().channelCount === 2, F = (v = c == null ? void 0 : c.forceStereo) !== null && v !== void 0 ? v : $;
      F && (c || (c = {}), c.dtx === void 0 && this.log.info("Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), c.red === void 0 && this.log.info("Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work."), (p = c.dtx) !== null && p !== void 0 || (c.dtx = !1), (_ = c.red) !== null && _ !== void 0 || (c.red = !1));
      const H = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), c);
      isSafari() && this.roomOptions.e2ee && (this.log.info("End-to-end encryption is set up, simulcast publishing will be disabled on Safari", Object.assign({}, this.logContext)), H.simulcast = !1), H.source && (u.source = H.source);
      const j = this.publish(u, H, F);
      this.pendingPublishPromises.set(u, j);
      try {
        return yield j;
      } catch (ee) {
        throw ee;
      } finally {
        this.pendingPublishPromises.delete(u);
      }
    });
  }
  publish(u, c, l) {
    var v, p, _, I, P, $, F, H, j, ee, X, ie;
    return __awaiter$3(this, void 0, void 0, function* () {
      Array.from(this.trackPublications.values()).find((ke) => u instanceof LocalTrack && ke.source === u.source) && u.source !== Track.Source.Unknown && this.log.info("publishing a second track with the same source: ".concat(u.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), c.stopMicTrackOnMute && u instanceof LocalAudioTrack && (u.stopOnMute = !0), u.source === Track.Source.ScreenShare && isFireFox() && (c.simulcast = !1), c.videoCodec === "av1" && !supportsAV1() && (c.videoCodec = void 0), c.videoCodec === "vp9" && !supportsVP9() && (c.videoCodec = void 0), c.videoCodec === void 0 && (c.videoCodec = defaultVideoCodec);
      const ne = c.videoCodec;
      u.on(TrackEvent.Muted, this.onTrackMuted), u.on(TrackEvent.Unmuted, this.onTrackUnmuted), u.on(TrackEvent.Ended, this.handleTrackEnded), u.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused), u.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
      const Z = new AddTrackRequest({
        // get local track id for use during publishing
        cid: u.mediaStreamTrack.id,
        name: c.name,
        type: Track.kindToProto(u.kind),
        muted: u.isMuted,
        source: Track.sourceToProto(u.source),
        disableDtx: !(!((v = c.dtx) !== null && v !== void 0) || v),
        encryption: this.encryptionType,
        stereo: l,
        disableRed: this.isE2EEEnabled || !(!((p = c.red) !== null && p !== void 0) || p),
        stream: c == null ? void 0 : c.stream
      });
      let de;
      if (u.kind === Track.Kind.Video) {
        let ke = {
          width: 0,
          height: 0
        };
        try {
          ke = yield u.waitForDimensions();
        } catch {
          const q = (I = (_ = this.roomOptions.videoCaptureDefaults) === null || _ === void 0 ? void 0 : _.resolution) !== null && I !== void 0 ? I : VideoPresets.h720.resolution;
          ke = {
            width: q.width,
            height: q.height
          }, this.log.error("could not determine track dimensions, using defaults", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)), {
            dims: ke
          }));
        }
        Z.width = ke.width, Z.height = ke.height, u instanceof LocalVideoTrack && (isSVCCodec(ne) && (u.source === Track.Source.ScreenShare && ne === "vp9" && (c.scalabilityMode = "L1T3"), c.scalabilityMode = (P = c.scalabilityMode) !== null && P !== void 0 ? P : "L3T3_KEY"), Z.simulcastCodecs = [new SimulcastCodec({
          codec: ne,
          cid: u.mediaStreamTrack.id
        })], c.backupCodec === !0 && (c.backupCodec = {
          codec: defaultVideoCodec
        }), c.backupCodec && ne !== c.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs
        Z.encryption === Encryption_Type.NONE && (this.roomOptions.dynacast || (this.roomOptions.dynacast = !0), Z.simulcastCodecs.push(new SimulcastCodec({
          codec: c.backupCodec.codec,
          cid: ""
        })))), de = computeVideoEncodings(u.source === Track.Source.ScreenShare, Z.width, Z.height, c), Z.layers = videoLayersFromEncodings(Z.width, Z.height, de, isSVCCodec(c.videoCodec));
      } else
        u.kind === Track.Kind.Audio && (de = [{
          maxBitrate: ($ = c.audioPreset) === null || $ === void 0 ? void 0 : $.maxBitrate,
          priority: (H = (F = c.audioPreset) === null || F === void 0 ? void 0 : F.priority) !== null && H !== void 0 ? H : "high",
          networkPriority: (ee = (j = c.audioPreset) === null || j === void 0 ? void 0 : j.priority) !== null && ee !== void 0 ? ee : "high"
        }]);
      if (!this.engine || this.engine.isClosed)
        throw new UnexpectedConnectionState("cannot publish track when not connected");
      const he = yield this.engine.addTrack(Z);
      let pe;
      if (he.codecs.forEach((ke) => {
        pe === void 0 && (pe = ke.mimeType);
      }), pe && u.kind === Track.Kind.Video) {
        const ke = mimeTypeToVideoCodecString(pe);
        ke !== ne && (this.log.debug("falling back to server selected codec", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)), {
          codec: ke
        })), c.videoCodec = ke, de = computeVideoEncodings(u.source === Track.Source.ScreenShare, Z.width, Z.height, c));
      }
      const be = new LocalTrackPublication(u.kind, he, u, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      if (be.options = c, u.sid = he.sid, !this.engine.pcManager)
        throw new UnexpectedConnectionState("pcManager is not ready");
      if (this.log.debug("publishing ".concat(u.kind, " with encodings"), Object.assign(Object.assign({}, this.logContext), {
        encodings: de,
        trackInfo: he
      })), u.sender = yield this.engine.createSender(u, c, de), de)
        if (isFireFox() && u.kind === Track.Kind.Audio) {
          let ke;
          for (const _e of this.engine.pcManager.publisher.getTransceivers())
            if (_e.sender === u.sender) {
              ke = _e;
              break;
            }
          ke && this.engine.pcManager.publisher.setTrackCodecBitrate({
            transceiver: ke,
            codec: "opus",
            maxbr: !((X = de[0]) === null || X === void 0) && X.maxBitrate ? de[0].maxBitrate / 1e3 : 0
          });
        } else
          u.codec && isSVCCodec(u.codec) && (!((ie = de[0]) === null || ie === void 0) && ie.maxBitrate) && this.engine.pcManager.publisher.setTrackCodecBitrate({
            cid: Z.cid,
            codec: u.codec,
            maxbr: de[0].maxBitrate / 1e3
          });
      return yield this.engine.negotiate(), u instanceof LocalVideoTrack ? u.startMonitor(this.engine.client) : u instanceof LocalAudioTrack && u.startMonitor(), this.addTrackPublication(be), this.emit(ParticipantEvent.LocalTrackPublished, be), be;
    });
  }
  get isLocal() {
    return !0;
  }
  /** @internal
   * publish additional codec to existing track
   */
  publishAdditionalCodecForTrack(u, c, l) {
    var v;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.encryptionType !== Encryption_Type.NONE)
        return;
      let p;
      if (this.trackPublications.forEach((H) => {
        H.track && H.track === u && (p = H);
      }), !p)
        throw new TrackInvalidError("track is not published");
      if (!(u instanceof LocalVideoTrack))
        throw new TrackInvalidError("track is not a video track");
      const _ = Object.assign(Object.assign({}, (v = this.roomOptions) === null || v === void 0 ? void 0 : v.publishDefaults), l), I = computeTrackBackupEncodings(u, c, _);
      if (!I) {
        this.log.info("backup codec has been disabled, ignoring request to add additional codec for track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)));
        return;
      }
      const P = u.addSimulcastTrack(c, I);
      if (!P)
        return;
      const $ = new AddTrackRequest({
        cid: P.mediaStreamTrack.id,
        type: Track.kindToProto(u.kind),
        muted: u.isMuted,
        source: Track.sourceToProto(u.source),
        sid: u.sid,
        simulcastCodecs: [{
          codec: _.videoCodec,
          cid: P.mediaStreamTrack.id
        }]
      });
      if ($.layers = videoLayersFromEncodings($.width, $.height, I), !this.engine || this.engine.isClosed)
        throw new UnexpectedConnectionState("cannot publish track when not connected");
      const F = yield this.engine.addTrack($);
      yield this.engine.createSimulcastSender(u, P, _, I), yield this.engine.negotiate(), this.log.debug("published ".concat(c, " for track ").concat(u.sid), Object.assign(Object.assign({}, this.logContext), {
        encodings: I,
        trackInfo: F
      }));
    });
  }
  unpublishTrack(u, c) {
    var l, v;
    return __awaiter$3(this, void 0, void 0, function* () {
      const p = this.getPublicationForTrack(u), _ = p ? getLogContextFromTrack(p) : void 0;
      if (this.log.debug("unpublishing track", Object.assign(Object.assign({}, this.logContext), _)), !p || !p.track) {
        this.log.warn("track was not unpublished because no publication was found", Object.assign(Object.assign({}, this.logContext), _));
        return;
      }
      u = p.track, u.off(TrackEvent.Muted, this.onTrackMuted), u.off(TrackEvent.Unmuted, this.onTrackUnmuted), u.off(TrackEvent.Ended, this.handleTrackEnded), u.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused), u.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed), c === void 0 && (c = (v = (l = this.roomOptions) === null || l === void 0 ? void 0 : l.stopLocalTrackOnUnpublish) !== null && v !== void 0 ? v : !0), c && u.stop();
      let I = !1;
      const P = u.sender;
      if (u.sender = void 0, this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && P)
        try {
          for (const $ of this.engine.pcManager.publisher.getTransceivers())
            $.sender === P && ($.direction = "inactive", I = !0);
          if (this.engine.removeTrack(P) && (I = !0), u instanceof LocalVideoTrack) {
            for (const [, $] of u.simulcastCodecs)
              $.sender && (this.engine.removeTrack($.sender) && (I = !0), $.sender = void 0);
            u.simulcastCodecs.clear();
          }
        } catch ($) {
          this.log.warn("failed to unpublish track", Object.assign(Object.assign(Object.assign({}, this.logContext), _), {
            error: $
          }));
        }
      switch (this.trackPublications.delete(p.trackSid), p.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.delete(p.trackSid);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.delete(p.trackSid);
          break;
      }
      return this.emit(ParticipantEvent.LocalTrackUnpublished, p), p.setTrack(void 0), I && (yield this.engine.negotiate()), p;
    });
  }
  unpublishTracks(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return (yield Promise.all(u.map((l) => this.unpublishTrack(l)))).filter((l) => l instanceof LocalTrackPublication);
    });
  }
  republishAllTracks(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = [];
      this.trackPublications.forEach((v) => {
        v.track && (u && (v.options = Object.assign(Object.assign({}, v.options), u)), l.push(v));
      }), yield Promise.all(l.map((v) => __awaiter$3(this, void 0, void 0, function* () {
        const p = v.track;
        yield this.unpublishTrack(p, !1), c && !p.isMuted && p.source !== Track.Source.ScreenShare && p.source !== Track.Source.ScreenShareAudio && (p instanceof LocalAudioTrack || p instanceof LocalVideoTrack) && !p.isUserProvided && (this.log.debug("restarting existing track", Object.assign(Object.assign({}, this.logContext), {
          track: v.trackSid
        })), yield p.restartTrack()), yield this.publishTrack(p, v.options);
      })));
    });
  }
  /**
   * Publish a new data payload to the room. Data will be forwarded to each
   * participant in the room if the destination field in publishOptions is empty
   *
   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode
   * @param options optionally specify a `reliable`, `topic` and `destination`
   */
  publishData(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = c.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY, v = c.destinationIdentities, p = c.topic, _ = new DataPacket({
        kind: l,
        value: {
          case: "user",
          value: new UserPacket({
            participantIdentity: this.identity,
            payload: u,
            destinationIdentities: v,
            topic: p
          })
        }
      });
      yield this.engine.sendDataPacket(_, l);
    });
  }
  /**
   * Control who can subscribe to LocalParticipant's published tracks.
   *
   * By default, all participants can subscribe. This allows fine-grained control over
   * who is able to subscribe at a participant and track level.
   *
   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and
   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks
   * will not grant permissions to any participants and will require a subsequent
   * permissions update to allow subscription.
   *
   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.
   *  Takes precedence over [[participantTrackPermissions]] if set to true.
   *  By default this is set to true.
   * @param participantTrackPermissions Full list of individual permissions per
   *  participant/track. Any omitted participants will not receive any permissions.
   */
  setTrackSubscriptionPermissions(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    this.participantTrackPermissions = c, this.allParticipantsAllowedToSubscribe = u, this.engine.client.isDisconnected || this.updateTrackSubscriptionPermissions();
  }
  /** @internal */
  updateInfo(u) {
    return u.sid !== this.sid || !super.updateInfo(u) ? !1 : (u.tracks.forEach((c) => {
      var l, v;
      const p = this.trackPublications.get(c.sid);
      if (p) {
        const _ = p.isMuted || ((v = (l = p.track) === null || l === void 0 ? void 0 : l.isUpstreamPaused) !== null && v !== void 0 ? v : !1);
        _ !== c.muted && (this.log.debug("updating server mute state after reconcile", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(p)), {
          mutedOnServer: _
        })), this.engine.client.sendMuteTrack(c.sid, _));
      }
    }), !0);
  }
  getPublicationForTrack(u) {
    let c;
    return this.trackPublications.forEach((l) => {
      const v = l.track;
      v && (u instanceof MediaStreamTrack ? (v instanceof LocalAudioTrack || v instanceof LocalVideoTrack) && v.mediaStreamTrack === u && (c = l) : u === v && (c = l));
    }), c;
  }
}
class RemoteTrackPublication extends TrackPublication {
  constructor(u, c, l, v) {
    super(u, c.sid, c.name, v), this.track = void 0, this.allowed = !0, this.disabled = !1, this.currentVideoQuality = VideoQuality.HIGH, this.handleEnded = (p) => {
      this.setTrack(void 0), this.emit(TrackEvent.Ended, p);
    }, this.handleVisibilityChange = (p) => {
      this.log.debug("adaptivestream video visibility ".concat(this.trackSid, ", visible=").concat(p), this.logContext), this.disabled = !p, this.emitTrackUpdate();
    }, this.handleVideoDimensionsChange = (p) => {
      this.log.debug("adaptivestream video dimensions ".concat(p.width, "x").concat(p.height), this.logContext), this.videoDimensions = p, this.emitTrackUpdate();
    }, this.subscribed = l, this.updateInfo(c);
  }
  /**
   * Subscribe or unsubscribe to this remote track
   * @param subscribed true to subscribe to a track, false to unsubscribe
   */
  setSubscribed(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus;
    this.subscribed = u, u && (this.allowed = !0);
    const v = new UpdateSubscription({
      trackSids: [this.trackSid],
      subscribe: this.subscribed,
      participantTracks: [new ParticipantTracks({
        // sending an empty participant id since TrackPublication doesn't keep it
        // this is filled in by the participant that receives this message
        participantSid: "",
        trackSids: [this.trackSid]
      })]
    });
    this.emit(TrackEvent.UpdateSubscription, v), this.emitSubscriptionUpdateIfChanged(c), this.emitPermissionUpdateIfChanged(l);
  }
  get subscriptionStatus() {
    return this.subscribed === !1 ? TrackPublication.SubscriptionStatus.Unsubscribed : super.isSubscribed ? TrackPublication.SubscriptionStatus.Subscribed : TrackPublication.SubscriptionStatus.Desired;
  }
  get permissionStatus() {
    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;
  }
  /**
   * Returns true if track is subscribed, and ready for playback
   */
  get isSubscribed() {
    return this.subscribed === !1 ? !1 : super.isSubscribed;
  }
  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled
  get isDesired() {
    return this.subscribed !== !1;
  }
  get isEnabled() {
    return !this.disabled;
  }
  /**
   * disable server from sending down data for this track. this is useful when
   * the participant is off screen, you may disable streaming down their video
   * to reduce bandwidth requirements
   * @param enabled
   */
  setEnabled(u) {
    !this.isManualOperationAllowed() || this.disabled === !u || (this.disabled = !u, this.emitTrackUpdate());
  }
  /**
   * for tracks that support simulcasting, adjust subscribed quality
   *
   * This indicates the highest quality the client can accept. if network
   * bandwidth does not allow, server will automatically reduce quality to
   * optimize for uninterrupted video
   */
  setVideoQuality(u) {
    !this.isManualOperationAllowed() || this.currentVideoQuality === u || (this.currentVideoQuality = u, this.videoDimensions = void 0, this.emitTrackUpdate());
  }
  setVideoDimensions(u) {
    var c, l;
    this.isManualOperationAllowed() && (((c = this.videoDimensions) === null || c === void 0 ? void 0 : c.width) === u.width && ((l = this.videoDimensions) === null || l === void 0 ? void 0 : l.height) === u.height || (this.track instanceof RemoteVideoTrack && (this.videoDimensions = u), this.currentVideoQuality = void 0, this.emitTrackUpdate()));
  }
  setVideoFPS(u) {
    this.isManualOperationAllowed() && this.track instanceof RemoteVideoTrack && this.fps !== u && (this.fps = u, this.emitTrackUpdate());
  }
  get videoQuality() {
    return this.currentVideoQuality;
  }
  /** @internal */
  setTrack(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus, v = this.track;
    v !== u && (v && (v.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange), v.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange), v.off(TrackEvent.Ended, this.handleEnded), v.detach(), v.stopMonitor(), this.emit(TrackEvent.Unsubscribed, v)), super.setTrack(u), u && (u.sid = this.trackSid, u.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange), u.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange), u.on(TrackEvent.Ended, this.handleEnded), this.emit(TrackEvent.Subscribed, u)), this.emitPermissionUpdateIfChanged(l), this.emitSubscriptionUpdateIfChanged(c));
  }
  /** @internal */
  setAllowed(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus;
    this.allowed = u, this.emitPermissionUpdateIfChanged(l), this.emitSubscriptionUpdateIfChanged(c);
  }
  /** @internal */
  setSubscriptionError(u) {
    this.emit(TrackEvent.SubscriptionFailed, u);
  }
  /** @internal */
  updateInfo(u) {
    super.updateInfo(u);
    const c = this.metadataMuted;
    this.metadataMuted = u.muted, this.track ? this.track.setMuted(u.muted) : c !== u.muted && this.emit(u.muted ? TrackEvent.Muted : TrackEvent.Unmuted);
  }
  emitSubscriptionUpdateIfChanged(u) {
    const c = this.subscriptionStatus;
    u !== c && this.emit(TrackEvent.SubscriptionStatusChanged, c, u);
  }
  emitPermissionUpdateIfChanged(u) {
    this.permissionStatus !== u && this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, u);
  }
  isManualOperationAllowed() {
    return this.kind === Track.Kind.Video && this.isAdaptiveStream ? (this.log.warn("adaptive stream is enabled, cannot change video track settings", this.logContext), !1) : this.isDesired ? !0 : (this.log.warn("cannot update track settings when not subscribed", this.logContext), !1);
  }
  get isAdaptiveStream() {
    return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;
  }
  /* @internal */
  emitTrackUpdate() {
    const u = new UpdateTrackSettings({
      trackSids: [this.trackSid],
      disabled: this.disabled,
      fps: this.fps
    });
    this.videoDimensions ? (u.width = Math.ceil(this.videoDimensions.width), u.height = Math.ceil(this.videoDimensions.height)) : this.currentVideoQuality !== void 0 ? u.quality = this.currentVideoQuality : u.quality = VideoQuality.HIGH, this.emit(TrackEvent.UpdateSettings, u);
  }
}
class RemoteParticipant extends Participant {
  /** @internal */
  static fromParticipantInfo(u, c) {
    return new RemoteParticipant(u, c.sid, c.identity, c.name, c.metadata);
  }
  /** @internal */
  constructor(u, c, l, v, p, _) {
    super(c, l || "", v, p, _), this.signalClient = u, this.trackPublications = /* @__PURE__ */ new Map(), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.volumeMap = /* @__PURE__ */ new Map();
  }
  addTrackPublication(u) {
    super.addTrackPublication(u), u.on(TrackEvent.UpdateSettings, (c) => {
      this.log.debug("send update settings", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), this.signalClient.sendUpdateTrackSettings(c);
    }), u.on(TrackEvent.UpdateSubscription, (c) => {
      c.participantTracks.forEach((l) => {
        l.participantSid = this.sid;
      }), this.signalClient.sendUpdateSubscription(c);
    }), u.on(TrackEvent.SubscriptionPermissionChanged, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, u, c);
    }), u.on(TrackEvent.SubscriptionStatusChanged, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, u, c);
    }), u.on(TrackEvent.Subscribed, (c) => {
      this.emit(ParticipantEvent.TrackSubscribed, c, u);
    }), u.on(TrackEvent.Unsubscribed, (c) => {
      this.emit(ParticipantEvent.TrackUnsubscribed, c, u);
    }), u.on(TrackEvent.SubscriptionFailed, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionFailed, u.trackSid, c);
    });
  }
  getTrackPublication(u) {
    const c = super.getTrackPublication(u);
    if (c)
      return c;
  }
  getTrackPublicationByName(u) {
    const c = super.getTrackPublicationByName(u);
    if (c)
      return c;
  }
  /**
   * sets the volume on the participant's audio track
   * by default, this affects the microphone publication
   * a different source can be passed in as a second argument
   * if no track exists the volume will be applied when the microphone track is added
   */
  setVolume(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Track.Source.Microphone;
    this.volumeMap.set(c, u);
    const l = this.getTrackPublication(c);
    l && l.track && l.track.setVolume(u);
  }
  /**
   * gets the volume on the participant's microphone track
   */
  getVolume() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Track.Source.Microphone;
    const c = this.getTrackPublication(u);
    return c && c.track ? c.track.getVolume() : this.volumeMap.get(u);
  }
  /** @internal */
  addSubscribedMediaTrack(u, c, l, v, p, _) {
    let I = this.getTrackPublicationBySid(c);
    if (I || c.startsWith("TR") || this.trackPublications.forEach((F) => {
      !I && u.kind === F.kind.toString() && (I = F);
    }), !I) {
      if (_ === 0) {
        this.log.error("could not find published track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: c
        })), this.emit(ParticipantEvent.TrackSubscriptionFailed, c);
        return;
      }
      _ === void 0 && (_ = 20), setTimeout(() => {
        this.addSubscribedMediaTrack(u, c, l, v, p, _ - 1);
      }, 150);
      return;
    }
    if (u.readyState === "ended") {
      this.log.error("unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(I))), this.emit(ParticipantEvent.TrackSubscriptionFailed, c);
      return;
    }
    const P = u.kind === "video";
    let $;
    return P ? $ = new RemoteVideoTrack(u, c, v, p) : $ = new RemoteAudioTrack(u, c, v, this.audioContext, this.audioOutput), $.source = I.source, $.isMuted = I.isMuted, $.setMediaStream(l), $.start(), I.setTrack($), this.volumeMap.has(I.source) && $ instanceof RemoteAudioTrack && $.setVolume(this.volumeMap.get(I.source)), I;
  }
  /** @internal */
  get hasMetadata() {
    return !!this.participantInfo;
  }
  /**
   * @internal
   */
  getTrackPublicationBySid(u) {
    return this.trackPublications.get(u);
  }
  /** @internal */
  updateInfo(u) {
    if (!super.updateInfo(u))
      return !1;
    const c = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map();
    return u.tracks.forEach((v) => {
      var p, _;
      let I = this.getTrackPublicationBySid(v.sid);
      if (I)
        I.updateInfo(v);
      else {
        const P = Track.kindFromProto(v.type);
        if (!P)
          return;
        I = new RemoteTrackPublication(P, v, (p = this.signalClient.connectOptions) === null || p === void 0 ? void 0 : p.autoSubscribe, {
          loggerContextCb: () => this.logContext,
          loggerName: (_ = this.loggerOptions) === null || _ === void 0 ? void 0 : _.loggerName
        }), I.updateInfo(v), l.set(v.sid, I);
        const $ = Array.from(this.trackPublications.values()).find((F) => F.source === (I == null ? void 0 : I.source));
        $ && I.source !== Track.Source.Unknown && this.log.debug("received a second track publication for ".concat(this.identity, " with the same source: ").concat(I.source), Object.assign(Object.assign({}, this.logContext), {
          oldTrack: getLogContextFromTrack($),
          newTrack: getLogContextFromTrack(I)
        })), this.addTrackPublication(I);
      }
      c.set(v.sid, I);
    }), this.trackPublications.forEach((v) => {
      c.has(v.trackSid) || (this.log.trace("detected removed track on remote participant, unpublishing", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(v))), this.unpublishTrack(v.trackSid, !0));
    }), l.forEach((v) => {
      this.emit(ParticipantEvent.TrackPublished, v);
    }), !0;
  }
  /** @internal */
  unpublishTrack(u, c) {
    const l = this.trackPublications.get(u);
    if (!l)
      return;
    const {
      track: v
    } = l;
    switch (v && (v.stop(), l.setTrack(void 0)), this.trackPublications.delete(u), l.kind) {
      case Track.Kind.Audio:
        this.audioTrackPublications.delete(u);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.delete(u);
        break;
    }
    c && this.emit(ParticipantEvent.TrackUnpublished, l);
  }
  /**
   * @internal
   */
  setAudioOutput(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.audioOutput = u;
      const c = [];
      this.audioTrackPublications.forEach((l) => {
        var v;
        l.track instanceof RemoteAudioTrack && c.push(l.track.setSinkId((v = u.deviceId) !== null && v !== void 0 ? v : "default"));
      }), yield Promise.all(c);
    });
  }
  /** @internal */
  emit(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    return this.log.trace("participant event", Object.assign(Object.assign({}, this.logContext), {
      event: u,
      args: l
    })), super.emit(u, ...l);
  }
}
var ConnectionState;
(function(a) {
  a.Disconnected = "disconnected", a.Connecting = "connecting", a.Connected = "connected", a.Reconnecting = "reconnecting";
})(ConnectionState || (ConnectionState = {}));
const connectionReconcileFrequency = 2 * 1e3;
class Room extends eventsExports$1.EventEmitter {
  /**
   * Creates a new Room, the primary construct for a LiveKit session.
   * @param options
   */
  constructor(u) {
    var c, l, v;
    super(), c = this, this.state = ConnectionState.Disconnected, this.activeSpeakers = [], this.isE2EEEnabled = !1, this.audioEnabled = !0, this.isVideoPlaybackBlocked = !1, this.log = livekitLogger, this.bufferedEvents = [], this.isResuming = !1, this.connect = (p, _, I) => __awaiter$3(this, void 0, void 0, function* () {
      var P;
      const $ = yield this.disconnectLock.lock();
      if (this.state === ConnectionState.Connected)
        return this.log.info("already connected to room ".concat(this.name), this.logContext), $(), Promise.resolve();
      if (this.connectFuture)
        return $(), this.connectFuture.promise;
      this.setAndEmitConnectionState(ConnectionState.Connecting), ((P = this.regionUrlProvider) === null || P === void 0 ? void 0 : P.getServerUrl().toString()) !== p && (this.regionUrl = void 0, this.regionUrlProvider = void 0), isCloud(new URL(p)) && (this.regionUrlProvider === void 0 ? this.regionUrlProvider = new RegionUrlProvider(p, _) : this.regionUrlProvider.updateToken(_), this.regionUrlProvider.fetchRegionSettings().catch((j) => {
        this.log.warn("could not fetch region settings", Object.assign(Object.assign({}, this.logContext), {
          error: j
        }));
      }));
      const F = (j, ee, X) => __awaiter$3(this, void 0, void 0, function* () {
        var ie;
        this.abortController && this.abortController.abort();
        const Q = new AbortController();
        this.abortController = Q, $ == null || $();
        try {
          yield this.attemptConnection(X ?? p, _, I, Q), this.abortController = void 0, j();
        } catch (ne) {
          if (this.regionUrlProvider && ne instanceof ConnectionError && ne.reason !== 3 && ne.reason !== 0) {
            let Z = null;
            try {
              Z = yield this.regionUrlProvider.getNextBestRegionUrl((ie = this.abortController) === null || ie === void 0 ? void 0 : ie.signal);
            } catch (de) {
              if (de instanceof ConnectionError && (de.status === 401 || de.reason === 3)) {
                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), ee(de);
                return;
              }
            }
            Z ? (this.log.info("Initial connection failed with ConnectionError: ".concat(ne.message, ". Retrying with another region: ").concat(Z), this.logContext), yield F(j, ee, Z)) : (this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), ee(ne));
          } else
            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), ee(ne);
        }
      }), H = this.regionUrl;
      return this.regionUrl = void 0, this.connectFuture = new Future((j, ee) => {
        F(j, ee, H);
      }, () => {
        this.clearConnectionFutures();
      }), this.connectFuture.promise;
    }), this.connectSignal = (p, _, I, P, $, F) => __awaiter$3(this, void 0, void 0, function* () {
      var H, j, ee;
      const X = yield I.join(p, _, {
        autoSubscribe: P.autoSubscribe,
        adaptiveStream: typeof $.adaptiveStream == "object" ? !0 : $.adaptiveStream,
        maxRetries: P.maxRetries,
        e2eeEnabled: !!this.e2eeManager,
        websocketTimeout: P.websocketTimeout
      }, F.signal);
      let ie = X.serverInfo;
      if (ie || (ie = {
        version: X.serverVersion,
        region: X.serverRegion
      }), this.log.debug("connected to Livekit Server ".concat(Object.entries(ie).map((Q) => {
        let [ne, Z] = Q;
        return "".concat(ne, ": ").concat(Z);
      }).join(", ")), {
        room: (H = X.room) === null || H === void 0 ? void 0 : H.name,
        roomSid: (j = X.room) === null || j === void 0 ? void 0 : j.sid,
        identity: (ee = X.participant) === null || ee === void 0 ? void 0 : ee.identity
      }), !X.serverVersion)
        throw new UnsupportedServer("unknown server version");
      return X.serverVersion === "0.15.1" && this.options.dynacast && (this.log.debug("disabling dynacast due to server version", this.logContext), $.dynacast = !1), X;
    }), this.applyJoinResponse = (p) => {
      const _ = p.participant;
      this.localParticipant.sid = _.sid, this.localParticipant.identity = _.identity, this.handleParticipantUpdates([_, ...p.otherParticipants]), p.room && this.handleRoomUpdate(p.room), this.options.e2ee && this.e2eeManager && this.e2eeManager.setSifTrailer(p.sifTrailer);
    }, this.attemptConnection = (p, _, I, P) => __awaiter$3(this, void 0, void 0, function* () {
      var $, F, H;
      this.state === ConnectionState.Reconnecting || this.isResuming || !(($ = this.engine) === null || $ === void 0) && $.pendingReconnect ? (this.log.info("Reconnection attempt replaced by new connection attempt", this.logContext), this.recreateEngine()) : this.maybeCreateEngine(), !((F = this.regionUrlProvider) === null || F === void 0) && F.isCloud() && this.engine.setRegionUrlProvider(this.regionUrlProvider), this.acquireAudioContext(), this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), I), this.connOptions.rtcConfig && (this.engine.rtcConfig = this.connOptions.rtcConfig), this.connOptions.peerConnectionTimeout && (this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout);
      try {
        const j = yield this.connectSignal(p, _, this.engine, this.connOptions, this.options, P);
        this.applyJoinResponse(j), this.setupLocalParticipantEvents(), this.emit(RoomEvent.SignalConnected);
      } catch (j) {
        yield this.engine.close(), this.recreateEngine();
        const ee = new ConnectionError("could not establish signal connection");
        throw j instanceof Error && (ee.message = "".concat(ee.message, ": ").concat(j.message)), j instanceof ConnectionError && (ee.reason = j.reason, ee.status = j.status), this.log.debug("error trying to establish signal connection", Object.assign(Object.assign({}, this.logContext), {
          error: j
        })), ee;
      }
      if (P.signal.aborted)
        throw yield this.engine.close(), this.recreateEngine(), new ConnectionError("Connection attempt aborted");
      try {
        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, P);
      } catch (j) {
        throw yield this.engine.close(), this.recreateEngine(), j;
      }
      isWeb() && this.options.disconnectOnPageLeave && (window.addEventListener("pagehide", this.onPageLeave), window.addEventListener("beforeunload", this.onPageLeave)), isWeb() && (document.addEventListener("freeze", this.onPageLeave), (H = navigator.mediaDevices) === null || H === void 0 || H.addEventListener("devicechange", this.handleDeviceChange)), this.setAndEmitConnectionState(ConnectionState.Connected), this.emit(RoomEvent.Connected), this.registerConnectionReconcile();
    }), this.disconnect = function() {
      let p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return __awaiter$3(c, void 0, void 0, function* () {
        var _, I, P, $;
        const F = yield this.disconnectLock.lock();
        try {
          if (this.state === ConnectionState.Disconnected) {
            this.log.debug("already disconnected", this.logContext);
            return;
          }
          this.log.info("disconnect from room", Object.assign({}, this.logContext)), (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting || this.isResuming) && (this.log.warn("abort connection attempt", this.logContext), (_ = this.abortController) === null || _ === void 0 || _.abort(), (P = (I = this.connectFuture) === null || I === void 0 ? void 0 : I.reject) === null || P === void 0 || P.call(I, new ConnectionError("Client initiated disconnect")), this.connectFuture = void 0), !(($ = this.engine) === null || $ === void 0) && $.client.isDisconnected || (yield this.engine.client.sendLeave()), this.engine && (yield this.engine.close()), this.handleDisconnect(p, DisconnectReason.CLIENT_INITIATED), this.engine = void 0;
        } finally {
          F();
        }
      });
    }, this.onPageLeave = () => __awaiter$3(this, void 0, void 0, function* () {
      yield this.disconnect();
    }), this.startAudio = () => __awaiter$3(this, void 0, void 0, function* () {
      const p = [], _ = getBrowser();
      if (_ && _.os === "iOS") {
        const I = "livekit-dummy-audio-el";
        let P = document.getElementById(I);
        if (!P) {
          P = document.createElement("audio"), P.id = I, P.autoplay = !0, P.hidden = !0;
          const $ = getEmptyAudioStreamTrack();
          $.enabled = !0;
          const F = new MediaStream([$]);
          P.srcObject = F, document.addEventListener("visibilitychange", () => {
            P && (P.srcObject = document.hidden ? null : F, document.hidden || (this.log.debug("page visible again, triggering startAudio to resume playback and update playback status", this.logContext), this.startAudio()));
          }), document.body.append(P), this.once(RoomEvent.Disconnected, () => {
            P == null || P.remove(), P = null;
          });
        }
        p.push(P);
      }
      this.remoteParticipants.forEach((I) => {
        I.audioTrackPublications.forEach((P) => {
          P.track && P.track.attachedElements.forEach(($) => {
            p.push($);
          });
        });
      });
      try {
        yield Promise.all([this.acquireAudioContext(), ...p.map((I) => (I.muted = !1, I.play()))]), this.handleAudioPlaybackStarted();
      } catch (I) {
        throw this.handleAudioPlaybackFailed(I), I;
      }
    }), this.startVideo = () => __awaiter$3(this, void 0, void 0, function* () {
      const p = [];
      for (const _ of this.remoteParticipants.values())
        _.videoTrackPublications.forEach((I) => {
          var P;
          (P = I.track) === null || P === void 0 || P.attachedElements.forEach(($) => {
            p.includes($) || p.push($);
          });
        });
      yield Promise.all(p.map((_) => _.play())).then(() => {
        this.handleVideoPlaybackStarted();
      }).catch((_) => {
        _.name === "NotAllowedError" ? this.handleVideoPlaybackFailed() : this.log.warn("Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler", this.logContext);
      });
    }), this.handleRestarting = () => {
      this.clearConnectionReconcile(), this.isResuming = !1;
      for (const p of this.remoteParticipants.values())
        this.handleParticipantDisconnected(p.identity, p);
      this.setAndEmitConnectionState(ConnectionState.Reconnecting) && this.emit(RoomEvent.Reconnecting);
    }, this.handleSignalRestarted = (p) => __awaiter$3(this, void 0, void 0, function* () {
      this.log.debug("signal reconnected to server, region ".concat(p.serverRegion), Object.assign(Object.assign({}, this.logContext), {
        region: p.serverRegion
      })), this.bufferedEvents = [], this.applyJoinResponse(p);
      try {
        yield this.localParticipant.republishAllTracks(void 0, !0);
      } catch (_) {
        this.log.error("error trying to re-publish tracks after reconnection", Object.assign(Object.assign({}, this.logContext), {
          error: _
        }));
      }
      try {
        yield this.engine.waitForRestarted(), this.log.debug("fully reconnected to server", Object.assign(Object.assign({}, this.logContext), {
          region: p.serverRegion
        }));
      } catch {
        return;
      }
      this.setAndEmitConnectionState(ConnectionState.Connected), this.emit(RoomEvent.Reconnected), this.registerConnectionReconcile(), this.emitBufferedEvents();
    }), this.handleParticipantUpdates = (p) => {
      p.forEach((_) => {
        var I;
        if (_.identity === this.localParticipant.identity) {
          this.localParticipant.updateInfo(_);
          return;
        }
        _.identity === "" && (_.identity = (I = this.sidToIdentity.get(_.sid)) !== null && I !== void 0 ? I : "");
        let P = this.remoteParticipants.get(_.identity);
        _.state === ParticipantInfo_State.DISCONNECTED ? this.handleParticipantDisconnected(_.identity, P) : P = this.getOrCreateParticipant(_.identity, _);
      });
    }, this.handleActiveSpeakersUpdate = (p) => {
      const _ = [], I = {};
      p.forEach((P) => {
        if (I[P.sid] = !0, P.sid === this.localParticipant.sid)
          this.localParticipant.audioLevel = P.level, this.localParticipant.setIsSpeaking(!0), _.push(this.localParticipant);
        else {
          const $ = this.getRemoteParticipantBySid(P.sid);
          $ && ($.audioLevel = P.level, $.setIsSpeaking(!0), _.push($));
        }
      }), I[this.localParticipant.sid] || (this.localParticipant.audioLevel = 0, this.localParticipant.setIsSpeaking(!1)), this.remoteParticipants.forEach((P) => {
        I[P.sid] || (P.audioLevel = 0, P.setIsSpeaking(!1));
      }), this.activeSpeakers = _, this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, _);
    }, this.handleSpeakersChanged = (p) => {
      const _ = /* @__PURE__ */ new Map();
      this.activeSpeakers.forEach((P) => {
        _.set(P.sid, P);
      }), p.forEach((P) => {
        let $ = this.getRemoteParticipantBySid(P.sid);
        P.sid === this.localParticipant.sid && ($ = this.localParticipant), $ && ($.audioLevel = P.level, $.setIsSpeaking(P.active), P.active ? _.set(P.sid, $) : _.delete(P.sid));
      });
      const I = Array.from(_.values());
      I.sort((P, $) => $.audioLevel - P.audioLevel), this.activeSpeakers = I, this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, I);
    }, this.handleStreamStateUpdate = (p) => {
      p.streamStates.forEach((_) => {
        const I = this.getRemoteParticipantBySid(_.participantSid);
        if (!I)
          return;
        const P = I.getTrackPublicationBySid(_.trackSid);
        !P || !P.track || (P.track.streamState = Track.streamStateFromProto(_.state), I.emit(ParticipantEvent.TrackStreamStateChanged, P, P.track.streamState), this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, P, P.track.streamState, I));
      });
    }, this.handleSubscriptionPermissionUpdate = (p) => {
      const _ = this.getRemoteParticipantBySid(p.participantSid);
      if (!_)
        return;
      const I = _.getTrackPublicationBySid(p.trackSid);
      I && I.setAllowed(p.allowed);
    }, this.handleSubscriptionError = (p) => {
      const _ = Array.from(this.remoteParticipants.values()).find((P) => P.trackPublications.has(p.trackSid));
      if (!_)
        return;
      const I = _.getTrackPublicationBySid(p.trackSid);
      I && I.setSubscriptionError(p.err);
    }, this.handleDataPacket = (p, _) => {
      const I = this.remoteParticipants.get(p.participantIdentity);
      this.emit(RoomEvent.DataReceived, p.payload, I, _, p.topic), I == null || I.emit(ParticipantEvent.DataReceived, p.payload, _);
    }, this.handleAudioPlaybackStarted = () => {
      this.canPlaybackAudio || (this.audioEnabled = !0, this.emit(RoomEvent.AudioPlaybackStatusChanged, !0));
    }, this.handleAudioPlaybackFailed = (p) => {
      this.log.warn("could not playback audio", Object.assign(Object.assign({}, this.logContext), {
        error: p
      })), this.canPlaybackAudio && (this.audioEnabled = !1, this.emit(RoomEvent.AudioPlaybackStatusChanged, !1));
    }, this.handleVideoPlaybackStarted = () => {
      this.isVideoPlaybackBlocked && (this.isVideoPlaybackBlocked = !1, this.emit(RoomEvent.VideoPlaybackStatusChanged, !0));
    }, this.handleVideoPlaybackFailed = () => {
      this.isVideoPlaybackBlocked || (this.isVideoPlaybackBlocked = !0, this.emit(RoomEvent.VideoPlaybackStatusChanged, !1));
    }, this.handleDeviceChange = () => __awaiter$3(this, void 0, void 0, function* () {
      this.emit(RoomEvent.MediaDevicesChanged);
    }), this.handleRoomUpdate = (p) => {
      const _ = this.roomInfo;
      this.roomInfo = p, _ && _.metadata !== p.metadata && this.emitWhenConnected(RoomEvent.RoomMetadataChanged, p.metadata), (_ == null ? void 0 : _.activeRecording) !== p.activeRecording && this.emitWhenConnected(RoomEvent.RecordingStatusChanged, p.activeRecording);
    }, this.handleConnectionQualityUpdate = (p) => {
      p.updates.forEach((_) => {
        if (_.participantSid === this.localParticipant.sid) {
          this.localParticipant.setConnectionQuality(_.quality);
          return;
        }
        const I = this.getRemoteParticipantBySid(_.participantSid);
        I && I.setConnectionQuality(_.quality);
      });
    }, this.onLocalParticipantMetadataChanged = (p) => {
      this.emit(RoomEvent.ParticipantMetadataChanged, p, this.localParticipant);
    }, this.onLocalParticipantNameChanged = (p) => {
      this.emit(RoomEvent.ParticipantNameChanged, p, this.localParticipant);
    }, this.onLocalTrackMuted = (p) => {
      this.emit(RoomEvent.TrackMuted, p, this.localParticipant);
    }, this.onLocalTrackUnmuted = (p) => {
      this.emit(RoomEvent.TrackUnmuted, p, this.localParticipant);
    }, this.onLocalTrackPublished = (p) => __awaiter$3(this, void 0, void 0, function* () {
      var _;
      this.emit(RoomEvent.LocalTrackPublished, p, this.localParticipant), p.track instanceof LocalAudioTrack && (yield p.track.checkForSilence()) && this.emit(RoomEvent.LocalAudioSilenceDetected, p);
      const I = yield (_ = p.track) === null || _ === void 0 ? void 0 : _.getDeviceId(), P = sourceToKind(p.source);
      P && I && I !== this.localParticipant.activeDeviceMap.get(P) && (this.localParticipant.activeDeviceMap.set(P, I), this.emit(RoomEvent.ActiveDeviceChanged, P, I));
    }), this.onLocalTrackUnpublished = (p) => {
      this.emit(RoomEvent.LocalTrackUnpublished, p, this.localParticipant);
    }, this.onLocalConnectionQualityChanged = (p) => {
      this.emit(RoomEvent.ConnectionQualityChanged, p, this.localParticipant);
    }, this.onMediaDevicesError = (p) => {
      this.emit(RoomEvent.MediaDevicesError, p);
    }, this.onLocalParticipantPermissionsChanged = (p) => {
      this.emit(RoomEvent.ParticipantPermissionsChanged, p, this.localParticipant);
    }, this.setMaxListeners(100), this.remoteParticipants = /* @__PURE__ */ new Map(), this.sidToIdentity = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, roomOptionDefaults), u), this.log = getLogger((l = this.options.loggerName) !== null && l !== void 0 ? l : LoggerNames.Room), this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), u == null ? void 0 : u.audioCaptureDefaults), this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), u == null ? void 0 : u.videoCaptureDefaults), this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), u == null ? void 0 : u.publishDefaults), this.maybeCreateEngine(), this.disconnectLock = new Mutex(), this.localParticipant = new LocalParticipant("", "", this.engine, this.options), this.options.videoCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set("videoinput", unwrapConstraint(this.options.videoCaptureDefaults.deviceId)), this.options.audioCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set("audioinput", unwrapConstraint(this.options.audioCaptureDefaults.deviceId)), !((v = this.options.audioOutput) === null || v === void 0) && v.deviceId && this.switchActiveDevice("audiooutput", unwrapConstraint(this.options.audioOutput.deviceId)).catch((p) => this.log.warn("Could not set audio output: ".concat(p.message), this.logContext)), this.options.e2ee && this.setupE2EE();
  }
  /**
   * @experimental
   */
  setE2EEEnabled(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.e2eeManager)
        yield Promise.all([this.localParticipant.setE2EEEnabled(u)]), this.localParticipant.identity !== "" && this.e2eeManager.setParticipantCryptorEnabled(u, this.localParticipant.identity);
      else
        throw Error("e2ee not configured, please set e2ee settings within the room options");
    });
  }
  setupE2EE() {
    var u;
    this.options.e2ee && (this.e2eeManager = new E2EEManager(this.options.e2ee), this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (c, l) => {
      l instanceof LocalParticipant && (this.isE2EEEnabled = c), this.emit(RoomEvent.ParticipantEncryptionStatusChanged, c, l);
    }), this.e2eeManager.on(EncryptionEvent.EncryptionError, (c) => this.emit(RoomEvent.EncryptionError, c)), (u = this.e2eeManager) === null || u === void 0 || u.setup(this));
  }
  get logContext() {
    var u;
    return {
      room: this.name,
      roomSid: (u = this.roomInfo) === null || u === void 0 ? void 0 : u.sid,
      identity: this.localParticipant.identity
    };
  }
  /**
   * if the current room has a participant with `recorder: true` in its JWT grant
   **/
  get isRecording() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.activeRecording) !== null && c !== void 0 ? c : !1;
  }
  /**
   * server assigned unique room id.
   * returns once a sid has been issued by the server.
   */
  getSid() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.state === ConnectionState.Disconnected ? "" : this.roomInfo && this.roomInfo.sid !== "" ? this.roomInfo.sid : new Promise((u, c) => {
        const l = (v) => {
          v.sid !== "" && (this.engine.off(EngineEvent.RoomUpdate, l), u(v.sid));
        };
        this.engine.on(EngineEvent.RoomUpdate, l), this.once(RoomEvent.Disconnected, () => {
          this.engine.off(EngineEvent.RoomUpdate, l), c("Room disconnected before room server id was available");
        });
      });
    });
  }
  /** user assigned name, derived from JWT token */
  get name() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.name) !== null && c !== void 0 ? c : "";
  }
  /** room metadata */
  get metadata() {
    var u;
    return (u = this.roomInfo) === null || u === void 0 ? void 0 : u.metadata;
  }
  get numParticipants() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.numParticipants) !== null && c !== void 0 ? c : 0;
  }
  get numPublishers() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.numPublishers) !== null && c !== void 0 ? c : 0;
  }
  maybeCreateEngine() {
    this.engine && !this.engine.isClosed || (this.engine = new RTCEngine(this.options), this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (u, c, l) => {
      this.onTrackAdded(u, c, l);
    }).on(EngineEvent.Disconnected, (u) => {
      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, u);
    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {
      this.clearConnectionReconcile(), this.isResuming = !0, this.log.info("Resuming signal connection", this.logContext);
    }).on(EngineEvent.Resumed, () => {
      this.registerConnectionReconcile(), this.isResuming = !1, this.log.info("Resumed signal connection", this.logContext), this.updateSubscriptions(), this.emitBufferedEvents();
    }).on(EngineEvent.SignalResumed, () => {
      this.bufferedEvents = [], (this.state === ConnectionState.Reconnecting || this.isResuming) && this.sendSyncState();
    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.DCBufferStatusChanged, (u, c) => {
      this.emit(RoomEvent.DCBufferStatusChanged, u, c);
    }), this.localParticipant && this.localParticipant.setupEngine(this.engine), this.e2eeManager && this.e2eeManager.setupEngine(this.engine));
  }
  /**
   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
   * In particular, it handles Chrome's unique behavior of creating `default`
   * devices. When encountered, it'll be removed from the list of devices.
   * The actual default device will be placed at top.
   * @param kind
   * @returns a list of available local devices
   */
  static getLocalDevices(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return DeviceManager.getInstance().getDevices(u, c);
  }
  /**
   * prepareConnection should be called as soon as the page is loaded, in order
   * to speed up the connection attempt. This function will
   * - perform DNS resolution and pre-warm the DNS cache
   * - establish TLS connection and cache TLS keys
   *
   * With LiveKit Cloud, it will also determine the best edge data center for
   * the current client to connect to if a token is provided.
   */
  prepareConnection(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.state === ConnectionState.Disconnected) {
        this.log.debug("prepareConnection to ".concat(u), this.logContext);
        try {
          if (isCloud(new URL(u)) && c) {
            this.regionUrlProvider = new RegionUrlProvider(u, c);
            const l = yield this.regionUrlProvider.getNextBestRegionUrl();
            l && this.state === ConnectionState.Disconnected && (this.regionUrl = l, yield fetch(toHttpUrl(l), {
              method: "HEAD"
            }), this.log.debug("prepared connection to ".concat(l), this.logContext));
          } else
            yield fetch(toHttpUrl(u), {
              method: "HEAD"
            });
        } catch (l) {
          this.log.warn("could not prepare connection", Object.assign(Object.assign({}, this.logContext), {
            error: l
          }));
        }
      }
    });
  }
  /**
   * retrieves a participant by identity
   * @param identity
   * @returns
   */
  getParticipantByIdentity(u) {
    return this.localParticipant.identity === u ? this.localParticipant : this.remoteParticipants.get(u);
  }
  clearConnectionFutures() {
    this.connectFuture = void 0;
  }
  /**
   * @internal for testing
   */
  simulateScenario(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let l = () => {
      }, v;
      switch (u) {
        case "signal-reconnect":
          yield this.engine.client.handleOnClose("simulate disconnect");
          break;
        case "speaker":
          v = new SimulateScenario({
            scenario: {
              case: "speakerUpdate",
              value: 3
            }
          });
          break;
        case "node-failure":
          v = new SimulateScenario({
            scenario: {
              case: "nodeFailure",
              value: !0
            }
          });
          break;
        case "server-leave":
          v = new SimulateScenario({
            scenario: {
              case: "serverLeave",
              value: !0
            }
          });
          break;
        case "migration":
          v = new SimulateScenario({
            scenario: {
              case: "migration",
              value: !0
            }
          });
          break;
        case "resume-reconnect":
          this.engine.failNext(), yield this.engine.client.handleOnClose("simulate resume-disconnect");
          break;
        case "disconnect-signal-on-resume":
          l = () => __awaiter$3(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          }), v = new SimulateScenario({
            scenario: {
              case: "disconnectSignalOnResume",
              value: !0
            }
          });
          break;
        case "disconnect-signal-on-resume-no-messages":
          l = () => __awaiter$3(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          }), v = new SimulateScenario({
            scenario: {
              case: "disconnectSignalOnResumeNoMessages",
              value: !0
            }
          });
          break;
        case "full-reconnect":
          this.engine.fullReconnectOnNext = !0, yield this.engine.client.handleOnClose("simulate full-reconnect");
          break;
        case "force-tcp":
        case "force-tls":
          v = new SimulateScenario({
            scenario: {
              case: "switchCandidateProtocol",
              value: u === "force-tls" ? 2 : 1
            }
          }), l = () => __awaiter$3(this, void 0, void 0, function* () {
            const p = this.engine.client.onLeave;
            p && p(new LeaveRequest({
              reason: DisconnectReason.CLIENT_INITIATED,
              canReconnect: !0
            }));
          });
          break;
        case "subscriber-bandwidth":
          if (c === void 0 || typeof c != "number")
            throw new Error("subscriber-bandwidth requires a number as argument");
          v = new SimulateScenario({
            scenario: {
              case: "subscriberBandwidth",
              value: BigInt(c)
            }
          });
          break;
      }
      v && (yield this.engine.client.sendSimulateScenario(v), yield l());
    });
  }
  /**
   * Returns true if audio playback is enabled
   */
  get canPlaybackAudio() {
    return this.audioEnabled;
  }
  /**
   * Returns true if video playback is enabled
   */
  get canPlaybackVideo() {
    return !this.isVideoPlaybackBlocked;
  }
  getActiveDevice(u) {
    return this.localParticipant.activeDeviceMap.get(u);
  }
  /**
   * Switches all active devices used in this room to the given device.
   *
   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
   *
   * @param kind use `videoinput` for camera track,
   *  `audioinput` for microphone track,
   *  `audiooutput` to set speaker for all incoming audio tracks
   * @param deviceId
   */
  switchActiveDevice(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    var v, p, _;
    return __awaiter$3(this, void 0, void 0, function* () {
      let I = !1, P = !0;
      const $ = l ? {
        exact: c
      } : c;
      if (u === "audioinput") {
        const F = this.options.audioCaptureDefaults.deviceId;
        this.options.audioCaptureDefaults.deviceId = $, I = F !== $;
        const H = Array.from(this.localParticipant.audioTrackPublications.values()).filter((j) => j.source === Track.Source.Microphone);
        try {
          P = (yield Promise.all(H.map((j) => {
            var ee;
            return (ee = j.audioTrack) === null || ee === void 0 ? void 0 : ee.setDeviceId($);
          }))).every((j) => j === !0);
        } catch (j) {
          throw this.options.audioCaptureDefaults.deviceId = F, j;
        }
      } else if (u === "videoinput") {
        const F = this.options.videoCaptureDefaults.deviceId;
        this.options.videoCaptureDefaults.deviceId = $, I = F !== $;
        const H = Array.from(this.localParticipant.videoTrackPublications.values()).filter((j) => j.source === Track.Source.Camera);
        try {
          P = (yield Promise.all(H.map((j) => {
            var ee;
            return (ee = j.videoTrack) === null || ee === void 0 ? void 0 : ee.setDeviceId($);
          }))).every((j) => j === !0);
        } catch (j) {
          throw this.options.videoCaptureDefaults.deviceId = F, j;
        }
      } else if (u === "audiooutput") {
        if (!supportsSetSinkId() && !this.options.webAudioMix || this.options.webAudioMix && this.audioContext && !("setSinkId" in this.audioContext))
          throw new Error("cannot switch audio output, setSinkId not supported");
        (v = (_ = this.options).audioOutput) !== null && v !== void 0 || (_.audioOutput = {});
        const F = this.options.audioOutput.deviceId;
        this.options.audioOutput.deviceId = c, I = F !== $;
        try {
          this.options.webAudioMix ? (p = this.audioContext) === null || p === void 0 || p.setSinkId(c) : yield Promise.all(Array.from(this.remoteParticipants.values()).map((H) => H.setAudioOutput({
            deviceId: c
          })));
        } catch (H) {
          throw this.options.audioOutput.deviceId = F, H;
        }
      }
      return I && P && (this.localParticipant.activeDeviceMap.set(u, c), this.emit(RoomEvent.ActiveDeviceChanged, u, c)), P;
    });
  }
  setupLocalParticipantEvents() {
    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
  }
  recreateEngine() {
    var u;
    (u = this.engine) === null || u === void 0 || u.close(), this.engine = void 0, this.isResuming = !1, this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.bufferedEvents = [], this.maybeCreateEngine();
  }
  onTrackAdded(u, c, l) {
    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {
      const F = () => {
        this.onTrackAdded(u, c, l), H();
      }, H = () => {
        this.off(RoomEvent.Reconnected, F), this.off(RoomEvent.Connected, F), this.off(RoomEvent.Disconnected, H);
      };
      this.once(RoomEvent.Reconnected, F), this.once(RoomEvent.Connected, F), this.once(RoomEvent.Disconnected, H);
      return;
    }
    if (this.state === ConnectionState.Disconnected) {
      this.log.warn("skipping incoming track after Room disconnected", this.logContext);
      return;
    }
    const v = unpackStreamId(c.id), p = v[0];
    let _ = v[1], I = u.id;
    if (_ && _.startsWith("TR") && (I = _), p === this.localParticipant.sid) {
      this.log.warn("tried to create RemoteParticipant for local participant", this.logContext);
      return;
    }
    const P = Array.from(this.remoteParticipants.values()).find((F) => F.sid === p);
    if (!P) {
      this.log.error("Tried to add a track for a participant, that's not present. Sid: ".concat(p), this.logContext);
      return;
    }
    let $;
    this.options.adaptiveStream && (typeof this.options.adaptiveStream == "object" ? $ = this.options.adaptiveStream : $ = {}), P.addSubscribedMediaTrack(u, I, c, l, $);
  }
  handleDisconnect() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, c = arguments.length > 1 ? arguments[1] : void 0;
    var l;
    if (this.clearConnectionReconcile(), this.isResuming = !1, this.bufferedEvents = [], this.state !== ConnectionState.Disconnected) {
      this.regionUrl = void 0;
      try {
        this.remoteParticipants.forEach((v) => {
          v.trackPublications.forEach((p) => {
            v.unpublishTrack(p.trackSid);
          });
        }), this.localParticipant.trackPublications.forEach((v) => {
          var p, _;
          v.track && this.localParticipant.unpublishTrack(v.track, u), u && ((p = v.track) === null || p === void 0 || p.detach(), (_ = v.track) === null || _ === void 0 || _.stop());
        }), this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged), this.localParticipant.trackPublications.clear(), this.localParticipant.videoTrackPublications.clear(), this.localParticipant.audioTrackPublications.clear(), this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.activeSpeakers = [], this.audioContext && typeof this.options.webAudioMix == "boolean" && (this.audioContext.close(), this.audioContext = void 0), isWeb() && (window.removeEventListener("beforeunload", this.onPageLeave), window.removeEventListener("pagehide", this.onPageLeave), window.removeEventListener("freeze", this.onPageLeave), (l = navigator.mediaDevices) === null || l === void 0 || l.removeEventListener("devicechange", this.handleDeviceChange));
      } finally {
        this.setAndEmitConnectionState(ConnectionState.Disconnected), this.emit(RoomEvent.Disconnected, c);
      }
    }
  }
  handleParticipantDisconnected(u, c) {
    this.remoteParticipants.delete(u), c && (c.trackPublications.forEach((l) => {
      c.unpublishTrack(l.trackSid, !0);
    }), this.emit(RoomEvent.ParticipantDisconnected, c));
  }
  acquireAudioContext() {
    var u, c;
    return __awaiter$3(this, void 0, void 0, function* () {
      if (typeof this.options.webAudioMix != "boolean" && this.options.webAudioMix.audioContext ? this.audioContext = this.options.webAudioMix.audioContext : (!this.audioContext || this.audioContext.state === "closed") && (this.audioContext = (u = getNewAudioContext()) !== null && u !== void 0 ? u : void 0), this.audioContext && this.audioContext.state === "suspended")
        try {
          yield this.audioContext.resume();
        } catch (v) {
          this.log.warn("Could not resume audio context", Object.assign(Object.assign({}, this.logContext), {
            error: v
          }));
        }
      this.options.webAudioMix && this.remoteParticipants.forEach((v) => v.setAudioContext(this.audioContext)), this.localParticipant.setAudioContext(this.audioContext);
      const l = ((c = this.audioContext) === null || c === void 0 ? void 0 : c.state) === "running";
      l !== this.canPlaybackAudio && (this.audioEnabled = l, this.emit(RoomEvent.AudioPlaybackStatusChanged, l));
    });
  }
  createParticipant(u, c) {
    var l;
    let v;
    return c ? v = RemoteParticipant.fromParticipantInfo(this.engine.client, c) : v = new RemoteParticipant(this.engine.client, "", u, void 0, void 0, {
      loggerContextCb: () => this.logContext,
      loggerName: this.options.loggerName
    }), this.options.webAudioMix && v.setAudioContext(this.audioContext), !((l = this.options.audioOutput) === null || l === void 0) && l.deviceId && v.setAudioOutput(this.options.audioOutput).catch((p) => this.log.warn("Could not set audio output: ".concat(p.message), this.logContext)), v;
  }
  getOrCreateParticipant(u, c) {
    if (this.remoteParticipants.has(u)) {
      const v = this.remoteParticipants.get(u);
      return c && v.updateInfo(c) && this.sidToIdentity.set(c.sid, c.identity), v;
    }
    const l = this.createParticipant(u, c);
    return this.remoteParticipants.set(u, l), this.sidToIdentity.set(c.sid, c.identity), this.emitWhenConnected(RoomEvent.ParticipantConnected, l), l.on(ParticipantEvent.TrackPublished, (v) => {
      this.emitWhenConnected(RoomEvent.TrackPublished, v, l);
    }).on(ParticipantEvent.TrackSubscribed, (v, p) => {
      v.kind === Track.Kind.Audio ? (v.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted), v.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed)) : v.kind === Track.Kind.Video && (v.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed), v.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted)), this.emit(RoomEvent.TrackSubscribed, v, p, l);
    }).on(ParticipantEvent.TrackUnpublished, (v) => {
      this.emit(RoomEvent.TrackUnpublished, v, l);
    }).on(ParticipantEvent.TrackUnsubscribed, (v, p) => {
      this.emit(RoomEvent.TrackUnsubscribed, v, p, l);
    }).on(ParticipantEvent.TrackSubscriptionFailed, (v) => {
      this.emit(RoomEvent.TrackSubscriptionFailed, v, l);
    }).on(ParticipantEvent.TrackMuted, (v) => {
      this.emitWhenConnected(RoomEvent.TrackMuted, v, l);
    }).on(ParticipantEvent.TrackUnmuted, (v) => {
      this.emitWhenConnected(RoomEvent.TrackUnmuted, v, l);
    }).on(ParticipantEvent.ParticipantMetadataChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, v, l);
    }).on(ParticipantEvent.ParticipantNameChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantNameChanged, v, l);
    }).on(ParticipantEvent.ConnectionQualityChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, v, l);
    }).on(ParticipantEvent.ParticipantPermissionsChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, v, l);
    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (v, p) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, v, p, l);
    }).on(ParticipantEvent.TrackSubscriptionFailed, (v, p) => {
      this.emit(RoomEvent.TrackSubscriptionFailed, v, l, p);
    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (v, p) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, v, p, l);
    }), c && l.updateInfo(c), l;
  }
  sendSyncState() {
    const u = Array.from(this.remoteParticipants.values()).reduce((l, v) => (l.push(...v.getTrackPublications()), l), []), c = this.localParticipant.getTrackPublications();
    this.engine.sendSyncState(u, c);
  }
  /**
   * After resuming, we'll need to notify the server of the current
   * subscription settings.
   */
  updateSubscriptions() {
    for (const u of this.remoteParticipants.values())
      for (const c of u.videoTrackPublications.values())
        c.isSubscribed && c instanceof RemoteTrackPublication && c.emitTrackUpdate();
  }
  getRemoteParticipantBySid(u) {
    const c = this.sidToIdentity.get(u);
    if (c)
      return this.remoteParticipants.get(c);
  }
  registerConnectionReconcile() {
    this.clearConnectionReconcile();
    let u = 0;
    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {
      // ensure we didn't tear it down
      !this.engine || // engine detected close, but Room missed it
      this.engine.isClosed || // transports failed without notifying engine
      !this.engine.verifyTransport() ? (u++, this.log.warn("detected connection state mismatch", Object.assign(Object.assign({}, this.logContext), {
        numFailures: u,
        engine: {
          closed: this.engine.isClosed,
          transportsConnected: this.engine.verifyTransport()
        }
      })), u >= 3 && (this.recreateEngine(), this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH))) : u = 0;
    }, connectionReconcileFrequency);
  }
  clearConnectionReconcile() {
    this.connectionReconcileInterval && CriticalTimers.clearInterval(this.connectionReconcileInterval);
  }
  setAndEmitConnectionState(u) {
    return u === this.state ? !1 : (this.state = u, this.emit(RoomEvent.ConnectionStateChanged, this.state), !0);
  }
  emitBufferedEvents() {
    this.bufferedEvents.forEach((u) => {
      let [c, l] = u;
      this.emit(c, ...l);
    }), this.bufferedEvents = [];
  }
  emitWhenConnected(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect)
      this.bufferedEvents.push([u, l]);
    else if (this.state === ConnectionState.Connected)
      return this.emit(u, ...l);
    return !1;
  }
  /**
   * Allows to populate a room with simulated participants.
   * No actual connection to a server will be established, all state is
   * @experimental
   */
  simulateParticipants(u) {
    var c, l;
    return __awaiter$3(this, void 0, void 0, function* () {
      const v = Object.assign({
        audio: !0,
        video: !0,
        useRealTracks: !1
      }, u.publish), p = Object.assign({
        count: 9,
        audio: !1,
        video: !0,
        aspectRatios: [1.66, 1.7, 1.3]
      }, u.participants);
      if (this.handleDisconnect(), this.roomInfo = new Room$1({
        sid: "RM_SIMULATED",
        name: "simulated-room",
        emptyTimeout: 0,
        maxParticipants: 0,
        creationTime: protoInt64.parse((/* @__PURE__ */ new Date()).getTime()),
        metadata: "",
        numParticipants: 1,
        numPublishers: 1,
        turnPassword: "",
        enabledCodecs: [],
        activeRecording: !1
      }), this.localParticipant.updateInfo(new ParticipantInfo({
        identity: "simulated-local",
        name: "local-name"
      })), this.setupLocalParticipantEvents(), this.emit(RoomEvent.SignalConnected), this.emit(RoomEvent.Connected), this.setAndEmitConnectionState(ConnectionState.Connected), v.video) {
        const _ = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({
          source: TrackSource.CAMERA,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO,
          name: "video-dummy"
        }), new LocalVideoTrack(v.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({
          video: !0
        })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((c = p.aspectRatios[0]) !== null && c !== void 0 ? c : 1), 160, !0, !0), void 0, !1, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(_), this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, _);
      }
      if (v.audio) {
        const _ = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({
          source: TrackSource.MICROPHONE,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO
        }), new LocalAudioTrack(v.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({
          audio: !0
        })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), void 0, !1, this.audioContext, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(_), this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, _);
      }
      for (let _ = 0; _ < p.count - 1; _ += 1) {
        let I = new ParticipantInfo({
          sid: Math.floor(Math.random() * 1e4).toString(),
          identity: "simulated-".concat(_),
          state: ParticipantInfo_State.ACTIVE,
          tracks: [],
          joinedAt: protoInt64.parse(Date.now())
        });
        const P = this.getOrCreateParticipant(I.identity, I);
        if (p.video) {
          const $ = createDummyVideoStreamTrack(160 * ((l = p.aspectRatios[_ % p.aspectRatios.length]) !== null && l !== void 0 ? l : 1), 160, !1, !0), F = new TrackInfo({
            source: TrackSource.CAMERA,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          });
          P.addSubscribedMediaTrack($, F.sid, new MediaStream([$])), I.tracks = [...I.tracks, F];
        }
        if (p.audio) {
          const $ = getEmptyAudioStreamTrack(), F = new TrackInfo({
            source: TrackSource.MICROPHONE,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          });
          P.addSubscribedMediaTrack($, F.sid, new MediaStream([$])), I.tracks = [...I.tracks, F];
        }
        P.updateInfo(I);
      }
    });
  }
  // /** @internal */
  emit(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    if (u !== RoomEvent.ActiveSpeakersChanged) {
      const p = mapArgs(l).filter((_) => _ !== void 0);
      this.log.debug("room event ".concat(u), Object.assign(Object.assign({}, this.logContext), {
        event: u,
        args: p
      }));
    }
    return super.emit(u, ...l);
  }
}
function mapArgs(a) {
  return a.map((u) => {
    if (u)
      return Array.isArray(u) ? mapArgs(u) : typeof u == "object" ? "logContext" in u && u.logContext : u;
  });
}
var CheckStatus;
(function(a) {
  a[a.IDLE = 0] = "IDLE", a[a.RUNNING = 1] = "RUNNING", a[a.SKIPPED = 2] = "SKIPPED", a[a.SUCCESS = 3] = "SUCCESS", a[a.FAILED = 4] = "FAILED";
})(CheckStatus || (CheckStatus = {}));
class Checker extends eventsExports$1.EventEmitter {
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    super(), this.status = CheckStatus.IDLE, this.logs = [], this.errorsAsWarnings = !1, this.url = u, this.token = c, this.name = this.constructor.name, this.room = new Room(l.roomOptions), this.connectOptions = l.connectOptions, l.errorsAsWarnings && (this.errorsAsWarnings = l.errorsAsWarnings);
  }
  run(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      if (this.status !== CheckStatus.IDLE)
        throw Error("check is running already");
      this.setStatus(CheckStatus.RUNNING);
      try {
        yield this.perform();
      } catch (c) {
        c instanceof Error && (this.errorsAsWarnings ? this.appendWarning(c.message) : this.appendError(c.message));
      }
      return yield this.disconnect(), yield new Promise((c) => setTimeout(c, 500)), this.status !== CheckStatus.SKIPPED && this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED), u && u(), this.getInfo();
    });
  }
  isSuccess() {
    return !this.logs.some((u) => u.level === "error");
  }
  connect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.room.state === ConnectionState.Connected ? this.room : (yield this.room.connect(this.url, this.token), this.room);
    });
  }
  disconnect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      this.room && this.room.state !== ConnectionState.Disconnected && (yield this.room.disconnect(), yield new Promise((u) => setTimeout(u, 500)));
    });
  }
  skip() {
    this.setStatus(CheckStatus.SKIPPED);
  }
  appendMessage(u) {
    this.logs.push({
      level: "info",
      message: u
    }), this.emit("update", this.getInfo());
  }
  appendWarning(u) {
    this.logs.push({
      level: "warning",
      message: u
    }), this.emit("update", this.getInfo());
  }
  appendError(u) {
    this.logs.push({
      level: "error",
      message: u
    }), this.emit("update", this.getInfo());
  }
  setStatus(u) {
    this.status = u, this.emit("update", this.getInfo());
  }
  get engine() {
    var u;
    return (u = this.room) === null || u === void 0 ? void 0 : u.engine;
  }
  getInfo() {
    return {
      logs: this.logs,
      name: this.name,
      status: this.status,
      description: this.description
    };
  }
}
function createLocalTracks(a) {
  var u, c;
  return __awaiter$3(this, void 0, void 0, function* () {
    a ?? (a = {}), (u = a.audio) !== null && u !== void 0 || (a.audio = !0), (c = a.video) !== null && c !== void 0 || (a.video = !0);
    const l = mergeDefaultOptions(a, audioDefaults, videoDefaults), v = constraintsForOptions(l), p = navigator.mediaDevices.getUserMedia(v);
    a.audio && (DeviceManager.userMediaPromiseMap.set("audioinput", p), p.catch(() => DeviceManager.userMediaPromiseMap.delete("audioinput"))), a.video && (DeviceManager.userMediaPromiseMap.set("videoinput", p), p.catch(() => DeviceManager.userMediaPromiseMap.delete("videoinput")));
    const _ = yield p;
    return _.getTracks().map((I) => {
      const P = I.kind === "audio";
      P ? a.audio : a.video;
      let $;
      const F = P ? v.audio : v.video;
      typeof F != "boolean" && ($ = F), $ ? $.deviceId = I.getSettings().deviceId : $ = {
        deviceId: I.getSettings().deviceId
      };
      const H = mediaTrackToLocalTrack(I, $);
      return H.kind === Track.Kind.Video ? H.source = Track.Source.Camera : H.kind === Track.Kind.Audio && (H.source = Track.Source.Microphone), H.mediaStream = _, H;
    });
  });
}
function createLocalVideoTrack(a) {
  return __awaiter$3(this, void 0, void 0, function* () {
    return (yield createLocalTracks({
      audio: !1,
      video: a
    }))[0];
  });
}
function createLocalAudioTrack(a) {
  return __awaiter$3(this, void 0, void 0, function* () {
    return (yield createLocalTracks({
      audio: a,
      video: !1
    }))[0];
  });
}
class PublishAudioCheck extends Checker {
  get description() {
    return "Can publish audio";
  }
  perform() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.connect(), l = yield createLocalAudioTrack();
      c.localParticipant.publishTrack(l), yield new Promise((_) => setTimeout(_, 3e3));
      const v = yield (u = l.sender) === null || u === void 0 ? void 0 : u.getStats();
      if (!v)
        throw new Error("Could not get RTCStats");
      let p = 0;
      if (v.forEach((_) => {
        _.type === "outbound-rtp" && _.mediaType === "audio" && (p = _.packetsSent);
      }), p === 0)
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat(p, " audio packets"));
    });
  }
}
class PublishVideoCheck extends Checker {
  get description() {
    return "Can publish video";
  }
  perform() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.connect(), l = yield createLocalVideoTrack();
      c.localParticipant.publishTrack(l), yield new Promise((_) => setTimeout(_, 3e3));
      const v = yield (u = l.sender) === null || u === void 0 ? void 0 : u.getStats();
      if (!v)
        throw new Error("Could not get RTCStats");
      let p = 0;
      if (v.forEach((_) => {
        _.type === "outbound-rtp" && _.mediaType === "video" && (p = _.packetsSent);
      }), p === 0)
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat(p, " video packets"));
    });
  }
}
class ReconnectCheck extends Checker {
  get description() {
    return "Resuming connection after interruption";
  }
  perform() {
    var u;
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.connect();
      let l = !1, v = !1, p;
      const _ = new Promise((P) => {
        setTimeout(P, 5e3), p = P;
      });
      c.on(RoomEvent.Reconnecting, () => {
        l = !0;
      }).on(RoomEvent.Reconnected, () => {
        v = !0, p(!0);
      }), (u = c.engine.client.ws) === null || u === void 0 || u.close();
      const I = c.engine.client.onClose;
      if (I && I(""), yield _, l) {
        if (!v || c.state !== ConnectionState.Connected)
          throw this.appendWarning("reconnection is only possible in Redis-based configurations"), new Error("Not able to reconnect");
      } else
        throw new Error("Did not attempt to reconnect");
    });
  }
}
class TURNCheck extends Checker {
  get description() {
    return "Can connect via TURN";
  }
  perform() {
    var u, c;
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = new SignalClient(), v = yield l.join(this.url, this.token, {
        autoSubscribe: !0,
        maxRetries: 0,
        e2eeEnabled: !1,
        websocketTimeout: 15e3
      });
      let p = !1, _ = !1, I = !1;
      for (let P of v.iceServers)
        for (let $ of P.urls)
          $.startsWith("turn:") ? (_ = !0, I = !0) : $.startsWith("turns:") && (_ = !0, I = !0, p = !0), $.startsWith("stun:") && (I = !0);
      I ? _ && !p && this.appendWarning("TURN is configured server side, but TURN/TLS is unavailable.") : this.appendWarning("No STUN servers configured on server side."), yield l.close(), !((c = (u = this.connectOptions) === null || u === void 0 ? void 0 : u.rtcConfig) === null || c === void 0) && c.iceServers || _ ? yield this.room.connect(this.url, this.token, {
        rtcConfig: {
          iceTransportPolicy: "relay"
        }
      }) : (this.appendWarning("No TURN servers configured."), this.skip(), yield new Promise((P) => setTimeout(P, 0)));
    });
  }
}
class WebRTCCheck extends Checker {
  get description() {
    return "Establishing WebRTC connection";
  }
  perform() {
    return __awaiter$3(this, void 0, void 0, function* () {
      let u = !1, c = !1;
      this.room.on(RoomEvent.SignalConnected, () => {
        const l = this.room.engine.client.onTrickle;
        this.room.engine.client.onTrickle = (v, p) => {
          if (v.candidate) {
            const _ = new RTCIceCandidate(v);
            let I = "".concat(_.protocol, " ").concat(_.address, ":").concat(_.port, " ").concat(_.type);
            _.address && (isIPPrivate(_.address) ? I += " (private)" : _.protocol === "tcp" && _.tcpType === "passive" ? (u = !0, I += " (passive)") : _.protocol === "udp" && (c = !0)), this.appendMessage(I);
          }
          l && l(v, p);
        }, this.room.engine.pcManager && (this.room.engine.pcManager.subscriber.onIceCandidateError = (v) => {
          v instanceof RTCPeerConnectionIceErrorEvent && this.appendWarning("error with ICE candidate: ".concat(v.errorCode, " ").concat(v.errorText, " ").concat(v.url));
        });
      });
      try {
        yield this.connect(), livekitLogger.info("now the room is connected");
      } catch (l) {
        throw this.appendWarning("ports need to be open on firewall in order to connect."), l;
      }
      u || this.appendWarning("Server is not configured for ICE/TCP"), c || this.appendWarning("No public IPv4 UDP candidates were found. Your server is likely not configured correctly");
    });
  }
}
function isIPPrivate(a) {
  const u = a.split(".");
  if (u.length === 4) {
    if (u[0] === "10")
      return !0;
    if (u[0] === "192" && u[1] === "168")
      return !0;
    if (u[0] === "172") {
      const c = parseInt(u[1], 10);
      if (c >= 16 && c <= 31)
        return !0;
    }
  }
  return !1;
}
class WebSocketCheck extends Checker {
  get description() {
    return "Connecting to signal connection via WebSocket";
  }
  perform() {
    var u, c, l;
    return __awaiter$3(this, void 0, void 0, function* () {
      (this.url.startsWith("ws:") || this.url.startsWith("http:")) && this.appendWarning("Server is insecure, clients may block connections to it");
      let v = new SignalClient();
      const p = yield v.join(this.url, this.token, {
        autoSubscribe: !0,
        maxRetries: 0,
        e2eeEnabled: !1,
        websocketTimeout: 15e3
      });
      this.appendMessage("Connected to server, version ".concat(p.serverVersion, ".")), ((u = p.serverInfo) === null || u === void 0 ? void 0 : u.edition) === ServerInfo_Edition.Cloud && (!((c = p.serverInfo) === null || c === void 0) && c.region) && this.appendMessage("LiveKit Cloud: ".concat((l = p.serverInfo) === null || l === void 0 ? void 0 : l.region)), yield v.close();
    });
  }
}
class ConnectionCheck extends eventsExports$1.EventEmitter {
  constructor(u, c) {
    super(), this.checkResults = /* @__PURE__ */ new Map(), this.url = u, this.token = c;
  }
  getNextCheckId() {
    const u = this.checkResults.size;
    return this.checkResults.set(u, {
      logs: [],
      status: CheckStatus.IDLE,
      name: "",
      description: ""
    }), u;
  }
  updateCheck(u, c) {
    this.checkResults.set(u, c), this.emit("checkUpdate", u, c);
  }
  isSuccess() {
    return Array.from(this.checkResults.values()).every((u) => u.status !== CheckStatus.FAILED);
  }
  getResults() {
    return Array.from(this.checkResults.values());
  }
  createAndRunCheck(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = this.getNextCheckId(), l = new u(this.url, this.token), v = (_) => {
        this.updateCheck(c, _);
      };
      l.on("update", v);
      const p = yield l.run();
      return l.off("update", v), p;
    });
  }
  checkWebsocket() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebSocketCheck);
    });
  }
  checkWebRTC() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebRTCCheck);
    });
  }
  checkTURN() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(TURNCheck);
    });
  }
  checkReconnect() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(ReconnectCheck);
    });
  }
  checkPublishAudio() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishAudioCheck);
    });
  }
  checkPublishVideo() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishVideoCheck);
    });
  }
}
const Rendering = lib$2.LiveApiModel.Rendering, VideoRendering = lib$2.LiveApiModel.VideoRendering, AudioRendering = lib$2.LiveApiModel.AudioRendering, RenderingQuality = lib$2.LiveApiModel.RenderingQuality, Encoding = lib$2.LiveApiModel.Encoding, VideoEncoding = lib$2.LiveApiModel.VideoEncoding, AudioEncoding = lib$2.LiveApiModel.AudioEncoding, ProjectBroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase, Role = lib$2.LiveApiModel.Role, DestinationAddress = lib$2.LiveApiModel.DestinationAddress, VideoCodec = lib$2.LiveApiModel.VideoCodec, AudioCodec = lib$2.LiveApiModel.AudioCodec, VideoCodecRateControl = lib$2.LiveApiModel.VideoCodecRateControl, VideoCodecProfile = lib$2.LiveApiModel.VideoCodecProfile, types$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AudioCodec,
  AudioEncoding,
  AudioRendering,
  DestinationAddress,
  Encoding,
  ProjectBroadcastPhase,
  Rendering,
  RenderingQuality,
  Role,
  VideoCodec,
  VideoCodecProfile,
  VideoCodecRateControl,
  VideoEncoding,
  VideoRendering
}, Symbol.toStringTag, { value: "Module" }));
var Permission = /* @__PURE__ */ ((a) => (a[a.ReadProject = 0] = "ReadProject", a[a.UpdateProject = 1] = "UpdateProject", a[a.JoinRoom = 2] = "JoinRoom", a[a.InviteGuests = 3] = "InviteGuests", a[a.ManageGuests = 4] = "ManageGuests", a[a.ManageBroadcast = 5] = "ManageBroadcast", a[a.ManageSelf = 6] = "ManageSelf", a))(Permission || {});
const permissions = {
  [Role.ROLE_HOST]: [
    0,
    1,
    2,
    3,
    4,
    5
    /* ManageBroadcast */
  ],
  [Role.ROLE_COHOST]: [
    0,
    1,
    2,
    3,
    4,
    5
    /* ManageBroadcast */
  ],
  [Role.ROLE_CONTRIBUTOR]: [
    0,
    1,
    2,
    3
    /* InviteGuests */
  ],
  [Role.ROLE_GUEST]: [
    0,
    2,
    6
    /* ManageSelf */
  ],
  [Role.ROLE_VIEWER]: [
    0,
    2
    /* JoinRoom */
  ],
  [Role.ROLE_IMPERSONATE]: [
    0,
    1,
    3,
    4,
    5
    /* ManageBroadcast */
  ]
}, hasPermission = (a, u) => {
  var c;
  return a ? !!((c = permissions[a]) != null && c.find((l) => l === u)) : !1;
};
let currentSubId = 0;
const subscribers = /* @__PURE__ */ new Map(), subscribersInternal = /* @__PURE__ */ new Map();
function createSubscribe(a = {}) {
  return function(u) {
    if (typeof u != "function")
      return;
    const c = a.internal ? subscribersInternal : subscribers, l = ++currentSubId;
    return c.set(l, u), () => {
      c.delete(l);
    };
  };
}
function createOn(a = {}) {
  return function(u, c) {
    return (a.internal ? subscribeInternal : subscribe)((v, p) => {
      if (u === v)
        return c(p);
    });
  };
}
function createTrigger(a = {}) {
  const u = a.internal ? subscribersInternal : subscribers;
  return async function(c, ...l) {
    let v = {
      type: c,
      payload: l[0]
    };
    const p = a.internal ? "Internal" : "External";
    log.info(`${p} Event:`, v), await Promise.all(Array.from(u.values()).map((_) => _(v.type, v.payload)));
  };
}
const trigger$1 = createTrigger(), subscribe = createSubscribe(), on = createOn(), triggerInternal$1 = createTrigger({
  internal: !0
}), subscribeInternal = createSubscribe({
  internal: !0
}), onInternal = createOn({
  internal: !0
}), events$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  on,
  onInternal,
  subscribe,
  subscribeInternal,
  trigger: trigger$1,
  triggerInternal: triggerInternal$1
}, Symbol.toStringTag, { value: "Module" }));
var loglevel = { exports: {} };
(function(a) {
  (function(u, c) {
    a.exports ? a.exports = c() : u.log = c();
  })(commonjsGlobal$1, function() {
    var u = function() {
    }, c = "undefined", l = typeof window !== c && typeof window.navigator !== c && /Trident\/|MSIE /.test(window.navigator.userAgent), v = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ], p = {}, _ = null;
    function I(ie, Q) {
      var ne = ie[Q];
      if (typeof ne.bind == "function")
        return ne.bind(ie);
      try {
        return Function.prototype.bind.call(ne, ie);
      } catch {
        return function() {
          return Function.prototype.apply.apply(ne, [ie, arguments]);
        };
      }
    }
    function P() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function $(ie) {
      return ie === "debug" && (ie = "log"), typeof console === c ? !1 : ie === "trace" && l ? P : console[ie] !== void 0 ? I(console, ie) : console.log !== void 0 ? I(console, "log") : u;
    }
    function F() {
      for (var ie = this.getLevel(), Q = 0; Q < v.length; Q++) {
        var ne = v[Q];
        this[ne] = Q < ie ? u : this.methodFactory(ne, ie, this.name);
      }
      if (this.log = this.debug, typeof console === c && ie < this.levels.SILENT)
        return "No console available for logging";
    }
    function H(ie) {
      return function() {
        typeof console !== c && (F.call(this), this[ie].apply(this, arguments));
      };
    }
    function j(ie, Q, ne) {
      return $(ie) || H.apply(this, arguments);
    }
    function ee(ie, Q) {
      var ne = this, Z, de, he, pe = "loglevel";
      typeof ie == "string" ? pe += ":" + ie : typeof ie == "symbol" && (pe = void 0);
      function be(C) {
        var b = (v[C] || "silent").toUpperCase();
        if (!(typeof window === c || !pe)) {
          try {
            window.localStorage[pe] = b;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(pe) + "=" + b + ";";
          } catch {
          }
        }
      }
      function ke() {
        var C;
        if (!(typeof window === c || !pe)) {
          try {
            C = window.localStorage[pe];
          } catch {
          }
          if (typeof C === c)
            try {
              var b = window.document.cookie, E = encodeURIComponent(pe), k = b.indexOf(E + "=");
              k !== -1 && (C = /^([^;]+)/.exec(
                b.slice(k + E.length + 1)
              )[1]);
            } catch {
            }
          return ne.levels[C] === void 0 && (C = void 0), C;
        }
      }
      function _e() {
        if (!(typeof window === c || !pe)) {
          try {
            window.localStorage.removeItem(pe);
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(pe) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      function q(C) {
        var b = C;
        if (typeof b == "string" && ne.levels[b.toUpperCase()] !== void 0 && (b = ne.levels[b.toUpperCase()]), typeof b == "number" && b >= 0 && b <= ne.levels.SILENT)
          return b;
        throw new TypeError("log.setLevel() called with invalid level: " + C);
      }
      ne.name = ie, ne.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, ne.methodFactory = Q || j, ne.getLevel = function() {
        return he ?? de ?? Z;
      }, ne.setLevel = function(C, b) {
        return he = q(C), b !== !1 && be(he), F.call(ne);
      }, ne.setDefaultLevel = function(C) {
        de = q(C), ke() || ne.setLevel(C, !1);
      }, ne.resetLevel = function() {
        he = null, _e(), F.call(ne);
      }, ne.enableAll = function(C) {
        ne.setLevel(ne.levels.TRACE, C);
      }, ne.disableAll = function(C) {
        ne.setLevel(ne.levels.SILENT, C);
      }, ne.rebuild = function() {
        if (_ !== ne && (Z = q(_.getLevel())), F.call(ne), _ === ne)
          for (var C in p)
            p[C].rebuild();
      }, Z = q(
        _ ? _.getLevel() : "WARN"
      );
      var z = ke();
      z != null && (he = q(z)), F.call(ne);
    }
    _ = new ee(), _.getLogger = function(Q) {
      if (typeof Q != "symbol" && typeof Q != "string" || Q === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var ne = p[Q];
      return ne || (ne = p[Q] = new ee(
        Q,
        _.methodFactory
      )), ne;
    };
    var X = typeof window !== c ? window.log : void 0;
    return _.noConflict = function() {
      return typeof window !== c && window.log === _ && (window.log = X), _;
    }, _.getLoggers = function() {
      return p;
    }, _.default = _, _;
  });
})(loglevel);
var loglevelExports = loglevel.exports;
const log = /* @__PURE__ */ getDefaultExportFromCjs$2(loglevelExports), connectionId$1 = (Math.random() * 1e20).toString(36), version$2 = "3.0.6", CoreContext = {
  config: null,
  // TODO: Rename to client
  clients: null,
  Request: {},
  Command: {},
  on,
  subscribe,
  /** @private @internal */
  onInternal,
  /** @private @internal */
  subscribeInternal,
  /** @private @internal */
  trigger: trigger$1,
  /** @private @internal */
  triggerInternal: triggerInternal$1,
  /** @private @internal */
  state: {},
  compositor: {},
  connectionId: connectionId$1,
  version: version$2,
  /** @private @internal */
  rendererVersion: version$2,
  log,
  logLevel: null
}, setAppState = (a) => {
  Object.keys(a).forEach((u) => {
    CoreContext.state[u] = a[u];
  });
}, context = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoreContext,
  default: CoreContext,
  log,
  setAppState
}, Symbol.toStringTag, { value: "Module" }));
var dist = {}, AccessToken$1 = {}, jws$3 = {}, safeBuffer$4 = { exports: {} };
const require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(dist$3);
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, I) {
    for (var P in _)
      I[P] = _[P];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, I, P) {
    return l(_, I, P);
  }
  v(l, p), p.from = function(_, I, P) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, I, P);
  }, p.alloc = function(_, I, P) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var $ = l(_);
    return I !== void 0 ? typeof P == "string" ? $.fill(I, P) : $.fill(I) : $.fill(0), $;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$4, safeBuffer$4.exports);
var safeBufferExports$3 = safeBuffer$4.exports, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function a(u, c, l) {
  return Function.prototype.apply.call(u, c, l);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(u) {
  return Object.getOwnPropertyNames(u).concat(Object.getOwnPropertySymbols(u));
} : ReflectOwnKeys = function(u) {
  return Object.getOwnPropertyNames(u);
};
function ProcessEmitWarning(a) {
  console && console.warn && console.warn(a);
}
var NumberIsNaN = Number.isNaN || function a(u) {
  return u !== u;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once$6;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(a) {
  if (typeof a != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof a);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(a) {
    if (typeof a != "number" || a < 0 || NumberIsNaN(a))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + a + ".");
    defaultMaxListeners = a;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function a(u) {
  if (typeof u != "number" || u < 0 || NumberIsNaN(u))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + u + ".");
  return this._maxListeners = u, this;
};
function _getMaxListeners(a) {
  return a._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : a._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function a() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function a(u) {
  for (var c = [], l = 1; l < arguments.length; l++)
    c.push(arguments[l]);
  var v = u === "error", p = this._events;
  if (p !== void 0)
    v = v && p.error === void 0;
  else if (!v)
    return !1;
  if (v) {
    var _;
    if (c.length > 0 && (_ = c[0]), _ instanceof Error)
      throw _;
    var I = new Error("Unhandled error." + (_ ? " (" + _.message + ")" : ""));
    throw I.context = _, I;
  }
  var P = p[u];
  if (P === void 0)
    return !1;
  if (typeof P == "function")
    ReflectApply(P, this, c);
  else
    for (var $ = P.length, F = arrayClone(P, $), l = 0; l < $; ++l)
      ReflectApply(F[l], this, c);
  return !0;
};
function _addListener(a, u, c, l) {
  var v, p, _;
  if (checkListener(c), p = a._events, p === void 0 ? (p = a._events = /* @__PURE__ */ Object.create(null), a._eventsCount = 0) : (p.newListener !== void 0 && (a.emit(
    "newListener",
    u,
    c.listener ? c.listener : c
  ), p = a._events), _ = p[u]), _ === void 0)
    _ = p[u] = c, ++a._eventsCount;
  else if (typeof _ == "function" ? _ = p[u] = l ? [c, _] : [_, c] : l ? _.unshift(c) : _.push(c), v = _getMaxListeners(a), v > 0 && _.length > v && !_.warned) {
    _.warned = !0;
    var I = new Error("Possible EventEmitter memory leak detected. " + _.length + " " + String(u) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    I.name = "MaxListenersExceededWarning", I.emitter = a, I.type = u, I.count = _.length, ProcessEmitWarning(I);
  }
  return a;
}
EventEmitter.prototype.addListener = function a(u, c) {
  return _addListener(this, u, c, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function a(u, c) {
  return _addListener(this, u, c, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(a, u, c) {
  var l = { fired: !1, wrapFn: void 0, target: a, type: u, listener: c }, v = onceWrapper.bind(l);
  return v.listener = c, l.wrapFn = v, v;
}
EventEmitter.prototype.once = function a(u, c) {
  return checkListener(c), this.on(u, _onceWrap(this, u, c)), this;
};
EventEmitter.prototype.prependOnceListener = function a(u, c) {
  return checkListener(c), this.prependListener(u, _onceWrap(this, u, c)), this;
};
EventEmitter.prototype.removeListener = function a(u, c) {
  var l, v, p, _, I;
  if (checkListener(c), v = this._events, v === void 0)
    return this;
  if (l = v[u], l === void 0)
    return this;
  if (l === c || l.listener === c)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete v[u], v.removeListener && this.emit("removeListener", u, l.listener || c));
  else if (typeof l != "function") {
    for (p = -1, _ = l.length - 1; _ >= 0; _--)
      if (l[_] === c || l[_].listener === c) {
        I = l[_].listener, p = _;
        break;
      }
    if (p < 0)
      return this;
    p === 0 ? l.shift() : spliceOne(l, p), l.length === 1 && (v[u] = l[0]), v.removeListener !== void 0 && this.emit("removeListener", u, I || c);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function a(u) {
  var c, l, v;
  if (l = this._events, l === void 0)
    return this;
  if (l.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : l[u] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete l[u]), this;
  if (arguments.length === 0) {
    var p = Object.keys(l), _;
    for (v = 0; v < p.length; ++v)
      _ = p[v], _ !== "removeListener" && this.removeAllListeners(_);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (c = l[u], typeof c == "function")
    this.removeListener(u, c);
  else if (c !== void 0)
    for (v = c.length - 1; v >= 0; v--)
      this.removeListener(u, c[v]);
  return this;
};
function _listeners(a, u, c) {
  var l = a._events;
  if (l === void 0)
    return [];
  var v = l[u];
  return v === void 0 ? [] : typeof v == "function" ? c ? [v.listener || v] : [v] : c ? unwrapListeners(v) : arrayClone(v, v.length);
}
EventEmitter.prototype.listeners = function a(u) {
  return _listeners(this, u, !0);
};
EventEmitter.prototype.rawListeners = function a(u) {
  return _listeners(this, u, !1);
};
EventEmitter.listenerCount = function(a, u) {
  return typeof a.listenerCount == "function" ? a.listenerCount(u) : listenerCount.call(a, u);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(a) {
  var u = this._events;
  if (u !== void 0) {
    var c = u[a];
    if (typeof c == "function")
      return 1;
    if (c !== void 0)
      return c.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function a() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(a, u) {
  for (var c = new Array(u), l = 0; l < u; ++l)
    c[l] = a[l];
  return c;
}
function spliceOne(a, u) {
  for (; u + 1 < a.length; u++)
    a[u] = a[u + 1];
  a.pop();
}
function unwrapListeners(a) {
  for (var u = new Array(a.length), c = 0; c < u.length; ++c)
    u[c] = a[c].listener || a[c];
  return u;
}
function once$6(a, u) {
  return new Promise(function(c, l) {
    function v(_) {
      a.removeListener(u, p), l(_);
    }
    function p() {
      typeof a.removeListener == "function" && a.removeListener("error", v), c([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(a, u, p, { once: !0 }), u !== "error" && addErrorHandlerIfEventEmitter(a, v, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(a, u, c) {
  typeof a.on == "function" && eventTargetAgnosticAddListener(a, "error", u, c);
}
function eventTargetAgnosticAddListener(a, u, c, l) {
  if (typeof a.on == "function")
    l.once ? a.once(u, c) : a.on(u, c);
  else if (typeof a.addEventListener == "function")
    a.addEventListener(u, function v(p) {
      l.once && a.removeEventListener(u, v), c(p);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof a);
}
var eventsExports = events.exports, inherits_browser = { exports: {} };
typeof Object.create == "function" ? inherits_browser.exports = function(u, c) {
  c && (u.super_ = c, u.prototype = Object.create(c.prototype, {
    constructor: {
      value: u,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(u, c) {
  if (c) {
    u.super_ = c;
    var l = function() {
    };
    l.prototype = c.prototype, u.prototype = new l(), u.prototype.constructor = u;
  }
};
var inherits_browserExports = inherits_browser.exports, streamBrowser$2, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser$2 = eventsExports.EventEmitter), streamBrowser$2;
}
var util$4 = {}, types$1 = {}, shams$1 = function a() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var u = {}, c = Symbol("test"), l = Object(c);
  if (typeof c == "string" || Object.prototype.toString.call(c) !== "[object Symbol]" || Object.prototype.toString.call(l) !== "[object Symbol]")
    return !1;
  var v = 42;
  u[c] = v;
  for (c in u)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(u).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(u).length !== 0)
    return !1;
  var p = Object.getOwnPropertySymbols(u);
  if (p.length !== 1 || p[0] !== c || !Object.prototype.propertyIsEnumerable.call(u, c))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var _ = Object.getOwnPropertyDescriptor(u, c);
    if (_.value !== v || _.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function a() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esErrors = Error, _eval = EvalError, range = RangeError, ref$1 = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, origSymbol = typeof Symbol < "u" && Symbol, hasSymbolSham = shams$1, hasSymbols$1 = function a() {
  return typeof origSymbol != "function" || typeof Symbol != "function" || typeof origSymbol("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : hasSymbolSham();
}, test = {
  foo: {}
}, $Object = Object, hasProto$1 = function a() {
  return { __proto__: test }.foo === test.foo && !({ __proto__: null } instanceof $Object);
}, ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max = Math.max, funcType = "[object Function]", concatty = function a(u, c) {
  for (var l = [], v = 0; v < u.length; v += 1)
    l[v] = u[v];
  for (var p = 0; p < c.length; p += 1)
    l[p + u.length] = c[p];
  return l;
}, slicy = function a(u, c) {
  for (var l = [], v = c || 0, p = 0; v < u.length; v += 1, p += 1)
    l[p] = u[v];
  return l;
}, joiny = function(a, u) {
  for (var c = "", l = 0; l < a.length; l += 1)
    c += a[l], l + 1 < a.length && (c += u);
  return c;
}, implementation$1 = function a(u) {
  var c = this;
  if (typeof c != "function" || toStr$3.apply(c) !== funcType)
    throw new TypeError(ERROR_MESSAGE + c);
  for (var l = slicy(arguments, 1), v, p = function() {
    if (this instanceof v) {
      var F = c.apply(
        this,
        concatty(l, arguments)
      );
      return Object(F) === F ? F : this;
    }
    return c.apply(
      u,
      concatty(l, arguments)
    );
  }, _ = max(0, c.length - l.length), I = [], P = 0; P < _; P++)
    I[P] = "$" + P;
  if (v = Function("binder", "return function (" + joiny(I, ",") + "){ return binder.apply(this,arguments); }")(p), c.prototype) {
    var $ = function() {
    };
    $.prototype = c.prototype, v.prototype = new $(), $.prototype = null;
  }
  return v;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, call$2 = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$4 = functionBind, hasown = bind$4.call(call$2, $hasOwn), undefined$1, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref$1, $SyntaxError$1 = syntax, $TypeError$2 = type, $URIError = uri, $Function = Function, getEvalledConstructor = function(a) {
  try {
    return $Function('"use strict"; return (' + a + ").constructor;")();
  } catch {
  }
}, $gOPD$1 = Object.getOwnPropertyDescriptor;
if ($gOPD$1)
  try {
    $gOPD$1({}, "");
  } catch {
    $gOPD$1 = null;
  }
var throwTypeError = function() {
  throw new $TypeError$2();
}, ThrowTypeError = $gOPD$1 ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD$1(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = hasSymbols$1(), hasProto = hasProto$1(), getProto$1 = Object.getPrototypeOf || (hasProto ? function(a) {
  return a.__proto__;
} : null), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$2,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet
};
if (getProto$1)
  try {
    null.error;
  } catch (a) {
    var errorProto = getProto$1(getProto$1(a));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function a(u) {
  var c;
  if (u === "%AsyncFunction%")
    c = getEvalledConstructor("async function () {}");
  else if (u === "%GeneratorFunction%")
    c = getEvalledConstructor("function* () {}");
  else if (u === "%AsyncGeneratorFunction%")
    c = getEvalledConstructor("async function* () {}");
  else if (u === "%AsyncGenerator%") {
    var l = a("%AsyncGeneratorFunction%");
    l && (c = l.prototype);
  } else if (u === "%AsyncIteratorPrototype%") {
    var v = a("%AsyncGenerator%");
    v && getProto$1 && (c = getProto$1(v.prototype));
  }
  return INTRINSICS[u] = c, c;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$3 = functionBind, hasOwn = hasown, $concat = bind$3.call(Function.call, Array.prototype.concat), $spliceApply = bind$3.call(Function.apply, Array.prototype.splice), $replace = bind$3.call(Function.call, String.prototype.replace), $strSlice = bind$3.call(Function.call, String.prototype.slice), $exec = bind$3.call(Function.call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function a(u) {
  var c = $strSlice(u, 0, 1), l = $strSlice(u, -1);
  if (c === "%" && l !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (l === "%" && c !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var v = [];
  return $replace(u, rePropName, function(p, _, I, P) {
    v[v.length] = I ? $replace(P, reEscapeChar, "$1") : _ || p;
  }), v;
}, getBaseIntrinsic = function a(u, c) {
  var l = u, v;
  if (hasOwn(LEGACY_ALIASES, l) && (v = LEGACY_ALIASES[l], l = "%" + v[0] + "%"), hasOwn(INTRINSICS, l)) {
    var p = INTRINSICS[l];
    if (p === needsEval && (p = doEval(l)), typeof p > "u" && !c)
      throw new $TypeError$2("intrinsic " + u + " exists, but is not available. Please file an issue!");
    return {
      alias: v,
      name: l,
      value: p
    };
  }
  throw new $SyntaxError$1("intrinsic " + u + " does not exist!");
}, getIntrinsic = function a(u, c) {
  if (typeof u != "string" || u.length === 0)
    throw new $TypeError$2("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof c != "boolean")
    throw new $TypeError$2('"allowMissing" argument must be a boolean');
  if ($exec(/^%?[^%]*%?$/, u) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var l = stringToPath(u), v = l.length > 0 ? l[0] : "", p = getBaseIntrinsic("%" + v + "%", c), _ = p.name, I = p.value, P = !1, $ = p.alias;
  $ && (v = $[0], $spliceApply(l, $concat([0, 1], $)));
  for (var F = 1, H = !0; F < l.length; F += 1) {
    var j = l[F], ee = $strSlice(j, 0, 1), X = $strSlice(j, -1);
    if ((ee === '"' || ee === "'" || ee === "`" || X === '"' || X === "'" || X === "`") && ee !== X)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((j === "constructor" || !H) && (P = !0), v += "." + j, _ = "%" + v + "%", hasOwn(INTRINSICS, _))
      I = INTRINSICS[_];
    else if (I != null) {
      if (!(j in I)) {
        if (!c)
          throw new $TypeError$2("base intrinsic for " + u + " exists, but the property is not available.");
        return;
      }
      if ($gOPD$1 && F + 1 >= l.length) {
        var ie = $gOPD$1(I, j);
        H = !!ie, H && "get" in ie && !("originalValue" in ie.get) ? I = ie.get : I = I[j];
      } else
        H = hasOwn(I, j), I = I[j];
      H && !P && (INTRINSICS[_] = I);
    }
  }
  return I;
}, callBind$2 = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty)
    return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var a = getIntrinsic, u = a("%Object.defineProperty%", !0) || !1;
  if (u)
    try {
      u({}, "a", { value: 1 });
    } catch {
      u = !1;
    }
  return esDefineProperty = u, esDefineProperty;
}
var GetIntrinsic$2 = getIntrinsic, $gOPD = GetIntrinsic$2("%Object.getOwnPropertyDescriptor%", !0);
if ($gOPD)
  try {
    $gOPD([], "length");
  } catch {
    $gOPD = null;
  }
var gopd$1 = $gOPD, $defineProperty$1 = requireEsDefineProperty(), $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function a(u, c, l) {
  if (!u || typeof u != "object" && typeof u != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof c != "string" && typeof c != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var v = arguments.length > 3 ? arguments[3] : null, p = arguments.length > 4 ? arguments[4] : null, _ = arguments.length > 5 ? arguments[5] : null, I = arguments.length > 6 ? arguments[6] : !1, P = !!gopd && gopd(u, c);
  if ($defineProperty$1)
    $defineProperty$1(u, c, {
      configurable: _ === null && P ? P.configurable : !_,
      enumerable: v === null && P ? P.enumerable : !v,
      value: l,
      writable: p === null && P ? P.writable : !p
    });
  else if (I || !v && !p && !_)
    u[c] = l;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = requireEsDefineProperty(), hasPropertyDescriptors = function a() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function a() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic$1 = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic$1("%Math.floor%"), setFunctionLength = function a(u, c) {
  if (typeof u != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof c != "number" || c < 0 || c > 4294967295 || $floor(c) !== c)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var l = arguments.length > 2 && !!arguments[2], v = !0, p = !0;
  if ("length" in u && gOPD$1) {
    var _ = gOPD$1(u, "length");
    _ && !_.configurable && (v = !1), _ && !_.writable && (p = !1);
  }
  return (v || p || !l) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    u,
    "length",
    c,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    u,
    "length",
    c
  )), u;
};
(function(a) {
  var u = functionBind, c = getIntrinsic, l = setFunctionLength, v = type, p = c("%Function.prototype.apply%"), _ = c("%Function.prototype.call%"), I = c("%Reflect.apply%", !0) || u.call(_, p), P = requireEsDefineProperty(), $ = c("%Math.max%");
  a.exports = function(j) {
    if (typeof j != "function")
      throw new v("a function is required");
    var ee = I(u, _, arguments);
    return l(
      ee,
      1 + $(0, j.length - (arguments.length - 1)),
      !0
    );
  };
  var F = function() {
    return I(u, p, arguments);
  };
  P ? P(a.exports, "apply", { value: F }) : a.exports.apply = F;
})(callBind$2);
var callBindExports = callBind$2.exports, GetIntrinsic = getIntrinsic, callBind$1 = callBindExports, $indexOf$1 = callBind$1(GetIntrinsic("String.prototype.indexOf")), callBound$2 = function a(u, c) {
  var l = GetIntrinsic(u, !!c);
  return typeof l == "function" && $indexOf$1(u, ".prototype.") > -1 ? callBind$1(l) : l;
}, hasToStringTag$3 = shams(), callBound$1 = callBound$2, $toString$1 = callBound$1("Object.prototype.toString"), isStandardArguments = function a(u) {
  return hasToStringTag$3 && u && typeof u == "object" && Symbol.toStringTag in u ? !1 : $toString$1(u) === "[object Arguments]";
}, isLegacyArguments = function a(u) {
  return isStandardArguments(u) ? !0 : u !== null && typeof u == "object" && typeof u.length == "number" && u.length >= 0 && $toString$1(u) !== "[object Array]" && $toString$1(u.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments, toStr$2 = Object.prototype.toString, fnToStr$1 = Function.prototype.toString, isFnRegex = /^\s*(?:function)?\*/, hasToStringTag$2 = shams(), getProto = Object.getPrototypeOf, getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function a(u) {
  if (typeof u != "function")
    return !1;
  if (isFnRegex.test(fnToStr$1.call(u)))
    return !0;
  if (!hasToStringTag$2) {
    var c = toStr$2.call(u);
    return c === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var l = getGeneratorFunc();
    GeneratorFunction = l ? getProto(l) : !1;
  }
  return getProto(u) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (a) {
    a !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function a(u) {
  try {
    var c = fnToStr.call(u);
    return constructorRegex.test(c);
  } catch {
    return !1;
  }
}, tryFunctionObject = function a(u) {
  try {
    return isES6ClassFn(u) ? !1 : (fnToStr.call(u), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, fnClass = "[object Function]", genClass = "[object GeneratorFunction]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, documentDotAll = typeof document == "object" && typeof document.all > "u" && document.all !== void 0 ? document.all : {}, isCallable$1 = reflectApply ? function a(u) {
  if (u === documentDotAll)
    return !0;
  if (!u || typeof u != "function" && typeof u != "object")
    return !1;
  if (typeof u == "function" && !u.prototype)
    return !0;
  try {
    reflectApply(u, null, badArrayLike);
  } catch (c) {
    if (c !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(u);
} : function a(u) {
  if (u === documentDotAll)
    return !0;
  if (!u || typeof u != "function" && typeof u != "object")
    return !1;
  if (typeof u == "function" && !u.prototype)
    return !0;
  if (hasToStringTag$1)
    return tryFunctionObject(u);
  if (isES6ClassFn(u))
    return !1;
  var c = toStr$1.call(u);
  return c === fnClass || c === genClass;
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty$2 = Object.prototype.hasOwnProperty, forEachArray = function a(u, c, l) {
  for (var v = 0, p = u.length; v < p; v++)
    hasOwnProperty$2.call(u, v) && (l == null ? c(u[v], v, u) : c.call(l, u[v], v, u));
}, forEachString = function a(u, c, l) {
  for (var v = 0, p = u.length; v < p; v++)
    l == null ? c(u.charAt(v), v, u) : c.call(l, u.charAt(v), v, u);
}, forEachObject = function a(u, c, l) {
  for (var v in u)
    hasOwnProperty$2.call(u, v) && (l == null ? c(u[v], v, u) : c.call(l, u[v], v, u));
}, forEach$2 = function a(u, c, l) {
  if (!isCallable(c))
    throw new TypeError("iterator must be a function");
  var v;
  arguments.length >= 3 && (v = l), toStr.call(u) === "[object Array]" ? forEachArray(u, c, v) : typeof u == "string" ? forEachString(u, c, v) : forEachObject(u, c, v);
}, forEach_1 = forEach$2, possibleNames = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], g$1 = typeof globalThis > "u" ? commonjsGlobal$1 : globalThis, availableTypedArrays$1 = function a() {
  for (var u = [], c = 0; c < possibleNames.length; c++)
    typeof g$1[possibleNames[c]] == "function" && (u[u.length] = possibleNames[c]);
  return u;
}, forEach$1 = forEach_1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$2, gOPD = gopd$1, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g = typeof globalThis > "u" ? commonjsGlobal$1 : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), getPrototypeOf = Object.getPrototypeOf, $indexOf = callBound("Array.prototype.indexOf", !0) || /** @type {(array: readonly unknown[], value: unknown) => keyof array} */
function a(u, c) {
  for (var l = 0; l < u.length; l += 1)
    if (u[l] === c)
      return l;
  return -1;
}, cache$2 = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf ? forEach$1(typedArrays, function(a) {
  var u = new g[a]();
  if (Symbol.toStringTag in u) {
    var c = getPrototypeOf(u), l = gOPD(c, Symbol.toStringTag);
    if (!l) {
      var v = getPrototypeOf(c);
      l = gOPD(v, Symbol.toStringTag);
    }
    cache$2["$" + a] = callBind(l.get);
  }
}) : forEach$1(typedArrays, function(a) {
  var u = new g[a](), c = u.slice || u.set;
  c && (cache$2["$" + a] = callBind(c));
});
var tryTypedArrays = function a(u) {
  var c = !1;
  return forEach$1(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, typeof cache>} */
    /** @type {any} */
    cache$2,
    /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
    function(l, v) {
      if (!c)
        try {
          "$" + l(u) === v && (c = $slice(v, 1));
        } catch {
        }
    }
  ), c;
}, trySlices = function a(u) {
  var c = !1;
  return forEach$1(
    // eslint-disable-next-line no-extra-parens
    /** @type {any} */
    cache$2,
    /** @type {(getter: typeof cache, name: `\$${TypedArrayName}`) => void} */
    function(l, v) {
      if (!c)
        try {
          l(u), c = $slice(v, 1);
        } catch {
        }
    }
  ), c;
}, whichTypedArray$1 = function a(u) {
  if (!u || typeof u != "object")
    return !1;
  if (!hasToStringTag) {
    var c = $slice($toString(u), 8, -1);
    return $indexOf(typedArrays, c) > -1 ? c : c !== "Object" ? !1 : trySlices(u);
  }
  return gOPD ? tryTypedArrays(u) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function a(u) {
  return !!whichTypedArray(u);
};
(function(a) {
  var u = isArguments$1, c = isGeneratorFunction, l = whichTypedArray$1, v = isTypedArray;
  function p(Fe) {
    return Fe.call.bind(Fe);
  }
  var _ = typeof BigInt < "u", I = typeof Symbol < "u", P = p(Object.prototype.toString), $ = p(Number.prototype.valueOf), F = p(String.prototype.valueOf), H = p(Boolean.prototype.valueOf);
  if (_)
    var j = p(BigInt.prototype.valueOf);
  if (I)
    var ee = p(Symbol.prototype.valueOf);
  function X(Fe, yt) {
    if (typeof Fe != "object")
      return !1;
    try {
      return yt(Fe), !0;
    } catch {
      return !1;
    }
  }
  a.isArgumentsObject = u, a.isGeneratorFunction = c, a.isTypedArray = v;
  function ie(Fe) {
    return typeof Promise < "u" && Fe instanceof Promise || Fe !== null && typeof Fe == "object" && typeof Fe.then == "function" && typeof Fe.catch == "function";
  }
  a.isPromise = ie;
  function Q(Fe) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Fe) : v(Fe) || me(Fe);
  }
  a.isArrayBufferView = Q;
  function ne(Fe) {
    return l(Fe) === "Uint8Array";
  }
  a.isUint8Array = ne;
  function Z(Fe) {
    return l(Fe) === "Uint8ClampedArray";
  }
  a.isUint8ClampedArray = Z;
  function de(Fe) {
    return l(Fe) === "Uint16Array";
  }
  a.isUint16Array = de;
  function he(Fe) {
    return l(Fe) === "Uint32Array";
  }
  a.isUint32Array = he;
  function pe(Fe) {
    return l(Fe) === "Int8Array";
  }
  a.isInt8Array = pe;
  function be(Fe) {
    return l(Fe) === "Int16Array";
  }
  a.isInt16Array = be;
  function ke(Fe) {
    return l(Fe) === "Int32Array";
  }
  a.isInt32Array = ke;
  function _e(Fe) {
    return l(Fe) === "Float32Array";
  }
  a.isFloat32Array = _e;
  function q(Fe) {
    return l(Fe) === "Float64Array";
  }
  a.isFloat64Array = q;
  function z(Fe) {
    return l(Fe) === "BigInt64Array";
  }
  a.isBigInt64Array = z;
  function C(Fe) {
    return l(Fe) === "BigUint64Array";
  }
  a.isBigUint64Array = C;
  function b(Fe) {
    return P(Fe) === "[object Map]";
  }
  b.working = typeof Map < "u" && b(/* @__PURE__ */ new Map());
  function E(Fe) {
    return typeof Map > "u" ? !1 : b.working ? b(Fe) : Fe instanceof Map;
  }
  a.isMap = E;
  function k(Fe) {
    return P(Fe) === "[object Set]";
  }
  k.working = typeof Set < "u" && k(/* @__PURE__ */ new Set());
  function O(Fe) {
    return typeof Set > "u" ? !1 : k.working ? k(Fe) : Fe instanceof Set;
  }
  a.isSet = O;
  function A(Fe) {
    return P(Fe) === "[object WeakMap]";
  }
  A.working = typeof WeakMap < "u" && A(/* @__PURE__ */ new WeakMap());
  function x(Fe) {
    return typeof WeakMap > "u" ? !1 : A.working ? A(Fe) : Fe instanceof WeakMap;
  }
  a.isWeakMap = x;
  function Y(Fe) {
    return P(Fe) === "[object WeakSet]";
  }
  Y.working = typeof WeakSet < "u" && Y(/* @__PURE__ */ new WeakSet());
  function B(Fe) {
    return Y(Fe);
  }
  a.isWeakSet = B;
  function T(Fe) {
    return P(Fe) === "[object ArrayBuffer]";
  }
  T.working = typeof ArrayBuffer < "u" && T(new ArrayBuffer());
  function D(Fe) {
    return typeof ArrayBuffer > "u" ? !1 : T.working ? T(Fe) : Fe instanceof ArrayBuffer;
  }
  a.isArrayBuffer = D;
  function te(Fe) {
    return P(Fe) === "[object DataView]";
  }
  te.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && te(new DataView(new ArrayBuffer(1), 0, 1));
  function me(Fe) {
    return typeof DataView > "u" ? !1 : te.working ? te(Fe) : Fe instanceof DataView;
  }
  a.isDataView = me;
  var Ie = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function $e(Fe) {
    return P(Fe) === "[object SharedArrayBuffer]";
  }
  function ye(Fe) {
    return typeof Ie > "u" ? !1 : (typeof $e.working > "u" && ($e.working = $e(new Ie())), $e.working ? $e(Fe) : Fe instanceof Ie);
  }
  a.isSharedArrayBuffer = ye;
  function fe(Fe) {
    return P(Fe) === "[object AsyncFunction]";
  }
  a.isAsyncFunction = fe;
  function Me(Fe) {
    return P(Fe) === "[object Map Iterator]";
  }
  a.isMapIterator = Me;
  function Ae(Fe) {
    return P(Fe) === "[object Set Iterator]";
  }
  a.isSetIterator = Ae;
  function xe(Fe) {
    return P(Fe) === "[object Generator]";
  }
  a.isGeneratorObject = xe;
  function ae(Fe) {
    return P(Fe) === "[object WebAssembly.Module]";
  }
  a.isWebAssemblyCompiledModule = ae;
  function N(Fe) {
    return X(Fe, $);
  }
  a.isNumberObject = N;
  function re(Fe) {
    return X(Fe, F);
  }
  a.isStringObject = re;
  function le(Fe) {
    return X(Fe, H);
  }
  a.isBooleanObject = le;
  function Ne(Fe) {
    return _ && X(Fe, j);
  }
  a.isBigIntObject = Ne;
  function Oe(Fe) {
    return I && X(Fe, ee);
  }
  a.isSymbolObject = Oe;
  function qe(Fe) {
    return N(Fe) || re(Fe) || le(Fe) || Ne(Fe) || Oe(Fe);
  }
  a.isBoxedPrimitive = qe;
  function je(Fe) {
    return typeof Uint8Array < "u" && (D(Fe) || ye(Fe));
  }
  a.isAnyArrayBuffer = je, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Fe) {
    Object.defineProperty(a, Fe, {
      enumerable: !1,
      value: function() {
        throw new Error(Fe + " is not supported in userland");
      }
    });
  });
})(types$1);
var isBufferBrowser = function a(u) {
  return u && typeof u == "object" && typeof u.copy == "function" && typeof u.fill == "function" && typeof u.readUInt8 == "function";
};
(function(a) {
  var u = Object.getOwnPropertyDescriptors || function(me) {
    for (var Ie = Object.keys(me), $e = {}, ye = 0; ye < Ie.length; ye++)
      $e[Ie[ye]] = Object.getOwnPropertyDescriptor(me, Ie[ye]);
    return $e;
  }, c = /%[sdj%]/g;
  a.format = function(te) {
    if (!pe(te)) {
      for (var me = [], Ie = 0; Ie < arguments.length; Ie++)
        me.push(_(arguments[Ie]));
      return me.join(" ");
    }
    for (var Ie = 1, $e = arguments, ye = $e.length, fe = String(te).replace(c, function(Ae) {
      if (Ae === "%%")
        return "%";
      if (Ie >= ye)
        return Ae;
      switch (Ae) {
        case "%s":
          return String($e[Ie++]);
        case "%d":
          return Number($e[Ie++]);
        case "%j":
          try {
            return JSON.stringify($e[Ie++]);
          } catch {
            return "[Circular]";
          }
        default:
          return Ae;
      }
    }), Me = $e[Ie]; Ie < ye; Me = $e[++Ie])
      Z(Me) || !q(Me) ? fe += " " + Me : fe += " " + _(Me);
    return fe;
  }, a.deprecate = function(te, me) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return te;
    if (typeof process$1 > "u")
      return function() {
        return a.deprecate(te, me).apply(this, arguments);
      };
    var Ie = !1;
    function $e() {
      if (!Ie) {
        if (process$1.throwDeprecation)
          throw new Error(me);
        process$1.traceDeprecation ? console.trace(me) : console.error(me), Ie = !0;
      }
      return te.apply(this, arguments);
    }
    return $e;
  };
  var l = {}, v = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var p = process$1.env.NODE_DEBUG;
    p = p.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), v = new RegExp("^" + p + "$", "i");
  }
  a.debuglog = function(te) {
    if (te = te.toUpperCase(), !l[te])
      if (v.test(te)) {
        var me = process$1.pid;
        l[te] = function() {
          var Ie = a.format.apply(a, arguments);
          console.error("%s %d: %s", te, me, Ie);
        };
      } else
        l[te] = function() {
        };
    return l[te];
  };
  function _(te, me) {
    var Ie = {
      seen: [],
      stylize: P
    };
    return arguments.length >= 3 && (Ie.depth = arguments[2]), arguments.length >= 4 && (Ie.colors = arguments[3]), ne(me) ? Ie.showHidden = me : me && a._extend(Ie, me), ke(Ie.showHidden) && (Ie.showHidden = !1), ke(Ie.depth) && (Ie.depth = 2), ke(Ie.colors) && (Ie.colors = !1), ke(Ie.customInspect) && (Ie.customInspect = !0), Ie.colors && (Ie.stylize = I), F(Ie, te, Ie.depth);
  }
  a.inspect = _, _.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, _.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function I(te, me) {
    var Ie = _.styles[me];
    return Ie ? "\x1B[" + _.colors[Ie][0] + "m" + te + "\x1B[" + _.colors[Ie][1] + "m" : te;
  }
  function P(te, me) {
    return te;
  }
  function $(te) {
    var me = {};
    return te.forEach(function(Ie, $e) {
      me[Ie] = !0;
    }), me;
  }
  function F(te, me, Ie) {
    if (te.customInspect && me && b(me.inspect) && // Filter out the util module, it's inspect function is special
    me.inspect !== a.inspect && // Also filter out any prototype objects using the circular check.
    !(me.constructor && me.constructor.prototype === me)) {
      var $e = me.inspect(Ie, te);
      return pe($e) || ($e = F(te, $e, Ie)), $e;
    }
    var ye = H(te, me);
    if (ye)
      return ye;
    var fe = Object.keys(me), Me = $(fe);
    if (te.showHidden && (fe = Object.getOwnPropertyNames(me)), C(me) && (fe.indexOf("message") >= 0 || fe.indexOf("description") >= 0))
      return j(me);
    if (fe.length === 0) {
      if (b(me)) {
        var Ae = me.name ? ": " + me.name : "";
        return te.stylize("[Function" + Ae + "]", "special");
      }
      if (_e(me))
        return te.stylize(RegExp.prototype.toString.call(me), "regexp");
      if (z(me))
        return te.stylize(Date.prototype.toString.call(me), "date");
      if (C(me))
        return j(me);
    }
    var xe = "", ae = !1, N = ["{", "}"];
    if (Q(me) && (ae = !0, N = ["[", "]"]), b(me)) {
      var re = me.name ? ": " + me.name : "";
      xe = " [Function" + re + "]";
    }
    if (_e(me) && (xe = " " + RegExp.prototype.toString.call(me)), z(me) && (xe = " " + Date.prototype.toUTCString.call(me)), C(me) && (xe = " " + j(me)), fe.length === 0 && (!ae || me.length == 0))
      return N[0] + xe + N[1];
    if (Ie < 0)
      return _e(me) ? te.stylize(RegExp.prototype.toString.call(me), "regexp") : te.stylize("[Object]", "special");
    te.seen.push(me);
    var le;
    return ae ? le = ee(te, me, Ie, Me, fe) : le = fe.map(function(Ne) {
      return X(te, me, Ie, Me, Ne, ae);
    }), te.seen.pop(), ie(le, xe, N);
  }
  function H(te, me) {
    if (ke(me))
      return te.stylize("undefined", "undefined");
    if (pe(me)) {
      var Ie = "'" + JSON.stringify(me).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return te.stylize(Ie, "string");
    }
    if (he(me))
      return te.stylize("" + me, "number");
    if (ne(me))
      return te.stylize("" + me, "boolean");
    if (Z(me))
      return te.stylize("null", "null");
  }
  function j(te) {
    return "[" + Error.prototype.toString.call(te) + "]";
  }
  function ee(te, me, Ie, $e, ye) {
    for (var fe = [], Me = 0, Ae = me.length; Me < Ae; ++Me)
      Y(me, String(Me)) ? fe.push(X(
        te,
        me,
        Ie,
        $e,
        String(Me),
        !0
      )) : fe.push("");
    return ye.forEach(function(xe) {
      xe.match(/^\d+$/) || fe.push(X(
        te,
        me,
        Ie,
        $e,
        xe,
        !0
      ));
    }), fe;
  }
  function X(te, me, Ie, $e, ye, fe) {
    var Me, Ae, xe;
    if (xe = Object.getOwnPropertyDescriptor(me, ye) || { value: me[ye] }, xe.get ? xe.set ? Ae = te.stylize("[Getter/Setter]", "special") : Ae = te.stylize("[Getter]", "special") : xe.set && (Ae = te.stylize("[Setter]", "special")), Y($e, ye) || (Me = "[" + ye + "]"), Ae || (te.seen.indexOf(xe.value) < 0 ? (Z(Ie) ? Ae = F(te, xe.value, null) : Ae = F(te, xe.value, Ie - 1), Ae.indexOf(`
`) > -1 && (fe ? Ae = Ae.split(`
`).map(function(ae) {
      return "  " + ae;
    }).join(`
`).slice(2) : Ae = `
` + Ae.split(`
`).map(function(ae) {
      return "   " + ae;
    }).join(`
`))) : Ae = te.stylize("[Circular]", "special")), ke(Me)) {
      if (fe && ye.match(/^\d+$/))
        return Ae;
      Me = JSON.stringify("" + ye), Me.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Me = Me.slice(1, -1), Me = te.stylize(Me, "name")) : (Me = Me.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Me = te.stylize(Me, "string"));
    }
    return Me + ": " + Ae;
  }
  function ie(te, me, Ie) {
    var $e = te.reduce(function(ye, fe) {
      return fe.indexOf(`
`) >= 0, ye + fe.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return $e > 60 ? Ie[0] + (me === "" ? "" : me + `
 `) + " " + te.join(`,
  `) + " " + Ie[1] : Ie[0] + me + " " + te.join(", ") + " " + Ie[1];
  }
  a.types = types$1;
  function Q(te) {
    return Array.isArray(te);
  }
  a.isArray = Q;
  function ne(te) {
    return typeof te == "boolean";
  }
  a.isBoolean = ne;
  function Z(te) {
    return te === null;
  }
  a.isNull = Z;
  function de(te) {
    return te == null;
  }
  a.isNullOrUndefined = de;
  function he(te) {
    return typeof te == "number";
  }
  a.isNumber = he;
  function pe(te) {
    return typeof te == "string";
  }
  a.isString = pe;
  function be(te) {
    return typeof te == "symbol";
  }
  a.isSymbol = be;
  function ke(te) {
    return te === void 0;
  }
  a.isUndefined = ke;
  function _e(te) {
    return q(te) && k(te) === "[object RegExp]";
  }
  a.isRegExp = _e, a.types.isRegExp = _e;
  function q(te) {
    return typeof te == "object" && te !== null;
  }
  a.isObject = q;
  function z(te) {
    return q(te) && k(te) === "[object Date]";
  }
  a.isDate = z, a.types.isDate = z;
  function C(te) {
    return q(te) && (k(te) === "[object Error]" || te instanceof Error);
  }
  a.isError = C, a.types.isNativeError = C;
  function b(te) {
    return typeof te == "function";
  }
  a.isFunction = b;
  function E(te) {
    return te === null || typeof te == "boolean" || typeof te == "number" || typeof te == "string" || typeof te == "symbol" || // ES6 symbol
    typeof te > "u";
  }
  a.isPrimitive = E, a.isBuffer = isBufferBrowser;
  function k(te) {
    return Object.prototype.toString.call(te);
  }
  function O(te) {
    return te < 10 ? "0" + te.toString(10) : te.toString(10);
  }
  var A = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function x() {
    var te = /* @__PURE__ */ new Date(), me = [
      O(te.getHours()),
      O(te.getMinutes()),
      O(te.getSeconds())
    ].join(":");
    return [te.getDate(), A[te.getMonth()], me].join(" ");
  }
  a.log = function() {
    console.log("%s - %s", x(), a.format.apply(a, arguments));
  }, a.inherits = inherits_browserExports, a._extend = function(te, me) {
    if (!me || !q(me))
      return te;
    for (var Ie = Object.keys(me), $e = Ie.length; $e--; )
      te[Ie[$e]] = me[Ie[$e]];
    return te;
  };
  function Y(te, me) {
    return Object.prototype.hasOwnProperty.call(te, me);
  }
  var B = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  a.promisify = function(me) {
    if (typeof me != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (B && me[B]) {
      var Ie = me[B];
      if (typeof Ie != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(Ie, B, {
        value: Ie,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Ie;
    }
    function Ie() {
      for (var $e, ye, fe = new Promise(function(xe, ae) {
        $e = xe, ye = ae;
      }), Me = [], Ae = 0; Ae < arguments.length; Ae++)
        Me.push(arguments[Ae]);
      Me.push(function(xe, ae) {
        xe ? ye(xe) : $e(ae);
      });
      try {
        me.apply(this, Me);
      } catch (xe) {
        ye(xe);
      }
      return fe;
    }
    return Object.setPrototypeOf(Ie, Object.getPrototypeOf(me)), B && Object.defineProperty(Ie, B, {
      value: Ie,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      Ie,
      u(me)
    );
  }, a.promisify.custom = B;
  function T(te, me) {
    if (!te) {
      var Ie = new Error("Promise was rejected with a falsy value");
      Ie.reason = te, te = Ie;
    }
    return me(te);
  }
  function D(te) {
    if (typeof te != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function me() {
      for (var Ie = [], $e = 0; $e < arguments.length; $e++)
        Ie.push(arguments[$e]);
      var ye = Ie.pop();
      if (typeof ye != "function")
        throw new TypeError("The last argument must be of type Function");
      var fe = this, Me = function() {
        return ye.apply(fe, arguments);
      };
      te.apply(this, Ie).then(
        function(Ae) {
          process$1.nextTick(Me.bind(null, null, Ae));
        },
        function(Ae) {
          process$1.nextTick(T.bind(null, Ae, Me));
        }
      );
    }
    return Object.setPrototypeOf(me, Object.getPrototypeOf(te)), Object.defineProperties(
      me,
      u(te)
    ), me;
  }
  a.callbackify = D;
})(util$4);
var buffer_list$2, hasRequiredBuffer_list$2;
function requireBuffer_list$2() {
  if (hasRequiredBuffer_list$2)
    return buffer_list$2;
  hasRequiredBuffer_list$2 = 1;
  function a(X, ie) {
    var Q = Object.keys(X);
    if (Object.getOwnPropertySymbols) {
      var ne = Object.getOwnPropertySymbols(X);
      ie && (ne = ne.filter(function(Z) {
        return Object.getOwnPropertyDescriptor(X, Z).enumerable;
      })), Q.push.apply(Q, ne);
    }
    return Q;
  }
  function u(X) {
    for (var ie = 1; ie < arguments.length; ie++) {
      var Q = arguments[ie] != null ? arguments[ie] : {};
      ie % 2 ? a(Object(Q), !0).forEach(function(ne) {
        c(X, ne, Q[ne]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(X, Object.getOwnPropertyDescriptors(Q)) : a(Object(Q)).forEach(function(ne) {
        Object.defineProperty(X, ne, Object.getOwnPropertyDescriptor(Q, ne));
      });
    }
    return X;
  }
  function c(X, ie, Q) {
    return ie = _(ie), ie in X ? Object.defineProperty(X, ie, { value: Q, enumerable: !0, configurable: !0, writable: !0 }) : X[ie] = Q, X;
  }
  function l(X, ie) {
    if (!(X instanceof ie))
      throw new TypeError("Cannot call a class as a function");
  }
  function v(X, ie) {
    for (var Q = 0; Q < ie.length; Q++) {
      var ne = ie[Q];
      ne.enumerable = ne.enumerable || !1, ne.configurable = !0, "value" in ne && (ne.writable = !0), Object.defineProperty(X, _(ne.key), ne);
    }
  }
  function p(X, ie, Q) {
    return ie && v(X.prototype, ie), Q && v(X, Q), Object.defineProperty(X, "prototype", { writable: !1 }), X;
  }
  function _(X) {
    var ie = I(X, "string");
    return typeof ie == "symbol" ? ie : String(ie);
  }
  function I(X, ie) {
    if (typeof X != "object" || X === null)
      return X;
    var Q = X[Symbol.toPrimitive];
    if (Q !== void 0) {
      var ne = Q.call(X, ie || "default");
      if (typeof ne != "object")
        return ne;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ie === "string" ? String : Number)(X);
  }
  var P = require$$0$2, $ = P.Buffer, F = util$4, H = F.inspect, j = H && H.custom || "inspect";
  function ee(X, ie, Q) {
    $.prototype.copy.call(X, ie, Q);
  }
  return buffer_list$2 = /* @__PURE__ */ function() {
    function X() {
      l(this, X), this.head = null, this.tail = null, this.length = 0;
    }
    return p(X, [{
      key: "push",
      value: function(Q) {
        var ne = {
          data: Q,
          next: null
        };
        this.length > 0 ? this.tail.next = ne : this.head = ne, this.tail = ne, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Q) {
        var ne = {
          data: Q,
          next: this.head
        };
        this.length === 0 && (this.tail = ne), this.head = ne, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Q = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Q;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Q) {
        if (this.length === 0)
          return "";
        for (var ne = this.head, Z = "" + ne.data; ne = ne.next; )
          Z += Q + ne.data;
        return Z;
      }
    }, {
      key: "concat",
      value: function(Q) {
        if (this.length === 0)
          return $.alloc(0);
        for (var ne = $.allocUnsafe(Q >>> 0), Z = this.head, de = 0; Z; )
          ee(Z.data, ne, de), de += Z.data.length, Z = Z.next;
        return ne;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Q, ne) {
        var Z;
        return Q < this.head.data.length ? (Z = this.head.data.slice(0, Q), this.head.data = this.head.data.slice(Q)) : Q === this.head.data.length ? Z = this.shift() : Z = ne ? this._getString(Q) : this._getBuffer(Q), Z;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Q) {
        var ne = this.head, Z = 1, de = ne.data;
        for (Q -= de.length; ne = ne.next; ) {
          var he = ne.data, pe = Q > he.length ? he.length : Q;
          if (pe === he.length ? de += he : de += he.slice(0, Q), Q -= pe, Q === 0) {
            pe === he.length ? (++Z, ne.next ? this.head = ne.next : this.head = this.tail = null) : (this.head = ne, ne.data = he.slice(pe));
            break;
          }
          ++Z;
        }
        return this.length -= Z, de;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Q) {
        var ne = $.allocUnsafe(Q), Z = this.head, de = 1;
        for (Z.data.copy(ne), Q -= Z.data.length; Z = Z.next; ) {
          var he = Z.data, pe = Q > he.length ? he.length : Q;
          if (he.copy(ne, ne.length - Q, 0, pe), Q -= pe, Q === 0) {
            pe === he.length ? (++de, Z.next ? this.head = Z.next : this.head = this.tail = null) : (this.head = Z, Z.data = he.slice(pe));
            break;
          }
          ++de;
        }
        return this.length -= de, ne;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: j,
      value: function(Q, ne) {
        return H(this, u(u({}, ne), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), X;
  }(), buffer_list$2;
}
var destroy_1$2, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy)
    return destroy_1$2;
  hasRequiredDestroy = 1;
  function a(_, I) {
    var P = this, $ = this._readableState && this._readableState.destroyed, F = this._writableState && this._writableState.destroyed;
    return $ || F ? (I ? I(_) : _ && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(v, this, _)) : process$1.nextTick(v, this, _)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(_ || null, function(H) {
      !I && H ? P._writableState ? P._writableState.errorEmitted ? process$1.nextTick(c, P) : (P._writableState.errorEmitted = !0, process$1.nextTick(u, P, H)) : process$1.nextTick(u, P, H) : I ? (process$1.nextTick(c, P), I(H)) : process$1.nextTick(c, P);
    }), this);
  }
  function u(_, I) {
    v(_, I), c(_);
  }
  function c(_) {
    _._writableState && !_._writableState.emitClose || _._readableState && !_._readableState.emitClose || _.emit("close");
  }
  function l() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function v(_, I) {
    _.emit("error", I);
  }
  function p(_, I) {
    var P = _._readableState, $ = _._writableState;
    P && P.autoDestroy || $ && $.autoDestroy ? _.destroy(I) : _.emit("error", I);
  }
  return destroy_1$2 = {
    destroy: a,
    undestroy: l,
    errorOrDestroy: p
  }, destroy_1$2;
}
var errorsBrowser$2 = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser)
    return errorsBrowser$2;
  hasRequiredErrorsBrowser = 1;
  function a(I, P) {
    I.prototype = Object.create(P.prototype), I.prototype.constructor = I, I.__proto__ = P;
  }
  var u = {};
  function c(I, P, $) {
    $ || ($ = Error);
    function F(j, ee, X) {
      return typeof P == "string" ? P : P(j, ee, X);
    }
    var H = /* @__PURE__ */ function(j) {
      a(ee, j);
      function ee(X, ie, Q) {
        return j.call(this, F(X, ie, Q)) || this;
      }
      return ee;
    }($);
    H.prototype.name = $.name, H.prototype.code = I, u[I] = H;
  }
  function l(I, P) {
    if (Array.isArray(I)) {
      var $ = I.length;
      return I = I.map(function(F) {
        return String(F);
      }), $ > 2 ? "one of ".concat(P, " ").concat(I.slice(0, $ - 1).join(", "), ", or ") + I[$ - 1] : $ === 2 ? "one of ".concat(P, " ").concat(I[0], " or ").concat(I[1]) : "of ".concat(P, " ").concat(I[0]);
    } else
      return "of ".concat(P, " ").concat(String(I));
  }
  function v(I, P, $) {
    return I.substr(!$ || $ < 0 ? 0 : +$, P.length) === P;
  }
  function p(I, P, $) {
    return ($ === void 0 || $ > I.length) && ($ = I.length), I.substring($ - P.length, $) === P;
  }
  function _(I, P, $) {
    return typeof $ != "number" && ($ = 0), $ + P.length > I.length ? !1 : I.indexOf(P, $) !== -1;
  }
  return c("ERR_INVALID_OPT_VALUE", function(I, P) {
    return 'The value "' + P + '" is invalid for option "' + I + '"';
  }, TypeError), c("ERR_INVALID_ARG_TYPE", function(I, P, $) {
    var F;
    typeof P == "string" && v(P, "not ") ? (F = "must not be", P = P.replace(/^not /, "")) : F = "must be";
    var H;
    if (p(I, " argument"))
      H = "The ".concat(I, " ").concat(F, " ").concat(l(P, "type"));
    else {
      var j = _(I, ".") ? "property" : "argument";
      H = 'The "'.concat(I, '" ').concat(j, " ").concat(F, " ").concat(l(P, "type"));
    }
    return H += ". Received type ".concat(typeof $), H;
  }, TypeError), c("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), c("ERR_METHOD_NOT_IMPLEMENTED", function(I) {
    return "The " + I + " method is not implemented";
  }), c("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), c("ERR_STREAM_DESTROYED", function(I) {
    return "Cannot call " + I + " after a stream was destroyed";
  }), c("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), c("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), c("ERR_STREAM_WRITE_AFTER_END", "write after end"), c("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), c("ERR_UNKNOWN_ENCODING", function(I) {
    return "Unknown encoding: " + I;
  }, TypeError), c("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser$2.codes = u, errorsBrowser$2;
}
var state$5, hasRequiredState;
function requireState() {
  if (hasRequiredState)
    return state$5;
  hasRequiredState = 1;
  var a = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function u(l, v, p) {
    return l.highWaterMark != null ? l.highWaterMark : v ? l[p] : null;
  }
  function c(l, v, p, _) {
    var I = u(v, _, p);
    if (I != null) {
      if (!(isFinite(I) && Math.floor(I) === I) || I < 0) {
        var P = _ ? p : "highWaterMark";
        throw new a(P, I);
      }
      return Math.floor(I);
    }
    return l.objectMode ? 16 : 16 * 1024;
  }
  return state$5 = {
    getHighWaterMark: c
  }, state$5;
}
var browser$c = deprecate;
function deprecate(a, u) {
  if (config$1("noDeprecation"))
    return a;
  var c = !1;
  function l() {
    if (!c) {
      if (config$1("throwDeprecation"))
        throw new Error(u);
      config$1("traceDeprecation") ? console.trace(u) : console.warn(u), c = !0;
    }
    return a.apply(this, arguments);
  }
  return l;
}
function config$1(a) {
  try {
    if (!commonjsGlobal$1.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var u = commonjsGlobal$1.localStorage[a];
  return u == null ? !1 : String(u).toLowerCase() === "true";
}
var _stream_writable$2, hasRequired_stream_writable$2;
function require_stream_writable$2() {
  if (hasRequired_stream_writable$2)
    return _stream_writable$2;
  hasRequired_stream_writable$2 = 1, _stream_writable$2 = _e;
  function a(ye) {
    var fe = this;
    this.next = null, this.entry = null, this.finish = function() {
      $e(fe, ye);
    };
  }
  var u;
  _e.WritableState = be;
  var c = {
    deprecate: browser$c
  }, l = requireStreamBrowser(), v = require$$0$2.Buffer, p = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(ye) {
    return v.from(ye);
  }
  function I(ye) {
    return v.isBuffer(ye) || ye instanceof p;
  }
  var P = requireDestroy(), $ = requireState(), F = $.getHighWaterMark, H = requireErrorsBrowser().codes, j = H.ERR_INVALID_ARG_TYPE, ee = H.ERR_METHOD_NOT_IMPLEMENTED, X = H.ERR_MULTIPLE_CALLBACK, ie = H.ERR_STREAM_CANNOT_PIPE, Q = H.ERR_STREAM_DESTROYED, ne = H.ERR_STREAM_NULL_VALUES, Z = H.ERR_STREAM_WRITE_AFTER_END, de = H.ERR_UNKNOWN_ENCODING, he = P.errorOrDestroy;
  inherits_browserExports(_e, l);
  function pe() {
  }
  function be(ye, fe, Me) {
    u = u || require_stream_duplex$2(), ye = ye || {}, typeof Me != "boolean" && (Me = fe instanceof u), this.objectMode = !!ye.objectMode, Me && (this.objectMode = this.objectMode || !!ye.writableObjectMode), this.highWaterMark = F(this, ye, "writableHighWaterMark", Me), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ae = ye.decodeStrings === !1;
    this.decodeStrings = !Ae, this.defaultEncoding = ye.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(xe) {
      A(fe, xe);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ye.emitClose !== !1, this.autoDestroy = !!ye.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
  }
  be.prototype.getBuffer = function() {
    for (var fe = this.bufferedRequest, Me = []; fe; )
      Me.push(fe), fe = fe.next;
    return Me;
  }, function() {
    try {
      Object.defineProperty(be.prototype, "buffer", {
        get: c.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ke;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ke = Function.prototype[Symbol.hasInstance], Object.defineProperty(_e, Symbol.hasInstance, {
    value: function(fe) {
      return ke.call(this, fe) ? !0 : this !== _e ? !1 : fe && fe._writableState instanceof be;
    }
  })) : ke = function(fe) {
    return fe instanceof this;
  };
  function _e(ye) {
    u = u || require_stream_duplex$2();
    var fe = this instanceof u;
    if (!fe && !ke.call(_e, this))
      return new _e(ye);
    this._writableState = new be(ye, this, fe), this.writable = !0, ye && (typeof ye.write == "function" && (this._write = ye.write), typeof ye.writev == "function" && (this._writev = ye.writev), typeof ye.destroy == "function" && (this._destroy = ye.destroy), typeof ye.final == "function" && (this._final = ye.final)), l.call(this);
  }
  _e.prototype.pipe = function() {
    he(this, new ie());
  };
  function q(ye, fe) {
    var Me = new Z();
    he(ye, Me), process$1.nextTick(fe, Me);
  }
  function z(ye, fe, Me, Ae) {
    var xe;
    return Me === null ? xe = new ne() : typeof Me != "string" && !fe.objectMode && (xe = new j("chunk", ["string", "Buffer"], Me)), xe ? (he(ye, xe), process$1.nextTick(Ae, xe), !1) : !0;
  }
  _e.prototype.write = function(ye, fe, Me) {
    var Ae = this._writableState, xe = !1, ae = !Ae.objectMode && I(ye);
    return ae && !v.isBuffer(ye) && (ye = _(ye)), typeof fe == "function" && (Me = fe, fe = null), ae ? fe = "buffer" : fe || (fe = Ae.defaultEncoding), typeof Me != "function" && (Me = pe), Ae.ending ? q(this, Me) : (ae || z(this, Ae, ye, Me)) && (Ae.pendingcb++, xe = b(this, Ae, ae, ye, fe, Me)), xe;
  }, _e.prototype.cork = function() {
    this._writableState.corked++;
  }, _e.prototype.uncork = function() {
    var ye = this._writableState;
    ye.corked && (ye.corked--, !ye.writing && !ye.corked && !ye.bufferProcessing && ye.bufferedRequest && B(this, ye));
  }, _e.prototype.setDefaultEncoding = function(fe) {
    if (typeof fe == "string" && (fe = fe.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((fe + "").toLowerCase()) > -1))
      throw new de(fe);
    return this._writableState.defaultEncoding = fe, this;
  }, Object.defineProperty(_e.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function C(ye, fe, Me) {
    return !ye.objectMode && ye.decodeStrings !== !1 && typeof fe == "string" && (fe = v.from(fe, Me)), fe;
  }
  Object.defineProperty(_e.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function b(ye, fe, Me, Ae, xe, ae) {
    if (!Me) {
      var N = C(fe, Ae, xe);
      Ae !== N && (Me = !0, xe = "buffer", Ae = N);
    }
    var re = fe.objectMode ? 1 : Ae.length;
    fe.length += re;
    var le = fe.length < fe.highWaterMark;
    if (le || (fe.needDrain = !0), fe.writing || fe.corked) {
      var Ne = fe.lastBufferedRequest;
      fe.lastBufferedRequest = {
        chunk: Ae,
        encoding: xe,
        isBuf: Me,
        callback: ae,
        next: null
      }, Ne ? Ne.next = fe.lastBufferedRequest : fe.bufferedRequest = fe.lastBufferedRequest, fe.bufferedRequestCount += 1;
    } else
      E(ye, fe, !1, re, Ae, xe, ae);
    return le;
  }
  function E(ye, fe, Me, Ae, xe, ae, N) {
    fe.writelen = Ae, fe.writecb = N, fe.writing = !0, fe.sync = !0, fe.destroyed ? fe.onwrite(new Q("write")) : Me ? ye._writev(xe, fe.onwrite) : ye._write(xe, ae, fe.onwrite), fe.sync = !1;
  }
  function k(ye, fe, Me, Ae, xe) {
    --fe.pendingcb, Me ? (process$1.nextTick(xe, Ae), process$1.nextTick(me, ye, fe), ye._writableState.errorEmitted = !0, he(ye, Ae)) : (xe(Ae), ye._writableState.errorEmitted = !0, he(ye, Ae), me(ye, fe));
  }
  function O(ye) {
    ye.writing = !1, ye.writecb = null, ye.length -= ye.writelen, ye.writelen = 0;
  }
  function A(ye, fe) {
    var Me = ye._writableState, Ae = Me.sync, xe = Me.writecb;
    if (typeof xe != "function")
      throw new X();
    if (O(Me), fe)
      k(ye, Me, Ae, fe, xe);
    else {
      var ae = T(Me) || ye.destroyed;
      !ae && !Me.corked && !Me.bufferProcessing && Me.bufferedRequest && B(ye, Me), Ae ? process$1.nextTick(x, ye, Me, ae, xe) : x(ye, Me, ae, xe);
    }
  }
  function x(ye, fe, Me, Ae) {
    Me || Y(ye, fe), fe.pendingcb--, Ae(), me(ye, fe);
  }
  function Y(ye, fe) {
    fe.length === 0 && fe.needDrain && (fe.needDrain = !1, ye.emit("drain"));
  }
  function B(ye, fe) {
    fe.bufferProcessing = !0;
    var Me = fe.bufferedRequest;
    if (ye._writev && Me && Me.next) {
      var Ae = fe.bufferedRequestCount, xe = new Array(Ae), ae = fe.corkedRequestsFree;
      ae.entry = Me;
      for (var N = 0, re = !0; Me; )
        xe[N] = Me, Me.isBuf || (re = !1), Me = Me.next, N += 1;
      xe.allBuffers = re, E(ye, fe, !0, fe.length, xe, "", ae.finish), fe.pendingcb++, fe.lastBufferedRequest = null, ae.next ? (fe.corkedRequestsFree = ae.next, ae.next = null) : fe.corkedRequestsFree = new a(fe), fe.bufferedRequestCount = 0;
    } else {
      for (; Me; ) {
        var le = Me.chunk, Ne = Me.encoding, Oe = Me.callback, qe = fe.objectMode ? 1 : le.length;
        if (E(ye, fe, !1, qe, le, Ne, Oe), Me = Me.next, fe.bufferedRequestCount--, fe.writing)
          break;
      }
      Me === null && (fe.lastBufferedRequest = null);
    }
    fe.bufferedRequest = Me, fe.bufferProcessing = !1;
  }
  _e.prototype._write = function(ye, fe, Me) {
    Me(new ee("_write()"));
  }, _e.prototype._writev = null, _e.prototype.end = function(ye, fe, Me) {
    var Ae = this._writableState;
    return typeof ye == "function" ? (Me = ye, ye = null, fe = null) : typeof fe == "function" && (Me = fe, fe = null), ye != null && this.write(ye, fe), Ae.corked && (Ae.corked = 1, this.uncork()), Ae.ending || Ie(this, Ae, Me), this;
  }, Object.defineProperty(_e.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function T(ye) {
    return ye.ending && ye.length === 0 && ye.bufferedRequest === null && !ye.finished && !ye.writing;
  }
  function D(ye, fe) {
    ye._final(function(Me) {
      fe.pendingcb--, Me && he(ye, Me), fe.prefinished = !0, ye.emit("prefinish"), me(ye, fe);
    });
  }
  function te(ye, fe) {
    !fe.prefinished && !fe.finalCalled && (typeof ye._final == "function" && !fe.destroyed ? (fe.pendingcb++, fe.finalCalled = !0, process$1.nextTick(D, ye, fe)) : (fe.prefinished = !0, ye.emit("prefinish")));
  }
  function me(ye, fe) {
    var Me = T(fe);
    if (Me && (te(ye, fe), fe.pendingcb === 0 && (fe.finished = !0, ye.emit("finish"), fe.autoDestroy))) {
      var Ae = ye._readableState;
      (!Ae || Ae.autoDestroy && Ae.endEmitted) && ye.destroy();
    }
    return Me;
  }
  function Ie(ye, fe, Me) {
    fe.ending = !0, me(ye, fe), Me && (fe.finished ? process$1.nextTick(Me) : ye.once("finish", Me)), fe.ended = !0, ye.writable = !1;
  }
  function $e(ye, fe, Me) {
    var Ae = ye.entry;
    for (ye.entry = null; Ae; ) {
      var xe = Ae.callback;
      fe.pendingcb--, xe(Me), Ae = Ae.next;
    }
    fe.corkedRequestsFree.next = ye;
  }
  return Object.defineProperty(_e.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(fe) {
      this._writableState && (this._writableState.destroyed = fe);
    }
  }), _e.prototype.destroy = P.destroy, _e.prototype._undestroy = P.undestroy, _e.prototype._destroy = function(ye, fe) {
    fe(ye);
  }, _stream_writable$2;
}
var _stream_duplex$2, hasRequired_stream_duplex$2;
function require_stream_duplex$2() {
  if (hasRequired_stream_duplex$2)
    return _stream_duplex$2;
  hasRequired_stream_duplex$2 = 1;
  var a = Object.keys || function($) {
    var F = [];
    for (var H in $)
      F.push(H);
    return F;
  };
  _stream_duplex$2 = _;
  var u = require_stream_readable$2(), c = require_stream_writable$2();
  inherits_browserExports(_, u);
  for (var l = a(c.prototype), v = 0; v < l.length; v++) {
    var p = l[v];
    _.prototype[p] || (_.prototype[p] = c.prototype[p]);
  }
  function _($) {
    if (!(this instanceof _))
      return new _($);
    u.call(this, $), c.call(this, $), this.allowHalfOpen = !0, $ && ($.readable === !1 && (this.readable = !1), $.writable === !1 && (this.writable = !1), $.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", I)));
  }
  Object.defineProperty(_.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(_.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(_.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function I() {
    this._writableState.ended || process$1.nextTick(P, this);
  }
  function P($) {
    $.end();
  }
  return Object.defineProperty(_.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(F) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = F, this._writableState.destroyed = F);
    }
  }), _stream_duplex$2;
}
var string_decoder = {}, safeBuffer$3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, I) {
    for (var P in _)
      I[P] = _[P];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, I, P) {
    return l(_, I, P);
  }
  p.prototype = Object.create(l.prototype), v(l, p), p.from = function(_, I, P) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, I, P);
  }, p.alloc = function(_, I, P) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var $ = l(_);
    return I !== void 0 ? typeof P == "string" ? $.fill(I, P) : $.fill(I) : $.fill(0), $;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$3, safeBuffer$3.exports);
var safeBufferExports$2 = safeBuffer$3.exports, Buffer$L = safeBufferExports$2.Buffer, isEncoding = Buffer$L.isEncoding || function(a) {
  switch (a = "" + a, a && a.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(a) {
  if (!a)
    return "utf8";
  for (var u; ; )
    switch (a) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return a;
      default:
        if (u)
          return;
        a = ("" + a).toLowerCase(), u = !0;
    }
}
function normalizeEncoding(a) {
  var u = _normalizeEncoding(a);
  if (typeof u != "string" && (Buffer$L.isEncoding === isEncoding || !isEncoding(a)))
    throw new Error("Unknown encoding: " + a);
  return u || a;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(a) {
  this.encoding = normalizeEncoding(a);
  var u;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, u = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, u = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, u = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$L.allocUnsafe(u);
}
StringDecoder$1.prototype.write = function(a) {
  if (a.length === 0)
    return "";
  var u, c;
  if (this.lastNeed) {
    if (u = this.fillLast(a), u === void 0)
      return "";
    c = this.lastNeed, this.lastNeed = 0;
  } else
    c = 0;
  return c < a.length ? u ? u + this.text(a, c) : this.text(a, c) : u || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(a) {
  if (this.lastNeed <= a.length)
    return a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, a.length), this.lastNeed -= a.length;
};
function utf8CheckByte(a) {
  return a <= 127 ? 0 : a >> 5 === 6 ? 2 : a >> 4 === 14 ? 3 : a >> 3 === 30 ? 4 : a >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(a, u, c) {
  var l = u.length - 1;
  if (l < c)
    return 0;
  var v = utf8CheckByte(u[l]);
  return v >= 0 ? (v > 0 && (a.lastNeed = v - 1), v) : --l < c || v === -2 ? 0 : (v = utf8CheckByte(u[l]), v >= 0 ? (v > 0 && (a.lastNeed = v - 2), v) : --l < c || v === -2 ? 0 : (v = utf8CheckByte(u[l]), v >= 0 ? (v > 0 && (v === 2 ? v = 0 : a.lastNeed = v - 3), v) : 0));
}
function utf8CheckExtraBytes(a, u, c) {
  if ((u[0] & 192) !== 128)
    return a.lastNeed = 0, "";
  if (a.lastNeed > 1 && u.length > 1) {
    if ((u[1] & 192) !== 128)
      return a.lastNeed = 1, "";
    if (a.lastNeed > 2 && u.length > 2 && (u[2] & 192) !== 128)
      return a.lastNeed = 2, "";
  }
}
function utf8FillLast(a) {
  var u = this.lastTotal - this.lastNeed, c = utf8CheckExtraBytes(this, a);
  if (c !== void 0)
    return c;
  if (this.lastNeed <= a.length)
    return a.copy(this.lastChar, u, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  a.copy(this.lastChar, u, 0, a.length), this.lastNeed -= a.length;
}
function utf8Text(a, u) {
  var c = utf8CheckIncomplete(this, a, u);
  if (!this.lastNeed)
    return a.toString("utf8", u);
  this.lastTotal = c;
  var l = a.length - (c - this.lastNeed);
  return a.copy(this.lastChar, 0, l), a.toString("utf8", u, l);
}
function utf8End(a) {
  var u = a && a.length ? this.write(a) : "";
  return this.lastNeed ? u + "" : u;
}
function utf16Text(a, u) {
  if ((a.length - u) % 2 === 0) {
    var c = a.toString("utf16le", u);
    if (c) {
      var l = c.charCodeAt(c.length - 1);
      if (l >= 55296 && l <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1], c.slice(0, -1);
    }
    return c;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = a[a.length - 1], a.toString("utf16le", u, a.length - 1);
}
function utf16End(a) {
  var u = a && a.length ? this.write(a) : "";
  if (this.lastNeed) {
    var c = this.lastTotal - this.lastNeed;
    return u + this.lastChar.toString("utf16le", 0, c);
  }
  return u;
}
function base64Text(a, u) {
  var c = (a.length - u) % 3;
  return c === 0 ? a.toString("base64", u) : (this.lastNeed = 3 - c, this.lastTotal = 3, c === 1 ? this.lastChar[0] = a[a.length - 1] : (this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1]), a.toString("base64", u, a.length - c));
}
function base64End(a) {
  var u = a && a.length ? this.write(a) : "";
  return this.lastNeed ? u + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : u;
}
function simpleWrite(a) {
  return a.toString(this.encoding);
}
function simpleEnd(a) {
  return a && a.length ? this.write(a) : "";
}
var endOfStream$2, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream)
    return endOfStream$2;
  hasRequiredEndOfStream = 1;
  var a = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function u(p) {
    var _ = !1;
    return function() {
      if (!_) {
        _ = !0;
        for (var I = arguments.length, P = new Array(I), $ = 0; $ < I; $++)
          P[$] = arguments[$];
        p.apply(this, P);
      }
    };
  }
  function c() {
  }
  function l(p) {
    return p.setHeader && typeof p.abort == "function";
  }
  function v(p, _, I) {
    if (typeof _ == "function")
      return v(p, null, _);
    _ || (_ = {}), I = u(I || c);
    var P = _.readable || _.readable !== !1 && p.readable, $ = _.writable || _.writable !== !1 && p.writable, F = function() {
      p.writable || j();
    }, H = p._writableState && p._writableState.finished, j = function() {
      $ = !1, H = !0, P || I.call(p);
    }, ee = p._readableState && p._readableState.endEmitted, X = function() {
      P = !1, ee = !0, $ || I.call(p);
    }, ie = function(de) {
      I.call(p, de);
    }, Q = function() {
      var de;
      if (P && !ee)
        return (!p._readableState || !p._readableState.ended) && (de = new a()), I.call(p, de);
      if ($ && !H)
        return (!p._writableState || !p._writableState.ended) && (de = new a()), I.call(p, de);
    }, ne = function() {
      p.req.on("finish", j);
    };
    return l(p) ? (p.on("complete", j), p.on("abort", Q), p.req ? ne() : p.on("request", ne)) : $ && !p._writableState && (p.on("end", F), p.on("close", F)), p.on("end", X), p.on("finish", j), _.error !== !1 && p.on("error", ie), p.on("close", Q), function() {
      p.removeListener("complete", j), p.removeListener("abort", Q), p.removeListener("request", ne), p.req && p.req.removeListener("finish", j), p.removeListener("end", F), p.removeListener("close", F), p.removeListener("finish", j), p.removeListener("end", X), p.removeListener("error", ie), p.removeListener("close", Q);
    };
  }
  return endOfStream$2 = v, endOfStream$2;
}
var async_iterator$2, hasRequiredAsync_iterator$2;
function requireAsync_iterator$2() {
  if (hasRequiredAsync_iterator$2)
    return async_iterator$2;
  hasRequiredAsync_iterator$2 = 1;
  var a;
  function u(de, he, pe) {
    return he = c(he), he in de ? Object.defineProperty(de, he, { value: pe, enumerable: !0, configurable: !0, writable: !0 }) : de[he] = pe, de;
  }
  function c(de) {
    var he = l(de, "string");
    return typeof he == "symbol" ? he : String(he);
  }
  function l(de, he) {
    if (typeof de != "object" || de === null)
      return de;
    var pe = de[Symbol.toPrimitive];
    if (pe !== void 0) {
      var be = pe.call(de, he || "default");
      if (typeof be != "object")
        return be;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (he === "string" ? String : Number)(de);
  }
  var v = requireEndOfStream(), p = Symbol("lastResolve"), _ = Symbol("lastReject"), I = Symbol("error"), P = Symbol("ended"), $ = Symbol("lastPromise"), F = Symbol("handlePromise"), H = Symbol("stream");
  function j(de, he) {
    return {
      value: de,
      done: he
    };
  }
  function ee(de) {
    var he = de[p];
    if (he !== null) {
      var pe = de[H].read();
      pe !== null && (de[$] = null, de[p] = null, de[_] = null, he(j(pe, !1)));
    }
  }
  function X(de) {
    process$1.nextTick(ee, de);
  }
  function ie(de, he) {
    return function(pe, be) {
      de.then(function() {
        if (he[P]) {
          pe(j(void 0, !0));
          return;
        }
        he[F](pe, be);
      }, be);
    };
  }
  var Q = Object.getPrototypeOf(function() {
  }), ne = Object.setPrototypeOf((a = {
    get stream() {
      return this[H];
    },
    next: function() {
      var he = this, pe = this[I];
      if (pe !== null)
        return Promise.reject(pe);
      if (this[P])
        return Promise.resolve(j(void 0, !0));
      if (this[H].destroyed)
        return new Promise(function(q, z) {
          process$1.nextTick(function() {
            he[I] ? z(he[I]) : q(j(void 0, !0));
          });
        });
      var be = this[$], ke;
      if (be)
        ke = new Promise(ie(be, this));
      else {
        var _e = this[H].read();
        if (_e !== null)
          return Promise.resolve(j(_e, !1));
        ke = new Promise(this[F]);
      }
      return this[$] = ke, ke;
    }
  }, u(a, Symbol.asyncIterator, function() {
    return this;
  }), u(a, "return", function() {
    var he = this;
    return new Promise(function(pe, be) {
      he[H].destroy(null, function(ke) {
        if (ke) {
          be(ke);
          return;
        }
        pe(j(void 0, !0));
      });
    });
  }), a), Q), Z = function(he) {
    var pe, be = Object.create(ne, (pe = {}, u(pe, H, {
      value: he,
      writable: !0
    }), u(pe, p, {
      value: null,
      writable: !0
    }), u(pe, _, {
      value: null,
      writable: !0
    }), u(pe, I, {
      value: null,
      writable: !0
    }), u(pe, P, {
      value: he._readableState.endEmitted,
      writable: !0
    }), u(pe, F, {
      value: function(_e, q) {
        var z = be[H].read();
        z ? (be[$] = null, be[p] = null, be[_] = null, _e(j(z, !1))) : (be[p] = _e, be[_] = q);
      },
      writable: !0
    }), pe));
    return be[$] = null, v(he, function(ke) {
      if (ke && ke.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var _e = be[_];
        _e !== null && (be[$] = null, be[p] = null, be[_] = null, _e(ke)), be[I] = ke;
        return;
      }
      var q = be[p];
      q !== null && (be[$] = null, be[p] = null, be[_] = null, q(j(void 0, !0))), be[P] = !0;
    }), he.on("readable", X.bind(null, be)), be;
  };
  return async_iterator$2 = Z, async_iterator$2;
}
var fromBrowser$2, hasRequiredFromBrowser$2;
function requireFromBrowser$2() {
  return hasRequiredFromBrowser$2 || (hasRequiredFromBrowser$2 = 1, fromBrowser$2 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser$2;
}
var _stream_readable$2, hasRequired_stream_readable$2;
function require_stream_readable$2() {
  if (hasRequired_stream_readable$2)
    return _stream_readable$2;
  hasRequired_stream_readable$2 = 1, _stream_readable$2 = q;
  var a;
  q.ReadableState = _e, eventsExports.EventEmitter;
  var u = function(N, re) {
    return N.listeners(re).length;
  }, c = requireStreamBrowser(), l = require$$0$2.Buffer, v = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(ae) {
    return l.from(ae);
  }
  function _(ae) {
    return l.isBuffer(ae) || ae instanceof v;
  }
  var I = util$4, P;
  I && I.debuglog ? P = I.debuglog("stream") : P = function() {
  };
  var $ = requireBuffer_list$2(), F = requireDestroy(), H = requireState(), j = H.getHighWaterMark, ee = requireErrorsBrowser().codes, X = ee.ERR_INVALID_ARG_TYPE, ie = ee.ERR_STREAM_PUSH_AFTER_EOF, Q = ee.ERR_METHOD_NOT_IMPLEMENTED, ne = ee.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Z, de, he;
  inherits_browserExports(q, c);
  var pe = F.errorOrDestroy, be = ["error", "close", "destroy", "pause", "resume"];
  function ke(ae, N, re) {
    if (typeof ae.prependListener == "function")
      return ae.prependListener(N, re);
    !ae._events || !ae._events[N] ? ae.on(N, re) : Array.isArray(ae._events[N]) ? ae._events[N].unshift(re) : ae._events[N] = [re, ae._events[N]];
  }
  function _e(ae, N, re) {
    a = a || require_stream_duplex$2(), ae = ae || {}, typeof re != "boolean" && (re = N instanceof a), this.objectMode = !!ae.objectMode, re && (this.objectMode = this.objectMode || !!ae.readableObjectMode), this.highWaterMark = j(this, ae, "readableHighWaterMark", re), this.buffer = new $(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = ae.emitClose !== !1, this.autoDestroy = !!ae.autoDestroy, this.destroyed = !1, this.defaultEncoding = ae.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, ae.encoding && (Z || (Z = string_decoder.StringDecoder), this.decoder = new Z(ae.encoding), this.encoding = ae.encoding);
  }
  function q(ae) {
    if (a = a || require_stream_duplex$2(), !(this instanceof q))
      return new q(ae);
    var N = this instanceof a;
    this._readableState = new _e(ae, this, N), this.readable = !0, ae && (typeof ae.read == "function" && (this._read = ae.read), typeof ae.destroy == "function" && (this._destroy = ae.destroy)), c.call(this);
  }
  Object.defineProperty(q.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(N) {
      this._readableState && (this._readableState.destroyed = N);
    }
  }), q.prototype.destroy = F.destroy, q.prototype._undestroy = F.undestroy, q.prototype._destroy = function(ae, N) {
    N(ae);
  }, q.prototype.push = function(ae, N) {
    var re = this._readableState, le;
    return re.objectMode ? le = !0 : typeof ae == "string" && (N = N || re.defaultEncoding, N !== re.encoding && (ae = l.from(ae, N), N = ""), le = !0), z(this, ae, N, !1, le);
  }, q.prototype.unshift = function(ae) {
    return z(this, ae, null, !0, !1);
  };
  function z(ae, N, re, le, Ne) {
    P("readableAddChunk", N);
    var Oe = ae._readableState;
    if (N === null)
      Oe.reading = !1, A(ae, Oe);
    else {
      var qe;
      if (Ne || (qe = b(Oe, N)), qe)
        pe(ae, qe);
      else if (Oe.objectMode || N && N.length > 0)
        if (typeof N != "string" && !Oe.objectMode && Object.getPrototypeOf(N) !== l.prototype && (N = p(N)), le)
          Oe.endEmitted ? pe(ae, new ne()) : C(ae, Oe, N, !0);
        else if (Oe.ended)
          pe(ae, new ie());
        else {
          if (Oe.destroyed)
            return !1;
          Oe.reading = !1, Oe.decoder && !re ? (N = Oe.decoder.write(N), Oe.objectMode || N.length !== 0 ? C(ae, Oe, N, !1) : B(ae, Oe)) : C(ae, Oe, N, !1);
        }
      else
        le || (Oe.reading = !1, B(ae, Oe));
    }
    return !Oe.ended && (Oe.length < Oe.highWaterMark || Oe.length === 0);
  }
  function C(ae, N, re, le) {
    N.flowing && N.length === 0 && !N.sync ? (N.awaitDrain = 0, ae.emit("data", re)) : (N.length += N.objectMode ? 1 : re.length, le ? N.buffer.unshift(re) : N.buffer.push(re), N.needReadable && x(ae)), B(ae, N);
  }
  function b(ae, N) {
    var re;
    return !_(N) && typeof N != "string" && N !== void 0 && !ae.objectMode && (re = new X("chunk", ["string", "Buffer", "Uint8Array"], N)), re;
  }
  q.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, q.prototype.setEncoding = function(ae) {
    Z || (Z = string_decoder.StringDecoder);
    var N = new Z(ae);
    this._readableState.decoder = N, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var re = this._readableState.buffer.head, le = ""; re !== null; )
      le += N.write(re.data), re = re.next;
    return this._readableState.buffer.clear(), le !== "" && this._readableState.buffer.push(le), this._readableState.length = le.length, this;
  };
  var E = 1073741824;
  function k(ae) {
    return ae >= E ? ae = E : (ae--, ae |= ae >>> 1, ae |= ae >>> 2, ae |= ae >>> 4, ae |= ae >>> 8, ae |= ae >>> 16, ae++), ae;
  }
  function O(ae, N) {
    return ae <= 0 || N.length === 0 && N.ended ? 0 : N.objectMode ? 1 : ae !== ae ? N.flowing && N.length ? N.buffer.head.data.length : N.length : (ae > N.highWaterMark && (N.highWaterMark = k(ae)), ae <= N.length ? ae : N.ended ? N.length : (N.needReadable = !0, 0));
  }
  q.prototype.read = function(ae) {
    P("read", ae), ae = parseInt(ae, 10);
    var N = this._readableState, re = ae;
    if (ae !== 0 && (N.emittedReadable = !1), ae === 0 && N.needReadable && ((N.highWaterMark !== 0 ? N.length >= N.highWaterMark : N.length > 0) || N.ended))
      return P("read: emitReadable", N.length, N.ended), N.length === 0 && N.ended ? Me(this) : x(this), null;
    if (ae = O(ae, N), ae === 0 && N.ended)
      return N.length === 0 && Me(this), null;
    var le = N.needReadable;
    P("need readable", le), (N.length === 0 || N.length - ae < N.highWaterMark) && (le = !0, P("length less than watermark", le)), N.ended || N.reading ? (le = !1, P("reading or ended", le)) : le && (P("do read"), N.reading = !0, N.sync = !0, N.length === 0 && (N.needReadable = !0), this._read(N.highWaterMark), N.sync = !1, N.reading || (ae = O(re, N)));
    var Ne;
    return ae > 0 ? Ne = fe(ae, N) : Ne = null, Ne === null ? (N.needReadable = N.length <= N.highWaterMark, ae = 0) : (N.length -= ae, N.awaitDrain = 0), N.length === 0 && (N.ended || (N.needReadable = !0), re !== ae && N.ended && Me(this)), Ne !== null && this.emit("data", Ne), Ne;
  };
  function A(ae, N) {
    if (P("onEofChunk"), !N.ended) {
      if (N.decoder) {
        var re = N.decoder.end();
        re && re.length && (N.buffer.push(re), N.length += N.objectMode ? 1 : re.length);
      }
      N.ended = !0, N.sync ? x(ae) : (N.needReadable = !1, N.emittedReadable || (N.emittedReadable = !0, Y(ae)));
    }
  }
  function x(ae) {
    var N = ae._readableState;
    P("emitReadable", N.needReadable, N.emittedReadable), N.needReadable = !1, N.emittedReadable || (P("emitReadable", N.flowing), N.emittedReadable = !0, process$1.nextTick(Y, ae));
  }
  function Y(ae) {
    var N = ae._readableState;
    P("emitReadable_", N.destroyed, N.length, N.ended), !N.destroyed && (N.length || N.ended) && (ae.emit("readable"), N.emittedReadable = !1), N.needReadable = !N.flowing && !N.ended && N.length <= N.highWaterMark, ye(ae);
  }
  function B(ae, N) {
    N.readingMore || (N.readingMore = !0, process$1.nextTick(T, ae, N));
  }
  function T(ae, N) {
    for (; !N.reading && !N.ended && (N.length < N.highWaterMark || N.flowing && N.length === 0); ) {
      var re = N.length;
      if (P("maybeReadMore read 0"), ae.read(0), re === N.length)
        break;
    }
    N.readingMore = !1;
  }
  q.prototype._read = function(ae) {
    pe(this, new Q("_read()"));
  }, q.prototype.pipe = function(ae, N) {
    var re = this, le = this._readableState;
    switch (le.pipesCount) {
      case 0:
        le.pipes = ae;
        break;
      case 1:
        le.pipes = [le.pipes, ae];
        break;
      default:
        le.pipes.push(ae);
        break;
    }
    le.pipesCount += 1, P("pipe count=%d opts=%j", le.pipesCount, N);
    var Ne = (!N || N.end !== !1) && ae !== process$1.stdout && ae !== process$1.stderr, Oe = Ne ? je : We;
    le.endEmitted ? process$1.nextTick(Oe) : re.once("end", Oe), ae.on("unpipe", qe);
    function qe(Re, J) {
      P("onunpipe"), Re === re && J && J.hasUnpiped === !1 && (J.hasUnpiped = !0, Xe());
    }
    function je() {
      P("onend"), ae.end();
    }
    var Fe = D(re);
    ae.on("drain", Fe);
    var yt = !1;
    function Xe() {
      P("cleanup"), ae.removeListener("close", ge), ae.removeListener("finish", Te), ae.removeListener("drain", Fe), ae.removeListener("error", V), ae.removeListener("unpipe", qe), re.removeListener("end", je), re.removeListener("end", We), re.removeListener("data", Ge), yt = !0, le.awaitDrain && (!ae._writableState || ae._writableState.needDrain) && Fe();
    }
    re.on("data", Ge);
    function Ge(Re) {
      P("ondata");
      var J = ae.write(Re);
      P("dest.write", J), J === !1 && ((le.pipesCount === 1 && le.pipes === ae || le.pipesCount > 1 && xe(le.pipes, ae) !== -1) && !yt && (P("false write response, pause", le.awaitDrain), le.awaitDrain++), re.pause());
    }
    function V(Re) {
      P("onerror", Re), We(), ae.removeListener("error", V), u(ae, "error") === 0 && pe(ae, Re);
    }
    ke(ae, "error", V);
    function ge() {
      ae.removeListener("finish", Te), We();
    }
    ae.once("close", ge);
    function Te() {
      P("onfinish"), ae.removeListener("close", ge), We();
    }
    ae.once("finish", Te);
    function We() {
      P("unpipe"), re.unpipe(ae);
    }
    return ae.emit("pipe", re), le.flowing || (P("pipe resume"), re.resume()), ae;
  };
  function D(ae) {
    return function() {
      var re = ae._readableState;
      P("pipeOnDrain", re.awaitDrain), re.awaitDrain && re.awaitDrain--, re.awaitDrain === 0 && u(ae, "data") && (re.flowing = !0, ye(ae));
    };
  }
  q.prototype.unpipe = function(ae) {
    var N = this._readableState, re = {
      hasUnpiped: !1
    };
    if (N.pipesCount === 0)
      return this;
    if (N.pipesCount === 1)
      return ae && ae !== N.pipes ? this : (ae || (ae = N.pipes), N.pipes = null, N.pipesCount = 0, N.flowing = !1, ae && ae.emit("unpipe", this, re), this);
    if (!ae) {
      var le = N.pipes, Ne = N.pipesCount;
      N.pipes = null, N.pipesCount = 0, N.flowing = !1;
      for (var Oe = 0; Oe < Ne; Oe++)
        le[Oe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var qe = xe(N.pipes, ae);
    return qe === -1 ? this : (N.pipes.splice(qe, 1), N.pipesCount -= 1, N.pipesCount === 1 && (N.pipes = N.pipes[0]), ae.emit("unpipe", this, re), this);
  }, q.prototype.on = function(ae, N) {
    var re = c.prototype.on.call(this, ae, N), le = this._readableState;
    return ae === "data" ? (le.readableListening = this.listenerCount("readable") > 0, le.flowing !== !1 && this.resume()) : ae === "readable" && !le.endEmitted && !le.readableListening && (le.readableListening = le.needReadable = !0, le.flowing = !1, le.emittedReadable = !1, P("on readable", le.length, le.reading), le.length ? x(this) : le.reading || process$1.nextTick(me, this)), re;
  }, q.prototype.addListener = q.prototype.on, q.prototype.removeListener = function(ae, N) {
    var re = c.prototype.removeListener.call(this, ae, N);
    return ae === "readable" && process$1.nextTick(te, this), re;
  }, q.prototype.removeAllListeners = function(ae) {
    var N = c.prototype.removeAllListeners.apply(this, arguments);
    return (ae === "readable" || ae === void 0) && process$1.nextTick(te, this), N;
  };
  function te(ae) {
    var N = ae._readableState;
    N.readableListening = ae.listenerCount("readable") > 0, N.resumeScheduled && !N.paused ? N.flowing = !0 : ae.listenerCount("data") > 0 && ae.resume();
  }
  function me(ae) {
    P("readable nexttick read 0"), ae.read(0);
  }
  q.prototype.resume = function() {
    var ae = this._readableState;
    return ae.flowing || (P("resume"), ae.flowing = !ae.readableListening, Ie(this, ae)), ae.paused = !1, this;
  };
  function Ie(ae, N) {
    N.resumeScheduled || (N.resumeScheduled = !0, process$1.nextTick($e, ae, N));
  }
  function $e(ae, N) {
    P("resume", N.reading), N.reading || ae.read(0), N.resumeScheduled = !1, ae.emit("resume"), ye(ae), N.flowing && !N.reading && ae.read(0);
  }
  q.prototype.pause = function() {
    return P("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (P("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ye(ae) {
    var N = ae._readableState;
    for (P("flow", N.flowing); N.flowing && ae.read() !== null; )
      ;
  }
  q.prototype.wrap = function(ae) {
    var N = this, re = this._readableState, le = !1;
    ae.on("end", function() {
      if (P("wrapped end"), re.decoder && !re.ended) {
        var qe = re.decoder.end();
        qe && qe.length && N.push(qe);
      }
      N.push(null);
    }), ae.on("data", function(qe) {
      if (P("wrapped data"), re.decoder && (qe = re.decoder.write(qe)), !(re.objectMode && qe == null) && !(!re.objectMode && (!qe || !qe.length))) {
        var je = N.push(qe);
        je || (le = !0, ae.pause());
      }
    });
    for (var Ne in ae)
      this[Ne] === void 0 && typeof ae[Ne] == "function" && (this[Ne] = /* @__PURE__ */ function(je) {
        return function() {
          return ae[je].apply(ae, arguments);
        };
      }(Ne));
    for (var Oe = 0; Oe < be.length; Oe++)
      ae.on(be[Oe], this.emit.bind(this, be[Oe]));
    return this._read = function(qe) {
      P("wrapped _read", qe), le && (le = !1, ae.resume());
    }, this;
  }, typeof Symbol == "function" && (q.prototype[Symbol.asyncIterator] = function() {
    return de === void 0 && (de = requireAsync_iterator$2()), de(this);
  }), Object.defineProperty(q.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(q.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(q.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(N) {
      this._readableState && (this._readableState.flowing = N);
    }
  }), q._fromList = fe, Object.defineProperty(q.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function fe(ae, N) {
    if (N.length === 0)
      return null;
    var re;
    return N.objectMode ? re = N.buffer.shift() : !ae || ae >= N.length ? (N.decoder ? re = N.buffer.join("") : N.buffer.length === 1 ? re = N.buffer.first() : re = N.buffer.concat(N.length), N.buffer.clear()) : re = N.buffer.consume(ae, N.decoder), re;
  }
  function Me(ae) {
    var N = ae._readableState;
    P("endReadable", N.endEmitted), N.endEmitted || (N.ended = !0, process$1.nextTick(Ae, N, ae));
  }
  function Ae(ae, N) {
    if (P("endReadableNT", ae.endEmitted, ae.length), !ae.endEmitted && ae.length === 0 && (ae.endEmitted = !0, N.readable = !1, N.emit("end"), ae.autoDestroy)) {
      var re = N._writableState;
      (!re || re.autoDestroy && re.finished) && N.destroy();
    }
  }
  typeof Symbol == "function" && (q.from = function(ae, N) {
    return he === void 0 && (he = requireFromBrowser$2()), he(q, ae, N);
  });
  function xe(ae, N) {
    for (var re = 0, le = ae.length; re < le; re++)
      if (ae[re] === N)
        return re;
    return -1;
  }
  return _stream_readable$2;
}
var _stream_transform$2, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform)
    return _stream_transform$2;
  hasRequired_stream_transform = 1, _stream_transform$2 = I;
  var a = requireErrorsBrowser().codes, u = a.ERR_METHOD_NOT_IMPLEMENTED, c = a.ERR_MULTIPLE_CALLBACK, l = a.ERR_TRANSFORM_ALREADY_TRANSFORMING, v = a.ERR_TRANSFORM_WITH_LENGTH_0, p = require_stream_duplex$2();
  inherits_browserExports(I, p);
  function _(F, H) {
    var j = this._transformState;
    j.transforming = !1;
    var ee = j.writecb;
    if (ee === null)
      return this.emit("error", new c());
    j.writechunk = null, j.writecb = null, H != null && this.push(H), ee(F);
    var X = this._readableState;
    X.reading = !1, (X.needReadable || X.length < X.highWaterMark) && this._read(X.highWaterMark);
  }
  function I(F) {
    if (!(this instanceof I))
      return new I(F);
    p.call(this, F), this._transformState = {
      afterTransform: _.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, F && (typeof F.transform == "function" && (this._transform = F.transform), typeof F.flush == "function" && (this._flush = F.flush)), this.on("prefinish", P);
  }
  function P() {
    var F = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(H, j) {
      $(F, H, j);
    }) : $(this, null, null);
  }
  I.prototype.push = function(F, H) {
    return this._transformState.needTransform = !1, p.prototype.push.call(this, F, H);
  }, I.prototype._transform = function(F, H, j) {
    j(new u("_transform()"));
  }, I.prototype._write = function(F, H, j) {
    var ee = this._transformState;
    if (ee.writecb = j, ee.writechunk = F, ee.writeencoding = H, !ee.transforming) {
      var X = this._readableState;
      (ee.needTransform || X.needReadable || X.length < X.highWaterMark) && this._read(X.highWaterMark);
    }
  }, I.prototype._read = function(F) {
    var H = this._transformState;
    H.writechunk !== null && !H.transforming ? (H.transforming = !0, this._transform(H.writechunk, H.writeencoding, H.afterTransform)) : H.needTransform = !0;
  }, I.prototype._destroy = function(F, H) {
    p.prototype._destroy.call(this, F, function(j) {
      H(j);
    });
  };
  function $(F, H, j) {
    if (H)
      return F.emit("error", H);
    if (j != null && F.push(j), F._writableState.length)
      throw new v();
    if (F._transformState.transforming)
      throw new l();
    return F.push(null);
  }
  return _stream_transform$2;
}
var _stream_passthrough$2, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough)
    return _stream_passthrough$2;
  hasRequired_stream_passthrough = 1, _stream_passthrough$2 = u;
  var a = require_stream_transform();
  inherits_browserExports(u, a);
  function u(c) {
    if (!(this instanceof u))
      return new u(c);
    a.call(this, c);
  }
  return u.prototype._transform = function(c, l, v) {
    v(null, c);
  }, _stream_passthrough$2;
}
var pipeline_1$2, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline)
    return pipeline_1$2;
  hasRequiredPipeline = 1;
  var a;
  function u(j) {
    var ee = !1;
    return function() {
      ee || (ee = !0, j.apply(void 0, arguments));
    };
  }
  var c = requireErrorsBrowser().codes, l = c.ERR_MISSING_ARGS, v = c.ERR_STREAM_DESTROYED;
  function p(j) {
    if (j)
      throw j;
  }
  function _(j) {
    return j.setHeader && typeof j.abort == "function";
  }
  function I(j, ee, X, ie) {
    ie = u(ie);
    var Q = !1;
    j.on("close", function() {
      Q = !0;
    }), a === void 0 && (a = requireEndOfStream()), a(j, {
      readable: ee,
      writable: X
    }, function(Z) {
      if (Z)
        return ie(Z);
      Q = !0, ie();
    });
    var ne = !1;
    return function(Z) {
      if (!Q && !ne) {
        if (ne = !0, _(j))
          return j.abort();
        if (typeof j.destroy == "function")
          return j.destroy();
        ie(Z || new v("pipe"));
      }
    };
  }
  function P(j) {
    j();
  }
  function $(j, ee) {
    return j.pipe(ee);
  }
  function F(j) {
    return !j.length || typeof j[j.length - 1] != "function" ? p : j.pop();
  }
  function H() {
    for (var j = arguments.length, ee = new Array(j), X = 0; X < j; X++)
      ee[X] = arguments[X];
    var ie = F(ee);
    if (Array.isArray(ee[0]) && (ee = ee[0]), ee.length < 2)
      throw new l("streams");
    var Q, ne = ee.map(function(Z, de) {
      var he = de < ee.length - 1, pe = de > 0;
      return I(Z, he, pe, function(be) {
        Q || (Q = be), be && ne.forEach(P), !he && (ne.forEach(P), ie(Q));
      });
    });
    return ee.reduce($);
  }
  return pipeline_1$2 = H, pipeline_1$2;
}
var streamBrowserify = Stream$3, EE = eventsExports.EventEmitter, inherits$v = inherits_browserExports;
inherits$v(Stream$3, EE);
Stream$3.Readable = require_stream_readable$2();
Stream$3.Writable = require_stream_writable$2();
Stream$3.Duplex = require_stream_duplex$2();
Stream$3.Transform = require_stream_transform();
Stream$3.PassThrough = require_stream_passthrough();
Stream$3.finished = requireEndOfStream();
Stream$3.pipeline = requirePipeline();
Stream$3.Stream = Stream$3;
function Stream$3() {
  EE.call(this);
}
Stream$3.prototype.pipe = function(a, u) {
  var c = this;
  function l(F) {
    a.writable && a.write(F) === !1 && c.pause && c.pause();
  }
  c.on("data", l);
  function v() {
    c.readable && c.resume && c.resume();
  }
  a.on("drain", v), !a._isStdio && (!u || u.end !== !1) && (c.on("end", _), c.on("close", I));
  var p = !1;
  function _() {
    p || (p = !0, a.end());
  }
  function I() {
    p || (p = !0, typeof a.destroy == "function" && a.destroy());
  }
  function P(F) {
    if ($(), EE.listenerCount(this, "error") === 0)
      throw F;
  }
  c.on("error", P), a.on("error", P);
  function $() {
    c.removeListener("data", l), a.removeListener("drain", v), c.removeListener("end", _), c.removeListener("close", I), c.removeListener("error", P), a.removeListener("error", P), c.removeListener("end", $), c.removeListener("close", $), a.removeListener("close", $);
  }
  return c.on("end", $), c.on("close", $), a.on("close", $), a.emit("pipe", c), a;
};
var Buffer$K = safeBufferExports$3.Buffer, Stream$2 = streamBrowserify, util$3 = util$4;
function DataStream$2(a) {
  if (this.buffer = null, this.writable = !0, this.readable = !0, !a)
    return this.buffer = Buffer$K.alloc(0), this;
  if (typeof a.pipe == "function")
    return this.buffer = Buffer$K.alloc(0), a.pipe(this), this;
  if (a.length || typeof a == "object")
    return this.buffer = a, this.writable = !1, process$1.nextTick((function() {
      this.emit("end", a), this.readable = !1, this.emit("close");
    }).bind(this)), this;
  throw new TypeError("Unexpected data type (" + typeof a + ")");
}
util$3.inherits(DataStream$2, Stream$2);
DataStream$2.prototype.write = function a(u) {
  this.buffer = Buffer$K.concat([this.buffer, Buffer$K.from(u)]), this.emit("data", u);
};
DataStream$2.prototype.end = function a(u) {
  u && this.write(u), this.emit("end", u), this.emit("close"), this.writable = !1, this.readable = !1;
};
var dataStream = DataStream$2, Buffer$J = require$$0$2.Buffer, SlowBuffer = require$$0$2.SlowBuffer, bufferEqualConstantTime = bufferEq;
function bufferEq(a, u) {
  if (!Buffer$J.isBuffer(a) || !Buffer$J.isBuffer(u) || a.length !== u.length)
    return !1;
  for (var c = 0, l = 0; l < a.length; l++)
    c |= a[l] ^ u[l];
  return c === 0;
}
bufferEq.install = function() {
  Buffer$J.prototype.equal = SlowBuffer.prototype.equal = function(u) {
    return bufferEq(this, u);
  };
};
var origBufEqual = Buffer$J.prototype.equal, origSlowBufEqual = SlowBuffer.prototype.equal;
bufferEq.restore = function() {
  Buffer$J.prototype.equal = origBufEqual, SlowBuffer.prototype.equal = origSlowBufEqual;
};
var cryptoBrowserify = {}, browser$b = { exports: {} }, MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer$I = safeBufferExports$3.Buffer, crypto$3 = commonjsGlobal$1.crypto || commonjsGlobal$1.msCrypto;
crypto$3 && crypto$3.getRandomValues ? browser$b.exports = randomBytes$2 : browser$b.exports = oldBrowser$1;
function randomBytes$2(a, u) {
  if (a > MAX_UINT32)
    throw new RangeError("requested too many random bytes");
  var c = Buffer$I.allocUnsafe(a);
  if (a > 0)
    if (a > MAX_BYTES)
      for (var l = 0; l < a; l += MAX_BYTES)
        crypto$3.getRandomValues(c.slice(l, l + MAX_BYTES));
    else
      crypto$3.getRandomValues(c);
  return typeof u == "function" ? process$1.nextTick(function() {
    u(null, c);
  }) : c;
}
var browserExports = browser$b.exports, safeBuffer$2 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, I) {
    for (var P in _)
      I[P] = _[P];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, I, P) {
    return l(_, I, P);
  }
  p.prototype = Object.create(l.prototype), v(l, p), p.from = function(_, I, P) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, I, P);
  }, p.alloc = function(_, I, P) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var $ = l(_);
    return I !== void 0 ? typeof P == "string" ? $.fill(I, P) : $.fill(I) : $.fill(0), $;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$2, safeBuffer$2.exports);
var safeBufferExports$1 = safeBuffer$2.exports, readableBrowser$1 = { exports: {} }, streamBrowser$1 = eventsExports.EventEmitter, buffer_list$1, hasRequiredBuffer_list$1;
function requireBuffer_list$1() {
  if (hasRequiredBuffer_list$1)
    return buffer_list$1;
  hasRequiredBuffer_list$1 = 1;
  function a(X, ie) {
    var Q = Object.keys(X);
    if (Object.getOwnPropertySymbols) {
      var ne = Object.getOwnPropertySymbols(X);
      ie && (ne = ne.filter(function(Z) {
        return Object.getOwnPropertyDescriptor(X, Z).enumerable;
      })), Q.push.apply(Q, ne);
    }
    return Q;
  }
  function u(X) {
    for (var ie = 1; ie < arguments.length; ie++) {
      var Q = arguments[ie] != null ? arguments[ie] : {};
      ie % 2 ? a(Object(Q), !0).forEach(function(ne) {
        c(X, ne, Q[ne]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(X, Object.getOwnPropertyDescriptors(Q)) : a(Object(Q)).forEach(function(ne) {
        Object.defineProperty(X, ne, Object.getOwnPropertyDescriptor(Q, ne));
      });
    }
    return X;
  }
  function c(X, ie, Q) {
    return ie = _(ie), ie in X ? Object.defineProperty(X, ie, { value: Q, enumerable: !0, configurable: !0, writable: !0 }) : X[ie] = Q, X;
  }
  function l(X, ie) {
    if (!(X instanceof ie))
      throw new TypeError("Cannot call a class as a function");
  }
  function v(X, ie) {
    for (var Q = 0; Q < ie.length; Q++) {
      var ne = ie[Q];
      ne.enumerable = ne.enumerable || !1, ne.configurable = !0, "value" in ne && (ne.writable = !0), Object.defineProperty(X, _(ne.key), ne);
    }
  }
  function p(X, ie, Q) {
    return ie && v(X.prototype, ie), Q && v(X, Q), Object.defineProperty(X, "prototype", { writable: !1 }), X;
  }
  function _(X) {
    var ie = I(X, "string");
    return typeof ie == "symbol" ? ie : String(ie);
  }
  function I(X, ie) {
    if (typeof X != "object" || X === null)
      return X;
    var Q = X[Symbol.toPrimitive];
    if (Q !== void 0) {
      var ne = Q.call(X, ie || "default");
      if (typeof ne != "object")
        return ne;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ie === "string" ? String : Number)(X);
  }
  var P = require$$0$2, $ = P.Buffer, F = util$4, H = F.inspect, j = H && H.custom || "inspect";
  function ee(X, ie, Q) {
    $.prototype.copy.call(X, ie, Q);
  }
  return buffer_list$1 = /* @__PURE__ */ function() {
    function X() {
      l(this, X), this.head = null, this.tail = null, this.length = 0;
    }
    return p(X, [{
      key: "push",
      value: function(Q) {
        var ne = {
          data: Q,
          next: null
        };
        this.length > 0 ? this.tail.next = ne : this.head = ne, this.tail = ne, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Q) {
        var ne = {
          data: Q,
          next: this.head
        };
        this.length === 0 && (this.tail = ne), this.head = ne, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Q = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Q;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Q) {
        if (this.length === 0)
          return "";
        for (var ne = this.head, Z = "" + ne.data; ne = ne.next; )
          Z += Q + ne.data;
        return Z;
      }
    }, {
      key: "concat",
      value: function(Q) {
        if (this.length === 0)
          return $.alloc(0);
        for (var ne = $.allocUnsafe(Q >>> 0), Z = this.head, de = 0; Z; )
          ee(Z.data, ne, de), de += Z.data.length, Z = Z.next;
        return ne;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Q, ne) {
        var Z;
        return Q < this.head.data.length ? (Z = this.head.data.slice(0, Q), this.head.data = this.head.data.slice(Q)) : Q === this.head.data.length ? Z = this.shift() : Z = ne ? this._getString(Q) : this._getBuffer(Q), Z;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Q) {
        var ne = this.head, Z = 1, de = ne.data;
        for (Q -= de.length; ne = ne.next; ) {
          var he = ne.data, pe = Q > he.length ? he.length : Q;
          if (pe === he.length ? de += he : de += he.slice(0, Q), Q -= pe, Q === 0) {
            pe === he.length ? (++Z, ne.next ? this.head = ne.next : this.head = this.tail = null) : (this.head = ne, ne.data = he.slice(pe));
            break;
          }
          ++Z;
        }
        return this.length -= Z, de;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Q) {
        var ne = $.allocUnsafe(Q), Z = this.head, de = 1;
        for (Z.data.copy(ne), Q -= Z.data.length; Z = Z.next; ) {
          var he = Z.data, pe = Q > he.length ? he.length : Q;
          if (he.copy(ne, ne.length - Q, 0, pe), Q -= pe, Q === 0) {
            pe === he.length ? (++de, Z.next ? this.head = Z.next : this.head = this.tail = null) : (this.head = Z, Z.data = he.slice(pe));
            break;
          }
          ++de;
        }
        return this.length -= de, ne;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: j,
      value: function(Q, ne) {
        return H(this, u(u({}, ne), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), X;
  }(), buffer_list$1;
}
function destroy$1(a, u) {
  var c = this, l = this._readableState && this._readableState.destroyed, v = this._writableState && this._writableState.destroyed;
  return l || v ? (u ? u(a) : a && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(emitErrorNT$1, this, a)) : process$1.nextTick(emitErrorNT$1, this, a)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(a || null, function(p) {
    !u && p ? c._writableState ? c._writableState.errorEmitted ? process$1.nextTick(emitCloseNT$1, c) : (c._writableState.errorEmitted = !0, process$1.nextTick(emitErrorAndCloseNT$1, c, p)) : process$1.nextTick(emitErrorAndCloseNT$1, c, p) : u ? (process$1.nextTick(emitCloseNT$1, c), u(p)) : process$1.nextTick(emitCloseNT$1, c);
  }), this);
}
function emitErrorAndCloseNT$1(a, u) {
  emitErrorNT$1(a, u), emitCloseNT$1(a);
}
function emitCloseNT$1(a) {
  a._writableState && !a._writableState.emitClose || a._readableState && !a._readableState.emitClose || a.emit("close");
}
function undestroy$1() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT$1(a, u) {
  a.emit("error", u);
}
function errorOrDestroy$1(a, u) {
  var c = a._readableState, l = a._writableState;
  c && c.autoDestroy || l && l.autoDestroy ? a.destroy(u) : a.emit("error", u);
}
var destroy_1$1 = {
  destroy: destroy$1,
  undestroy: undestroy$1,
  errorOrDestroy: errorOrDestroy$1
}, errorsBrowser$1 = {};
function _inheritsLoose$2(a, u) {
  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, a.__proto__ = u;
}
var codes$1 = {};
function createErrorType$1(a, u, c) {
  c || (c = Error);
  function l(p, _, I) {
    return typeof u == "string" ? u : u(p, _, I);
  }
  var v = /* @__PURE__ */ function(p) {
    _inheritsLoose$2(_, p);
    function _(I, P, $) {
      return p.call(this, l(I, P, $)) || this;
    }
    return _;
  }(c);
  v.prototype.name = c.name, v.prototype.code = a, codes$1[a] = v;
}
function oneOf$1(a, u) {
  if (Array.isArray(a)) {
    var c = a.length;
    return a = a.map(function(l) {
      return String(l);
    }), c > 2 ? "one of ".concat(u, " ").concat(a.slice(0, c - 1).join(", "), ", or ") + a[c - 1] : c === 2 ? "one of ".concat(u, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(u, " ").concat(a[0]);
  } else
    return "of ".concat(u, " ").concat(String(a));
}
function startsWith$1(a, u, c) {
  return a.substr(!c || c < 0 ? 0 : +c, u.length) === u;
}
function endsWith$1(a, u, c) {
  return (c === void 0 || c > a.length) && (c = a.length), a.substring(c - u.length, c) === u;
}
function includes$3(a, u, c) {
  return typeof c != "number" && (c = 0), c + u.length > a.length ? !1 : a.indexOf(u, c) !== -1;
}
createErrorType$1("ERR_INVALID_OPT_VALUE", function(a, u) {
  return 'The value "' + u + '" is invalid for option "' + a + '"';
}, TypeError);
createErrorType$1("ERR_INVALID_ARG_TYPE", function(a, u, c) {
  var l;
  typeof u == "string" && startsWith$1(u, "not ") ? (l = "must not be", u = u.replace(/^not /, "")) : l = "must be";
  var v;
  if (endsWith$1(a, " argument"))
    v = "The ".concat(a, " ").concat(l, " ").concat(oneOf$1(u, "type"));
  else {
    var p = includes$3(a, ".") ? "property" : "argument";
    v = 'The "'.concat(a, '" ').concat(p, " ").concat(l, " ").concat(oneOf$1(u, "type"));
  }
  return v += ". Received type ".concat(typeof c), v;
}, TypeError);
createErrorType$1("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType$1("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
  return "The " + a + " method is not implemented";
});
createErrorType$1("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType$1("ERR_STREAM_DESTROYED", function(a) {
  return "Cannot call " + a + " after a stream was destroyed";
});
createErrorType$1("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType$1("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType$1("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType$1("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType$1("ERR_UNKNOWN_ENCODING", function(a) {
  return "Unknown encoding: " + a;
}, TypeError);
createErrorType$1("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser$1.codes = codes$1;
var ERR_INVALID_OPT_VALUE$1 = errorsBrowser$1.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom$1(a, u, c) {
  return a.highWaterMark != null ? a.highWaterMark : u ? a[c] : null;
}
function getHighWaterMark$1(a, u, c, l) {
  var v = highWaterMarkFrom$1(u, l, c);
  if (v != null) {
    if (!(isFinite(v) && Math.floor(v) === v) || v < 0) {
      var p = l ? c : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE$1(p, v);
    }
    return Math.floor(v);
  }
  return a.objectMode ? 16 : 16 * 1024;
}
var state$4 = {
  getHighWaterMark: getHighWaterMark$1
}, _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1)
    return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = _e;
  function a(ye) {
    var fe = this;
    this.next = null, this.entry = null, this.finish = function() {
      $e(fe, ye);
    };
  }
  var u;
  _e.WritableState = be;
  var c = {
    deprecate: browser$c
  }, l = streamBrowser$1, v = require$$0$2.Buffer, p = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(ye) {
    return v.from(ye);
  }
  function I(ye) {
    return v.isBuffer(ye) || ye instanceof p;
  }
  var P = destroy_1$1, $ = state$4, F = $.getHighWaterMark, H = errorsBrowser$1.codes, j = H.ERR_INVALID_ARG_TYPE, ee = H.ERR_METHOD_NOT_IMPLEMENTED, X = H.ERR_MULTIPLE_CALLBACK, ie = H.ERR_STREAM_CANNOT_PIPE, Q = H.ERR_STREAM_DESTROYED, ne = H.ERR_STREAM_NULL_VALUES, Z = H.ERR_STREAM_WRITE_AFTER_END, de = H.ERR_UNKNOWN_ENCODING, he = P.errorOrDestroy;
  inherits_browserExports(_e, l);
  function pe() {
  }
  function be(ye, fe, Me) {
    u = u || require_stream_duplex$1(), ye = ye || {}, typeof Me != "boolean" && (Me = fe instanceof u), this.objectMode = !!ye.objectMode, Me && (this.objectMode = this.objectMode || !!ye.writableObjectMode), this.highWaterMark = F(this, ye, "writableHighWaterMark", Me), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ae = ye.decodeStrings === !1;
    this.decodeStrings = !Ae, this.defaultEncoding = ye.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(xe) {
      A(fe, xe);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ye.emitClose !== !1, this.autoDestroy = !!ye.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
  }
  be.prototype.getBuffer = function() {
    for (var fe = this.bufferedRequest, Me = []; fe; )
      Me.push(fe), fe = fe.next;
    return Me;
  }, function() {
    try {
      Object.defineProperty(be.prototype, "buffer", {
        get: c.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ke;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ke = Function.prototype[Symbol.hasInstance], Object.defineProperty(_e, Symbol.hasInstance, {
    value: function(fe) {
      return ke.call(this, fe) ? !0 : this !== _e ? !1 : fe && fe._writableState instanceof be;
    }
  })) : ke = function(fe) {
    return fe instanceof this;
  };
  function _e(ye) {
    u = u || require_stream_duplex$1();
    var fe = this instanceof u;
    if (!fe && !ke.call(_e, this))
      return new _e(ye);
    this._writableState = new be(ye, this, fe), this.writable = !0, ye && (typeof ye.write == "function" && (this._write = ye.write), typeof ye.writev == "function" && (this._writev = ye.writev), typeof ye.destroy == "function" && (this._destroy = ye.destroy), typeof ye.final == "function" && (this._final = ye.final)), l.call(this);
  }
  _e.prototype.pipe = function() {
    he(this, new ie());
  };
  function q(ye, fe) {
    var Me = new Z();
    he(ye, Me), process$1.nextTick(fe, Me);
  }
  function z(ye, fe, Me, Ae) {
    var xe;
    return Me === null ? xe = new ne() : typeof Me != "string" && !fe.objectMode && (xe = new j("chunk", ["string", "Buffer"], Me)), xe ? (he(ye, xe), process$1.nextTick(Ae, xe), !1) : !0;
  }
  _e.prototype.write = function(ye, fe, Me) {
    var Ae = this._writableState, xe = !1, ae = !Ae.objectMode && I(ye);
    return ae && !v.isBuffer(ye) && (ye = _(ye)), typeof fe == "function" && (Me = fe, fe = null), ae ? fe = "buffer" : fe || (fe = Ae.defaultEncoding), typeof Me != "function" && (Me = pe), Ae.ending ? q(this, Me) : (ae || z(this, Ae, ye, Me)) && (Ae.pendingcb++, xe = b(this, Ae, ae, ye, fe, Me)), xe;
  }, _e.prototype.cork = function() {
    this._writableState.corked++;
  }, _e.prototype.uncork = function() {
    var ye = this._writableState;
    ye.corked && (ye.corked--, !ye.writing && !ye.corked && !ye.bufferProcessing && ye.bufferedRequest && B(this, ye));
  }, _e.prototype.setDefaultEncoding = function(fe) {
    if (typeof fe == "string" && (fe = fe.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((fe + "").toLowerCase()) > -1))
      throw new de(fe);
    return this._writableState.defaultEncoding = fe, this;
  }, Object.defineProperty(_e.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function C(ye, fe, Me) {
    return !ye.objectMode && ye.decodeStrings !== !1 && typeof fe == "string" && (fe = v.from(fe, Me)), fe;
  }
  Object.defineProperty(_e.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function b(ye, fe, Me, Ae, xe, ae) {
    if (!Me) {
      var N = C(fe, Ae, xe);
      Ae !== N && (Me = !0, xe = "buffer", Ae = N);
    }
    var re = fe.objectMode ? 1 : Ae.length;
    fe.length += re;
    var le = fe.length < fe.highWaterMark;
    if (le || (fe.needDrain = !0), fe.writing || fe.corked) {
      var Ne = fe.lastBufferedRequest;
      fe.lastBufferedRequest = {
        chunk: Ae,
        encoding: xe,
        isBuf: Me,
        callback: ae,
        next: null
      }, Ne ? Ne.next = fe.lastBufferedRequest : fe.bufferedRequest = fe.lastBufferedRequest, fe.bufferedRequestCount += 1;
    } else
      E(ye, fe, !1, re, Ae, xe, ae);
    return le;
  }
  function E(ye, fe, Me, Ae, xe, ae, N) {
    fe.writelen = Ae, fe.writecb = N, fe.writing = !0, fe.sync = !0, fe.destroyed ? fe.onwrite(new Q("write")) : Me ? ye._writev(xe, fe.onwrite) : ye._write(xe, ae, fe.onwrite), fe.sync = !1;
  }
  function k(ye, fe, Me, Ae, xe) {
    --fe.pendingcb, Me ? (process$1.nextTick(xe, Ae), process$1.nextTick(me, ye, fe), ye._writableState.errorEmitted = !0, he(ye, Ae)) : (xe(Ae), ye._writableState.errorEmitted = !0, he(ye, Ae), me(ye, fe));
  }
  function O(ye) {
    ye.writing = !1, ye.writecb = null, ye.length -= ye.writelen, ye.writelen = 0;
  }
  function A(ye, fe) {
    var Me = ye._writableState, Ae = Me.sync, xe = Me.writecb;
    if (typeof xe != "function")
      throw new X();
    if (O(Me), fe)
      k(ye, Me, Ae, fe, xe);
    else {
      var ae = T(Me) || ye.destroyed;
      !ae && !Me.corked && !Me.bufferProcessing && Me.bufferedRequest && B(ye, Me), Ae ? process$1.nextTick(x, ye, Me, ae, xe) : x(ye, Me, ae, xe);
    }
  }
  function x(ye, fe, Me, Ae) {
    Me || Y(ye, fe), fe.pendingcb--, Ae(), me(ye, fe);
  }
  function Y(ye, fe) {
    fe.length === 0 && fe.needDrain && (fe.needDrain = !1, ye.emit("drain"));
  }
  function B(ye, fe) {
    fe.bufferProcessing = !0;
    var Me = fe.bufferedRequest;
    if (ye._writev && Me && Me.next) {
      var Ae = fe.bufferedRequestCount, xe = new Array(Ae), ae = fe.corkedRequestsFree;
      ae.entry = Me;
      for (var N = 0, re = !0; Me; )
        xe[N] = Me, Me.isBuf || (re = !1), Me = Me.next, N += 1;
      xe.allBuffers = re, E(ye, fe, !0, fe.length, xe, "", ae.finish), fe.pendingcb++, fe.lastBufferedRequest = null, ae.next ? (fe.corkedRequestsFree = ae.next, ae.next = null) : fe.corkedRequestsFree = new a(fe), fe.bufferedRequestCount = 0;
    } else {
      for (; Me; ) {
        var le = Me.chunk, Ne = Me.encoding, Oe = Me.callback, qe = fe.objectMode ? 1 : le.length;
        if (E(ye, fe, !1, qe, le, Ne, Oe), Me = Me.next, fe.bufferedRequestCount--, fe.writing)
          break;
      }
      Me === null && (fe.lastBufferedRequest = null);
    }
    fe.bufferedRequest = Me, fe.bufferProcessing = !1;
  }
  _e.prototype._write = function(ye, fe, Me) {
    Me(new ee("_write()"));
  }, _e.prototype._writev = null, _e.prototype.end = function(ye, fe, Me) {
    var Ae = this._writableState;
    return typeof ye == "function" ? (Me = ye, ye = null, fe = null) : typeof fe == "function" && (Me = fe, fe = null), ye != null && this.write(ye, fe), Ae.corked && (Ae.corked = 1, this.uncork()), Ae.ending || Ie(this, Ae, Me), this;
  }, Object.defineProperty(_e.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function T(ye) {
    return ye.ending && ye.length === 0 && ye.bufferedRequest === null && !ye.finished && !ye.writing;
  }
  function D(ye, fe) {
    ye._final(function(Me) {
      fe.pendingcb--, Me && he(ye, Me), fe.prefinished = !0, ye.emit("prefinish"), me(ye, fe);
    });
  }
  function te(ye, fe) {
    !fe.prefinished && !fe.finalCalled && (typeof ye._final == "function" && !fe.destroyed ? (fe.pendingcb++, fe.finalCalled = !0, process$1.nextTick(D, ye, fe)) : (fe.prefinished = !0, ye.emit("prefinish")));
  }
  function me(ye, fe) {
    var Me = T(fe);
    if (Me && (te(ye, fe), fe.pendingcb === 0 && (fe.finished = !0, ye.emit("finish"), fe.autoDestroy))) {
      var Ae = ye._readableState;
      (!Ae || Ae.autoDestroy && Ae.endEmitted) && ye.destroy();
    }
    return Me;
  }
  function Ie(ye, fe, Me) {
    fe.ending = !0, me(ye, fe), Me && (fe.finished ? process$1.nextTick(Me) : ye.once("finish", Me)), fe.ended = !0, ye.writable = !1;
  }
  function $e(ye, fe, Me) {
    var Ae = ye.entry;
    for (ye.entry = null; Ae; ) {
      var xe = Ae.callback;
      fe.pendingcb--, xe(Me), Ae = Ae.next;
    }
    fe.corkedRequestsFree.next = ye;
  }
  return Object.defineProperty(_e.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(fe) {
      this._writableState && (this._writableState.destroyed = fe);
    }
  }), _e.prototype.destroy = P.destroy, _e.prototype._undestroy = P.undestroy, _e.prototype._destroy = function(ye, fe) {
    fe(ye);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1)
    return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var a = Object.keys || function($) {
    var F = [];
    for (var H in $)
      F.push(H);
    return F;
  };
  _stream_duplex$1 = _;
  var u = require_stream_readable$1(), c = require_stream_writable$1();
  inherits_browserExports(_, u);
  for (var l = a(c.prototype), v = 0; v < l.length; v++) {
    var p = l[v];
    _.prototype[p] || (_.prototype[p] = c.prototype[p]);
  }
  function _($) {
    if (!(this instanceof _))
      return new _($);
    u.call(this, $), c.call(this, $), this.allowHalfOpen = !0, $ && ($.readable === !1 && (this.readable = !1), $.writable === !1 && (this.writable = !1), $.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", I)));
  }
  Object.defineProperty(_.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(_.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(_.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function I() {
    this._writableState.ended || process$1.nextTick(P, this);
  }
  function P($) {
    $.end();
  }
  return Object.defineProperty(_.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(F) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = F, this._writableState.destroyed = F);
    }
  }), _stream_duplex$1;
}
var ERR_STREAM_PREMATURE_CLOSE$1 = errorsBrowser$1.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$5(a) {
  var u = !1;
  return function() {
    if (!u) {
      u = !0;
      for (var c = arguments.length, l = new Array(c), v = 0; v < c; v++)
        l[v] = arguments[v];
      a.apply(this, l);
    }
  };
}
function noop$4() {
}
function isRequest$3(a) {
  return a.setHeader && typeof a.abort == "function";
}
function eos$3(a, u, c) {
  if (typeof u == "function")
    return eos$3(a, null, u);
  u || (u = {}), c = once$5(c || noop$4);
  var l = u.readable || u.readable !== !1 && a.readable, v = u.writable || u.writable !== !1 && a.writable, p = function() {
    a.writable || I();
  }, _ = a._writableState && a._writableState.finished, I = function() {
    v = !1, _ = !0, l || c.call(a);
  }, P = a._readableState && a._readableState.endEmitted, $ = function() {
    l = !1, P = !0, v || c.call(a);
  }, F = function(X) {
    c.call(a, X);
  }, H = function() {
    var X;
    if (l && !P)
      return (!a._readableState || !a._readableState.ended) && (X = new ERR_STREAM_PREMATURE_CLOSE$1()), c.call(a, X);
    if (v && !_)
      return (!a._writableState || !a._writableState.ended) && (X = new ERR_STREAM_PREMATURE_CLOSE$1()), c.call(a, X);
  }, j = function() {
    a.req.on("finish", I);
  };
  return isRequest$3(a) ? (a.on("complete", I), a.on("abort", H), a.req ? j() : a.on("request", j)) : v && !a._writableState && (a.on("end", p), a.on("close", p)), a.on("end", $), a.on("finish", I), u.error !== !1 && a.on("error", F), a.on("close", H), function() {
    a.removeListener("complete", I), a.removeListener("abort", H), a.removeListener("request", j), a.req && a.req.removeListener("finish", I), a.removeListener("end", p), a.removeListener("close", p), a.removeListener("finish", I), a.removeListener("end", $), a.removeListener("error", F), a.removeListener("close", H);
  };
}
var endOfStream$1 = eos$3, async_iterator$1, hasRequiredAsync_iterator$1;
function requireAsync_iterator$1() {
  if (hasRequiredAsync_iterator$1)
    return async_iterator$1;
  hasRequiredAsync_iterator$1 = 1;
  var a;
  function u(de, he, pe) {
    return he = c(he), he in de ? Object.defineProperty(de, he, { value: pe, enumerable: !0, configurable: !0, writable: !0 }) : de[he] = pe, de;
  }
  function c(de) {
    var he = l(de, "string");
    return typeof he == "symbol" ? he : String(he);
  }
  function l(de, he) {
    if (typeof de != "object" || de === null)
      return de;
    var pe = de[Symbol.toPrimitive];
    if (pe !== void 0) {
      var be = pe.call(de, he || "default");
      if (typeof be != "object")
        return be;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (he === "string" ? String : Number)(de);
  }
  var v = endOfStream$1, p = Symbol("lastResolve"), _ = Symbol("lastReject"), I = Symbol("error"), P = Symbol("ended"), $ = Symbol("lastPromise"), F = Symbol("handlePromise"), H = Symbol("stream");
  function j(de, he) {
    return {
      value: de,
      done: he
    };
  }
  function ee(de) {
    var he = de[p];
    if (he !== null) {
      var pe = de[H].read();
      pe !== null && (de[$] = null, de[p] = null, de[_] = null, he(j(pe, !1)));
    }
  }
  function X(de) {
    process$1.nextTick(ee, de);
  }
  function ie(de, he) {
    return function(pe, be) {
      de.then(function() {
        if (he[P]) {
          pe(j(void 0, !0));
          return;
        }
        he[F](pe, be);
      }, be);
    };
  }
  var Q = Object.getPrototypeOf(function() {
  }), ne = Object.setPrototypeOf((a = {
    get stream() {
      return this[H];
    },
    next: function() {
      var he = this, pe = this[I];
      if (pe !== null)
        return Promise.reject(pe);
      if (this[P])
        return Promise.resolve(j(void 0, !0));
      if (this[H].destroyed)
        return new Promise(function(q, z) {
          process$1.nextTick(function() {
            he[I] ? z(he[I]) : q(j(void 0, !0));
          });
        });
      var be = this[$], ke;
      if (be)
        ke = new Promise(ie(be, this));
      else {
        var _e = this[H].read();
        if (_e !== null)
          return Promise.resolve(j(_e, !1));
        ke = new Promise(this[F]);
      }
      return this[$] = ke, ke;
    }
  }, u(a, Symbol.asyncIterator, function() {
    return this;
  }), u(a, "return", function() {
    var he = this;
    return new Promise(function(pe, be) {
      he[H].destroy(null, function(ke) {
        if (ke) {
          be(ke);
          return;
        }
        pe(j(void 0, !0));
      });
    });
  }), a), Q), Z = function(he) {
    var pe, be = Object.create(ne, (pe = {}, u(pe, H, {
      value: he,
      writable: !0
    }), u(pe, p, {
      value: null,
      writable: !0
    }), u(pe, _, {
      value: null,
      writable: !0
    }), u(pe, I, {
      value: null,
      writable: !0
    }), u(pe, P, {
      value: he._readableState.endEmitted,
      writable: !0
    }), u(pe, F, {
      value: function(_e, q) {
        var z = be[H].read();
        z ? (be[$] = null, be[p] = null, be[_] = null, _e(j(z, !1))) : (be[p] = _e, be[_] = q);
      },
      writable: !0
    }), pe));
    return be[$] = null, v(he, function(ke) {
      if (ke && ke.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var _e = be[_];
        _e !== null && (be[$] = null, be[p] = null, be[_] = null, _e(ke)), be[I] = ke;
        return;
      }
      var q = be[p];
      q !== null && (be[$] = null, be[p] = null, be[_] = null, q(j(void 0, !0))), be[P] = !0;
    }), he.on("readable", X.bind(null, be)), be;
  };
  return async_iterator$1 = Z, async_iterator$1;
}
var fromBrowser$1, hasRequiredFromBrowser$1;
function requireFromBrowser$1() {
  return hasRequiredFromBrowser$1 || (hasRequiredFromBrowser$1 = 1, fromBrowser$1 = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser$1;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1)
    return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = q;
  var a;
  q.ReadableState = _e, eventsExports.EventEmitter;
  var u = function(N, re) {
    return N.listeners(re).length;
  }, c = streamBrowser$1, l = require$$0$2.Buffer, v = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(ae) {
    return l.from(ae);
  }
  function _(ae) {
    return l.isBuffer(ae) || ae instanceof v;
  }
  var I = util$4, P;
  I && I.debuglog ? P = I.debuglog("stream") : P = function() {
  };
  var $ = requireBuffer_list$1(), F = destroy_1$1, H = state$4, j = H.getHighWaterMark, ee = errorsBrowser$1.codes, X = ee.ERR_INVALID_ARG_TYPE, ie = ee.ERR_STREAM_PUSH_AFTER_EOF, Q = ee.ERR_METHOD_NOT_IMPLEMENTED, ne = ee.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Z, de, he;
  inherits_browserExports(q, c);
  var pe = F.errorOrDestroy, be = ["error", "close", "destroy", "pause", "resume"];
  function ke(ae, N, re) {
    if (typeof ae.prependListener == "function")
      return ae.prependListener(N, re);
    !ae._events || !ae._events[N] ? ae.on(N, re) : Array.isArray(ae._events[N]) ? ae._events[N].unshift(re) : ae._events[N] = [re, ae._events[N]];
  }
  function _e(ae, N, re) {
    a = a || require_stream_duplex$1(), ae = ae || {}, typeof re != "boolean" && (re = N instanceof a), this.objectMode = !!ae.objectMode, re && (this.objectMode = this.objectMode || !!ae.readableObjectMode), this.highWaterMark = j(this, ae, "readableHighWaterMark", re), this.buffer = new $(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = ae.emitClose !== !1, this.autoDestroy = !!ae.autoDestroy, this.destroyed = !1, this.defaultEncoding = ae.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, ae.encoding && (Z || (Z = string_decoder.StringDecoder), this.decoder = new Z(ae.encoding), this.encoding = ae.encoding);
  }
  function q(ae) {
    if (a = a || require_stream_duplex$1(), !(this instanceof q))
      return new q(ae);
    var N = this instanceof a;
    this._readableState = new _e(ae, this, N), this.readable = !0, ae && (typeof ae.read == "function" && (this._read = ae.read), typeof ae.destroy == "function" && (this._destroy = ae.destroy)), c.call(this);
  }
  Object.defineProperty(q.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(N) {
      this._readableState && (this._readableState.destroyed = N);
    }
  }), q.prototype.destroy = F.destroy, q.prototype._undestroy = F.undestroy, q.prototype._destroy = function(ae, N) {
    N(ae);
  }, q.prototype.push = function(ae, N) {
    var re = this._readableState, le;
    return re.objectMode ? le = !0 : typeof ae == "string" && (N = N || re.defaultEncoding, N !== re.encoding && (ae = l.from(ae, N), N = ""), le = !0), z(this, ae, N, !1, le);
  }, q.prototype.unshift = function(ae) {
    return z(this, ae, null, !0, !1);
  };
  function z(ae, N, re, le, Ne) {
    P("readableAddChunk", N);
    var Oe = ae._readableState;
    if (N === null)
      Oe.reading = !1, A(ae, Oe);
    else {
      var qe;
      if (Ne || (qe = b(Oe, N)), qe)
        pe(ae, qe);
      else if (Oe.objectMode || N && N.length > 0)
        if (typeof N != "string" && !Oe.objectMode && Object.getPrototypeOf(N) !== l.prototype && (N = p(N)), le)
          Oe.endEmitted ? pe(ae, new ne()) : C(ae, Oe, N, !0);
        else if (Oe.ended)
          pe(ae, new ie());
        else {
          if (Oe.destroyed)
            return !1;
          Oe.reading = !1, Oe.decoder && !re ? (N = Oe.decoder.write(N), Oe.objectMode || N.length !== 0 ? C(ae, Oe, N, !1) : B(ae, Oe)) : C(ae, Oe, N, !1);
        }
      else
        le || (Oe.reading = !1, B(ae, Oe));
    }
    return !Oe.ended && (Oe.length < Oe.highWaterMark || Oe.length === 0);
  }
  function C(ae, N, re, le) {
    N.flowing && N.length === 0 && !N.sync ? (N.awaitDrain = 0, ae.emit("data", re)) : (N.length += N.objectMode ? 1 : re.length, le ? N.buffer.unshift(re) : N.buffer.push(re), N.needReadable && x(ae)), B(ae, N);
  }
  function b(ae, N) {
    var re;
    return !_(N) && typeof N != "string" && N !== void 0 && !ae.objectMode && (re = new X("chunk", ["string", "Buffer", "Uint8Array"], N)), re;
  }
  q.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, q.prototype.setEncoding = function(ae) {
    Z || (Z = string_decoder.StringDecoder);
    var N = new Z(ae);
    this._readableState.decoder = N, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var re = this._readableState.buffer.head, le = ""; re !== null; )
      le += N.write(re.data), re = re.next;
    return this._readableState.buffer.clear(), le !== "" && this._readableState.buffer.push(le), this._readableState.length = le.length, this;
  };
  var E = 1073741824;
  function k(ae) {
    return ae >= E ? ae = E : (ae--, ae |= ae >>> 1, ae |= ae >>> 2, ae |= ae >>> 4, ae |= ae >>> 8, ae |= ae >>> 16, ae++), ae;
  }
  function O(ae, N) {
    return ae <= 0 || N.length === 0 && N.ended ? 0 : N.objectMode ? 1 : ae !== ae ? N.flowing && N.length ? N.buffer.head.data.length : N.length : (ae > N.highWaterMark && (N.highWaterMark = k(ae)), ae <= N.length ? ae : N.ended ? N.length : (N.needReadable = !0, 0));
  }
  q.prototype.read = function(ae) {
    P("read", ae), ae = parseInt(ae, 10);
    var N = this._readableState, re = ae;
    if (ae !== 0 && (N.emittedReadable = !1), ae === 0 && N.needReadable && ((N.highWaterMark !== 0 ? N.length >= N.highWaterMark : N.length > 0) || N.ended))
      return P("read: emitReadable", N.length, N.ended), N.length === 0 && N.ended ? Me(this) : x(this), null;
    if (ae = O(ae, N), ae === 0 && N.ended)
      return N.length === 0 && Me(this), null;
    var le = N.needReadable;
    P("need readable", le), (N.length === 0 || N.length - ae < N.highWaterMark) && (le = !0, P("length less than watermark", le)), N.ended || N.reading ? (le = !1, P("reading or ended", le)) : le && (P("do read"), N.reading = !0, N.sync = !0, N.length === 0 && (N.needReadable = !0), this._read(N.highWaterMark), N.sync = !1, N.reading || (ae = O(re, N)));
    var Ne;
    return ae > 0 ? Ne = fe(ae, N) : Ne = null, Ne === null ? (N.needReadable = N.length <= N.highWaterMark, ae = 0) : (N.length -= ae, N.awaitDrain = 0), N.length === 0 && (N.ended || (N.needReadable = !0), re !== ae && N.ended && Me(this)), Ne !== null && this.emit("data", Ne), Ne;
  };
  function A(ae, N) {
    if (P("onEofChunk"), !N.ended) {
      if (N.decoder) {
        var re = N.decoder.end();
        re && re.length && (N.buffer.push(re), N.length += N.objectMode ? 1 : re.length);
      }
      N.ended = !0, N.sync ? x(ae) : (N.needReadable = !1, N.emittedReadable || (N.emittedReadable = !0, Y(ae)));
    }
  }
  function x(ae) {
    var N = ae._readableState;
    P("emitReadable", N.needReadable, N.emittedReadable), N.needReadable = !1, N.emittedReadable || (P("emitReadable", N.flowing), N.emittedReadable = !0, process$1.nextTick(Y, ae));
  }
  function Y(ae) {
    var N = ae._readableState;
    P("emitReadable_", N.destroyed, N.length, N.ended), !N.destroyed && (N.length || N.ended) && (ae.emit("readable"), N.emittedReadable = !1), N.needReadable = !N.flowing && !N.ended && N.length <= N.highWaterMark, ye(ae);
  }
  function B(ae, N) {
    N.readingMore || (N.readingMore = !0, process$1.nextTick(T, ae, N));
  }
  function T(ae, N) {
    for (; !N.reading && !N.ended && (N.length < N.highWaterMark || N.flowing && N.length === 0); ) {
      var re = N.length;
      if (P("maybeReadMore read 0"), ae.read(0), re === N.length)
        break;
    }
    N.readingMore = !1;
  }
  q.prototype._read = function(ae) {
    pe(this, new Q("_read()"));
  }, q.prototype.pipe = function(ae, N) {
    var re = this, le = this._readableState;
    switch (le.pipesCount) {
      case 0:
        le.pipes = ae;
        break;
      case 1:
        le.pipes = [le.pipes, ae];
        break;
      default:
        le.pipes.push(ae);
        break;
    }
    le.pipesCount += 1, P("pipe count=%d opts=%j", le.pipesCount, N);
    var Ne = (!N || N.end !== !1) && ae !== process$1.stdout && ae !== process$1.stderr, Oe = Ne ? je : We;
    le.endEmitted ? process$1.nextTick(Oe) : re.once("end", Oe), ae.on("unpipe", qe);
    function qe(Re, J) {
      P("onunpipe"), Re === re && J && J.hasUnpiped === !1 && (J.hasUnpiped = !0, Xe());
    }
    function je() {
      P("onend"), ae.end();
    }
    var Fe = D(re);
    ae.on("drain", Fe);
    var yt = !1;
    function Xe() {
      P("cleanup"), ae.removeListener("close", ge), ae.removeListener("finish", Te), ae.removeListener("drain", Fe), ae.removeListener("error", V), ae.removeListener("unpipe", qe), re.removeListener("end", je), re.removeListener("end", We), re.removeListener("data", Ge), yt = !0, le.awaitDrain && (!ae._writableState || ae._writableState.needDrain) && Fe();
    }
    re.on("data", Ge);
    function Ge(Re) {
      P("ondata");
      var J = ae.write(Re);
      P("dest.write", J), J === !1 && ((le.pipesCount === 1 && le.pipes === ae || le.pipesCount > 1 && xe(le.pipes, ae) !== -1) && !yt && (P("false write response, pause", le.awaitDrain), le.awaitDrain++), re.pause());
    }
    function V(Re) {
      P("onerror", Re), We(), ae.removeListener("error", V), u(ae, "error") === 0 && pe(ae, Re);
    }
    ke(ae, "error", V);
    function ge() {
      ae.removeListener("finish", Te), We();
    }
    ae.once("close", ge);
    function Te() {
      P("onfinish"), ae.removeListener("close", ge), We();
    }
    ae.once("finish", Te);
    function We() {
      P("unpipe"), re.unpipe(ae);
    }
    return ae.emit("pipe", re), le.flowing || (P("pipe resume"), re.resume()), ae;
  };
  function D(ae) {
    return function() {
      var re = ae._readableState;
      P("pipeOnDrain", re.awaitDrain), re.awaitDrain && re.awaitDrain--, re.awaitDrain === 0 && u(ae, "data") && (re.flowing = !0, ye(ae));
    };
  }
  q.prototype.unpipe = function(ae) {
    var N = this._readableState, re = {
      hasUnpiped: !1
    };
    if (N.pipesCount === 0)
      return this;
    if (N.pipesCount === 1)
      return ae && ae !== N.pipes ? this : (ae || (ae = N.pipes), N.pipes = null, N.pipesCount = 0, N.flowing = !1, ae && ae.emit("unpipe", this, re), this);
    if (!ae) {
      var le = N.pipes, Ne = N.pipesCount;
      N.pipes = null, N.pipesCount = 0, N.flowing = !1;
      for (var Oe = 0; Oe < Ne; Oe++)
        le[Oe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var qe = xe(N.pipes, ae);
    return qe === -1 ? this : (N.pipes.splice(qe, 1), N.pipesCount -= 1, N.pipesCount === 1 && (N.pipes = N.pipes[0]), ae.emit("unpipe", this, re), this);
  }, q.prototype.on = function(ae, N) {
    var re = c.prototype.on.call(this, ae, N), le = this._readableState;
    return ae === "data" ? (le.readableListening = this.listenerCount("readable") > 0, le.flowing !== !1 && this.resume()) : ae === "readable" && !le.endEmitted && !le.readableListening && (le.readableListening = le.needReadable = !0, le.flowing = !1, le.emittedReadable = !1, P("on readable", le.length, le.reading), le.length ? x(this) : le.reading || process$1.nextTick(me, this)), re;
  }, q.prototype.addListener = q.prototype.on, q.prototype.removeListener = function(ae, N) {
    var re = c.prototype.removeListener.call(this, ae, N);
    return ae === "readable" && process$1.nextTick(te, this), re;
  }, q.prototype.removeAllListeners = function(ae) {
    var N = c.prototype.removeAllListeners.apply(this, arguments);
    return (ae === "readable" || ae === void 0) && process$1.nextTick(te, this), N;
  };
  function te(ae) {
    var N = ae._readableState;
    N.readableListening = ae.listenerCount("readable") > 0, N.resumeScheduled && !N.paused ? N.flowing = !0 : ae.listenerCount("data") > 0 && ae.resume();
  }
  function me(ae) {
    P("readable nexttick read 0"), ae.read(0);
  }
  q.prototype.resume = function() {
    var ae = this._readableState;
    return ae.flowing || (P("resume"), ae.flowing = !ae.readableListening, Ie(this, ae)), ae.paused = !1, this;
  };
  function Ie(ae, N) {
    N.resumeScheduled || (N.resumeScheduled = !0, process$1.nextTick($e, ae, N));
  }
  function $e(ae, N) {
    P("resume", N.reading), N.reading || ae.read(0), N.resumeScheduled = !1, ae.emit("resume"), ye(ae), N.flowing && !N.reading && ae.read(0);
  }
  q.prototype.pause = function() {
    return P("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (P("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ye(ae) {
    var N = ae._readableState;
    for (P("flow", N.flowing); N.flowing && ae.read() !== null; )
      ;
  }
  q.prototype.wrap = function(ae) {
    var N = this, re = this._readableState, le = !1;
    ae.on("end", function() {
      if (P("wrapped end"), re.decoder && !re.ended) {
        var qe = re.decoder.end();
        qe && qe.length && N.push(qe);
      }
      N.push(null);
    }), ae.on("data", function(qe) {
      if (P("wrapped data"), re.decoder && (qe = re.decoder.write(qe)), !(re.objectMode && qe == null) && !(!re.objectMode && (!qe || !qe.length))) {
        var je = N.push(qe);
        je || (le = !0, ae.pause());
      }
    });
    for (var Ne in ae)
      this[Ne] === void 0 && typeof ae[Ne] == "function" && (this[Ne] = /* @__PURE__ */ function(je) {
        return function() {
          return ae[je].apply(ae, arguments);
        };
      }(Ne));
    for (var Oe = 0; Oe < be.length; Oe++)
      ae.on(be[Oe], this.emit.bind(this, be[Oe]));
    return this._read = function(qe) {
      P("wrapped _read", qe), le && (le = !1, ae.resume());
    }, this;
  }, typeof Symbol == "function" && (q.prototype[Symbol.asyncIterator] = function() {
    return de === void 0 && (de = requireAsync_iterator$1()), de(this);
  }), Object.defineProperty(q.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(q.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(q.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(N) {
      this._readableState && (this._readableState.flowing = N);
    }
  }), q._fromList = fe, Object.defineProperty(q.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function fe(ae, N) {
    if (N.length === 0)
      return null;
    var re;
    return N.objectMode ? re = N.buffer.shift() : !ae || ae >= N.length ? (N.decoder ? re = N.buffer.join("") : N.buffer.length === 1 ? re = N.buffer.first() : re = N.buffer.concat(N.length), N.buffer.clear()) : re = N.buffer.consume(ae, N.decoder), re;
  }
  function Me(ae) {
    var N = ae._readableState;
    P("endReadable", N.endEmitted), N.endEmitted || (N.ended = !0, process$1.nextTick(Ae, N, ae));
  }
  function Ae(ae, N) {
    if (P("endReadableNT", ae.endEmitted, ae.length), !ae.endEmitted && ae.length === 0 && (ae.endEmitted = !0, N.readable = !1, N.emit("end"), ae.autoDestroy)) {
      var re = N._writableState;
      (!re || re.autoDestroy && re.finished) && N.destroy();
    }
  }
  typeof Symbol == "function" && (q.from = function(ae, N) {
    return he === void 0 && (he = requireFromBrowser$1()), he(q, ae, N);
  });
  function xe(ae, N) {
    for (var re = 0, le = ae.length; re < le; re++)
      if (ae[re] === N)
        return re;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1 = Transform$9, _require$codes$3 = errorsBrowser$1.codes, ERR_METHOD_NOT_IMPLEMENTED$1 = _require$codes$3.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK$1 = _require$codes$3.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING$1 = _require$codes$3.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0$1 = _require$codes$3.ERR_TRANSFORM_WITH_LENGTH_0, Duplex$1 = require_stream_duplex$1();
inherits_browserExports(Transform$9, Duplex$1);
function afterTransform$1(a, u) {
  var c = this._transformState;
  c.transforming = !1;
  var l = c.writecb;
  if (l === null)
    return this.emit("error", new ERR_MULTIPLE_CALLBACK$1());
  c.writechunk = null, c.writecb = null, u != null && this.push(u), l(a);
  var v = this._readableState;
  v.reading = !1, (v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
}
function Transform$9(a) {
  if (!(this instanceof Transform$9))
    return new Transform$9(a);
  Duplex$1.call(this, a), this._transformState = {
    afterTransform: afterTransform$1.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, a && (typeof a.transform == "function" && (this._transform = a.transform), typeof a.flush == "function" && (this._flush = a.flush)), this.on("prefinish", prefinish$1);
}
function prefinish$1() {
  var a = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(u, c) {
    done$1(a, u, c);
  }) : done$1(this, null, null);
}
Transform$9.prototype.push = function(a, u) {
  return this._transformState.needTransform = !1, Duplex$1.prototype.push.call(this, a, u);
};
Transform$9.prototype._transform = function(a, u, c) {
  c(new ERR_METHOD_NOT_IMPLEMENTED$1("_transform()"));
};
Transform$9.prototype._write = function(a, u, c) {
  var l = this._transformState;
  if (l.writecb = c, l.writechunk = a, l.writeencoding = u, !l.transforming) {
    var v = this._readableState;
    (l.needTransform || v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
  }
};
Transform$9.prototype._read = function(a) {
  var u = this._transformState;
  u.writechunk !== null && !u.transforming ? (u.transforming = !0, this._transform(u.writechunk, u.writeencoding, u.afterTransform)) : u.needTransform = !0;
};
Transform$9.prototype._destroy = function(a, u) {
  Duplex$1.prototype._destroy.call(this, a, function(c) {
    u(c);
  });
};
function done$1(a, u, c) {
  if (u)
    return a.emit("error", u);
  if (c != null && a.push(c), a._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0$1();
  if (a._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING$1();
  return a.push(null);
}
var _stream_passthrough$1 = PassThrough$1, Transform$8 = _stream_transform$1;
inherits_browserExports(PassThrough$1, Transform$8);
function PassThrough$1(a) {
  if (!(this instanceof PassThrough$1))
    return new PassThrough$1(a);
  Transform$8.call(this, a);
}
PassThrough$1.prototype._transform = function(a, u, c) {
  c(null, a);
};
var eos$2;
function once$4(a) {
  var u = !1;
  return function() {
    u || (u = !0, a.apply(void 0, arguments));
  };
}
var _require$codes$2 = errorsBrowser$1.codes, ERR_MISSING_ARGS$1 = _require$codes$2.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED$1 = _require$codes$2.ERR_STREAM_DESTROYED;
function noop$3(a) {
  if (a)
    throw a;
}
function isRequest$2(a) {
  return a.setHeader && typeof a.abort == "function";
}
function destroyer$1(a, u, c, l) {
  l = once$4(l);
  var v = !1;
  a.on("close", function() {
    v = !0;
  }), eos$2 === void 0 && (eos$2 = endOfStream$1), eos$2(a, {
    readable: u,
    writable: c
  }, function(_) {
    if (_)
      return l(_);
    v = !0, l();
  });
  var p = !1;
  return function(_) {
    if (!v && !p) {
      if (p = !0, isRequest$2(a))
        return a.abort();
      if (typeof a.destroy == "function")
        return a.destroy();
      l(_ || new ERR_STREAM_DESTROYED$1("pipe"));
    }
  };
}
function call$1(a) {
  a();
}
function pipe$1(a, u) {
  return a.pipe(u);
}
function popCallback$1(a) {
  return !a.length || typeof a[a.length - 1] != "function" ? noop$3 : a.pop();
}
function pipeline$1() {
  for (var a = arguments.length, u = new Array(a), c = 0; c < a; c++)
    u[c] = arguments[c];
  var l = popCallback$1(u);
  if (Array.isArray(u[0]) && (u = u[0]), u.length < 2)
    throw new ERR_MISSING_ARGS$1("streams");
  var v, p = u.map(function(_, I) {
    var P = I < u.length - 1, $ = I > 0;
    return destroyer$1(_, P, $, function(F) {
      v || (v = F), F && p.forEach(call$1), !P && (p.forEach(call$1), l(v));
    });
  });
  return u.reduce(pipe$1);
}
var pipeline_1$1 = pipeline$1;
(function(a, u) {
  u = a.exports = require_stream_readable$1(), u.Stream = u, u.Readable = u, u.Writable = require_stream_writable$1(), u.Duplex = require_stream_duplex$1(), u.Transform = _stream_transform$1, u.PassThrough = _stream_passthrough$1, u.finished = endOfStream$1, u.pipeline = pipeline_1$1;
})(readableBrowser$1, readableBrowser$1.exports);
var readableBrowserExports$1 = readableBrowser$1.exports, Buffer$H = safeBufferExports$1.Buffer, Transform$7 = readableBrowserExports$1.Transform, inherits$u = inherits_browserExports;
function throwIfNotStringOrBuffer(a, u) {
  if (!Buffer$H.isBuffer(a) && typeof a != "string")
    throw new TypeError(u + " must be a string or a buffer");
}
function HashBase$2(a) {
  Transform$7.call(this), this._block = Buffer$H.allocUnsafe(a), this._blockSize = a, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$u(HashBase$2, Transform$7);
HashBase$2.prototype._transform = function(a, u, c) {
  var l = null;
  try {
    this.update(a, u);
  } catch (v) {
    l = v;
  }
  c(l);
};
HashBase$2.prototype._flush = function(a) {
  var u = null;
  try {
    this.push(this.digest());
  } catch (c) {
    u = c;
  }
  a(u);
};
HashBase$2.prototype.update = function(a, u) {
  if (throwIfNotStringOrBuffer(a, "Data"), this._finalized)
    throw new Error("Digest already called");
  Buffer$H.isBuffer(a) || (a = Buffer$H.from(a, u));
  for (var c = this._block, l = 0; this._blockOffset + a.length - l >= this._blockSize; ) {
    for (var v = this._blockOffset; v < this._blockSize; )
      c[v++] = a[l++];
    this._update(), this._blockOffset = 0;
  }
  for (; l < a.length; )
    c[this._blockOffset++] = a[l++];
  for (var p = 0, _ = a.length * 8; _ > 0; ++p)
    this._length[p] += _, _ = this._length[p] / 4294967296 | 0, _ > 0 && (this._length[p] -= 4294967296 * _);
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(a) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = !0;
  var u = this._digest();
  a !== void 0 && (u = u.toString(a)), this._block.fill(0), this._blockOffset = 0;
  for (var c = 0; c < 4; ++c)
    this._length[c] = 0;
  return u;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2, inherits$t = inherits_browserExports, HashBase$1 = hashBase, Buffer$G = safeBufferExports$3.Buffer, ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$t(MD5$3, HashBase$1);
MD5$3.prototype._update = function() {
  for (var a = ARRAY16$1, u = 0; u < 16; ++u)
    a[u] = this._block.readInt32LE(u * 4);
  var c = this._a, l = this._b, v = this._c, p = this._d;
  c = fnF(c, l, v, p, a[0], 3614090360, 7), p = fnF(p, c, l, v, a[1], 3905402710, 12), v = fnF(v, p, c, l, a[2], 606105819, 17), l = fnF(l, v, p, c, a[3], 3250441966, 22), c = fnF(c, l, v, p, a[4], 4118548399, 7), p = fnF(p, c, l, v, a[5], 1200080426, 12), v = fnF(v, p, c, l, a[6], 2821735955, 17), l = fnF(l, v, p, c, a[7], 4249261313, 22), c = fnF(c, l, v, p, a[8], 1770035416, 7), p = fnF(p, c, l, v, a[9], 2336552879, 12), v = fnF(v, p, c, l, a[10], 4294925233, 17), l = fnF(l, v, p, c, a[11], 2304563134, 22), c = fnF(c, l, v, p, a[12], 1804603682, 7), p = fnF(p, c, l, v, a[13], 4254626195, 12), v = fnF(v, p, c, l, a[14], 2792965006, 17), l = fnF(l, v, p, c, a[15], 1236535329, 22), c = fnG(c, l, v, p, a[1], 4129170786, 5), p = fnG(p, c, l, v, a[6], 3225465664, 9), v = fnG(v, p, c, l, a[11], 643717713, 14), l = fnG(l, v, p, c, a[0], 3921069994, 20), c = fnG(c, l, v, p, a[5], 3593408605, 5), p = fnG(p, c, l, v, a[10], 38016083, 9), v = fnG(v, p, c, l, a[15], 3634488961, 14), l = fnG(l, v, p, c, a[4], 3889429448, 20), c = fnG(c, l, v, p, a[9], 568446438, 5), p = fnG(p, c, l, v, a[14], 3275163606, 9), v = fnG(v, p, c, l, a[3], 4107603335, 14), l = fnG(l, v, p, c, a[8], 1163531501, 20), c = fnG(c, l, v, p, a[13], 2850285829, 5), p = fnG(p, c, l, v, a[2], 4243563512, 9), v = fnG(v, p, c, l, a[7], 1735328473, 14), l = fnG(l, v, p, c, a[12], 2368359562, 20), c = fnH(c, l, v, p, a[5], 4294588738, 4), p = fnH(p, c, l, v, a[8], 2272392833, 11), v = fnH(v, p, c, l, a[11], 1839030562, 16), l = fnH(l, v, p, c, a[14], 4259657740, 23), c = fnH(c, l, v, p, a[1], 2763975236, 4), p = fnH(p, c, l, v, a[4], 1272893353, 11), v = fnH(v, p, c, l, a[7], 4139469664, 16), l = fnH(l, v, p, c, a[10], 3200236656, 23), c = fnH(c, l, v, p, a[13], 681279174, 4), p = fnH(p, c, l, v, a[0], 3936430074, 11), v = fnH(v, p, c, l, a[3], 3572445317, 16), l = fnH(l, v, p, c, a[6], 76029189, 23), c = fnH(c, l, v, p, a[9], 3654602809, 4), p = fnH(p, c, l, v, a[12], 3873151461, 11), v = fnH(v, p, c, l, a[15], 530742520, 16), l = fnH(l, v, p, c, a[2], 3299628645, 23), c = fnI(c, l, v, p, a[0], 4096336452, 6), p = fnI(p, c, l, v, a[7], 1126891415, 10), v = fnI(v, p, c, l, a[14], 2878612391, 15), l = fnI(l, v, p, c, a[5], 4237533241, 21), c = fnI(c, l, v, p, a[12], 1700485571, 6), p = fnI(p, c, l, v, a[3], 2399980690, 10), v = fnI(v, p, c, l, a[10], 4293915773, 15), l = fnI(l, v, p, c, a[1], 2240044497, 21), c = fnI(c, l, v, p, a[8], 1873313359, 6), p = fnI(p, c, l, v, a[15], 4264355552, 10), v = fnI(v, p, c, l, a[6], 2734768916, 15), l = fnI(l, v, p, c, a[13], 1309151649, 21), c = fnI(c, l, v, p, a[4], 4149444226, 6), p = fnI(p, c, l, v, a[11], 3174756917, 10), v = fnI(v, p, c, l, a[2], 718787259, 15), l = fnI(l, v, p, c, a[9], 3951481745, 21), this._a = this._a + c | 0, this._b = this._b + l | 0, this._c = this._c + v | 0, this._d = this._d + p | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var a = Buffer$G.allocUnsafe(16);
  return a.writeInt32LE(this._a, 0), a.writeInt32LE(this._b, 4), a.writeInt32LE(this._c, 8), a.writeInt32LE(this._d, 12), a;
};
function rotl$1(a, u) {
  return a << u | a >>> 32 - u;
}
function fnF(a, u, c, l, v, p, _) {
  return rotl$1(a + (u & c | ~u & l) + v + p | 0, _) + u | 0;
}
function fnG(a, u, c, l, v, p, _) {
  return rotl$1(a + (u & l | c & ~l) + v + p | 0, _) + u | 0;
}
function fnH(a, u, c, l, v, p, _) {
  return rotl$1(a + (u ^ c ^ l) + v + p | 0, _) + u | 0;
}
function fnI(a, u, c, l, v, p, _) {
  return rotl$1(a + (c ^ (u | ~l)) + v + p | 0, _) + u | 0;
}
var md5_js = MD5$3, Buffer$F = require$$0$2.Buffer, inherits$s = inherits_browserExports, HashBase = hashBase, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$4() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$s(RIPEMD160$4, HashBase);
RIPEMD160$4.prototype._update = function() {
  for (var a = ARRAY16, u = 0; u < 16; ++u)
    a[u] = this._block.readInt32LE(u * 4);
  for (var c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, I = this._a | 0, P = this._b | 0, $ = this._c | 0, F = this._d | 0, H = this._e | 0, j = 0; j < 80; j += 1) {
    var ee, X;
    j < 16 ? (ee = fn1(c, l, v, p, _, a[zl[j]], hl[0], sl[j]), X = fn5(I, P, $, F, H, a[zr[j]], hr[0], sr[j])) : j < 32 ? (ee = fn2(c, l, v, p, _, a[zl[j]], hl[1], sl[j]), X = fn4(I, P, $, F, H, a[zr[j]], hr[1], sr[j])) : j < 48 ? (ee = fn3(c, l, v, p, _, a[zl[j]], hl[2], sl[j]), X = fn3(I, P, $, F, H, a[zr[j]], hr[2], sr[j])) : j < 64 ? (ee = fn4(c, l, v, p, _, a[zl[j]], hl[3], sl[j]), X = fn2(I, P, $, F, H, a[zr[j]], hr[3], sr[j])) : (ee = fn5(c, l, v, p, _, a[zl[j]], hl[4], sl[j]), X = fn1(I, P, $, F, H, a[zr[j]], hr[4], sr[j])), c = _, _ = p, p = rotl(v, 10), v = l, l = ee, I = H, H = F, F = rotl($, 10), $ = P, P = X;
  }
  var ie = this._b + v + F | 0;
  this._b = this._c + p + H | 0, this._c = this._d + _ + I | 0, this._d = this._e + c + P | 0, this._e = this._a + l + $ | 0, this._a = ie;
};
RIPEMD160$4.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var a = Buffer$F.alloc ? Buffer$F.alloc(20) : new Buffer$F(20);
  return a.writeInt32LE(this._a, 0), a.writeInt32LE(this._b, 4), a.writeInt32LE(this._c, 8), a.writeInt32LE(this._d, 12), a.writeInt32LE(this._e, 16), a;
};
function rotl(a, u) {
  return a << u | a >>> 32 - u;
}
function fn1(a, u, c, l, v, p, _, I) {
  return rotl(a + (u ^ c ^ l) + p + _ | 0, I) + v | 0;
}
function fn2(a, u, c, l, v, p, _, I) {
  return rotl(a + (u & c | ~u & l) + p + _ | 0, I) + v | 0;
}
function fn3(a, u, c, l, v, p, _, I) {
  return rotl(a + ((u | ~c) ^ l) + p + _ | 0, I) + v | 0;
}
function fn4(a, u, c, l, v, p, _, I) {
  return rotl(a + (u & l | c & ~l) + p + _ | 0, I) + v | 0;
}
function fn5(a, u, c, l, v, p, _, I) {
  return rotl(a + (u ^ (c | ~l)) + p + _ | 0, I) + v | 0;
}
var ripemd160 = RIPEMD160$4, sha_js = { exports: {} }, Buffer$E = safeBufferExports$3.Buffer;
function Hash$7(a, u) {
  this._block = Buffer$E.alloc(a), this._finalSize = u, this._blockSize = a, this._len = 0;
}
Hash$7.prototype.update = function(a, u) {
  typeof a == "string" && (u = u || "utf8", a = Buffer$E.from(a, u));
  for (var c = this._block, l = this._blockSize, v = a.length, p = this._len, _ = 0; _ < v; ) {
    for (var I = p % l, P = Math.min(v - _, l - I), $ = 0; $ < P; $++)
      c[I + $] = a[_ + $];
    p += P, _ += P, p % l === 0 && this._update(c);
  }
  return this._len += v, this;
};
Hash$7.prototype.digest = function(a) {
  var u = this._len % this._blockSize;
  this._block[u] = 128, this._block.fill(0, u + 1), u >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var c = this._len * 8;
  if (c <= 4294967295)
    this._block.writeUInt32BE(c, this._blockSize - 4);
  else {
    var l = (c & 4294967295) >>> 0, v = (c - l) / 4294967296;
    this._block.writeUInt32BE(v, this._blockSize - 8), this._block.writeUInt32BE(l, this._blockSize - 4);
  }
  this._update(this._block);
  var p = this._hash();
  return a ? p.toString(a) : p;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$3 = Hash$7, inherits$r = inherits_browserExports, Hash$6 = hash$3, Buffer$D = safeBufferExports$3.Buffer, K$4 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$5 = new Array(80);
function Sha() {
  this.init(), this._w = W$5, Hash$6.call(this, 64, 56);
}
inherits$r(Sha, Hash$6);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(a) {
  return a << 5 | a >>> 27;
}
function rotl30$1(a) {
  return a << 30 | a >>> 2;
}
function ft$1(a, u, c, l) {
  return a === 0 ? u & c | ~u & l : a === 2 ? u & c | u & l | c & l : u ^ c ^ l;
}
Sha.prototype._update = function(a) {
  for (var u = this._w, c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, I = 0; I < 16; ++I)
    u[I] = a.readInt32BE(I * 4);
  for (; I < 80; ++I)
    u[I] = u[I - 3] ^ u[I - 8] ^ u[I - 14] ^ u[I - 16];
  for (var P = 0; P < 80; ++P) {
    var $ = ~~(P / 20), F = rotl5$1(c) + ft$1($, l, v, p) + _ + u[P] + K$4[$] | 0;
    _ = p, p = v, v = rotl30$1(l), l = c, c = F;
  }
  this._a = c + this._a | 0, this._b = l + this._b | 0, this._c = v + this._c | 0, this._d = p + this._d | 0, this._e = _ + this._e | 0;
};
Sha.prototype._hash = function() {
  var a = Buffer$D.allocUnsafe(20);
  return a.writeInt32BE(this._a | 0, 0), a.writeInt32BE(this._b | 0, 4), a.writeInt32BE(this._c | 0, 8), a.writeInt32BE(this._d | 0, 12), a.writeInt32BE(this._e | 0, 16), a;
};
var sha$4 = Sha, inherits$q = inherits_browserExports, Hash$5 = hash$3, Buffer$C = safeBufferExports$3.Buffer, K$3 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$4 = new Array(80);
function Sha1() {
  this.init(), this._w = W$4, Hash$5.call(this, 64, 56);
}
inherits$q(Sha1, Hash$5);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(a) {
  return a << 1 | a >>> 31;
}
function rotl5(a) {
  return a << 5 | a >>> 27;
}
function rotl30(a) {
  return a << 30 | a >>> 2;
}
function ft(a, u, c, l) {
  return a === 0 ? u & c | ~u & l : a === 2 ? u & c | u & l | c & l : u ^ c ^ l;
}
Sha1.prototype._update = function(a) {
  for (var u = this._w, c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, I = 0; I < 16; ++I)
    u[I] = a.readInt32BE(I * 4);
  for (; I < 80; ++I)
    u[I] = rotl1(u[I - 3] ^ u[I - 8] ^ u[I - 14] ^ u[I - 16]);
  for (var P = 0; P < 80; ++P) {
    var $ = ~~(P / 20), F = rotl5(c) + ft($, l, v, p) + _ + u[P] + K$3[$] | 0;
    _ = p, p = v, v = rotl30(l), l = c, c = F;
  }
  this._a = c + this._a | 0, this._b = l + this._b | 0, this._c = v + this._c | 0, this._d = p + this._d | 0, this._e = _ + this._e | 0;
};
Sha1.prototype._hash = function() {
  var a = Buffer$C.allocUnsafe(20);
  return a.writeInt32BE(this._a | 0, 0), a.writeInt32BE(this._b | 0, 4), a.writeInt32BE(this._c | 0, 8), a.writeInt32BE(this._d | 0, 12), a.writeInt32BE(this._e | 0, 16), a;
};
var sha1 = Sha1, inherits$p = inherits_browserExports, Hash$4 = hash$3, Buffer$B = safeBufferExports$3.Buffer, K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$3 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$3, Hash$4.call(this, 64, 56);
}
inherits$p(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(a, u, c) {
  return c ^ a & (u ^ c);
}
function maj$1(a, u, c) {
  return a & u | c & (a | u);
}
function sigma0$1(a) {
  return (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
}
function sigma1$1(a) {
  return (a >>> 6 | a << 26) ^ (a >>> 11 | a << 21) ^ (a >>> 25 | a << 7);
}
function gamma0(a) {
  return (a >>> 7 | a << 25) ^ (a >>> 18 | a << 14) ^ a >>> 3;
}
function gamma1(a) {
  return (a >>> 17 | a << 15) ^ (a >>> 19 | a << 13) ^ a >>> 10;
}
Sha256$1.prototype._update = function(a) {
  for (var u = this._w, c = this._a | 0, l = this._b | 0, v = this._c | 0, p = this._d | 0, _ = this._e | 0, I = this._f | 0, P = this._g | 0, $ = this._h | 0, F = 0; F < 16; ++F)
    u[F] = a.readInt32BE(F * 4);
  for (; F < 64; ++F)
    u[F] = gamma1(u[F - 2]) + u[F - 7] + gamma0(u[F - 15]) + u[F - 16] | 0;
  for (var H = 0; H < 64; ++H) {
    var j = $ + sigma1$1(_) + ch(_, I, P) + K$2[H] + u[H] | 0, ee = sigma0$1(c) + maj$1(c, l, v) | 0;
    $ = P, P = I, I = _, _ = p + j | 0, p = v, v = l, l = c, c = j + ee | 0;
  }
  this._a = c + this._a | 0, this._b = l + this._b | 0, this._c = v + this._c | 0, this._d = p + this._d | 0, this._e = _ + this._e | 0, this._f = I + this._f | 0, this._g = P + this._g | 0, this._h = $ + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var a = Buffer$B.allocUnsafe(32);
  return a.writeInt32BE(this._a, 0), a.writeInt32BE(this._b, 4), a.writeInt32BE(this._c, 8), a.writeInt32BE(this._d, 12), a.writeInt32BE(this._e, 16), a.writeInt32BE(this._f, 20), a.writeInt32BE(this._g, 24), a.writeInt32BE(this._h, 28), a;
};
var sha256$1 = Sha256$1, inherits$o = inherits_browserExports, Sha256 = sha256$1, Hash$3 = hash$3, Buffer$A = safeBufferExports$3.Buffer, W$2 = new Array(64);
function Sha224() {
  this.init(), this._w = W$2, Hash$3.call(this, 64, 56);
}
inherits$o(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var a = Buffer$A.allocUnsafe(28);
  return a.writeInt32BE(this._a, 0), a.writeInt32BE(this._b, 4), a.writeInt32BE(this._c, 8), a.writeInt32BE(this._d, 12), a.writeInt32BE(this._e, 16), a.writeInt32BE(this._f, 20), a.writeInt32BE(this._g, 24), a;
};
var sha224$1 = Sha224, inherits$n = inherits_browserExports, Hash$2 = hash$3, Buffer$z = safeBufferExports$3.Buffer, K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$1 = new Array(160);
function Sha512() {
  this.init(), this._w = W$1, Hash$2.call(this, 128, 112);
}
inherits$n(Sha512, Hash$2);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(a, u, c) {
  return c ^ a & (u ^ c);
}
function maj(a, u, c) {
  return a & u | c & (a | u);
}
function sigma0(a, u) {
  return (a >>> 28 | u << 4) ^ (u >>> 2 | a << 30) ^ (u >>> 7 | a << 25);
}
function sigma1(a, u) {
  return (a >>> 14 | u << 18) ^ (a >>> 18 | u << 14) ^ (u >>> 9 | a << 23);
}
function Gamma0(a, u) {
  return (a >>> 1 | u << 31) ^ (a >>> 8 | u << 24) ^ a >>> 7;
}
function Gamma0l(a, u) {
  return (a >>> 1 | u << 31) ^ (a >>> 8 | u << 24) ^ (a >>> 7 | u << 25);
}
function Gamma1(a, u) {
  return (a >>> 19 | u << 13) ^ (u >>> 29 | a << 3) ^ a >>> 6;
}
function Gamma1l(a, u) {
  return (a >>> 19 | u << 13) ^ (u >>> 29 | a << 3) ^ (a >>> 6 | u << 26);
}
function getCarry(a, u) {
  return a >>> 0 < u >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(a) {
  for (var u = this._w, c = this._ah | 0, l = this._bh | 0, v = this._ch | 0, p = this._dh | 0, _ = this._eh | 0, I = this._fh | 0, P = this._gh | 0, $ = this._hh | 0, F = this._al | 0, H = this._bl | 0, j = this._cl | 0, ee = this._dl | 0, X = this._el | 0, ie = this._fl | 0, Q = this._gl | 0, ne = this._hl | 0, Z = 0; Z < 32; Z += 2)
    u[Z] = a.readInt32BE(Z * 4), u[Z + 1] = a.readInt32BE(Z * 4 + 4);
  for (; Z < 160; Z += 2) {
    var de = u[Z - 30], he = u[Z - 15 * 2 + 1], pe = Gamma0(de, he), be = Gamma0l(he, de);
    de = u[Z - 2 * 2], he = u[Z - 2 * 2 + 1];
    var ke = Gamma1(de, he), _e = Gamma1l(he, de), q = u[Z - 7 * 2], z = u[Z - 7 * 2 + 1], C = u[Z - 16 * 2], b = u[Z - 16 * 2 + 1], E = be + z | 0, k = pe + q + getCarry(E, be) | 0;
    E = E + _e | 0, k = k + ke + getCarry(E, _e) | 0, E = E + b | 0, k = k + C + getCarry(E, b) | 0, u[Z] = k, u[Z + 1] = E;
  }
  for (var O = 0; O < 160; O += 2) {
    k = u[O], E = u[O + 1];
    var A = maj(c, l, v), x = maj(F, H, j), Y = sigma0(c, F), B = sigma0(F, c), T = sigma1(_, X), D = sigma1(X, _), te = K$1[O], me = K$1[O + 1], Ie = Ch(_, I, P), $e = Ch(X, ie, Q), ye = ne + D | 0, fe = $ + T + getCarry(ye, ne) | 0;
    ye = ye + $e | 0, fe = fe + Ie + getCarry(ye, $e) | 0, ye = ye + me | 0, fe = fe + te + getCarry(ye, me) | 0, ye = ye + E | 0, fe = fe + k + getCarry(ye, E) | 0;
    var Me = B + x | 0, Ae = Y + A + getCarry(Me, B) | 0;
    $ = P, ne = Q, P = I, Q = ie, I = _, ie = X, X = ee + ye | 0, _ = p + fe + getCarry(X, ee) | 0, p = v, ee = j, v = l, j = H, l = c, H = F, F = ye + Me | 0, c = fe + Ae + getCarry(F, ye) | 0;
  }
  this._al = this._al + F | 0, this._bl = this._bl + H | 0, this._cl = this._cl + j | 0, this._dl = this._dl + ee | 0, this._el = this._el + X | 0, this._fl = this._fl + ie | 0, this._gl = this._gl + Q | 0, this._hl = this._hl + ne | 0, this._ah = this._ah + c + getCarry(this._al, F) | 0, this._bh = this._bh + l + getCarry(this._bl, H) | 0, this._ch = this._ch + v + getCarry(this._cl, j) | 0, this._dh = this._dh + p + getCarry(this._dl, ee) | 0, this._eh = this._eh + _ + getCarry(this._el, X) | 0, this._fh = this._fh + I + getCarry(this._fl, ie) | 0, this._gh = this._gh + P + getCarry(this._gl, Q) | 0, this._hh = this._hh + $ + getCarry(this._hl, ne) | 0;
};
Sha512.prototype._hash = function() {
  var a = Buffer$z.allocUnsafe(64);
  function u(c, l, v) {
    a.writeInt32BE(c, v), a.writeInt32BE(l, v + 4);
  }
  return u(this._ah, this._al, 0), u(this._bh, this._bl, 8), u(this._ch, this._cl, 16), u(this._dh, this._dl, 24), u(this._eh, this._el, 32), u(this._fh, this._fl, 40), u(this._gh, this._gl, 48), u(this._hh, this._hl, 56), a;
};
var sha512$1 = Sha512, inherits$m = inherits_browserExports, SHA512$2 = sha512$1, Hash$1 = hash$3, Buffer$y = safeBufferExports$3.Buffer, W = new Array(160);
function Sha384() {
  this.init(), this._w = W, Hash$1.call(this, 128, 112);
}
inherits$m(Sha384, SHA512$2);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var a = Buffer$y.allocUnsafe(48);
  function u(c, l, v) {
    a.writeInt32BE(c, v), a.writeInt32BE(l, v + 4);
  }
  return u(this._ah, this._al, 0), u(this._bh, this._bl, 8), u(this._ch, this._cl, 16), u(this._dh, this._dl, 24), u(this._eh, this._el, 32), u(this._fh, this._fl, 40), a;
};
var sha384$1 = Sha384, exports$1 = sha_js.exports = function a(u) {
  u = u.toLowerCase();
  var c = exports$1[u];
  if (!c)
    throw new Error(u + " is not supported (we accept pull requests)");
  return new c();
};
exports$1.sha = sha$4;
exports$1.sha1 = sha1;
exports$1.sha224 = sha224$1;
exports$1.sha256 = sha256$1;
exports$1.sha384 = sha384$1;
exports$1.sha512 = sha512$1;
var sha_jsExports = sha_js.exports, Buffer$x = safeBufferExports$3.Buffer, Transform$6 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$l = inherits_browserExports;
function CipherBase$1(a) {
  Transform$6.call(this), this.hashMode = typeof a == "string", this.hashMode ? this[a] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$l(CipherBase$1, Transform$6);
CipherBase$1.prototype.update = function(a, u, c) {
  typeof a == "string" && (a = Buffer$x.from(a, u));
  var l = this._update(a);
  return this.hashMode ? this : (c && (l = this._toString(l, c)), l);
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(a, u, c) {
  var l;
  try {
    this.hashMode ? this._update(a) : this.push(this._update(a));
  } catch (v) {
    l = v;
  } finally {
    c(l);
  }
};
CipherBase$1.prototype._flush = function(a) {
  var u;
  try {
    this.push(this.__final());
  } catch (c) {
    u = c;
  }
  a(u);
};
CipherBase$1.prototype._finalOrDigest = function(a) {
  var u = this.__final() || Buffer$x.alloc(0);
  return a && (u = this._toString(u, a, !0)), u;
};
CipherBase$1.prototype._toString = function(a, u, c) {
  if (this._decoder || (this._decoder = new StringDecoder(u), this._encoding = u), this._encoding !== u)
    throw new Error("can't switch encodings");
  var l = this._decoder.write(a);
  return c && (l += this._decoder.end()), l;
};
var cipherBase = CipherBase$1, inherits$k = inherits_browserExports, MD5$2 = md5_js, RIPEMD160$3 = ripemd160, sha$3 = sha_jsExports, Base$5 = cipherBase;
function Hash(a) {
  Base$5.call(this, "digest"), this._hash = a;
}
inherits$k(Hash, Base$5);
Hash.prototype._update = function(a) {
  this._hash.update(a);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser$a = function a(u) {
  return u = u.toLowerCase(), u === "md5" ? new MD5$2() : u === "rmd160" || u === "ripemd160" ? new RIPEMD160$3() : new Hash(sha$3(u));
}, inherits$j = inherits_browserExports, Buffer$w = safeBufferExports$3.Buffer, Base$4 = cipherBase, ZEROS$2 = Buffer$w.alloc(128), blocksize = 64;
function Hmac$3(a, u) {
  Base$4.call(this, "digest"), typeof u == "string" && (u = Buffer$w.from(u)), this._alg = a, this._key = u, u.length > blocksize ? u = a(u) : u.length < blocksize && (u = Buffer$w.concat([u, ZEROS$2], blocksize));
  for (var c = this._ipad = Buffer$w.allocUnsafe(blocksize), l = this._opad = Buffer$w.allocUnsafe(blocksize), v = 0; v < blocksize; v++)
    c[v] = u[v] ^ 54, l[v] = u[v] ^ 92;
  this._hash = [c];
}
inherits$j(Hmac$3, Base$4);
Hmac$3.prototype._update = function(a) {
  this._hash.push(a);
};
Hmac$3.prototype._final = function() {
  var a = this._alg(Buffer$w.concat(this._hash));
  return this._alg(Buffer$w.concat([this._opad, a]));
};
var legacy = Hmac$3, MD5$1 = md5_js, md5$2 = function(a) {
  return new MD5$1().update(a).digest();
}, inherits$i = inherits_browserExports, Legacy = legacy, Base$3 = cipherBase, Buffer$v = safeBufferExports$3.Buffer, md5$1 = md5$2, RIPEMD160$2 = ripemd160, sha$2 = sha_jsExports, ZEROS$1 = Buffer$v.alloc(128);
function Hmac$2(a, u) {
  Base$3.call(this, "digest"), typeof u == "string" && (u = Buffer$v.from(u));
  var c = a === "sha512" || a === "sha384" ? 128 : 64;
  if (this._alg = a, this._key = u, u.length > c) {
    var l = a === "rmd160" ? new RIPEMD160$2() : sha$2(a);
    u = l.update(u).digest();
  } else
    u.length < c && (u = Buffer$v.concat([u, ZEROS$1], c));
  for (var v = this._ipad = Buffer$v.allocUnsafe(c), p = this._opad = Buffer$v.allocUnsafe(c), _ = 0; _ < c; _++)
    v[_] = u[_] ^ 54, p[_] = u[_] ^ 92;
  this._hash = a === "rmd160" ? new RIPEMD160$2() : sha$2(a), this._hash.update(v);
}
inherits$i(Hmac$2, Base$3);
Hmac$2.prototype._update = function(a) {
  this._hash.update(a);
};
Hmac$2.prototype._final = function() {
  var a = this._hash.digest(), u = this._alg === "rmd160" ? new RIPEMD160$2() : sha$2(this._alg);
  return u.update(this._opad).update(a).digest();
};
var browser$9 = function a(u, c) {
  return u = u.toLowerCase(), u === "rmd160" || u === "ripemd160" ? new Hmac$2("rmd160", c) : u === "md5" ? new Legacy(md5$1, c) : new Hmac$2(u, c);
};
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos = require$$6, browser$8 = {}, MAX_ALLOC = Math.pow(2, 30) - 1, precondition = function(a, u) {
  if (typeof a != "number")
    throw new TypeError("Iterations not a number");
  if (a < 0)
    throw new TypeError("Bad iterations");
  if (typeof u != "number")
    throw new TypeError("Key length not a number");
  if (u < 0 || u > MAX_ALLOC || u !== u)
    throw new TypeError("Bad key length");
}, defaultEncoding$2;
if (commonjsGlobal$1.process && commonjsGlobal$1.process.browser)
  defaultEncoding$2 = "utf-8";
else if (commonjsGlobal$1.process && commonjsGlobal$1.process.version) {
  var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else
  defaultEncoding$2 = "utf-8";
var defaultEncoding_1 = defaultEncoding$2, Buffer$u = safeBufferExports$3.Buffer, toBuffer$2 = function(a, u, c) {
  if (Buffer$u.isBuffer(a))
    return a;
  if (typeof a == "string")
    return Buffer$u.from(a, u);
  if (ArrayBuffer.isView(a))
    return Buffer$u.from(a.buffer);
  throw new TypeError(c + " must be a string, a Buffer, a typed array or a DataView");
}, md5 = md5$2, RIPEMD160$1 = ripemd160, sha$1 = sha_jsExports, Buffer$t = safeBufferExports$3.Buffer, checkParameters$1 = precondition, defaultEncoding$1 = defaultEncoding_1, toBuffer$1 = toBuffer$2, ZEROS = Buffer$t.alloc(128), sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function Hmac$1(a, u, c) {
  var l = getDigest(a), v = a === "sha512" || a === "sha384" ? 128 : 64;
  u.length > v ? u = l(u) : u.length < v && (u = Buffer$t.concat([u, ZEROS], v));
  for (var p = Buffer$t.allocUnsafe(v + sizes[a]), _ = Buffer$t.allocUnsafe(v + sizes[a]), I = 0; I < v; I++)
    p[I] = u[I] ^ 54, _[I] = u[I] ^ 92;
  var P = Buffer$t.allocUnsafe(v + c + 4);
  p.copy(P, 0, 0, v), this.ipad1 = P, this.ipad2 = p, this.opad = _, this.alg = a, this.blocksize = v, this.hash = l, this.size = sizes[a];
}
Hmac$1.prototype.run = function(a, u) {
  a.copy(u, this.blocksize);
  var c = this.hash(u);
  return c.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function getDigest(a) {
  function u(l) {
    return sha$1(a).update(l).digest();
  }
  function c(l) {
    return new RIPEMD160$1().update(l).digest();
  }
  return a === "rmd160" || a === "ripemd160" ? c : a === "md5" ? md5 : u;
}
function pbkdf2(a, u, c, l, v) {
  checkParameters$1(c, l), a = toBuffer$1(a, defaultEncoding$1, "Password"), u = toBuffer$1(u, defaultEncoding$1, "Salt"), v = v || "sha1";
  var p = new Hmac$1(v, a, u.length), _ = Buffer$t.allocUnsafe(l), I = Buffer$t.allocUnsafe(u.length + 4);
  u.copy(I, 0, 0, u.length);
  for (var P = 0, $ = sizes[v], F = Math.ceil(l / $), H = 1; H <= F; H++) {
    I.writeUInt32BE(H, u.length);
    for (var j = p.run(I, p.ipad1), ee = j, X = 1; X < c; X++) {
      ee = p.run(ee, p.ipad2);
      for (var ie = 0; ie < $; ie++)
        j[ie] ^= ee[ie];
    }
    j.copy(_, P), P += $;
  }
  return _;
}
var syncBrowser = pbkdf2, Buffer$s = safeBufferExports$3.Buffer, checkParameters = precondition, defaultEncoding = defaultEncoding_1, sync = syncBrowser, toBuffer = toBuffer$2, ZERO_BUF, subtle = commonjsGlobal$1.crypto && commonjsGlobal$1.crypto.subtle, toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, checks = [];
function checkNative(a) {
  if (commonjsGlobal$1.process && !commonjsGlobal$1.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)
    return Promise.resolve(!1);
  if (checks[a] !== void 0)
    return checks[a];
  ZERO_BUF = ZERO_BUF || Buffer$s.alloc(8);
  var u = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, a).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return checks[a] = u, u;
}
var nextTick$1;
function getNextTick() {
  return nextTick$1 || (commonjsGlobal$1.process && commonjsGlobal$1.process.nextTick ? nextTick$1 = commonjsGlobal$1.process.nextTick : commonjsGlobal$1.queueMicrotask ? nextTick$1 = commonjsGlobal$1.queueMicrotask : commonjsGlobal$1.setImmediate ? nextTick$1 = commonjsGlobal$1.setImmediate : nextTick$1 = commonjsGlobal$1.setTimeout, nextTick$1);
}
function browserPbkdf2(a, u, c, l, v) {
  return subtle.importKey(
    "raw",
    a,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(p) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt: u,
      iterations: c,
      hash: {
        name: v
      }
    }, p, l << 3);
  }).then(function(p) {
    return Buffer$s.from(p);
  });
}
function resolvePromise(a, u) {
  a.then(function(c) {
    getNextTick()(function() {
      u(null, c);
    });
  }, function(c) {
    getNextTick()(function() {
      u(c);
    });
  });
}
var async = function(a, u, c, l, v, p) {
  typeof v == "function" && (p = v, v = void 0), v = v || "sha1";
  var _ = toBrowser[v.toLowerCase()];
  if (!_ || typeof commonjsGlobal$1.Promise != "function") {
    getNextTick()(function() {
      var I;
      try {
        I = sync(a, u, c, l, v);
      } catch (P) {
        return p(P);
      }
      p(null, I);
    });
    return;
  }
  if (checkParameters(c, l), a = toBuffer(a, defaultEncoding, "Password"), u = toBuffer(u, defaultEncoding, "Salt"), typeof p != "function")
    throw new Error("No callback provided to pbkdf2");
  resolvePromise(checkNative(_).then(function(I) {
    return I ? browserPbkdf2(a, u, c, l, _) : sync(a, u, c, l, v);
  }), p);
};
browser$8.pbkdf2 = async;
browser$8.pbkdf2Sync = syncBrowser;
var browser$7 = {}, des$2 = {}, utils$x = {};
utils$x.readUInt32BE = function a(u, c) {
  var l = u[0 + c] << 24 | u[1 + c] << 16 | u[2 + c] << 8 | u[3 + c];
  return l >>> 0;
};
utils$x.writeUInt32BE = function a(u, c, l) {
  u[0 + l] = c >>> 24, u[1 + l] = c >>> 16 & 255, u[2 + l] = c >>> 8 & 255, u[3 + l] = c & 255;
};
utils$x.ip = function a(u, c, l, v) {
  for (var p = 0, _ = 0, I = 6; I >= 0; I -= 2) {
    for (var P = 0; P <= 24; P += 8)
      p <<= 1, p |= c >>> P + I & 1;
    for (var P = 0; P <= 24; P += 8)
      p <<= 1, p |= u >>> P + I & 1;
  }
  for (var I = 6; I >= 0; I -= 2) {
    for (var P = 1; P <= 25; P += 8)
      _ <<= 1, _ |= c >>> P + I & 1;
    for (var P = 1; P <= 25; P += 8)
      _ <<= 1, _ |= u >>> P + I & 1;
  }
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.rip = function a(u, c, l, v) {
  for (var p = 0, _ = 0, I = 0; I < 4; I++)
    for (var P = 24; P >= 0; P -= 8)
      p <<= 1, p |= c >>> P + I & 1, p <<= 1, p |= u >>> P + I & 1;
  for (var I = 4; I < 8; I++)
    for (var P = 24; P >= 0; P -= 8)
      _ <<= 1, _ |= c >>> P + I & 1, _ <<= 1, _ |= u >>> P + I & 1;
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.pc1 = function a(u, c, l, v) {
  for (var p = 0, _ = 0, I = 7; I >= 5; I--) {
    for (var P = 0; P <= 24; P += 8)
      p <<= 1, p |= c >> P + I & 1;
    for (var P = 0; P <= 24; P += 8)
      p <<= 1, p |= u >> P + I & 1;
  }
  for (var P = 0; P <= 24; P += 8)
    p <<= 1, p |= c >> P + I & 1;
  for (var I = 1; I <= 3; I++) {
    for (var P = 0; P <= 24; P += 8)
      _ <<= 1, _ |= c >> P + I & 1;
    for (var P = 0; P <= 24; P += 8)
      _ <<= 1, _ |= u >> P + I & 1;
  }
  for (var P = 0; P <= 24; P += 8)
    _ <<= 1, _ |= u >> P + I & 1;
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.r28shl = function a(u, c) {
  return u << c & 268435455 | u >>> 28 - c;
};
var pc2table = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$x.pc2 = function a(u, c, l, v) {
  for (var p = 0, _ = 0, I = pc2table.length >>> 1, P = 0; P < I; P++)
    p <<= 1, p |= u >>> pc2table[P] & 1;
  for (var P = I; P < pc2table.length; P++)
    _ <<= 1, _ |= c >>> pc2table[P] & 1;
  l[v + 0] = p >>> 0, l[v + 1] = _ >>> 0;
};
utils$x.expand = function a(u, c, l) {
  var v = 0, p = 0;
  v = (u & 1) << 5 | u >>> 27;
  for (var _ = 23; _ >= 15; _ -= 4)
    v <<= 6, v |= u >>> _ & 63;
  for (var _ = 11; _ >= 3; _ -= 4)
    p |= u >>> _ & 63, p <<= 6;
  p |= (u & 31) << 1 | u >>> 31, c[l + 0] = v >>> 0, c[l + 1] = p >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$x.substitute = function a(u, c) {
  for (var l = 0, v = 0; v < 4; v++) {
    var p = u >>> 18 - v * 6 & 63, _ = sTable[v * 64 + p];
    l <<= 4, l |= _;
  }
  for (var v = 0; v < 4; v++) {
    var p = c >>> 18 - v * 6 & 63, _ = sTable[4 * 64 + v * 64 + p];
    l <<= 4, l |= _;
  }
  return l >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$x.permute = function a(u) {
  for (var c = 0, l = 0; l < permuteTable.length; l++)
    c <<= 1, c |= u >>> permuteTable[l] & 1;
  return c >>> 0;
};
utils$x.padSplit = function a(u, c, l) {
  for (var v = u.toString(2); v.length < c; )
    v = "0" + v;
  for (var p = [], _ = 0; _ < c; _ += l)
    p.push(v.slice(_, _ + l));
  return p.join(" ");
};
var minimalisticAssert = assert$j;
function assert$j(a, u) {
  if (!a)
    throw new Error(u || "Assertion failed");
}
assert$j.equal = function a(u, c, l) {
  if (u != c)
    throw new Error(l || "Assertion failed: " + u + " != " + c);
};
var assert$i = minimalisticAssert;
function Cipher$3(a) {
  this.options = a, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = a.padding !== !1;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function a() {
};
Cipher$3.prototype.update = function a(u) {
  return u.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(u) : this._updateEncrypt(u);
};
Cipher$3.prototype._buffer = function a(u, c) {
  for (var l = Math.min(this.buffer.length - this.bufferOff, u.length - c), v = 0; v < l; v++)
    this.buffer[this.bufferOff + v] = u[c + v];
  return this.bufferOff += l, l;
};
Cipher$3.prototype._flushBuffer = function a(u, c) {
  return this._update(this.buffer, 0, u, c), this.bufferOff = 0, this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function a(u) {
  var c = 0, l = 0, v = (this.bufferOff + u.length) / this.blockSize | 0, p = new Array(v * this.blockSize);
  this.bufferOff !== 0 && (c += this._buffer(u, c), this.bufferOff === this.buffer.length && (l += this._flushBuffer(p, l)));
  for (var _ = u.length - (u.length - c) % this.blockSize; c < _; c += this.blockSize)
    this._update(u, c, p, l), l += this.blockSize;
  for (; c < u.length; c++, this.bufferOff++)
    this.buffer[this.bufferOff] = u[c];
  return p;
};
Cipher$3.prototype._updateDecrypt = function a(u) {
  for (var c = 0, l = 0, v = Math.ceil((this.bufferOff + u.length) / this.blockSize) - 1, p = new Array(v * this.blockSize); v > 0; v--)
    c += this._buffer(u, c), l += this._flushBuffer(p, l);
  return c += this._buffer(u, c), p;
};
Cipher$3.prototype.final = function a(u) {
  var c;
  u && (c = this.update(u));
  var l;
  return this.type === "encrypt" ? l = this._finalEncrypt() : l = this._finalDecrypt(), c ? c.concat(l) : l;
};
Cipher$3.prototype._pad = function a(u, c) {
  if (c === 0)
    return !1;
  for (; c < u.length; )
    u[c++] = 0;
  return !0;
};
Cipher$3.prototype._finalEncrypt = function a() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var u = new Array(this.blockSize);
  return this._update(this.buffer, 0, u, 0), u;
};
Cipher$3.prototype._unpad = function a(u) {
  return u;
};
Cipher$3.prototype._finalDecrypt = function a() {
  assert$i.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var u = new Array(this.blockSize);
  return this._flushBuffer(u, 0), this._unpad(u);
};
var assert$h = minimalisticAssert, inherits$h = inherits_browserExports, utils$w = utils$x, Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2), this.keys = null;
}
function DES$3(a) {
  Cipher$2.call(this, a);
  var u = new DESState();
  this._desState = u, this.deriveKeys(u, a.key);
}
inherits$h(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function a(u) {
  return new DES$3(u);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function a(u, c) {
  u.keys = new Array(16 * 2), assert$h.equal(c.length, this.blockSize, "Invalid key length");
  var l = utils$w.readUInt32BE(c, 0), v = utils$w.readUInt32BE(c, 4);
  utils$w.pc1(l, v, u.tmp, 0), l = u.tmp[0], v = u.tmp[1];
  for (var p = 0; p < u.keys.length; p += 2) {
    var _ = shiftTable[p >>> 1];
    l = utils$w.r28shl(l, _), v = utils$w.r28shl(v, _), utils$w.pc2(l, v, u.keys, p);
  }
};
DES$3.prototype._update = function a(u, c, l, v) {
  var p = this._desState, _ = utils$w.readUInt32BE(u, c), I = utils$w.readUInt32BE(u, c + 4);
  utils$w.ip(_, I, p.tmp, 0), _ = p.tmp[0], I = p.tmp[1], this.type === "encrypt" ? this._encrypt(p, _, I, p.tmp, 0) : this._decrypt(p, _, I, p.tmp, 0), _ = p.tmp[0], I = p.tmp[1], utils$w.writeUInt32BE(l, _, v), utils$w.writeUInt32BE(l, I, v + 4);
};
DES$3.prototype._pad = function a(u, c) {
  if (this.padding === !1)
    return !1;
  for (var l = u.length - c, v = c; v < u.length; v++)
    u[v] = l;
  return !0;
};
DES$3.prototype._unpad = function a(u) {
  if (this.padding === !1)
    return u;
  for (var c = u[u.length - 1], l = u.length - c; l < u.length; l++)
    assert$h.equal(u[l], c);
  return u.slice(0, u.length - c);
};
DES$3.prototype._encrypt = function a(u, c, l, v, p) {
  for (var _ = c, I = l, P = 0; P < u.keys.length; P += 2) {
    var $ = u.keys[P], F = u.keys[P + 1];
    utils$w.expand(I, u.tmp, 0), $ ^= u.tmp[0], F ^= u.tmp[1];
    var H = utils$w.substitute($, F), j = utils$w.permute(H), ee = I;
    I = (_ ^ j) >>> 0, _ = ee;
  }
  utils$w.rip(I, _, v, p);
};
DES$3.prototype._decrypt = function a(u, c, l, v, p) {
  for (var _ = l, I = c, P = u.keys.length - 2; P >= 0; P -= 2) {
    var $ = u.keys[P], F = u.keys[P + 1];
    utils$w.expand(_, u.tmp, 0), $ ^= u.tmp[0], F ^= u.tmp[1];
    var H = utils$w.substitute($, F), j = utils$w.permute(H), ee = _;
    _ = (I ^ j) >>> 0, I = ee;
  }
  utils$w.rip(_, I, v, p);
};
var cbc$1 = {}, assert$g = minimalisticAssert, inherits$g = inherits_browserExports, proto = {};
function CBCState(a) {
  assert$g.equal(a.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var u = 0; u < this.iv.length; u++)
    this.iv[u] = a[u];
}
function instantiate(a) {
  function u(p) {
    a.call(this, p), this._cbcInit();
  }
  inherits$g(u, a);
  for (var c = Object.keys(proto), l = 0; l < c.length; l++) {
    var v = c[l];
    u.prototype[v] = proto[v];
  }
  return u.create = function(_) {
    return new u(_);
  }, u;
}
cbc$1.instantiate = instantiate;
proto._cbcInit = function a() {
  var u = new CBCState(this.options.iv);
  this._cbcState = u;
};
proto._update = function a(u, c, l, v) {
  var p = this._cbcState, _ = this.constructor.super_.prototype, I = p.iv;
  if (this.type === "encrypt") {
    for (var P = 0; P < this.blockSize; P++)
      I[P] ^= u[c + P];
    _._update.call(this, I, 0, l, v);
    for (var P = 0; P < this.blockSize; P++)
      I[P] = l[v + P];
  } else {
    _._update.call(this, u, c, l, v);
    for (var P = 0; P < this.blockSize; P++)
      l[v + P] ^= I[P];
    for (var P = 0; P < this.blockSize; P++)
      I[P] = u[c + P];
  }
};
var assert$f = minimalisticAssert, inherits$f = inherits_browserExports, Cipher$1 = cipher, DES$2 = des$1;
function EDEState(a, u) {
  assert$f.equal(u.length, 24, "Invalid key length");
  var c = u.slice(0, 8), l = u.slice(8, 16), v = u.slice(16, 24);
  a === "encrypt" ? this.ciphers = [
    DES$2.create({ type: "encrypt", key: c }),
    DES$2.create({ type: "decrypt", key: l }),
    DES$2.create({ type: "encrypt", key: v })
  ] : this.ciphers = [
    DES$2.create({ type: "decrypt", key: v }),
    DES$2.create({ type: "encrypt", key: l }),
    DES$2.create({ type: "decrypt", key: c })
  ];
}
function EDE(a) {
  Cipher$1.call(this, a);
  var u = new EDEState(this.type, this.options.key);
  this._edeState = u;
}
inherits$f(EDE, Cipher$1);
var ede = EDE;
EDE.create = function a(u) {
  return new EDE(u);
};
EDE.prototype._update = function a(u, c, l, v) {
  var p = this._edeState;
  p.ciphers[0]._update(u, c, l, v), p.ciphers[1]._update(l, v, l, v), p.ciphers[2]._update(l, v, l, v);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$x;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase, des = des$2, inherits$e = inherits_browserExports, Buffer$r = safeBufferExports$3.Buffer, modes$4 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$4.des = modes$4["des-cbc"];
modes$4.des3 = modes$4["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$e(DES$1, CipherBase);
function DES$1(a) {
  CipherBase.call(this);
  var u = a.mode.toLowerCase(), c = modes$4[u], l;
  a.decrypt ? l = "decrypt" : l = "encrypt";
  var v = a.key;
  Buffer$r.isBuffer(v) || (v = Buffer$r.from(v)), (u === "des-ede" || u === "des-ede-cbc") && (v = Buffer$r.concat([v, v.slice(0, 8)]));
  var p = a.iv;
  Buffer$r.isBuffer(p) || (p = Buffer$r.from(p)), this._des = c.create({
    key: v,
    iv: p,
    type: l
  });
}
DES$1.prototype._update = function(a) {
  return Buffer$r.from(this._des.update(a));
};
DES$1.prototype._final = function() {
  return Buffer$r.from(this._des.final());
};
var browser$6 = {}, encrypter = {}, ecb = {};
ecb.encrypt = function(a, u) {
  return a._cipher.encryptBlock(u);
};
ecb.decrypt = function(a, u) {
  return a._cipher.decryptBlock(u);
};
var cbc = {}, bufferXor = function a(u, c) {
  for (var l = Math.min(u.length, c.length), v = new Buffer$O(l), p = 0; p < l; ++p)
    v[p] = u[p] ^ c[p];
  return v;
}, xor$7 = bufferXor;
cbc.encrypt = function(a, u) {
  var c = xor$7(u, a._prev);
  return a._prev = a._cipher.encryptBlock(c), a._prev;
};
cbc.decrypt = function(a, u) {
  var c = a._prev;
  a._prev = u;
  var l = a._cipher.decryptBlock(u);
  return xor$7(l, c);
};
var cfb = {}, Buffer$q = safeBufferExports$3.Buffer, xor$6 = bufferXor;
function encryptStart(a, u, c) {
  var l = u.length, v = xor$6(u, a._cache);
  return a._cache = a._cache.slice(l), a._prev = Buffer$q.concat([a._prev, c ? u : v]), v;
}
cfb.encrypt = function(a, u, c) {
  for (var l = Buffer$q.allocUnsafe(0), v; u.length; )
    if (a._cache.length === 0 && (a._cache = a._cipher.encryptBlock(a._prev), a._prev = Buffer$q.allocUnsafe(0)), a._cache.length <= u.length)
      v = a._cache.length, l = Buffer$q.concat([l, encryptStart(a, u.slice(0, v), c)]), u = u.slice(v);
    else {
      l = Buffer$q.concat([l, encryptStart(a, u, c)]);
      break;
    }
  return l;
};
var cfb8 = {}, Buffer$p = safeBufferExports$3.Buffer;
function encryptByte$1(a, u, c) {
  var l = a._cipher.encryptBlock(a._prev), v = l[0] ^ u;
  return a._prev = Buffer$p.concat([
    a._prev.slice(1),
    Buffer$p.from([c ? u : v])
  ]), v;
}
cfb8.encrypt = function(a, u, c) {
  for (var l = u.length, v = Buffer$p.allocUnsafe(l), p = -1; ++p < l; )
    v[p] = encryptByte$1(a, u[p], c);
  return v;
};
var cfb1 = {}, Buffer$o = safeBufferExports$3.Buffer;
function encryptByte(a, u, c) {
  for (var l, v = -1, p = 8, _ = 0, I, P; ++v < p; )
    l = a._cipher.encryptBlock(a._prev), I = u & 1 << 7 - v ? 128 : 0, P = l[0] ^ I, _ += (P & 128) >> v % 8, a._prev = shiftIn(a._prev, c ? I : P);
  return _;
}
function shiftIn(a, u) {
  var c = a.length, l = -1, v = Buffer$o.allocUnsafe(a.length);
  for (a = Buffer$o.concat([a, Buffer$o.from([u])]); ++l < c; )
    v[l] = a[l] << 1 | a[l + 1] >> 7;
  return v;
}
cfb1.encrypt = function(a, u, c) {
  for (var l = u.length, v = Buffer$o.allocUnsafe(l), p = -1; ++p < l; )
    v[p] = encryptByte(a, u[p], c);
  return v;
};
var ofb = {}, xor$5 = bufferXor;
function getBlock$1(a) {
  return a._prev = a._cipher.encryptBlock(a._prev), a._prev;
}
ofb.encrypt = function(a, u) {
  for (; a._cache.length < u.length; )
    a._cache = Buffer$O.concat([a._cache, getBlock$1(a)]);
  var c = a._cache.slice(0, u.length);
  return a._cache = a._cache.slice(u.length), xor$5(u, c);
};
var ctr = {};
function incr32$2(a) {
  for (var u = a.length, c; u--; )
    if (c = a.readUInt8(u), c === 255)
      a.writeUInt8(0, u);
    else {
      c++, a.writeUInt8(c, u);
      break;
    }
}
var incr32_1 = incr32$2, xor$4 = bufferXor, Buffer$n = safeBufferExports$3.Buffer, incr32$1 = incr32_1;
function getBlock(a) {
  var u = a._cipher.encryptBlockRaw(a._prev);
  return incr32$1(a._prev), u;
}
var blockSize = 16;
ctr.encrypt = function(a, u) {
  var c = Math.ceil(u.length / blockSize), l = a._cache.length;
  a._cache = Buffer$n.concat([
    a._cache,
    Buffer$n.allocUnsafe(c * blockSize)
  ]);
  for (var v = 0; v < c; v++) {
    var p = getBlock(a), _ = l + v * blockSize;
    a._cache.writeUInt32BE(p[0], _ + 0), a._cache.writeUInt32BE(p[1], _ + 4), a._cache.writeUInt32BE(p[2], _ + 8), a._cache.writeUInt32BE(p[3], _ + 12);
  }
  var I = a._cache.slice(0, u.length);
  return a._cache = a._cache.slice(u.length), xor$4(u, I);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
}, modes$3 = require$$2;
for (var key$3 in modes$3)
  modes$3[key$3].module = modeModules[modes$3[key$3].mode];
var modes_1 = modes$3, aes$5 = {}, Buffer$m = safeBufferExports$3.Buffer;
function asUInt32Array(a) {
  Buffer$m.isBuffer(a) || (a = Buffer$m.from(a));
  for (var u = a.length / 4 | 0, c = new Array(u), l = 0; l < u; l++)
    c[l] = a.readUInt32BE(l * 4);
  return c;
}
function scrubVec(a) {
  for (var u = 0; u < a.length; a++)
    a[u] = 0;
}
function cryptBlock(a, u, c, l, v) {
  for (var p = c[0], _ = c[1], I = c[2], P = c[3], $ = a[0] ^ u[0], F = a[1] ^ u[1], H = a[2] ^ u[2], j = a[3] ^ u[3], ee, X, ie, Q, ne = 4, Z = 1; Z < v; Z++)
    ee = p[$ >>> 24] ^ _[F >>> 16 & 255] ^ I[H >>> 8 & 255] ^ P[j & 255] ^ u[ne++], X = p[F >>> 24] ^ _[H >>> 16 & 255] ^ I[j >>> 8 & 255] ^ P[$ & 255] ^ u[ne++], ie = p[H >>> 24] ^ _[j >>> 16 & 255] ^ I[$ >>> 8 & 255] ^ P[F & 255] ^ u[ne++], Q = p[j >>> 24] ^ _[$ >>> 16 & 255] ^ I[F >>> 8 & 255] ^ P[H & 255] ^ u[ne++], $ = ee, F = X, H = ie, j = Q;
  return ee = (l[$ >>> 24] << 24 | l[F >>> 16 & 255] << 16 | l[H >>> 8 & 255] << 8 | l[j & 255]) ^ u[ne++], X = (l[F >>> 24] << 24 | l[H >>> 16 & 255] << 16 | l[j >>> 8 & 255] << 8 | l[$ & 255]) ^ u[ne++], ie = (l[H >>> 24] << 24 | l[j >>> 16 & 255] << 16 | l[$ >>> 8 & 255] << 8 | l[F & 255]) ^ u[ne++], Q = (l[j >>> 24] << 24 | l[$ >>> 16 & 255] << 16 | l[F >>> 8 & 255] << 8 | l[H & 255]) ^ u[ne++], ee = ee >>> 0, X = X >>> 0, ie = ie >>> 0, Q = Q >>> 0, [ee, X, ie, Q];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {
  for (var a = new Array(256), u = 0; u < 256; u++)
    u < 128 ? a[u] = u << 1 : a[u] = u << 1 ^ 283;
  for (var c = [], l = [], v = [[], [], [], []], p = [[], [], [], []], _ = 0, I = 0, P = 0; P < 256; ++P) {
    var $ = I ^ I << 1 ^ I << 2 ^ I << 3 ^ I << 4;
    $ = $ >>> 8 ^ $ & 255 ^ 99, c[_] = $, l[$] = _;
    var F = a[_], H = a[F], j = a[H], ee = a[$] * 257 ^ $ * 16843008;
    v[0][_] = ee << 24 | ee >>> 8, v[1][_] = ee << 16 | ee >>> 16, v[2][_] = ee << 8 | ee >>> 24, v[3][_] = ee, ee = j * 16843009 ^ H * 65537 ^ F * 257 ^ _ * 16843008, p[0][$] = ee << 24 | ee >>> 8, p[1][$] = ee << 16 | ee >>> 16, p[2][$] = ee << 8 | ee >>> 24, p[3][$] = ee, _ === 0 ? _ = I = 1 : (_ = F ^ a[a[a[j ^ F]]], I ^= a[a[I]]);
  }
  return {
    SBOX: c,
    INV_SBOX: l,
    SUB_MIX: v,
    INV_SUB_MIX: p
  };
}();
function AES(a) {
  this._key = asUInt32Array(a), this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  for (var a = this._key, u = a.length, c = u + 6, l = (c + 1) * 4, v = [], p = 0; p < u; p++)
    v[p] = a[p];
  for (p = u; p < l; p++) {
    var _ = v[p - 1];
    p % u === 0 ? (_ = _ << 8 | _ >>> 24, _ = G.SBOX[_ >>> 24] << 24 | G.SBOX[_ >>> 16 & 255] << 16 | G.SBOX[_ >>> 8 & 255] << 8 | G.SBOX[_ & 255], _ ^= RCON[p / u | 0] << 24) : u > 6 && p % u === 4 && (_ = G.SBOX[_ >>> 24] << 24 | G.SBOX[_ >>> 16 & 255] << 16 | G.SBOX[_ >>> 8 & 255] << 8 | G.SBOX[_ & 255]), v[p] = v[p - u] ^ _;
  }
  for (var I = [], P = 0; P < l; P++) {
    var $ = l - P, F = v[$ - (P % 4 ? 0 : 4)];
    P < 4 || $ <= 4 ? I[P] = F : I[P] = G.INV_SUB_MIX[0][G.SBOX[F >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[F >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[F >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[F & 255]];
  }
  this._nRounds = c, this._keySchedule = v, this._invKeySchedule = I;
};
AES.prototype.encryptBlockRaw = function(a) {
  return a = asUInt32Array(a), cryptBlock(a, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(a) {
  var u = this.encryptBlockRaw(a), c = Buffer$m.allocUnsafe(16);
  return c.writeUInt32BE(u[0], 0), c.writeUInt32BE(u[1], 4), c.writeUInt32BE(u[2], 8), c.writeUInt32BE(u[3], 12), c;
};
AES.prototype.decryptBlock = function(a) {
  a = asUInt32Array(a);
  var u = a[1];
  a[1] = a[3], a[3] = u;
  var c = cryptBlock(a, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), l = Buffer$m.allocUnsafe(16);
  return l.writeUInt32BE(c[0], 0), l.writeUInt32BE(c[3], 4), l.writeUInt32BE(c[2], 8), l.writeUInt32BE(c[1], 12), l;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);
};
aes$5.AES = AES;
var Buffer$l = safeBufferExports$3.Buffer, ZEROES = Buffer$l.alloc(16, 0);
function toArray$1(a) {
  return [
    a.readUInt32BE(0),
    a.readUInt32BE(4),
    a.readUInt32BE(8),
    a.readUInt32BE(12)
  ];
}
function fromArray(a) {
  var u = Buffer$l.allocUnsafe(16);
  return u.writeUInt32BE(a[0] >>> 0, 0), u.writeUInt32BE(a[1] >>> 0, 4), u.writeUInt32BE(a[2] >>> 0, 8), u.writeUInt32BE(a[3] >>> 0, 12), u;
}
function GHASH$1(a) {
  this.h = a, this.state = Buffer$l.alloc(16, 0), this.cache = Buffer$l.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(a) {
  for (var u = -1; ++u < a.length; )
    this.state[u] ^= a[u];
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  for (var a = toArray$1(this.h), u = [0, 0, 0, 0], c, l, v, p = -1; ++p < 128; ) {
    for (l = (this.state[~~(p / 8)] & 1 << 7 - p % 8) !== 0, l && (u[0] ^= a[0], u[1] ^= a[1], u[2] ^= a[2], u[3] ^= a[3]), v = (a[3] & 1) !== 0, c = 3; c > 0; c--)
      a[c] = a[c] >>> 1 | (a[c - 1] & 1) << 31;
    a[0] = a[0] >>> 1, v && (a[0] = a[0] ^ 225 << 24);
  }
  this.state = fromArray(u);
};
GHASH$1.prototype.update = function(a) {
  this.cache = Buffer$l.concat([this.cache, a]);
  for (var u; this.cache.length >= 16; )
    u = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(u);
};
GHASH$1.prototype.final = function(a, u) {
  return this.cache.length && this.ghash(Buffer$l.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, a, 0, u])), this.state;
};
var ghash = GHASH$1, aes$4 = aes$5, Buffer$k = safeBufferExports$3.Buffer, Transform$5 = cipherBase, inherits$d = inherits_browserExports, GHASH = ghash, xor$3 = bufferXor, incr32 = incr32_1;
function xorTest(a, u) {
  var c = 0;
  a.length !== u.length && c++;
  for (var l = Math.min(a.length, u.length), v = 0; v < l; ++v)
    c += a[v] ^ u[v];
  return c;
}
function calcIv(a, u, c) {
  if (u.length === 12)
    return a._finID = Buffer$k.concat([u, Buffer$k.from([0, 0, 0, 1])]), Buffer$k.concat([u, Buffer$k.from([0, 0, 0, 2])]);
  var l = new GHASH(c), v = u.length, p = v % 16;
  l.update(u), p && (p = 16 - p, l.update(Buffer$k.alloc(p, 0))), l.update(Buffer$k.alloc(8, 0));
  var _ = v * 8, I = Buffer$k.alloc(8);
  I.writeUIntBE(_, 0, 8), l.update(I), a._finID = l.state;
  var P = Buffer$k.from(a._finID);
  return incr32(P), P;
}
function StreamCipher$3(a, u, c, l) {
  Transform$5.call(this);
  var v = Buffer$k.alloc(4, 0);
  this._cipher = new aes$4.AES(u);
  var p = this._cipher.encryptBlock(v);
  this._ghash = new GHASH(p), c = calcIv(this, c, p), this._prev = Buffer$k.from(c), this._cache = Buffer$k.allocUnsafe(0), this._secCache = Buffer$k.allocUnsafe(0), this._decrypt = l, this._alen = 0, this._len = 0, this._mode = a, this._authTag = null, this._called = !1;
}
inherits$d(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(a) {
  if (!this._called && this._alen) {
    var u = 16 - this._alen % 16;
    u < 16 && (u = Buffer$k.alloc(u, 0), this._ghash.update(u));
  }
  this._called = !0;
  var c = this._mode.encrypt(this, a);
  return this._decrypt ? this._ghash.update(a) : this._ghash.update(c), this._len += a.length, c;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag)
    throw new Error("Unsupported state or unable to authenticate data");
  var a = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(a, this._authTag))
    throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = a, this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function a() {
  if (this._decrypt || !Buffer$k.isBuffer(this._authTag))
    throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function a(u) {
  if (!this._decrypt)
    throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = u;
};
StreamCipher$3.prototype.setAAD = function a(u) {
  if (this._called)
    throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(u), this._alen += u.length;
};
var authCipher = StreamCipher$3, aes$3 = aes$5, Buffer$j = safeBufferExports$3.Buffer, Transform$4 = cipherBase, inherits$c = inherits_browserExports;
function StreamCipher$2(a, u, c, l) {
  Transform$4.call(this), this._cipher = new aes$3.AES(u), this._prev = Buffer$j.from(c), this._cache = Buffer$j.allocUnsafe(0), this._secCache = Buffer$j.allocUnsafe(0), this._decrypt = l, this._mode = a;
}
inherits$c(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(a) {
  return this._mode.encrypt(this, a, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2, Buffer$i = safeBufferExports$3.Buffer, MD5 = md5_js;
function EVP_BytesToKey(a, u, c, l) {
  if (Buffer$i.isBuffer(a) || (a = Buffer$i.from(a, "binary")), u && (Buffer$i.isBuffer(u) || (u = Buffer$i.from(u, "binary")), u.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var v = c / 8, p = Buffer$i.alloc(v), _ = Buffer$i.alloc(l || 0), I = Buffer$i.alloc(0); v > 0 || l > 0; ) {
    var P = new MD5();
    P.update(I), P.update(a), u && P.update(u), I = P.digest();
    var $ = 0;
    if (v > 0) {
      var F = p.length - v;
      $ = Math.min(v, I.length), I.copy(p, F, 0, $), v -= $;
    }
    if ($ < I.length && l > 0) {
      var H = _.length - l, j = Math.min(l, I.length - $);
      I.copy(_, H, $, $ + j), l -= j;
    }
  }
  return I.fill(0), { key: p, iv: _ };
}
var evp_bytestokey = EVP_BytesToKey, MODES$1 = modes_1, AuthCipher$1 = authCipher, Buffer$h = safeBufferExports$3.Buffer, StreamCipher$1 = streamCipher, Transform$3 = cipherBase, aes$2 = aes$5, ebtk$2 = evp_bytestokey, inherits$b = inherits_browserExports;
function Cipher(a, u, c) {
  Transform$3.call(this), this._cache = new Splitter$1(), this._cipher = new aes$2.AES(u), this._prev = Buffer$h.from(c), this._mode = a, this._autopadding = !0;
}
inherits$b(Cipher, Transform$3);
Cipher.prototype._update = function(a) {
  this._cache.add(a);
  for (var u, c, l = []; u = this._cache.get(); )
    c = this._mode.encrypt(this, u), l.push(c);
  return Buffer$h.concat(l);
};
var PADDING$1 = Buffer$h.alloc(16, 16);
Cipher.prototype._final = function() {
  var a = this._cache.flush();
  if (this._autopadding)
    return a = this._mode.encrypt(this, a), this._cipher.scrub(), a;
  if (!a.equals(PADDING$1))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Cipher.prototype.setAutoPadding = function(a) {
  return this._autopadding = !!a, this;
};
function Splitter$1() {
  this.cache = Buffer$h.allocUnsafe(0);
}
Splitter$1.prototype.add = function(a) {
  this.cache = Buffer$h.concat([this.cache, a]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var a = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), a;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  for (var a = 16 - this.cache.length, u = Buffer$h.allocUnsafe(a), c = -1; ++c < a; )
    u.writeUInt8(a, c);
  return Buffer$h.concat([this.cache, u]);
};
function createCipheriv$1(a, u, c) {
  var l = MODES$1[a.toLowerCase()];
  if (!l)
    throw new TypeError("invalid suite type");
  if (typeof u == "string" && (u = Buffer$h.from(u)), u.length !== l.key / 8)
    throw new TypeError("invalid key length " + u.length);
  if (typeof c == "string" && (c = Buffer$h.from(c)), l.mode !== "GCM" && c.length !== l.iv)
    throw new TypeError("invalid iv length " + c.length);
  return l.type === "stream" ? new StreamCipher$1(l.module, u, c) : l.type === "auth" ? new AuthCipher$1(l.module, u, c) : new Cipher(l.module, u, c);
}
function createCipher$1(a, u) {
  var c = MODES$1[a.toLowerCase()];
  if (!c)
    throw new TypeError("invalid suite type");
  var l = ebtk$2(u, !1, c.key, c.iv);
  return createCipheriv$1(a, l.key, l.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$1;
var decrypter = {}, AuthCipher = authCipher, Buffer$g = safeBufferExports$3.Buffer, MODES = modes_1, StreamCipher = streamCipher, Transform$2 = cipherBase, aes$1 = aes$5, ebtk$1 = evp_bytestokey, inherits$a = inherits_browserExports;
function Decipher(a, u, c) {
  Transform$2.call(this), this._cache = new Splitter(), this._last = void 0, this._cipher = new aes$1.AES(u), this._prev = Buffer$g.from(c), this._mode = a, this._autopadding = !0;
}
inherits$a(Decipher, Transform$2);
Decipher.prototype._update = function(a) {
  this._cache.add(a);
  for (var u, c, l = []; u = this._cache.get(this._autopadding); )
    c = this._mode.decrypt(this, u), l.push(c);
  return Buffer$g.concat(l);
};
Decipher.prototype._final = function() {
  var a = this._cache.flush();
  if (this._autopadding)
    return unpad(this._mode.decrypt(this, a));
  if (a)
    throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(a) {
  return this._autopadding = !!a, this;
};
function Splitter() {
  this.cache = Buffer$g.allocUnsafe(0);
}
Splitter.prototype.add = function(a) {
  this.cache = Buffer$g.concat([this.cache, a]);
};
Splitter.prototype.get = function(a) {
  var u;
  if (a) {
    if (this.cache.length > 16)
      return u = this.cache.slice(0, 16), this.cache = this.cache.slice(16), u;
  } else if (this.cache.length >= 16)
    return u = this.cache.slice(0, 16), this.cache = this.cache.slice(16), u;
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length)
    return this.cache;
};
function unpad(a) {
  var u = a[15];
  if (u < 1 || u > 16)
    throw new Error("unable to decrypt data");
  for (var c = -1; ++c < u; )
    if (a[c + (16 - u)] !== u)
      throw new Error("unable to decrypt data");
  if (u !== 16)
    return a.slice(0, 16 - u);
}
function createDecipheriv$1(a, u, c) {
  var l = MODES[a.toLowerCase()];
  if (!l)
    throw new TypeError("invalid suite type");
  if (typeof c == "string" && (c = Buffer$g.from(c)), l.mode !== "GCM" && c.length !== l.iv)
    throw new TypeError("invalid iv length " + c.length);
  if (typeof u == "string" && (u = Buffer$g.from(u)), u.length !== l.key / 8)
    throw new TypeError("invalid key length " + u.length);
  return l.type === "stream" ? new StreamCipher(l.module, u, c, !0) : l.type === "auth" ? new AuthCipher(l.module, u, c, !0) : new Decipher(l.module, u, c);
}
function createDecipher$1(a, u) {
  var c = MODES[a.toLowerCase()];
  if (!c)
    throw new TypeError("invalid suite type");
  var l = ebtk$1(u, !1, c.key, c.iv);
  return createDecipheriv$1(a, l.key, l.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter, deciphers = decrypter, modes$2 = require$$2;
function getCiphers$1() {
  return Object.keys(modes$2);
}
browser$6.createCipher = browser$6.Cipher = ciphers$2.createCipher;
browser$6.createCipheriv = browser$6.Cipheriv = ciphers$2.createCipheriv;
browser$6.createDecipher = browser$6.Decipher = deciphers.createDecipher;
browser$6.createDecipheriv = browser$6.Decipheriv = deciphers.createDecipheriv;
browser$6.listCiphers = browser$6.getCiphers = getCiphers$1;
var modes$1 = {};
(function(a) {
  a["des-ecb"] = {
    key: 8,
    iv: 0
  }, a["des-cbc"] = a.des = {
    key: 8,
    iv: 8
  }, a["des-ede3-cbc"] = a.des3 = {
    key: 24,
    iv: 8
  }, a["des-ede3"] = {
    key: 24,
    iv: 0
  }, a["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, a["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes$1);
var DES = browserifyDes, aes = browser$6, aesModes = modes_1, desModes = modes$1, ebtk = evp_bytestokey;
function createCipher(a, u) {
  a = a.toLowerCase();
  var c, l;
  if (aesModes[a])
    c = aesModes[a].key, l = aesModes[a].iv;
  else if (desModes[a])
    c = desModes[a].key * 8, l = desModes[a].iv;
  else
    throw new TypeError("invalid suite type");
  var v = ebtk(u, !1, c, l);
  return createCipheriv(a, v.key, v.iv);
}
function createDecipher(a, u) {
  a = a.toLowerCase();
  var c, l;
  if (aesModes[a])
    c = aesModes[a].key, l = aesModes[a].iv;
  else if (desModes[a])
    c = desModes[a].key * 8, l = desModes[a].iv;
  else
    throw new TypeError("invalid suite type");
  var v = ebtk(u, !1, c, l);
  return createDecipheriv(a, v.key, v.iv);
}
function createCipheriv(a, u, c) {
  if (a = a.toLowerCase(), aesModes[a])
    return aes.createCipheriv(a, u, c);
  if (desModes[a])
    return new DES({ key: u, iv: c, mode: a });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(a, u, c) {
  if (a = a.toLowerCase(), aesModes[a])
    return aes.createDecipheriv(a, u, c);
  if (desModes[a])
    return new DES({ key: u, iv: c, mode: a, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}
browser$7.createCipher = browser$7.Cipher = createCipher;
browser$7.createCipheriv = browser$7.Cipheriv = createCipheriv;
browser$7.createDecipher = browser$7.Decipher = createDecipher;
browser$7.createDecipheriv = browser$7.Decipheriv = createDecipheriv;
browser$7.listCiphers = browser$7.getCiphers = getCiphers;
var browser$5 = {}, bn$6 = { exports: {} };
bn$6.exports;
(function(a) {
  (function(u, c) {
    function l(C, b) {
      if (!C)
        throw new Error(b || "Assertion failed");
    }
    function v(C, b) {
      C.super_ = b;
      var E = function() {
      };
      E.prototype = b.prototype, C.prototype = new E(), C.prototype.constructor = C;
    }
    function p(C, b, E) {
      if (p.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((b === "le" || b === "be") && (E = b, b = 10), this._init(C || 0, b || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(b) {
      return b instanceof p ? !0 : b !== null && typeof b == "object" && b.constructor.wordSize === p.wordSize && Array.isArray(b.words);
    }, p.max = function(b, E) {
      return b.cmp(E) > 0 ? b : E;
    }, p.min = function(b, E) {
      return b.cmp(E) < 0 ? b : E;
    }, p.prototype._init = function(b, E, k) {
      if (typeof b == "number")
        return this._initNumber(b, E, k);
      if (typeof b == "object")
        return this._initArray(b, E, k);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), b = b.toString().replace(/\s+/g, "");
      var O = 0;
      b[0] === "-" && (O++, this.negative = 1), O < b.length && (E === 16 ? this._parseHex(b, O, k) : (this._parseBase(b, E, O), k === "le" && this._initArray(this.toArray(), E, k)));
    }, p.prototype._initNumber = function(b, E, k) {
      b < 0 && (this.negative = 1, b = -b), b < 67108864 ? (this.words = [b & 67108863], this.length = 1) : b < 4503599627370496 ? (this.words = [
        b & 67108863,
        b / 67108864 & 67108863
      ], this.length = 2) : (l(b < 9007199254740992), this.words = [
        b & 67108863,
        b / 67108864 & 67108863,
        1
      ], this.length = 3), k === "le" && this._initArray(this.toArray(), E, k);
    }, p.prototype._initArray = function(b, E, k) {
      if (l(typeof b.length == "number"), b.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(b.length / 3), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var A, x, Y = 0;
      if (k === "be")
        for (O = b.length - 1, A = 0; O >= 0; O -= 3)
          x = b[O] | b[O - 1] << 8 | b[O - 2] << 16, this.words[A] |= x << Y & 67108863, this.words[A + 1] = x >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, A++);
      else if (k === "le")
        for (O = 0, A = 0; O < b.length; O += 3)
          x = b[O] | b[O + 1] << 8 | b[O + 2] << 16, this.words[A] |= x << Y & 67108863, this.words[A + 1] = x >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, A++);
      return this.strip();
    };
    function I(C, b) {
      var E = C.charCodeAt(b);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function P(C, b, E) {
      var k = I(C, E);
      return E - 1 >= b && (k |= I(C, E - 1) << 4), k;
    }
    p.prototype._parseHex = function(b, E, k) {
      this.length = Math.ceil((b.length - E) / 6), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var A = 0, x = 0, Y;
      if (k === "be")
        for (O = b.length - 1; O >= E; O -= 2)
          Y = P(b, E, O) << A, this.words[x] |= Y & 67108863, A >= 18 ? (A -= 18, x += 1, this.words[x] |= Y >>> 26) : A += 8;
      else {
        var B = b.length - E;
        for (O = B % 2 === 0 ? E + 1 : E; O < b.length; O += 2)
          Y = P(b, E, O) << A, this.words[x] |= Y & 67108863, A >= 18 ? (A -= 18, x += 1, this.words[x] |= Y >>> 26) : A += 8;
      }
      this.strip();
    };
    function $(C, b, E, k) {
      for (var O = 0, A = Math.min(C.length, E), x = b; x < A; x++) {
        var Y = C.charCodeAt(x) - 48;
        O *= k, Y >= 49 ? O += Y - 49 + 10 : Y >= 17 ? O += Y - 17 + 10 : O += Y;
      }
      return O;
    }
    p.prototype._parseBase = function(b, E, k) {
      this.words = [0], this.length = 1;
      for (var O = 0, A = 1; A <= 67108863; A *= E)
        O++;
      O--, A = A / E | 0;
      for (var x = b.length - k, Y = x % O, B = Math.min(x, x - Y) + k, T = 0, D = k; D < B; D += O)
        T = $(b, D, D + O, E), this.imuln(A), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = $(b, D, b.length, E), D = 0; D < Y; D++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(b) {
      b.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        b.words[E] = this.words[E];
      b.length = this.length, b.negative = this.negative, b.red = this.red;
    }, p.prototype.clone = function() {
      var b = new p(null);
      return this.copy(b), b;
    }, p.prototype._expand = function(b) {
      for (; this.length < b; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], H = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], j = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(b, E) {
      b = b || 10, E = E | 0 || 1;
      var k;
      if (b === 16 || b === "hex") {
        k = "";
        for (var O = 0, A = 0, x = 0; x < this.length; x++) {
          var Y = this.words[x], B = ((Y << O | A) & 16777215).toString(16);
          A = Y >>> 24 - O & 16777215, A !== 0 || x !== this.length - 1 ? k = F[6 - B.length] + B + k : k = B + k, O += 2, O >= 26 && (O -= 26, x--);
        }
        for (A !== 0 && (k = A.toString(16) + k); k.length % E !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      if (b === (b | 0) && b >= 2 && b <= 36) {
        var T = H[b], D = j[b];
        k = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var me = te.modn(D).toString(b);
          te = te.idivn(D), te.isZero() ? k = me + k : k = F[T - me.length] + me + k;
        }
        for (this.isZero() && (k = "0" + k); k.length % E !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var b = this.words[0];
      return this.length === 2 ? b += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? b += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -b : b;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(b, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, b, E);
    }, p.prototype.toArray = function(b, E) {
      return this.toArrayLike(Array, b, E);
    }, p.prototype.toArrayLike = function(b, E, k) {
      var O = this.byteLength(), A = k || Math.max(1, O);
      l(O <= A, "byte array longer than desired length"), l(A > 0, "Requested array length <= 0"), this.strip();
      var x = E === "le", Y = new b(A), B, T, D = this.clone();
      if (x) {
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), Y[T] = B;
        for (; T < A; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < A - O; T++)
          Y[T] = 0;
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), Y[A - T - 1] = B;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(b) {
      return 32 - Math.clz32(b);
    } : p.prototype._countBits = function(b) {
      var E = b, k = 0;
      return E >= 4096 && (k += 13, E >>>= 13), E >= 64 && (k += 7, E >>>= 7), E >= 8 && (k += 4, E >>>= 4), E >= 2 && (k += 2, E >>>= 2), k + E;
    }, p.prototype._zeroBits = function(b) {
      if (b === 0)
        return 26;
      var E = b, k = 0;
      return E & 8191 || (k += 13, E >>>= 13), E & 127 || (k += 7, E >>>= 7), E & 15 || (k += 4, E >>>= 4), E & 3 || (k += 2, E >>>= 2), E & 1 || k++, k;
    }, p.prototype.bitLength = function() {
      var b = this.words[this.length - 1], E = this._countBits(b);
      return (this.length - 1) * 26 + E;
    };
    function ee(C) {
      for (var b = new Array(C.bitLength()), E = 0; E < b.length; E++) {
        var k = E / 26 | 0, O = E % 26;
        b[E] = (C.words[k] & 1 << O) >>> O;
      }
      return b;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var b = 0, E = 0; E < this.length; E++) {
        var k = this._zeroBits(this.words[E]);
        if (b += k, k !== 26)
          break;
      }
      return b;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(b) {
      return this.negative !== 0 ? this.abs().inotn(b).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(b) {
      return this.testn(b - 1) ? this.notn(b).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(b) {
      for (; this.length < b.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < b.length; E++)
        this.words[E] = this.words[E] | b.words[E];
      return this.strip();
    }, p.prototype.ior = function(b) {
      return l((this.negative | b.negative) === 0), this.iuor(b);
    }, p.prototype.or = function(b) {
      return this.length > b.length ? this.clone().ior(b) : b.clone().ior(this);
    }, p.prototype.uor = function(b) {
      return this.length > b.length ? this.clone().iuor(b) : b.clone().iuor(this);
    }, p.prototype.iuand = function(b) {
      var E;
      this.length > b.length ? E = b : E = this;
      for (var k = 0; k < E.length; k++)
        this.words[k] = this.words[k] & b.words[k];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(b) {
      return l((this.negative | b.negative) === 0), this.iuand(b);
    }, p.prototype.and = function(b) {
      return this.length > b.length ? this.clone().iand(b) : b.clone().iand(this);
    }, p.prototype.uand = function(b) {
      return this.length > b.length ? this.clone().iuand(b) : b.clone().iuand(this);
    }, p.prototype.iuxor = function(b) {
      var E, k;
      this.length > b.length ? (E = this, k = b) : (E = b, k = this);
      for (var O = 0; O < k.length; O++)
        this.words[O] = E.words[O] ^ k.words[O];
      if (this !== E)
        for (; O < E.length; O++)
          this.words[O] = E.words[O];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(b) {
      return l((this.negative | b.negative) === 0), this.iuxor(b);
    }, p.prototype.xor = function(b) {
      return this.length > b.length ? this.clone().ixor(b) : b.clone().ixor(this);
    }, p.prototype.uxor = function(b) {
      return this.length > b.length ? this.clone().iuxor(b) : b.clone().iuxor(this);
    }, p.prototype.inotn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = Math.ceil(b / 26) | 0, k = b % 26;
      this._expand(E), k > 0 && E--;
      for (var O = 0; O < E; O++)
        this.words[O] = ~this.words[O] & 67108863;
      return k > 0 && (this.words[O] = ~this.words[O] & 67108863 >> 26 - k), this.strip();
    }, p.prototype.notn = function(b) {
      return this.clone().inotn(b);
    }, p.prototype.setn = function(b, E) {
      l(typeof b == "number" && b >= 0);
      var k = b / 26 | 0, O = b % 26;
      return this._expand(k + 1), E ? this.words[k] = this.words[k] | 1 << O : this.words[k] = this.words[k] & ~(1 << O), this.strip();
    }, p.prototype.iadd = function(b) {
      var E;
      if (this.negative !== 0 && b.negative === 0)
        return this.negative = 0, E = this.isub(b), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && b.negative !== 0)
        return b.negative = 0, E = this.isub(b), b.negative = 1, E._normSign();
      var k, O;
      this.length > b.length ? (k = this, O = b) : (k = b, O = this);
      for (var A = 0, x = 0; x < O.length; x++)
        E = (k.words[x] | 0) + (O.words[x] | 0) + A, this.words[x] = E & 67108863, A = E >>> 26;
      for (; A !== 0 && x < k.length; x++)
        E = (k.words[x] | 0) + A, this.words[x] = E & 67108863, A = E >>> 26;
      if (this.length = k.length, A !== 0)
        this.words[this.length] = A, this.length++;
      else if (k !== this)
        for (; x < k.length; x++)
          this.words[x] = k.words[x];
      return this;
    }, p.prototype.add = function(b) {
      var E;
      return b.negative !== 0 && this.negative === 0 ? (b.negative = 0, E = this.sub(b), b.negative ^= 1, E) : b.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = b.sub(this), this.negative = 1, E) : this.length > b.length ? this.clone().iadd(b) : b.clone().iadd(this);
    }, p.prototype.isub = function(b) {
      if (b.negative !== 0) {
        b.negative = 0;
        var E = this.iadd(b);
        return b.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(b), this.negative = 1, this._normSign();
      var k = this.cmp(b);
      if (k === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var O, A;
      k > 0 ? (O = this, A = b) : (O = b, A = this);
      for (var x = 0, Y = 0; Y < A.length; Y++)
        E = (O.words[Y] | 0) - (A.words[Y] | 0) + x, x = E >> 26, this.words[Y] = E & 67108863;
      for (; x !== 0 && Y < O.length; Y++)
        E = (O.words[Y] | 0) + x, x = E >> 26, this.words[Y] = E & 67108863;
      if (x === 0 && Y < O.length && O !== this)
        for (; Y < O.length; Y++)
          this.words[Y] = O.words[Y];
      return this.length = Math.max(this.length, Y), O !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(b) {
      return this.clone().isub(b);
    };
    function X(C, b, E) {
      E.negative = b.negative ^ C.negative;
      var k = C.length + b.length | 0;
      E.length = k, k = k - 1 | 0;
      var O = C.words[0] | 0, A = b.words[0] | 0, x = O * A, Y = x & 67108863, B = x / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < k; T++) {
        for (var D = B >>> 26, te = B & 67108863, me = Math.min(T, b.length - 1), Ie = Math.max(0, T - C.length + 1); Ie <= me; Ie++) {
          var $e = T - Ie | 0;
          O = C.words[$e] | 0, A = b.words[Ie] | 0, x = O * A + te, D += x / 67108864 | 0, te = x & 67108863;
        }
        E.words[T] = te | 0, B = D | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ie = function(b, E, k) {
      var O = b.words, A = E.words, x = k.words, Y = 0, B, T, D, te = O[0] | 0, me = te & 8191, Ie = te >>> 13, $e = O[1] | 0, ye = $e & 8191, fe = $e >>> 13, Me = O[2] | 0, Ae = Me & 8191, xe = Me >>> 13, ae = O[3] | 0, N = ae & 8191, re = ae >>> 13, le = O[4] | 0, Ne = le & 8191, Oe = le >>> 13, qe = O[5] | 0, je = qe & 8191, Fe = qe >>> 13, yt = O[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, V = O[7] | 0, ge = V & 8191, Te = V >>> 13, We = O[8] | 0, Re = We & 8191, J = We >>> 13, Ee = O[9] | 0, ue = Ee & 8191, ce = Ee >>> 13, ve = A[0] | 0, Ce = ve & 8191, Be = ve >>> 13, He = A[1] | 0, Ve = He & 8191, Ze = He >>> 13, Ke = A[2] | 0, U = Ke & 8191, se = Ke >>> 13, Se = A[3] | 0, Ue = Se & 8191, De = Se >>> 13, Ye = A[4] | 0, Qe = Ye & 8191, st = Ye >>> 13, St = A[5] | 0, tt = St & 8191, it = St >>> 13, Tt = A[6] | 0, rt = Tt & 8191, dt = Tt >>> 13, wt = A[7] | 0, nt = wt & 8191, at = wt >>> 13, gt = A[8] | 0, ot = gt & 8191, ct = gt >>> 13, Ct = A[9] | 0, ut = Ct & 8191, lt = Ct >>> 13;
      k.negative = b.negative ^ E.negative, k.length = 19, B = Math.imul(me, Ce), T = Math.imul(me, Be), T = T + Math.imul(Ie, Ce) | 0, D = Math.imul(Ie, Be);
      var kt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, B = Math.imul(ye, Ce), T = Math.imul(ye, Be), T = T + Math.imul(fe, Ce) | 0, D = Math.imul(fe, Be), B = B + Math.imul(me, Ve) | 0, T = T + Math.imul(me, Ze) | 0, T = T + Math.imul(Ie, Ve) | 0, D = D + Math.imul(Ie, Ze) | 0;
      var Rt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(Ae, Ce), T = Math.imul(Ae, Be), T = T + Math.imul(xe, Ce) | 0, D = Math.imul(xe, Be), B = B + Math.imul(ye, Ve) | 0, T = T + Math.imul(ye, Ze) | 0, T = T + Math.imul(fe, Ve) | 0, D = D + Math.imul(fe, Ze) | 0, B = B + Math.imul(me, U) | 0, T = T + Math.imul(me, se) | 0, T = T + Math.imul(Ie, U) | 0, D = D + Math.imul(Ie, se) | 0;
      var Je = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, B = Math.imul(N, Ce), T = Math.imul(N, Be), T = T + Math.imul(re, Ce) | 0, D = Math.imul(re, Be), B = B + Math.imul(Ae, Ve) | 0, T = T + Math.imul(Ae, Ze) | 0, T = T + Math.imul(xe, Ve) | 0, D = D + Math.imul(xe, Ze) | 0, B = B + Math.imul(ye, U) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(fe, U) | 0, D = D + Math.imul(fe, se) | 0, B = B + Math.imul(me, Ue) | 0, T = T + Math.imul(me, De) | 0, T = T + Math.imul(Ie, Ue) | 0, D = D + Math.imul(Ie, De) | 0;
      var ze = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, B = Math.imul(Ne, Ce), T = Math.imul(Ne, Be), T = T + Math.imul(Oe, Ce) | 0, D = Math.imul(Oe, Be), B = B + Math.imul(N, Ve) | 0, T = T + Math.imul(N, Ze) | 0, T = T + Math.imul(re, Ve) | 0, D = D + Math.imul(re, Ze) | 0, B = B + Math.imul(Ae, U) | 0, T = T + Math.imul(Ae, se) | 0, T = T + Math.imul(xe, U) | 0, D = D + Math.imul(xe, se) | 0, B = B + Math.imul(ye, Ue) | 0, T = T + Math.imul(ye, De) | 0, T = T + Math.imul(fe, Ue) | 0, D = D + Math.imul(fe, De) | 0, B = B + Math.imul(me, Qe) | 0, T = T + Math.imul(me, st) | 0, T = T + Math.imul(Ie, Qe) | 0, D = D + Math.imul(Ie, st) | 0;
      var et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, B = Math.imul(je, Ce), T = Math.imul(je, Be), T = T + Math.imul(Fe, Ce) | 0, D = Math.imul(Fe, Be), B = B + Math.imul(Ne, Ve) | 0, T = T + Math.imul(Ne, Ze) | 0, T = T + Math.imul(Oe, Ve) | 0, D = D + Math.imul(Oe, Ze) | 0, B = B + Math.imul(N, U) | 0, T = T + Math.imul(N, se) | 0, T = T + Math.imul(re, U) | 0, D = D + Math.imul(re, se) | 0, B = B + Math.imul(Ae, Ue) | 0, T = T + Math.imul(Ae, De) | 0, T = T + Math.imul(xe, Ue) | 0, D = D + Math.imul(xe, De) | 0, B = B + Math.imul(ye, Qe) | 0, T = T + Math.imul(ye, st) | 0, T = T + Math.imul(fe, Qe) | 0, D = D + Math.imul(fe, st) | 0, B = B + Math.imul(me, tt) | 0, T = T + Math.imul(me, it) | 0, T = T + Math.imul(Ie, tt) | 0, D = D + Math.imul(Ie, it) | 0;
      var pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Ce), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Ce) | 0, D = Math.imul(Ge, Be), B = B + Math.imul(je, Ve) | 0, T = T + Math.imul(je, Ze) | 0, T = T + Math.imul(Fe, Ve) | 0, D = D + Math.imul(Fe, Ze) | 0, B = B + Math.imul(Ne, U) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Oe, U) | 0, D = D + Math.imul(Oe, se) | 0, B = B + Math.imul(N, Ue) | 0, T = T + Math.imul(N, De) | 0, T = T + Math.imul(re, Ue) | 0, D = D + Math.imul(re, De) | 0, B = B + Math.imul(Ae, Qe) | 0, T = T + Math.imul(Ae, st) | 0, T = T + Math.imul(xe, Qe) | 0, D = D + Math.imul(xe, st) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(fe, tt) | 0, D = D + Math.imul(fe, it) | 0, B = B + Math.imul(me, rt) | 0, T = T + Math.imul(me, dt) | 0, T = T + Math.imul(Ie, rt) | 0, D = D + Math.imul(Ie, dt) | 0;
      var mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ge, Ce), T = Math.imul(ge, Be), T = T + Math.imul(Te, Ce) | 0, D = Math.imul(Te, Be), B = B + Math.imul(Xe, Ve) | 0, T = T + Math.imul(Xe, Ze) | 0, T = T + Math.imul(Ge, Ve) | 0, D = D + Math.imul(Ge, Ze) | 0, B = B + Math.imul(je, U) | 0, T = T + Math.imul(je, se) | 0, T = T + Math.imul(Fe, U) | 0, D = D + Math.imul(Fe, se) | 0, B = B + Math.imul(Ne, Ue) | 0, T = T + Math.imul(Ne, De) | 0, T = T + Math.imul(Oe, Ue) | 0, D = D + Math.imul(Oe, De) | 0, B = B + Math.imul(N, Qe) | 0, T = T + Math.imul(N, st) | 0, T = T + Math.imul(re, Qe) | 0, D = D + Math.imul(re, st) | 0, B = B + Math.imul(Ae, tt) | 0, T = T + Math.imul(Ae, it) | 0, T = T + Math.imul(xe, tt) | 0, D = D + Math.imul(xe, it) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(fe, rt) | 0, D = D + Math.imul(fe, dt) | 0, B = B + Math.imul(me, nt) | 0, T = T + Math.imul(me, at) | 0, T = T + Math.imul(Ie, nt) | 0, D = D + Math.imul(Ie, at) | 0;
      var vt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, B = Math.imul(Re, Ce), T = Math.imul(Re, Be), T = T + Math.imul(J, Ce) | 0, D = Math.imul(J, Be), B = B + Math.imul(ge, Ve) | 0, T = T + Math.imul(ge, Ze) | 0, T = T + Math.imul(Te, Ve) | 0, D = D + Math.imul(Te, Ze) | 0, B = B + Math.imul(Xe, U) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, U) | 0, D = D + Math.imul(Ge, se) | 0, B = B + Math.imul(je, Ue) | 0, T = T + Math.imul(je, De) | 0, T = T + Math.imul(Fe, Ue) | 0, D = D + Math.imul(Fe, De) | 0, B = B + Math.imul(Ne, Qe) | 0, T = T + Math.imul(Ne, st) | 0, T = T + Math.imul(Oe, Qe) | 0, D = D + Math.imul(Oe, st) | 0, B = B + Math.imul(N, tt) | 0, T = T + Math.imul(N, it) | 0, T = T + Math.imul(re, tt) | 0, D = D + Math.imul(re, it) | 0, B = B + Math.imul(Ae, rt) | 0, T = T + Math.imul(Ae, dt) | 0, T = T + Math.imul(xe, rt) | 0, D = D + Math.imul(xe, dt) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(fe, nt) | 0, D = D + Math.imul(fe, at) | 0, B = B + Math.imul(me, ot) | 0, T = T + Math.imul(me, ct) | 0, T = T + Math.imul(Ie, ot) | 0, D = D + Math.imul(Ie, ct) | 0;
      var ht = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(ue, Ce), T = Math.imul(ue, Be), T = T + Math.imul(ce, Ce) | 0, D = Math.imul(ce, Be), B = B + Math.imul(Re, Ve) | 0, T = T + Math.imul(Re, Ze) | 0, T = T + Math.imul(J, Ve) | 0, D = D + Math.imul(J, Ze) | 0, B = B + Math.imul(ge, U) | 0, T = T + Math.imul(ge, se) | 0, T = T + Math.imul(Te, U) | 0, D = D + Math.imul(Te, se) | 0, B = B + Math.imul(Xe, Ue) | 0, T = T + Math.imul(Xe, De) | 0, T = T + Math.imul(Ge, Ue) | 0, D = D + Math.imul(Ge, De) | 0, B = B + Math.imul(je, Qe) | 0, T = T + Math.imul(je, st) | 0, T = T + Math.imul(Fe, Qe) | 0, D = D + Math.imul(Fe, st) | 0, B = B + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Oe, tt) | 0, D = D + Math.imul(Oe, it) | 0, B = B + Math.imul(N, rt) | 0, T = T + Math.imul(N, dt) | 0, T = T + Math.imul(re, rt) | 0, D = D + Math.imul(re, dt) | 0, B = B + Math.imul(Ae, nt) | 0, T = T + Math.imul(Ae, at) | 0, T = T + Math.imul(xe, nt) | 0, D = D + Math.imul(xe, at) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(fe, ot) | 0, D = D + Math.imul(fe, ct) | 0, B = B + Math.imul(me, ut) | 0, T = T + Math.imul(me, lt) | 0, T = T + Math.imul(Ie, ut) | 0, D = D + Math.imul(Ie, lt) | 0;
      var _t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, B = Math.imul(ue, Ve), T = Math.imul(ue, Ze), T = T + Math.imul(ce, Ve) | 0, D = Math.imul(ce, Ze), B = B + Math.imul(Re, U) | 0, T = T + Math.imul(Re, se) | 0, T = T + Math.imul(J, U) | 0, D = D + Math.imul(J, se) | 0, B = B + Math.imul(ge, Ue) | 0, T = T + Math.imul(ge, De) | 0, T = T + Math.imul(Te, Ue) | 0, D = D + Math.imul(Te, De) | 0, B = B + Math.imul(Xe, Qe) | 0, T = T + Math.imul(Xe, st) | 0, T = T + Math.imul(Ge, Qe) | 0, D = D + Math.imul(Ge, st) | 0, B = B + Math.imul(je, tt) | 0, T = T + Math.imul(je, it) | 0, T = T + Math.imul(Fe, tt) | 0, D = D + Math.imul(Fe, it) | 0, B = B + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Oe, rt) | 0, D = D + Math.imul(Oe, dt) | 0, B = B + Math.imul(N, nt) | 0, T = T + Math.imul(N, at) | 0, T = T + Math.imul(re, nt) | 0, D = D + Math.imul(re, at) | 0, B = B + Math.imul(Ae, ot) | 0, T = T + Math.imul(Ae, ct) | 0, T = T + Math.imul(xe, ot) | 0, D = D + Math.imul(xe, ct) | 0, B = B + Math.imul(ye, ut) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(fe, ut) | 0, D = D + Math.imul(fe, lt) | 0;
      var Et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(ue, U), T = Math.imul(ue, se), T = T + Math.imul(ce, U) | 0, D = Math.imul(ce, se), B = B + Math.imul(Re, Ue) | 0, T = T + Math.imul(Re, De) | 0, T = T + Math.imul(J, Ue) | 0, D = D + Math.imul(J, De) | 0, B = B + Math.imul(ge, Qe) | 0, T = T + Math.imul(ge, st) | 0, T = T + Math.imul(Te, Qe) | 0, D = D + Math.imul(Te, st) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, tt) | 0, D = D + Math.imul(Ge, it) | 0, B = B + Math.imul(je, rt) | 0, T = T + Math.imul(je, dt) | 0, T = T + Math.imul(Fe, rt) | 0, D = D + Math.imul(Fe, dt) | 0, B = B + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Oe, nt) | 0, D = D + Math.imul(Oe, at) | 0, B = B + Math.imul(N, ot) | 0, T = T + Math.imul(N, ct) | 0, T = T + Math.imul(re, ot) | 0, D = D + Math.imul(re, ct) | 0, B = B + Math.imul(Ae, ut) | 0, T = T + Math.imul(Ae, lt) | 0, T = T + Math.imul(xe, ut) | 0, D = D + Math.imul(xe, lt) | 0;
      var Pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, B = Math.imul(ue, Ue), T = Math.imul(ue, De), T = T + Math.imul(ce, Ue) | 0, D = Math.imul(ce, De), B = B + Math.imul(Re, Qe) | 0, T = T + Math.imul(Re, st) | 0, T = T + Math.imul(J, Qe) | 0, D = D + Math.imul(J, st) | 0, B = B + Math.imul(ge, tt) | 0, T = T + Math.imul(ge, it) | 0, T = T + Math.imul(Te, tt) | 0, D = D + Math.imul(Te, it) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, rt) | 0, D = D + Math.imul(Ge, dt) | 0, B = B + Math.imul(je, nt) | 0, T = T + Math.imul(je, at) | 0, T = T + Math.imul(Fe, nt) | 0, D = D + Math.imul(Fe, at) | 0, B = B + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Oe, ot) | 0, D = D + Math.imul(Oe, ct) | 0, B = B + Math.imul(N, ut) | 0, T = T + Math.imul(N, lt) | 0, T = T + Math.imul(re, ut) | 0, D = D + Math.imul(re, lt) | 0;
      var Nt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(ue, Qe), T = Math.imul(ue, st), T = T + Math.imul(ce, Qe) | 0, D = Math.imul(ce, st), B = B + Math.imul(Re, tt) | 0, T = T + Math.imul(Re, it) | 0, T = T + Math.imul(J, tt) | 0, D = D + Math.imul(J, it) | 0, B = B + Math.imul(ge, rt) | 0, T = T + Math.imul(ge, dt) | 0, T = T + Math.imul(Te, rt) | 0, D = D + Math.imul(Te, dt) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, nt) | 0, D = D + Math.imul(Ge, at) | 0, B = B + Math.imul(je, ot) | 0, T = T + Math.imul(je, ct) | 0, T = T + Math.imul(Fe, ot) | 0, D = D + Math.imul(Fe, ct) | 0, B = B + Math.imul(Ne, ut) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Oe, ut) | 0, D = D + Math.imul(Oe, lt) | 0;
      var Mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, B = Math.imul(ue, tt), T = Math.imul(ue, it), T = T + Math.imul(ce, tt) | 0, D = Math.imul(ce, it), B = B + Math.imul(Re, rt) | 0, T = T + Math.imul(Re, dt) | 0, T = T + Math.imul(J, rt) | 0, D = D + Math.imul(J, dt) | 0, B = B + Math.imul(ge, nt) | 0, T = T + Math.imul(ge, at) | 0, T = T + Math.imul(Te, nt) | 0, D = D + Math.imul(Te, at) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, D = D + Math.imul(Ge, ct) | 0, B = B + Math.imul(je, ut) | 0, T = T + Math.imul(je, lt) | 0, T = T + Math.imul(Fe, ut) | 0, D = D + Math.imul(Fe, lt) | 0;
      var Ot = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(ue, rt), T = Math.imul(ue, dt), T = T + Math.imul(ce, rt) | 0, D = Math.imul(ce, dt), B = B + Math.imul(Re, nt) | 0, T = T + Math.imul(Re, at) | 0, T = T + Math.imul(J, nt) | 0, D = D + Math.imul(J, at) | 0, B = B + Math.imul(ge, ot) | 0, T = T + Math.imul(ge, ct) | 0, T = T + Math.imul(Te, ot) | 0, D = D + Math.imul(Te, ct) | 0, B = B + Math.imul(Xe, ut) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, ut) | 0, D = D + Math.imul(Ge, lt) | 0;
      var $t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(ue, nt), T = Math.imul(ue, at), T = T + Math.imul(ce, nt) | 0, D = Math.imul(ce, at), B = B + Math.imul(Re, ot) | 0, T = T + Math.imul(Re, ct) | 0, T = T + Math.imul(J, ot) | 0, D = D + Math.imul(J, ct) | 0, B = B + Math.imul(ge, ut) | 0, T = T + Math.imul(ge, lt) | 0, T = T + Math.imul(Te, ut) | 0, D = D + Math.imul(Te, lt) | 0;
      var Bt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(ue, ot), T = Math.imul(ue, ct), T = T + Math.imul(ce, ot) | 0, D = Math.imul(ce, ct), B = B + Math.imul(Re, ut) | 0, T = T + Math.imul(Re, lt) | 0, T = T + Math.imul(J, ut) | 0, D = D + Math.imul(J, lt) | 0;
      var xt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, B = Math.imul(ue, ut), T = Math.imul(ue, lt), T = T + Math.imul(ce, ut) | 0, D = Math.imul(ce, lt);
      var Ut = (Y + B | 0) + ((T & 8191) << 13) | 0;
      return Y = (D + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, x[0] = kt, x[1] = Rt, x[2] = Je, x[3] = ze, x[4] = et, x[5] = pt, x[6] = mt, x[7] = vt, x[8] = ht, x[9] = _t, x[10] = Et, x[11] = Pt, x[12] = Nt, x[13] = Mt, x[14] = Ot, x[15] = $t, x[16] = Bt, x[17] = xt, x[18] = Ut, Y !== 0 && (x[19] = Y, k.length++), k;
    };
    Math.imul || (ie = X);
    function Q(C, b, E) {
      E.negative = b.negative ^ C.negative, E.length = C.length + b.length;
      for (var k = 0, O = 0, A = 0; A < E.length - 1; A++) {
        var x = O;
        O = 0;
        for (var Y = k & 67108863, B = Math.min(A, b.length - 1), T = Math.max(0, A - C.length + 1); T <= B; T++) {
          var D = A - T, te = C.words[D] | 0, me = b.words[T] | 0, Ie = te * me, $e = Ie & 67108863;
          x = x + (Ie / 67108864 | 0) | 0, $e = $e + Y | 0, Y = $e & 67108863, x = x + ($e >>> 26) | 0, O += x >>> 26, x &= 67108863;
        }
        E.words[A] = Y, k = x, x = O;
      }
      return k !== 0 ? E.words[A] = k : E.length--, E.strip();
    }
    function ne(C, b, E) {
      var k = new Z();
      return k.mulp(C, b, E);
    }
    p.prototype.mulTo = function(b, E) {
      var k, O = this.length + b.length;
      return this.length === 10 && b.length === 10 ? k = ie(this, b, E) : O < 63 ? k = X(this, b, E) : O < 1024 ? k = Q(this, b, E) : k = ne(this, b, E), k;
    };
    function Z(C, b) {
      this.x = C, this.y = b;
    }
    Z.prototype.makeRBT = function(b) {
      for (var E = new Array(b), k = p.prototype._countBits(b) - 1, O = 0; O < b; O++)
        E[O] = this.revBin(O, k, b);
      return E;
    }, Z.prototype.revBin = function(b, E, k) {
      if (b === 0 || b === k - 1)
        return b;
      for (var O = 0, A = 0; A < E; A++)
        O |= (b & 1) << E - A - 1, b >>= 1;
      return O;
    }, Z.prototype.permute = function(b, E, k, O, A, x) {
      for (var Y = 0; Y < x; Y++)
        O[Y] = E[b[Y]], A[Y] = k[b[Y]];
    }, Z.prototype.transform = function(b, E, k, O, A, x) {
      this.permute(x, b, E, k, O, A);
      for (var Y = 1; Y < A; Y <<= 1)
        for (var B = Y << 1, T = Math.cos(2 * Math.PI / B), D = Math.sin(2 * Math.PI / B), te = 0; te < A; te += B)
          for (var me = T, Ie = D, $e = 0; $e < Y; $e++) {
            var ye = k[te + $e], fe = O[te + $e], Me = k[te + $e + Y], Ae = O[te + $e + Y], xe = me * Me - Ie * Ae;
            Ae = me * Ae + Ie * Me, Me = xe, k[te + $e] = ye + Me, O[te + $e] = fe + Ae, k[te + $e + Y] = ye - Me, O[te + $e + Y] = fe - Ae, $e !== B && (xe = T * me - D * Ie, Ie = T * Ie + D * me, me = xe);
          }
    }, Z.prototype.guessLen13b = function(b, E) {
      var k = Math.max(E, b) | 1, O = k & 1, A = 0;
      for (k = k / 2 | 0; k; k = k >>> 1)
        A++;
      return 1 << A + 1 + O;
    }, Z.prototype.conjugate = function(b, E, k) {
      if (!(k <= 1))
        for (var O = 0; O < k / 2; O++) {
          var A = b[O];
          b[O] = b[k - O - 1], b[k - O - 1] = A, A = E[O], E[O] = -E[k - O - 1], E[k - O - 1] = -A;
        }
    }, Z.prototype.normalize13b = function(b, E) {
      for (var k = 0, O = 0; O < E / 2; O++) {
        var A = Math.round(b[2 * O + 1] / E) * 8192 + Math.round(b[2 * O] / E) + k;
        b[O] = A & 67108863, A < 67108864 ? k = 0 : k = A / 67108864 | 0;
      }
      return b;
    }, Z.prototype.convert13b = function(b, E, k, O) {
      for (var A = 0, x = 0; x < E; x++)
        A = A + (b[x] | 0), k[2 * x] = A & 8191, A = A >>> 13, k[2 * x + 1] = A & 8191, A = A >>> 13;
      for (x = 2 * E; x < O; ++x)
        k[x] = 0;
      l(A === 0), l((A & -8192) === 0);
    }, Z.prototype.stub = function(b) {
      for (var E = new Array(b), k = 0; k < b; k++)
        E[k] = 0;
      return E;
    }, Z.prototype.mulp = function(b, E, k) {
      var O = 2 * this.guessLen13b(b.length, E.length), A = this.makeRBT(O), x = this.stub(O), Y = new Array(O), B = new Array(O), T = new Array(O), D = new Array(O), te = new Array(O), me = new Array(O), Ie = k.words;
      Ie.length = O, this.convert13b(b.words, b.length, Y, O), this.convert13b(E.words, E.length, D, O), this.transform(Y, x, B, T, O, A), this.transform(D, x, te, me, O, A);
      for (var $e = 0; $e < O; $e++) {
        var ye = B[$e] * te[$e] - T[$e] * me[$e];
        T[$e] = B[$e] * me[$e] + T[$e] * te[$e], B[$e] = ye;
      }
      return this.conjugate(B, T, O), this.transform(B, T, Ie, x, O, A), this.conjugate(Ie, x, O), this.normalize13b(Ie, O), k.negative = b.negative ^ E.negative, k.length = b.length + E.length, k.strip();
    }, p.prototype.mul = function(b) {
      var E = new p(null);
      return E.words = new Array(this.length + b.length), this.mulTo(b, E);
    }, p.prototype.mulf = function(b) {
      var E = new p(null);
      return E.words = new Array(this.length + b.length), ne(this, b, E);
    }, p.prototype.imul = function(b) {
      return this.clone().mulTo(b, this);
    }, p.prototype.imuln = function(b) {
      l(typeof b == "number"), l(b < 67108864);
      for (var E = 0, k = 0; k < this.length; k++) {
        var O = (this.words[k] | 0) * b, A = (O & 67108863) + (E & 67108863);
        E >>= 26, E += O / 67108864 | 0, E += A >>> 26, this.words[k] = A & 67108863;
      }
      return E !== 0 && (this.words[k] = E, this.length++), this;
    }, p.prototype.muln = function(b) {
      return this.clone().imuln(b);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(b) {
      var E = ee(b);
      if (E.length === 0)
        return new p(1);
      for (var k = this, O = 0; O < E.length && E[O] === 0; O++, k = k.sqr())
        ;
      if (++O < E.length)
        for (var A = k.sqr(); O < E.length; O++, A = A.sqr())
          E[O] !== 0 && (k = k.mul(A));
      return k;
    }, p.prototype.iushln = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26, O = 67108863 >>> 26 - E << 26 - E, A;
      if (E !== 0) {
        var x = 0;
        for (A = 0; A < this.length; A++) {
          var Y = this.words[A] & O, B = (this.words[A] | 0) - Y << E;
          this.words[A] = B | x, x = Y >>> 26 - E;
        }
        x && (this.words[A] = x, this.length++);
      }
      if (k !== 0) {
        for (A = this.length - 1; A >= 0; A--)
          this.words[A + k] = this.words[A];
        for (A = 0; A < k; A++)
          this.words[A] = 0;
        this.length += k;
      }
      return this.strip();
    }, p.prototype.ishln = function(b) {
      return l(this.negative === 0), this.iushln(b);
    }, p.prototype.iushrn = function(b, E, k) {
      l(typeof b == "number" && b >= 0);
      var O;
      E ? O = (E - E % 26) / 26 : O = 0;
      var A = b % 26, x = Math.min((b - A) / 26, this.length), Y = 67108863 ^ 67108863 >>> A << A, B = k;
      if (O -= x, O = Math.max(0, O), B) {
        for (var T = 0; T < x; T++)
          B.words[T] = this.words[T];
        B.length = x;
      }
      if (x !== 0)
        if (this.length > x)
          for (this.length -= x, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + x];
        else
          this.words[0] = 0, this.length = 1;
      var D = 0;
      for (T = this.length - 1; T >= 0 && (D !== 0 || T >= O); T--) {
        var te = this.words[T] | 0;
        this.words[T] = D << 26 - A | te >>> A, D = te & Y;
      }
      return B && D !== 0 && (B.words[B.length++] = D), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(b, E, k) {
      return l(this.negative === 0), this.iushrn(b, E, k);
    }, p.prototype.shln = function(b) {
      return this.clone().ishln(b);
    }, p.prototype.ushln = function(b) {
      return this.clone().iushln(b);
    }, p.prototype.shrn = function(b) {
      return this.clone().ishrn(b);
    }, p.prototype.ushrn = function(b) {
      return this.clone().iushrn(b);
    }, p.prototype.testn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26, O = 1 << E;
      if (this.length <= k)
        return !1;
      var A = this.words[k];
      return !!(A & O);
    }, p.prototype.imaskn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= k)
        return this;
      if (E !== 0 && k++, this.length = Math.min(k, this.length), E !== 0) {
        var O = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= O;
      }
      return this.strip();
    }, p.prototype.maskn = function(b) {
      return this.clone().imaskn(b);
    }, p.prototype.iaddn = function(b) {
      return l(typeof b == "number"), l(b < 67108864), b < 0 ? this.isubn(-b) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < b ? (this.words[0] = b - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(b), this.negative = 1, this) : this._iaddn(b);
    }, p.prototype._iaddn = function(b) {
      this.words[0] += b;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(b) {
      if (l(typeof b == "number"), l(b < 67108864), b < 0)
        return this.iaddn(-b);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(b), this.negative = 1, this;
      if (this.words[0] -= b, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(b) {
      return this.clone().iaddn(b);
    }, p.prototype.subn = function(b) {
      return this.clone().isubn(b);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(b, E, k) {
      var O = b.length + k, A;
      this._expand(O);
      var x, Y = 0;
      for (A = 0; A < b.length; A++) {
        x = (this.words[A + k] | 0) + Y;
        var B = (b.words[A] | 0) * E;
        x -= B & 67108863, Y = (x >> 26) - (B / 67108864 | 0), this.words[A + k] = x & 67108863;
      }
      for (; A < this.length - k; A++)
        x = (this.words[A + k] | 0) + Y, Y = x >> 26, this.words[A + k] = x & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, A = 0; A < this.length; A++)
        x = -(this.words[A] | 0) + Y, Y = x >> 26, this.words[A] = x & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(b, E) {
      var k = this.length - b.length, O = this.clone(), A = b, x = A.words[A.length - 1] | 0, Y = this._countBits(x);
      k = 26 - Y, k !== 0 && (A = A.ushln(k), O.iushln(k), x = A.words[A.length - 1] | 0);
      var B = O.length - A.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var D = 0; D < T.length; D++)
          T.words[D] = 0;
      }
      var te = O.clone()._ishlnsubmul(A, 1, B);
      te.negative === 0 && (O = te, T && (T.words[B] = 1));
      for (var me = B - 1; me >= 0; me--) {
        var Ie = (O.words[A.length + me] | 0) * 67108864 + (O.words[A.length + me - 1] | 0);
        for (Ie = Math.min(Ie / x | 0, 67108863), O._ishlnsubmul(A, Ie, me); O.negative !== 0; )
          Ie--, O.negative = 0, O._ishlnsubmul(A, 1, me), O.isZero() || (O.negative ^= 1);
        T && (T.words[me] = Ie);
      }
      return T && T.strip(), O.strip(), E !== "div" && k !== 0 && O.iushrn(k), {
        div: T || null,
        mod: O
      };
    }, p.prototype.divmod = function(b, E, k) {
      if (l(!b.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var O, A, x;
      return this.negative !== 0 && b.negative === 0 ? (x = this.neg().divmod(b, E), E !== "mod" && (O = x.div.neg()), E !== "div" && (A = x.mod.neg(), k && A.negative !== 0 && A.iadd(b)), {
        div: O,
        mod: A
      }) : this.negative === 0 && b.negative !== 0 ? (x = this.divmod(b.neg(), E), E !== "mod" && (O = x.div.neg()), {
        div: O,
        mod: x.mod
      }) : this.negative & b.negative ? (x = this.neg().divmod(b.neg(), E), E !== "div" && (A = x.mod.neg(), k && A.negative !== 0 && A.isub(b)), {
        div: x.div,
        mod: A
      }) : b.length > this.length || this.cmp(b) < 0 ? {
        div: new p(0),
        mod: this
      } : b.length === 1 ? E === "div" ? {
        div: this.divn(b.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(b.words[0]))
      } : {
        div: this.divn(b.words[0]),
        mod: new p(this.modn(b.words[0]))
      } : this._wordDiv(b, E);
    }, p.prototype.div = function(b) {
      return this.divmod(b, "div", !1).div;
    }, p.prototype.mod = function(b) {
      return this.divmod(b, "mod", !1).mod;
    }, p.prototype.umod = function(b) {
      return this.divmod(b, "mod", !0).mod;
    }, p.prototype.divRound = function(b) {
      var E = this.divmod(b);
      if (E.mod.isZero())
        return E.div;
      var k = E.div.negative !== 0 ? E.mod.isub(b) : E.mod, O = b.ushrn(1), A = b.andln(1), x = k.cmp(O);
      return x < 0 || A === 1 && x === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(b) {
      l(b <= 67108863);
      for (var E = (1 << 26) % b, k = 0, O = this.length - 1; O >= 0; O--)
        k = (E * k + (this.words[O] | 0)) % b;
      return k;
    }, p.prototype.idivn = function(b) {
      l(b <= 67108863);
      for (var E = 0, k = this.length - 1; k >= 0; k--) {
        var O = (this.words[k] | 0) + E * 67108864;
        this.words[k] = O / b | 0, E = O % b;
      }
      return this.strip();
    }, p.prototype.divn = function(b) {
      return this.clone().idivn(b);
    }, p.prototype.egcd = function(b) {
      l(b.negative === 0), l(!b.isZero());
      var E = this, k = b.clone();
      E.negative !== 0 ? E = E.umod(b) : E = E.clone();
      for (var O = new p(1), A = new p(0), x = new p(0), Y = new p(1), B = 0; E.isEven() && k.isEven(); )
        E.iushrn(1), k.iushrn(1), ++B;
      for (var T = k.clone(), D = E.clone(); !E.isZero(); ) {
        for (var te = 0, me = 1; !(E.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (O.isOdd() || A.isOdd()) && (O.iadd(T), A.isub(D)), O.iushrn(1), A.iushrn(1);
        for (var Ie = 0, $e = 1; !(k.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (k.iushrn(Ie); Ie-- > 0; )
            (x.isOdd() || Y.isOdd()) && (x.iadd(T), Y.isub(D)), x.iushrn(1), Y.iushrn(1);
        E.cmp(k) >= 0 ? (E.isub(k), O.isub(x), A.isub(Y)) : (k.isub(E), x.isub(O), Y.isub(A));
      }
      return {
        a: x,
        b: Y,
        gcd: k.iushln(B)
      };
    }, p.prototype._invmp = function(b) {
      l(b.negative === 0), l(!b.isZero());
      var E = this, k = b.clone();
      E.negative !== 0 ? E = E.umod(b) : E = E.clone();
      for (var O = new p(1), A = new p(0), x = k.clone(); E.cmpn(1) > 0 && k.cmpn(1) > 0; ) {
        for (var Y = 0, B = 1; !(E.words[0] & B) && Y < 26; ++Y, B <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            O.isOdd() && O.iadd(x), O.iushrn(1);
        for (var T = 0, D = 1; !(k.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (k.iushrn(T); T-- > 0; )
            A.isOdd() && A.iadd(x), A.iushrn(1);
        E.cmp(k) >= 0 ? (E.isub(k), O.isub(A)) : (k.isub(E), A.isub(O));
      }
      var te;
      return E.cmpn(1) === 0 ? te = O : te = A, te.cmpn(0) < 0 && te.iadd(b), te;
    }, p.prototype.gcd = function(b) {
      if (this.isZero())
        return b.abs();
      if (b.isZero())
        return this.abs();
      var E = this.clone(), k = b.clone();
      E.negative = 0, k.negative = 0;
      for (var O = 0; E.isEven() && k.isEven(); O++)
        E.iushrn(1), k.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; k.isEven(); )
          k.iushrn(1);
        var A = E.cmp(k);
        if (A < 0) {
          var x = E;
          E = k, k = x;
        } else if (A === 0 || k.cmpn(1) === 0)
          break;
        E.isub(k);
      } while (!0);
      return k.iushln(O);
    }, p.prototype.invm = function(b) {
      return this.egcd(b).a.umod(b);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(b) {
      return this.words[0] & b;
    }, p.prototype.bincn = function(b) {
      l(typeof b == "number");
      var E = b % 26, k = (b - E) / 26, O = 1 << E;
      if (this.length <= k)
        return this._expand(k + 1), this.words[k] |= O, this;
      for (var A = O, x = k; A !== 0 && x < this.length; x++) {
        var Y = this.words[x] | 0;
        Y += A, A = Y >>> 26, Y &= 67108863, this.words[x] = Y;
      }
      return A !== 0 && (this.words[x] = A, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(b) {
      var E = b < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var k;
      if (this.length > 1)
        k = 1;
      else {
        E && (b = -b), l(b <= 67108863, "Number is too big");
        var O = this.words[0] | 0;
        k = O === b ? 0 : O < b ? -1 : 1;
      }
      return this.negative !== 0 ? -k | 0 : k;
    }, p.prototype.cmp = function(b) {
      if (this.negative !== 0 && b.negative === 0)
        return -1;
      if (this.negative === 0 && b.negative !== 0)
        return 1;
      var E = this.ucmp(b);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(b) {
      if (this.length > b.length)
        return 1;
      if (this.length < b.length)
        return -1;
      for (var E = 0, k = this.length - 1; k >= 0; k--) {
        var O = this.words[k] | 0, A = b.words[k] | 0;
        if (O !== A) {
          O < A ? E = -1 : O > A && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(b) {
      return this.cmpn(b) === 1;
    }, p.prototype.gt = function(b) {
      return this.cmp(b) === 1;
    }, p.prototype.gten = function(b) {
      return this.cmpn(b) >= 0;
    }, p.prototype.gte = function(b) {
      return this.cmp(b) >= 0;
    }, p.prototype.ltn = function(b) {
      return this.cmpn(b) === -1;
    }, p.prototype.lt = function(b) {
      return this.cmp(b) === -1;
    }, p.prototype.lten = function(b) {
      return this.cmpn(b) <= 0;
    }, p.prototype.lte = function(b) {
      return this.cmp(b) <= 0;
    }, p.prototype.eqn = function(b) {
      return this.cmpn(b) === 0;
    }, p.prototype.eq = function(b) {
      return this.cmp(b) === 0;
    }, p.red = function(b) {
      return new q(b);
    }, p.prototype.toRed = function(b) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), b.convertTo(this)._forceRed(b);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(b) {
      return this.red = b, this;
    }, p.prototype.forceRed = function(b) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(b);
    }, p.prototype.redAdd = function(b) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, b);
    }, p.prototype.redIAdd = function(b) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, b);
    }, p.prototype.redSub = function(b) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, b);
    }, p.prototype.redISub = function(b) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, b);
    }, p.prototype.redShl = function(b) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, b);
    }, p.prototype.redMul = function(b) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.mul(this, b);
    }, p.prototype.redIMul = function(b) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.imul(this, b);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(b) {
      return l(this.red && !b.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, b);
    };
    var de = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function he(C, b) {
      this.name = C, this.p = new p(b, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    he.prototype._tmp = function() {
      var b = new p(null);
      return b.words = new Array(Math.ceil(this.n / 13)), b;
    }, he.prototype.ireduce = function(b) {
      var E = b, k;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), k = E.bitLength();
      while (k > this.n);
      var O = k < this.n ? -1 : E.ucmp(this.p);
      return O === 0 ? (E.words[0] = 0, E.length = 1) : O > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, he.prototype.split = function(b, E) {
      b.iushrn(this.n, 0, E);
    }, he.prototype.imulK = function(b) {
      return b.imul(this.k);
    };
    function pe() {
      he.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(pe, he), pe.prototype.split = function(b, E) {
      for (var k = 4194303, O = Math.min(b.length, 9), A = 0; A < O; A++)
        E.words[A] = b.words[A];
      if (E.length = O, b.length <= 9) {
        b.words[0] = 0, b.length = 1;
        return;
      }
      var x = b.words[9];
      for (E.words[E.length++] = x & k, A = 10; A < b.length; A++) {
        var Y = b.words[A] | 0;
        b.words[A - 10] = (Y & k) << 4 | x >>> 22, x = Y;
      }
      x >>>= 22, b.words[A - 10] = x, x === 0 && b.length > 10 ? b.length -= 10 : b.length -= 9;
    }, pe.prototype.imulK = function(b) {
      b.words[b.length] = 0, b.words[b.length + 1] = 0, b.length += 2;
      for (var E = 0, k = 0; k < b.length; k++) {
        var O = b.words[k] | 0;
        E += O * 977, b.words[k] = E & 67108863, E = O * 64 + (E / 67108864 | 0);
      }
      return b.words[b.length - 1] === 0 && (b.length--, b.words[b.length - 1] === 0 && b.length--), b;
    };
    function be() {
      he.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(be, he);
    function ke() {
      he.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(ke, he);
    function _e() {
      he.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(_e, he), _e.prototype.imulK = function(b) {
      for (var E = 0, k = 0; k < b.length; k++) {
        var O = (b.words[k] | 0) * 19 + E, A = O & 67108863;
        O >>>= 26, b.words[k] = A, E = O;
      }
      return E !== 0 && (b.words[b.length++] = E), b;
    }, p._prime = function(b) {
      if (de[b])
        return de[b];
      var E;
      if (b === "k256")
        E = new pe();
      else if (b === "p224")
        E = new be();
      else if (b === "p192")
        E = new ke();
      else if (b === "p25519")
        E = new _e();
      else
        throw new Error("Unknown prime " + b);
      return de[b] = E, E;
    };
    function q(C) {
      if (typeof C == "string") {
        var b = p._prime(C);
        this.m = b.p, this.prime = b;
      } else
        l(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    q.prototype._verify1 = function(b) {
      l(b.negative === 0, "red works only with positives"), l(b.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(b, E) {
      l((b.negative | E.negative) === 0, "red works only with positives"), l(
        b.red && b.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(b) {
      return this.prime ? this.prime.ireduce(b)._forceRed(this) : b.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(b) {
      return b.isZero() ? b.clone() : this.m.sub(b)._forceRed(this);
    }, q.prototype.add = function(b, E) {
      this._verify2(b, E);
      var k = b.add(E);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k._forceRed(this);
    }, q.prototype.iadd = function(b, E) {
      this._verify2(b, E);
      var k = b.iadd(E);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k;
    }, q.prototype.sub = function(b, E) {
      this._verify2(b, E);
      var k = b.sub(E);
      return k.cmpn(0) < 0 && k.iadd(this.m), k._forceRed(this);
    }, q.prototype.isub = function(b, E) {
      this._verify2(b, E);
      var k = b.isub(E);
      return k.cmpn(0) < 0 && k.iadd(this.m), k;
    }, q.prototype.shl = function(b, E) {
      return this._verify1(b), this.imod(b.ushln(E));
    }, q.prototype.imul = function(b, E) {
      return this._verify2(b, E), this.imod(b.imul(E));
    }, q.prototype.mul = function(b, E) {
      return this._verify2(b, E), this.imod(b.mul(E));
    }, q.prototype.isqr = function(b) {
      return this.imul(b, b.clone());
    }, q.prototype.sqr = function(b) {
      return this.mul(b, b);
    }, q.prototype.sqrt = function(b) {
      if (b.isZero())
        return b.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var k = this.m.add(new p(1)).iushrn(2);
        return this.pow(b, k);
      }
      for (var O = this.m.subn(1), A = 0; !O.isZero() && O.andln(1) === 0; )
        A++, O.iushrn(1);
      l(!O.isZero());
      var x = new p(1).toRed(this), Y = x.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var D = this.pow(T, O), te = this.pow(b, O.addn(1).iushrn(1)), me = this.pow(b, O), Ie = A; me.cmp(x) !== 0; ) {
        for (var $e = me, ye = 0; $e.cmp(x) !== 0; ye++)
          $e = $e.redSqr();
        l(ye < Ie);
        var fe = this.pow(D, new p(1).iushln(Ie - ye - 1));
        te = te.redMul(fe), D = fe.redSqr(), me = me.redMul(D), Ie = ye;
      }
      return te;
    }, q.prototype.invm = function(b) {
      var E = b._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(b, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return b.clone();
      var k = 4, O = new Array(1 << k);
      O[0] = new p(1).toRed(this), O[1] = b;
      for (var A = 2; A < O.length; A++)
        O[A] = this.mul(O[A - 1], b);
      var x = O[0], Y = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), A = E.length - 1; A >= 0; A--) {
        for (var D = E.words[A], te = T - 1; te >= 0; te--) {
          var me = D >> te & 1;
          if (x !== O[0] && (x = this.sqr(x)), me === 0 && Y === 0) {
            B = 0;
            continue;
          }
          Y <<= 1, Y |= me, B++, !(B !== k && (A !== 0 || te !== 0)) && (x = this.mul(x, O[Y]), B = 0, Y = 0);
        }
        T = 26;
      }
      return x;
    }, q.prototype.convertTo = function(b) {
      var E = b.umod(this.m);
      return E === b ? E.clone() : E;
    }, q.prototype.convertFrom = function(b) {
      var E = b.clone();
      return E.red = null, E;
    }, p.mont = function(b) {
      return new z(b);
    };
    function z(C) {
      q.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, q), z.prototype.convertTo = function(b) {
      return this.imod(b.ushln(this.shift));
    }, z.prototype.convertFrom = function(b) {
      var E = this.imod(b.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(b, E) {
      if (b.isZero() || E.isZero())
        return b.words[0] = 0, b.length = 1, b;
      var k = b.imul(E), O = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = k.isub(O).iushrn(this.shift), x = A;
      return A.cmp(this.m) >= 0 ? x = A.isub(this.m) : A.cmpn(0) < 0 && (x = A.iadd(this.m)), x._forceRed(this);
    }, z.prototype.mul = function(b, E) {
      if (b.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var k = b.mul(E), O = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = k.isub(O).iushrn(this.shift), x = A;
      return A.cmp(this.m) >= 0 ? x = A.isub(this.m) : A.cmpn(0) < 0 && (x = A.iadd(this.m)), x._forceRed(this);
    }, z.prototype.invm = function(b) {
      var E = this.imod(b._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$6);
var bnExports$6 = bn$6.exports, bn$5 = { exports: {} };
bn$5.exports;
(function(a) {
  (function(u, c) {
    function l(C, b) {
      if (!C)
        throw new Error(b || "Assertion failed");
    }
    function v(C, b) {
      C.super_ = b;
      var E = function() {
      };
      E.prototype = b.prototype, C.prototype = new E(), C.prototype.constructor = C;
    }
    function p(C, b, E) {
      if (p.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((b === "le" || b === "be") && (E = b, b = 10), this._init(C || 0, b || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(b) {
      return b instanceof p ? !0 : b !== null && typeof b == "object" && b.constructor.wordSize === p.wordSize && Array.isArray(b.words);
    }, p.max = function(b, E) {
      return b.cmp(E) > 0 ? b : E;
    }, p.min = function(b, E) {
      return b.cmp(E) < 0 ? b : E;
    }, p.prototype._init = function(b, E, k) {
      if (typeof b == "number")
        return this._initNumber(b, E, k);
      if (typeof b == "object")
        return this._initArray(b, E, k);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), b = b.toString().replace(/\s+/g, "");
      var O = 0;
      b[0] === "-" && (O++, this.negative = 1), O < b.length && (E === 16 ? this._parseHex(b, O, k) : (this._parseBase(b, E, O), k === "le" && this._initArray(this.toArray(), E, k)));
    }, p.prototype._initNumber = function(b, E, k) {
      b < 0 && (this.negative = 1, b = -b), b < 67108864 ? (this.words = [b & 67108863], this.length = 1) : b < 4503599627370496 ? (this.words = [
        b & 67108863,
        b / 67108864 & 67108863
      ], this.length = 2) : (l(b < 9007199254740992), this.words = [
        b & 67108863,
        b / 67108864 & 67108863,
        1
      ], this.length = 3), k === "le" && this._initArray(this.toArray(), E, k);
    }, p.prototype._initArray = function(b, E, k) {
      if (l(typeof b.length == "number"), b.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(b.length / 3), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var A, x, Y = 0;
      if (k === "be")
        for (O = b.length - 1, A = 0; O >= 0; O -= 3)
          x = b[O] | b[O - 1] << 8 | b[O - 2] << 16, this.words[A] |= x << Y & 67108863, this.words[A + 1] = x >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, A++);
      else if (k === "le")
        for (O = 0, A = 0; O < b.length; O += 3)
          x = b[O] | b[O + 1] << 8 | b[O + 2] << 16, this.words[A] |= x << Y & 67108863, this.words[A + 1] = x >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, A++);
      return this.strip();
    };
    function I(C, b) {
      var E = C.charCodeAt(b);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function P(C, b, E) {
      var k = I(C, E);
      return E - 1 >= b && (k |= I(C, E - 1) << 4), k;
    }
    p.prototype._parseHex = function(b, E, k) {
      this.length = Math.ceil((b.length - E) / 6), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var A = 0, x = 0, Y;
      if (k === "be")
        for (O = b.length - 1; O >= E; O -= 2)
          Y = P(b, E, O) << A, this.words[x] |= Y & 67108863, A >= 18 ? (A -= 18, x += 1, this.words[x] |= Y >>> 26) : A += 8;
      else {
        var B = b.length - E;
        for (O = B % 2 === 0 ? E + 1 : E; O < b.length; O += 2)
          Y = P(b, E, O) << A, this.words[x] |= Y & 67108863, A >= 18 ? (A -= 18, x += 1, this.words[x] |= Y >>> 26) : A += 8;
      }
      this.strip();
    };
    function $(C, b, E, k) {
      for (var O = 0, A = Math.min(C.length, E), x = b; x < A; x++) {
        var Y = C.charCodeAt(x) - 48;
        O *= k, Y >= 49 ? O += Y - 49 + 10 : Y >= 17 ? O += Y - 17 + 10 : O += Y;
      }
      return O;
    }
    p.prototype._parseBase = function(b, E, k) {
      this.words = [0], this.length = 1;
      for (var O = 0, A = 1; A <= 67108863; A *= E)
        O++;
      O--, A = A / E | 0;
      for (var x = b.length - k, Y = x % O, B = Math.min(x, x - Y) + k, T = 0, D = k; D < B; D += O)
        T = $(b, D, D + O, E), this.imuln(A), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = $(b, D, b.length, E), D = 0; D < Y; D++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(b) {
      b.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        b.words[E] = this.words[E];
      b.length = this.length, b.negative = this.negative, b.red = this.red;
    }, p.prototype.clone = function() {
      var b = new p(null);
      return this.copy(b), b;
    }, p.prototype._expand = function(b) {
      for (; this.length < b; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], H = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], j = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(b, E) {
      b = b || 10, E = E | 0 || 1;
      var k;
      if (b === 16 || b === "hex") {
        k = "";
        for (var O = 0, A = 0, x = 0; x < this.length; x++) {
          var Y = this.words[x], B = ((Y << O | A) & 16777215).toString(16);
          A = Y >>> 24 - O & 16777215, A !== 0 || x !== this.length - 1 ? k = F[6 - B.length] + B + k : k = B + k, O += 2, O >= 26 && (O -= 26, x--);
        }
        for (A !== 0 && (k = A.toString(16) + k); k.length % E !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      if (b === (b | 0) && b >= 2 && b <= 36) {
        var T = H[b], D = j[b];
        k = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var me = te.modn(D).toString(b);
          te = te.idivn(D), te.isZero() ? k = me + k : k = F[T - me.length] + me + k;
        }
        for (this.isZero() && (k = "0" + k); k.length % E !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var b = this.words[0];
      return this.length === 2 ? b += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? b += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -b : b;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(b, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, b, E);
    }, p.prototype.toArray = function(b, E) {
      return this.toArrayLike(Array, b, E);
    }, p.prototype.toArrayLike = function(b, E, k) {
      var O = this.byteLength(), A = k || Math.max(1, O);
      l(O <= A, "byte array longer than desired length"), l(A > 0, "Requested array length <= 0"), this.strip();
      var x = E === "le", Y = new b(A), B, T, D = this.clone();
      if (x) {
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), Y[T] = B;
        for (; T < A; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < A - O; T++)
          Y[T] = 0;
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), Y[A - T - 1] = B;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(b) {
      return 32 - Math.clz32(b);
    } : p.prototype._countBits = function(b) {
      var E = b, k = 0;
      return E >= 4096 && (k += 13, E >>>= 13), E >= 64 && (k += 7, E >>>= 7), E >= 8 && (k += 4, E >>>= 4), E >= 2 && (k += 2, E >>>= 2), k + E;
    }, p.prototype._zeroBits = function(b) {
      if (b === 0)
        return 26;
      var E = b, k = 0;
      return E & 8191 || (k += 13, E >>>= 13), E & 127 || (k += 7, E >>>= 7), E & 15 || (k += 4, E >>>= 4), E & 3 || (k += 2, E >>>= 2), E & 1 || k++, k;
    }, p.prototype.bitLength = function() {
      var b = this.words[this.length - 1], E = this._countBits(b);
      return (this.length - 1) * 26 + E;
    };
    function ee(C) {
      for (var b = new Array(C.bitLength()), E = 0; E < b.length; E++) {
        var k = E / 26 | 0, O = E % 26;
        b[E] = (C.words[k] & 1 << O) >>> O;
      }
      return b;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var b = 0, E = 0; E < this.length; E++) {
        var k = this._zeroBits(this.words[E]);
        if (b += k, k !== 26)
          break;
      }
      return b;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(b) {
      return this.negative !== 0 ? this.abs().inotn(b).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(b) {
      return this.testn(b - 1) ? this.notn(b).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(b) {
      for (; this.length < b.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < b.length; E++)
        this.words[E] = this.words[E] | b.words[E];
      return this.strip();
    }, p.prototype.ior = function(b) {
      return l((this.negative | b.negative) === 0), this.iuor(b);
    }, p.prototype.or = function(b) {
      return this.length > b.length ? this.clone().ior(b) : b.clone().ior(this);
    }, p.prototype.uor = function(b) {
      return this.length > b.length ? this.clone().iuor(b) : b.clone().iuor(this);
    }, p.prototype.iuand = function(b) {
      var E;
      this.length > b.length ? E = b : E = this;
      for (var k = 0; k < E.length; k++)
        this.words[k] = this.words[k] & b.words[k];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(b) {
      return l((this.negative | b.negative) === 0), this.iuand(b);
    }, p.prototype.and = function(b) {
      return this.length > b.length ? this.clone().iand(b) : b.clone().iand(this);
    }, p.prototype.uand = function(b) {
      return this.length > b.length ? this.clone().iuand(b) : b.clone().iuand(this);
    }, p.prototype.iuxor = function(b) {
      var E, k;
      this.length > b.length ? (E = this, k = b) : (E = b, k = this);
      for (var O = 0; O < k.length; O++)
        this.words[O] = E.words[O] ^ k.words[O];
      if (this !== E)
        for (; O < E.length; O++)
          this.words[O] = E.words[O];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(b) {
      return l((this.negative | b.negative) === 0), this.iuxor(b);
    }, p.prototype.xor = function(b) {
      return this.length > b.length ? this.clone().ixor(b) : b.clone().ixor(this);
    }, p.prototype.uxor = function(b) {
      return this.length > b.length ? this.clone().iuxor(b) : b.clone().iuxor(this);
    }, p.prototype.inotn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = Math.ceil(b / 26) | 0, k = b % 26;
      this._expand(E), k > 0 && E--;
      for (var O = 0; O < E; O++)
        this.words[O] = ~this.words[O] & 67108863;
      return k > 0 && (this.words[O] = ~this.words[O] & 67108863 >> 26 - k), this.strip();
    }, p.prototype.notn = function(b) {
      return this.clone().inotn(b);
    }, p.prototype.setn = function(b, E) {
      l(typeof b == "number" && b >= 0);
      var k = b / 26 | 0, O = b % 26;
      return this._expand(k + 1), E ? this.words[k] = this.words[k] | 1 << O : this.words[k] = this.words[k] & ~(1 << O), this.strip();
    }, p.prototype.iadd = function(b) {
      var E;
      if (this.negative !== 0 && b.negative === 0)
        return this.negative = 0, E = this.isub(b), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && b.negative !== 0)
        return b.negative = 0, E = this.isub(b), b.negative = 1, E._normSign();
      var k, O;
      this.length > b.length ? (k = this, O = b) : (k = b, O = this);
      for (var A = 0, x = 0; x < O.length; x++)
        E = (k.words[x] | 0) + (O.words[x] | 0) + A, this.words[x] = E & 67108863, A = E >>> 26;
      for (; A !== 0 && x < k.length; x++)
        E = (k.words[x] | 0) + A, this.words[x] = E & 67108863, A = E >>> 26;
      if (this.length = k.length, A !== 0)
        this.words[this.length] = A, this.length++;
      else if (k !== this)
        for (; x < k.length; x++)
          this.words[x] = k.words[x];
      return this;
    }, p.prototype.add = function(b) {
      var E;
      return b.negative !== 0 && this.negative === 0 ? (b.negative = 0, E = this.sub(b), b.negative ^= 1, E) : b.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = b.sub(this), this.negative = 1, E) : this.length > b.length ? this.clone().iadd(b) : b.clone().iadd(this);
    }, p.prototype.isub = function(b) {
      if (b.negative !== 0) {
        b.negative = 0;
        var E = this.iadd(b);
        return b.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(b), this.negative = 1, this._normSign();
      var k = this.cmp(b);
      if (k === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var O, A;
      k > 0 ? (O = this, A = b) : (O = b, A = this);
      for (var x = 0, Y = 0; Y < A.length; Y++)
        E = (O.words[Y] | 0) - (A.words[Y] | 0) + x, x = E >> 26, this.words[Y] = E & 67108863;
      for (; x !== 0 && Y < O.length; Y++)
        E = (O.words[Y] | 0) + x, x = E >> 26, this.words[Y] = E & 67108863;
      if (x === 0 && Y < O.length && O !== this)
        for (; Y < O.length; Y++)
          this.words[Y] = O.words[Y];
      return this.length = Math.max(this.length, Y), O !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(b) {
      return this.clone().isub(b);
    };
    function X(C, b, E) {
      E.negative = b.negative ^ C.negative;
      var k = C.length + b.length | 0;
      E.length = k, k = k - 1 | 0;
      var O = C.words[0] | 0, A = b.words[0] | 0, x = O * A, Y = x & 67108863, B = x / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < k; T++) {
        for (var D = B >>> 26, te = B & 67108863, me = Math.min(T, b.length - 1), Ie = Math.max(0, T - C.length + 1); Ie <= me; Ie++) {
          var $e = T - Ie | 0;
          O = C.words[$e] | 0, A = b.words[Ie] | 0, x = O * A + te, D += x / 67108864 | 0, te = x & 67108863;
        }
        E.words[T] = te | 0, B = D | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ie = function(b, E, k) {
      var O = b.words, A = E.words, x = k.words, Y = 0, B, T, D, te = O[0] | 0, me = te & 8191, Ie = te >>> 13, $e = O[1] | 0, ye = $e & 8191, fe = $e >>> 13, Me = O[2] | 0, Ae = Me & 8191, xe = Me >>> 13, ae = O[3] | 0, N = ae & 8191, re = ae >>> 13, le = O[4] | 0, Ne = le & 8191, Oe = le >>> 13, qe = O[5] | 0, je = qe & 8191, Fe = qe >>> 13, yt = O[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, V = O[7] | 0, ge = V & 8191, Te = V >>> 13, We = O[8] | 0, Re = We & 8191, J = We >>> 13, Ee = O[9] | 0, ue = Ee & 8191, ce = Ee >>> 13, ve = A[0] | 0, Ce = ve & 8191, Be = ve >>> 13, He = A[1] | 0, Ve = He & 8191, Ze = He >>> 13, Ke = A[2] | 0, U = Ke & 8191, se = Ke >>> 13, Se = A[3] | 0, Ue = Se & 8191, De = Se >>> 13, Ye = A[4] | 0, Qe = Ye & 8191, st = Ye >>> 13, St = A[5] | 0, tt = St & 8191, it = St >>> 13, Tt = A[6] | 0, rt = Tt & 8191, dt = Tt >>> 13, wt = A[7] | 0, nt = wt & 8191, at = wt >>> 13, gt = A[8] | 0, ot = gt & 8191, ct = gt >>> 13, Ct = A[9] | 0, ut = Ct & 8191, lt = Ct >>> 13;
      k.negative = b.negative ^ E.negative, k.length = 19, B = Math.imul(me, Ce), T = Math.imul(me, Be), T = T + Math.imul(Ie, Ce) | 0, D = Math.imul(Ie, Be);
      var kt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, B = Math.imul(ye, Ce), T = Math.imul(ye, Be), T = T + Math.imul(fe, Ce) | 0, D = Math.imul(fe, Be), B = B + Math.imul(me, Ve) | 0, T = T + Math.imul(me, Ze) | 0, T = T + Math.imul(Ie, Ve) | 0, D = D + Math.imul(Ie, Ze) | 0;
      var Rt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(Ae, Ce), T = Math.imul(Ae, Be), T = T + Math.imul(xe, Ce) | 0, D = Math.imul(xe, Be), B = B + Math.imul(ye, Ve) | 0, T = T + Math.imul(ye, Ze) | 0, T = T + Math.imul(fe, Ve) | 0, D = D + Math.imul(fe, Ze) | 0, B = B + Math.imul(me, U) | 0, T = T + Math.imul(me, se) | 0, T = T + Math.imul(Ie, U) | 0, D = D + Math.imul(Ie, se) | 0;
      var Je = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, B = Math.imul(N, Ce), T = Math.imul(N, Be), T = T + Math.imul(re, Ce) | 0, D = Math.imul(re, Be), B = B + Math.imul(Ae, Ve) | 0, T = T + Math.imul(Ae, Ze) | 0, T = T + Math.imul(xe, Ve) | 0, D = D + Math.imul(xe, Ze) | 0, B = B + Math.imul(ye, U) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(fe, U) | 0, D = D + Math.imul(fe, se) | 0, B = B + Math.imul(me, Ue) | 0, T = T + Math.imul(me, De) | 0, T = T + Math.imul(Ie, Ue) | 0, D = D + Math.imul(Ie, De) | 0;
      var ze = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, B = Math.imul(Ne, Ce), T = Math.imul(Ne, Be), T = T + Math.imul(Oe, Ce) | 0, D = Math.imul(Oe, Be), B = B + Math.imul(N, Ve) | 0, T = T + Math.imul(N, Ze) | 0, T = T + Math.imul(re, Ve) | 0, D = D + Math.imul(re, Ze) | 0, B = B + Math.imul(Ae, U) | 0, T = T + Math.imul(Ae, se) | 0, T = T + Math.imul(xe, U) | 0, D = D + Math.imul(xe, se) | 0, B = B + Math.imul(ye, Ue) | 0, T = T + Math.imul(ye, De) | 0, T = T + Math.imul(fe, Ue) | 0, D = D + Math.imul(fe, De) | 0, B = B + Math.imul(me, Qe) | 0, T = T + Math.imul(me, st) | 0, T = T + Math.imul(Ie, Qe) | 0, D = D + Math.imul(Ie, st) | 0;
      var et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, B = Math.imul(je, Ce), T = Math.imul(je, Be), T = T + Math.imul(Fe, Ce) | 0, D = Math.imul(Fe, Be), B = B + Math.imul(Ne, Ve) | 0, T = T + Math.imul(Ne, Ze) | 0, T = T + Math.imul(Oe, Ve) | 0, D = D + Math.imul(Oe, Ze) | 0, B = B + Math.imul(N, U) | 0, T = T + Math.imul(N, se) | 0, T = T + Math.imul(re, U) | 0, D = D + Math.imul(re, se) | 0, B = B + Math.imul(Ae, Ue) | 0, T = T + Math.imul(Ae, De) | 0, T = T + Math.imul(xe, Ue) | 0, D = D + Math.imul(xe, De) | 0, B = B + Math.imul(ye, Qe) | 0, T = T + Math.imul(ye, st) | 0, T = T + Math.imul(fe, Qe) | 0, D = D + Math.imul(fe, st) | 0, B = B + Math.imul(me, tt) | 0, T = T + Math.imul(me, it) | 0, T = T + Math.imul(Ie, tt) | 0, D = D + Math.imul(Ie, it) | 0;
      var pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Ce), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Ce) | 0, D = Math.imul(Ge, Be), B = B + Math.imul(je, Ve) | 0, T = T + Math.imul(je, Ze) | 0, T = T + Math.imul(Fe, Ve) | 0, D = D + Math.imul(Fe, Ze) | 0, B = B + Math.imul(Ne, U) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Oe, U) | 0, D = D + Math.imul(Oe, se) | 0, B = B + Math.imul(N, Ue) | 0, T = T + Math.imul(N, De) | 0, T = T + Math.imul(re, Ue) | 0, D = D + Math.imul(re, De) | 0, B = B + Math.imul(Ae, Qe) | 0, T = T + Math.imul(Ae, st) | 0, T = T + Math.imul(xe, Qe) | 0, D = D + Math.imul(xe, st) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(fe, tt) | 0, D = D + Math.imul(fe, it) | 0, B = B + Math.imul(me, rt) | 0, T = T + Math.imul(me, dt) | 0, T = T + Math.imul(Ie, rt) | 0, D = D + Math.imul(Ie, dt) | 0;
      var mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ge, Ce), T = Math.imul(ge, Be), T = T + Math.imul(Te, Ce) | 0, D = Math.imul(Te, Be), B = B + Math.imul(Xe, Ve) | 0, T = T + Math.imul(Xe, Ze) | 0, T = T + Math.imul(Ge, Ve) | 0, D = D + Math.imul(Ge, Ze) | 0, B = B + Math.imul(je, U) | 0, T = T + Math.imul(je, se) | 0, T = T + Math.imul(Fe, U) | 0, D = D + Math.imul(Fe, se) | 0, B = B + Math.imul(Ne, Ue) | 0, T = T + Math.imul(Ne, De) | 0, T = T + Math.imul(Oe, Ue) | 0, D = D + Math.imul(Oe, De) | 0, B = B + Math.imul(N, Qe) | 0, T = T + Math.imul(N, st) | 0, T = T + Math.imul(re, Qe) | 0, D = D + Math.imul(re, st) | 0, B = B + Math.imul(Ae, tt) | 0, T = T + Math.imul(Ae, it) | 0, T = T + Math.imul(xe, tt) | 0, D = D + Math.imul(xe, it) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(fe, rt) | 0, D = D + Math.imul(fe, dt) | 0, B = B + Math.imul(me, nt) | 0, T = T + Math.imul(me, at) | 0, T = T + Math.imul(Ie, nt) | 0, D = D + Math.imul(Ie, at) | 0;
      var vt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, B = Math.imul(Re, Ce), T = Math.imul(Re, Be), T = T + Math.imul(J, Ce) | 0, D = Math.imul(J, Be), B = B + Math.imul(ge, Ve) | 0, T = T + Math.imul(ge, Ze) | 0, T = T + Math.imul(Te, Ve) | 0, D = D + Math.imul(Te, Ze) | 0, B = B + Math.imul(Xe, U) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, U) | 0, D = D + Math.imul(Ge, se) | 0, B = B + Math.imul(je, Ue) | 0, T = T + Math.imul(je, De) | 0, T = T + Math.imul(Fe, Ue) | 0, D = D + Math.imul(Fe, De) | 0, B = B + Math.imul(Ne, Qe) | 0, T = T + Math.imul(Ne, st) | 0, T = T + Math.imul(Oe, Qe) | 0, D = D + Math.imul(Oe, st) | 0, B = B + Math.imul(N, tt) | 0, T = T + Math.imul(N, it) | 0, T = T + Math.imul(re, tt) | 0, D = D + Math.imul(re, it) | 0, B = B + Math.imul(Ae, rt) | 0, T = T + Math.imul(Ae, dt) | 0, T = T + Math.imul(xe, rt) | 0, D = D + Math.imul(xe, dt) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(fe, nt) | 0, D = D + Math.imul(fe, at) | 0, B = B + Math.imul(me, ot) | 0, T = T + Math.imul(me, ct) | 0, T = T + Math.imul(Ie, ot) | 0, D = D + Math.imul(Ie, ct) | 0;
      var ht = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(ue, Ce), T = Math.imul(ue, Be), T = T + Math.imul(ce, Ce) | 0, D = Math.imul(ce, Be), B = B + Math.imul(Re, Ve) | 0, T = T + Math.imul(Re, Ze) | 0, T = T + Math.imul(J, Ve) | 0, D = D + Math.imul(J, Ze) | 0, B = B + Math.imul(ge, U) | 0, T = T + Math.imul(ge, se) | 0, T = T + Math.imul(Te, U) | 0, D = D + Math.imul(Te, se) | 0, B = B + Math.imul(Xe, Ue) | 0, T = T + Math.imul(Xe, De) | 0, T = T + Math.imul(Ge, Ue) | 0, D = D + Math.imul(Ge, De) | 0, B = B + Math.imul(je, Qe) | 0, T = T + Math.imul(je, st) | 0, T = T + Math.imul(Fe, Qe) | 0, D = D + Math.imul(Fe, st) | 0, B = B + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Oe, tt) | 0, D = D + Math.imul(Oe, it) | 0, B = B + Math.imul(N, rt) | 0, T = T + Math.imul(N, dt) | 0, T = T + Math.imul(re, rt) | 0, D = D + Math.imul(re, dt) | 0, B = B + Math.imul(Ae, nt) | 0, T = T + Math.imul(Ae, at) | 0, T = T + Math.imul(xe, nt) | 0, D = D + Math.imul(xe, at) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(fe, ot) | 0, D = D + Math.imul(fe, ct) | 0, B = B + Math.imul(me, ut) | 0, T = T + Math.imul(me, lt) | 0, T = T + Math.imul(Ie, ut) | 0, D = D + Math.imul(Ie, lt) | 0;
      var _t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, B = Math.imul(ue, Ve), T = Math.imul(ue, Ze), T = T + Math.imul(ce, Ve) | 0, D = Math.imul(ce, Ze), B = B + Math.imul(Re, U) | 0, T = T + Math.imul(Re, se) | 0, T = T + Math.imul(J, U) | 0, D = D + Math.imul(J, se) | 0, B = B + Math.imul(ge, Ue) | 0, T = T + Math.imul(ge, De) | 0, T = T + Math.imul(Te, Ue) | 0, D = D + Math.imul(Te, De) | 0, B = B + Math.imul(Xe, Qe) | 0, T = T + Math.imul(Xe, st) | 0, T = T + Math.imul(Ge, Qe) | 0, D = D + Math.imul(Ge, st) | 0, B = B + Math.imul(je, tt) | 0, T = T + Math.imul(je, it) | 0, T = T + Math.imul(Fe, tt) | 0, D = D + Math.imul(Fe, it) | 0, B = B + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Oe, rt) | 0, D = D + Math.imul(Oe, dt) | 0, B = B + Math.imul(N, nt) | 0, T = T + Math.imul(N, at) | 0, T = T + Math.imul(re, nt) | 0, D = D + Math.imul(re, at) | 0, B = B + Math.imul(Ae, ot) | 0, T = T + Math.imul(Ae, ct) | 0, T = T + Math.imul(xe, ot) | 0, D = D + Math.imul(xe, ct) | 0, B = B + Math.imul(ye, ut) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(fe, ut) | 0, D = D + Math.imul(fe, lt) | 0;
      var Et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(ue, U), T = Math.imul(ue, se), T = T + Math.imul(ce, U) | 0, D = Math.imul(ce, se), B = B + Math.imul(Re, Ue) | 0, T = T + Math.imul(Re, De) | 0, T = T + Math.imul(J, Ue) | 0, D = D + Math.imul(J, De) | 0, B = B + Math.imul(ge, Qe) | 0, T = T + Math.imul(ge, st) | 0, T = T + Math.imul(Te, Qe) | 0, D = D + Math.imul(Te, st) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, tt) | 0, D = D + Math.imul(Ge, it) | 0, B = B + Math.imul(je, rt) | 0, T = T + Math.imul(je, dt) | 0, T = T + Math.imul(Fe, rt) | 0, D = D + Math.imul(Fe, dt) | 0, B = B + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Oe, nt) | 0, D = D + Math.imul(Oe, at) | 0, B = B + Math.imul(N, ot) | 0, T = T + Math.imul(N, ct) | 0, T = T + Math.imul(re, ot) | 0, D = D + Math.imul(re, ct) | 0, B = B + Math.imul(Ae, ut) | 0, T = T + Math.imul(Ae, lt) | 0, T = T + Math.imul(xe, ut) | 0, D = D + Math.imul(xe, lt) | 0;
      var Pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, B = Math.imul(ue, Ue), T = Math.imul(ue, De), T = T + Math.imul(ce, Ue) | 0, D = Math.imul(ce, De), B = B + Math.imul(Re, Qe) | 0, T = T + Math.imul(Re, st) | 0, T = T + Math.imul(J, Qe) | 0, D = D + Math.imul(J, st) | 0, B = B + Math.imul(ge, tt) | 0, T = T + Math.imul(ge, it) | 0, T = T + Math.imul(Te, tt) | 0, D = D + Math.imul(Te, it) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, rt) | 0, D = D + Math.imul(Ge, dt) | 0, B = B + Math.imul(je, nt) | 0, T = T + Math.imul(je, at) | 0, T = T + Math.imul(Fe, nt) | 0, D = D + Math.imul(Fe, at) | 0, B = B + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Oe, ot) | 0, D = D + Math.imul(Oe, ct) | 0, B = B + Math.imul(N, ut) | 0, T = T + Math.imul(N, lt) | 0, T = T + Math.imul(re, ut) | 0, D = D + Math.imul(re, lt) | 0;
      var Nt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(ue, Qe), T = Math.imul(ue, st), T = T + Math.imul(ce, Qe) | 0, D = Math.imul(ce, st), B = B + Math.imul(Re, tt) | 0, T = T + Math.imul(Re, it) | 0, T = T + Math.imul(J, tt) | 0, D = D + Math.imul(J, it) | 0, B = B + Math.imul(ge, rt) | 0, T = T + Math.imul(ge, dt) | 0, T = T + Math.imul(Te, rt) | 0, D = D + Math.imul(Te, dt) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, nt) | 0, D = D + Math.imul(Ge, at) | 0, B = B + Math.imul(je, ot) | 0, T = T + Math.imul(je, ct) | 0, T = T + Math.imul(Fe, ot) | 0, D = D + Math.imul(Fe, ct) | 0, B = B + Math.imul(Ne, ut) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Oe, ut) | 0, D = D + Math.imul(Oe, lt) | 0;
      var Mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, B = Math.imul(ue, tt), T = Math.imul(ue, it), T = T + Math.imul(ce, tt) | 0, D = Math.imul(ce, it), B = B + Math.imul(Re, rt) | 0, T = T + Math.imul(Re, dt) | 0, T = T + Math.imul(J, rt) | 0, D = D + Math.imul(J, dt) | 0, B = B + Math.imul(ge, nt) | 0, T = T + Math.imul(ge, at) | 0, T = T + Math.imul(Te, nt) | 0, D = D + Math.imul(Te, at) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, D = D + Math.imul(Ge, ct) | 0, B = B + Math.imul(je, ut) | 0, T = T + Math.imul(je, lt) | 0, T = T + Math.imul(Fe, ut) | 0, D = D + Math.imul(Fe, lt) | 0;
      var Ot = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(ue, rt), T = Math.imul(ue, dt), T = T + Math.imul(ce, rt) | 0, D = Math.imul(ce, dt), B = B + Math.imul(Re, nt) | 0, T = T + Math.imul(Re, at) | 0, T = T + Math.imul(J, nt) | 0, D = D + Math.imul(J, at) | 0, B = B + Math.imul(ge, ot) | 0, T = T + Math.imul(ge, ct) | 0, T = T + Math.imul(Te, ot) | 0, D = D + Math.imul(Te, ct) | 0, B = B + Math.imul(Xe, ut) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, ut) | 0, D = D + Math.imul(Ge, lt) | 0;
      var $t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(ue, nt), T = Math.imul(ue, at), T = T + Math.imul(ce, nt) | 0, D = Math.imul(ce, at), B = B + Math.imul(Re, ot) | 0, T = T + Math.imul(Re, ct) | 0, T = T + Math.imul(J, ot) | 0, D = D + Math.imul(J, ct) | 0, B = B + Math.imul(ge, ut) | 0, T = T + Math.imul(ge, lt) | 0, T = T + Math.imul(Te, ut) | 0, D = D + Math.imul(Te, lt) | 0;
      var Bt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(ue, ot), T = Math.imul(ue, ct), T = T + Math.imul(ce, ot) | 0, D = Math.imul(ce, ct), B = B + Math.imul(Re, ut) | 0, T = T + Math.imul(Re, lt) | 0, T = T + Math.imul(J, ut) | 0, D = D + Math.imul(J, lt) | 0;
      var xt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, B = Math.imul(ue, ut), T = Math.imul(ue, lt), T = T + Math.imul(ce, ut) | 0, D = Math.imul(ce, lt);
      var Ut = (Y + B | 0) + ((T & 8191) << 13) | 0;
      return Y = (D + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, x[0] = kt, x[1] = Rt, x[2] = Je, x[3] = ze, x[4] = et, x[5] = pt, x[6] = mt, x[7] = vt, x[8] = ht, x[9] = _t, x[10] = Et, x[11] = Pt, x[12] = Nt, x[13] = Mt, x[14] = Ot, x[15] = $t, x[16] = Bt, x[17] = xt, x[18] = Ut, Y !== 0 && (x[19] = Y, k.length++), k;
    };
    Math.imul || (ie = X);
    function Q(C, b, E) {
      E.negative = b.negative ^ C.negative, E.length = C.length + b.length;
      for (var k = 0, O = 0, A = 0; A < E.length - 1; A++) {
        var x = O;
        O = 0;
        for (var Y = k & 67108863, B = Math.min(A, b.length - 1), T = Math.max(0, A - C.length + 1); T <= B; T++) {
          var D = A - T, te = C.words[D] | 0, me = b.words[T] | 0, Ie = te * me, $e = Ie & 67108863;
          x = x + (Ie / 67108864 | 0) | 0, $e = $e + Y | 0, Y = $e & 67108863, x = x + ($e >>> 26) | 0, O += x >>> 26, x &= 67108863;
        }
        E.words[A] = Y, k = x, x = O;
      }
      return k !== 0 ? E.words[A] = k : E.length--, E.strip();
    }
    function ne(C, b, E) {
      var k = new Z();
      return k.mulp(C, b, E);
    }
    p.prototype.mulTo = function(b, E) {
      var k, O = this.length + b.length;
      return this.length === 10 && b.length === 10 ? k = ie(this, b, E) : O < 63 ? k = X(this, b, E) : O < 1024 ? k = Q(this, b, E) : k = ne(this, b, E), k;
    };
    function Z(C, b) {
      this.x = C, this.y = b;
    }
    Z.prototype.makeRBT = function(b) {
      for (var E = new Array(b), k = p.prototype._countBits(b) - 1, O = 0; O < b; O++)
        E[O] = this.revBin(O, k, b);
      return E;
    }, Z.prototype.revBin = function(b, E, k) {
      if (b === 0 || b === k - 1)
        return b;
      for (var O = 0, A = 0; A < E; A++)
        O |= (b & 1) << E - A - 1, b >>= 1;
      return O;
    }, Z.prototype.permute = function(b, E, k, O, A, x) {
      for (var Y = 0; Y < x; Y++)
        O[Y] = E[b[Y]], A[Y] = k[b[Y]];
    }, Z.prototype.transform = function(b, E, k, O, A, x) {
      this.permute(x, b, E, k, O, A);
      for (var Y = 1; Y < A; Y <<= 1)
        for (var B = Y << 1, T = Math.cos(2 * Math.PI / B), D = Math.sin(2 * Math.PI / B), te = 0; te < A; te += B)
          for (var me = T, Ie = D, $e = 0; $e < Y; $e++) {
            var ye = k[te + $e], fe = O[te + $e], Me = k[te + $e + Y], Ae = O[te + $e + Y], xe = me * Me - Ie * Ae;
            Ae = me * Ae + Ie * Me, Me = xe, k[te + $e] = ye + Me, O[te + $e] = fe + Ae, k[te + $e + Y] = ye - Me, O[te + $e + Y] = fe - Ae, $e !== B && (xe = T * me - D * Ie, Ie = T * Ie + D * me, me = xe);
          }
    }, Z.prototype.guessLen13b = function(b, E) {
      var k = Math.max(E, b) | 1, O = k & 1, A = 0;
      for (k = k / 2 | 0; k; k = k >>> 1)
        A++;
      return 1 << A + 1 + O;
    }, Z.prototype.conjugate = function(b, E, k) {
      if (!(k <= 1))
        for (var O = 0; O < k / 2; O++) {
          var A = b[O];
          b[O] = b[k - O - 1], b[k - O - 1] = A, A = E[O], E[O] = -E[k - O - 1], E[k - O - 1] = -A;
        }
    }, Z.prototype.normalize13b = function(b, E) {
      for (var k = 0, O = 0; O < E / 2; O++) {
        var A = Math.round(b[2 * O + 1] / E) * 8192 + Math.round(b[2 * O] / E) + k;
        b[O] = A & 67108863, A < 67108864 ? k = 0 : k = A / 67108864 | 0;
      }
      return b;
    }, Z.prototype.convert13b = function(b, E, k, O) {
      for (var A = 0, x = 0; x < E; x++)
        A = A + (b[x] | 0), k[2 * x] = A & 8191, A = A >>> 13, k[2 * x + 1] = A & 8191, A = A >>> 13;
      for (x = 2 * E; x < O; ++x)
        k[x] = 0;
      l(A === 0), l((A & -8192) === 0);
    }, Z.prototype.stub = function(b) {
      for (var E = new Array(b), k = 0; k < b; k++)
        E[k] = 0;
      return E;
    }, Z.prototype.mulp = function(b, E, k) {
      var O = 2 * this.guessLen13b(b.length, E.length), A = this.makeRBT(O), x = this.stub(O), Y = new Array(O), B = new Array(O), T = new Array(O), D = new Array(O), te = new Array(O), me = new Array(O), Ie = k.words;
      Ie.length = O, this.convert13b(b.words, b.length, Y, O), this.convert13b(E.words, E.length, D, O), this.transform(Y, x, B, T, O, A), this.transform(D, x, te, me, O, A);
      for (var $e = 0; $e < O; $e++) {
        var ye = B[$e] * te[$e] - T[$e] * me[$e];
        T[$e] = B[$e] * me[$e] + T[$e] * te[$e], B[$e] = ye;
      }
      return this.conjugate(B, T, O), this.transform(B, T, Ie, x, O, A), this.conjugate(Ie, x, O), this.normalize13b(Ie, O), k.negative = b.negative ^ E.negative, k.length = b.length + E.length, k.strip();
    }, p.prototype.mul = function(b) {
      var E = new p(null);
      return E.words = new Array(this.length + b.length), this.mulTo(b, E);
    }, p.prototype.mulf = function(b) {
      var E = new p(null);
      return E.words = new Array(this.length + b.length), ne(this, b, E);
    }, p.prototype.imul = function(b) {
      return this.clone().mulTo(b, this);
    }, p.prototype.imuln = function(b) {
      l(typeof b == "number"), l(b < 67108864);
      for (var E = 0, k = 0; k < this.length; k++) {
        var O = (this.words[k] | 0) * b, A = (O & 67108863) + (E & 67108863);
        E >>= 26, E += O / 67108864 | 0, E += A >>> 26, this.words[k] = A & 67108863;
      }
      return E !== 0 && (this.words[k] = E, this.length++), this;
    }, p.prototype.muln = function(b) {
      return this.clone().imuln(b);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(b) {
      var E = ee(b);
      if (E.length === 0)
        return new p(1);
      for (var k = this, O = 0; O < E.length && E[O] === 0; O++, k = k.sqr())
        ;
      if (++O < E.length)
        for (var A = k.sqr(); O < E.length; O++, A = A.sqr())
          E[O] !== 0 && (k = k.mul(A));
      return k;
    }, p.prototype.iushln = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26, O = 67108863 >>> 26 - E << 26 - E, A;
      if (E !== 0) {
        var x = 0;
        for (A = 0; A < this.length; A++) {
          var Y = this.words[A] & O, B = (this.words[A] | 0) - Y << E;
          this.words[A] = B | x, x = Y >>> 26 - E;
        }
        x && (this.words[A] = x, this.length++);
      }
      if (k !== 0) {
        for (A = this.length - 1; A >= 0; A--)
          this.words[A + k] = this.words[A];
        for (A = 0; A < k; A++)
          this.words[A] = 0;
        this.length += k;
      }
      return this.strip();
    }, p.prototype.ishln = function(b) {
      return l(this.negative === 0), this.iushln(b);
    }, p.prototype.iushrn = function(b, E, k) {
      l(typeof b == "number" && b >= 0);
      var O;
      E ? O = (E - E % 26) / 26 : O = 0;
      var A = b % 26, x = Math.min((b - A) / 26, this.length), Y = 67108863 ^ 67108863 >>> A << A, B = k;
      if (O -= x, O = Math.max(0, O), B) {
        for (var T = 0; T < x; T++)
          B.words[T] = this.words[T];
        B.length = x;
      }
      if (x !== 0)
        if (this.length > x)
          for (this.length -= x, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + x];
        else
          this.words[0] = 0, this.length = 1;
      var D = 0;
      for (T = this.length - 1; T >= 0 && (D !== 0 || T >= O); T--) {
        var te = this.words[T] | 0;
        this.words[T] = D << 26 - A | te >>> A, D = te & Y;
      }
      return B && D !== 0 && (B.words[B.length++] = D), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(b, E, k) {
      return l(this.negative === 0), this.iushrn(b, E, k);
    }, p.prototype.shln = function(b) {
      return this.clone().ishln(b);
    }, p.prototype.ushln = function(b) {
      return this.clone().iushln(b);
    }, p.prototype.shrn = function(b) {
      return this.clone().ishrn(b);
    }, p.prototype.ushrn = function(b) {
      return this.clone().iushrn(b);
    }, p.prototype.testn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26, O = 1 << E;
      if (this.length <= k)
        return !1;
      var A = this.words[k];
      return !!(A & O);
    }, p.prototype.imaskn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= k)
        return this;
      if (E !== 0 && k++, this.length = Math.min(k, this.length), E !== 0) {
        var O = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= O;
      }
      return this.strip();
    }, p.prototype.maskn = function(b) {
      return this.clone().imaskn(b);
    }, p.prototype.iaddn = function(b) {
      return l(typeof b == "number"), l(b < 67108864), b < 0 ? this.isubn(-b) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < b ? (this.words[0] = b - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(b), this.negative = 1, this) : this._iaddn(b);
    }, p.prototype._iaddn = function(b) {
      this.words[0] += b;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(b) {
      if (l(typeof b == "number"), l(b < 67108864), b < 0)
        return this.iaddn(-b);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(b), this.negative = 1, this;
      if (this.words[0] -= b, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(b) {
      return this.clone().iaddn(b);
    }, p.prototype.subn = function(b) {
      return this.clone().isubn(b);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(b, E, k) {
      var O = b.length + k, A;
      this._expand(O);
      var x, Y = 0;
      for (A = 0; A < b.length; A++) {
        x = (this.words[A + k] | 0) + Y;
        var B = (b.words[A] | 0) * E;
        x -= B & 67108863, Y = (x >> 26) - (B / 67108864 | 0), this.words[A + k] = x & 67108863;
      }
      for (; A < this.length - k; A++)
        x = (this.words[A + k] | 0) + Y, Y = x >> 26, this.words[A + k] = x & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, A = 0; A < this.length; A++)
        x = -(this.words[A] | 0) + Y, Y = x >> 26, this.words[A] = x & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(b, E) {
      var k = this.length - b.length, O = this.clone(), A = b, x = A.words[A.length - 1] | 0, Y = this._countBits(x);
      k = 26 - Y, k !== 0 && (A = A.ushln(k), O.iushln(k), x = A.words[A.length - 1] | 0);
      var B = O.length - A.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var D = 0; D < T.length; D++)
          T.words[D] = 0;
      }
      var te = O.clone()._ishlnsubmul(A, 1, B);
      te.negative === 0 && (O = te, T && (T.words[B] = 1));
      for (var me = B - 1; me >= 0; me--) {
        var Ie = (O.words[A.length + me] | 0) * 67108864 + (O.words[A.length + me - 1] | 0);
        for (Ie = Math.min(Ie / x | 0, 67108863), O._ishlnsubmul(A, Ie, me); O.negative !== 0; )
          Ie--, O.negative = 0, O._ishlnsubmul(A, 1, me), O.isZero() || (O.negative ^= 1);
        T && (T.words[me] = Ie);
      }
      return T && T.strip(), O.strip(), E !== "div" && k !== 0 && O.iushrn(k), {
        div: T || null,
        mod: O
      };
    }, p.prototype.divmod = function(b, E, k) {
      if (l(!b.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var O, A, x;
      return this.negative !== 0 && b.negative === 0 ? (x = this.neg().divmod(b, E), E !== "mod" && (O = x.div.neg()), E !== "div" && (A = x.mod.neg(), k && A.negative !== 0 && A.iadd(b)), {
        div: O,
        mod: A
      }) : this.negative === 0 && b.negative !== 0 ? (x = this.divmod(b.neg(), E), E !== "mod" && (O = x.div.neg()), {
        div: O,
        mod: x.mod
      }) : this.negative & b.negative ? (x = this.neg().divmod(b.neg(), E), E !== "div" && (A = x.mod.neg(), k && A.negative !== 0 && A.isub(b)), {
        div: x.div,
        mod: A
      }) : b.length > this.length || this.cmp(b) < 0 ? {
        div: new p(0),
        mod: this
      } : b.length === 1 ? E === "div" ? {
        div: this.divn(b.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(b.words[0]))
      } : {
        div: this.divn(b.words[0]),
        mod: new p(this.modn(b.words[0]))
      } : this._wordDiv(b, E);
    }, p.prototype.div = function(b) {
      return this.divmod(b, "div", !1).div;
    }, p.prototype.mod = function(b) {
      return this.divmod(b, "mod", !1).mod;
    }, p.prototype.umod = function(b) {
      return this.divmod(b, "mod", !0).mod;
    }, p.prototype.divRound = function(b) {
      var E = this.divmod(b);
      if (E.mod.isZero())
        return E.div;
      var k = E.div.negative !== 0 ? E.mod.isub(b) : E.mod, O = b.ushrn(1), A = b.andln(1), x = k.cmp(O);
      return x < 0 || A === 1 && x === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(b) {
      l(b <= 67108863);
      for (var E = (1 << 26) % b, k = 0, O = this.length - 1; O >= 0; O--)
        k = (E * k + (this.words[O] | 0)) % b;
      return k;
    }, p.prototype.idivn = function(b) {
      l(b <= 67108863);
      for (var E = 0, k = this.length - 1; k >= 0; k--) {
        var O = (this.words[k] | 0) + E * 67108864;
        this.words[k] = O / b | 0, E = O % b;
      }
      return this.strip();
    }, p.prototype.divn = function(b) {
      return this.clone().idivn(b);
    }, p.prototype.egcd = function(b) {
      l(b.negative === 0), l(!b.isZero());
      var E = this, k = b.clone();
      E.negative !== 0 ? E = E.umod(b) : E = E.clone();
      for (var O = new p(1), A = new p(0), x = new p(0), Y = new p(1), B = 0; E.isEven() && k.isEven(); )
        E.iushrn(1), k.iushrn(1), ++B;
      for (var T = k.clone(), D = E.clone(); !E.isZero(); ) {
        for (var te = 0, me = 1; !(E.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (O.isOdd() || A.isOdd()) && (O.iadd(T), A.isub(D)), O.iushrn(1), A.iushrn(1);
        for (var Ie = 0, $e = 1; !(k.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (k.iushrn(Ie); Ie-- > 0; )
            (x.isOdd() || Y.isOdd()) && (x.iadd(T), Y.isub(D)), x.iushrn(1), Y.iushrn(1);
        E.cmp(k) >= 0 ? (E.isub(k), O.isub(x), A.isub(Y)) : (k.isub(E), x.isub(O), Y.isub(A));
      }
      return {
        a: x,
        b: Y,
        gcd: k.iushln(B)
      };
    }, p.prototype._invmp = function(b) {
      l(b.negative === 0), l(!b.isZero());
      var E = this, k = b.clone();
      E.negative !== 0 ? E = E.umod(b) : E = E.clone();
      for (var O = new p(1), A = new p(0), x = k.clone(); E.cmpn(1) > 0 && k.cmpn(1) > 0; ) {
        for (var Y = 0, B = 1; !(E.words[0] & B) && Y < 26; ++Y, B <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            O.isOdd() && O.iadd(x), O.iushrn(1);
        for (var T = 0, D = 1; !(k.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (k.iushrn(T); T-- > 0; )
            A.isOdd() && A.iadd(x), A.iushrn(1);
        E.cmp(k) >= 0 ? (E.isub(k), O.isub(A)) : (k.isub(E), A.isub(O));
      }
      var te;
      return E.cmpn(1) === 0 ? te = O : te = A, te.cmpn(0) < 0 && te.iadd(b), te;
    }, p.prototype.gcd = function(b) {
      if (this.isZero())
        return b.abs();
      if (b.isZero())
        return this.abs();
      var E = this.clone(), k = b.clone();
      E.negative = 0, k.negative = 0;
      for (var O = 0; E.isEven() && k.isEven(); O++)
        E.iushrn(1), k.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; k.isEven(); )
          k.iushrn(1);
        var A = E.cmp(k);
        if (A < 0) {
          var x = E;
          E = k, k = x;
        } else if (A === 0 || k.cmpn(1) === 0)
          break;
        E.isub(k);
      } while (!0);
      return k.iushln(O);
    }, p.prototype.invm = function(b) {
      return this.egcd(b).a.umod(b);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(b) {
      return this.words[0] & b;
    }, p.prototype.bincn = function(b) {
      l(typeof b == "number");
      var E = b % 26, k = (b - E) / 26, O = 1 << E;
      if (this.length <= k)
        return this._expand(k + 1), this.words[k] |= O, this;
      for (var A = O, x = k; A !== 0 && x < this.length; x++) {
        var Y = this.words[x] | 0;
        Y += A, A = Y >>> 26, Y &= 67108863, this.words[x] = Y;
      }
      return A !== 0 && (this.words[x] = A, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(b) {
      var E = b < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var k;
      if (this.length > 1)
        k = 1;
      else {
        E && (b = -b), l(b <= 67108863, "Number is too big");
        var O = this.words[0] | 0;
        k = O === b ? 0 : O < b ? -1 : 1;
      }
      return this.negative !== 0 ? -k | 0 : k;
    }, p.prototype.cmp = function(b) {
      if (this.negative !== 0 && b.negative === 0)
        return -1;
      if (this.negative === 0 && b.negative !== 0)
        return 1;
      var E = this.ucmp(b);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(b) {
      if (this.length > b.length)
        return 1;
      if (this.length < b.length)
        return -1;
      for (var E = 0, k = this.length - 1; k >= 0; k--) {
        var O = this.words[k] | 0, A = b.words[k] | 0;
        if (O !== A) {
          O < A ? E = -1 : O > A && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(b) {
      return this.cmpn(b) === 1;
    }, p.prototype.gt = function(b) {
      return this.cmp(b) === 1;
    }, p.prototype.gten = function(b) {
      return this.cmpn(b) >= 0;
    }, p.prototype.gte = function(b) {
      return this.cmp(b) >= 0;
    }, p.prototype.ltn = function(b) {
      return this.cmpn(b) === -1;
    }, p.prototype.lt = function(b) {
      return this.cmp(b) === -1;
    }, p.prototype.lten = function(b) {
      return this.cmpn(b) <= 0;
    }, p.prototype.lte = function(b) {
      return this.cmp(b) <= 0;
    }, p.prototype.eqn = function(b) {
      return this.cmpn(b) === 0;
    }, p.prototype.eq = function(b) {
      return this.cmp(b) === 0;
    }, p.red = function(b) {
      return new q(b);
    }, p.prototype.toRed = function(b) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), b.convertTo(this)._forceRed(b);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(b) {
      return this.red = b, this;
    }, p.prototype.forceRed = function(b) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(b);
    }, p.prototype.redAdd = function(b) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, b);
    }, p.prototype.redIAdd = function(b) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, b);
    }, p.prototype.redSub = function(b) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, b);
    }, p.prototype.redISub = function(b) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, b);
    }, p.prototype.redShl = function(b) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, b);
    }, p.prototype.redMul = function(b) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.mul(this, b);
    }, p.prototype.redIMul = function(b) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.imul(this, b);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(b) {
      return l(this.red && !b.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, b);
    };
    var de = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function he(C, b) {
      this.name = C, this.p = new p(b, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    he.prototype._tmp = function() {
      var b = new p(null);
      return b.words = new Array(Math.ceil(this.n / 13)), b;
    }, he.prototype.ireduce = function(b) {
      var E = b, k;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), k = E.bitLength();
      while (k > this.n);
      var O = k < this.n ? -1 : E.ucmp(this.p);
      return O === 0 ? (E.words[0] = 0, E.length = 1) : O > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, he.prototype.split = function(b, E) {
      b.iushrn(this.n, 0, E);
    }, he.prototype.imulK = function(b) {
      return b.imul(this.k);
    };
    function pe() {
      he.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(pe, he), pe.prototype.split = function(b, E) {
      for (var k = 4194303, O = Math.min(b.length, 9), A = 0; A < O; A++)
        E.words[A] = b.words[A];
      if (E.length = O, b.length <= 9) {
        b.words[0] = 0, b.length = 1;
        return;
      }
      var x = b.words[9];
      for (E.words[E.length++] = x & k, A = 10; A < b.length; A++) {
        var Y = b.words[A] | 0;
        b.words[A - 10] = (Y & k) << 4 | x >>> 22, x = Y;
      }
      x >>>= 22, b.words[A - 10] = x, x === 0 && b.length > 10 ? b.length -= 10 : b.length -= 9;
    }, pe.prototype.imulK = function(b) {
      b.words[b.length] = 0, b.words[b.length + 1] = 0, b.length += 2;
      for (var E = 0, k = 0; k < b.length; k++) {
        var O = b.words[k] | 0;
        E += O * 977, b.words[k] = E & 67108863, E = O * 64 + (E / 67108864 | 0);
      }
      return b.words[b.length - 1] === 0 && (b.length--, b.words[b.length - 1] === 0 && b.length--), b;
    };
    function be() {
      he.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(be, he);
    function ke() {
      he.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(ke, he);
    function _e() {
      he.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(_e, he), _e.prototype.imulK = function(b) {
      for (var E = 0, k = 0; k < b.length; k++) {
        var O = (b.words[k] | 0) * 19 + E, A = O & 67108863;
        O >>>= 26, b.words[k] = A, E = O;
      }
      return E !== 0 && (b.words[b.length++] = E), b;
    }, p._prime = function(b) {
      if (de[b])
        return de[b];
      var E;
      if (b === "k256")
        E = new pe();
      else if (b === "p224")
        E = new be();
      else if (b === "p192")
        E = new ke();
      else if (b === "p25519")
        E = new _e();
      else
        throw new Error("Unknown prime " + b);
      return de[b] = E, E;
    };
    function q(C) {
      if (typeof C == "string") {
        var b = p._prime(C);
        this.m = b.p, this.prime = b;
      } else
        l(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    q.prototype._verify1 = function(b) {
      l(b.negative === 0, "red works only with positives"), l(b.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(b, E) {
      l((b.negative | E.negative) === 0, "red works only with positives"), l(
        b.red && b.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(b) {
      return this.prime ? this.prime.ireduce(b)._forceRed(this) : b.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(b) {
      return b.isZero() ? b.clone() : this.m.sub(b)._forceRed(this);
    }, q.prototype.add = function(b, E) {
      this._verify2(b, E);
      var k = b.add(E);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k._forceRed(this);
    }, q.prototype.iadd = function(b, E) {
      this._verify2(b, E);
      var k = b.iadd(E);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k;
    }, q.prototype.sub = function(b, E) {
      this._verify2(b, E);
      var k = b.sub(E);
      return k.cmpn(0) < 0 && k.iadd(this.m), k._forceRed(this);
    }, q.prototype.isub = function(b, E) {
      this._verify2(b, E);
      var k = b.isub(E);
      return k.cmpn(0) < 0 && k.iadd(this.m), k;
    }, q.prototype.shl = function(b, E) {
      return this._verify1(b), this.imod(b.ushln(E));
    }, q.prototype.imul = function(b, E) {
      return this._verify2(b, E), this.imod(b.imul(E));
    }, q.prototype.mul = function(b, E) {
      return this._verify2(b, E), this.imod(b.mul(E));
    }, q.prototype.isqr = function(b) {
      return this.imul(b, b.clone());
    }, q.prototype.sqr = function(b) {
      return this.mul(b, b);
    }, q.prototype.sqrt = function(b) {
      if (b.isZero())
        return b.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var k = this.m.add(new p(1)).iushrn(2);
        return this.pow(b, k);
      }
      for (var O = this.m.subn(1), A = 0; !O.isZero() && O.andln(1) === 0; )
        A++, O.iushrn(1);
      l(!O.isZero());
      var x = new p(1).toRed(this), Y = x.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var D = this.pow(T, O), te = this.pow(b, O.addn(1).iushrn(1)), me = this.pow(b, O), Ie = A; me.cmp(x) !== 0; ) {
        for (var $e = me, ye = 0; $e.cmp(x) !== 0; ye++)
          $e = $e.redSqr();
        l(ye < Ie);
        var fe = this.pow(D, new p(1).iushln(Ie - ye - 1));
        te = te.redMul(fe), D = fe.redSqr(), me = me.redMul(D), Ie = ye;
      }
      return te;
    }, q.prototype.invm = function(b) {
      var E = b._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(b, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return b.clone();
      var k = 4, O = new Array(1 << k);
      O[0] = new p(1).toRed(this), O[1] = b;
      for (var A = 2; A < O.length; A++)
        O[A] = this.mul(O[A - 1], b);
      var x = O[0], Y = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), A = E.length - 1; A >= 0; A--) {
        for (var D = E.words[A], te = T - 1; te >= 0; te--) {
          var me = D >> te & 1;
          if (x !== O[0] && (x = this.sqr(x)), me === 0 && Y === 0) {
            B = 0;
            continue;
          }
          Y <<= 1, Y |= me, B++, !(B !== k && (A !== 0 || te !== 0)) && (x = this.mul(x, O[Y]), B = 0, Y = 0);
        }
        T = 26;
      }
      return x;
    }, q.prototype.convertTo = function(b) {
      var E = b.umod(this.m);
      return E === b ? E.clone() : E;
    }, q.prototype.convertFrom = function(b) {
      var E = b.clone();
      return E.red = null, E;
    }, p.mont = function(b) {
      return new z(b);
    };
    function z(C) {
      q.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, q), z.prototype.convertTo = function(b) {
      return this.imod(b.ushln(this.shift));
    }, z.prototype.convertFrom = function(b) {
      var E = this.imod(b.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(b, E) {
      if (b.isZero() || E.isZero())
        return b.words[0] = 0, b.length = 1, b;
      var k = b.imul(E), O = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = k.isub(O).iushrn(this.shift), x = A;
      return A.cmp(this.m) >= 0 ? x = A.isub(this.m) : A.cmpn(0) < 0 && (x = A.iadd(this.m)), x._forceRed(this);
    }, z.prototype.mul = function(b, E) {
      if (b.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var k = b.mul(E), O = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = k.isub(O).iushrn(this.shift), x = A;
      return A.cmp(this.m) >= 0 ? x = A.isub(this.m) : A.cmpn(0) < 0 && (x = A.iadd(this.m)), x._forceRed(this);
    }, z.prototype.invm = function(b) {
      var E = this.imod(b._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$5);
var bnExports$5 = bn$5.exports, brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand)
    return brorand.exports;
  hasRequiredBrorand = 1;
  var a;
  brorand.exports = function(v) {
    return a || (a = new u(null)), a.generate(v);
  };
  function u(l) {
    this.rand = l;
  }
  if (brorand.exports.Rand = u, u.prototype.generate = function(v) {
    return this._rand(v);
  }, u.prototype._rand = function(v) {
    if (this.rand.getBytes)
      return this.rand.getBytes(v);
    for (var p = new Uint8Array(v), _ = 0; _ < p.length; _++)
      p[_] = this.rand.getByte();
    return p;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? u.prototype._rand = function(v) {
      var p = new Uint8Array(v);
      return self.crypto.getRandomValues(p), p;
    } : self.msCrypto && self.msCrypto.getRandomValues ? u.prototype._rand = function(v) {
      var p = new Uint8Array(v);
      return self.msCrypto.getRandomValues(p), p;
    } : typeof window == "object" && (u.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var c = requireCryptoBrowserify();
      if (typeof c.randomBytes != "function")
        throw new Error("Not supported");
      u.prototype._rand = function(v) {
        return c.randomBytes(v);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr)
    return mr;
  hasRequiredMr = 1;
  var a = bnExports$5, u = requireBrorand();
  function c(l) {
    this.rand = l || new u.Rand();
  }
  return mr = c, c.create = function(v) {
    return new c(v);
  }, c.prototype._randbelow = function(v) {
    var p = v.bitLength(), _ = Math.ceil(p / 8);
    do
      var I = new a(this.rand.generate(_));
    while (I.cmp(v) >= 0);
    return I;
  }, c.prototype._randrange = function(v, p) {
    var _ = p.sub(v);
    return v.add(this._randbelow(_));
  }, c.prototype.test = function(v, p, _) {
    var I = v.bitLength(), P = a.mont(v), $ = new a(1).toRed(P);
    p || (p = Math.max(1, I / 48 | 0));
    for (var F = v.subn(1), H = 0; !F.testn(H); H++)
      ;
    for (var j = v.shrn(H), ee = F.toRed(P), X = !0; p > 0; p--) {
      var ie = this._randrange(new a(2), F);
      _ && _(ie);
      var Q = ie.toRed(P).redPow(j);
      if (!(Q.cmp($) === 0 || Q.cmp(ee) === 0)) {
        for (var ne = 1; ne < H; ne++) {
          if (Q = Q.redSqr(), Q.cmp($) === 0)
            return !1;
          if (Q.cmp(ee) === 0)
            break;
        }
        if (ne === H)
          return !1;
      }
    }
    return X;
  }, c.prototype.getDivisor = function(v, p) {
    var _ = v.bitLength(), I = a.mont(v), P = new a(1).toRed(I);
    p || (p = Math.max(1, _ / 48 | 0));
    for (var $ = v.subn(1), F = 0; !$.testn(F); F++)
      ;
    for (var H = v.shrn(F), j = $.toRed(I); p > 0; p--) {
      var ee = this._randrange(new a(2), $), X = v.gcd(ee);
      if (X.cmpn(1) !== 0)
        return X;
      var ie = ee.toRed(I).redPow(H);
      if (!(ie.cmp(P) === 0 || ie.cmp(j) === 0)) {
        for (var Q = 1; Q < F; Q++) {
          if (ie = ie.redSqr(), ie.cmp(P) === 0)
            return ie.fromRed().subn(1).gcd(v);
          if (ie.cmp(j) === 0)
            break;
        }
        if (Q === F)
          return ie = ie.redSqr(), ie.fromRed().subn(1).gcd(v);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime)
    return generatePrime;
  hasRequiredGeneratePrime = 1;
  var a = browserExports;
  generatePrime = Q, Q.simpleSieve = X, Q.fermatTest = ie;
  var u = bnExports$6, c = new u(24), l = requireMr(), v = new l(), p = new u(1), _ = new u(2), I = new u(5);
  new u(16), new u(8);
  var P = new u(10), $ = new u(3);
  new u(7);
  var F = new u(11), H = new u(4);
  new u(12);
  var j = null;
  function ee() {
    if (j !== null)
      return j;
    var ne = 1048576, Z = [];
    Z[0] = 2;
    for (var de = 1, he = 3; he < ne; he += 2) {
      for (var pe = Math.ceil(Math.sqrt(he)), be = 0; be < de && Z[be] <= pe && he % Z[be] !== 0; be++)
        ;
      de !== be && Z[be] <= pe || (Z[de++] = he);
    }
    return j = Z, Z;
  }
  function X(ne) {
    for (var Z = ee(), de = 0; de < Z.length; de++)
      if (ne.modn(Z[de]) === 0)
        return ne.cmpn(Z[de]) === 0;
    return !0;
  }
  function ie(ne) {
    var Z = u.mont(ne);
    return _.toRed(Z).redPow(ne.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Q(ne, Z) {
    if (ne < 16)
      return Z === 2 || Z === 5 ? new u([140, 123]) : new u([140, 39]);
    Z = new u(Z);
    for (var de, he; ; ) {
      for (de = new u(a(Math.ceil(ne / 8))); de.bitLength() > ne; )
        de.ishrn(1);
      if (de.isEven() && de.iadd(p), de.testn(1) || de.iadd(_), Z.cmp(_)) {
        if (!Z.cmp(I))
          for (; de.mod(P).cmp($); )
            de.iadd(H);
      } else
        for (; de.mod(c).cmp(F); )
          de.iadd(H);
      if (he = de.shrn(1), X(he) && X(de) && ie(he) && ie(de) && v.test(he) && v.test(de))
        return de;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh)
    return dh;
  hasRequiredDh = 1;
  var a = bnExports$6, u = requireMr(), c = new u(), l = new a(24), v = new a(11), p = new a(10), _ = new a(3), I = new a(7), P = requireGeneratePrime(), $ = browserExports;
  dh = X;
  function F(Q, ne) {
    return ne = ne || "utf8", Buffer$O.isBuffer(Q) || (Q = new Buffer$O(Q, ne)), this._pub = new a(Q), this;
  }
  function H(Q, ne) {
    return ne = ne || "utf8", Buffer$O.isBuffer(Q) || (Q = new Buffer$O(Q, ne)), this._priv = new a(Q), this;
  }
  var j = {};
  function ee(Q, ne) {
    var Z = ne.toString("hex"), de = [Z, Q.toString(16)].join("_");
    if (de in j)
      return j[de];
    var he = 0;
    if (Q.isEven() || !P.simpleSieve || !P.fermatTest(Q) || !c.test(Q))
      return he += 1, Z === "02" || Z === "05" ? he += 8 : he += 4, j[de] = he, he;
    c.test(Q.shrn(1)) || (he += 2);
    var pe;
    switch (Z) {
      case "02":
        Q.mod(l).cmp(v) && (he += 8);
        break;
      case "05":
        pe = Q.mod(p), pe.cmp(_) && pe.cmp(I) && (he += 8);
        break;
      default:
        he += 4;
    }
    return j[de] = he, he;
  }
  function X(Q, ne, Z) {
    this.setGenerator(ne), this.__prime = new a(Q), this._prime = a.mont(this.__prime), this._primeLen = Q.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, Z ? (this.setPublicKey = F, this.setPrivateKey = H) : this._primeCode = 8;
  }
  Object.defineProperty(X.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = ee(this.__prime, this.__gen)), this._primeCode;
    }
  }), X.prototype.generateKeys = function() {
    return this._priv || (this._priv = new a($(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, X.prototype.computeSecret = function(Q) {
    Q = new a(Q), Q = Q.toRed(this._prime);
    var ne = Q.redPow(this._priv).fromRed(), Z = new Buffer$O(ne.toArray()), de = this.getPrime();
    if (Z.length < de.length) {
      var he = new Buffer$O(de.length - Z.length);
      he.fill(0), Z = Buffer$O.concat([he, Z]);
    }
    return Z;
  }, X.prototype.getPublicKey = function(ne) {
    return ie(this._pub, ne);
  }, X.prototype.getPrivateKey = function(ne) {
    return ie(this._priv, ne);
  }, X.prototype.getPrime = function(Q) {
    return ie(this.__prime, Q);
  }, X.prototype.getGenerator = function(Q) {
    return ie(this._gen, Q);
  }, X.prototype.setGenerator = function(Q, ne) {
    return ne = ne || "utf8", Buffer$O.isBuffer(Q) || (Q = new Buffer$O(Q, ne)), this.__gen = Q, this._gen = new a(Q), this;
  };
  function ie(Q, ne) {
    var Z = new Buffer$O(Q.toArray());
    return ne ? Z.toString(ne) : Z;
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2)
    return browser$5;
  hasRequiredBrowser$2 = 1;
  var a = requireGeneratePrime(), u = require$$1$1, c = requireDh();
  function l(_) {
    var I = new Buffer$O(u[_].prime, "hex"), P = new Buffer$O(u[_].gen, "hex");
    return new c(I, P);
  }
  var v = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function p(_, I, P, $) {
    return Buffer$O.isBuffer(I) || v[I] === void 0 ? p(_, "binary", I, P) : (I = I || "binary", $ = $ || "binary", P = P || new Buffer$O([2]), Buffer$O.isBuffer(P) || (P = new Buffer$O(P, $)), typeof _ == "number" ? new c(a(_, P), P, !0) : (Buffer$O.isBuffer(_) || (_ = new Buffer$O(_, I)), new c(_, P, !0)));
  }
  return browser$5.DiffieHellmanGroup = browser$5.createDiffieHellmanGroup = browser$5.getDiffieHellman = l, browser$5.createDiffieHellman = browser$5.DiffieHellman = p, browser$5;
}
var safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(a, u) {
  var c = require$$0$2, l = c.Buffer;
  function v(_, I) {
    for (var P in _)
      I[P] = _[P];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = p);
  function p(_, I, P) {
    return l(_, I, P);
  }
  p.prototype = Object.create(l.prototype), v(l, p), p.from = function(_, I, P) {
    if (typeof _ == "number")
      throw new TypeError("Argument must not be a number");
    return l(_, I, P);
  }, p.alloc = function(_, I, P) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    var $ = l(_);
    return I !== void 0 ? typeof P == "string" ? $.fill(I, P) : $.fill(I) : $.fill(0), $;
  }, p.allocUnsafe = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return l(_);
  }, p.allocUnsafeSlow = function(_) {
    if (typeof _ != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(_);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, readableBrowser = { exports: {} }, streamBrowser = eventsExports.EventEmitter, buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function a(X, ie) {
    var Q = Object.keys(X);
    if (Object.getOwnPropertySymbols) {
      var ne = Object.getOwnPropertySymbols(X);
      ie && (ne = ne.filter(function(Z) {
        return Object.getOwnPropertyDescriptor(X, Z).enumerable;
      })), Q.push.apply(Q, ne);
    }
    return Q;
  }
  function u(X) {
    for (var ie = 1; ie < arguments.length; ie++) {
      var Q = arguments[ie] != null ? arguments[ie] : {};
      ie % 2 ? a(Object(Q), !0).forEach(function(ne) {
        c(X, ne, Q[ne]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(X, Object.getOwnPropertyDescriptors(Q)) : a(Object(Q)).forEach(function(ne) {
        Object.defineProperty(X, ne, Object.getOwnPropertyDescriptor(Q, ne));
      });
    }
    return X;
  }
  function c(X, ie, Q) {
    return ie = _(ie), ie in X ? Object.defineProperty(X, ie, { value: Q, enumerable: !0, configurable: !0, writable: !0 }) : X[ie] = Q, X;
  }
  function l(X, ie) {
    if (!(X instanceof ie))
      throw new TypeError("Cannot call a class as a function");
  }
  function v(X, ie) {
    for (var Q = 0; Q < ie.length; Q++) {
      var ne = ie[Q];
      ne.enumerable = ne.enumerable || !1, ne.configurable = !0, "value" in ne && (ne.writable = !0), Object.defineProperty(X, _(ne.key), ne);
    }
  }
  function p(X, ie, Q) {
    return ie && v(X.prototype, ie), Q && v(X, Q), Object.defineProperty(X, "prototype", { writable: !1 }), X;
  }
  function _(X) {
    var ie = I(X, "string");
    return typeof ie == "symbol" ? ie : String(ie);
  }
  function I(X, ie) {
    if (typeof X != "object" || X === null)
      return X;
    var Q = X[Symbol.toPrimitive];
    if (Q !== void 0) {
      var ne = Q.call(X, ie || "default");
      if (typeof ne != "object")
        return ne;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ie === "string" ? String : Number)(X);
  }
  var P = require$$0$2, $ = P.Buffer, F = util$4, H = F.inspect, j = H && H.custom || "inspect";
  function ee(X, ie, Q) {
    $.prototype.copy.call(X, ie, Q);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function X() {
      l(this, X), this.head = null, this.tail = null, this.length = 0;
    }
    return p(X, [{
      key: "push",
      value: function(Q) {
        var ne = {
          data: Q,
          next: null
        };
        this.length > 0 ? this.tail.next = ne : this.head = ne, this.tail = ne, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Q) {
        var ne = {
          data: Q,
          next: this.head
        };
        this.length === 0 && (this.tail = ne), this.head = ne, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Q = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Q;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Q) {
        if (this.length === 0)
          return "";
        for (var ne = this.head, Z = "" + ne.data; ne = ne.next; )
          Z += Q + ne.data;
        return Z;
      }
    }, {
      key: "concat",
      value: function(Q) {
        if (this.length === 0)
          return $.alloc(0);
        for (var ne = $.allocUnsafe(Q >>> 0), Z = this.head, de = 0; Z; )
          ee(Z.data, ne, de), de += Z.data.length, Z = Z.next;
        return ne;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Q, ne) {
        var Z;
        return Q < this.head.data.length ? (Z = this.head.data.slice(0, Q), this.head.data = this.head.data.slice(Q)) : Q === this.head.data.length ? Z = this.shift() : Z = ne ? this._getString(Q) : this._getBuffer(Q), Z;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Q) {
        var ne = this.head, Z = 1, de = ne.data;
        for (Q -= de.length; ne = ne.next; ) {
          var he = ne.data, pe = Q > he.length ? he.length : Q;
          if (pe === he.length ? de += he : de += he.slice(0, Q), Q -= pe, Q === 0) {
            pe === he.length ? (++Z, ne.next ? this.head = ne.next : this.head = this.tail = null) : (this.head = ne, ne.data = he.slice(pe));
            break;
          }
          ++Z;
        }
        return this.length -= Z, de;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Q) {
        var ne = $.allocUnsafe(Q), Z = this.head, de = 1;
        for (Z.data.copy(ne), Q -= Z.data.length; Z = Z.next; ) {
          var he = Z.data, pe = Q > he.length ? he.length : Q;
          if (he.copy(ne, ne.length - Q, 0, pe), Q -= pe, Q === 0) {
            pe === he.length ? (++de, Z.next ? this.head = Z.next : this.head = this.tail = null) : (this.head = Z, Z.data = he.slice(pe));
            break;
          }
          ++de;
        }
        return this.length -= de, ne;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: j,
      value: function(Q, ne) {
        return H(this, u(u({}, ne), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), X;
  }(), buffer_list;
}
function destroy(a, u) {
  var c = this, l = this._readableState && this._readableState.destroyed, v = this._writableState && this._writableState.destroyed;
  return l || v ? (u ? u(a) : a && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(emitErrorNT, this, a)) : process$1.nextTick(emitErrorNT, this, a)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(a || null, function(p) {
    !u && p ? c._writableState ? c._writableState.errorEmitted ? process$1.nextTick(emitCloseNT, c) : (c._writableState.errorEmitted = !0, process$1.nextTick(emitErrorAndCloseNT, c, p)) : process$1.nextTick(emitErrorAndCloseNT, c, p) : u ? (process$1.nextTick(emitCloseNT, c), u(p)) : process$1.nextTick(emitCloseNT, c);
  }), this);
}
function emitErrorAndCloseNT(a, u) {
  emitErrorNT(a, u), emitCloseNT(a);
}
function emitCloseNT(a) {
  a._writableState && !a._writableState.emitClose || a._readableState && !a._readableState.emitClose || a.emit("close");
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(a, u) {
  a.emit("error", u);
}
function errorOrDestroy(a, u) {
  var c = a._readableState, l = a._writableState;
  c && c.autoDestroy || l && l.autoDestroy ? a.destroy(u) : a.emit("error", u);
}
var destroy_1 = {
  destroy,
  undestroy,
  errorOrDestroy
}, errorsBrowser = {};
function _inheritsLoose$1(a, u) {
  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, a.__proto__ = u;
}
var codes = {};
function createErrorType(a, u, c) {
  c || (c = Error);
  function l(p, _, I) {
    return typeof u == "string" ? u : u(p, _, I);
  }
  var v = /* @__PURE__ */ function(p) {
    _inheritsLoose$1(_, p);
    function _(I, P, $) {
      return p.call(this, l(I, P, $)) || this;
    }
    return _;
  }(c);
  v.prototype.name = c.name, v.prototype.code = a, codes[a] = v;
}
function oneOf(a, u) {
  if (Array.isArray(a)) {
    var c = a.length;
    return a = a.map(function(l) {
      return String(l);
    }), c > 2 ? "one of ".concat(u, " ").concat(a.slice(0, c - 1).join(", "), ", or ") + a[c - 1] : c === 2 ? "one of ".concat(u, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(u, " ").concat(a[0]);
  } else
    return "of ".concat(u, " ").concat(String(a));
}
function startsWith(a, u, c) {
  return a.substr(!c || c < 0 ? 0 : +c, u.length) === u;
}
function endsWith(a, u, c) {
  return (c === void 0 || c > a.length) && (c = a.length), a.substring(c - u.length, c) === u;
}
function includes$2(a, u, c) {
  return typeof c != "number" && (c = 0), c + u.length > a.length ? !1 : a.indexOf(u, c) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(a, u) {
  return 'The value "' + u + '" is invalid for option "' + a + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(a, u, c) {
  var l;
  typeof u == "string" && startsWith(u, "not ") ? (l = "must not be", u = u.replace(/^not /, "")) : l = "must be";
  var v;
  if (endsWith(a, " argument"))
    v = "The ".concat(a, " ").concat(l, " ").concat(oneOf(u, "type"));
  else {
    var p = includes$2(a, ".") ? "property" : "argument";
    v = 'The "'.concat(a, '" ').concat(p, " ").concat(l, " ").concat(oneOf(u, "type"));
  }
  return v += ". Received type ".concat(typeof c), v;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
  return "The " + a + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(a) {
  return "Cannot call " + a + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(a) {
  return "Unknown encoding: " + a;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var ERR_INVALID_OPT_VALUE = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(a, u, c) {
  return a.highWaterMark != null ? a.highWaterMark : u ? a[c] : null;
}
function getHighWaterMark(a, u, c, l) {
  var v = highWaterMarkFrom(u, l, c);
  if (v != null) {
    if (!(isFinite(v) && Math.floor(v) === v) || v < 0) {
      var p = l ? c : "highWaterMark";
      throw new ERR_INVALID_OPT_VALUE(p, v);
    }
    return Math.floor(v);
  }
  return a.objectMode ? 16 : 16 * 1024;
}
var state$3 = {
  getHighWaterMark
}, _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1, _stream_writable = _e;
  function a(ye) {
    var fe = this;
    this.next = null, this.entry = null, this.finish = function() {
      $e(fe, ye);
    };
  }
  var u;
  _e.WritableState = be;
  var c = {
    deprecate: browser$c
  }, l = streamBrowser, v = require$$0$2.Buffer, p = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function _(ye) {
    return v.from(ye);
  }
  function I(ye) {
    return v.isBuffer(ye) || ye instanceof p;
  }
  var P = destroy_1, $ = state$3, F = $.getHighWaterMark, H = errorsBrowser.codes, j = H.ERR_INVALID_ARG_TYPE, ee = H.ERR_METHOD_NOT_IMPLEMENTED, X = H.ERR_MULTIPLE_CALLBACK, ie = H.ERR_STREAM_CANNOT_PIPE, Q = H.ERR_STREAM_DESTROYED, ne = H.ERR_STREAM_NULL_VALUES, Z = H.ERR_STREAM_WRITE_AFTER_END, de = H.ERR_UNKNOWN_ENCODING, he = P.errorOrDestroy;
  inherits_browserExports(_e, l);
  function pe() {
  }
  function be(ye, fe, Me) {
    u = u || require_stream_duplex(), ye = ye || {}, typeof Me != "boolean" && (Me = fe instanceof u), this.objectMode = !!ye.objectMode, Me && (this.objectMode = this.objectMode || !!ye.writableObjectMode), this.highWaterMark = F(this, ye, "writableHighWaterMark", Me), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ae = ye.decodeStrings === !1;
    this.decodeStrings = !Ae, this.defaultEncoding = ye.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(xe) {
      A(fe, xe);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ye.emitClose !== !1, this.autoDestroy = !!ye.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
  }
  be.prototype.getBuffer = function() {
    for (var fe = this.bufferedRequest, Me = []; fe; )
      Me.push(fe), fe = fe.next;
    return Me;
  }, function() {
    try {
      Object.defineProperty(be.prototype, "buffer", {
        get: c.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ke;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ke = Function.prototype[Symbol.hasInstance], Object.defineProperty(_e, Symbol.hasInstance, {
    value: function(fe) {
      return ke.call(this, fe) ? !0 : this !== _e ? !1 : fe && fe._writableState instanceof be;
    }
  })) : ke = function(fe) {
    return fe instanceof this;
  };
  function _e(ye) {
    u = u || require_stream_duplex();
    var fe = this instanceof u;
    if (!fe && !ke.call(_e, this))
      return new _e(ye);
    this._writableState = new be(ye, this, fe), this.writable = !0, ye && (typeof ye.write == "function" && (this._write = ye.write), typeof ye.writev == "function" && (this._writev = ye.writev), typeof ye.destroy == "function" && (this._destroy = ye.destroy), typeof ye.final == "function" && (this._final = ye.final)), l.call(this);
  }
  _e.prototype.pipe = function() {
    he(this, new ie());
  };
  function q(ye, fe) {
    var Me = new Z();
    he(ye, Me), process$1.nextTick(fe, Me);
  }
  function z(ye, fe, Me, Ae) {
    var xe;
    return Me === null ? xe = new ne() : typeof Me != "string" && !fe.objectMode && (xe = new j("chunk", ["string", "Buffer"], Me)), xe ? (he(ye, xe), process$1.nextTick(Ae, xe), !1) : !0;
  }
  _e.prototype.write = function(ye, fe, Me) {
    var Ae = this._writableState, xe = !1, ae = !Ae.objectMode && I(ye);
    return ae && !v.isBuffer(ye) && (ye = _(ye)), typeof fe == "function" && (Me = fe, fe = null), ae ? fe = "buffer" : fe || (fe = Ae.defaultEncoding), typeof Me != "function" && (Me = pe), Ae.ending ? q(this, Me) : (ae || z(this, Ae, ye, Me)) && (Ae.pendingcb++, xe = b(this, Ae, ae, ye, fe, Me)), xe;
  }, _e.prototype.cork = function() {
    this._writableState.corked++;
  }, _e.prototype.uncork = function() {
    var ye = this._writableState;
    ye.corked && (ye.corked--, !ye.writing && !ye.corked && !ye.bufferProcessing && ye.bufferedRequest && B(this, ye));
  }, _e.prototype.setDefaultEncoding = function(fe) {
    if (typeof fe == "string" && (fe = fe.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((fe + "").toLowerCase()) > -1))
      throw new de(fe);
    return this._writableState.defaultEncoding = fe, this;
  }, Object.defineProperty(_e.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function C(ye, fe, Me) {
    return !ye.objectMode && ye.decodeStrings !== !1 && typeof fe == "string" && (fe = v.from(fe, Me)), fe;
  }
  Object.defineProperty(_e.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function b(ye, fe, Me, Ae, xe, ae) {
    if (!Me) {
      var N = C(fe, Ae, xe);
      Ae !== N && (Me = !0, xe = "buffer", Ae = N);
    }
    var re = fe.objectMode ? 1 : Ae.length;
    fe.length += re;
    var le = fe.length < fe.highWaterMark;
    if (le || (fe.needDrain = !0), fe.writing || fe.corked) {
      var Ne = fe.lastBufferedRequest;
      fe.lastBufferedRequest = {
        chunk: Ae,
        encoding: xe,
        isBuf: Me,
        callback: ae,
        next: null
      }, Ne ? Ne.next = fe.lastBufferedRequest : fe.bufferedRequest = fe.lastBufferedRequest, fe.bufferedRequestCount += 1;
    } else
      E(ye, fe, !1, re, Ae, xe, ae);
    return le;
  }
  function E(ye, fe, Me, Ae, xe, ae, N) {
    fe.writelen = Ae, fe.writecb = N, fe.writing = !0, fe.sync = !0, fe.destroyed ? fe.onwrite(new Q("write")) : Me ? ye._writev(xe, fe.onwrite) : ye._write(xe, ae, fe.onwrite), fe.sync = !1;
  }
  function k(ye, fe, Me, Ae, xe) {
    --fe.pendingcb, Me ? (process$1.nextTick(xe, Ae), process$1.nextTick(me, ye, fe), ye._writableState.errorEmitted = !0, he(ye, Ae)) : (xe(Ae), ye._writableState.errorEmitted = !0, he(ye, Ae), me(ye, fe));
  }
  function O(ye) {
    ye.writing = !1, ye.writecb = null, ye.length -= ye.writelen, ye.writelen = 0;
  }
  function A(ye, fe) {
    var Me = ye._writableState, Ae = Me.sync, xe = Me.writecb;
    if (typeof xe != "function")
      throw new X();
    if (O(Me), fe)
      k(ye, Me, Ae, fe, xe);
    else {
      var ae = T(Me) || ye.destroyed;
      !ae && !Me.corked && !Me.bufferProcessing && Me.bufferedRequest && B(ye, Me), Ae ? process$1.nextTick(x, ye, Me, ae, xe) : x(ye, Me, ae, xe);
    }
  }
  function x(ye, fe, Me, Ae) {
    Me || Y(ye, fe), fe.pendingcb--, Ae(), me(ye, fe);
  }
  function Y(ye, fe) {
    fe.length === 0 && fe.needDrain && (fe.needDrain = !1, ye.emit("drain"));
  }
  function B(ye, fe) {
    fe.bufferProcessing = !0;
    var Me = fe.bufferedRequest;
    if (ye._writev && Me && Me.next) {
      var Ae = fe.bufferedRequestCount, xe = new Array(Ae), ae = fe.corkedRequestsFree;
      ae.entry = Me;
      for (var N = 0, re = !0; Me; )
        xe[N] = Me, Me.isBuf || (re = !1), Me = Me.next, N += 1;
      xe.allBuffers = re, E(ye, fe, !0, fe.length, xe, "", ae.finish), fe.pendingcb++, fe.lastBufferedRequest = null, ae.next ? (fe.corkedRequestsFree = ae.next, ae.next = null) : fe.corkedRequestsFree = new a(fe), fe.bufferedRequestCount = 0;
    } else {
      for (; Me; ) {
        var le = Me.chunk, Ne = Me.encoding, Oe = Me.callback, qe = fe.objectMode ? 1 : le.length;
        if (E(ye, fe, !1, qe, le, Ne, Oe), Me = Me.next, fe.bufferedRequestCount--, fe.writing)
          break;
      }
      Me === null && (fe.lastBufferedRequest = null);
    }
    fe.bufferedRequest = Me, fe.bufferProcessing = !1;
  }
  _e.prototype._write = function(ye, fe, Me) {
    Me(new ee("_write()"));
  }, _e.prototype._writev = null, _e.prototype.end = function(ye, fe, Me) {
    var Ae = this._writableState;
    return typeof ye == "function" ? (Me = ye, ye = null, fe = null) : typeof fe == "function" && (Me = fe, fe = null), ye != null && this.write(ye, fe), Ae.corked && (Ae.corked = 1, this.uncork()), Ae.ending || Ie(this, Ae, Me), this;
  }, Object.defineProperty(_e.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function T(ye) {
    return ye.ending && ye.length === 0 && ye.bufferedRequest === null && !ye.finished && !ye.writing;
  }
  function D(ye, fe) {
    ye._final(function(Me) {
      fe.pendingcb--, Me && he(ye, Me), fe.prefinished = !0, ye.emit("prefinish"), me(ye, fe);
    });
  }
  function te(ye, fe) {
    !fe.prefinished && !fe.finalCalled && (typeof ye._final == "function" && !fe.destroyed ? (fe.pendingcb++, fe.finalCalled = !0, process$1.nextTick(D, ye, fe)) : (fe.prefinished = !0, ye.emit("prefinish")));
  }
  function me(ye, fe) {
    var Me = T(fe);
    if (Me && (te(ye, fe), fe.pendingcb === 0 && (fe.finished = !0, ye.emit("finish"), fe.autoDestroy))) {
      var Ae = ye._readableState;
      (!Ae || Ae.autoDestroy && Ae.endEmitted) && ye.destroy();
    }
    return Me;
  }
  function Ie(ye, fe, Me) {
    fe.ending = !0, me(ye, fe), Me && (fe.finished ? process$1.nextTick(Me) : ye.once("finish", Me)), fe.ended = !0, ye.writable = !1;
  }
  function $e(ye, fe, Me) {
    var Ae = ye.entry;
    for (ye.entry = null; Ae; ) {
      var xe = Ae.callback;
      fe.pendingcb--, xe(Me), Ae = Ae.next;
    }
    fe.corkedRequestsFree.next = ye;
  }
  return Object.defineProperty(_e.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(fe) {
      this._writableState && (this._writableState.destroyed = fe);
    }
  }), _e.prototype.destroy = P.destroy, _e.prototype._undestroy = P.undestroy, _e.prototype._destroy = function(ye, fe) {
    fe(ye);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var a = Object.keys || function($) {
    var F = [];
    for (var H in $)
      F.push(H);
    return F;
  };
  _stream_duplex = _;
  var u = require_stream_readable(), c = require_stream_writable();
  inherits_browserExports(_, u);
  for (var l = a(c.prototype), v = 0; v < l.length; v++) {
    var p = l[v];
    _.prototype[p] || (_.prototype[p] = c.prototype[p]);
  }
  function _($) {
    if (!(this instanceof _))
      return new _($);
    u.call(this, $), c.call(this, $), this.allowHalfOpen = !0, $ && ($.readable === !1 && (this.readable = !1), $.writable === !1 && (this.writable = !1), $.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", I)));
  }
  Object.defineProperty(_.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(_.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(_.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function I() {
    this._writableState.ended || process$1.nextTick(P, this);
  }
  function P($) {
    $.end();
  }
  return Object.defineProperty(_.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(F) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = F, this._writableState.destroyed = F);
    }
  }), _stream_duplex;
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once$3(a) {
  var u = !1;
  return function() {
    if (!u) {
      u = !0;
      for (var c = arguments.length, l = new Array(c), v = 0; v < c; v++)
        l[v] = arguments[v];
      a.apply(this, l);
    }
  };
}
function noop$2() {
}
function isRequest$1(a) {
  return a.setHeader && typeof a.abort == "function";
}
function eos$1(a, u, c) {
  if (typeof u == "function")
    return eos$1(a, null, u);
  u || (u = {}), c = once$3(c || noop$2);
  var l = u.readable || u.readable !== !1 && a.readable, v = u.writable || u.writable !== !1 && a.writable, p = function() {
    a.writable || I();
  }, _ = a._writableState && a._writableState.finished, I = function() {
    v = !1, _ = !0, l || c.call(a);
  }, P = a._readableState && a._readableState.endEmitted, $ = function() {
    l = !1, P = !0, v || c.call(a);
  }, F = function(X) {
    c.call(a, X);
  }, H = function() {
    var X;
    if (l && !P)
      return (!a._readableState || !a._readableState.ended) && (X = new ERR_STREAM_PREMATURE_CLOSE()), c.call(a, X);
    if (v && !_)
      return (!a._writableState || !a._writableState.ended) && (X = new ERR_STREAM_PREMATURE_CLOSE()), c.call(a, X);
  }, j = function() {
    a.req.on("finish", I);
  };
  return isRequest$1(a) ? (a.on("complete", I), a.on("abort", H), a.req ? j() : a.on("request", j)) : v && !a._writableState && (a.on("end", p), a.on("close", p)), a.on("end", $), a.on("finish", I), u.error !== !1 && a.on("error", F), a.on("close", H), function() {
    a.removeListener("complete", I), a.removeListener("abort", H), a.removeListener("request", j), a.req && a.req.removeListener("finish", I), a.removeListener("end", p), a.removeListener("close", p), a.removeListener("finish", I), a.removeListener("end", $), a.removeListener("error", F), a.removeListener("close", H);
  };
}
var endOfStream = eos$1, async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var a;
  function u(de, he, pe) {
    return he = c(he), he in de ? Object.defineProperty(de, he, { value: pe, enumerable: !0, configurable: !0, writable: !0 }) : de[he] = pe, de;
  }
  function c(de) {
    var he = l(de, "string");
    return typeof he == "symbol" ? he : String(he);
  }
  function l(de, he) {
    if (typeof de != "object" || de === null)
      return de;
    var pe = de[Symbol.toPrimitive];
    if (pe !== void 0) {
      var be = pe.call(de, he || "default");
      if (typeof be != "object")
        return be;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (he === "string" ? String : Number)(de);
  }
  var v = endOfStream, p = Symbol("lastResolve"), _ = Symbol("lastReject"), I = Symbol("error"), P = Symbol("ended"), $ = Symbol("lastPromise"), F = Symbol("handlePromise"), H = Symbol("stream");
  function j(de, he) {
    return {
      value: de,
      done: he
    };
  }
  function ee(de) {
    var he = de[p];
    if (he !== null) {
      var pe = de[H].read();
      pe !== null && (de[$] = null, de[p] = null, de[_] = null, he(j(pe, !1)));
    }
  }
  function X(de) {
    process$1.nextTick(ee, de);
  }
  function ie(de, he) {
    return function(pe, be) {
      de.then(function() {
        if (he[P]) {
          pe(j(void 0, !0));
          return;
        }
        he[F](pe, be);
      }, be);
    };
  }
  var Q = Object.getPrototypeOf(function() {
  }), ne = Object.setPrototypeOf((a = {
    get stream() {
      return this[H];
    },
    next: function() {
      var he = this, pe = this[I];
      if (pe !== null)
        return Promise.reject(pe);
      if (this[P])
        return Promise.resolve(j(void 0, !0));
      if (this[H].destroyed)
        return new Promise(function(q, z) {
          process$1.nextTick(function() {
            he[I] ? z(he[I]) : q(j(void 0, !0));
          });
        });
      var be = this[$], ke;
      if (be)
        ke = new Promise(ie(be, this));
      else {
        var _e = this[H].read();
        if (_e !== null)
          return Promise.resolve(j(_e, !1));
        ke = new Promise(this[F]);
      }
      return this[$] = ke, ke;
    }
  }, u(a, Symbol.asyncIterator, function() {
    return this;
  }), u(a, "return", function() {
    var he = this;
    return new Promise(function(pe, be) {
      he[H].destroy(null, function(ke) {
        if (ke) {
          be(ke);
          return;
        }
        pe(j(void 0, !0));
      });
    });
  }), a), Q), Z = function(he) {
    var pe, be = Object.create(ne, (pe = {}, u(pe, H, {
      value: he,
      writable: !0
    }), u(pe, p, {
      value: null,
      writable: !0
    }), u(pe, _, {
      value: null,
      writable: !0
    }), u(pe, I, {
      value: null,
      writable: !0
    }), u(pe, P, {
      value: he._readableState.endEmitted,
      writable: !0
    }), u(pe, F, {
      value: function(_e, q) {
        var z = be[H].read();
        z ? (be[$] = null, be[p] = null, be[_] = null, _e(j(z, !1))) : (be[p] = _e, be[_] = q);
      },
      writable: !0
    }), pe));
    return be[$] = null, v(he, function(ke) {
      if (ke && ke.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var _e = be[_];
        _e !== null && (be[$] = null, be[p] = null, be[_] = null, _e(ke)), be[I] = ke;
        return;
      }
      var q = be[p];
      q !== null && (be[$] = null, be[p] = null, be[_] = null, q(j(void 0, !0))), be[P] = !0;
    }), he.on("readable", X.bind(null, be)), be;
  };
  return async_iterator = Z, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1, _stream_readable = q;
  var a;
  q.ReadableState = _e, eventsExports.EventEmitter;
  var u = function(N, re) {
    return N.listeners(re).length;
  }, c = streamBrowser, l = require$$0$2.Buffer, v = (typeof commonjsGlobal$1 < "u" ? commonjsGlobal$1 : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(ae) {
    return l.from(ae);
  }
  function _(ae) {
    return l.isBuffer(ae) || ae instanceof v;
  }
  var I = util$4, P;
  I && I.debuglog ? P = I.debuglog("stream") : P = function() {
  };
  var $ = requireBuffer_list(), F = destroy_1, H = state$3, j = H.getHighWaterMark, ee = errorsBrowser.codes, X = ee.ERR_INVALID_ARG_TYPE, ie = ee.ERR_STREAM_PUSH_AFTER_EOF, Q = ee.ERR_METHOD_NOT_IMPLEMENTED, ne = ee.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Z, de, he;
  inherits_browserExports(q, c);
  var pe = F.errorOrDestroy, be = ["error", "close", "destroy", "pause", "resume"];
  function ke(ae, N, re) {
    if (typeof ae.prependListener == "function")
      return ae.prependListener(N, re);
    !ae._events || !ae._events[N] ? ae.on(N, re) : Array.isArray(ae._events[N]) ? ae._events[N].unshift(re) : ae._events[N] = [re, ae._events[N]];
  }
  function _e(ae, N, re) {
    a = a || require_stream_duplex(), ae = ae || {}, typeof re != "boolean" && (re = N instanceof a), this.objectMode = !!ae.objectMode, re && (this.objectMode = this.objectMode || !!ae.readableObjectMode), this.highWaterMark = j(this, ae, "readableHighWaterMark", re), this.buffer = new $(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = ae.emitClose !== !1, this.autoDestroy = !!ae.autoDestroy, this.destroyed = !1, this.defaultEncoding = ae.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, ae.encoding && (Z || (Z = string_decoder.StringDecoder), this.decoder = new Z(ae.encoding), this.encoding = ae.encoding);
  }
  function q(ae) {
    if (a = a || require_stream_duplex(), !(this instanceof q))
      return new q(ae);
    var N = this instanceof a;
    this._readableState = new _e(ae, this, N), this.readable = !0, ae && (typeof ae.read == "function" && (this._read = ae.read), typeof ae.destroy == "function" && (this._destroy = ae.destroy)), c.call(this);
  }
  Object.defineProperty(q.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(N) {
      this._readableState && (this._readableState.destroyed = N);
    }
  }), q.prototype.destroy = F.destroy, q.prototype._undestroy = F.undestroy, q.prototype._destroy = function(ae, N) {
    N(ae);
  }, q.prototype.push = function(ae, N) {
    var re = this._readableState, le;
    return re.objectMode ? le = !0 : typeof ae == "string" && (N = N || re.defaultEncoding, N !== re.encoding && (ae = l.from(ae, N), N = ""), le = !0), z(this, ae, N, !1, le);
  }, q.prototype.unshift = function(ae) {
    return z(this, ae, null, !0, !1);
  };
  function z(ae, N, re, le, Ne) {
    P("readableAddChunk", N);
    var Oe = ae._readableState;
    if (N === null)
      Oe.reading = !1, A(ae, Oe);
    else {
      var qe;
      if (Ne || (qe = b(Oe, N)), qe)
        pe(ae, qe);
      else if (Oe.objectMode || N && N.length > 0)
        if (typeof N != "string" && !Oe.objectMode && Object.getPrototypeOf(N) !== l.prototype && (N = p(N)), le)
          Oe.endEmitted ? pe(ae, new ne()) : C(ae, Oe, N, !0);
        else if (Oe.ended)
          pe(ae, new ie());
        else {
          if (Oe.destroyed)
            return !1;
          Oe.reading = !1, Oe.decoder && !re ? (N = Oe.decoder.write(N), Oe.objectMode || N.length !== 0 ? C(ae, Oe, N, !1) : B(ae, Oe)) : C(ae, Oe, N, !1);
        }
      else
        le || (Oe.reading = !1, B(ae, Oe));
    }
    return !Oe.ended && (Oe.length < Oe.highWaterMark || Oe.length === 0);
  }
  function C(ae, N, re, le) {
    N.flowing && N.length === 0 && !N.sync ? (N.awaitDrain = 0, ae.emit("data", re)) : (N.length += N.objectMode ? 1 : re.length, le ? N.buffer.unshift(re) : N.buffer.push(re), N.needReadable && x(ae)), B(ae, N);
  }
  function b(ae, N) {
    var re;
    return !_(N) && typeof N != "string" && N !== void 0 && !ae.objectMode && (re = new X("chunk", ["string", "Buffer", "Uint8Array"], N)), re;
  }
  q.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, q.prototype.setEncoding = function(ae) {
    Z || (Z = string_decoder.StringDecoder);
    var N = new Z(ae);
    this._readableState.decoder = N, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var re = this._readableState.buffer.head, le = ""; re !== null; )
      le += N.write(re.data), re = re.next;
    return this._readableState.buffer.clear(), le !== "" && this._readableState.buffer.push(le), this._readableState.length = le.length, this;
  };
  var E = 1073741824;
  function k(ae) {
    return ae >= E ? ae = E : (ae--, ae |= ae >>> 1, ae |= ae >>> 2, ae |= ae >>> 4, ae |= ae >>> 8, ae |= ae >>> 16, ae++), ae;
  }
  function O(ae, N) {
    return ae <= 0 || N.length === 0 && N.ended ? 0 : N.objectMode ? 1 : ae !== ae ? N.flowing && N.length ? N.buffer.head.data.length : N.length : (ae > N.highWaterMark && (N.highWaterMark = k(ae)), ae <= N.length ? ae : N.ended ? N.length : (N.needReadable = !0, 0));
  }
  q.prototype.read = function(ae) {
    P("read", ae), ae = parseInt(ae, 10);
    var N = this._readableState, re = ae;
    if (ae !== 0 && (N.emittedReadable = !1), ae === 0 && N.needReadable && ((N.highWaterMark !== 0 ? N.length >= N.highWaterMark : N.length > 0) || N.ended))
      return P("read: emitReadable", N.length, N.ended), N.length === 0 && N.ended ? Me(this) : x(this), null;
    if (ae = O(ae, N), ae === 0 && N.ended)
      return N.length === 0 && Me(this), null;
    var le = N.needReadable;
    P("need readable", le), (N.length === 0 || N.length - ae < N.highWaterMark) && (le = !0, P("length less than watermark", le)), N.ended || N.reading ? (le = !1, P("reading or ended", le)) : le && (P("do read"), N.reading = !0, N.sync = !0, N.length === 0 && (N.needReadable = !0), this._read(N.highWaterMark), N.sync = !1, N.reading || (ae = O(re, N)));
    var Ne;
    return ae > 0 ? Ne = fe(ae, N) : Ne = null, Ne === null ? (N.needReadable = N.length <= N.highWaterMark, ae = 0) : (N.length -= ae, N.awaitDrain = 0), N.length === 0 && (N.ended || (N.needReadable = !0), re !== ae && N.ended && Me(this)), Ne !== null && this.emit("data", Ne), Ne;
  };
  function A(ae, N) {
    if (P("onEofChunk"), !N.ended) {
      if (N.decoder) {
        var re = N.decoder.end();
        re && re.length && (N.buffer.push(re), N.length += N.objectMode ? 1 : re.length);
      }
      N.ended = !0, N.sync ? x(ae) : (N.needReadable = !1, N.emittedReadable || (N.emittedReadable = !0, Y(ae)));
    }
  }
  function x(ae) {
    var N = ae._readableState;
    P("emitReadable", N.needReadable, N.emittedReadable), N.needReadable = !1, N.emittedReadable || (P("emitReadable", N.flowing), N.emittedReadable = !0, process$1.nextTick(Y, ae));
  }
  function Y(ae) {
    var N = ae._readableState;
    P("emitReadable_", N.destroyed, N.length, N.ended), !N.destroyed && (N.length || N.ended) && (ae.emit("readable"), N.emittedReadable = !1), N.needReadable = !N.flowing && !N.ended && N.length <= N.highWaterMark, ye(ae);
  }
  function B(ae, N) {
    N.readingMore || (N.readingMore = !0, process$1.nextTick(T, ae, N));
  }
  function T(ae, N) {
    for (; !N.reading && !N.ended && (N.length < N.highWaterMark || N.flowing && N.length === 0); ) {
      var re = N.length;
      if (P("maybeReadMore read 0"), ae.read(0), re === N.length)
        break;
    }
    N.readingMore = !1;
  }
  q.prototype._read = function(ae) {
    pe(this, new Q("_read()"));
  }, q.prototype.pipe = function(ae, N) {
    var re = this, le = this._readableState;
    switch (le.pipesCount) {
      case 0:
        le.pipes = ae;
        break;
      case 1:
        le.pipes = [le.pipes, ae];
        break;
      default:
        le.pipes.push(ae);
        break;
    }
    le.pipesCount += 1, P("pipe count=%d opts=%j", le.pipesCount, N);
    var Ne = (!N || N.end !== !1) && ae !== process$1.stdout && ae !== process$1.stderr, Oe = Ne ? je : We;
    le.endEmitted ? process$1.nextTick(Oe) : re.once("end", Oe), ae.on("unpipe", qe);
    function qe(Re, J) {
      P("onunpipe"), Re === re && J && J.hasUnpiped === !1 && (J.hasUnpiped = !0, Xe());
    }
    function je() {
      P("onend"), ae.end();
    }
    var Fe = D(re);
    ae.on("drain", Fe);
    var yt = !1;
    function Xe() {
      P("cleanup"), ae.removeListener("close", ge), ae.removeListener("finish", Te), ae.removeListener("drain", Fe), ae.removeListener("error", V), ae.removeListener("unpipe", qe), re.removeListener("end", je), re.removeListener("end", We), re.removeListener("data", Ge), yt = !0, le.awaitDrain && (!ae._writableState || ae._writableState.needDrain) && Fe();
    }
    re.on("data", Ge);
    function Ge(Re) {
      P("ondata");
      var J = ae.write(Re);
      P("dest.write", J), J === !1 && ((le.pipesCount === 1 && le.pipes === ae || le.pipesCount > 1 && xe(le.pipes, ae) !== -1) && !yt && (P("false write response, pause", le.awaitDrain), le.awaitDrain++), re.pause());
    }
    function V(Re) {
      P("onerror", Re), We(), ae.removeListener("error", V), u(ae, "error") === 0 && pe(ae, Re);
    }
    ke(ae, "error", V);
    function ge() {
      ae.removeListener("finish", Te), We();
    }
    ae.once("close", ge);
    function Te() {
      P("onfinish"), ae.removeListener("close", ge), We();
    }
    ae.once("finish", Te);
    function We() {
      P("unpipe"), re.unpipe(ae);
    }
    return ae.emit("pipe", re), le.flowing || (P("pipe resume"), re.resume()), ae;
  };
  function D(ae) {
    return function() {
      var re = ae._readableState;
      P("pipeOnDrain", re.awaitDrain), re.awaitDrain && re.awaitDrain--, re.awaitDrain === 0 && u(ae, "data") && (re.flowing = !0, ye(ae));
    };
  }
  q.prototype.unpipe = function(ae) {
    var N = this._readableState, re = {
      hasUnpiped: !1
    };
    if (N.pipesCount === 0)
      return this;
    if (N.pipesCount === 1)
      return ae && ae !== N.pipes ? this : (ae || (ae = N.pipes), N.pipes = null, N.pipesCount = 0, N.flowing = !1, ae && ae.emit("unpipe", this, re), this);
    if (!ae) {
      var le = N.pipes, Ne = N.pipesCount;
      N.pipes = null, N.pipesCount = 0, N.flowing = !1;
      for (var Oe = 0; Oe < Ne; Oe++)
        le[Oe].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var qe = xe(N.pipes, ae);
    return qe === -1 ? this : (N.pipes.splice(qe, 1), N.pipesCount -= 1, N.pipesCount === 1 && (N.pipes = N.pipes[0]), ae.emit("unpipe", this, re), this);
  }, q.prototype.on = function(ae, N) {
    var re = c.prototype.on.call(this, ae, N), le = this._readableState;
    return ae === "data" ? (le.readableListening = this.listenerCount("readable") > 0, le.flowing !== !1 && this.resume()) : ae === "readable" && !le.endEmitted && !le.readableListening && (le.readableListening = le.needReadable = !0, le.flowing = !1, le.emittedReadable = !1, P("on readable", le.length, le.reading), le.length ? x(this) : le.reading || process$1.nextTick(me, this)), re;
  }, q.prototype.addListener = q.prototype.on, q.prototype.removeListener = function(ae, N) {
    var re = c.prototype.removeListener.call(this, ae, N);
    return ae === "readable" && process$1.nextTick(te, this), re;
  }, q.prototype.removeAllListeners = function(ae) {
    var N = c.prototype.removeAllListeners.apply(this, arguments);
    return (ae === "readable" || ae === void 0) && process$1.nextTick(te, this), N;
  };
  function te(ae) {
    var N = ae._readableState;
    N.readableListening = ae.listenerCount("readable") > 0, N.resumeScheduled && !N.paused ? N.flowing = !0 : ae.listenerCount("data") > 0 && ae.resume();
  }
  function me(ae) {
    P("readable nexttick read 0"), ae.read(0);
  }
  q.prototype.resume = function() {
    var ae = this._readableState;
    return ae.flowing || (P("resume"), ae.flowing = !ae.readableListening, Ie(this, ae)), ae.paused = !1, this;
  };
  function Ie(ae, N) {
    N.resumeScheduled || (N.resumeScheduled = !0, process$1.nextTick($e, ae, N));
  }
  function $e(ae, N) {
    P("resume", N.reading), N.reading || ae.read(0), N.resumeScheduled = !1, ae.emit("resume"), ye(ae), N.flowing && !N.reading && ae.read(0);
  }
  q.prototype.pause = function() {
    return P("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (P("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function ye(ae) {
    var N = ae._readableState;
    for (P("flow", N.flowing); N.flowing && ae.read() !== null; )
      ;
  }
  q.prototype.wrap = function(ae) {
    var N = this, re = this._readableState, le = !1;
    ae.on("end", function() {
      if (P("wrapped end"), re.decoder && !re.ended) {
        var qe = re.decoder.end();
        qe && qe.length && N.push(qe);
      }
      N.push(null);
    }), ae.on("data", function(qe) {
      if (P("wrapped data"), re.decoder && (qe = re.decoder.write(qe)), !(re.objectMode && qe == null) && !(!re.objectMode && (!qe || !qe.length))) {
        var je = N.push(qe);
        je || (le = !0, ae.pause());
      }
    });
    for (var Ne in ae)
      this[Ne] === void 0 && typeof ae[Ne] == "function" && (this[Ne] = /* @__PURE__ */ function(je) {
        return function() {
          return ae[je].apply(ae, arguments);
        };
      }(Ne));
    for (var Oe = 0; Oe < be.length; Oe++)
      ae.on(be[Oe], this.emit.bind(this, be[Oe]));
    return this._read = function(qe) {
      P("wrapped _read", qe), le && (le = !1, ae.resume());
    }, this;
  }, typeof Symbol == "function" && (q.prototype[Symbol.asyncIterator] = function() {
    return de === void 0 && (de = requireAsync_iterator()), de(this);
  }), Object.defineProperty(q.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(q.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(q.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(N) {
      this._readableState && (this._readableState.flowing = N);
    }
  }), q._fromList = fe, Object.defineProperty(q.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function fe(ae, N) {
    if (N.length === 0)
      return null;
    var re;
    return N.objectMode ? re = N.buffer.shift() : !ae || ae >= N.length ? (N.decoder ? re = N.buffer.join("") : N.buffer.length === 1 ? re = N.buffer.first() : re = N.buffer.concat(N.length), N.buffer.clear()) : re = N.buffer.consume(ae, N.decoder), re;
  }
  function Me(ae) {
    var N = ae._readableState;
    P("endReadable", N.endEmitted), N.endEmitted || (N.ended = !0, process$1.nextTick(Ae, N, ae));
  }
  function Ae(ae, N) {
    if (P("endReadableNT", ae.endEmitted, ae.length), !ae.endEmitted && ae.length === 0 && (ae.endEmitted = !0, N.readable = !1, N.emit("end"), ae.autoDestroy)) {
      var re = N._writableState;
      (!re || re.autoDestroy && re.finished) && N.destroy();
    }
  }
  typeof Symbol == "function" && (q.from = function(ae, N) {
    return he === void 0 && (he = requireFromBrowser()), he(q, ae, N);
  });
  function xe(ae, N) {
    for (var re = 0, le = ae.length; re < le; re++)
      if (ae[re] === N)
        return re;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, _require$codes$1 = errorsBrowser.codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes$1.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes$1.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes$1.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes$1.ERR_TRANSFORM_WITH_LENGTH_0, Duplex = require_stream_duplex();
inherits_browserExports(Transform$1, Duplex);
function afterTransform(a, u) {
  var c = this._transformState;
  c.transforming = !1;
  var l = c.writecb;
  if (l === null)
    return this.emit("error", new ERR_MULTIPLE_CALLBACK());
  c.writechunk = null, c.writecb = null, u != null && this.push(u), l(a);
  var v = this._readableState;
  v.reading = !1, (v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
}
function Transform$1(a) {
  if (!(this instanceof Transform$1))
    return new Transform$1(a);
  Duplex.call(this, a), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, a && (typeof a.transform == "function" && (this._transform = a.transform), typeof a.flush == "function" && (this._flush = a.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var a = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(u, c) {
    done(a, u, c);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(a, u) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, a, u);
};
Transform$1.prototype._transform = function(a, u, c) {
  c(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
};
Transform$1.prototype._write = function(a, u, c) {
  var l = this._transformState;
  if (l.writecb = c, l.writechunk = a, l.writeencoding = u, !l.transforming) {
    var v = this._readableState;
    (l.needTransform || v.needReadable || v.length < v.highWaterMark) && this._read(v.highWaterMark);
  }
};
Transform$1.prototype._read = function(a) {
  var u = this._transformState;
  u.writechunk !== null && !u.transforming ? (u.transforming = !0, this._transform(u.writechunk, u.writeencoding, u.afterTransform)) : u.needTransform = !0;
};
Transform$1.prototype._destroy = function(a, u) {
  Duplex.prototype._destroy.call(this, a, function(c) {
    u(c);
  });
};
function done(a, u, c) {
  if (u)
    return a.emit("error", u);
  if (c != null && a.push(c), a._writableState.length)
    throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (a._transformState.transforming)
    throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return a.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform;
inherits_browserExports(PassThrough, Transform);
function PassThrough(a) {
  if (!(this instanceof PassThrough))
    return new PassThrough(a);
  Transform.call(this, a);
}
PassThrough.prototype._transform = function(a, u, c) {
  c(null, a);
};
var eos;
function once$2(a) {
  var u = !1;
  return function() {
    u || (u = !0, a.apply(void 0, arguments));
  };
}
var _require$codes = errorsBrowser.codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop$1(a) {
  if (a)
    throw a;
}
function isRequest(a) {
  return a.setHeader && typeof a.abort == "function";
}
function destroyer(a, u, c, l) {
  l = once$2(l);
  var v = !1;
  a.on("close", function() {
    v = !0;
  }), eos === void 0 && (eos = endOfStream), eos(a, {
    readable: u,
    writable: c
  }, function(_) {
    if (_)
      return l(_);
    v = !0, l();
  });
  var p = !1;
  return function(_) {
    if (!v && !p) {
      if (p = !0, isRequest(a))
        return a.abort();
      if (typeof a.destroy == "function")
        return a.destroy();
      l(_ || new ERR_STREAM_DESTROYED("pipe"));
    }
  };
}
function call(a) {
  a();
}
function pipe(a, u) {
  return a.pipe(u);
}
function popCallback(a) {
  return !a.length || typeof a[a.length - 1] != "function" ? noop$1 : a.pop();
}
function pipeline() {
  for (var a = arguments.length, u = new Array(a), c = 0; c < a; c++)
    u[c] = arguments[c];
  var l = popCallback(u);
  if (Array.isArray(u[0]) && (u = u[0]), u.length < 2)
    throw new ERR_MISSING_ARGS("streams");
  var v, p = u.map(function(_, I) {
    var P = I < u.length - 1, $ = I > 0;
    return destroyer(_, P, $, function(F) {
      v || (v = F), F && p.forEach(call), !P && (p.forEach(call), l(v));
    });
  });
  return u.reduce(pipe);
}
var pipeline_1 = pipeline;
(function(a, u) {
  u = a.exports = require_stream_readable(), u.Stream = u, u.Readable = u, u.Writable = require_stream_writable(), u.Duplex = require_stream_duplex(), u.Transform = _stream_transform, u.PassThrough = _stream_passthrough, u.finished = endOfStream, u.pipeline = pipeline_1;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, sign$1 = { exports: {} }, bn$4 = { exports: {} };
bn$4.exports;
(function(a) {
  (function(u, c) {
    function l(E, k) {
      if (!E)
        throw new Error(k || "Assertion failed");
    }
    function v(E, k) {
      E.super_ = k;
      var O = function() {
      };
      O.prototype = k.prototype, E.prototype = new O(), E.prototype.constructor = E;
    }
    function p(E, k, O) {
      if (p.isBN(E))
        return E;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, E !== null && ((k === "le" || k === "be") && (O = k, k = 10), this._init(E || 0, k || 10, O || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(k) {
      return k instanceof p ? !0 : k !== null && typeof k == "object" && k.constructor.wordSize === p.wordSize && Array.isArray(k.words);
    }, p.max = function(k, O) {
      return k.cmp(O) > 0 ? k : O;
    }, p.min = function(k, O) {
      return k.cmp(O) < 0 ? k : O;
    }, p.prototype._init = function(k, O, A) {
      if (typeof k == "number")
        return this._initNumber(k, O, A);
      if (typeof k == "object")
        return this._initArray(k, O, A);
      O === "hex" && (O = 16), l(O === (O | 0) && O >= 2 && O <= 36), k = k.toString().replace(/\s+/g, "");
      var x = 0;
      k[0] === "-" && (x++, this.negative = 1), x < k.length && (O === 16 ? this._parseHex(k, x, A) : (this._parseBase(k, O, x), A === "le" && this._initArray(this.toArray(), O, A)));
    }, p.prototype._initNumber = function(k, O, A) {
      k < 0 && (this.negative = 1, k = -k), k < 67108864 ? (this.words = [k & 67108863], this.length = 1) : k < 4503599627370496 ? (this.words = [
        k & 67108863,
        k / 67108864 & 67108863
      ], this.length = 2) : (l(k < 9007199254740992), this.words = [
        k & 67108863,
        k / 67108864 & 67108863,
        1
      ], this.length = 3), A === "le" && this._initArray(this.toArray(), O, A);
    }, p.prototype._initArray = function(k, O, A) {
      if (l(typeof k.length == "number"), k.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(k.length / 3), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var Y, B, T = 0;
      if (A === "be")
        for (x = k.length - 1, Y = 0; x >= 0; x -= 3)
          B = k[x] | k[x - 1] << 8 | k[x - 2] << 16, this.words[Y] |= B << T & 67108863, this.words[Y + 1] = B >>> 26 - T & 67108863, T += 24, T >= 26 && (T -= 26, Y++);
      else if (A === "le")
        for (x = 0, Y = 0; x < k.length; x += 3)
          B = k[x] | k[x + 1] << 8 | k[x + 2] << 16, this.words[Y] |= B << T & 67108863, this.words[Y + 1] = B >>> 26 - T & 67108863, T += 24, T >= 26 && (T -= 26, Y++);
      return this._strip();
    };
    function I(E, k) {
      var O = E.charCodeAt(k);
      if (O >= 48 && O <= 57)
        return O - 48;
      if (O >= 65 && O <= 70)
        return O - 55;
      if (O >= 97 && O <= 102)
        return O - 87;
      l(!1, "Invalid character in " + E);
    }
    function P(E, k, O) {
      var A = I(E, O);
      return O - 1 >= k && (A |= I(E, O - 1) << 4), A;
    }
    p.prototype._parseHex = function(k, O, A) {
      this.length = Math.ceil((k.length - O) / 6), this.words = new Array(this.length);
      for (var x = 0; x < this.length; x++)
        this.words[x] = 0;
      var Y = 0, B = 0, T;
      if (A === "be")
        for (x = k.length - 1; x >= O; x -= 2)
          T = P(k, O, x) << Y, this.words[B] |= T & 67108863, Y >= 18 ? (Y -= 18, B += 1, this.words[B] |= T >>> 26) : Y += 8;
      else {
        var D = k.length - O;
        for (x = D % 2 === 0 ? O + 1 : O; x < k.length; x += 2)
          T = P(k, O, x) << Y, this.words[B] |= T & 67108863, Y >= 18 ? (Y -= 18, B += 1, this.words[B] |= T >>> 26) : Y += 8;
      }
      this._strip();
    };
    function $(E, k, O, A) {
      for (var x = 0, Y = 0, B = Math.min(E.length, O), T = k; T < B; T++) {
        var D = E.charCodeAt(T) - 48;
        x *= A, D >= 49 ? Y = D - 49 + 10 : D >= 17 ? Y = D - 17 + 10 : Y = D, l(D >= 0 && Y < A, "Invalid character"), x += Y;
      }
      return x;
    }
    p.prototype._parseBase = function(k, O, A) {
      this.words = [0], this.length = 1;
      for (var x = 0, Y = 1; Y <= 67108863; Y *= O)
        x++;
      x--, Y = Y / O | 0;
      for (var B = k.length - A, T = B % x, D = Math.min(B, B - T) + A, te = 0, me = A; me < D; me += x)
        te = $(k, me, me + x, O), this.imuln(Y), this.words[0] + te < 67108864 ? this.words[0] += te : this._iaddn(te);
      if (T !== 0) {
        var Ie = 1;
        for (te = $(k, me, k.length, O), me = 0; me < T; me++)
          Ie *= O;
        this.imuln(Ie), this.words[0] + te < 67108864 ? this.words[0] += te : this._iaddn(te);
      }
      this._strip();
    }, p.prototype.copy = function(k) {
      k.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        k.words[O] = this.words[O];
      k.length = this.length, k.negative = this.negative, k.red = this.red;
    };
    function F(E, k) {
      E.words = k.words, E.length = k.length, E.negative = k.negative, E.red = k.red;
    }
    if (p.prototype._move = function(k) {
      F(k, this);
    }, p.prototype.clone = function() {
      var k = new p(null);
      return this.copy(k), k;
    }, p.prototype._expand = function(k) {
      for (; this.length < k; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        p.prototype[Symbol.for("nodejs.util.inspect.custom")] = H;
      } catch {
        p.prototype.inspect = H;
      }
    else
      p.prototype.inspect = H;
    function H() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var j = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ee = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(k, O) {
      k = k || 10, O = O | 0 || 1;
      var A;
      if (k === 16 || k === "hex") {
        A = "";
        for (var x = 0, Y = 0, B = 0; B < this.length; B++) {
          var T = this.words[B], D = ((T << x | Y) & 16777215).toString(16);
          Y = T >>> 24 - x & 16777215, x += 2, x >= 26 && (x -= 26, B--), Y !== 0 || B !== this.length - 1 ? A = j[6 - D.length] + D + A : A = D + A;
        }
        for (Y !== 0 && (A = Y.toString(16) + A); A.length % O !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      if (k === (k | 0) && k >= 2 && k <= 36) {
        var te = ee[k], me = X[k];
        A = "";
        var Ie = this.clone();
        for (Ie.negative = 0; !Ie.isZero(); ) {
          var $e = Ie.modrn(me).toString(k);
          Ie = Ie.idivn(me), Ie.isZero() ? A = $e + A : A = j[te - $e.length] + $e + A;
        }
        for (this.isZero() && (A = "0" + A); A.length % O !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var k = this.words[0];
      return this.length === 2 ? k += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? k += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -k : k;
    }, p.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, _ && (p.prototype.toBuffer = function(k, O) {
      return this.toArrayLike(_, k, O);
    }), p.prototype.toArray = function(k, O) {
      return this.toArrayLike(Array, k, O);
    };
    var ie = function(k, O) {
      return k.allocUnsafe ? k.allocUnsafe(O) : new k(O);
    };
    p.prototype.toArrayLike = function(k, O, A) {
      this._strip();
      var x = this.byteLength(), Y = A || Math.max(1, x);
      l(x <= Y, "byte array longer than desired length"), l(Y > 0, "Requested array length <= 0");
      var B = ie(k, Y), T = O === "le" ? "LE" : "BE";
      return this["_toArrayLike" + T](B, x), B;
    }, p.prototype._toArrayLikeLE = function(k, O) {
      for (var A = 0, x = 0, Y = 0, B = 0; Y < this.length; Y++) {
        var T = this.words[Y] << B | x;
        k[A++] = T & 255, A < k.length && (k[A++] = T >> 8 & 255), A < k.length && (k[A++] = T >> 16 & 255), B === 6 ? (A < k.length && (k[A++] = T >> 24 & 255), x = 0, B = 0) : (x = T >>> 24, B += 2);
      }
      if (A < k.length)
        for (k[A++] = x; A < k.length; )
          k[A++] = 0;
    }, p.prototype._toArrayLikeBE = function(k, O) {
      for (var A = k.length - 1, x = 0, Y = 0, B = 0; Y < this.length; Y++) {
        var T = this.words[Y] << B | x;
        k[A--] = T & 255, A >= 0 && (k[A--] = T >> 8 & 255), A >= 0 && (k[A--] = T >> 16 & 255), B === 6 ? (A >= 0 && (k[A--] = T >> 24 & 255), x = 0, B = 0) : (x = T >>> 24, B += 2);
      }
      if (A >= 0)
        for (k[A--] = x; A >= 0; )
          k[A--] = 0;
    }, Math.clz32 ? p.prototype._countBits = function(k) {
      return 32 - Math.clz32(k);
    } : p.prototype._countBits = function(k) {
      var O = k, A = 0;
      return O >= 4096 && (A += 13, O >>>= 13), O >= 64 && (A += 7, O >>>= 7), O >= 8 && (A += 4, O >>>= 4), O >= 2 && (A += 2, O >>>= 2), A + O;
    }, p.prototype._zeroBits = function(k) {
      if (k === 0)
        return 26;
      var O = k, A = 0;
      return O & 8191 || (A += 13, O >>>= 13), O & 127 || (A += 7, O >>>= 7), O & 15 || (A += 4, O >>>= 4), O & 3 || (A += 2, O >>>= 2), O & 1 || A++, A;
    }, p.prototype.bitLength = function() {
      var k = this.words[this.length - 1], O = this._countBits(k);
      return (this.length - 1) * 26 + O;
    };
    function Q(E) {
      for (var k = new Array(E.bitLength()), O = 0; O < k.length; O++) {
        var A = O / 26 | 0, x = O % 26;
        k[O] = E.words[A] >>> x & 1;
      }
      return k;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var k = 0, O = 0; O < this.length; O++) {
        var A = this._zeroBits(this.words[O]);
        if (k += A, A !== 26)
          break;
      }
      return k;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(k) {
      return this.negative !== 0 ? this.abs().inotn(k).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(k) {
      return this.testn(k - 1) ? this.notn(k).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(k) {
      for (; this.length < k.length; )
        this.words[this.length++] = 0;
      for (var O = 0; O < k.length; O++)
        this.words[O] = this.words[O] | k.words[O];
      return this._strip();
    }, p.prototype.ior = function(k) {
      return l((this.negative | k.negative) === 0), this.iuor(k);
    }, p.prototype.or = function(k) {
      return this.length > k.length ? this.clone().ior(k) : k.clone().ior(this);
    }, p.prototype.uor = function(k) {
      return this.length > k.length ? this.clone().iuor(k) : k.clone().iuor(this);
    }, p.prototype.iuand = function(k) {
      var O;
      this.length > k.length ? O = k : O = this;
      for (var A = 0; A < O.length; A++)
        this.words[A] = this.words[A] & k.words[A];
      return this.length = O.length, this._strip();
    }, p.prototype.iand = function(k) {
      return l((this.negative | k.negative) === 0), this.iuand(k);
    }, p.prototype.and = function(k) {
      return this.length > k.length ? this.clone().iand(k) : k.clone().iand(this);
    }, p.prototype.uand = function(k) {
      return this.length > k.length ? this.clone().iuand(k) : k.clone().iuand(this);
    }, p.prototype.iuxor = function(k) {
      var O, A;
      this.length > k.length ? (O = this, A = k) : (O = k, A = this);
      for (var x = 0; x < A.length; x++)
        this.words[x] = O.words[x] ^ A.words[x];
      if (this !== O)
        for (; x < O.length; x++)
          this.words[x] = O.words[x];
      return this.length = O.length, this._strip();
    }, p.prototype.ixor = function(k) {
      return l((this.negative | k.negative) === 0), this.iuxor(k);
    }, p.prototype.xor = function(k) {
      return this.length > k.length ? this.clone().ixor(k) : k.clone().ixor(this);
    }, p.prototype.uxor = function(k) {
      return this.length > k.length ? this.clone().iuxor(k) : k.clone().iuxor(this);
    }, p.prototype.inotn = function(k) {
      l(typeof k == "number" && k >= 0);
      var O = Math.ceil(k / 26) | 0, A = k % 26;
      this._expand(O), A > 0 && O--;
      for (var x = 0; x < O; x++)
        this.words[x] = ~this.words[x] & 67108863;
      return A > 0 && (this.words[x] = ~this.words[x] & 67108863 >> 26 - A), this._strip();
    }, p.prototype.notn = function(k) {
      return this.clone().inotn(k);
    }, p.prototype.setn = function(k, O) {
      l(typeof k == "number" && k >= 0);
      var A = k / 26 | 0, x = k % 26;
      return this._expand(A + 1), O ? this.words[A] = this.words[A] | 1 << x : this.words[A] = this.words[A] & ~(1 << x), this._strip();
    }, p.prototype.iadd = function(k) {
      var O;
      if (this.negative !== 0 && k.negative === 0)
        return this.negative = 0, O = this.isub(k), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && k.negative !== 0)
        return k.negative = 0, O = this.isub(k), k.negative = 1, O._normSign();
      var A, x;
      this.length > k.length ? (A = this, x = k) : (A = k, x = this);
      for (var Y = 0, B = 0; B < x.length; B++)
        O = (A.words[B] | 0) + (x.words[B] | 0) + Y, this.words[B] = O & 67108863, Y = O >>> 26;
      for (; Y !== 0 && B < A.length; B++)
        O = (A.words[B] | 0) + Y, this.words[B] = O & 67108863, Y = O >>> 26;
      if (this.length = A.length, Y !== 0)
        this.words[this.length] = Y, this.length++;
      else if (A !== this)
        for (; B < A.length; B++)
          this.words[B] = A.words[B];
      return this;
    }, p.prototype.add = function(k) {
      var O;
      return k.negative !== 0 && this.negative === 0 ? (k.negative = 0, O = this.sub(k), k.negative ^= 1, O) : k.negative === 0 && this.negative !== 0 ? (this.negative = 0, O = k.sub(this), this.negative = 1, O) : this.length > k.length ? this.clone().iadd(k) : k.clone().iadd(this);
    }, p.prototype.isub = function(k) {
      if (k.negative !== 0) {
        k.negative = 0;
        var O = this.iadd(k);
        return k.negative = 1, O._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(k), this.negative = 1, this._normSign();
      var A = this.cmp(k);
      if (A === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var x, Y;
      A > 0 ? (x = this, Y = k) : (x = k, Y = this);
      for (var B = 0, T = 0; T < Y.length; T++)
        O = (x.words[T] | 0) - (Y.words[T] | 0) + B, B = O >> 26, this.words[T] = O & 67108863;
      for (; B !== 0 && T < x.length; T++)
        O = (x.words[T] | 0) + B, B = O >> 26, this.words[T] = O & 67108863;
      if (B === 0 && T < x.length && x !== this)
        for (; T < x.length; T++)
          this.words[T] = x.words[T];
      return this.length = Math.max(this.length, T), x !== this && (this.negative = 1), this._strip();
    }, p.prototype.sub = function(k) {
      return this.clone().isub(k);
    };
    function ne(E, k, O) {
      O.negative = k.negative ^ E.negative;
      var A = E.length + k.length | 0;
      O.length = A, A = A - 1 | 0;
      var x = E.words[0] | 0, Y = k.words[0] | 0, B = x * Y, T = B & 67108863, D = B / 67108864 | 0;
      O.words[0] = T;
      for (var te = 1; te < A; te++) {
        for (var me = D >>> 26, Ie = D & 67108863, $e = Math.min(te, k.length - 1), ye = Math.max(0, te - E.length + 1); ye <= $e; ye++) {
          var fe = te - ye | 0;
          x = E.words[fe] | 0, Y = k.words[ye] | 0, B = x * Y + Ie, me += B / 67108864 | 0, Ie = B & 67108863;
        }
        O.words[te] = Ie | 0, D = me | 0;
      }
      return D !== 0 ? O.words[te] = D | 0 : O.length--, O._strip();
    }
    var Z = function(k, O, A) {
      var x = k.words, Y = O.words, B = A.words, T = 0, D, te, me, Ie = x[0] | 0, $e = Ie & 8191, ye = Ie >>> 13, fe = x[1] | 0, Me = fe & 8191, Ae = fe >>> 13, xe = x[2] | 0, ae = xe & 8191, N = xe >>> 13, re = x[3] | 0, le = re & 8191, Ne = re >>> 13, Oe = x[4] | 0, qe = Oe & 8191, je = Oe >>> 13, Fe = x[5] | 0, yt = Fe & 8191, Xe = Fe >>> 13, Ge = x[6] | 0, V = Ge & 8191, ge = Ge >>> 13, Te = x[7] | 0, We = Te & 8191, Re = Te >>> 13, J = x[8] | 0, Ee = J & 8191, ue = J >>> 13, ce = x[9] | 0, ve = ce & 8191, Ce = ce >>> 13, Be = Y[0] | 0, He = Be & 8191, Ve = Be >>> 13, Ze = Y[1] | 0, Ke = Ze & 8191, U = Ze >>> 13, se = Y[2] | 0, Se = se & 8191, Ue = se >>> 13, De = Y[3] | 0, Ye = De & 8191, Qe = De >>> 13, st = Y[4] | 0, St = st & 8191, tt = st >>> 13, it = Y[5] | 0, Tt = it & 8191, rt = it >>> 13, dt = Y[6] | 0, wt = dt & 8191, nt = dt >>> 13, at = Y[7] | 0, gt = at & 8191, ot = at >>> 13, ct = Y[8] | 0, Ct = ct & 8191, ut = ct >>> 13, lt = Y[9] | 0, kt = lt & 8191, Rt = lt >>> 13;
      A.negative = k.negative ^ O.negative, A.length = 19, D = Math.imul($e, He), te = Math.imul($e, Ve), te = te + Math.imul(ye, He) | 0, me = Math.imul(ye, Ve);
      var Je = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, D = Math.imul(Me, He), te = Math.imul(Me, Ve), te = te + Math.imul(Ae, He) | 0, me = Math.imul(Ae, Ve), D = D + Math.imul($e, Ke) | 0, te = te + Math.imul($e, U) | 0, te = te + Math.imul(ye, Ke) | 0, me = me + Math.imul(ye, U) | 0;
      var ze = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, D = Math.imul(ae, He), te = Math.imul(ae, Ve), te = te + Math.imul(N, He) | 0, me = Math.imul(N, Ve), D = D + Math.imul(Me, Ke) | 0, te = te + Math.imul(Me, U) | 0, te = te + Math.imul(Ae, Ke) | 0, me = me + Math.imul(Ae, U) | 0, D = D + Math.imul($e, Se) | 0, te = te + Math.imul($e, Ue) | 0, te = te + Math.imul(ye, Se) | 0, me = me + Math.imul(ye, Ue) | 0;
      var et = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, D = Math.imul(le, He), te = Math.imul(le, Ve), te = te + Math.imul(Ne, He) | 0, me = Math.imul(Ne, Ve), D = D + Math.imul(ae, Ke) | 0, te = te + Math.imul(ae, U) | 0, te = te + Math.imul(N, Ke) | 0, me = me + Math.imul(N, U) | 0, D = D + Math.imul(Me, Se) | 0, te = te + Math.imul(Me, Ue) | 0, te = te + Math.imul(Ae, Se) | 0, me = me + Math.imul(Ae, Ue) | 0, D = D + Math.imul($e, Ye) | 0, te = te + Math.imul($e, Qe) | 0, te = te + Math.imul(ye, Ye) | 0, me = me + Math.imul(ye, Qe) | 0;
      var pt = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, D = Math.imul(qe, He), te = Math.imul(qe, Ve), te = te + Math.imul(je, He) | 0, me = Math.imul(je, Ve), D = D + Math.imul(le, Ke) | 0, te = te + Math.imul(le, U) | 0, te = te + Math.imul(Ne, Ke) | 0, me = me + Math.imul(Ne, U) | 0, D = D + Math.imul(ae, Se) | 0, te = te + Math.imul(ae, Ue) | 0, te = te + Math.imul(N, Se) | 0, me = me + Math.imul(N, Ue) | 0, D = D + Math.imul(Me, Ye) | 0, te = te + Math.imul(Me, Qe) | 0, te = te + Math.imul(Ae, Ye) | 0, me = me + Math.imul(Ae, Qe) | 0, D = D + Math.imul($e, St) | 0, te = te + Math.imul($e, tt) | 0, te = te + Math.imul(ye, St) | 0, me = me + Math.imul(ye, tt) | 0;
      var mt = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, D = Math.imul(yt, He), te = Math.imul(yt, Ve), te = te + Math.imul(Xe, He) | 0, me = Math.imul(Xe, Ve), D = D + Math.imul(qe, Ke) | 0, te = te + Math.imul(qe, U) | 0, te = te + Math.imul(je, Ke) | 0, me = me + Math.imul(je, U) | 0, D = D + Math.imul(le, Se) | 0, te = te + Math.imul(le, Ue) | 0, te = te + Math.imul(Ne, Se) | 0, me = me + Math.imul(Ne, Ue) | 0, D = D + Math.imul(ae, Ye) | 0, te = te + Math.imul(ae, Qe) | 0, te = te + Math.imul(N, Ye) | 0, me = me + Math.imul(N, Qe) | 0, D = D + Math.imul(Me, St) | 0, te = te + Math.imul(Me, tt) | 0, te = te + Math.imul(Ae, St) | 0, me = me + Math.imul(Ae, tt) | 0, D = D + Math.imul($e, Tt) | 0, te = te + Math.imul($e, rt) | 0, te = te + Math.imul(ye, Tt) | 0, me = me + Math.imul(ye, rt) | 0;
      var vt = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, D = Math.imul(V, He), te = Math.imul(V, Ve), te = te + Math.imul(ge, He) | 0, me = Math.imul(ge, Ve), D = D + Math.imul(yt, Ke) | 0, te = te + Math.imul(yt, U) | 0, te = te + Math.imul(Xe, Ke) | 0, me = me + Math.imul(Xe, U) | 0, D = D + Math.imul(qe, Se) | 0, te = te + Math.imul(qe, Ue) | 0, te = te + Math.imul(je, Se) | 0, me = me + Math.imul(je, Ue) | 0, D = D + Math.imul(le, Ye) | 0, te = te + Math.imul(le, Qe) | 0, te = te + Math.imul(Ne, Ye) | 0, me = me + Math.imul(Ne, Qe) | 0, D = D + Math.imul(ae, St) | 0, te = te + Math.imul(ae, tt) | 0, te = te + Math.imul(N, St) | 0, me = me + Math.imul(N, tt) | 0, D = D + Math.imul(Me, Tt) | 0, te = te + Math.imul(Me, rt) | 0, te = te + Math.imul(Ae, Tt) | 0, me = me + Math.imul(Ae, rt) | 0, D = D + Math.imul($e, wt) | 0, te = te + Math.imul($e, nt) | 0, te = te + Math.imul(ye, wt) | 0, me = me + Math.imul(ye, nt) | 0;
      var ht = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, D = Math.imul(We, He), te = Math.imul(We, Ve), te = te + Math.imul(Re, He) | 0, me = Math.imul(Re, Ve), D = D + Math.imul(V, Ke) | 0, te = te + Math.imul(V, U) | 0, te = te + Math.imul(ge, Ke) | 0, me = me + Math.imul(ge, U) | 0, D = D + Math.imul(yt, Se) | 0, te = te + Math.imul(yt, Ue) | 0, te = te + Math.imul(Xe, Se) | 0, me = me + Math.imul(Xe, Ue) | 0, D = D + Math.imul(qe, Ye) | 0, te = te + Math.imul(qe, Qe) | 0, te = te + Math.imul(je, Ye) | 0, me = me + Math.imul(je, Qe) | 0, D = D + Math.imul(le, St) | 0, te = te + Math.imul(le, tt) | 0, te = te + Math.imul(Ne, St) | 0, me = me + Math.imul(Ne, tt) | 0, D = D + Math.imul(ae, Tt) | 0, te = te + Math.imul(ae, rt) | 0, te = te + Math.imul(N, Tt) | 0, me = me + Math.imul(N, rt) | 0, D = D + Math.imul(Me, wt) | 0, te = te + Math.imul(Me, nt) | 0, te = te + Math.imul(Ae, wt) | 0, me = me + Math.imul(Ae, nt) | 0, D = D + Math.imul($e, gt) | 0, te = te + Math.imul($e, ot) | 0, te = te + Math.imul(ye, gt) | 0, me = me + Math.imul(ye, ot) | 0;
      var _t = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, D = Math.imul(Ee, He), te = Math.imul(Ee, Ve), te = te + Math.imul(ue, He) | 0, me = Math.imul(ue, Ve), D = D + Math.imul(We, Ke) | 0, te = te + Math.imul(We, U) | 0, te = te + Math.imul(Re, Ke) | 0, me = me + Math.imul(Re, U) | 0, D = D + Math.imul(V, Se) | 0, te = te + Math.imul(V, Ue) | 0, te = te + Math.imul(ge, Se) | 0, me = me + Math.imul(ge, Ue) | 0, D = D + Math.imul(yt, Ye) | 0, te = te + Math.imul(yt, Qe) | 0, te = te + Math.imul(Xe, Ye) | 0, me = me + Math.imul(Xe, Qe) | 0, D = D + Math.imul(qe, St) | 0, te = te + Math.imul(qe, tt) | 0, te = te + Math.imul(je, St) | 0, me = me + Math.imul(je, tt) | 0, D = D + Math.imul(le, Tt) | 0, te = te + Math.imul(le, rt) | 0, te = te + Math.imul(Ne, Tt) | 0, me = me + Math.imul(Ne, rt) | 0, D = D + Math.imul(ae, wt) | 0, te = te + Math.imul(ae, nt) | 0, te = te + Math.imul(N, wt) | 0, me = me + Math.imul(N, nt) | 0, D = D + Math.imul(Me, gt) | 0, te = te + Math.imul(Me, ot) | 0, te = te + Math.imul(Ae, gt) | 0, me = me + Math.imul(Ae, ot) | 0, D = D + Math.imul($e, Ct) | 0, te = te + Math.imul($e, ut) | 0, te = te + Math.imul(ye, Ct) | 0, me = me + Math.imul(ye, ut) | 0;
      var Et = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, D = Math.imul(ve, He), te = Math.imul(ve, Ve), te = te + Math.imul(Ce, He) | 0, me = Math.imul(Ce, Ve), D = D + Math.imul(Ee, Ke) | 0, te = te + Math.imul(Ee, U) | 0, te = te + Math.imul(ue, Ke) | 0, me = me + Math.imul(ue, U) | 0, D = D + Math.imul(We, Se) | 0, te = te + Math.imul(We, Ue) | 0, te = te + Math.imul(Re, Se) | 0, me = me + Math.imul(Re, Ue) | 0, D = D + Math.imul(V, Ye) | 0, te = te + Math.imul(V, Qe) | 0, te = te + Math.imul(ge, Ye) | 0, me = me + Math.imul(ge, Qe) | 0, D = D + Math.imul(yt, St) | 0, te = te + Math.imul(yt, tt) | 0, te = te + Math.imul(Xe, St) | 0, me = me + Math.imul(Xe, tt) | 0, D = D + Math.imul(qe, Tt) | 0, te = te + Math.imul(qe, rt) | 0, te = te + Math.imul(je, Tt) | 0, me = me + Math.imul(je, rt) | 0, D = D + Math.imul(le, wt) | 0, te = te + Math.imul(le, nt) | 0, te = te + Math.imul(Ne, wt) | 0, me = me + Math.imul(Ne, nt) | 0, D = D + Math.imul(ae, gt) | 0, te = te + Math.imul(ae, ot) | 0, te = te + Math.imul(N, gt) | 0, me = me + Math.imul(N, ot) | 0, D = D + Math.imul(Me, Ct) | 0, te = te + Math.imul(Me, ut) | 0, te = te + Math.imul(Ae, Ct) | 0, me = me + Math.imul(Ae, ut) | 0, D = D + Math.imul($e, kt) | 0, te = te + Math.imul($e, Rt) | 0, te = te + Math.imul(ye, kt) | 0, me = me + Math.imul(ye, Rt) | 0;
      var Pt = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, D = Math.imul(ve, Ke), te = Math.imul(ve, U), te = te + Math.imul(Ce, Ke) | 0, me = Math.imul(Ce, U), D = D + Math.imul(Ee, Se) | 0, te = te + Math.imul(Ee, Ue) | 0, te = te + Math.imul(ue, Se) | 0, me = me + Math.imul(ue, Ue) | 0, D = D + Math.imul(We, Ye) | 0, te = te + Math.imul(We, Qe) | 0, te = te + Math.imul(Re, Ye) | 0, me = me + Math.imul(Re, Qe) | 0, D = D + Math.imul(V, St) | 0, te = te + Math.imul(V, tt) | 0, te = te + Math.imul(ge, St) | 0, me = me + Math.imul(ge, tt) | 0, D = D + Math.imul(yt, Tt) | 0, te = te + Math.imul(yt, rt) | 0, te = te + Math.imul(Xe, Tt) | 0, me = me + Math.imul(Xe, rt) | 0, D = D + Math.imul(qe, wt) | 0, te = te + Math.imul(qe, nt) | 0, te = te + Math.imul(je, wt) | 0, me = me + Math.imul(je, nt) | 0, D = D + Math.imul(le, gt) | 0, te = te + Math.imul(le, ot) | 0, te = te + Math.imul(Ne, gt) | 0, me = me + Math.imul(Ne, ot) | 0, D = D + Math.imul(ae, Ct) | 0, te = te + Math.imul(ae, ut) | 0, te = te + Math.imul(N, Ct) | 0, me = me + Math.imul(N, ut) | 0, D = D + Math.imul(Me, kt) | 0, te = te + Math.imul(Me, Rt) | 0, te = te + Math.imul(Ae, kt) | 0, me = me + Math.imul(Ae, Rt) | 0;
      var Nt = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, D = Math.imul(ve, Se), te = Math.imul(ve, Ue), te = te + Math.imul(Ce, Se) | 0, me = Math.imul(Ce, Ue), D = D + Math.imul(Ee, Ye) | 0, te = te + Math.imul(Ee, Qe) | 0, te = te + Math.imul(ue, Ye) | 0, me = me + Math.imul(ue, Qe) | 0, D = D + Math.imul(We, St) | 0, te = te + Math.imul(We, tt) | 0, te = te + Math.imul(Re, St) | 0, me = me + Math.imul(Re, tt) | 0, D = D + Math.imul(V, Tt) | 0, te = te + Math.imul(V, rt) | 0, te = te + Math.imul(ge, Tt) | 0, me = me + Math.imul(ge, rt) | 0, D = D + Math.imul(yt, wt) | 0, te = te + Math.imul(yt, nt) | 0, te = te + Math.imul(Xe, wt) | 0, me = me + Math.imul(Xe, nt) | 0, D = D + Math.imul(qe, gt) | 0, te = te + Math.imul(qe, ot) | 0, te = te + Math.imul(je, gt) | 0, me = me + Math.imul(je, ot) | 0, D = D + Math.imul(le, Ct) | 0, te = te + Math.imul(le, ut) | 0, te = te + Math.imul(Ne, Ct) | 0, me = me + Math.imul(Ne, ut) | 0, D = D + Math.imul(ae, kt) | 0, te = te + Math.imul(ae, Rt) | 0, te = te + Math.imul(N, kt) | 0, me = me + Math.imul(N, Rt) | 0;
      var Mt = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, D = Math.imul(ve, Ye), te = Math.imul(ve, Qe), te = te + Math.imul(Ce, Ye) | 0, me = Math.imul(Ce, Qe), D = D + Math.imul(Ee, St) | 0, te = te + Math.imul(Ee, tt) | 0, te = te + Math.imul(ue, St) | 0, me = me + Math.imul(ue, tt) | 0, D = D + Math.imul(We, Tt) | 0, te = te + Math.imul(We, rt) | 0, te = te + Math.imul(Re, Tt) | 0, me = me + Math.imul(Re, rt) | 0, D = D + Math.imul(V, wt) | 0, te = te + Math.imul(V, nt) | 0, te = te + Math.imul(ge, wt) | 0, me = me + Math.imul(ge, nt) | 0, D = D + Math.imul(yt, gt) | 0, te = te + Math.imul(yt, ot) | 0, te = te + Math.imul(Xe, gt) | 0, me = me + Math.imul(Xe, ot) | 0, D = D + Math.imul(qe, Ct) | 0, te = te + Math.imul(qe, ut) | 0, te = te + Math.imul(je, Ct) | 0, me = me + Math.imul(je, ut) | 0, D = D + Math.imul(le, kt) | 0, te = te + Math.imul(le, Rt) | 0, te = te + Math.imul(Ne, kt) | 0, me = me + Math.imul(Ne, Rt) | 0;
      var Ot = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, D = Math.imul(ve, St), te = Math.imul(ve, tt), te = te + Math.imul(Ce, St) | 0, me = Math.imul(Ce, tt), D = D + Math.imul(Ee, Tt) | 0, te = te + Math.imul(Ee, rt) | 0, te = te + Math.imul(ue, Tt) | 0, me = me + Math.imul(ue, rt) | 0, D = D + Math.imul(We, wt) | 0, te = te + Math.imul(We, nt) | 0, te = te + Math.imul(Re, wt) | 0, me = me + Math.imul(Re, nt) | 0, D = D + Math.imul(V, gt) | 0, te = te + Math.imul(V, ot) | 0, te = te + Math.imul(ge, gt) | 0, me = me + Math.imul(ge, ot) | 0, D = D + Math.imul(yt, Ct) | 0, te = te + Math.imul(yt, ut) | 0, te = te + Math.imul(Xe, Ct) | 0, me = me + Math.imul(Xe, ut) | 0, D = D + Math.imul(qe, kt) | 0, te = te + Math.imul(qe, Rt) | 0, te = te + Math.imul(je, kt) | 0, me = me + Math.imul(je, Rt) | 0;
      var $t = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, D = Math.imul(ve, Tt), te = Math.imul(ve, rt), te = te + Math.imul(Ce, Tt) | 0, me = Math.imul(Ce, rt), D = D + Math.imul(Ee, wt) | 0, te = te + Math.imul(Ee, nt) | 0, te = te + Math.imul(ue, wt) | 0, me = me + Math.imul(ue, nt) | 0, D = D + Math.imul(We, gt) | 0, te = te + Math.imul(We, ot) | 0, te = te + Math.imul(Re, gt) | 0, me = me + Math.imul(Re, ot) | 0, D = D + Math.imul(V, Ct) | 0, te = te + Math.imul(V, ut) | 0, te = te + Math.imul(ge, Ct) | 0, me = me + Math.imul(ge, ut) | 0, D = D + Math.imul(yt, kt) | 0, te = te + Math.imul(yt, Rt) | 0, te = te + Math.imul(Xe, kt) | 0, me = me + Math.imul(Xe, Rt) | 0;
      var Bt = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, D = Math.imul(ve, wt), te = Math.imul(ve, nt), te = te + Math.imul(Ce, wt) | 0, me = Math.imul(Ce, nt), D = D + Math.imul(Ee, gt) | 0, te = te + Math.imul(Ee, ot) | 0, te = te + Math.imul(ue, gt) | 0, me = me + Math.imul(ue, ot) | 0, D = D + Math.imul(We, Ct) | 0, te = te + Math.imul(We, ut) | 0, te = te + Math.imul(Re, Ct) | 0, me = me + Math.imul(Re, ut) | 0, D = D + Math.imul(V, kt) | 0, te = te + Math.imul(V, Rt) | 0, te = te + Math.imul(ge, kt) | 0, me = me + Math.imul(ge, Rt) | 0;
      var xt = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, D = Math.imul(ve, gt), te = Math.imul(ve, ot), te = te + Math.imul(Ce, gt) | 0, me = Math.imul(Ce, ot), D = D + Math.imul(Ee, Ct) | 0, te = te + Math.imul(Ee, ut) | 0, te = te + Math.imul(ue, Ct) | 0, me = me + Math.imul(ue, ut) | 0, D = D + Math.imul(We, kt) | 0, te = te + Math.imul(We, Rt) | 0, te = te + Math.imul(Re, kt) | 0, me = me + Math.imul(Re, Rt) | 0;
      var Ut = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, D = Math.imul(ve, Ct), te = Math.imul(ve, ut), te = te + Math.imul(Ce, Ct) | 0, me = Math.imul(Ce, ut), D = D + Math.imul(Ee, kt) | 0, te = te + Math.imul(Ee, Rt) | 0, te = te + Math.imul(ue, kt) | 0, me = me + Math.imul(ue, Rt) | 0;
      var Jt = (T + D | 0) + ((te & 8191) << 13) | 0;
      T = (me + (te >>> 13) | 0) + (Jt >>> 26) | 0, Jt &= 67108863, D = Math.imul(ve, kt), te = Math.imul(ve, Rt), te = te + Math.imul(Ce, kt) | 0, me = Math.imul(Ce, Rt);
      var Vt = (T + D | 0) + ((te & 8191) << 13) | 0;
      return T = (me + (te >>> 13) | 0) + (Vt >>> 26) | 0, Vt &= 67108863, B[0] = Je, B[1] = ze, B[2] = et, B[3] = pt, B[4] = mt, B[5] = vt, B[6] = ht, B[7] = _t, B[8] = Et, B[9] = Pt, B[10] = Nt, B[11] = Mt, B[12] = Ot, B[13] = $t, B[14] = Bt, B[15] = xt, B[16] = Ut, B[17] = Jt, B[18] = Vt, T !== 0 && (B[19] = T, A.length++), A;
    };
    Math.imul || (Z = ne);
    function de(E, k, O) {
      O.negative = k.negative ^ E.negative, O.length = E.length + k.length;
      for (var A = 0, x = 0, Y = 0; Y < O.length - 1; Y++) {
        var B = x;
        x = 0;
        for (var T = A & 67108863, D = Math.min(Y, k.length - 1), te = Math.max(0, Y - E.length + 1); te <= D; te++) {
          var me = Y - te, Ie = E.words[me] | 0, $e = k.words[te] | 0, ye = Ie * $e, fe = ye & 67108863;
          B = B + (ye / 67108864 | 0) | 0, fe = fe + T | 0, T = fe & 67108863, B = B + (fe >>> 26) | 0, x += B >>> 26, B &= 67108863;
        }
        O.words[Y] = T, A = B, B = x;
      }
      return A !== 0 ? O.words[Y] = A : O.length--, O._strip();
    }
    function he(E, k, O) {
      return de(E, k, O);
    }
    p.prototype.mulTo = function(k, O) {
      var A, x = this.length + k.length;
      return this.length === 10 && k.length === 10 ? A = Z(this, k, O) : x < 63 ? A = ne(this, k, O) : x < 1024 ? A = de(this, k, O) : A = he(this, k, O), A;
    }, p.prototype.mul = function(k) {
      var O = new p(null);
      return O.words = new Array(this.length + k.length), this.mulTo(k, O);
    }, p.prototype.mulf = function(k) {
      var O = new p(null);
      return O.words = new Array(this.length + k.length), he(this, k, O);
    }, p.prototype.imul = function(k) {
      return this.clone().mulTo(k, this);
    }, p.prototype.imuln = function(k) {
      var O = k < 0;
      O && (k = -k), l(typeof k == "number"), l(k < 67108864);
      for (var A = 0, x = 0; x < this.length; x++) {
        var Y = (this.words[x] | 0) * k, B = (Y & 67108863) + (A & 67108863);
        A >>= 26, A += Y / 67108864 | 0, A += B >>> 26, this.words[x] = B & 67108863;
      }
      return A !== 0 && (this.words[x] = A, this.length++), O ? this.ineg() : this;
    }, p.prototype.muln = function(k) {
      return this.clone().imuln(k);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(k) {
      var O = Q(k);
      if (O.length === 0)
        return new p(1);
      for (var A = this, x = 0; x < O.length && O[x] === 0; x++, A = A.sqr())
        ;
      if (++x < O.length)
        for (var Y = A.sqr(); x < O.length; x++, Y = Y.sqr())
          O[x] !== 0 && (A = A.mul(Y));
      return A;
    }, p.prototype.iushln = function(k) {
      l(typeof k == "number" && k >= 0);
      var O = k % 26, A = (k - O) / 26, x = 67108863 >>> 26 - O << 26 - O, Y;
      if (O !== 0) {
        var B = 0;
        for (Y = 0; Y < this.length; Y++) {
          var T = this.words[Y] & x, D = (this.words[Y] | 0) - T << O;
          this.words[Y] = D | B, B = T >>> 26 - O;
        }
        B && (this.words[Y] = B, this.length++);
      }
      if (A !== 0) {
        for (Y = this.length - 1; Y >= 0; Y--)
          this.words[Y + A] = this.words[Y];
        for (Y = 0; Y < A; Y++)
          this.words[Y] = 0;
        this.length += A;
      }
      return this._strip();
    }, p.prototype.ishln = function(k) {
      return l(this.negative === 0), this.iushln(k);
    }, p.prototype.iushrn = function(k, O, A) {
      l(typeof k == "number" && k >= 0);
      var x;
      O ? x = (O - O % 26) / 26 : x = 0;
      var Y = k % 26, B = Math.min((k - Y) / 26, this.length), T = 67108863 ^ 67108863 >>> Y << Y, D = A;
      if (x -= B, x = Math.max(0, x), D) {
        for (var te = 0; te < B; te++)
          D.words[te] = this.words[te];
        D.length = B;
      }
      if (B !== 0)
        if (this.length > B)
          for (this.length -= B, te = 0; te < this.length; te++)
            this.words[te] = this.words[te + B];
        else
          this.words[0] = 0, this.length = 1;
      var me = 0;
      for (te = this.length - 1; te >= 0 && (me !== 0 || te >= x); te--) {
        var Ie = this.words[te] | 0;
        this.words[te] = me << 26 - Y | Ie >>> Y, me = Ie & T;
      }
      return D && me !== 0 && (D.words[D.length++] = me), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, p.prototype.ishrn = function(k, O, A) {
      return l(this.negative === 0), this.iushrn(k, O, A);
    }, p.prototype.shln = function(k) {
      return this.clone().ishln(k);
    }, p.prototype.ushln = function(k) {
      return this.clone().iushln(k);
    }, p.prototype.shrn = function(k) {
      return this.clone().ishrn(k);
    }, p.prototype.ushrn = function(k) {
      return this.clone().iushrn(k);
    }, p.prototype.testn = function(k) {
      l(typeof k == "number" && k >= 0);
      var O = k % 26, A = (k - O) / 26, x = 1 << O;
      if (this.length <= A)
        return !1;
      var Y = this.words[A];
      return !!(Y & x);
    }, p.prototype.imaskn = function(k) {
      l(typeof k == "number" && k >= 0);
      var O = k % 26, A = (k - O) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= A)
        return this;
      if (O !== 0 && A++, this.length = Math.min(A, this.length), O !== 0) {
        var x = 67108863 ^ 67108863 >>> O << O;
        this.words[this.length - 1] &= x;
      }
      return this._strip();
    }, p.prototype.maskn = function(k) {
      return this.clone().imaskn(k);
    }, p.prototype.iaddn = function(k) {
      return l(typeof k == "number"), l(k < 67108864), k < 0 ? this.isubn(-k) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= k ? (this.words[0] = k - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(k), this.negative = 1, this) : this._iaddn(k);
    }, p.prototype._iaddn = function(k) {
      this.words[0] += k;
      for (var O = 0; O < this.length && this.words[O] >= 67108864; O++)
        this.words[O] -= 67108864, O === this.length - 1 ? this.words[O + 1] = 1 : this.words[O + 1]++;
      return this.length = Math.max(this.length, O + 1), this;
    }, p.prototype.isubn = function(k) {
      if (l(typeof k == "number"), l(k < 67108864), k < 0)
        return this.iaddn(-k);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(k), this.negative = 1, this;
      if (this.words[0] -= k, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var O = 0; O < this.length && this.words[O] < 0; O++)
          this.words[O] += 67108864, this.words[O + 1] -= 1;
      return this._strip();
    }, p.prototype.addn = function(k) {
      return this.clone().iaddn(k);
    }, p.prototype.subn = function(k) {
      return this.clone().isubn(k);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(k, O, A) {
      var x = k.length + A, Y;
      this._expand(x);
      var B, T = 0;
      for (Y = 0; Y < k.length; Y++) {
        B = (this.words[Y + A] | 0) + T;
        var D = (k.words[Y] | 0) * O;
        B -= D & 67108863, T = (B >> 26) - (D / 67108864 | 0), this.words[Y + A] = B & 67108863;
      }
      for (; Y < this.length - A; Y++)
        B = (this.words[Y + A] | 0) + T, T = B >> 26, this.words[Y + A] = B & 67108863;
      if (T === 0)
        return this._strip();
      for (l(T === -1), T = 0, Y = 0; Y < this.length; Y++)
        B = -(this.words[Y] | 0) + T, T = B >> 26, this.words[Y] = B & 67108863;
      return this.negative = 1, this._strip();
    }, p.prototype._wordDiv = function(k, O) {
      var A = this.length - k.length, x = this.clone(), Y = k, B = Y.words[Y.length - 1] | 0, T = this._countBits(B);
      A = 26 - T, A !== 0 && (Y = Y.ushln(A), x.iushln(A), B = Y.words[Y.length - 1] | 0);
      var D = x.length - Y.length, te;
      if (O !== "mod") {
        te = new p(null), te.length = D + 1, te.words = new Array(te.length);
        for (var me = 0; me < te.length; me++)
          te.words[me] = 0;
      }
      var Ie = x.clone()._ishlnsubmul(Y, 1, D);
      Ie.negative === 0 && (x = Ie, te && (te.words[D] = 1));
      for (var $e = D - 1; $e >= 0; $e--) {
        var ye = (x.words[Y.length + $e] | 0) * 67108864 + (x.words[Y.length + $e - 1] | 0);
        for (ye = Math.min(ye / B | 0, 67108863), x._ishlnsubmul(Y, ye, $e); x.negative !== 0; )
          ye--, x.negative = 0, x._ishlnsubmul(Y, 1, $e), x.isZero() || (x.negative ^= 1);
        te && (te.words[$e] = ye);
      }
      return te && te._strip(), x._strip(), O !== "div" && A !== 0 && x.iushrn(A), {
        div: te || null,
        mod: x
      };
    }, p.prototype.divmod = function(k, O, A) {
      if (l(!k.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var x, Y, B;
      return this.negative !== 0 && k.negative === 0 ? (B = this.neg().divmod(k, O), O !== "mod" && (x = B.div.neg()), O !== "div" && (Y = B.mod.neg(), A && Y.negative !== 0 && Y.iadd(k)), {
        div: x,
        mod: Y
      }) : this.negative === 0 && k.negative !== 0 ? (B = this.divmod(k.neg(), O), O !== "mod" && (x = B.div.neg()), {
        div: x,
        mod: B.mod
      }) : this.negative & k.negative ? (B = this.neg().divmod(k.neg(), O), O !== "div" && (Y = B.mod.neg(), A && Y.negative !== 0 && Y.isub(k)), {
        div: B.div,
        mod: Y
      }) : k.length > this.length || this.cmp(k) < 0 ? {
        div: new p(0),
        mod: this
      } : k.length === 1 ? O === "div" ? {
        div: this.divn(k.words[0]),
        mod: null
      } : O === "mod" ? {
        div: null,
        mod: new p(this.modrn(k.words[0]))
      } : {
        div: this.divn(k.words[0]),
        mod: new p(this.modrn(k.words[0]))
      } : this._wordDiv(k, O);
    }, p.prototype.div = function(k) {
      return this.divmod(k, "div", !1).div;
    }, p.prototype.mod = function(k) {
      return this.divmod(k, "mod", !1).mod;
    }, p.prototype.umod = function(k) {
      return this.divmod(k, "mod", !0).mod;
    }, p.prototype.divRound = function(k) {
      var O = this.divmod(k);
      if (O.mod.isZero())
        return O.div;
      var A = O.div.negative !== 0 ? O.mod.isub(k) : O.mod, x = k.ushrn(1), Y = k.andln(1), B = A.cmp(x);
      return B < 0 || Y === 1 && B === 0 ? O.div : O.div.negative !== 0 ? O.div.isubn(1) : O.div.iaddn(1);
    }, p.prototype.modrn = function(k) {
      var O = k < 0;
      O && (k = -k), l(k <= 67108863);
      for (var A = (1 << 26) % k, x = 0, Y = this.length - 1; Y >= 0; Y--)
        x = (A * x + (this.words[Y] | 0)) % k;
      return O ? -x : x;
    }, p.prototype.modn = function(k) {
      return this.modrn(k);
    }, p.prototype.idivn = function(k) {
      var O = k < 0;
      O && (k = -k), l(k <= 67108863);
      for (var A = 0, x = this.length - 1; x >= 0; x--) {
        var Y = (this.words[x] | 0) + A * 67108864;
        this.words[x] = Y / k | 0, A = Y % k;
      }
      return this._strip(), O ? this.ineg() : this;
    }, p.prototype.divn = function(k) {
      return this.clone().idivn(k);
    }, p.prototype.egcd = function(k) {
      l(k.negative === 0), l(!k.isZero());
      var O = this, A = k.clone();
      O.negative !== 0 ? O = O.umod(k) : O = O.clone();
      for (var x = new p(1), Y = new p(0), B = new p(0), T = new p(1), D = 0; O.isEven() && A.isEven(); )
        O.iushrn(1), A.iushrn(1), ++D;
      for (var te = A.clone(), me = O.clone(); !O.isZero(); ) {
        for (var Ie = 0, $e = 1; !(O.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (O.iushrn(Ie); Ie-- > 0; )
            (x.isOdd() || Y.isOdd()) && (x.iadd(te), Y.isub(me)), x.iushrn(1), Y.iushrn(1);
        for (var ye = 0, fe = 1; !(A.words[0] & fe) && ye < 26; ++ye, fe <<= 1)
          ;
        if (ye > 0)
          for (A.iushrn(ye); ye-- > 0; )
            (B.isOdd() || T.isOdd()) && (B.iadd(te), T.isub(me)), B.iushrn(1), T.iushrn(1);
        O.cmp(A) >= 0 ? (O.isub(A), x.isub(B), Y.isub(T)) : (A.isub(O), B.isub(x), T.isub(Y));
      }
      return {
        a: B,
        b: T,
        gcd: A.iushln(D)
      };
    }, p.prototype._invmp = function(k) {
      l(k.negative === 0), l(!k.isZero());
      var O = this, A = k.clone();
      O.negative !== 0 ? O = O.umod(k) : O = O.clone();
      for (var x = new p(1), Y = new p(0), B = A.clone(); O.cmpn(1) > 0 && A.cmpn(1) > 0; ) {
        for (var T = 0, D = 1; !(O.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (O.iushrn(T); T-- > 0; )
            x.isOdd() && x.iadd(B), x.iushrn(1);
        for (var te = 0, me = 1; !(A.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for (A.iushrn(te); te-- > 0; )
            Y.isOdd() && Y.iadd(B), Y.iushrn(1);
        O.cmp(A) >= 0 ? (O.isub(A), x.isub(Y)) : (A.isub(O), Y.isub(x));
      }
      var Ie;
      return O.cmpn(1) === 0 ? Ie = x : Ie = Y, Ie.cmpn(0) < 0 && Ie.iadd(k), Ie;
    }, p.prototype.gcd = function(k) {
      if (this.isZero())
        return k.abs();
      if (k.isZero())
        return this.abs();
      var O = this.clone(), A = k.clone();
      O.negative = 0, A.negative = 0;
      for (var x = 0; O.isEven() && A.isEven(); x++)
        O.iushrn(1), A.iushrn(1);
      do {
        for (; O.isEven(); )
          O.iushrn(1);
        for (; A.isEven(); )
          A.iushrn(1);
        var Y = O.cmp(A);
        if (Y < 0) {
          var B = O;
          O = A, A = B;
        } else if (Y === 0 || A.cmpn(1) === 0)
          break;
        O.isub(A);
      } while (!0);
      return A.iushln(x);
    }, p.prototype.invm = function(k) {
      return this.egcd(k).a.umod(k);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(k) {
      return this.words[0] & k;
    }, p.prototype.bincn = function(k) {
      l(typeof k == "number");
      var O = k % 26, A = (k - O) / 26, x = 1 << O;
      if (this.length <= A)
        return this._expand(A + 1), this.words[A] |= x, this;
      for (var Y = x, B = A; Y !== 0 && B < this.length; B++) {
        var T = this.words[B] | 0;
        T += Y, Y = T >>> 26, T &= 67108863, this.words[B] = T;
      }
      return Y !== 0 && (this.words[B] = Y, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(k) {
      var O = k < 0;
      if (this.negative !== 0 && !O)
        return -1;
      if (this.negative === 0 && O)
        return 1;
      this._strip();
      var A;
      if (this.length > 1)
        A = 1;
      else {
        O && (k = -k), l(k <= 67108863, "Number is too big");
        var x = this.words[0] | 0;
        A = x === k ? 0 : x < k ? -1 : 1;
      }
      return this.negative !== 0 ? -A | 0 : A;
    }, p.prototype.cmp = function(k) {
      if (this.negative !== 0 && k.negative === 0)
        return -1;
      if (this.negative === 0 && k.negative !== 0)
        return 1;
      var O = this.ucmp(k);
      return this.negative !== 0 ? -O | 0 : O;
    }, p.prototype.ucmp = function(k) {
      if (this.length > k.length)
        return 1;
      if (this.length < k.length)
        return -1;
      for (var O = 0, A = this.length - 1; A >= 0; A--) {
        var x = this.words[A] | 0, Y = k.words[A] | 0;
        if (x !== Y) {
          x < Y ? O = -1 : x > Y && (O = 1);
          break;
        }
      }
      return O;
    }, p.prototype.gtn = function(k) {
      return this.cmpn(k) === 1;
    }, p.prototype.gt = function(k) {
      return this.cmp(k) === 1;
    }, p.prototype.gten = function(k) {
      return this.cmpn(k) >= 0;
    }, p.prototype.gte = function(k) {
      return this.cmp(k) >= 0;
    }, p.prototype.ltn = function(k) {
      return this.cmpn(k) === -1;
    }, p.prototype.lt = function(k) {
      return this.cmp(k) === -1;
    }, p.prototype.lten = function(k) {
      return this.cmpn(k) <= 0;
    }, p.prototype.lte = function(k) {
      return this.cmp(k) <= 0;
    }, p.prototype.eqn = function(k) {
      return this.cmpn(k) === 0;
    }, p.prototype.eq = function(k) {
      return this.cmp(k) === 0;
    }, p.red = function(k) {
      return new C(k);
    }, p.prototype.toRed = function(k) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), k.convertTo(this)._forceRed(k);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(k) {
      return this.red = k, this;
    }, p.prototype.forceRed = function(k) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(k);
    }, p.prototype.redAdd = function(k) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, k);
    }, p.prototype.redIAdd = function(k) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, k);
    }, p.prototype.redSub = function(k) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, k);
    }, p.prototype.redISub = function(k) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, k);
    }, p.prototype.redShl = function(k) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, k);
    }, p.prototype.redMul = function(k) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, k), this.red.mul(this, k);
    }, p.prototype.redIMul = function(k) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, k), this.red.imul(this, k);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(k) {
      return l(this.red && !k.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, k);
    };
    var pe = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function be(E, k) {
      this.name = E, this.p = new p(k, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    be.prototype._tmp = function() {
      var k = new p(null);
      return k.words = new Array(Math.ceil(this.n / 13)), k;
    }, be.prototype.ireduce = function(k) {
      var O = k, A;
      do
        this.split(O, this.tmp), O = this.imulK(O), O = O.iadd(this.tmp), A = O.bitLength();
      while (A > this.n);
      var x = A < this.n ? -1 : O.ucmp(this.p);
      return x === 0 ? (O.words[0] = 0, O.length = 1) : x > 0 ? O.isub(this.p) : O.strip !== void 0 ? O.strip() : O._strip(), O;
    }, be.prototype.split = function(k, O) {
      k.iushrn(this.n, 0, O);
    }, be.prototype.imulK = function(k) {
      return k.imul(this.k);
    };
    function ke() {
      be.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(ke, be), ke.prototype.split = function(k, O) {
      for (var A = 4194303, x = Math.min(k.length, 9), Y = 0; Y < x; Y++)
        O.words[Y] = k.words[Y];
      if (O.length = x, k.length <= 9) {
        k.words[0] = 0, k.length = 1;
        return;
      }
      var B = k.words[9];
      for (O.words[O.length++] = B & A, Y = 10; Y < k.length; Y++) {
        var T = k.words[Y] | 0;
        k.words[Y - 10] = (T & A) << 4 | B >>> 22, B = T;
      }
      B >>>= 22, k.words[Y - 10] = B, B === 0 && k.length > 10 ? k.length -= 10 : k.length -= 9;
    }, ke.prototype.imulK = function(k) {
      k.words[k.length] = 0, k.words[k.length + 1] = 0, k.length += 2;
      for (var O = 0, A = 0; A < k.length; A++) {
        var x = k.words[A] | 0;
        O += x * 977, k.words[A] = O & 67108863, O = x * 64 + (O / 67108864 | 0);
      }
      return k.words[k.length - 1] === 0 && (k.length--, k.words[k.length - 1] === 0 && k.length--), k;
    };
    function _e() {
      be.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(_e, be);
    function q() {
      be.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(q, be);
    function z() {
      be.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(z, be), z.prototype.imulK = function(k) {
      for (var O = 0, A = 0; A < k.length; A++) {
        var x = (k.words[A] | 0) * 19 + O, Y = x & 67108863;
        x >>>= 26, k.words[A] = Y, O = x;
      }
      return O !== 0 && (k.words[k.length++] = O), k;
    }, p._prime = function(k) {
      if (pe[k])
        return pe[k];
      var O;
      if (k === "k256")
        O = new ke();
      else if (k === "p224")
        O = new _e();
      else if (k === "p192")
        O = new q();
      else if (k === "p25519")
        O = new z();
      else
        throw new Error("Unknown prime " + k);
      return pe[k] = O, O;
    };
    function C(E) {
      if (typeof E == "string") {
        var k = p._prime(E);
        this.m = k.p, this.prime = k;
      } else
        l(E.gtn(1), "modulus must be greater than 1"), this.m = E, this.prime = null;
    }
    C.prototype._verify1 = function(k) {
      l(k.negative === 0, "red works only with positives"), l(k.red, "red works only with red numbers");
    }, C.prototype._verify2 = function(k, O) {
      l((k.negative | O.negative) === 0, "red works only with positives"), l(
        k.red && k.red === O.red,
        "red works only with red numbers"
      );
    }, C.prototype.imod = function(k) {
      return this.prime ? this.prime.ireduce(k)._forceRed(this) : (F(k, k.umod(this.m)._forceRed(this)), k);
    }, C.prototype.neg = function(k) {
      return k.isZero() ? k.clone() : this.m.sub(k)._forceRed(this);
    }, C.prototype.add = function(k, O) {
      this._verify2(k, O);
      var A = k.add(O);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A._forceRed(this);
    }, C.prototype.iadd = function(k, O) {
      this._verify2(k, O);
      var A = k.iadd(O);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A;
    }, C.prototype.sub = function(k, O) {
      this._verify2(k, O);
      var A = k.sub(O);
      return A.cmpn(0) < 0 && A.iadd(this.m), A._forceRed(this);
    }, C.prototype.isub = function(k, O) {
      this._verify2(k, O);
      var A = k.isub(O);
      return A.cmpn(0) < 0 && A.iadd(this.m), A;
    }, C.prototype.shl = function(k, O) {
      return this._verify1(k), this.imod(k.ushln(O));
    }, C.prototype.imul = function(k, O) {
      return this._verify2(k, O), this.imod(k.imul(O));
    }, C.prototype.mul = function(k, O) {
      return this._verify2(k, O), this.imod(k.mul(O));
    }, C.prototype.isqr = function(k) {
      return this.imul(k, k.clone());
    }, C.prototype.sqr = function(k) {
      return this.mul(k, k);
    }, C.prototype.sqrt = function(k) {
      if (k.isZero())
        return k.clone();
      var O = this.m.andln(3);
      if (l(O % 2 === 1), O === 3) {
        var A = this.m.add(new p(1)).iushrn(2);
        return this.pow(k, A);
      }
      for (var x = this.m.subn(1), Y = 0; !x.isZero() && x.andln(1) === 0; )
        Y++, x.iushrn(1);
      l(!x.isZero());
      var B = new p(1).toRed(this), T = B.redNeg(), D = this.m.subn(1).iushrn(1), te = this.m.bitLength();
      for (te = new p(2 * te * te).toRed(this); this.pow(te, D).cmp(T) !== 0; )
        te.redIAdd(T);
      for (var me = this.pow(te, x), Ie = this.pow(k, x.addn(1).iushrn(1)), $e = this.pow(k, x), ye = Y; $e.cmp(B) !== 0; ) {
        for (var fe = $e, Me = 0; fe.cmp(B) !== 0; Me++)
          fe = fe.redSqr();
        l(Me < ye);
        var Ae = this.pow(me, new p(1).iushln(ye - Me - 1));
        Ie = Ie.redMul(Ae), me = Ae.redSqr(), $e = $e.redMul(me), ye = Me;
      }
      return Ie;
    }, C.prototype.invm = function(k) {
      var O = k._invmp(this.m);
      return O.negative !== 0 ? (O.negative = 0, this.imod(O).redNeg()) : this.imod(O);
    }, C.prototype.pow = function(k, O) {
      if (O.isZero())
        return new p(1).toRed(this);
      if (O.cmpn(1) === 0)
        return k.clone();
      var A = 4, x = new Array(1 << A);
      x[0] = new p(1).toRed(this), x[1] = k;
      for (var Y = 2; Y < x.length; Y++)
        x[Y] = this.mul(x[Y - 1], k);
      var B = x[0], T = 0, D = 0, te = O.bitLength() % 26;
      for (te === 0 && (te = 26), Y = O.length - 1; Y >= 0; Y--) {
        for (var me = O.words[Y], Ie = te - 1; Ie >= 0; Ie--) {
          var $e = me >> Ie & 1;
          if (B !== x[0] && (B = this.sqr(B)), $e === 0 && T === 0) {
            D = 0;
            continue;
          }
          T <<= 1, T |= $e, D++, !(D !== A && (Y !== 0 || Ie !== 0)) && (B = this.mul(B, x[T]), D = 0, T = 0);
        }
        te = 26;
      }
      return B;
    }, C.prototype.convertTo = function(k) {
      var O = k.umod(this.m);
      return O === k ? O.clone() : O;
    }, C.prototype.convertFrom = function(k) {
      var O = k.clone();
      return O.red = null, O;
    }, p.mont = function(k) {
      return new b(k);
    };
    function b(E) {
      C.call(this, E), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(b, C), b.prototype.convertTo = function(k) {
      return this.imod(k.ushln(this.shift));
    }, b.prototype.convertFrom = function(k) {
      var O = this.imod(k.mul(this.rinv));
      return O.red = null, O;
    }, b.prototype.imul = function(k, O) {
      if (k.isZero() || O.isZero())
        return k.words[0] = 0, k.length = 1, k;
      var A = k.imul(O), x = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = A.isub(x).iushrn(this.shift), B = Y;
      return Y.cmp(this.m) >= 0 ? B = Y.isub(this.m) : Y.cmpn(0) < 0 && (B = Y.iadd(this.m)), B._forceRed(this);
    }, b.prototype.mul = function(k, O) {
      if (k.isZero() || O.isZero())
        return new p(0)._forceRed(this);
      var A = k.mul(O), x = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Y = A.isub(x).iushrn(this.shift), B = Y;
      return Y.cmp(this.m) >= 0 ? B = Y.isub(this.m) : Y.cmpn(0) < 0 && (B = Y.iadd(this.m)), B._forceRed(this);
    }, b.prototype.invm = function(k) {
      var O = this.imod(k._invmp(this.m).mul(this.r2));
      return O._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$4);
var bnExports$4 = bn$4.exports, BN$a = bnExports$4, randomBytes$1 = browserExports;
function blind(a) {
  var u = getr(a), c = u.toRed(BN$a.mont(a.modulus)).redPow(new BN$a(a.publicExponent)).fromRed();
  return { blinder: c, unblinder: u.invm(a.modulus) };
}
function getr(a) {
  var u = a.modulus.byteLength(), c;
  do
    c = new BN$a(randomBytes$1(u));
  while (c.cmp(a.modulus) >= 0 || !c.umod(a.prime1) || !c.umod(a.prime2));
  return c;
}
function crt$2(a, u) {
  var c = blind(u), l = u.modulus.byteLength(), v = new BN$a(a).mul(c.blinder).umod(u.modulus), p = v.toRed(BN$a.mont(u.prime1)), _ = v.toRed(BN$a.mont(u.prime2)), I = u.coefficient, P = u.prime1, $ = u.prime2, F = p.redPow(u.exponent1).fromRed(), H = _.redPow(u.exponent2).fromRed(), j = F.isub(H).imul(I).umod(P).imul($);
  return H.iadd(j).imul(c.unblinder).umod(u.modulus).toArrayLike(Buffer$O, "be", l);
}
crt$2.getr = getr;
var browserifyRsa = crt$2, elliptic = {};
const name$1 = "elliptic", version$1 = "6.5.4", description$1 = "EC cryptography", main$1 = "lib/elliptic.js", files = [
  "lib"
], scripts$1 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository$1 = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords$1 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author$1 = "Fedor Indutny <fedor@indutny.com>", license$1 = "MIT", bugs$1 = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage$1 = "https://github.com/indutny/elliptic", devDependencies$1 = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies$1 = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0$1 = {
  name: name$1,
  version: version$1,
  description: description$1,
  main: main$1,
  files,
  scripts: scripts$1,
  repository: repository$1,
  keywords: keywords$1,
  author: author$1,
  license: license$1,
  bugs: bugs$1,
  homepage: homepage$1,
  devDependencies: devDependencies$1,
  dependencies: dependencies$1
};
var utils$v = {}, bn$3 = { exports: {} };
bn$3.exports;
(function(a) {
  (function(u, c) {
    function l(C, b) {
      if (!C)
        throw new Error(b || "Assertion failed");
    }
    function v(C, b) {
      C.super_ = b;
      var E = function() {
      };
      E.prototype = b.prototype, C.prototype = new E(), C.prototype.constructor = C;
    }
    function p(C, b, E) {
      if (p.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((b === "le" || b === "be") && (E = b, b = 10), this._init(C || 0, b || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(b) {
      return b instanceof p ? !0 : b !== null && typeof b == "object" && b.constructor.wordSize === p.wordSize && Array.isArray(b.words);
    }, p.max = function(b, E) {
      return b.cmp(E) > 0 ? b : E;
    }, p.min = function(b, E) {
      return b.cmp(E) < 0 ? b : E;
    }, p.prototype._init = function(b, E, k) {
      if (typeof b == "number")
        return this._initNumber(b, E, k);
      if (typeof b == "object")
        return this._initArray(b, E, k);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), b = b.toString().replace(/\s+/g, "");
      var O = 0;
      b[0] === "-" && (O++, this.negative = 1), O < b.length && (E === 16 ? this._parseHex(b, O, k) : (this._parseBase(b, E, O), k === "le" && this._initArray(this.toArray(), E, k)));
    }, p.prototype._initNumber = function(b, E, k) {
      b < 0 && (this.negative = 1, b = -b), b < 67108864 ? (this.words = [b & 67108863], this.length = 1) : b < 4503599627370496 ? (this.words = [
        b & 67108863,
        b / 67108864 & 67108863
      ], this.length = 2) : (l(b < 9007199254740992), this.words = [
        b & 67108863,
        b / 67108864 & 67108863,
        1
      ], this.length = 3), k === "le" && this._initArray(this.toArray(), E, k);
    }, p.prototype._initArray = function(b, E, k) {
      if (l(typeof b.length == "number"), b.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(b.length / 3), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var A, x, Y = 0;
      if (k === "be")
        for (O = b.length - 1, A = 0; O >= 0; O -= 3)
          x = b[O] | b[O - 1] << 8 | b[O - 2] << 16, this.words[A] |= x << Y & 67108863, this.words[A + 1] = x >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, A++);
      else if (k === "le")
        for (O = 0, A = 0; O < b.length; O += 3)
          x = b[O] | b[O + 1] << 8 | b[O + 2] << 16, this.words[A] |= x << Y & 67108863, this.words[A + 1] = x >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, A++);
      return this.strip();
    };
    function I(C, b) {
      var E = C.charCodeAt(b);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function P(C, b, E) {
      var k = I(C, E);
      return E - 1 >= b && (k |= I(C, E - 1) << 4), k;
    }
    p.prototype._parseHex = function(b, E, k) {
      this.length = Math.ceil((b.length - E) / 6), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var A = 0, x = 0, Y;
      if (k === "be")
        for (O = b.length - 1; O >= E; O -= 2)
          Y = P(b, E, O) << A, this.words[x] |= Y & 67108863, A >= 18 ? (A -= 18, x += 1, this.words[x] |= Y >>> 26) : A += 8;
      else {
        var B = b.length - E;
        for (O = B % 2 === 0 ? E + 1 : E; O < b.length; O += 2)
          Y = P(b, E, O) << A, this.words[x] |= Y & 67108863, A >= 18 ? (A -= 18, x += 1, this.words[x] |= Y >>> 26) : A += 8;
      }
      this.strip();
    };
    function $(C, b, E, k) {
      for (var O = 0, A = Math.min(C.length, E), x = b; x < A; x++) {
        var Y = C.charCodeAt(x) - 48;
        O *= k, Y >= 49 ? O += Y - 49 + 10 : Y >= 17 ? O += Y - 17 + 10 : O += Y;
      }
      return O;
    }
    p.prototype._parseBase = function(b, E, k) {
      this.words = [0], this.length = 1;
      for (var O = 0, A = 1; A <= 67108863; A *= E)
        O++;
      O--, A = A / E | 0;
      for (var x = b.length - k, Y = x % O, B = Math.min(x, x - Y) + k, T = 0, D = k; D < B; D += O)
        T = $(b, D, D + O, E), this.imuln(A), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = $(b, D, b.length, E), D = 0; D < Y; D++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(b) {
      b.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        b.words[E] = this.words[E];
      b.length = this.length, b.negative = this.negative, b.red = this.red;
    }, p.prototype.clone = function() {
      var b = new p(null);
      return this.copy(b), b;
    }, p.prototype._expand = function(b) {
      for (; this.length < b; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], H = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], j = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(b, E) {
      b = b || 10, E = E | 0 || 1;
      var k;
      if (b === 16 || b === "hex") {
        k = "";
        for (var O = 0, A = 0, x = 0; x < this.length; x++) {
          var Y = this.words[x], B = ((Y << O | A) & 16777215).toString(16);
          A = Y >>> 24 - O & 16777215, A !== 0 || x !== this.length - 1 ? k = F[6 - B.length] + B + k : k = B + k, O += 2, O >= 26 && (O -= 26, x--);
        }
        for (A !== 0 && (k = A.toString(16) + k); k.length % E !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      if (b === (b | 0) && b >= 2 && b <= 36) {
        var T = H[b], D = j[b];
        k = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var me = te.modn(D).toString(b);
          te = te.idivn(D), te.isZero() ? k = me + k : k = F[T - me.length] + me + k;
        }
        for (this.isZero() && (k = "0" + k); k.length % E !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var b = this.words[0];
      return this.length === 2 ? b += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? b += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -b : b;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(b, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, b, E);
    }, p.prototype.toArray = function(b, E) {
      return this.toArrayLike(Array, b, E);
    }, p.prototype.toArrayLike = function(b, E, k) {
      var O = this.byteLength(), A = k || Math.max(1, O);
      l(O <= A, "byte array longer than desired length"), l(A > 0, "Requested array length <= 0"), this.strip();
      var x = E === "le", Y = new b(A), B, T, D = this.clone();
      if (x) {
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), Y[T] = B;
        for (; T < A; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < A - O; T++)
          Y[T] = 0;
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), Y[A - T - 1] = B;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(b) {
      return 32 - Math.clz32(b);
    } : p.prototype._countBits = function(b) {
      var E = b, k = 0;
      return E >= 4096 && (k += 13, E >>>= 13), E >= 64 && (k += 7, E >>>= 7), E >= 8 && (k += 4, E >>>= 4), E >= 2 && (k += 2, E >>>= 2), k + E;
    }, p.prototype._zeroBits = function(b) {
      if (b === 0)
        return 26;
      var E = b, k = 0;
      return E & 8191 || (k += 13, E >>>= 13), E & 127 || (k += 7, E >>>= 7), E & 15 || (k += 4, E >>>= 4), E & 3 || (k += 2, E >>>= 2), E & 1 || k++, k;
    }, p.prototype.bitLength = function() {
      var b = this.words[this.length - 1], E = this._countBits(b);
      return (this.length - 1) * 26 + E;
    };
    function ee(C) {
      for (var b = new Array(C.bitLength()), E = 0; E < b.length; E++) {
        var k = E / 26 | 0, O = E % 26;
        b[E] = (C.words[k] & 1 << O) >>> O;
      }
      return b;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var b = 0, E = 0; E < this.length; E++) {
        var k = this._zeroBits(this.words[E]);
        if (b += k, k !== 26)
          break;
      }
      return b;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(b) {
      return this.negative !== 0 ? this.abs().inotn(b).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(b) {
      return this.testn(b - 1) ? this.notn(b).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(b) {
      for (; this.length < b.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < b.length; E++)
        this.words[E] = this.words[E] | b.words[E];
      return this.strip();
    }, p.prototype.ior = function(b) {
      return l((this.negative | b.negative) === 0), this.iuor(b);
    }, p.prototype.or = function(b) {
      return this.length > b.length ? this.clone().ior(b) : b.clone().ior(this);
    }, p.prototype.uor = function(b) {
      return this.length > b.length ? this.clone().iuor(b) : b.clone().iuor(this);
    }, p.prototype.iuand = function(b) {
      var E;
      this.length > b.length ? E = b : E = this;
      for (var k = 0; k < E.length; k++)
        this.words[k] = this.words[k] & b.words[k];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(b) {
      return l((this.negative | b.negative) === 0), this.iuand(b);
    }, p.prototype.and = function(b) {
      return this.length > b.length ? this.clone().iand(b) : b.clone().iand(this);
    }, p.prototype.uand = function(b) {
      return this.length > b.length ? this.clone().iuand(b) : b.clone().iuand(this);
    }, p.prototype.iuxor = function(b) {
      var E, k;
      this.length > b.length ? (E = this, k = b) : (E = b, k = this);
      for (var O = 0; O < k.length; O++)
        this.words[O] = E.words[O] ^ k.words[O];
      if (this !== E)
        for (; O < E.length; O++)
          this.words[O] = E.words[O];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(b) {
      return l((this.negative | b.negative) === 0), this.iuxor(b);
    }, p.prototype.xor = function(b) {
      return this.length > b.length ? this.clone().ixor(b) : b.clone().ixor(this);
    }, p.prototype.uxor = function(b) {
      return this.length > b.length ? this.clone().iuxor(b) : b.clone().iuxor(this);
    }, p.prototype.inotn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = Math.ceil(b / 26) | 0, k = b % 26;
      this._expand(E), k > 0 && E--;
      for (var O = 0; O < E; O++)
        this.words[O] = ~this.words[O] & 67108863;
      return k > 0 && (this.words[O] = ~this.words[O] & 67108863 >> 26 - k), this.strip();
    }, p.prototype.notn = function(b) {
      return this.clone().inotn(b);
    }, p.prototype.setn = function(b, E) {
      l(typeof b == "number" && b >= 0);
      var k = b / 26 | 0, O = b % 26;
      return this._expand(k + 1), E ? this.words[k] = this.words[k] | 1 << O : this.words[k] = this.words[k] & ~(1 << O), this.strip();
    }, p.prototype.iadd = function(b) {
      var E;
      if (this.negative !== 0 && b.negative === 0)
        return this.negative = 0, E = this.isub(b), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && b.negative !== 0)
        return b.negative = 0, E = this.isub(b), b.negative = 1, E._normSign();
      var k, O;
      this.length > b.length ? (k = this, O = b) : (k = b, O = this);
      for (var A = 0, x = 0; x < O.length; x++)
        E = (k.words[x] | 0) + (O.words[x] | 0) + A, this.words[x] = E & 67108863, A = E >>> 26;
      for (; A !== 0 && x < k.length; x++)
        E = (k.words[x] | 0) + A, this.words[x] = E & 67108863, A = E >>> 26;
      if (this.length = k.length, A !== 0)
        this.words[this.length] = A, this.length++;
      else if (k !== this)
        for (; x < k.length; x++)
          this.words[x] = k.words[x];
      return this;
    }, p.prototype.add = function(b) {
      var E;
      return b.negative !== 0 && this.negative === 0 ? (b.negative = 0, E = this.sub(b), b.negative ^= 1, E) : b.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = b.sub(this), this.negative = 1, E) : this.length > b.length ? this.clone().iadd(b) : b.clone().iadd(this);
    }, p.prototype.isub = function(b) {
      if (b.negative !== 0) {
        b.negative = 0;
        var E = this.iadd(b);
        return b.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(b), this.negative = 1, this._normSign();
      var k = this.cmp(b);
      if (k === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var O, A;
      k > 0 ? (O = this, A = b) : (O = b, A = this);
      for (var x = 0, Y = 0; Y < A.length; Y++)
        E = (O.words[Y] | 0) - (A.words[Y] | 0) + x, x = E >> 26, this.words[Y] = E & 67108863;
      for (; x !== 0 && Y < O.length; Y++)
        E = (O.words[Y] | 0) + x, x = E >> 26, this.words[Y] = E & 67108863;
      if (x === 0 && Y < O.length && O !== this)
        for (; Y < O.length; Y++)
          this.words[Y] = O.words[Y];
      return this.length = Math.max(this.length, Y), O !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(b) {
      return this.clone().isub(b);
    };
    function X(C, b, E) {
      E.negative = b.negative ^ C.negative;
      var k = C.length + b.length | 0;
      E.length = k, k = k - 1 | 0;
      var O = C.words[0] | 0, A = b.words[0] | 0, x = O * A, Y = x & 67108863, B = x / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < k; T++) {
        for (var D = B >>> 26, te = B & 67108863, me = Math.min(T, b.length - 1), Ie = Math.max(0, T - C.length + 1); Ie <= me; Ie++) {
          var $e = T - Ie | 0;
          O = C.words[$e] | 0, A = b.words[Ie] | 0, x = O * A + te, D += x / 67108864 | 0, te = x & 67108863;
        }
        E.words[T] = te | 0, B = D | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ie = function(b, E, k) {
      var O = b.words, A = E.words, x = k.words, Y = 0, B, T, D, te = O[0] | 0, me = te & 8191, Ie = te >>> 13, $e = O[1] | 0, ye = $e & 8191, fe = $e >>> 13, Me = O[2] | 0, Ae = Me & 8191, xe = Me >>> 13, ae = O[3] | 0, N = ae & 8191, re = ae >>> 13, le = O[4] | 0, Ne = le & 8191, Oe = le >>> 13, qe = O[5] | 0, je = qe & 8191, Fe = qe >>> 13, yt = O[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, V = O[7] | 0, ge = V & 8191, Te = V >>> 13, We = O[8] | 0, Re = We & 8191, J = We >>> 13, Ee = O[9] | 0, ue = Ee & 8191, ce = Ee >>> 13, ve = A[0] | 0, Ce = ve & 8191, Be = ve >>> 13, He = A[1] | 0, Ve = He & 8191, Ze = He >>> 13, Ke = A[2] | 0, U = Ke & 8191, se = Ke >>> 13, Se = A[3] | 0, Ue = Se & 8191, De = Se >>> 13, Ye = A[4] | 0, Qe = Ye & 8191, st = Ye >>> 13, St = A[5] | 0, tt = St & 8191, it = St >>> 13, Tt = A[6] | 0, rt = Tt & 8191, dt = Tt >>> 13, wt = A[7] | 0, nt = wt & 8191, at = wt >>> 13, gt = A[8] | 0, ot = gt & 8191, ct = gt >>> 13, Ct = A[9] | 0, ut = Ct & 8191, lt = Ct >>> 13;
      k.negative = b.negative ^ E.negative, k.length = 19, B = Math.imul(me, Ce), T = Math.imul(me, Be), T = T + Math.imul(Ie, Ce) | 0, D = Math.imul(Ie, Be);
      var kt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, B = Math.imul(ye, Ce), T = Math.imul(ye, Be), T = T + Math.imul(fe, Ce) | 0, D = Math.imul(fe, Be), B = B + Math.imul(me, Ve) | 0, T = T + Math.imul(me, Ze) | 0, T = T + Math.imul(Ie, Ve) | 0, D = D + Math.imul(Ie, Ze) | 0;
      var Rt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(Ae, Ce), T = Math.imul(Ae, Be), T = T + Math.imul(xe, Ce) | 0, D = Math.imul(xe, Be), B = B + Math.imul(ye, Ve) | 0, T = T + Math.imul(ye, Ze) | 0, T = T + Math.imul(fe, Ve) | 0, D = D + Math.imul(fe, Ze) | 0, B = B + Math.imul(me, U) | 0, T = T + Math.imul(me, se) | 0, T = T + Math.imul(Ie, U) | 0, D = D + Math.imul(Ie, se) | 0;
      var Je = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, B = Math.imul(N, Ce), T = Math.imul(N, Be), T = T + Math.imul(re, Ce) | 0, D = Math.imul(re, Be), B = B + Math.imul(Ae, Ve) | 0, T = T + Math.imul(Ae, Ze) | 0, T = T + Math.imul(xe, Ve) | 0, D = D + Math.imul(xe, Ze) | 0, B = B + Math.imul(ye, U) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(fe, U) | 0, D = D + Math.imul(fe, se) | 0, B = B + Math.imul(me, Ue) | 0, T = T + Math.imul(me, De) | 0, T = T + Math.imul(Ie, Ue) | 0, D = D + Math.imul(Ie, De) | 0;
      var ze = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, B = Math.imul(Ne, Ce), T = Math.imul(Ne, Be), T = T + Math.imul(Oe, Ce) | 0, D = Math.imul(Oe, Be), B = B + Math.imul(N, Ve) | 0, T = T + Math.imul(N, Ze) | 0, T = T + Math.imul(re, Ve) | 0, D = D + Math.imul(re, Ze) | 0, B = B + Math.imul(Ae, U) | 0, T = T + Math.imul(Ae, se) | 0, T = T + Math.imul(xe, U) | 0, D = D + Math.imul(xe, se) | 0, B = B + Math.imul(ye, Ue) | 0, T = T + Math.imul(ye, De) | 0, T = T + Math.imul(fe, Ue) | 0, D = D + Math.imul(fe, De) | 0, B = B + Math.imul(me, Qe) | 0, T = T + Math.imul(me, st) | 0, T = T + Math.imul(Ie, Qe) | 0, D = D + Math.imul(Ie, st) | 0;
      var et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, B = Math.imul(je, Ce), T = Math.imul(je, Be), T = T + Math.imul(Fe, Ce) | 0, D = Math.imul(Fe, Be), B = B + Math.imul(Ne, Ve) | 0, T = T + Math.imul(Ne, Ze) | 0, T = T + Math.imul(Oe, Ve) | 0, D = D + Math.imul(Oe, Ze) | 0, B = B + Math.imul(N, U) | 0, T = T + Math.imul(N, se) | 0, T = T + Math.imul(re, U) | 0, D = D + Math.imul(re, se) | 0, B = B + Math.imul(Ae, Ue) | 0, T = T + Math.imul(Ae, De) | 0, T = T + Math.imul(xe, Ue) | 0, D = D + Math.imul(xe, De) | 0, B = B + Math.imul(ye, Qe) | 0, T = T + Math.imul(ye, st) | 0, T = T + Math.imul(fe, Qe) | 0, D = D + Math.imul(fe, st) | 0, B = B + Math.imul(me, tt) | 0, T = T + Math.imul(me, it) | 0, T = T + Math.imul(Ie, tt) | 0, D = D + Math.imul(Ie, it) | 0;
      var pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Ce), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Ce) | 0, D = Math.imul(Ge, Be), B = B + Math.imul(je, Ve) | 0, T = T + Math.imul(je, Ze) | 0, T = T + Math.imul(Fe, Ve) | 0, D = D + Math.imul(Fe, Ze) | 0, B = B + Math.imul(Ne, U) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Oe, U) | 0, D = D + Math.imul(Oe, se) | 0, B = B + Math.imul(N, Ue) | 0, T = T + Math.imul(N, De) | 0, T = T + Math.imul(re, Ue) | 0, D = D + Math.imul(re, De) | 0, B = B + Math.imul(Ae, Qe) | 0, T = T + Math.imul(Ae, st) | 0, T = T + Math.imul(xe, Qe) | 0, D = D + Math.imul(xe, st) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(fe, tt) | 0, D = D + Math.imul(fe, it) | 0, B = B + Math.imul(me, rt) | 0, T = T + Math.imul(me, dt) | 0, T = T + Math.imul(Ie, rt) | 0, D = D + Math.imul(Ie, dt) | 0;
      var mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ge, Ce), T = Math.imul(ge, Be), T = T + Math.imul(Te, Ce) | 0, D = Math.imul(Te, Be), B = B + Math.imul(Xe, Ve) | 0, T = T + Math.imul(Xe, Ze) | 0, T = T + Math.imul(Ge, Ve) | 0, D = D + Math.imul(Ge, Ze) | 0, B = B + Math.imul(je, U) | 0, T = T + Math.imul(je, se) | 0, T = T + Math.imul(Fe, U) | 0, D = D + Math.imul(Fe, se) | 0, B = B + Math.imul(Ne, Ue) | 0, T = T + Math.imul(Ne, De) | 0, T = T + Math.imul(Oe, Ue) | 0, D = D + Math.imul(Oe, De) | 0, B = B + Math.imul(N, Qe) | 0, T = T + Math.imul(N, st) | 0, T = T + Math.imul(re, Qe) | 0, D = D + Math.imul(re, st) | 0, B = B + Math.imul(Ae, tt) | 0, T = T + Math.imul(Ae, it) | 0, T = T + Math.imul(xe, tt) | 0, D = D + Math.imul(xe, it) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(fe, rt) | 0, D = D + Math.imul(fe, dt) | 0, B = B + Math.imul(me, nt) | 0, T = T + Math.imul(me, at) | 0, T = T + Math.imul(Ie, nt) | 0, D = D + Math.imul(Ie, at) | 0;
      var vt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, B = Math.imul(Re, Ce), T = Math.imul(Re, Be), T = T + Math.imul(J, Ce) | 0, D = Math.imul(J, Be), B = B + Math.imul(ge, Ve) | 0, T = T + Math.imul(ge, Ze) | 0, T = T + Math.imul(Te, Ve) | 0, D = D + Math.imul(Te, Ze) | 0, B = B + Math.imul(Xe, U) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, U) | 0, D = D + Math.imul(Ge, se) | 0, B = B + Math.imul(je, Ue) | 0, T = T + Math.imul(je, De) | 0, T = T + Math.imul(Fe, Ue) | 0, D = D + Math.imul(Fe, De) | 0, B = B + Math.imul(Ne, Qe) | 0, T = T + Math.imul(Ne, st) | 0, T = T + Math.imul(Oe, Qe) | 0, D = D + Math.imul(Oe, st) | 0, B = B + Math.imul(N, tt) | 0, T = T + Math.imul(N, it) | 0, T = T + Math.imul(re, tt) | 0, D = D + Math.imul(re, it) | 0, B = B + Math.imul(Ae, rt) | 0, T = T + Math.imul(Ae, dt) | 0, T = T + Math.imul(xe, rt) | 0, D = D + Math.imul(xe, dt) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(fe, nt) | 0, D = D + Math.imul(fe, at) | 0, B = B + Math.imul(me, ot) | 0, T = T + Math.imul(me, ct) | 0, T = T + Math.imul(Ie, ot) | 0, D = D + Math.imul(Ie, ct) | 0;
      var ht = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(ue, Ce), T = Math.imul(ue, Be), T = T + Math.imul(ce, Ce) | 0, D = Math.imul(ce, Be), B = B + Math.imul(Re, Ve) | 0, T = T + Math.imul(Re, Ze) | 0, T = T + Math.imul(J, Ve) | 0, D = D + Math.imul(J, Ze) | 0, B = B + Math.imul(ge, U) | 0, T = T + Math.imul(ge, se) | 0, T = T + Math.imul(Te, U) | 0, D = D + Math.imul(Te, se) | 0, B = B + Math.imul(Xe, Ue) | 0, T = T + Math.imul(Xe, De) | 0, T = T + Math.imul(Ge, Ue) | 0, D = D + Math.imul(Ge, De) | 0, B = B + Math.imul(je, Qe) | 0, T = T + Math.imul(je, st) | 0, T = T + Math.imul(Fe, Qe) | 0, D = D + Math.imul(Fe, st) | 0, B = B + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Oe, tt) | 0, D = D + Math.imul(Oe, it) | 0, B = B + Math.imul(N, rt) | 0, T = T + Math.imul(N, dt) | 0, T = T + Math.imul(re, rt) | 0, D = D + Math.imul(re, dt) | 0, B = B + Math.imul(Ae, nt) | 0, T = T + Math.imul(Ae, at) | 0, T = T + Math.imul(xe, nt) | 0, D = D + Math.imul(xe, at) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(fe, ot) | 0, D = D + Math.imul(fe, ct) | 0, B = B + Math.imul(me, ut) | 0, T = T + Math.imul(me, lt) | 0, T = T + Math.imul(Ie, ut) | 0, D = D + Math.imul(Ie, lt) | 0;
      var _t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, B = Math.imul(ue, Ve), T = Math.imul(ue, Ze), T = T + Math.imul(ce, Ve) | 0, D = Math.imul(ce, Ze), B = B + Math.imul(Re, U) | 0, T = T + Math.imul(Re, se) | 0, T = T + Math.imul(J, U) | 0, D = D + Math.imul(J, se) | 0, B = B + Math.imul(ge, Ue) | 0, T = T + Math.imul(ge, De) | 0, T = T + Math.imul(Te, Ue) | 0, D = D + Math.imul(Te, De) | 0, B = B + Math.imul(Xe, Qe) | 0, T = T + Math.imul(Xe, st) | 0, T = T + Math.imul(Ge, Qe) | 0, D = D + Math.imul(Ge, st) | 0, B = B + Math.imul(je, tt) | 0, T = T + Math.imul(je, it) | 0, T = T + Math.imul(Fe, tt) | 0, D = D + Math.imul(Fe, it) | 0, B = B + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Oe, rt) | 0, D = D + Math.imul(Oe, dt) | 0, B = B + Math.imul(N, nt) | 0, T = T + Math.imul(N, at) | 0, T = T + Math.imul(re, nt) | 0, D = D + Math.imul(re, at) | 0, B = B + Math.imul(Ae, ot) | 0, T = T + Math.imul(Ae, ct) | 0, T = T + Math.imul(xe, ot) | 0, D = D + Math.imul(xe, ct) | 0, B = B + Math.imul(ye, ut) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(fe, ut) | 0, D = D + Math.imul(fe, lt) | 0;
      var Et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(ue, U), T = Math.imul(ue, se), T = T + Math.imul(ce, U) | 0, D = Math.imul(ce, se), B = B + Math.imul(Re, Ue) | 0, T = T + Math.imul(Re, De) | 0, T = T + Math.imul(J, Ue) | 0, D = D + Math.imul(J, De) | 0, B = B + Math.imul(ge, Qe) | 0, T = T + Math.imul(ge, st) | 0, T = T + Math.imul(Te, Qe) | 0, D = D + Math.imul(Te, st) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, tt) | 0, D = D + Math.imul(Ge, it) | 0, B = B + Math.imul(je, rt) | 0, T = T + Math.imul(je, dt) | 0, T = T + Math.imul(Fe, rt) | 0, D = D + Math.imul(Fe, dt) | 0, B = B + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Oe, nt) | 0, D = D + Math.imul(Oe, at) | 0, B = B + Math.imul(N, ot) | 0, T = T + Math.imul(N, ct) | 0, T = T + Math.imul(re, ot) | 0, D = D + Math.imul(re, ct) | 0, B = B + Math.imul(Ae, ut) | 0, T = T + Math.imul(Ae, lt) | 0, T = T + Math.imul(xe, ut) | 0, D = D + Math.imul(xe, lt) | 0;
      var Pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, B = Math.imul(ue, Ue), T = Math.imul(ue, De), T = T + Math.imul(ce, Ue) | 0, D = Math.imul(ce, De), B = B + Math.imul(Re, Qe) | 0, T = T + Math.imul(Re, st) | 0, T = T + Math.imul(J, Qe) | 0, D = D + Math.imul(J, st) | 0, B = B + Math.imul(ge, tt) | 0, T = T + Math.imul(ge, it) | 0, T = T + Math.imul(Te, tt) | 0, D = D + Math.imul(Te, it) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, rt) | 0, D = D + Math.imul(Ge, dt) | 0, B = B + Math.imul(je, nt) | 0, T = T + Math.imul(je, at) | 0, T = T + Math.imul(Fe, nt) | 0, D = D + Math.imul(Fe, at) | 0, B = B + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Oe, ot) | 0, D = D + Math.imul(Oe, ct) | 0, B = B + Math.imul(N, ut) | 0, T = T + Math.imul(N, lt) | 0, T = T + Math.imul(re, ut) | 0, D = D + Math.imul(re, lt) | 0;
      var Nt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(ue, Qe), T = Math.imul(ue, st), T = T + Math.imul(ce, Qe) | 0, D = Math.imul(ce, st), B = B + Math.imul(Re, tt) | 0, T = T + Math.imul(Re, it) | 0, T = T + Math.imul(J, tt) | 0, D = D + Math.imul(J, it) | 0, B = B + Math.imul(ge, rt) | 0, T = T + Math.imul(ge, dt) | 0, T = T + Math.imul(Te, rt) | 0, D = D + Math.imul(Te, dt) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, nt) | 0, D = D + Math.imul(Ge, at) | 0, B = B + Math.imul(je, ot) | 0, T = T + Math.imul(je, ct) | 0, T = T + Math.imul(Fe, ot) | 0, D = D + Math.imul(Fe, ct) | 0, B = B + Math.imul(Ne, ut) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Oe, ut) | 0, D = D + Math.imul(Oe, lt) | 0;
      var Mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, B = Math.imul(ue, tt), T = Math.imul(ue, it), T = T + Math.imul(ce, tt) | 0, D = Math.imul(ce, it), B = B + Math.imul(Re, rt) | 0, T = T + Math.imul(Re, dt) | 0, T = T + Math.imul(J, rt) | 0, D = D + Math.imul(J, dt) | 0, B = B + Math.imul(ge, nt) | 0, T = T + Math.imul(ge, at) | 0, T = T + Math.imul(Te, nt) | 0, D = D + Math.imul(Te, at) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, D = D + Math.imul(Ge, ct) | 0, B = B + Math.imul(je, ut) | 0, T = T + Math.imul(je, lt) | 0, T = T + Math.imul(Fe, ut) | 0, D = D + Math.imul(Fe, lt) | 0;
      var Ot = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(ue, rt), T = Math.imul(ue, dt), T = T + Math.imul(ce, rt) | 0, D = Math.imul(ce, dt), B = B + Math.imul(Re, nt) | 0, T = T + Math.imul(Re, at) | 0, T = T + Math.imul(J, nt) | 0, D = D + Math.imul(J, at) | 0, B = B + Math.imul(ge, ot) | 0, T = T + Math.imul(ge, ct) | 0, T = T + Math.imul(Te, ot) | 0, D = D + Math.imul(Te, ct) | 0, B = B + Math.imul(Xe, ut) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, ut) | 0, D = D + Math.imul(Ge, lt) | 0;
      var $t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(ue, nt), T = Math.imul(ue, at), T = T + Math.imul(ce, nt) | 0, D = Math.imul(ce, at), B = B + Math.imul(Re, ot) | 0, T = T + Math.imul(Re, ct) | 0, T = T + Math.imul(J, ot) | 0, D = D + Math.imul(J, ct) | 0, B = B + Math.imul(ge, ut) | 0, T = T + Math.imul(ge, lt) | 0, T = T + Math.imul(Te, ut) | 0, D = D + Math.imul(Te, lt) | 0;
      var Bt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(ue, ot), T = Math.imul(ue, ct), T = T + Math.imul(ce, ot) | 0, D = Math.imul(ce, ct), B = B + Math.imul(Re, ut) | 0, T = T + Math.imul(Re, lt) | 0, T = T + Math.imul(J, ut) | 0, D = D + Math.imul(J, lt) | 0;
      var xt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, B = Math.imul(ue, ut), T = Math.imul(ue, lt), T = T + Math.imul(ce, ut) | 0, D = Math.imul(ce, lt);
      var Ut = (Y + B | 0) + ((T & 8191) << 13) | 0;
      return Y = (D + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, x[0] = kt, x[1] = Rt, x[2] = Je, x[3] = ze, x[4] = et, x[5] = pt, x[6] = mt, x[7] = vt, x[8] = ht, x[9] = _t, x[10] = Et, x[11] = Pt, x[12] = Nt, x[13] = Mt, x[14] = Ot, x[15] = $t, x[16] = Bt, x[17] = xt, x[18] = Ut, Y !== 0 && (x[19] = Y, k.length++), k;
    };
    Math.imul || (ie = X);
    function Q(C, b, E) {
      E.negative = b.negative ^ C.negative, E.length = C.length + b.length;
      for (var k = 0, O = 0, A = 0; A < E.length - 1; A++) {
        var x = O;
        O = 0;
        for (var Y = k & 67108863, B = Math.min(A, b.length - 1), T = Math.max(0, A - C.length + 1); T <= B; T++) {
          var D = A - T, te = C.words[D] | 0, me = b.words[T] | 0, Ie = te * me, $e = Ie & 67108863;
          x = x + (Ie / 67108864 | 0) | 0, $e = $e + Y | 0, Y = $e & 67108863, x = x + ($e >>> 26) | 0, O += x >>> 26, x &= 67108863;
        }
        E.words[A] = Y, k = x, x = O;
      }
      return k !== 0 ? E.words[A] = k : E.length--, E.strip();
    }
    function ne(C, b, E) {
      var k = new Z();
      return k.mulp(C, b, E);
    }
    p.prototype.mulTo = function(b, E) {
      var k, O = this.length + b.length;
      return this.length === 10 && b.length === 10 ? k = ie(this, b, E) : O < 63 ? k = X(this, b, E) : O < 1024 ? k = Q(this, b, E) : k = ne(this, b, E), k;
    };
    function Z(C, b) {
      this.x = C, this.y = b;
    }
    Z.prototype.makeRBT = function(b) {
      for (var E = new Array(b), k = p.prototype._countBits(b) - 1, O = 0; O < b; O++)
        E[O] = this.revBin(O, k, b);
      return E;
    }, Z.prototype.revBin = function(b, E, k) {
      if (b === 0 || b === k - 1)
        return b;
      for (var O = 0, A = 0; A < E; A++)
        O |= (b & 1) << E - A - 1, b >>= 1;
      return O;
    }, Z.prototype.permute = function(b, E, k, O, A, x) {
      for (var Y = 0; Y < x; Y++)
        O[Y] = E[b[Y]], A[Y] = k[b[Y]];
    }, Z.prototype.transform = function(b, E, k, O, A, x) {
      this.permute(x, b, E, k, O, A);
      for (var Y = 1; Y < A; Y <<= 1)
        for (var B = Y << 1, T = Math.cos(2 * Math.PI / B), D = Math.sin(2 * Math.PI / B), te = 0; te < A; te += B)
          for (var me = T, Ie = D, $e = 0; $e < Y; $e++) {
            var ye = k[te + $e], fe = O[te + $e], Me = k[te + $e + Y], Ae = O[te + $e + Y], xe = me * Me - Ie * Ae;
            Ae = me * Ae + Ie * Me, Me = xe, k[te + $e] = ye + Me, O[te + $e] = fe + Ae, k[te + $e + Y] = ye - Me, O[te + $e + Y] = fe - Ae, $e !== B && (xe = T * me - D * Ie, Ie = T * Ie + D * me, me = xe);
          }
    }, Z.prototype.guessLen13b = function(b, E) {
      var k = Math.max(E, b) | 1, O = k & 1, A = 0;
      for (k = k / 2 | 0; k; k = k >>> 1)
        A++;
      return 1 << A + 1 + O;
    }, Z.prototype.conjugate = function(b, E, k) {
      if (!(k <= 1))
        for (var O = 0; O < k / 2; O++) {
          var A = b[O];
          b[O] = b[k - O - 1], b[k - O - 1] = A, A = E[O], E[O] = -E[k - O - 1], E[k - O - 1] = -A;
        }
    }, Z.prototype.normalize13b = function(b, E) {
      for (var k = 0, O = 0; O < E / 2; O++) {
        var A = Math.round(b[2 * O + 1] / E) * 8192 + Math.round(b[2 * O] / E) + k;
        b[O] = A & 67108863, A < 67108864 ? k = 0 : k = A / 67108864 | 0;
      }
      return b;
    }, Z.prototype.convert13b = function(b, E, k, O) {
      for (var A = 0, x = 0; x < E; x++)
        A = A + (b[x] | 0), k[2 * x] = A & 8191, A = A >>> 13, k[2 * x + 1] = A & 8191, A = A >>> 13;
      for (x = 2 * E; x < O; ++x)
        k[x] = 0;
      l(A === 0), l((A & -8192) === 0);
    }, Z.prototype.stub = function(b) {
      for (var E = new Array(b), k = 0; k < b; k++)
        E[k] = 0;
      return E;
    }, Z.prototype.mulp = function(b, E, k) {
      var O = 2 * this.guessLen13b(b.length, E.length), A = this.makeRBT(O), x = this.stub(O), Y = new Array(O), B = new Array(O), T = new Array(O), D = new Array(O), te = new Array(O), me = new Array(O), Ie = k.words;
      Ie.length = O, this.convert13b(b.words, b.length, Y, O), this.convert13b(E.words, E.length, D, O), this.transform(Y, x, B, T, O, A), this.transform(D, x, te, me, O, A);
      for (var $e = 0; $e < O; $e++) {
        var ye = B[$e] * te[$e] - T[$e] * me[$e];
        T[$e] = B[$e] * me[$e] + T[$e] * te[$e], B[$e] = ye;
      }
      return this.conjugate(B, T, O), this.transform(B, T, Ie, x, O, A), this.conjugate(Ie, x, O), this.normalize13b(Ie, O), k.negative = b.negative ^ E.negative, k.length = b.length + E.length, k.strip();
    }, p.prototype.mul = function(b) {
      var E = new p(null);
      return E.words = new Array(this.length + b.length), this.mulTo(b, E);
    }, p.prototype.mulf = function(b) {
      var E = new p(null);
      return E.words = new Array(this.length + b.length), ne(this, b, E);
    }, p.prototype.imul = function(b) {
      return this.clone().mulTo(b, this);
    }, p.prototype.imuln = function(b) {
      l(typeof b == "number"), l(b < 67108864);
      for (var E = 0, k = 0; k < this.length; k++) {
        var O = (this.words[k] | 0) * b, A = (O & 67108863) + (E & 67108863);
        E >>= 26, E += O / 67108864 | 0, E += A >>> 26, this.words[k] = A & 67108863;
      }
      return E !== 0 && (this.words[k] = E, this.length++), this;
    }, p.prototype.muln = function(b) {
      return this.clone().imuln(b);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(b) {
      var E = ee(b);
      if (E.length === 0)
        return new p(1);
      for (var k = this, O = 0; O < E.length && E[O] === 0; O++, k = k.sqr())
        ;
      if (++O < E.length)
        for (var A = k.sqr(); O < E.length; O++, A = A.sqr())
          E[O] !== 0 && (k = k.mul(A));
      return k;
    }, p.prototype.iushln = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26, O = 67108863 >>> 26 - E << 26 - E, A;
      if (E !== 0) {
        var x = 0;
        for (A = 0; A < this.length; A++) {
          var Y = this.words[A] & O, B = (this.words[A] | 0) - Y << E;
          this.words[A] = B | x, x = Y >>> 26 - E;
        }
        x && (this.words[A] = x, this.length++);
      }
      if (k !== 0) {
        for (A = this.length - 1; A >= 0; A--)
          this.words[A + k] = this.words[A];
        for (A = 0; A < k; A++)
          this.words[A] = 0;
        this.length += k;
      }
      return this.strip();
    }, p.prototype.ishln = function(b) {
      return l(this.negative === 0), this.iushln(b);
    }, p.prototype.iushrn = function(b, E, k) {
      l(typeof b == "number" && b >= 0);
      var O;
      E ? O = (E - E % 26) / 26 : O = 0;
      var A = b % 26, x = Math.min((b - A) / 26, this.length), Y = 67108863 ^ 67108863 >>> A << A, B = k;
      if (O -= x, O = Math.max(0, O), B) {
        for (var T = 0; T < x; T++)
          B.words[T] = this.words[T];
        B.length = x;
      }
      if (x !== 0)
        if (this.length > x)
          for (this.length -= x, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + x];
        else
          this.words[0] = 0, this.length = 1;
      var D = 0;
      for (T = this.length - 1; T >= 0 && (D !== 0 || T >= O); T--) {
        var te = this.words[T] | 0;
        this.words[T] = D << 26 - A | te >>> A, D = te & Y;
      }
      return B && D !== 0 && (B.words[B.length++] = D), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(b, E, k) {
      return l(this.negative === 0), this.iushrn(b, E, k);
    }, p.prototype.shln = function(b) {
      return this.clone().ishln(b);
    }, p.prototype.ushln = function(b) {
      return this.clone().iushln(b);
    }, p.prototype.shrn = function(b) {
      return this.clone().ishrn(b);
    }, p.prototype.ushrn = function(b) {
      return this.clone().iushrn(b);
    }, p.prototype.testn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26, O = 1 << E;
      if (this.length <= k)
        return !1;
      var A = this.words[k];
      return !!(A & O);
    }, p.prototype.imaskn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= k)
        return this;
      if (E !== 0 && k++, this.length = Math.min(k, this.length), E !== 0) {
        var O = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= O;
      }
      return this.strip();
    }, p.prototype.maskn = function(b) {
      return this.clone().imaskn(b);
    }, p.prototype.iaddn = function(b) {
      return l(typeof b == "number"), l(b < 67108864), b < 0 ? this.isubn(-b) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < b ? (this.words[0] = b - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(b), this.negative = 1, this) : this._iaddn(b);
    }, p.prototype._iaddn = function(b) {
      this.words[0] += b;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(b) {
      if (l(typeof b == "number"), l(b < 67108864), b < 0)
        return this.iaddn(-b);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(b), this.negative = 1, this;
      if (this.words[0] -= b, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(b) {
      return this.clone().iaddn(b);
    }, p.prototype.subn = function(b) {
      return this.clone().isubn(b);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(b, E, k) {
      var O = b.length + k, A;
      this._expand(O);
      var x, Y = 0;
      for (A = 0; A < b.length; A++) {
        x = (this.words[A + k] | 0) + Y;
        var B = (b.words[A] | 0) * E;
        x -= B & 67108863, Y = (x >> 26) - (B / 67108864 | 0), this.words[A + k] = x & 67108863;
      }
      for (; A < this.length - k; A++)
        x = (this.words[A + k] | 0) + Y, Y = x >> 26, this.words[A + k] = x & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, A = 0; A < this.length; A++)
        x = -(this.words[A] | 0) + Y, Y = x >> 26, this.words[A] = x & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(b, E) {
      var k = this.length - b.length, O = this.clone(), A = b, x = A.words[A.length - 1] | 0, Y = this._countBits(x);
      k = 26 - Y, k !== 0 && (A = A.ushln(k), O.iushln(k), x = A.words[A.length - 1] | 0);
      var B = O.length - A.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var D = 0; D < T.length; D++)
          T.words[D] = 0;
      }
      var te = O.clone()._ishlnsubmul(A, 1, B);
      te.negative === 0 && (O = te, T && (T.words[B] = 1));
      for (var me = B - 1; me >= 0; me--) {
        var Ie = (O.words[A.length + me] | 0) * 67108864 + (O.words[A.length + me - 1] | 0);
        for (Ie = Math.min(Ie / x | 0, 67108863), O._ishlnsubmul(A, Ie, me); O.negative !== 0; )
          Ie--, O.negative = 0, O._ishlnsubmul(A, 1, me), O.isZero() || (O.negative ^= 1);
        T && (T.words[me] = Ie);
      }
      return T && T.strip(), O.strip(), E !== "div" && k !== 0 && O.iushrn(k), {
        div: T || null,
        mod: O
      };
    }, p.prototype.divmod = function(b, E, k) {
      if (l(!b.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var O, A, x;
      return this.negative !== 0 && b.negative === 0 ? (x = this.neg().divmod(b, E), E !== "mod" && (O = x.div.neg()), E !== "div" && (A = x.mod.neg(), k && A.negative !== 0 && A.iadd(b)), {
        div: O,
        mod: A
      }) : this.negative === 0 && b.negative !== 0 ? (x = this.divmod(b.neg(), E), E !== "mod" && (O = x.div.neg()), {
        div: O,
        mod: x.mod
      }) : this.negative & b.negative ? (x = this.neg().divmod(b.neg(), E), E !== "div" && (A = x.mod.neg(), k && A.negative !== 0 && A.isub(b)), {
        div: x.div,
        mod: A
      }) : b.length > this.length || this.cmp(b) < 0 ? {
        div: new p(0),
        mod: this
      } : b.length === 1 ? E === "div" ? {
        div: this.divn(b.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(b.words[0]))
      } : {
        div: this.divn(b.words[0]),
        mod: new p(this.modn(b.words[0]))
      } : this._wordDiv(b, E);
    }, p.prototype.div = function(b) {
      return this.divmod(b, "div", !1).div;
    }, p.prototype.mod = function(b) {
      return this.divmod(b, "mod", !1).mod;
    }, p.prototype.umod = function(b) {
      return this.divmod(b, "mod", !0).mod;
    }, p.prototype.divRound = function(b) {
      var E = this.divmod(b);
      if (E.mod.isZero())
        return E.div;
      var k = E.div.negative !== 0 ? E.mod.isub(b) : E.mod, O = b.ushrn(1), A = b.andln(1), x = k.cmp(O);
      return x < 0 || A === 1 && x === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(b) {
      l(b <= 67108863);
      for (var E = (1 << 26) % b, k = 0, O = this.length - 1; O >= 0; O--)
        k = (E * k + (this.words[O] | 0)) % b;
      return k;
    }, p.prototype.idivn = function(b) {
      l(b <= 67108863);
      for (var E = 0, k = this.length - 1; k >= 0; k--) {
        var O = (this.words[k] | 0) + E * 67108864;
        this.words[k] = O / b | 0, E = O % b;
      }
      return this.strip();
    }, p.prototype.divn = function(b) {
      return this.clone().idivn(b);
    }, p.prototype.egcd = function(b) {
      l(b.negative === 0), l(!b.isZero());
      var E = this, k = b.clone();
      E.negative !== 0 ? E = E.umod(b) : E = E.clone();
      for (var O = new p(1), A = new p(0), x = new p(0), Y = new p(1), B = 0; E.isEven() && k.isEven(); )
        E.iushrn(1), k.iushrn(1), ++B;
      for (var T = k.clone(), D = E.clone(); !E.isZero(); ) {
        for (var te = 0, me = 1; !(E.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (O.isOdd() || A.isOdd()) && (O.iadd(T), A.isub(D)), O.iushrn(1), A.iushrn(1);
        for (var Ie = 0, $e = 1; !(k.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (k.iushrn(Ie); Ie-- > 0; )
            (x.isOdd() || Y.isOdd()) && (x.iadd(T), Y.isub(D)), x.iushrn(1), Y.iushrn(1);
        E.cmp(k) >= 0 ? (E.isub(k), O.isub(x), A.isub(Y)) : (k.isub(E), x.isub(O), Y.isub(A));
      }
      return {
        a: x,
        b: Y,
        gcd: k.iushln(B)
      };
    }, p.prototype._invmp = function(b) {
      l(b.negative === 0), l(!b.isZero());
      var E = this, k = b.clone();
      E.negative !== 0 ? E = E.umod(b) : E = E.clone();
      for (var O = new p(1), A = new p(0), x = k.clone(); E.cmpn(1) > 0 && k.cmpn(1) > 0; ) {
        for (var Y = 0, B = 1; !(E.words[0] & B) && Y < 26; ++Y, B <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            O.isOdd() && O.iadd(x), O.iushrn(1);
        for (var T = 0, D = 1; !(k.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (k.iushrn(T); T-- > 0; )
            A.isOdd() && A.iadd(x), A.iushrn(1);
        E.cmp(k) >= 0 ? (E.isub(k), O.isub(A)) : (k.isub(E), A.isub(O));
      }
      var te;
      return E.cmpn(1) === 0 ? te = O : te = A, te.cmpn(0) < 0 && te.iadd(b), te;
    }, p.prototype.gcd = function(b) {
      if (this.isZero())
        return b.abs();
      if (b.isZero())
        return this.abs();
      var E = this.clone(), k = b.clone();
      E.negative = 0, k.negative = 0;
      for (var O = 0; E.isEven() && k.isEven(); O++)
        E.iushrn(1), k.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; k.isEven(); )
          k.iushrn(1);
        var A = E.cmp(k);
        if (A < 0) {
          var x = E;
          E = k, k = x;
        } else if (A === 0 || k.cmpn(1) === 0)
          break;
        E.isub(k);
      } while (!0);
      return k.iushln(O);
    }, p.prototype.invm = function(b) {
      return this.egcd(b).a.umod(b);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(b) {
      return this.words[0] & b;
    }, p.prototype.bincn = function(b) {
      l(typeof b == "number");
      var E = b % 26, k = (b - E) / 26, O = 1 << E;
      if (this.length <= k)
        return this._expand(k + 1), this.words[k] |= O, this;
      for (var A = O, x = k; A !== 0 && x < this.length; x++) {
        var Y = this.words[x] | 0;
        Y += A, A = Y >>> 26, Y &= 67108863, this.words[x] = Y;
      }
      return A !== 0 && (this.words[x] = A, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(b) {
      var E = b < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var k;
      if (this.length > 1)
        k = 1;
      else {
        E && (b = -b), l(b <= 67108863, "Number is too big");
        var O = this.words[0] | 0;
        k = O === b ? 0 : O < b ? -1 : 1;
      }
      return this.negative !== 0 ? -k | 0 : k;
    }, p.prototype.cmp = function(b) {
      if (this.negative !== 0 && b.negative === 0)
        return -1;
      if (this.negative === 0 && b.negative !== 0)
        return 1;
      var E = this.ucmp(b);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(b) {
      if (this.length > b.length)
        return 1;
      if (this.length < b.length)
        return -1;
      for (var E = 0, k = this.length - 1; k >= 0; k--) {
        var O = this.words[k] | 0, A = b.words[k] | 0;
        if (O !== A) {
          O < A ? E = -1 : O > A && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(b) {
      return this.cmpn(b) === 1;
    }, p.prototype.gt = function(b) {
      return this.cmp(b) === 1;
    }, p.prototype.gten = function(b) {
      return this.cmpn(b) >= 0;
    }, p.prototype.gte = function(b) {
      return this.cmp(b) >= 0;
    }, p.prototype.ltn = function(b) {
      return this.cmpn(b) === -1;
    }, p.prototype.lt = function(b) {
      return this.cmp(b) === -1;
    }, p.prototype.lten = function(b) {
      return this.cmpn(b) <= 0;
    }, p.prototype.lte = function(b) {
      return this.cmp(b) <= 0;
    }, p.prototype.eqn = function(b) {
      return this.cmpn(b) === 0;
    }, p.prototype.eq = function(b) {
      return this.cmp(b) === 0;
    }, p.red = function(b) {
      return new q(b);
    }, p.prototype.toRed = function(b) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), b.convertTo(this)._forceRed(b);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(b) {
      return this.red = b, this;
    }, p.prototype.forceRed = function(b) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(b);
    }, p.prototype.redAdd = function(b) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, b);
    }, p.prototype.redIAdd = function(b) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, b);
    }, p.prototype.redSub = function(b) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, b);
    }, p.prototype.redISub = function(b) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, b);
    }, p.prototype.redShl = function(b) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, b);
    }, p.prototype.redMul = function(b) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.mul(this, b);
    }, p.prototype.redIMul = function(b) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.imul(this, b);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(b) {
      return l(this.red && !b.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, b);
    };
    var de = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function he(C, b) {
      this.name = C, this.p = new p(b, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    he.prototype._tmp = function() {
      var b = new p(null);
      return b.words = new Array(Math.ceil(this.n / 13)), b;
    }, he.prototype.ireduce = function(b) {
      var E = b, k;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), k = E.bitLength();
      while (k > this.n);
      var O = k < this.n ? -1 : E.ucmp(this.p);
      return O === 0 ? (E.words[0] = 0, E.length = 1) : O > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, he.prototype.split = function(b, E) {
      b.iushrn(this.n, 0, E);
    }, he.prototype.imulK = function(b) {
      return b.imul(this.k);
    };
    function pe() {
      he.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(pe, he), pe.prototype.split = function(b, E) {
      for (var k = 4194303, O = Math.min(b.length, 9), A = 0; A < O; A++)
        E.words[A] = b.words[A];
      if (E.length = O, b.length <= 9) {
        b.words[0] = 0, b.length = 1;
        return;
      }
      var x = b.words[9];
      for (E.words[E.length++] = x & k, A = 10; A < b.length; A++) {
        var Y = b.words[A] | 0;
        b.words[A - 10] = (Y & k) << 4 | x >>> 22, x = Y;
      }
      x >>>= 22, b.words[A - 10] = x, x === 0 && b.length > 10 ? b.length -= 10 : b.length -= 9;
    }, pe.prototype.imulK = function(b) {
      b.words[b.length] = 0, b.words[b.length + 1] = 0, b.length += 2;
      for (var E = 0, k = 0; k < b.length; k++) {
        var O = b.words[k] | 0;
        E += O * 977, b.words[k] = E & 67108863, E = O * 64 + (E / 67108864 | 0);
      }
      return b.words[b.length - 1] === 0 && (b.length--, b.words[b.length - 1] === 0 && b.length--), b;
    };
    function be() {
      he.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(be, he);
    function ke() {
      he.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(ke, he);
    function _e() {
      he.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(_e, he), _e.prototype.imulK = function(b) {
      for (var E = 0, k = 0; k < b.length; k++) {
        var O = (b.words[k] | 0) * 19 + E, A = O & 67108863;
        O >>>= 26, b.words[k] = A, E = O;
      }
      return E !== 0 && (b.words[b.length++] = E), b;
    }, p._prime = function(b) {
      if (de[b])
        return de[b];
      var E;
      if (b === "k256")
        E = new pe();
      else if (b === "p224")
        E = new be();
      else if (b === "p192")
        E = new ke();
      else if (b === "p25519")
        E = new _e();
      else
        throw new Error("Unknown prime " + b);
      return de[b] = E, E;
    };
    function q(C) {
      if (typeof C == "string") {
        var b = p._prime(C);
        this.m = b.p, this.prime = b;
      } else
        l(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    q.prototype._verify1 = function(b) {
      l(b.negative === 0, "red works only with positives"), l(b.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(b, E) {
      l((b.negative | E.negative) === 0, "red works only with positives"), l(
        b.red && b.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(b) {
      return this.prime ? this.prime.ireduce(b)._forceRed(this) : b.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(b) {
      return b.isZero() ? b.clone() : this.m.sub(b)._forceRed(this);
    }, q.prototype.add = function(b, E) {
      this._verify2(b, E);
      var k = b.add(E);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k._forceRed(this);
    }, q.prototype.iadd = function(b, E) {
      this._verify2(b, E);
      var k = b.iadd(E);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k;
    }, q.prototype.sub = function(b, E) {
      this._verify2(b, E);
      var k = b.sub(E);
      return k.cmpn(0) < 0 && k.iadd(this.m), k._forceRed(this);
    }, q.prototype.isub = function(b, E) {
      this._verify2(b, E);
      var k = b.isub(E);
      return k.cmpn(0) < 0 && k.iadd(this.m), k;
    }, q.prototype.shl = function(b, E) {
      return this._verify1(b), this.imod(b.ushln(E));
    }, q.prototype.imul = function(b, E) {
      return this._verify2(b, E), this.imod(b.imul(E));
    }, q.prototype.mul = function(b, E) {
      return this._verify2(b, E), this.imod(b.mul(E));
    }, q.prototype.isqr = function(b) {
      return this.imul(b, b.clone());
    }, q.prototype.sqr = function(b) {
      return this.mul(b, b);
    }, q.prototype.sqrt = function(b) {
      if (b.isZero())
        return b.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var k = this.m.add(new p(1)).iushrn(2);
        return this.pow(b, k);
      }
      for (var O = this.m.subn(1), A = 0; !O.isZero() && O.andln(1) === 0; )
        A++, O.iushrn(1);
      l(!O.isZero());
      var x = new p(1).toRed(this), Y = x.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var D = this.pow(T, O), te = this.pow(b, O.addn(1).iushrn(1)), me = this.pow(b, O), Ie = A; me.cmp(x) !== 0; ) {
        for (var $e = me, ye = 0; $e.cmp(x) !== 0; ye++)
          $e = $e.redSqr();
        l(ye < Ie);
        var fe = this.pow(D, new p(1).iushln(Ie - ye - 1));
        te = te.redMul(fe), D = fe.redSqr(), me = me.redMul(D), Ie = ye;
      }
      return te;
    }, q.prototype.invm = function(b) {
      var E = b._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(b, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return b.clone();
      var k = 4, O = new Array(1 << k);
      O[0] = new p(1).toRed(this), O[1] = b;
      for (var A = 2; A < O.length; A++)
        O[A] = this.mul(O[A - 1], b);
      var x = O[0], Y = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), A = E.length - 1; A >= 0; A--) {
        for (var D = E.words[A], te = T - 1; te >= 0; te--) {
          var me = D >> te & 1;
          if (x !== O[0] && (x = this.sqr(x)), me === 0 && Y === 0) {
            B = 0;
            continue;
          }
          Y <<= 1, Y |= me, B++, !(B !== k && (A !== 0 || te !== 0)) && (x = this.mul(x, O[Y]), B = 0, Y = 0);
        }
        T = 26;
      }
      return x;
    }, q.prototype.convertTo = function(b) {
      var E = b.umod(this.m);
      return E === b ? E.clone() : E;
    }, q.prototype.convertFrom = function(b) {
      var E = b.clone();
      return E.red = null, E;
    }, p.mont = function(b) {
      return new z(b);
    };
    function z(C) {
      q.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, q), z.prototype.convertTo = function(b) {
      return this.imod(b.ushln(this.shift));
    }, z.prototype.convertFrom = function(b) {
      var E = this.imod(b.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(b, E) {
      if (b.isZero() || E.isZero())
        return b.words[0] = 0, b.length = 1, b;
      var k = b.imul(E), O = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = k.isub(O).iushrn(this.shift), x = A;
      return A.cmp(this.m) >= 0 ? x = A.isub(this.m) : A.cmpn(0) < 0 && (x = A.iadd(this.m)), x._forceRed(this);
    }, z.prototype.mul = function(b, E) {
      if (b.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var k = b.mul(E), O = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = k.isub(O).iushrn(this.shift), x = A;
      return A.cmp(this.m) >= 0 ? x = A.isub(this.m) : A.cmpn(0) < 0 && (x = A.iadd(this.m)), x._forceRed(this);
    }, z.prototype.invm = function(b) {
      var E = this.imod(b._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$3);
var bnExports$3 = bn$3.exports, utils$u = {};
(function(a) {
  var u = a;
  function c(p, _) {
    if (Array.isArray(p))
      return p.slice();
    if (!p)
      return [];
    var I = [];
    if (typeof p != "string") {
      for (var P = 0; P < p.length; P++)
        I[P] = p[P] | 0;
      return I;
    }
    if (_ === "hex") {
      p = p.replace(/[^a-z0-9]+/ig, ""), p.length % 2 !== 0 && (p = "0" + p);
      for (var P = 0; P < p.length; P += 2)
        I.push(parseInt(p[P] + p[P + 1], 16));
    } else
      for (var P = 0; P < p.length; P++) {
        var $ = p.charCodeAt(P), F = $ >> 8, H = $ & 255;
        F ? I.push(F, H) : I.push(H);
      }
    return I;
  }
  u.toArray = c;
  function l(p) {
    return p.length === 1 ? "0" + p : p;
  }
  u.zero2 = l;
  function v(p) {
    for (var _ = "", I = 0; I < p.length; I++)
      _ += l(p[I].toString(16));
    return _;
  }
  u.toHex = v, u.encode = function(_, I) {
    return I === "hex" ? v(_) : _;
  };
})(utils$u);
(function(a) {
  var u = a, c = bnExports$3, l = minimalisticAssert, v = utils$u;
  u.assert = l, u.toArray = v.toArray, u.zero2 = v.zero2, u.toHex = v.toHex, u.encode = v.encode;
  function p(F, H, j) {
    var ee = new Array(Math.max(F.bitLength(), j) + 1);
    ee.fill(0);
    for (var X = 1 << H + 1, ie = F.clone(), Q = 0; Q < ee.length; Q++) {
      var ne, Z = ie.andln(X - 1);
      ie.isOdd() ? (Z > (X >> 1) - 1 ? ne = (X >> 1) - Z : ne = Z, ie.isubn(ne)) : ne = 0, ee[Q] = ne, ie.iushrn(1);
    }
    return ee;
  }
  u.getNAF = p;
  function _(F, H) {
    var j = [
      [],
      []
    ];
    F = F.clone(), H = H.clone();
    for (var ee = 0, X = 0, ie; F.cmpn(-ee) > 0 || H.cmpn(-X) > 0; ) {
      var Q = F.andln(3) + ee & 3, ne = H.andln(3) + X & 3;
      Q === 3 && (Q = -1), ne === 3 && (ne = -1);
      var Z;
      Q & 1 ? (ie = F.andln(7) + ee & 7, (ie === 3 || ie === 5) && ne === 2 ? Z = -Q : Z = Q) : Z = 0, j[0].push(Z);
      var de;
      ne & 1 ? (ie = H.andln(7) + X & 7, (ie === 3 || ie === 5) && Q === 2 ? de = -ne : de = ne) : de = 0, j[1].push(de), 2 * ee === Z + 1 && (ee = 1 - ee), 2 * X === de + 1 && (X = 1 - X), F.iushrn(1), H.iushrn(1);
    }
    return j;
  }
  u.getJSF = _;
  function I(F, H, j) {
    var ee = "_" + H;
    F.prototype[H] = function() {
      return this[ee] !== void 0 ? this[ee] : this[ee] = j.call(this);
    };
  }
  u.cachedProperty = I;
  function P(F) {
    return typeof F == "string" ? u.toArray(F, "hex") : F;
  }
  u.parseBytes = P;
  function $(F) {
    return new c(F, "hex", "le");
  }
  u.intFromLE = $;
})(utils$v);
var curve = {}, BN$9 = bnExports$3, utils$t = utils$v, getNAF = utils$t.getNAF, getJSF = utils$t.getJSF, assert$e = utils$t.assert;
function BaseCurve(a, u) {
  this.type = a, this.p = new BN$9(u.p, 16), this.red = u.prime ? BN$9.red(u.prime) : BN$9.mont(this.p), this.zero = new BN$9(0).toRed(this.red), this.one = new BN$9(1).toRed(this.red), this.two = new BN$9(2).toRed(this.red), this.n = u.n && new BN$9(u.n, 16), this.g = u.g && this.pointFromJSON(u.g, u.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var c = this.n && this.p.div(this.n);
  !c || c.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function a() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function a() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function a(u, c) {
  assert$e(u.precomputed);
  var l = u._getDoubles(), v = getNAF(c, 1, this._bitLength), p = (1 << l.step + 1) - (l.step % 2 === 0 ? 2 : 1);
  p /= 3;
  var _ = [], I, P;
  for (I = 0; I < v.length; I += l.step) {
    P = 0;
    for (var $ = I + l.step - 1; $ >= I; $--)
      P = (P << 1) + v[$];
    _.push(P);
  }
  for (var F = this.jpoint(null, null, null), H = this.jpoint(null, null, null), j = p; j > 0; j--) {
    for (I = 0; I < _.length; I++)
      P = _[I], P === j ? H = H.mixedAdd(l.points[I]) : P === -j && (H = H.mixedAdd(l.points[I].neg()));
    F = F.add(H);
  }
  return F.toP();
};
BaseCurve.prototype._wnafMul = function a(u, c) {
  var l = 4, v = u._getNAFPoints(l);
  l = v.wnd;
  for (var p = v.points, _ = getNAF(c, l, this._bitLength), I = this.jpoint(null, null, null), P = _.length - 1; P >= 0; P--) {
    for (var $ = 0; P >= 0 && _[P] === 0; P--)
      $++;
    if (P >= 0 && $++, I = I.dblp($), P < 0)
      break;
    var F = _[P];
    assert$e(F !== 0), u.type === "affine" ? F > 0 ? I = I.mixedAdd(p[F - 1 >> 1]) : I = I.mixedAdd(p[-F - 1 >> 1].neg()) : F > 0 ? I = I.add(p[F - 1 >> 1]) : I = I.add(p[-F - 1 >> 1].neg());
  }
  return u.type === "affine" ? I.toP() : I;
};
BaseCurve.prototype._wnafMulAdd = function a(u, c, l, v, p) {
  var _ = this._wnafT1, I = this._wnafT2, P = this._wnafT3, $ = 0, F, H, j;
  for (F = 0; F < v; F++) {
    j = c[F];
    var ee = j._getNAFPoints(u);
    _[F] = ee.wnd, I[F] = ee.points;
  }
  for (F = v - 1; F >= 1; F -= 2) {
    var X = F - 1, ie = F;
    if (_[X] !== 1 || _[ie] !== 1) {
      P[X] = getNAF(l[X], _[X], this._bitLength), P[ie] = getNAF(l[ie], _[ie], this._bitLength), $ = Math.max(P[X].length, $), $ = Math.max(P[ie].length, $);
      continue;
    }
    var Q = [
      c[X],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      c[ie]
      /* 7 */
    ];
    c[X].y.cmp(c[ie].y) === 0 ? (Q[1] = c[X].add(c[ie]), Q[2] = c[X].toJ().mixedAdd(c[ie].neg())) : c[X].y.cmp(c[ie].y.redNeg()) === 0 ? (Q[1] = c[X].toJ().mixedAdd(c[ie]), Q[2] = c[X].add(c[ie].neg())) : (Q[1] = c[X].toJ().mixedAdd(c[ie]), Q[2] = c[X].toJ().mixedAdd(c[ie].neg()));
    var ne = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], Z = getJSF(l[X], l[ie]);
    for ($ = Math.max(Z[0].length, $), P[X] = new Array($), P[ie] = new Array($), H = 0; H < $; H++) {
      var de = Z[0][H] | 0, he = Z[1][H] | 0;
      P[X][H] = ne[(de + 1) * 3 + (he + 1)], P[ie][H] = 0, I[X] = Q;
    }
  }
  var pe = this.jpoint(null, null, null), be = this._wnafT4;
  for (F = $; F >= 0; F--) {
    for (var ke = 0; F >= 0; ) {
      var _e = !0;
      for (H = 0; H < v; H++)
        be[H] = P[H][F] | 0, be[H] !== 0 && (_e = !1);
      if (!_e)
        break;
      ke++, F--;
    }
    if (F >= 0 && ke++, pe = pe.dblp(ke), F < 0)
      break;
    for (H = 0; H < v; H++) {
      var q = be[H];
      q !== 0 && (q > 0 ? j = I[H][q - 1 >> 1] : q < 0 && (j = I[H][-q - 1 >> 1].neg()), j.type === "affine" ? pe = pe.mixedAdd(j) : pe = pe.add(j));
    }
  }
  for (F = 0; F < v; F++)
    I[F] = null;
  return p ? pe : pe.toP();
};
function BasePoint(a, u) {
  this.curve = a, this.type = u, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function a() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function a() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function a(u, c) {
  u = utils$t.toArray(u, c);
  var l = this.p.byteLength();
  if ((u[0] === 4 || u[0] === 6 || u[0] === 7) && u.length - 1 === 2 * l) {
    u[0] === 6 ? assert$e(u[u.length - 1] % 2 === 0) : u[0] === 7 && assert$e(u[u.length - 1] % 2 === 1);
    var v = this.point(
      u.slice(1, 1 + l),
      u.slice(1 + l, 1 + 2 * l)
    );
    return v;
  } else if ((u[0] === 2 || u[0] === 3) && u.length - 1 === l)
    return this.pointFromX(u.slice(1, 1 + l), u[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function a(u) {
  return this.encode(u, !0);
};
BasePoint.prototype._encode = function a(u) {
  var c = this.curve.p.byteLength(), l = this.getX().toArray("be", c);
  return u ? [this.getY().isEven() ? 2 : 3].concat(l) : [4].concat(l, this.getY().toArray("be", c));
};
BasePoint.prototype.encode = function a(u, c) {
  return utils$t.encode(this._encode(c), u);
};
BasePoint.prototype.precompute = function a(u) {
  if (this.precomputed)
    return this;
  var c = {
    doubles: null,
    naf: null,
    beta: null
  };
  return c.naf = this._getNAFPoints(8), c.doubles = this._getDoubles(4, u), c.beta = this._getBeta(), this.precomputed = c, this;
};
BasePoint.prototype._hasDoubles = function a(u) {
  if (!this.precomputed)
    return !1;
  var c = this.precomputed.doubles;
  return c ? c.points.length >= Math.ceil((u.bitLength() + 1) / c.step) : !1;
};
BasePoint.prototype._getDoubles = function a(u, c) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var l = [this], v = this, p = 0; p < c; p += u) {
    for (var _ = 0; _ < u; _++)
      v = v.dbl();
    l.push(v);
  }
  return {
    step: u,
    points: l
  };
};
BasePoint.prototype._getNAFPoints = function a(u) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var c = [this], l = (1 << u) - 1, v = l === 1 ? null : this.dbl(), p = 1; p < l; p++)
    c[p] = c[p - 1].add(v);
  return {
    wnd: u,
    points: c
  };
};
BasePoint.prototype._getBeta = function a() {
  return null;
};
BasePoint.prototype.dblp = function a(u) {
  for (var c = this, l = 0; l < u; l++)
    c = c.dbl();
  return c;
};
var utils$s = utils$v, BN$8 = bnExports$3, inherits$9 = inherits_browserExports, Base$2 = base$1, assert$d = utils$s.assert;
function ShortCurve(a) {
  Base$2.call(this, "short", a), this.a = new BN$8(a.a, 16).toRed(this.red), this.b = new BN$8(a.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(a), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$9(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function a(u) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var c, l;
    if (u.beta)
      c = new BN$8(u.beta, 16).toRed(this.red);
    else {
      var v = this._getEndoRoots(this.p);
      c = v[0].cmp(v[1]) < 0 ? v[0] : v[1], c = c.toRed(this.red);
    }
    if (u.lambda)
      l = new BN$8(u.lambda, 16);
    else {
      var p = this._getEndoRoots(this.n);
      this.g.mul(p[0]).x.cmp(this.g.x.redMul(c)) === 0 ? l = p[0] : (l = p[1], assert$d(this.g.mul(l).x.cmp(this.g.x.redMul(c)) === 0));
    }
    var _;
    return u.basis ? _ = u.basis.map(function(I) {
      return {
        a: new BN$8(I.a, 16),
        b: new BN$8(I.b, 16)
      };
    }) : _ = this._getEndoBasis(l), {
      beta: c,
      lambda: l,
      basis: _
    };
  }
};
ShortCurve.prototype._getEndoRoots = function a(u) {
  var c = u === this.p ? this.red : BN$8.mont(u), l = new BN$8(2).toRed(c).redInvm(), v = l.redNeg(), p = new BN$8(3).toRed(c).redNeg().redSqrt().redMul(l), _ = v.redAdd(p).fromRed(), I = v.redSub(p).fromRed();
  return [_, I];
};
ShortCurve.prototype._getEndoBasis = function a(u) {
  for (var c = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), l = u, v = this.n.clone(), p = new BN$8(1), _ = new BN$8(0), I = new BN$8(0), P = new BN$8(1), $, F, H, j, ee, X, ie, Q = 0, ne, Z; l.cmpn(0) !== 0; ) {
    var de = v.div(l);
    ne = v.sub(de.mul(l)), Z = I.sub(de.mul(p));
    var he = P.sub(de.mul(_));
    if (!H && ne.cmp(c) < 0)
      $ = ie.neg(), F = p, H = ne.neg(), j = Z;
    else if (H && ++Q === 2)
      break;
    ie = ne, v = l, l = ne, I = p, p = Z, P = _, _ = he;
  }
  ee = ne.neg(), X = Z;
  var pe = H.sqr().add(j.sqr()), be = ee.sqr().add(X.sqr());
  return be.cmp(pe) >= 0 && (ee = $, X = F), H.negative && (H = H.neg(), j = j.neg()), ee.negative && (ee = ee.neg(), X = X.neg()), [
    { a: H, b: j },
    { a: ee, b: X }
  ];
};
ShortCurve.prototype._endoSplit = function a(u) {
  var c = this.endo.basis, l = c[0], v = c[1], p = v.b.mul(u).divRound(this.n), _ = l.b.neg().mul(u).divRound(this.n), I = p.mul(l.a), P = _.mul(v.a), $ = p.mul(l.b), F = _.mul(v.b), H = u.sub(I).sub(P), j = $.add(F).neg();
  return { k1: H, k2: j };
};
ShortCurve.prototype.pointFromX = function a(u, c) {
  u = new BN$8(u, 16), u.red || (u = u.toRed(this.red));
  var l = u.redSqr().redMul(u).redIAdd(u.redMul(this.a)).redIAdd(this.b), v = l.redSqrt();
  if (v.redSqr().redSub(l).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var p = v.fromRed().isOdd();
  return (c && !p || !c && p) && (v = v.redNeg()), this.point(u, v);
};
ShortCurve.prototype.validate = function a(u) {
  if (u.inf)
    return !0;
  var c = u.x, l = u.y, v = this.a.redMul(c), p = c.redSqr().redMul(c).redIAdd(v).redIAdd(this.b);
  return l.redSqr().redISub(p).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function a(u, c, l) {
  for (var v = this._endoWnafT1, p = this._endoWnafT2, _ = 0; _ < u.length; _++) {
    var I = this._endoSplit(c[_]), P = u[_], $ = P._getBeta();
    I.k1.negative && (I.k1.ineg(), P = P.neg(!0)), I.k2.negative && (I.k2.ineg(), $ = $.neg(!0)), v[_ * 2] = P, v[_ * 2 + 1] = $, p[_ * 2] = I.k1, p[_ * 2 + 1] = I.k2;
  }
  for (var F = this._wnafMulAdd(1, v, p, _ * 2, l), H = 0; H < _ * 2; H++)
    v[H] = null, p[H] = null;
  return F;
};
function Point$2(a, u, c, l) {
  Base$2.BasePoint.call(this, a, "affine"), u === null && c === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(u, 16), this.y = new BN$8(c, 16), l && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$9(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function a(u, c, l) {
  return new Point$2(this, u, c, l);
};
ShortCurve.prototype.pointFromJSON = function a(u, c) {
  return Point$2.fromJSON(this, u, c);
};
Point$2.prototype._getBeta = function a() {
  if (this.curve.endo) {
    var u = this.precomputed;
    if (u && u.beta)
      return u.beta;
    var c = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (u) {
      var l = this.curve, v = function(p) {
        return l.point(p.x.redMul(l.endo.beta), p.y);
      };
      u.beta = c, c.precomputed = {
        beta: null,
        naf: u.naf && {
          wnd: u.naf.wnd,
          points: u.naf.points.map(v)
        },
        doubles: u.doubles && {
          step: u.doubles.step,
          points: u.doubles.points.map(v)
        }
      };
    }
    return c;
  }
};
Point$2.prototype.toJSON = function a() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function a(u, c, l) {
  typeof c == "string" && (c = JSON.parse(c));
  var v = u.point(c[0], c[1], l);
  if (!c[2])
    return v;
  function p(I) {
    return u.point(I[0], I[1], l);
  }
  var _ = c[2];
  return v.precomputed = {
    beta: null,
    doubles: _.doubles && {
      step: _.doubles.step,
      points: [v].concat(_.doubles.points.map(p))
    },
    naf: _.naf && {
      wnd: _.naf.wnd,
      points: [v].concat(_.naf.points.map(p))
    }
  }, v;
};
Point$2.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function a() {
  return this.inf;
};
Point$2.prototype.add = function a(u) {
  if (this.inf)
    return u;
  if (u.inf)
    return this;
  if (this.eq(u))
    return this.dbl();
  if (this.neg().eq(u))
    return this.curve.point(null, null);
  if (this.x.cmp(u.x) === 0)
    return this.curve.point(null, null);
  var c = this.y.redSub(u.y);
  c.cmpn(0) !== 0 && (c = c.redMul(this.x.redSub(u.x).redInvm()));
  var l = c.redSqr().redISub(this.x).redISub(u.x), v = c.redMul(this.x.redSub(l)).redISub(this.y);
  return this.curve.point(l, v);
};
Point$2.prototype.dbl = function a() {
  if (this.inf)
    return this;
  var u = this.y.redAdd(this.y);
  if (u.cmpn(0) === 0)
    return this.curve.point(null, null);
  var c = this.curve.a, l = this.x.redSqr(), v = u.redInvm(), p = l.redAdd(l).redIAdd(l).redIAdd(c).redMul(v), _ = p.redSqr().redISub(this.x.redAdd(this.x)), I = p.redMul(this.x.redSub(_)).redISub(this.y);
  return this.curve.point(_, I);
};
Point$2.prototype.getX = function a() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function a() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function a(u) {
  return u = new BN$8(u, 16), this.isInfinity() ? this : this._hasDoubles(u) ? this.curve._fixedNafMul(this, u) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [u]) : this.curve._wnafMul(this, u);
};
Point$2.prototype.mulAdd = function a(u, c, l) {
  var v = [this, c], p = [u, l];
  return this.curve.endo ? this.curve._endoWnafMulAdd(v, p) : this.curve._wnafMulAdd(1, v, p, 2);
};
Point$2.prototype.jmulAdd = function a(u, c, l) {
  var v = [this, c], p = [u, l];
  return this.curve.endo ? this.curve._endoWnafMulAdd(v, p, !0) : this.curve._wnafMulAdd(1, v, p, 2, !0);
};
Point$2.prototype.eq = function a(u) {
  return this === u || this.inf === u.inf && (this.inf || this.x.cmp(u.x) === 0 && this.y.cmp(u.y) === 0);
};
Point$2.prototype.neg = function a(u) {
  if (this.inf)
    return this;
  var c = this.curve.point(this.x, this.y.redNeg());
  if (u && this.precomputed) {
    var l = this.precomputed, v = function(p) {
      return p.neg();
    };
    c.precomputed = {
      naf: l.naf && {
        wnd: l.naf.wnd,
        points: l.naf.points.map(v)
      },
      doubles: l.doubles && {
        step: l.doubles.step,
        points: l.doubles.points.map(v)
      }
    };
  }
  return c;
};
Point$2.prototype.toJ = function a() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var u = this.curve.jpoint(this.x, this.y, this.curve.one);
  return u;
};
function JPoint(a, u, c, l) {
  Base$2.BasePoint.call(this, a, "jacobian"), u === null && c === null && l === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(u, 16), this.y = new BN$8(c, 16), this.z = new BN$8(l, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$9(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function a(u, c, l) {
  return new JPoint(this, u, c, l);
};
JPoint.prototype.toP = function a() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var u = this.z.redInvm(), c = u.redSqr(), l = this.x.redMul(c), v = this.y.redMul(c).redMul(u);
  return this.curve.point(l, v);
};
JPoint.prototype.neg = function a() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function a(u) {
  if (this.isInfinity())
    return u;
  if (u.isInfinity())
    return this;
  var c = u.z.redSqr(), l = this.z.redSqr(), v = this.x.redMul(c), p = u.x.redMul(l), _ = this.y.redMul(c.redMul(u.z)), I = u.y.redMul(l.redMul(this.z)), P = v.redSub(p), $ = _.redSub(I);
  if (P.cmpn(0) === 0)
    return $.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var F = P.redSqr(), H = F.redMul(P), j = v.redMul(F), ee = $.redSqr().redIAdd(H).redISub(j).redISub(j), X = $.redMul(j.redISub(ee)).redISub(_.redMul(H)), ie = this.z.redMul(u.z).redMul(P);
  return this.curve.jpoint(ee, X, ie);
};
JPoint.prototype.mixedAdd = function a(u) {
  if (this.isInfinity())
    return u.toJ();
  if (u.isInfinity())
    return this;
  var c = this.z.redSqr(), l = this.x, v = u.x.redMul(c), p = this.y, _ = u.y.redMul(c).redMul(this.z), I = l.redSub(v), P = p.redSub(_);
  if (I.cmpn(0) === 0)
    return P.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var $ = I.redSqr(), F = $.redMul(I), H = l.redMul($), j = P.redSqr().redIAdd(F).redISub(H).redISub(H), ee = P.redMul(H.redISub(j)).redISub(p.redMul(F)), X = this.z.redMul(I);
  return this.curve.jpoint(j, ee, X);
};
JPoint.prototype.dblp = function a(u) {
  if (u === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!u)
    return this.dbl();
  var c;
  if (this.curve.zeroA || this.curve.threeA) {
    var l = this;
    for (c = 0; c < u; c++)
      l = l.dbl();
    return l;
  }
  var v = this.curve.a, p = this.curve.tinv, _ = this.x, I = this.y, P = this.z, $ = P.redSqr().redSqr(), F = I.redAdd(I);
  for (c = 0; c < u; c++) {
    var H = _.redSqr(), j = F.redSqr(), ee = j.redSqr(), X = H.redAdd(H).redIAdd(H).redIAdd(v.redMul($)), ie = _.redMul(j), Q = X.redSqr().redISub(ie.redAdd(ie)), ne = ie.redISub(Q), Z = X.redMul(ne);
    Z = Z.redIAdd(Z).redISub(ee);
    var de = F.redMul(P);
    c + 1 < u && ($ = $.redMul(ee)), _ = Q, P = de, F = Z;
  }
  return this.curve.jpoint(_, F.redMul(p), P);
};
JPoint.prototype.dbl = function a() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function a() {
  var u, c, l;
  if (this.zOne) {
    var v = this.x.redSqr(), p = this.y.redSqr(), _ = p.redSqr(), I = this.x.redAdd(p).redSqr().redISub(v).redISub(_);
    I = I.redIAdd(I);
    var P = v.redAdd(v).redIAdd(v), $ = P.redSqr().redISub(I).redISub(I), F = _.redIAdd(_);
    F = F.redIAdd(F), F = F.redIAdd(F), u = $, c = P.redMul(I.redISub($)).redISub(F), l = this.y.redAdd(this.y);
  } else {
    var H = this.x.redSqr(), j = this.y.redSqr(), ee = j.redSqr(), X = this.x.redAdd(j).redSqr().redISub(H).redISub(ee);
    X = X.redIAdd(X);
    var ie = H.redAdd(H).redIAdd(H), Q = ie.redSqr(), ne = ee.redIAdd(ee);
    ne = ne.redIAdd(ne), ne = ne.redIAdd(ne), u = Q.redISub(X).redISub(X), c = ie.redMul(X.redISub(u)).redISub(ne), l = this.y.redMul(this.z), l = l.redIAdd(l);
  }
  return this.curve.jpoint(u, c, l);
};
JPoint.prototype._threeDbl = function a() {
  var u, c, l;
  if (this.zOne) {
    var v = this.x.redSqr(), p = this.y.redSqr(), _ = p.redSqr(), I = this.x.redAdd(p).redSqr().redISub(v).redISub(_);
    I = I.redIAdd(I);
    var P = v.redAdd(v).redIAdd(v).redIAdd(this.curve.a), $ = P.redSqr().redISub(I).redISub(I);
    u = $;
    var F = _.redIAdd(_);
    F = F.redIAdd(F), F = F.redIAdd(F), c = P.redMul(I.redISub($)).redISub(F), l = this.y.redAdd(this.y);
  } else {
    var H = this.z.redSqr(), j = this.y.redSqr(), ee = this.x.redMul(j), X = this.x.redSub(H).redMul(this.x.redAdd(H));
    X = X.redAdd(X).redIAdd(X);
    var ie = ee.redIAdd(ee);
    ie = ie.redIAdd(ie);
    var Q = ie.redAdd(ie);
    u = X.redSqr().redISub(Q), l = this.y.redAdd(this.z).redSqr().redISub(j).redISub(H);
    var ne = j.redSqr();
    ne = ne.redIAdd(ne), ne = ne.redIAdd(ne), ne = ne.redIAdd(ne), c = X.redMul(ie.redISub(u)).redISub(ne);
  }
  return this.curve.jpoint(u, c, l);
};
JPoint.prototype._dbl = function a() {
  var u = this.curve.a, c = this.x, l = this.y, v = this.z, p = v.redSqr().redSqr(), _ = c.redSqr(), I = l.redSqr(), P = _.redAdd(_).redIAdd(_).redIAdd(u.redMul(p)), $ = c.redAdd(c);
  $ = $.redIAdd($);
  var F = $.redMul(I), H = P.redSqr().redISub(F.redAdd(F)), j = F.redISub(H), ee = I.redSqr();
  ee = ee.redIAdd(ee), ee = ee.redIAdd(ee), ee = ee.redIAdd(ee);
  var X = P.redMul(j).redISub(ee), ie = l.redAdd(l).redMul(v);
  return this.curve.jpoint(H, X, ie);
};
JPoint.prototype.trpl = function a() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var u = this.x.redSqr(), c = this.y.redSqr(), l = this.z.redSqr(), v = c.redSqr(), p = u.redAdd(u).redIAdd(u), _ = p.redSqr(), I = this.x.redAdd(c).redSqr().redISub(u).redISub(v);
  I = I.redIAdd(I), I = I.redAdd(I).redIAdd(I), I = I.redISub(_);
  var P = I.redSqr(), $ = v.redIAdd(v);
  $ = $.redIAdd($), $ = $.redIAdd($), $ = $.redIAdd($);
  var F = p.redIAdd(I).redSqr().redISub(_).redISub(P).redISub($), H = c.redMul(F);
  H = H.redIAdd(H), H = H.redIAdd(H);
  var j = this.x.redMul(P).redISub(H);
  j = j.redIAdd(j), j = j.redIAdd(j);
  var ee = this.y.redMul(F.redMul($.redISub(F)).redISub(I.redMul(P)));
  ee = ee.redIAdd(ee), ee = ee.redIAdd(ee), ee = ee.redIAdd(ee);
  var X = this.z.redAdd(I).redSqr().redISub(l).redISub(P);
  return this.curve.jpoint(j, ee, X);
};
JPoint.prototype.mul = function a(u, c) {
  return u = new BN$8(u, c), this.curve._wnafMul(this, u);
};
JPoint.prototype.eq = function a(u) {
  if (u.type === "affine")
    return this.eq(u.toJ());
  if (this === u)
    return !0;
  var c = this.z.redSqr(), l = u.z.redSqr();
  if (this.x.redMul(l).redISub(u.x.redMul(c)).cmpn(0) !== 0)
    return !1;
  var v = c.redMul(this.z), p = l.redMul(u.z);
  return this.y.redMul(p).redISub(u.y.redMul(v)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function a(u) {
  var c = this.z.redSqr(), l = u.toRed(this.curve.red).redMul(c);
  if (this.x.cmp(l) === 0)
    return !0;
  for (var v = u.clone(), p = this.curve.redN.redMul(c); ; ) {
    if (v.iadd(this.curve.n), v.cmp(this.curve.p) >= 0)
      return !1;
    if (l.redIAdd(p), this.x.cmp(l) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function a() {
  return this.z.cmpn(0) === 0;
};
var BN$7 = bnExports$3, inherits$8 = inherits_browserExports, Base$1 = base$1, utils$r = utils$v;
function MontCurve(a) {
  Base$1.call(this, "mont", a), this.a = new BN$7(a.a, 16).toRed(this.red), this.b = new BN$7(a.b, 16).toRed(this.red), this.i4 = new BN$7(4).toRed(this.red).redInvm(), this.two = new BN$7(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$8(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function a(u) {
  var c = u.normalize().x, l = c.redSqr(), v = l.redMul(c).redAdd(l.redMul(this.a)).redAdd(c), p = v.redSqrt();
  return p.redSqr().cmp(v) === 0;
};
function Point$1(a, u, c) {
  Base$1.BasePoint.call(this, a, "projective"), u === null && c === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$7(u, 16), this.z = new BN$7(c, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$8(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function a(u, c) {
  return this.point(utils$r.toArray(u, c), 1);
};
MontCurve.prototype.point = function a(u, c) {
  return new Point$1(this, u, c);
};
MontCurve.prototype.pointFromJSON = function a(u) {
  return Point$1.fromJSON(this, u);
};
Point$1.prototype.precompute = function a() {
};
Point$1.prototype._encode = function a() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function a(u, c) {
  return new Point$1(u, c[0], c[1] || u.one);
};
Point$1.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function a() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function a() {
  var u = this.x.redAdd(this.z), c = u.redSqr(), l = this.x.redSub(this.z), v = l.redSqr(), p = c.redSub(v), _ = c.redMul(v), I = p.redMul(v.redAdd(this.curve.a24.redMul(p)));
  return this.curve.point(_, I);
};
Point$1.prototype.add = function a() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function a(u, c) {
  var l = this.x.redAdd(this.z), v = this.x.redSub(this.z), p = u.x.redAdd(u.z), _ = u.x.redSub(u.z), I = _.redMul(l), P = p.redMul(v), $ = c.z.redMul(I.redAdd(P).redSqr()), F = c.x.redMul(I.redISub(P).redSqr());
  return this.curve.point($, F);
};
Point$1.prototype.mul = function a(u) {
  for (var c = u.clone(), l = this, v = this.curve.point(null, null), p = this, _ = []; c.cmpn(0) !== 0; c.iushrn(1))
    _.push(c.andln(1));
  for (var I = _.length - 1; I >= 0; I--)
    _[I] === 0 ? (l = l.diffAdd(v, p), v = v.dbl()) : (v = l.diffAdd(v, p), l = l.dbl());
  return v;
};
Point$1.prototype.mulAdd = function a() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function a() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function a(u) {
  return this.getX().cmp(u.getX()) === 0;
};
Point$1.prototype.normalize = function a() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$1.prototype.getX = function a() {
  return this.normalize(), this.x.fromRed();
};
var utils$q = utils$v, BN$6 = bnExports$3, inherits$7 = inherits_browserExports, Base = base$1, assert$c = utils$q.assert;
function EdwardsCurve(a) {
  this.twisted = (a.a | 0) !== 1, this.mOneA = this.twisted && (a.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", a), this.a = new BN$6(a.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$6(a.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$6(a.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (a.c | 0) === 1;
}
inherits$7(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function a(u) {
  return this.mOneA ? u.redNeg() : this.a.redMul(u);
};
EdwardsCurve.prototype._mulC = function a(u) {
  return this.oneC ? u : this.c.redMul(u);
};
EdwardsCurve.prototype.jpoint = function a(u, c, l, v) {
  return this.point(u, c, l, v);
};
EdwardsCurve.prototype.pointFromX = function a(u, c) {
  u = new BN$6(u, 16), u.red || (u = u.toRed(this.red));
  var l = u.redSqr(), v = this.c2.redSub(this.a.redMul(l)), p = this.one.redSub(this.c2.redMul(this.d).redMul(l)), _ = v.redMul(p.redInvm()), I = _.redSqrt();
  if (I.redSqr().redSub(_).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var P = I.fromRed().isOdd();
  return (c && !P || !c && P) && (I = I.redNeg()), this.point(u, I);
};
EdwardsCurve.prototype.pointFromY = function a(u, c) {
  u = new BN$6(u, 16), u.red || (u = u.toRed(this.red));
  var l = u.redSqr(), v = l.redSub(this.c2), p = l.redMul(this.d).redMul(this.c2).redSub(this.a), _ = v.redMul(p.redInvm());
  if (_.cmp(this.zero) === 0) {
    if (c)
      throw new Error("invalid point");
    return this.point(this.zero, u);
  }
  var I = _.redSqrt();
  if (I.redSqr().redSub(_).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return I.fromRed().isOdd() !== c && (I = I.redNeg()), this.point(I, u);
};
EdwardsCurve.prototype.validate = function a(u) {
  if (u.isInfinity())
    return !0;
  u.normalize();
  var c = u.x.redSqr(), l = u.y.redSqr(), v = c.redMul(this.a).redAdd(l), p = this.c2.redMul(this.one.redAdd(this.d.redMul(c).redMul(l)));
  return v.cmp(p) === 0;
};
function Point(a, u, c, l, v) {
  Base.BasePoint.call(this, a, "projective"), u === null && c === null && l === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$6(u, 16), this.y = new BN$6(c, 16), this.z = l ? new BN$6(l, 16) : this.curve.one, this.t = v && new BN$6(v, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$7(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function a(u) {
  return Point.fromJSON(this, u);
};
EdwardsCurve.prototype.point = function a(u, c, l, v) {
  return new Point(this, u, c, l, v);
};
Point.fromJSON = function a(u, c) {
  return new Point(u, c[0], c[1], c[2]);
};
Point.prototype.inspect = function a() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function a() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function a() {
  var u = this.x.redSqr(), c = this.y.redSqr(), l = this.z.redSqr();
  l = l.redIAdd(l);
  var v = this.curve._mulA(u), p = this.x.redAdd(this.y).redSqr().redISub(u).redISub(c), _ = v.redAdd(c), I = _.redSub(l), P = v.redSub(c), $ = p.redMul(I), F = _.redMul(P), H = p.redMul(P), j = I.redMul(_);
  return this.curve.point($, F, j, H);
};
Point.prototype._projDbl = function a() {
  var u = this.x.redAdd(this.y).redSqr(), c = this.x.redSqr(), l = this.y.redSqr(), v, p, _, I, P, $;
  if (this.curve.twisted) {
    I = this.curve._mulA(c);
    var F = I.redAdd(l);
    this.zOne ? (v = u.redSub(c).redSub(l).redMul(F.redSub(this.curve.two)), p = F.redMul(I.redSub(l)), _ = F.redSqr().redSub(F).redSub(F)) : (P = this.z.redSqr(), $ = F.redSub(P).redISub(P), v = u.redSub(c).redISub(l).redMul($), p = F.redMul(I.redSub(l)), _ = F.redMul($));
  } else
    I = c.redAdd(l), P = this.curve._mulC(this.z).redSqr(), $ = I.redSub(P).redSub(P), v = this.curve._mulC(u.redISub(I)).redMul($), p = this.curve._mulC(I).redMul(c.redISub(l)), _ = I.redMul($);
  return this.curve.point(v, p, _);
};
Point.prototype.dbl = function a() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point.prototype._extAdd = function a(u) {
  var c = this.y.redSub(this.x).redMul(u.y.redSub(u.x)), l = this.y.redAdd(this.x).redMul(u.y.redAdd(u.x)), v = this.t.redMul(this.curve.dd).redMul(u.t), p = this.z.redMul(u.z.redAdd(u.z)), _ = l.redSub(c), I = p.redSub(v), P = p.redAdd(v), $ = l.redAdd(c), F = _.redMul(I), H = P.redMul($), j = _.redMul($), ee = I.redMul(P);
  return this.curve.point(F, H, ee, j);
};
Point.prototype._projAdd = function a(u) {
  var c = this.z.redMul(u.z), l = c.redSqr(), v = this.x.redMul(u.x), p = this.y.redMul(u.y), _ = this.curve.d.redMul(v).redMul(p), I = l.redSub(_), P = l.redAdd(_), $ = this.x.redAdd(this.y).redMul(u.x.redAdd(u.y)).redISub(v).redISub(p), F = c.redMul(I).redMul($), H, j;
  return this.curve.twisted ? (H = c.redMul(P).redMul(p.redSub(this.curve._mulA(v))), j = I.redMul(P)) : (H = c.redMul(P).redMul(p.redSub(v)), j = this.curve._mulC(I).redMul(P)), this.curve.point(F, H, j);
};
Point.prototype.add = function a(u) {
  return this.isInfinity() ? u : u.isInfinity() ? this : this.curve.extended ? this._extAdd(u) : this._projAdd(u);
};
Point.prototype.mul = function a(u) {
  return this._hasDoubles(u) ? this.curve._fixedNafMul(this, u) : this.curve._wnafMul(this, u);
};
Point.prototype.mulAdd = function a(u, c, l) {
  return this.curve._wnafMulAdd(1, [this, c], [u, l], 2, !1);
};
Point.prototype.jmulAdd = function a(u, c, l) {
  return this.curve._wnafMulAdd(1, [this, c], [u, l], 2, !0);
};
Point.prototype.normalize = function a() {
  if (this.zOne)
    return this;
  var u = this.z.redInvm();
  return this.x = this.x.redMul(u), this.y = this.y.redMul(u), this.t && (this.t = this.t.redMul(u)), this.z = this.curve.one, this.zOne = !0, this;
};
Point.prototype.neg = function a() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function a() {
  return this.normalize(), this.x.fromRed();
};
Point.prototype.getY = function a() {
  return this.normalize(), this.y.fromRed();
};
Point.prototype.eq = function a(u) {
  return this === u || this.getX().cmp(u.getX()) === 0 && this.getY().cmp(u.getY()) === 0;
};
Point.prototype.eqXToP = function a(u) {
  var c = u.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(c) === 0)
    return !0;
  for (var l = u.clone(), v = this.curve.redN.redMul(this.z); ; ) {
    if (l.iadd(this.curve.n), l.cmp(this.curve.p) >= 0)
      return !1;
    if (c.redIAdd(v), this.x.cmp(c) === 0)
      return !0;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(a) {
  var u = a;
  u.base = base$1, u.short = short, u.mont = mont, u.edwards = edwards;
})(curve);
var curves$1 = {}, hash$2 = {}, utils$p = {}, assert$b = minimalisticAssert, inherits$6 = inherits_browserExports;
utils$p.inherits = inherits$6;
function isSurrogatePair(a, u) {
  return (a.charCodeAt(u) & 64512) !== 55296 || u < 0 || u + 1 >= a.length ? !1 : (a.charCodeAt(u + 1) & 64512) === 56320;
}
function toArray(a, u) {
  if (Array.isArray(a))
    return a.slice();
  if (!a)
    return [];
  var c = [];
  if (typeof a == "string")
    if (u) {
      if (u === "hex")
        for (a = a.replace(/[^a-z0-9]+/ig, ""), a.length % 2 !== 0 && (a = "0" + a), v = 0; v < a.length; v += 2)
          c.push(parseInt(a[v] + a[v + 1], 16));
    } else
      for (var l = 0, v = 0; v < a.length; v++) {
        var p = a.charCodeAt(v);
        p < 128 ? c[l++] = p : p < 2048 ? (c[l++] = p >> 6 | 192, c[l++] = p & 63 | 128) : isSurrogatePair(a, v) ? (p = 65536 + ((p & 1023) << 10) + (a.charCodeAt(++v) & 1023), c[l++] = p >> 18 | 240, c[l++] = p >> 12 & 63 | 128, c[l++] = p >> 6 & 63 | 128, c[l++] = p & 63 | 128) : (c[l++] = p >> 12 | 224, c[l++] = p >> 6 & 63 | 128, c[l++] = p & 63 | 128);
      }
  else
    for (v = 0; v < a.length; v++)
      c[v] = a[v] | 0;
  return c;
}
utils$p.toArray = toArray;
function toHex$1(a) {
  for (var u = "", c = 0; c < a.length; c++)
    u += zero2(a[c].toString(16));
  return u;
}
utils$p.toHex = toHex$1;
function htonl(a) {
  var u = a >>> 24 | a >>> 8 & 65280 | a << 8 & 16711680 | (a & 255) << 24;
  return u >>> 0;
}
utils$p.htonl = htonl;
function toHex32(a, u) {
  for (var c = "", l = 0; l < a.length; l++) {
    var v = a[l];
    u === "little" && (v = htonl(v)), c += zero8(v.toString(16));
  }
  return c;
}
utils$p.toHex32 = toHex32;
function zero2(a) {
  return a.length === 1 ? "0" + a : a;
}
utils$p.zero2 = zero2;
function zero8(a) {
  return a.length === 7 ? "0" + a : a.length === 6 ? "00" + a : a.length === 5 ? "000" + a : a.length === 4 ? "0000" + a : a.length === 3 ? "00000" + a : a.length === 2 ? "000000" + a : a.length === 1 ? "0000000" + a : a;
}
utils$p.zero8 = zero8;
function join32(a, u, c, l) {
  var v = c - u;
  assert$b(v % 4 === 0);
  for (var p = new Array(v / 4), _ = 0, I = u; _ < p.length; _++, I += 4) {
    var P;
    l === "big" ? P = a[I] << 24 | a[I + 1] << 16 | a[I + 2] << 8 | a[I + 3] : P = a[I + 3] << 24 | a[I + 2] << 16 | a[I + 1] << 8 | a[I], p[_] = P >>> 0;
  }
  return p;
}
utils$p.join32 = join32;
function split32(a, u) {
  for (var c = new Array(a.length * 4), l = 0, v = 0; l < a.length; l++, v += 4) {
    var p = a[l];
    u === "big" ? (c[v] = p >>> 24, c[v + 1] = p >>> 16 & 255, c[v + 2] = p >>> 8 & 255, c[v + 3] = p & 255) : (c[v + 3] = p >>> 24, c[v + 2] = p >>> 16 & 255, c[v + 1] = p >>> 8 & 255, c[v] = p & 255);
  }
  return c;
}
utils$p.split32 = split32;
function rotr32$1(a, u) {
  return a >>> u | a << 32 - u;
}
utils$p.rotr32 = rotr32$1;
function rotl32$2(a, u) {
  return a << u | a >>> 32 - u;
}
utils$p.rotl32 = rotl32$2;
function sum32$3(a, u) {
  return a + u >>> 0;
}
utils$p.sum32 = sum32$3;
function sum32_3$1(a, u, c) {
  return a + u + c >>> 0;
}
utils$p.sum32_3 = sum32_3$1;
function sum32_4$2(a, u, c, l) {
  return a + u + c + l >>> 0;
}
utils$p.sum32_4 = sum32_4$2;
function sum32_5$2(a, u, c, l, v) {
  return a + u + c + l + v >>> 0;
}
utils$p.sum32_5 = sum32_5$2;
function sum64$1(a, u, c, l) {
  var v = a[u], p = a[u + 1], _ = l + p >>> 0, I = (_ < l ? 1 : 0) + c + v;
  a[u] = I >>> 0, a[u + 1] = _;
}
utils$p.sum64 = sum64$1;
function sum64_hi$1(a, u, c, l) {
  var v = u + l >>> 0, p = (v < u ? 1 : 0) + a + c;
  return p >>> 0;
}
utils$p.sum64_hi = sum64_hi$1;
function sum64_lo$1(a, u, c, l) {
  var v = u + l;
  return v >>> 0;
}
utils$p.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(a, u, c, l, v, p, _, I) {
  var P = 0, $ = u;
  $ = $ + l >>> 0, P += $ < u ? 1 : 0, $ = $ + p >>> 0, P += $ < p ? 1 : 0, $ = $ + I >>> 0, P += $ < I ? 1 : 0;
  var F = a + c + v + _ + P;
  return F >>> 0;
}
utils$p.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(a, u, c, l, v, p, _, I) {
  var P = u + l + p + I;
  return P >>> 0;
}
utils$p.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(a, u, c, l, v, p, _, I, P, $) {
  var F = 0, H = u;
  H = H + l >>> 0, F += H < u ? 1 : 0, H = H + p >>> 0, F += H < p ? 1 : 0, H = H + I >>> 0, F += H < I ? 1 : 0, H = H + $ >>> 0, F += H < $ ? 1 : 0;
  var j = a + c + v + _ + P + F;
  return j >>> 0;
}
utils$p.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(a, u, c, l, v, p, _, I, P, $) {
  var F = u + l + p + I + $;
  return F >>> 0;
}
utils$p.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(a, u, c) {
  var l = u << 32 - c | a >>> c;
  return l >>> 0;
}
utils$p.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(a, u, c) {
  var l = a << 32 - c | u >>> c;
  return l >>> 0;
}
utils$p.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(a, u, c) {
  return a >>> c;
}
utils$p.shr64_hi = shr64_hi$1;
function shr64_lo$1(a, u, c) {
  var l = a << 32 - c | u >>> c;
  return l >>> 0;
}
utils$p.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$o = utils$p, assert$a = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function a(u, c) {
  if (u = utils$o.toArray(u, c), this.pending ? this.pending = this.pending.concat(u) : this.pending = u, this.pendingTotal += u.length, this.pending.length >= this._delta8) {
    u = this.pending;
    var l = u.length % this._delta8;
    this.pending = u.slice(u.length - l, u.length), this.pending.length === 0 && (this.pending = null), u = utils$o.join32(u, 0, u.length - l, this.endian);
    for (var v = 0; v < u.length; v += this._delta32)
      this._update(u, v, v + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function a(u) {
  return this.update(this._pad()), assert$a(this.pending === null), this._digest(u);
};
BlockHash$4.prototype._pad = function a() {
  var u = this.pendingTotal, c = this._delta8, l = c - (u + this.padLength) % c, v = new Array(l + this.padLength);
  v[0] = 128;
  for (var p = 1; p < l; p++)
    v[p] = 0;
  if (u <<= 3, this.endian === "big") {
    for (var _ = 8; _ < this.padLength; _++)
      v[p++] = 0;
    v[p++] = 0, v[p++] = 0, v[p++] = 0, v[p++] = 0, v[p++] = u >>> 24 & 255, v[p++] = u >>> 16 & 255, v[p++] = u >>> 8 & 255, v[p++] = u & 255;
  } else
    for (v[p++] = u & 255, v[p++] = u >>> 8 & 255, v[p++] = u >>> 16 & 255, v[p++] = u >>> 24 & 255, v[p++] = 0, v[p++] = 0, v[p++] = 0, v[p++] = 0, _ = 8; _ < this.padLength; _++)
      v[p++] = 0;
  return v;
};
var sha = {}, common$4 = {}, utils$n = utils$p, rotr32 = utils$n.rotr32;
function ft_1$1(a, u, c, l) {
  if (a === 0)
    return ch32$1(u, c, l);
  if (a === 1 || a === 3)
    return p32(u, c, l);
  if (a === 2)
    return maj32$1(u, c, l);
}
common$4.ft_1 = ft_1$1;
function ch32$1(a, u, c) {
  return a & u ^ ~a & c;
}
common$4.ch32 = ch32$1;
function maj32$1(a, u, c) {
  return a & u ^ a & c ^ u & c;
}
common$4.maj32 = maj32$1;
function p32(a, u, c) {
  return a ^ u ^ c;
}
common$4.p32 = p32;
function s0_256$1(a) {
  return rotr32(a, 2) ^ rotr32(a, 13) ^ rotr32(a, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(a) {
  return rotr32(a, 6) ^ rotr32(a, 11) ^ rotr32(a, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(a) {
  return rotr32(a, 7) ^ rotr32(a, 18) ^ a >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(a) {
  return rotr32(a, 17) ^ rotr32(a, 19) ^ a >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$m = utils$p, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$m.rotl32, sum32$2 = utils$m.sum32, sum32_5$1 = utils$m.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$m.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function a(u, c) {
  for (var l = this.W, v = 0; v < 16; v++)
    l[v] = u[c + v];
  for (; v < l.length; v++)
    l[v] = rotl32$1(l[v - 3] ^ l[v - 8] ^ l[v - 14] ^ l[v - 16], 1);
  var p = this.h[0], _ = this.h[1], I = this.h[2], P = this.h[3], $ = this.h[4];
  for (v = 0; v < l.length; v++) {
    var F = ~~(v / 20), H = sum32_5$1(rotl32$1(p, 5), ft_1(F, _, I, P), $, l[v], sha1_K[F]);
    $ = P, P = I, I = rotl32$1(_, 30), _ = p, p = H;
  }
  this.h[0] = sum32$2(this.h[0], p), this.h[1] = sum32$2(this.h[1], _), this.h[2] = sum32$2(this.h[2], I), this.h[3] = sum32$2(this.h[3], P), this.h[4] = sum32$2(this.h[4], $);
};
SHA1.prototype._digest = function a(u) {
  return u === "hex" ? utils$m.toHex32(this.h, "big") : utils$m.split32(this.h, "big");
};
var utils$l = utils$p, common$2 = common$5, shaCommon = common$4, assert$9 = minimalisticAssert, sum32$1 = utils$l.sum32, sum32_4$1 = utils$l.sum32_4, sum32_5 = utils$l.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$l.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function a(u, c) {
  for (var l = this.W, v = 0; v < 16; v++)
    l[v] = u[c + v];
  for (; v < l.length; v++)
    l[v] = sum32_4$1(g1_256(l[v - 2]), l[v - 7], g0_256(l[v - 15]), l[v - 16]);
  var p = this.h[0], _ = this.h[1], I = this.h[2], P = this.h[3], $ = this.h[4], F = this.h[5], H = this.h[6], j = this.h[7];
  for (assert$9(this.k.length === l.length), v = 0; v < l.length; v++) {
    var ee = sum32_5(j, s1_256($), ch32($, F, H), this.k[v], l[v]), X = sum32$1(s0_256(p), maj32(p, _, I));
    j = H, H = F, F = $, $ = sum32$1(P, ee), P = I, I = _, _ = p, p = sum32$1(ee, X);
  }
  this.h[0] = sum32$1(this.h[0], p), this.h[1] = sum32$1(this.h[1], _), this.h[2] = sum32$1(this.h[2], I), this.h[3] = sum32$1(this.h[3], P), this.h[4] = sum32$1(this.h[4], $), this.h[5] = sum32$1(this.h[5], F), this.h[6] = sum32$1(this.h[6], H), this.h[7] = sum32$1(this.h[7], j);
};
SHA256$1.prototype._digest = function a(u) {
  return u === "hex" ? utils$l.toHex32(this.h, "big") : utils$l.split32(this.h, "big");
};
var utils$k = utils$p, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$k.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function a(u) {
  return u === "hex" ? utils$k.toHex32(this.h.slice(0, 7), "big") : utils$k.split32(this.h.slice(0, 7), "big");
};
var utils$j = utils$p, common$1 = common$5, assert$8 = minimalisticAssert, rotr64_hi = utils$j.rotr64_hi, rotr64_lo = utils$j.rotr64_lo, shr64_hi = utils$j.shr64_hi, shr64_lo = utils$j.shr64_lo, sum64 = utils$j.sum64, sum64_hi = utils$j.sum64_hi, sum64_lo = utils$j.sum64_lo, sum64_4_hi = utils$j.sum64_4_hi, sum64_4_lo = utils$j.sum64_4_lo, sum64_5_hi = utils$j.sum64_5_hi, sum64_5_lo = utils$j.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$j.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function a(u, c) {
  for (var l = this.W, v = 0; v < 32; v++)
    l[v] = u[c + v];
  for (; v < l.length; v += 2) {
    var p = g1_512_hi(l[v - 4], l[v - 3]), _ = g1_512_lo(l[v - 4], l[v - 3]), I = l[v - 14], P = l[v - 13], $ = g0_512_hi(l[v - 30], l[v - 29]), F = g0_512_lo(l[v - 30], l[v - 29]), H = l[v - 32], j = l[v - 31];
    l[v] = sum64_4_hi(
      p,
      _,
      I,
      P,
      $,
      F,
      H,
      j
    ), l[v + 1] = sum64_4_lo(
      p,
      _,
      I,
      P,
      $,
      F,
      H,
      j
    );
  }
};
SHA512$1.prototype._update = function a(u, c) {
  this._prepareBlock(u, c);
  var l = this.W, v = this.h[0], p = this.h[1], _ = this.h[2], I = this.h[3], P = this.h[4], $ = this.h[5], F = this.h[6], H = this.h[7], j = this.h[8], ee = this.h[9], X = this.h[10], ie = this.h[11], Q = this.h[12], ne = this.h[13], Z = this.h[14], de = this.h[15];
  assert$8(this.k.length === l.length);
  for (var he = 0; he < l.length; he += 2) {
    var pe = Z, be = de, ke = s1_512_hi(j, ee), _e = s1_512_lo(j, ee), q = ch64_hi(j, ee, X, ie, Q), z = ch64_lo(j, ee, X, ie, Q, ne), C = this.k[he], b = this.k[he + 1], E = l[he], k = l[he + 1], O = sum64_5_hi(
      pe,
      be,
      ke,
      _e,
      q,
      z,
      C,
      b,
      E,
      k
    ), A = sum64_5_lo(
      pe,
      be,
      ke,
      _e,
      q,
      z,
      C,
      b,
      E,
      k
    );
    pe = s0_512_hi(v, p), be = s0_512_lo(v, p), ke = maj64_hi(v, p, _, I, P), _e = maj64_lo(v, p, _, I, P, $);
    var x = sum64_hi(pe, be, ke, _e), Y = sum64_lo(pe, be, ke, _e);
    Z = Q, de = ne, Q = X, ne = ie, X = j, ie = ee, j = sum64_hi(F, H, O, A), ee = sum64_lo(H, H, O, A), F = P, H = $, P = _, $ = I, _ = v, I = p, v = sum64_hi(O, A, x, Y), p = sum64_lo(O, A, x, Y);
  }
  sum64(this.h, 0, v, p), sum64(this.h, 2, _, I), sum64(this.h, 4, P, $), sum64(this.h, 6, F, H), sum64(this.h, 8, j, ee), sum64(this.h, 10, X, ie), sum64(this.h, 12, Q, ne), sum64(this.h, 14, Z, de);
};
SHA512$1.prototype._digest = function a(u) {
  return u === "hex" ? utils$j.toHex32(this.h, "big") : utils$j.split32(this.h, "big");
};
function ch64_hi(a, u, c, l, v) {
  var p = a & c ^ ~a & v;
  return p < 0 && (p += 4294967296), p;
}
function ch64_lo(a, u, c, l, v, p) {
  var _ = u & l ^ ~u & p;
  return _ < 0 && (_ += 4294967296), _;
}
function maj64_hi(a, u, c, l, v) {
  var p = a & c ^ a & v ^ c & v;
  return p < 0 && (p += 4294967296), p;
}
function maj64_lo(a, u, c, l, v, p) {
  var _ = u & l ^ u & p ^ l & p;
  return _ < 0 && (_ += 4294967296), _;
}
function s0_512_hi(a, u) {
  var c = rotr64_hi(a, u, 28), l = rotr64_hi(u, a, 2), v = rotr64_hi(u, a, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function s0_512_lo(a, u) {
  var c = rotr64_lo(a, u, 28), l = rotr64_lo(u, a, 2), v = rotr64_lo(u, a, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function s1_512_hi(a, u) {
  var c = rotr64_hi(a, u, 14), l = rotr64_hi(a, u, 18), v = rotr64_hi(u, a, 9), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function s1_512_lo(a, u) {
  var c = rotr64_lo(a, u, 14), l = rotr64_lo(a, u, 18), v = rotr64_lo(u, a, 9), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g0_512_hi(a, u) {
  var c = rotr64_hi(a, u, 1), l = rotr64_hi(a, u, 8), v = shr64_hi(a, u, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g0_512_lo(a, u) {
  var c = rotr64_lo(a, u, 1), l = rotr64_lo(a, u, 8), v = shr64_lo(a, u, 7), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g1_512_hi(a, u) {
  var c = rotr64_hi(a, u, 19), l = rotr64_hi(u, a, 29), v = shr64_hi(a, u, 6), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
function g1_512_lo(a, u) {
  var c = rotr64_lo(a, u, 19), l = rotr64_lo(u, a, 29), v = shr64_lo(a, u, 6), p = c ^ l ^ v;
  return p < 0 && (p += 4294967296), p;
}
var utils$i = utils$p, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$i.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function a(u) {
  return u === "hex" ? utils$i.toHex32(this.h.slice(0, 12), "big") : utils$i.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$h = utils$p, common = common$5, rotl32 = utils$h.rotl32, sum32 = utils$h.sum32, sum32_3 = utils$h.sum32_3, sum32_4 = utils$h.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$h.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function a(u, c) {
  for (var l = this.h[0], v = this.h[1], p = this.h[2], _ = this.h[3], I = this.h[4], P = l, $ = v, F = p, H = _, j = I, ee = 0; ee < 80; ee++) {
    var X = sum32(
      rotl32(
        sum32_4(l, f(ee, v, p, _), u[r[ee] + c], K(ee)),
        s$1[ee]
      ),
      I
    );
    l = I, I = _, _ = rotl32(p, 10), p = v, v = X, X = sum32(
      rotl32(
        sum32_4(P, f(79 - ee, $, F, H), u[rh[ee] + c], Kh(ee)),
        sh[ee]
      ),
      j
    ), P = j, j = H, H = rotl32(F, 10), F = $, $ = X;
  }
  X = sum32_3(this.h[1], p, H), this.h[1] = sum32_3(this.h[2], _, j), this.h[2] = sum32_3(this.h[3], I, P), this.h[3] = sum32_3(this.h[4], l, $), this.h[4] = sum32_3(this.h[0], v, F), this.h[0] = X;
};
RIPEMD160.prototype._digest = function a(u) {
  return u === "hex" ? utils$h.toHex32(this.h, "little") : utils$h.split32(this.h, "little");
};
function f(a, u, c, l) {
  return a <= 15 ? u ^ c ^ l : a <= 31 ? u & c | ~u & l : a <= 47 ? (u | ~c) ^ l : a <= 63 ? u & l | c & ~l : u ^ (c | ~l);
}
function K(a) {
  return a <= 15 ? 0 : a <= 31 ? 1518500249 : a <= 47 ? 1859775393 : a <= 63 ? 2400959708 : 2840853838;
}
function Kh(a) {
  return a <= 15 ? 1352829926 : a <= 31 ? 1548603684 : a <= 47 ? 1836072691 : a <= 63 ? 2053994217 : 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$g = utils$p, assert$7 = minimalisticAssert;
function Hmac(a, u, c) {
  if (!(this instanceof Hmac))
    return new Hmac(a, u, c);
  this.Hash = a, this.blockSize = a.blockSize / 8, this.outSize = a.outSize / 8, this.inner = null, this.outer = null, this._init(utils$g.toArray(u, c));
}
var hmac = Hmac;
Hmac.prototype._init = function a(u) {
  u.length > this.blockSize && (u = new this.Hash().update(u).digest()), assert$7(u.length <= this.blockSize);
  for (var c = u.length; c < this.blockSize; c++)
    u.push(0);
  for (c = 0; c < u.length; c++)
    u[c] ^= 54;
  for (this.inner = new this.Hash().update(u), c = 0; c < u.length; c++)
    u[c] ^= 106;
  this.outer = new this.Hash().update(u);
};
Hmac.prototype.update = function a(u, c) {
  return this.inner.update(u, c), this;
};
Hmac.prototype.digest = function a(u) {
  return this.outer.update(this.inner.digest()), this.outer.digest(u);
};
(function(a) {
  var u = a;
  u.utils = utils$p, u.common = common$5, u.sha = sha, u.ripemd = ripemd, u.hmac = hmac, u.sha1 = u.sha.sha1, u.sha256 = u.sha.sha256, u.sha224 = u.sha.sha224, u.sha384 = u.sha.sha384, u.sha512 = u.sha.sha512, u.ripemd160 = u.ripemd.ripemd160;
})(hash$2);
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(a) {
  var u = a, c = hash$2, l = curve, v = utils$v, p = v.assert;
  function _($) {
    $.type === "short" ? this.curve = new l.short($) : $.type === "edwards" ? this.curve = new l.edwards($) : this.curve = new l.mont($), this.g = this.curve.g, this.n = this.curve.n, this.hash = $.hash, p(this.g.validate(), "Invalid curve"), p(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  u.PresetCurve = _;
  function I($, F) {
    Object.defineProperty(u, $, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var H = new _(F);
        return Object.defineProperty(u, $, {
          configurable: !0,
          enumerable: !0,
          value: H
        }), H;
      }
    });
  }
  I("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: c.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), I("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: c.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), I("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: c.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), I("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: c.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), I("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: c.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), I("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: c.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), I("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: c.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var P;
  try {
    P = requireSecp256k1();
  } catch {
    P = void 0;
  }
  I("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: c.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      P
    ]
  });
})(curves$1);
var hash$1 = hash$2, utils$f = utils$u, assert$6 = minimalisticAssert;
function HmacDRBG(a) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(a);
  this.hash = a.hash, this.predResist = !!a.predResist, this.outLen = this.hash.outSize, this.minEntropy = a.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var u = utils$f.toArray(a.entropy, a.entropyEnc || "hex"), c = utils$f.toArray(a.nonce, a.nonceEnc || "hex"), l = utils$f.toArray(a.pers, a.persEnc || "hex");
  assert$6(
    u.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(u, c, l);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function a(u, c, l) {
  var v = u.concat(c).concat(l);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var p = 0; p < this.V.length; p++)
    this.K[p] = 0, this.V[p] = 1;
  this._update(v), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function a() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function a(u) {
  var c = this._hmac().update(this.V).update([0]);
  u && (c = c.update(u)), this.K = c.digest(), this.V = this._hmac().update(this.V).digest(), u && (this.K = this._hmac().update(this.V).update([1]).update(u).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function a(u, c, l, v) {
  typeof c != "string" && (v = l, l = c, c = null), u = utils$f.toArray(u, c), l = utils$f.toArray(l, v), assert$6(
    u.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(u.concat(l || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function a(u, c, l, v) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof c != "string" && (v = l, l = c, c = null), l && (l = utils$f.toArray(l, v || "hex"), this._update(l));
  for (var p = []; p.length < u; )
    this.V = this._hmac().update(this.V).digest(), p = p.concat(this.V);
  var _ = p.slice(0, u);
  return this._update(l), this._reseed++, utils$f.encode(_, c);
};
var BN$5 = bnExports$3, utils$e = utils$v, assert$5 = utils$e.assert;
function KeyPair$2(a, u) {
  this.ec = a, this.priv = null, this.pub = null, u.priv && this._importPrivate(u.priv, u.privEnc), u.pub && this._importPublic(u.pub, u.pubEnc);
}
var key$2 = KeyPair$2;
KeyPair$2.fromPublic = function a(u, c, l) {
  return c instanceof KeyPair$2 ? c : new KeyPair$2(u, {
    pub: c,
    pubEnc: l
  });
};
KeyPair$2.fromPrivate = function a(u, c, l) {
  return c instanceof KeyPair$2 ? c : new KeyPair$2(u, {
    priv: c,
    privEnc: l
  });
};
KeyPair$2.prototype.validate = function a() {
  var u = this.getPublic();
  return u.isInfinity() ? { result: !1, reason: "Invalid public key" } : u.validate() ? u.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$2.prototype.getPublic = function a(u, c) {
  return typeof u == "string" && (c = u, u = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), c ? this.pub.encode(c, u) : this.pub;
};
KeyPair$2.prototype.getPrivate = function a(u) {
  return u === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$2.prototype._importPrivate = function a(u, c) {
  this.priv = new BN$5(u, c || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function a(u, c) {
  if (u.x || u.y) {
    this.ec.curve.type === "mont" ? assert$5(u.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$5(u.x && u.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(u.x, u.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(u, c);
};
KeyPair$2.prototype.derive = function a(u) {
  return u.validate() || assert$5(u.validate(), "public point not validated"), u.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function a(u, c, l) {
  return this.ec.sign(u, this, c, l);
};
KeyPair$2.prototype.verify = function a(u, c) {
  return this.ec.verify(u, c, this);
};
KeyPair$2.prototype.inspect = function a() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$4 = bnExports$3, utils$d = utils$v, assert$4 = utils$d.assert;
function Signature$2(a, u) {
  if (a instanceof Signature$2)
    return a;
  this._importDER(a, u) || (assert$4(a.r && a.s, "Signature without r or s"), this.r = new BN$4(a.r, 16), this.s = new BN$4(a.s, 16), a.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = a.recoveryParam);
}
var signature$1 = Signature$2;
function Position() {
  this.place = 0;
}
function getLength(a, u) {
  var c = a[u.place++];
  if (!(c & 128))
    return c;
  var l = c & 15;
  if (l === 0 || l > 4)
    return !1;
  for (var v = 0, p = 0, _ = u.place; p < l; p++, _++)
    v <<= 8, v |= a[_], v >>>= 0;
  return v <= 127 ? !1 : (u.place = _, v);
}
function rmPadding(a) {
  for (var u = 0, c = a.length - 1; !a[u] && !(a[u + 1] & 128) && u < c; )
    u++;
  return u === 0 ? a : a.slice(u);
}
Signature$2.prototype._importDER = function a(u, c) {
  u = utils$d.toArray(u, c);
  var l = new Position();
  if (u[l.place++] !== 48)
    return !1;
  var v = getLength(u, l);
  if (v === !1 || v + l.place !== u.length || u[l.place++] !== 2)
    return !1;
  var p = getLength(u, l);
  if (p === !1)
    return !1;
  var _ = u.slice(l.place, p + l.place);
  if (l.place += p, u[l.place++] !== 2)
    return !1;
  var I = getLength(u, l);
  if (I === !1 || u.length !== I + l.place)
    return !1;
  var P = u.slice(l.place, I + l.place);
  if (_[0] === 0)
    if (_[1] & 128)
      _ = _.slice(1);
    else
      return !1;
  if (P[0] === 0)
    if (P[1] & 128)
      P = P.slice(1);
    else
      return !1;
  return this.r = new BN$4(_), this.s = new BN$4(P), this.recoveryParam = null, !0;
};
function constructLength(a, u) {
  if (u < 128) {
    a.push(u);
    return;
  }
  var c = 1 + (Math.log(u) / Math.LN2 >>> 3);
  for (a.push(c | 128); --c; )
    a.push(u >>> (c << 3) & 255);
  a.push(u);
}
Signature$2.prototype.toDER = function a(u) {
  var c = this.r.toArray(), l = this.s.toArray();
  for (c[0] & 128 && (c = [0].concat(c)), l[0] & 128 && (l = [0].concat(l)), c = rmPadding(c), l = rmPadding(l); !l[0] && !(l[1] & 128); )
    l = l.slice(1);
  var v = [2];
  constructLength(v, c.length), v = v.concat(c), v.push(2), constructLength(v, l.length);
  var p = v.concat(l), _ = [48];
  return constructLength(_, p.length), _ = _.concat(p), utils$d.encode(_, u);
};
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc)
    return ec;
  hasRequiredEc = 1;
  var a = bnExports$3, u = hmacDrbg, c = utils$v, l = curves$1, v = requireBrorand(), p = c.assert, _ = key$2, I = signature$1;
  function P($) {
    if (!(this instanceof P))
      return new P($);
    typeof $ == "string" && (p(
      Object.prototype.hasOwnProperty.call(l, $),
      "Unknown curve " + $
    ), $ = l[$]), $ instanceof l.PresetCurve && ($ = { curve: $ }), this.curve = $.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = $.curve.g, this.g.precompute($.curve.n.bitLength() + 1), this.hash = $.hash || $.curve.hash;
  }
  return ec = P, P.prototype.keyPair = function(F) {
    return new _(this, F);
  }, P.prototype.keyFromPrivate = function(F, H) {
    return _.fromPrivate(this, F, H);
  }, P.prototype.keyFromPublic = function(F, H) {
    return _.fromPublic(this, F, H);
  }, P.prototype.genKeyPair = function(F) {
    F || (F = {});
    for (var H = new u({
      hash: this.hash,
      pers: F.pers,
      persEnc: F.persEnc || "utf8",
      entropy: F.entropy || v(this.hash.hmacStrength),
      entropyEnc: F.entropy && F.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), j = this.n.byteLength(), ee = this.n.sub(new a(2)); ; ) {
      var X = new a(H.generate(j));
      if (!(X.cmp(ee) > 0))
        return X.iaddn(1), this.keyFromPrivate(X);
    }
  }, P.prototype._truncateToN = function(F, H) {
    var j = F.byteLength() * 8 - this.n.bitLength();
    return j > 0 && (F = F.ushrn(j)), !H && F.cmp(this.n) >= 0 ? F.sub(this.n) : F;
  }, P.prototype.sign = function(F, H, j, ee) {
    typeof j == "object" && (ee = j, j = null), ee || (ee = {}), H = this.keyFromPrivate(H, j), F = this._truncateToN(new a(F, 16));
    for (var X = this.n.byteLength(), ie = H.getPrivate().toArray("be", X), Q = F.toArray("be", X), ne = new u({
      hash: this.hash,
      entropy: ie,
      nonce: Q,
      pers: ee.pers,
      persEnc: ee.persEnc || "utf8"
    }), Z = this.n.sub(new a(1)), de = 0; ; de++) {
      var he = ee.k ? ee.k(de) : new a(ne.generate(this.n.byteLength()));
      if (he = this._truncateToN(he, !0), !(he.cmpn(1) <= 0 || he.cmp(Z) >= 0)) {
        var pe = this.g.mul(he);
        if (!pe.isInfinity()) {
          var be = pe.getX(), ke = be.umod(this.n);
          if (ke.cmpn(0) !== 0) {
            var _e = he.invm(this.n).mul(ke.mul(H.getPrivate()).iadd(F));
            if (_e = _e.umod(this.n), _e.cmpn(0) !== 0) {
              var q = (pe.getY().isOdd() ? 1 : 0) | (be.cmp(ke) !== 0 ? 2 : 0);
              return ee.canonical && _e.cmp(this.nh) > 0 && (_e = this.n.sub(_e), q ^= 1), new I({ r: ke, s: _e, recoveryParam: q });
            }
          }
        }
      }
    }
  }, P.prototype.verify = function(F, H, j, ee) {
    F = this._truncateToN(new a(F, 16)), j = this.keyFromPublic(j, ee), H = new I(H, "hex");
    var X = H.r, ie = H.s;
    if (X.cmpn(1) < 0 || X.cmp(this.n) >= 0 || ie.cmpn(1) < 0 || ie.cmp(this.n) >= 0)
      return !1;
    var Q = ie.invm(this.n), ne = Q.mul(F).umod(this.n), Z = Q.mul(X).umod(this.n), de;
    return this.curve._maxwellTrick ? (de = this.g.jmulAdd(ne, j.getPublic(), Z), de.isInfinity() ? !1 : de.eqXToP(X)) : (de = this.g.mulAdd(ne, j.getPublic(), Z), de.isInfinity() ? !1 : de.getX().umod(this.n).cmp(X) === 0);
  }, P.prototype.recoverPubKey = function($, F, H, j) {
    p((3 & H) === H, "The recovery param is more than two bits"), F = new I(F, j);
    var ee = this.n, X = new a($), ie = F.r, Q = F.s, ne = H & 1, Z = H >> 1;
    if (ie.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Z)
      throw new Error("Unable to find sencond key candinate");
    Z ? ie = this.curve.pointFromX(ie.add(this.curve.n), ne) : ie = this.curve.pointFromX(ie, ne);
    var de = F.r.invm(ee), he = ee.sub(X).mul(de).umod(ee), pe = Q.mul(de).umod(ee);
    return this.g.mulAdd(he, ie, pe);
  }, P.prototype.getKeyRecoveryParam = function($, F, H, j) {
    if (F = new I(F, j), F.recoveryParam !== null)
      return F.recoveryParam;
    for (var ee = 0; ee < 4; ee++) {
      var X;
      try {
        X = this.recoverPubKey($, F, ee);
      } catch {
        continue;
      }
      if (X.eq(H))
        return ee;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var utils$c = utils$v, assert$3 = utils$c.assert, parseBytes$2 = utils$c.parseBytes, cachedProperty$1 = utils$c.cachedProperty;
function KeyPair$1(a, u) {
  this.eddsa = a, this._secret = parseBytes$2(u.secret), a.isPoint(u.pub) ? this._pub = u.pub : this._pubBytes = parseBytes$2(u.pub);
}
KeyPair$1.fromPublic = function a(u, c) {
  return c instanceof KeyPair$1 ? c : new KeyPair$1(u, { pub: c });
};
KeyPair$1.fromSecret = function a(u, c) {
  return c instanceof KeyPair$1 ? c : new KeyPair$1(u, { secret: c });
};
KeyPair$1.prototype.secret = function a() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function a() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function a() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function a() {
  var u = this.eddsa, c = this.hash(), l = u.encodingLength - 1, v = c.slice(0, u.encodingLength);
  return v[0] &= 248, v[l] &= 127, v[l] |= 64, v;
});
cachedProperty$1(KeyPair$1, "priv", function a() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function a() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function a() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function a(u) {
  return assert$3(this._secret, "KeyPair can only verify"), this.eddsa.sign(u, this);
};
KeyPair$1.prototype.verify = function a(u, c) {
  return this.eddsa.verify(u, c, this);
};
KeyPair$1.prototype.getSecret = function a(u) {
  return assert$3(this._secret, "KeyPair is public only"), utils$c.encode(this.secret(), u);
};
KeyPair$1.prototype.getPublic = function a(u) {
  return utils$c.encode(this.pubBytes(), u);
};
var key$1 = KeyPair$1, BN$3 = bnExports$3, utils$b = utils$v, assert$2 = utils$b.assert, cachedProperty = utils$b.cachedProperty, parseBytes$1 = utils$b.parseBytes;
function Signature$1(a, u) {
  this.eddsa = a, typeof u != "object" && (u = parseBytes$1(u)), Array.isArray(u) && (u = {
    R: u.slice(0, a.encodingLength),
    S: u.slice(a.encodingLength)
  }), assert$2(u.R && u.S, "Signature without R or S"), a.isPoint(u.R) && (this._R = u.R), u.S instanceof BN$3 && (this._S = u.S), this._Rencoded = Array.isArray(u.R) ? u.R : u.Rencoded, this._Sencoded = Array.isArray(u.S) ? u.S : u.Sencoded;
}
cachedProperty(Signature$1, "S", function a() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function a() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function a() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function a() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function a() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function a() {
  return utils$b.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash = hash$2, curves = curves$1, utils$a = utils$v, assert$1 = utils$a.assert, parseBytes = utils$a.parseBytes, KeyPair = key$1, Signature = signature;
function EDDSA(a) {
  if (assert$1(a === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(a);
  a = curves[a].curve, this.curve = a, this.g = a.g, this.g.precompute(a.n.bitLength() + 1), this.pointClass = a.point().constructor, this.encodingLength = Math.ceil(a.n.bitLength() / 8), this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function a(u, c) {
  u = parseBytes(u);
  var l = this.keyFromSecret(c), v = this.hashInt(l.messagePrefix(), u), p = this.g.mul(v), _ = this.encodePoint(p), I = this.hashInt(_, l.pubBytes(), u).mul(l.priv()), P = v.add(I).umod(this.curve.n);
  return this.makeSignature({ R: p, S: P, Rencoded: _ });
};
EDDSA.prototype.verify = function a(u, c, l) {
  u = parseBytes(u), c = this.makeSignature(c);
  var v = this.keyFromPublic(l), p = this.hashInt(c.Rencoded(), v.pubBytes(), u), _ = this.g.mul(c.S()), I = c.R().add(v.pub().mul(p));
  return I.eq(_);
};
EDDSA.prototype.hashInt = function a() {
  for (var u = this.hash(), c = 0; c < arguments.length; c++)
    u.update(arguments[c]);
  return utils$a.intFromLE(u.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function a(u) {
  return KeyPair.fromPublic(this, u);
};
EDDSA.prototype.keyFromSecret = function a(u) {
  return KeyPair.fromSecret(this, u);
};
EDDSA.prototype.makeSignature = function a(u) {
  return u instanceof Signature ? u : new Signature(this, u);
};
EDDSA.prototype.encodePoint = function a(u) {
  var c = u.getY().toArray("le", this.encodingLength);
  return c[this.encodingLength - 1] |= u.getX().isOdd() ? 128 : 0, c;
};
EDDSA.prototype.decodePoint = function a(u) {
  u = utils$a.parseBytes(u);
  var c = u.length - 1, l = u.slice(0, c).concat(u[c] & -129), v = (u[c] & 128) !== 0, p = utils$a.intFromLE(l);
  return this.curve.pointFromY(p, v);
};
EDDSA.prototype.encodeInt = function a(u) {
  return u.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function a(u) {
  return utils$a.intFromLE(u);
};
EDDSA.prototype.isPoint = function a(u) {
  return u instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(a) {
    var u = a;
    u.version = require$$0$1.version, u.utils = utils$v, u.rand = requireBrorand(), u.curve = curve, u.curves = curves$1, u.ec = requireEc(), u.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var asn1$3 = {}, asn1$2 = {}, bn$2 = { exports: {} };
bn$2.exports;
(function(a) {
  (function(u, c) {
    function l(C, b) {
      if (!C)
        throw new Error(b || "Assertion failed");
    }
    function v(C, b) {
      C.super_ = b;
      var E = function() {
      };
      E.prototype = b.prototype, C.prototype = new E(), C.prototype.constructor = C;
    }
    function p(C, b, E) {
      if (p.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((b === "le" || b === "be") && (E = b, b = 10), this._init(C || 0, b || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(b) {
      return b instanceof p ? !0 : b !== null && typeof b == "object" && b.constructor.wordSize === p.wordSize && Array.isArray(b.words);
    }, p.max = function(b, E) {
      return b.cmp(E) > 0 ? b : E;
    }, p.min = function(b, E) {
      return b.cmp(E) < 0 ? b : E;
    }, p.prototype._init = function(b, E, k) {
      if (typeof b == "number")
        return this._initNumber(b, E, k);
      if (typeof b == "object")
        return this._initArray(b, E, k);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), b = b.toString().replace(/\s+/g, "");
      var O = 0;
      b[0] === "-" && (O++, this.negative = 1), O < b.length && (E === 16 ? this._parseHex(b, O, k) : (this._parseBase(b, E, O), k === "le" && this._initArray(this.toArray(), E, k)));
    }, p.prototype._initNumber = function(b, E, k) {
      b < 0 && (this.negative = 1, b = -b), b < 67108864 ? (this.words = [b & 67108863], this.length = 1) : b < 4503599627370496 ? (this.words = [
        b & 67108863,
        b / 67108864 & 67108863
      ], this.length = 2) : (l(b < 9007199254740992), this.words = [
        b & 67108863,
        b / 67108864 & 67108863,
        1
      ], this.length = 3), k === "le" && this._initArray(this.toArray(), E, k);
    }, p.prototype._initArray = function(b, E, k) {
      if (l(typeof b.length == "number"), b.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(b.length / 3), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var A, x, Y = 0;
      if (k === "be")
        for (O = b.length - 1, A = 0; O >= 0; O -= 3)
          x = b[O] | b[O - 1] << 8 | b[O - 2] << 16, this.words[A] |= x << Y & 67108863, this.words[A + 1] = x >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, A++);
      else if (k === "le")
        for (O = 0, A = 0; O < b.length; O += 3)
          x = b[O] | b[O + 1] << 8 | b[O + 2] << 16, this.words[A] |= x << Y & 67108863, this.words[A + 1] = x >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, A++);
      return this.strip();
    };
    function I(C, b) {
      var E = C.charCodeAt(b);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function P(C, b, E) {
      var k = I(C, E);
      return E - 1 >= b && (k |= I(C, E - 1) << 4), k;
    }
    p.prototype._parseHex = function(b, E, k) {
      this.length = Math.ceil((b.length - E) / 6), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var A = 0, x = 0, Y;
      if (k === "be")
        for (O = b.length - 1; O >= E; O -= 2)
          Y = P(b, E, O) << A, this.words[x] |= Y & 67108863, A >= 18 ? (A -= 18, x += 1, this.words[x] |= Y >>> 26) : A += 8;
      else {
        var B = b.length - E;
        for (O = B % 2 === 0 ? E + 1 : E; O < b.length; O += 2)
          Y = P(b, E, O) << A, this.words[x] |= Y & 67108863, A >= 18 ? (A -= 18, x += 1, this.words[x] |= Y >>> 26) : A += 8;
      }
      this.strip();
    };
    function $(C, b, E, k) {
      for (var O = 0, A = Math.min(C.length, E), x = b; x < A; x++) {
        var Y = C.charCodeAt(x) - 48;
        O *= k, Y >= 49 ? O += Y - 49 + 10 : Y >= 17 ? O += Y - 17 + 10 : O += Y;
      }
      return O;
    }
    p.prototype._parseBase = function(b, E, k) {
      this.words = [0], this.length = 1;
      for (var O = 0, A = 1; A <= 67108863; A *= E)
        O++;
      O--, A = A / E | 0;
      for (var x = b.length - k, Y = x % O, B = Math.min(x, x - Y) + k, T = 0, D = k; D < B; D += O)
        T = $(b, D, D + O, E), this.imuln(A), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = $(b, D, b.length, E), D = 0; D < Y; D++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(b) {
      b.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        b.words[E] = this.words[E];
      b.length = this.length, b.negative = this.negative, b.red = this.red;
    }, p.prototype.clone = function() {
      var b = new p(null);
      return this.copy(b), b;
    }, p.prototype._expand = function(b) {
      for (; this.length < b; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], H = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], j = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(b, E) {
      b = b || 10, E = E | 0 || 1;
      var k;
      if (b === 16 || b === "hex") {
        k = "";
        for (var O = 0, A = 0, x = 0; x < this.length; x++) {
          var Y = this.words[x], B = ((Y << O | A) & 16777215).toString(16);
          A = Y >>> 24 - O & 16777215, A !== 0 || x !== this.length - 1 ? k = F[6 - B.length] + B + k : k = B + k, O += 2, O >= 26 && (O -= 26, x--);
        }
        for (A !== 0 && (k = A.toString(16) + k); k.length % E !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      if (b === (b | 0) && b >= 2 && b <= 36) {
        var T = H[b], D = j[b];
        k = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var me = te.modn(D).toString(b);
          te = te.idivn(D), te.isZero() ? k = me + k : k = F[T - me.length] + me + k;
        }
        for (this.isZero() && (k = "0" + k); k.length % E !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var b = this.words[0];
      return this.length === 2 ? b += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? b += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -b : b;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(b, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, b, E);
    }, p.prototype.toArray = function(b, E) {
      return this.toArrayLike(Array, b, E);
    }, p.prototype.toArrayLike = function(b, E, k) {
      var O = this.byteLength(), A = k || Math.max(1, O);
      l(O <= A, "byte array longer than desired length"), l(A > 0, "Requested array length <= 0"), this.strip();
      var x = E === "le", Y = new b(A), B, T, D = this.clone();
      if (x) {
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), Y[T] = B;
        for (; T < A; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < A - O; T++)
          Y[T] = 0;
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), Y[A - T - 1] = B;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(b) {
      return 32 - Math.clz32(b);
    } : p.prototype._countBits = function(b) {
      var E = b, k = 0;
      return E >= 4096 && (k += 13, E >>>= 13), E >= 64 && (k += 7, E >>>= 7), E >= 8 && (k += 4, E >>>= 4), E >= 2 && (k += 2, E >>>= 2), k + E;
    }, p.prototype._zeroBits = function(b) {
      if (b === 0)
        return 26;
      var E = b, k = 0;
      return E & 8191 || (k += 13, E >>>= 13), E & 127 || (k += 7, E >>>= 7), E & 15 || (k += 4, E >>>= 4), E & 3 || (k += 2, E >>>= 2), E & 1 || k++, k;
    }, p.prototype.bitLength = function() {
      var b = this.words[this.length - 1], E = this._countBits(b);
      return (this.length - 1) * 26 + E;
    };
    function ee(C) {
      for (var b = new Array(C.bitLength()), E = 0; E < b.length; E++) {
        var k = E / 26 | 0, O = E % 26;
        b[E] = (C.words[k] & 1 << O) >>> O;
      }
      return b;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var b = 0, E = 0; E < this.length; E++) {
        var k = this._zeroBits(this.words[E]);
        if (b += k, k !== 26)
          break;
      }
      return b;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(b) {
      return this.negative !== 0 ? this.abs().inotn(b).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(b) {
      return this.testn(b - 1) ? this.notn(b).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(b) {
      for (; this.length < b.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < b.length; E++)
        this.words[E] = this.words[E] | b.words[E];
      return this.strip();
    }, p.prototype.ior = function(b) {
      return l((this.negative | b.negative) === 0), this.iuor(b);
    }, p.prototype.or = function(b) {
      return this.length > b.length ? this.clone().ior(b) : b.clone().ior(this);
    }, p.prototype.uor = function(b) {
      return this.length > b.length ? this.clone().iuor(b) : b.clone().iuor(this);
    }, p.prototype.iuand = function(b) {
      var E;
      this.length > b.length ? E = b : E = this;
      for (var k = 0; k < E.length; k++)
        this.words[k] = this.words[k] & b.words[k];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(b) {
      return l((this.negative | b.negative) === 0), this.iuand(b);
    }, p.prototype.and = function(b) {
      return this.length > b.length ? this.clone().iand(b) : b.clone().iand(this);
    }, p.prototype.uand = function(b) {
      return this.length > b.length ? this.clone().iuand(b) : b.clone().iuand(this);
    }, p.prototype.iuxor = function(b) {
      var E, k;
      this.length > b.length ? (E = this, k = b) : (E = b, k = this);
      for (var O = 0; O < k.length; O++)
        this.words[O] = E.words[O] ^ k.words[O];
      if (this !== E)
        for (; O < E.length; O++)
          this.words[O] = E.words[O];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(b) {
      return l((this.negative | b.negative) === 0), this.iuxor(b);
    }, p.prototype.xor = function(b) {
      return this.length > b.length ? this.clone().ixor(b) : b.clone().ixor(this);
    }, p.prototype.uxor = function(b) {
      return this.length > b.length ? this.clone().iuxor(b) : b.clone().iuxor(this);
    }, p.prototype.inotn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = Math.ceil(b / 26) | 0, k = b % 26;
      this._expand(E), k > 0 && E--;
      for (var O = 0; O < E; O++)
        this.words[O] = ~this.words[O] & 67108863;
      return k > 0 && (this.words[O] = ~this.words[O] & 67108863 >> 26 - k), this.strip();
    }, p.prototype.notn = function(b) {
      return this.clone().inotn(b);
    }, p.prototype.setn = function(b, E) {
      l(typeof b == "number" && b >= 0);
      var k = b / 26 | 0, O = b % 26;
      return this._expand(k + 1), E ? this.words[k] = this.words[k] | 1 << O : this.words[k] = this.words[k] & ~(1 << O), this.strip();
    }, p.prototype.iadd = function(b) {
      var E;
      if (this.negative !== 0 && b.negative === 0)
        return this.negative = 0, E = this.isub(b), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && b.negative !== 0)
        return b.negative = 0, E = this.isub(b), b.negative = 1, E._normSign();
      var k, O;
      this.length > b.length ? (k = this, O = b) : (k = b, O = this);
      for (var A = 0, x = 0; x < O.length; x++)
        E = (k.words[x] | 0) + (O.words[x] | 0) + A, this.words[x] = E & 67108863, A = E >>> 26;
      for (; A !== 0 && x < k.length; x++)
        E = (k.words[x] | 0) + A, this.words[x] = E & 67108863, A = E >>> 26;
      if (this.length = k.length, A !== 0)
        this.words[this.length] = A, this.length++;
      else if (k !== this)
        for (; x < k.length; x++)
          this.words[x] = k.words[x];
      return this;
    }, p.prototype.add = function(b) {
      var E;
      return b.negative !== 0 && this.negative === 0 ? (b.negative = 0, E = this.sub(b), b.negative ^= 1, E) : b.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = b.sub(this), this.negative = 1, E) : this.length > b.length ? this.clone().iadd(b) : b.clone().iadd(this);
    }, p.prototype.isub = function(b) {
      if (b.negative !== 0) {
        b.negative = 0;
        var E = this.iadd(b);
        return b.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(b), this.negative = 1, this._normSign();
      var k = this.cmp(b);
      if (k === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var O, A;
      k > 0 ? (O = this, A = b) : (O = b, A = this);
      for (var x = 0, Y = 0; Y < A.length; Y++)
        E = (O.words[Y] | 0) - (A.words[Y] | 0) + x, x = E >> 26, this.words[Y] = E & 67108863;
      for (; x !== 0 && Y < O.length; Y++)
        E = (O.words[Y] | 0) + x, x = E >> 26, this.words[Y] = E & 67108863;
      if (x === 0 && Y < O.length && O !== this)
        for (; Y < O.length; Y++)
          this.words[Y] = O.words[Y];
      return this.length = Math.max(this.length, Y), O !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(b) {
      return this.clone().isub(b);
    };
    function X(C, b, E) {
      E.negative = b.negative ^ C.negative;
      var k = C.length + b.length | 0;
      E.length = k, k = k - 1 | 0;
      var O = C.words[0] | 0, A = b.words[0] | 0, x = O * A, Y = x & 67108863, B = x / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < k; T++) {
        for (var D = B >>> 26, te = B & 67108863, me = Math.min(T, b.length - 1), Ie = Math.max(0, T - C.length + 1); Ie <= me; Ie++) {
          var $e = T - Ie | 0;
          O = C.words[$e] | 0, A = b.words[Ie] | 0, x = O * A + te, D += x / 67108864 | 0, te = x & 67108863;
        }
        E.words[T] = te | 0, B = D | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ie = function(b, E, k) {
      var O = b.words, A = E.words, x = k.words, Y = 0, B, T, D, te = O[0] | 0, me = te & 8191, Ie = te >>> 13, $e = O[1] | 0, ye = $e & 8191, fe = $e >>> 13, Me = O[2] | 0, Ae = Me & 8191, xe = Me >>> 13, ae = O[3] | 0, N = ae & 8191, re = ae >>> 13, le = O[4] | 0, Ne = le & 8191, Oe = le >>> 13, qe = O[5] | 0, je = qe & 8191, Fe = qe >>> 13, yt = O[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, V = O[7] | 0, ge = V & 8191, Te = V >>> 13, We = O[8] | 0, Re = We & 8191, J = We >>> 13, Ee = O[9] | 0, ue = Ee & 8191, ce = Ee >>> 13, ve = A[0] | 0, Ce = ve & 8191, Be = ve >>> 13, He = A[1] | 0, Ve = He & 8191, Ze = He >>> 13, Ke = A[2] | 0, U = Ke & 8191, se = Ke >>> 13, Se = A[3] | 0, Ue = Se & 8191, De = Se >>> 13, Ye = A[4] | 0, Qe = Ye & 8191, st = Ye >>> 13, St = A[5] | 0, tt = St & 8191, it = St >>> 13, Tt = A[6] | 0, rt = Tt & 8191, dt = Tt >>> 13, wt = A[7] | 0, nt = wt & 8191, at = wt >>> 13, gt = A[8] | 0, ot = gt & 8191, ct = gt >>> 13, Ct = A[9] | 0, ut = Ct & 8191, lt = Ct >>> 13;
      k.negative = b.negative ^ E.negative, k.length = 19, B = Math.imul(me, Ce), T = Math.imul(me, Be), T = T + Math.imul(Ie, Ce) | 0, D = Math.imul(Ie, Be);
      var kt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, B = Math.imul(ye, Ce), T = Math.imul(ye, Be), T = T + Math.imul(fe, Ce) | 0, D = Math.imul(fe, Be), B = B + Math.imul(me, Ve) | 0, T = T + Math.imul(me, Ze) | 0, T = T + Math.imul(Ie, Ve) | 0, D = D + Math.imul(Ie, Ze) | 0;
      var Rt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(Ae, Ce), T = Math.imul(Ae, Be), T = T + Math.imul(xe, Ce) | 0, D = Math.imul(xe, Be), B = B + Math.imul(ye, Ve) | 0, T = T + Math.imul(ye, Ze) | 0, T = T + Math.imul(fe, Ve) | 0, D = D + Math.imul(fe, Ze) | 0, B = B + Math.imul(me, U) | 0, T = T + Math.imul(me, se) | 0, T = T + Math.imul(Ie, U) | 0, D = D + Math.imul(Ie, se) | 0;
      var Je = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, B = Math.imul(N, Ce), T = Math.imul(N, Be), T = T + Math.imul(re, Ce) | 0, D = Math.imul(re, Be), B = B + Math.imul(Ae, Ve) | 0, T = T + Math.imul(Ae, Ze) | 0, T = T + Math.imul(xe, Ve) | 0, D = D + Math.imul(xe, Ze) | 0, B = B + Math.imul(ye, U) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(fe, U) | 0, D = D + Math.imul(fe, se) | 0, B = B + Math.imul(me, Ue) | 0, T = T + Math.imul(me, De) | 0, T = T + Math.imul(Ie, Ue) | 0, D = D + Math.imul(Ie, De) | 0;
      var ze = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, B = Math.imul(Ne, Ce), T = Math.imul(Ne, Be), T = T + Math.imul(Oe, Ce) | 0, D = Math.imul(Oe, Be), B = B + Math.imul(N, Ve) | 0, T = T + Math.imul(N, Ze) | 0, T = T + Math.imul(re, Ve) | 0, D = D + Math.imul(re, Ze) | 0, B = B + Math.imul(Ae, U) | 0, T = T + Math.imul(Ae, se) | 0, T = T + Math.imul(xe, U) | 0, D = D + Math.imul(xe, se) | 0, B = B + Math.imul(ye, Ue) | 0, T = T + Math.imul(ye, De) | 0, T = T + Math.imul(fe, Ue) | 0, D = D + Math.imul(fe, De) | 0, B = B + Math.imul(me, Qe) | 0, T = T + Math.imul(me, st) | 0, T = T + Math.imul(Ie, Qe) | 0, D = D + Math.imul(Ie, st) | 0;
      var et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, B = Math.imul(je, Ce), T = Math.imul(je, Be), T = T + Math.imul(Fe, Ce) | 0, D = Math.imul(Fe, Be), B = B + Math.imul(Ne, Ve) | 0, T = T + Math.imul(Ne, Ze) | 0, T = T + Math.imul(Oe, Ve) | 0, D = D + Math.imul(Oe, Ze) | 0, B = B + Math.imul(N, U) | 0, T = T + Math.imul(N, se) | 0, T = T + Math.imul(re, U) | 0, D = D + Math.imul(re, se) | 0, B = B + Math.imul(Ae, Ue) | 0, T = T + Math.imul(Ae, De) | 0, T = T + Math.imul(xe, Ue) | 0, D = D + Math.imul(xe, De) | 0, B = B + Math.imul(ye, Qe) | 0, T = T + Math.imul(ye, st) | 0, T = T + Math.imul(fe, Qe) | 0, D = D + Math.imul(fe, st) | 0, B = B + Math.imul(me, tt) | 0, T = T + Math.imul(me, it) | 0, T = T + Math.imul(Ie, tt) | 0, D = D + Math.imul(Ie, it) | 0;
      var pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Ce), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Ce) | 0, D = Math.imul(Ge, Be), B = B + Math.imul(je, Ve) | 0, T = T + Math.imul(je, Ze) | 0, T = T + Math.imul(Fe, Ve) | 0, D = D + Math.imul(Fe, Ze) | 0, B = B + Math.imul(Ne, U) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Oe, U) | 0, D = D + Math.imul(Oe, se) | 0, B = B + Math.imul(N, Ue) | 0, T = T + Math.imul(N, De) | 0, T = T + Math.imul(re, Ue) | 0, D = D + Math.imul(re, De) | 0, B = B + Math.imul(Ae, Qe) | 0, T = T + Math.imul(Ae, st) | 0, T = T + Math.imul(xe, Qe) | 0, D = D + Math.imul(xe, st) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(fe, tt) | 0, D = D + Math.imul(fe, it) | 0, B = B + Math.imul(me, rt) | 0, T = T + Math.imul(me, dt) | 0, T = T + Math.imul(Ie, rt) | 0, D = D + Math.imul(Ie, dt) | 0;
      var mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ge, Ce), T = Math.imul(ge, Be), T = T + Math.imul(Te, Ce) | 0, D = Math.imul(Te, Be), B = B + Math.imul(Xe, Ve) | 0, T = T + Math.imul(Xe, Ze) | 0, T = T + Math.imul(Ge, Ve) | 0, D = D + Math.imul(Ge, Ze) | 0, B = B + Math.imul(je, U) | 0, T = T + Math.imul(je, se) | 0, T = T + Math.imul(Fe, U) | 0, D = D + Math.imul(Fe, se) | 0, B = B + Math.imul(Ne, Ue) | 0, T = T + Math.imul(Ne, De) | 0, T = T + Math.imul(Oe, Ue) | 0, D = D + Math.imul(Oe, De) | 0, B = B + Math.imul(N, Qe) | 0, T = T + Math.imul(N, st) | 0, T = T + Math.imul(re, Qe) | 0, D = D + Math.imul(re, st) | 0, B = B + Math.imul(Ae, tt) | 0, T = T + Math.imul(Ae, it) | 0, T = T + Math.imul(xe, tt) | 0, D = D + Math.imul(xe, it) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(fe, rt) | 0, D = D + Math.imul(fe, dt) | 0, B = B + Math.imul(me, nt) | 0, T = T + Math.imul(me, at) | 0, T = T + Math.imul(Ie, nt) | 0, D = D + Math.imul(Ie, at) | 0;
      var vt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, B = Math.imul(Re, Ce), T = Math.imul(Re, Be), T = T + Math.imul(J, Ce) | 0, D = Math.imul(J, Be), B = B + Math.imul(ge, Ve) | 0, T = T + Math.imul(ge, Ze) | 0, T = T + Math.imul(Te, Ve) | 0, D = D + Math.imul(Te, Ze) | 0, B = B + Math.imul(Xe, U) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, U) | 0, D = D + Math.imul(Ge, se) | 0, B = B + Math.imul(je, Ue) | 0, T = T + Math.imul(je, De) | 0, T = T + Math.imul(Fe, Ue) | 0, D = D + Math.imul(Fe, De) | 0, B = B + Math.imul(Ne, Qe) | 0, T = T + Math.imul(Ne, st) | 0, T = T + Math.imul(Oe, Qe) | 0, D = D + Math.imul(Oe, st) | 0, B = B + Math.imul(N, tt) | 0, T = T + Math.imul(N, it) | 0, T = T + Math.imul(re, tt) | 0, D = D + Math.imul(re, it) | 0, B = B + Math.imul(Ae, rt) | 0, T = T + Math.imul(Ae, dt) | 0, T = T + Math.imul(xe, rt) | 0, D = D + Math.imul(xe, dt) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(fe, nt) | 0, D = D + Math.imul(fe, at) | 0, B = B + Math.imul(me, ot) | 0, T = T + Math.imul(me, ct) | 0, T = T + Math.imul(Ie, ot) | 0, D = D + Math.imul(Ie, ct) | 0;
      var ht = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(ue, Ce), T = Math.imul(ue, Be), T = T + Math.imul(ce, Ce) | 0, D = Math.imul(ce, Be), B = B + Math.imul(Re, Ve) | 0, T = T + Math.imul(Re, Ze) | 0, T = T + Math.imul(J, Ve) | 0, D = D + Math.imul(J, Ze) | 0, B = B + Math.imul(ge, U) | 0, T = T + Math.imul(ge, se) | 0, T = T + Math.imul(Te, U) | 0, D = D + Math.imul(Te, se) | 0, B = B + Math.imul(Xe, Ue) | 0, T = T + Math.imul(Xe, De) | 0, T = T + Math.imul(Ge, Ue) | 0, D = D + Math.imul(Ge, De) | 0, B = B + Math.imul(je, Qe) | 0, T = T + Math.imul(je, st) | 0, T = T + Math.imul(Fe, Qe) | 0, D = D + Math.imul(Fe, st) | 0, B = B + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Oe, tt) | 0, D = D + Math.imul(Oe, it) | 0, B = B + Math.imul(N, rt) | 0, T = T + Math.imul(N, dt) | 0, T = T + Math.imul(re, rt) | 0, D = D + Math.imul(re, dt) | 0, B = B + Math.imul(Ae, nt) | 0, T = T + Math.imul(Ae, at) | 0, T = T + Math.imul(xe, nt) | 0, D = D + Math.imul(xe, at) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(fe, ot) | 0, D = D + Math.imul(fe, ct) | 0, B = B + Math.imul(me, ut) | 0, T = T + Math.imul(me, lt) | 0, T = T + Math.imul(Ie, ut) | 0, D = D + Math.imul(Ie, lt) | 0;
      var _t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, B = Math.imul(ue, Ve), T = Math.imul(ue, Ze), T = T + Math.imul(ce, Ve) | 0, D = Math.imul(ce, Ze), B = B + Math.imul(Re, U) | 0, T = T + Math.imul(Re, se) | 0, T = T + Math.imul(J, U) | 0, D = D + Math.imul(J, se) | 0, B = B + Math.imul(ge, Ue) | 0, T = T + Math.imul(ge, De) | 0, T = T + Math.imul(Te, Ue) | 0, D = D + Math.imul(Te, De) | 0, B = B + Math.imul(Xe, Qe) | 0, T = T + Math.imul(Xe, st) | 0, T = T + Math.imul(Ge, Qe) | 0, D = D + Math.imul(Ge, st) | 0, B = B + Math.imul(je, tt) | 0, T = T + Math.imul(je, it) | 0, T = T + Math.imul(Fe, tt) | 0, D = D + Math.imul(Fe, it) | 0, B = B + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Oe, rt) | 0, D = D + Math.imul(Oe, dt) | 0, B = B + Math.imul(N, nt) | 0, T = T + Math.imul(N, at) | 0, T = T + Math.imul(re, nt) | 0, D = D + Math.imul(re, at) | 0, B = B + Math.imul(Ae, ot) | 0, T = T + Math.imul(Ae, ct) | 0, T = T + Math.imul(xe, ot) | 0, D = D + Math.imul(xe, ct) | 0, B = B + Math.imul(ye, ut) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(fe, ut) | 0, D = D + Math.imul(fe, lt) | 0;
      var Et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(ue, U), T = Math.imul(ue, se), T = T + Math.imul(ce, U) | 0, D = Math.imul(ce, se), B = B + Math.imul(Re, Ue) | 0, T = T + Math.imul(Re, De) | 0, T = T + Math.imul(J, Ue) | 0, D = D + Math.imul(J, De) | 0, B = B + Math.imul(ge, Qe) | 0, T = T + Math.imul(ge, st) | 0, T = T + Math.imul(Te, Qe) | 0, D = D + Math.imul(Te, st) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, tt) | 0, D = D + Math.imul(Ge, it) | 0, B = B + Math.imul(je, rt) | 0, T = T + Math.imul(je, dt) | 0, T = T + Math.imul(Fe, rt) | 0, D = D + Math.imul(Fe, dt) | 0, B = B + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Oe, nt) | 0, D = D + Math.imul(Oe, at) | 0, B = B + Math.imul(N, ot) | 0, T = T + Math.imul(N, ct) | 0, T = T + Math.imul(re, ot) | 0, D = D + Math.imul(re, ct) | 0, B = B + Math.imul(Ae, ut) | 0, T = T + Math.imul(Ae, lt) | 0, T = T + Math.imul(xe, ut) | 0, D = D + Math.imul(xe, lt) | 0;
      var Pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, B = Math.imul(ue, Ue), T = Math.imul(ue, De), T = T + Math.imul(ce, Ue) | 0, D = Math.imul(ce, De), B = B + Math.imul(Re, Qe) | 0, T = T + Math.imul(Re, st) | 0, T = T + Math.imul(J, Qe) | 0, D = D + Math.imul(J, st) | 0, B = B + Math.imul(ge, tt) | 0, T = T + Math.imul(ge, it) | 0, T = T + Math.imul(Te, tt) | 0, D = D + Math.imul(Te, it) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, rt) | 0, D = D + Math.imul(Ge, dt) | 0, B = B + Math.imul(je, nt) | 0, T = T + Math.imul(je, at) | 0, T = T + Math.imul(Fe, nt) | 0, D = D + Math.imul(Fe, at) | 0, B = B + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Oe, ot) | 0, D = D + Math.imul(Oe, ct) | 0, B = B + Math.imul(N, ut) | 0, T = T + Math.imul(N, lt) | 0, T = T + Math.imul(re, ut) | 0, D = D + Math.imul(re, lt) | 0;
      var Nt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(ue, Qe), T = Math.imul(ue, st), T = T + Math.imul(ce, Qe) | 0, D = Math.imul(ce, st), B = B + Math.imul(Re, tt) | 0, T = T + Math.imul(Re, it) | 0, T = T + Math.imul(J, tt) | 0, D = D + Math.imul(J, it) | 0, B = B + Math.imul(ge, rt) | 0, T = T + Math.imul(ge, dt) | 0, T = T + Math.imul(Te, rt) | 0, D = D + Math.imul(Te, dt) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, nt) | 0, D = D + Math.imul(Ge, at) | 0, B = B + Math.imul(je, ot) | 0, T = T + Math.imul(je, ct) | 0, T = T + Math.imul(Fe, ot) | 0, D = D + Math.imul(Fe, ct) | 0, B = B + Math.imul(Ne, ut) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Oe, ut) | 0, D = D + Math.imul(Oe, lt) | 0;
      var Mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, B = Math.imul(ue, tt), T = Math.imul(ue, it), T = T + Math.imul(ce, tt) | 0, D = Math.imul(ce, it), B = B + Math.imul(Re, rt) | 0, T = T + Math.imul(Re, dt) | 0, T = T + Math.imul(J, rt) | 0, D = D + Math.imul(J, dt) | 0, B = B + Math.imul(ge, nt) | 0, T = T + Math.imul(ge, at) | 0, T = T + Math.imul(Te, nt) | 0, D = D + Math.imul(Te, at) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, D = D + Math.imul(Ge, ct) | 0, B = B + Math.imul(je, ut) | 0, T = T + Math.imul(je, lt) | 0, T = T + Math.imul(Fe, ut) | 0, D = D + Math.imul(Fe, lt) | 0;
      var Ot = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(ue, rt), T = Math.imul(ue, dt), T = T + Math.imul(ce, rt) | 0, D = Math.imul(ce, dt), B = B + Math.imul(Re, nt) | 0, T = T + Math.imul(Re, at) | 0, T = T + Math.imul(J, nt) | 0, D = D + Math.imul(J, at) | 0, B = B + Math.imul(ge, ot) | 0, T = T + Math.imul(ge, ct) | 0, T = T + Math.imul(Te, ot) | 0, D = D + Math.imul(Te, ct) | 0, B = B + Math.imul(Xe, ut) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, ut) | 0, D = D + Math.imul(Ge, lt) | 0;
      var $t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(ue, nt), T = Math.imul(ue, at), T = T + Math.imul(ce, nt) | 0, D = Math.imul(ce, at), B = B + Math.imul(Re, ot) | 0, T = T + Math.imul(Re, ct) | 0, T = T + Math.imul(J, ot) | 0, D = D + Math.imul(J, ct) | 0, B = B + Math.imul(ge, ut) | 0, T = T + Math.imul(ge, lt) | 0, T = T + Math.imul(Te, ut) | 0, D = D + Math.imul(Te, lt) | 0;
      var Bt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(ue, ot), T = Math.imul(ue, ct), T = T + Math.imul(ce, ot) | 0, D = Math.imul(ce, ct), B = B + Math.imul(Re, ut) | 0, T = T + Math.imul(Re, lt) | 0, T = T + Math.imul(J, ut) | 0, D = D + Math.imul(J, lt) | 0;
      var xt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, B = Math.imul(ue, ut), T = Math.imul(ue, lt), T = T + Math.imul(ce, ut) | 0, D = Math.imul(ce, lt);
      var Ut = (Y + B | 0) + ((T & 8191) << 13) | 0;
      return Y = (D + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, x[0] = kt, x[1] = Rt, x[2] = Je, x[3] = ze, x[4] = et, x[5] = pt, x[6] = mt, x[7] = vt, x[8] = ht, x[9] = _t, x[10] = Et, x[11] = Pt, x[12] = Nt, x[13] = Mt, x[14] = Ot, x[15] = $t, x[16] = Bt, x[17] = xt, x[18] = Ut, Y !== 0 && (x[19] = Y, k.length++), k;
    };
    Math.imul || (ie = X);
    function Q(C, b, E) {
      E.negative = b.negative ^ C.negative, E.length = C.length + b.length;
      for (var k = 0, O = 0, A = 0; A < E.length - 1; A++) {
        var x = O;
        O = 0;
        for (var Y = k & 67108863, B = Math.min(A, b.length - 1), T = Math.max(0, A - C.length + 1); T <= B; T++) {
          var D = A - T, te = C.words[D] | 0, me = b.words[T] | 0, Ie = te * me, $e = Ie & 67108863;
          x = x + (Ie / 67108864 | 0) | 0, $e = $e + Y | 0, Y = $e & 67108863, x = x + ($e >>> 26) | 0, O += x >>> 26, x &= 67108863;
        }
        E.words[A] = Y, k = x, x = O;
      }
      return k !== 0 ? E.words[A] = k : E.length--, E.strip();
    }
    function ne(C, b, E) {
      var k = new Z();
      return k.mulp(C, b, E);
    }
    p.prototype.mulTo = function(b, E) {
      var k, O = this.length + b.length;
      return this.length === 10 && b.length === 10 ? k = ie(this, b, E) : O < 63 ? k = X(this, b, E) : O < 1024 ? k = Q(this, b, E) : k = ne(this, b, E), k;
    };
    function Z(C, b) {
      this.x = C, this.y = b;
    }
    Z.prototype.makeRBT = function(b) {
      for (var E = new Array(b), k = p.prototype._countBits(b) - 1, O = 0; O < b; O++)
        E[O] = this.revBin(O, k, b);
      return E;
    }, Z.prototype.revBin = function(b, E, k) {
      if (b === 0 || b === k - 1)
        return b;
      for (var O = 0, A = 0; A < E; A++)
        O |= (b & 1) << E - A - 1, b >>= 1;
      return O;
    }, Z.prototype.permute = function(b, E, k, O, A, x) {
      for (var Y = 0; Y < x; Y++)
        O[Y] = E[b[Y]], A[Y] = k[b[Y]];
    }, Z.prototype.transform = function(b, E, k, O, A, x) {
      this.permute(x, b, E, k, O, A);
      for (var Y = 1; Y < A; Y <<= 1)
        for (var B = Y << 1, T = Math.cos(2 * Math.PI / B), D = Math.sin(2 * Math.PI / B), te = 0; te < A; te += B)
          for (var me = T, Ie = D, $e = 0; $e < Y; $e++) {
            var ye = k[te + $e], fe = O[te + $e], Me = k[te + $e + Y], Ae = O[te + $e + Y], xe = me * Me - Ie * Ae;
            Ae = me * Ae + Ie * Me, Me = xe, k[te + $e] = ye + Me, O[te + $e] = fe + Ae, k[te + $e + Y] = ye - Me, O[te + $e + Y] = fe - Ae, $e !== B && (xe = T * me - D * Ie, Ie = T * Ie + D * me, me = xe);
          }
    }, Z.prototype.guessLen13b = function(b, E) {
      var k = Math.max(E, b) | 1, O = k & 1, A = 0;
      for (k = k / 2 | 0; k; k = k >>> 1)
        A++;
      return 1 << A + 1 + O;
    }, Z.prototype.conjugate = function(b, E, k) {
      if (!(k <= 1))
        for (var O = 0; O < k / 2; O++) {
          var A = b[O];
          b[O] = b[k - O - 1], b[k - O - 1] = A, A = E[O], E[O] = -E[k - O - 1], E[k - O - 1] = -A;
        }
    }, Z.prototype.normalize13b = function(b, E) {
      for (var k = 0, O = 0; O < E / 2; O++) {
        var A = Math.round(b[2 * O + 1] / E) * 8192 + Math.round(b[2 * O] / E) + k;
        b[O] = A & 67108863, A < 67108864 ? k = 0 : k = A / 67108864 | 0;
      }
      return b;
    }, Z.prototype.convert13b = function(b, E, k, O) {
      for (var A = 0, x = 0; x < E; x++)
        A = A + (b[x] | 0), k[2 * x] = A & 8191, A = A >>> 13, k[2 * x + 1] = A & 8191, A = A >>> 13;
      for (x = 2 * E; x < O; ++x)
        k[x] = 0;
      l(A === 0), l((A & -8192) === 0);
    }, Z.prototype.stub = function(b) {
      for (var E = new Array(b), k = 0; k < b; k++)
        E[k] = 0;
      return E;
    }, Z.prototype.mulp = function(b, E, k) {
      var O = 2 * this.guessLen13b(b.length, E.length), A = this.makeRBT(O), x = this.stub(O), Y = new Array(O), B = new Array(O), T = new Array(O), D = new Array(O), te = new Array(O), me = new Array(O), Ie = k.words;
      Ie.length = O, this.convert13b(b.words, b.length, Y, O), this.convert13b(E.words, E.length, D, O), this.transform(Y, x, B, T, O, A), this.transform(D, x, te, me, O, A);
      for (var $e = 0; $e < O; $e++) {
        var ye = B[$e] * te[$e] - T[$e] * me[$e];
        T[$e] = B[$e] * me[$e] + T[$e] * te[$e], B[$e] = ye;
      }
      return this.conjugate(B, T, O), this.transform(B, T, Ie, x, O, A), this.conjugate(Ie, x, O), this.normalize13b(Ie, O), k.negative = b.negative ^ E.negative, k.length = b.length + E.length, k.strip();
    }, p.prototype.mul = function(b) {
      var E = new p(null);
      return E.words = new Array(this.length + b.length), this.mulTo(b, E);
    }, p.prototype.mulf = function(b) {
      var E = new p(null);
      return E.words = new Array(this.length + b.length), ne(this, b, E);
    }, p.prototype.imul = function(b) {
      return this.clone().mulTo(b, this);
    }, p.prototype.imuln = function(b) {
      l(typeof b == "number"), l(b < 67108864);
      for (var E = 0, k = 0; k < this.length; k++) {
        var O = (this.words[k] | 0) * b, A = (O & 67108863) + (E & 67108863);
        E >>= 26, E += O / 67108864 | 0, E += A >>> 26, this.words[k] = A & 67108863;
      }
      return E !== 0 && (this.words[k] = E, this.length++), this;
    }, p.prototype.muln = function(b) {
      return this.clone().imuln(b);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(b) {
      var E = ee(b);
      if (E.length === 0)
        return new p(1);
      for (var k = this, O = 0; O < E.length && E[O] === 0; O++, k = k.sqr())
        ;
      if (++O < E.length)
        for (var A = k.sqr(); O < E.length; O++, A = A.sqr())
          E[O] !== 0 && (k = k.mul(A));
      return k;
    }, p.prototype.iushln = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26, O = 67108863 >>> 26 - E << 26 - E, A;
      if (E !== 0) {
        var x = 0;
        for (A = 0; A < this.length; A++) {
          var Y = this.words[A] & O, B = (this.words[A] | 0) - Y << E;
          this.words[A] = B | x, x = Y >>> 26 - E;
        }
        x && (this.words[A] = x, this.length++);
      }
      if (k !== 0) {
        for (A = this.length - 1; A >= 0; A--)
          this.words[A + k] = this.words[A];
        for (A = 0; A < k; A++)
          this.words[A] = 0;
        this.length += k;
      }
      return this.strip();
    }, p.prototype.ishln = function(b) {
      return l(this.negative === 0), this.iushln(b);
    }, p.prototype.iushrn = function(b, E, k) {
      l(typeof b == "number" && b >= 0);
      var O;
      E ? O = (E - E % 26) / 26 : O = 0;
      var A = b % 26, x = Math.min((b - A) / 26, this.length), Y = 67108863 ^ 67108863 >>> A << A, B = k;
      if (O -= x, O = Math.max(0, O), B) {
        for (var T = 0; T < x; T++)
          B.words[T] = this.words[T];
        B.length = x;
      }
      if (x !== 0)
        if (this.length > x)
          for (this.length -= x, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + x];
        else
          this.words[0] = 0, this.length = 1;
      var D = 0;
      for (T = this.length - 1; T >= 0 && (D !== 0 || T >= O); T--) {
        var te = this.words[T] | 0;
        this.words[T] = D << 26 - A | te >>> A, D = te & Y;
      }
      return B && D !== 0 && (B.words[B.length++] = D), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(b, E, k) {
      return l(this.negative === 0), this.iushrn(b, E, k);
    }, p.prototype.shln = function(b) {
      return this.clone().ishln(b);
    }, p.prototype.ushln = function(b) {
      return this.clone().iushln(b);
    }, p.prototype.shrn = function(b) {
      return this.clone().ishrn(b);
    }, p.prototype.ushrn = function(b) {
      return this.clone().iushrn(b);
    }, p.prototype.testn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26, O = 1 << E;
      if (this.length <= k)
        return !1;
      var A = this.words[k];
      return !!(A & O);
    }, p.prototype.imaskn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= k)
        return this;
      if (E !== 0 && k++, this.length = Math.min(k, this.length), E !== 0) {
        var O = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= O;
      }
      return this.strip();
    }, p.prototype.maskn = function(b) {
      return this.clone().imaskn(b);
    }, p.prototype.iaddn = function(b) {
      return l(typeof b == "number"), l(b < 67108864), b < 0 ? this.isubn(-b) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < b ? (this.words[0] = b - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(b), this.negative = 1, this) : this._iaddn(b);
    }, p.prototype._iaddn = function(b) {
      this.words[0] += b;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(b) {
      if (l(typeof b == "number"), l(b < 67108864), b < 0)
        return this.iaddn(-b);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(b), this.negative = 1, this;
      if (this.words[0] -= b, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(b) {
      return this.clone().iaddn(b);
    }, p.prototype.subn = function(b) {
      return this.clone().isubn(b);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(b, E, k) {
      var O = b.length + k, A;
      this._expand(O);
      var x, Y = 0;
      for (A = 0; A < b.length; A++) {
        x = (this.words[A + k] | 0) + Y;
        var B = (b.words[A] | 0) * E;
        x -= B & 67108863, Y = (x >> 26) - (B / 67108864 | 0), this.words[A + k] = x & 67108863;
      }
      for (; A < this.length - k; A++)
        x = (this.words[A + k] | 0) + Y, Y = x >> 26, this.words[A + k] = x & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, A = 0; A < this.length; A++)
        x = -(this.words[A] | 0) + Y, Y = x >> 26, this.words[A] = x & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(b, E) {
      var k = this.length - b.length, O = this.clone(), A = b, x = A.words[A.length - 1] | 0, Y = this._countBits(x);
      k = 26 - Y, k !== 0 && (A = A.ushln(k), O.iushln(k), x = A.words[A.length - 1] | 0);
      var B = O.length - A.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var D = 0; D < T.length; D++)
          T.words[D] = 0;
      }
      var te = O.clone()._ishlnsubmul(A, 1, B);
      te.negative === 0 && (O = te, T && (T.words[B] = 1));
      for (var me = B - 1; me >= 0; me--) {
        var Ie = (O.words[A.length + me] | 0) * 67108864 + (O.words[A.length + me - 1] | 0);
        for (Ie = Math.min(Ie / x | 0, 67108863), O._ishlnsubmul(A, Ie, me); O.negative !== 0; )
          Ie--, O.negative = 0, O._ishlnsubmul(A, 1, me), O.isZero() || (O.negative ^= 1);
        T && (T.words[me] = Ie);
      }
      return T && T.strip(), O.strip(), E !== "div" && k !== 0 && O.iushrn(k), {
        div: T || null,
        mod: O
      };
    }, p.prototype.divmod = function(b, E, k) {
      if (l(!b.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var O, A, x;
      return this.negative !== 0 && b.negative === 0 ? (x = this.neg().divmod(b, E), E !== "mod" && (O = x.div.neg()), E !== "div" && (A = x.mod.neg(), k && A.negative !== 0 && A.iadd(b)), {
        div: O,
        mod: A
      }) : this.negative === 0 && b.negative !== 0 ? (x = this.divmod(b.neg(), E), E !== "mod" && (O = x.div.neg()), {
        div: O,
        mod: x.mod
      }) : this.negative & b.negative ? (x = this.neg().divmod(b.neg(), E), E !== "div" && (A = x.mod.neg(), k && A.negative !== 0 && A.isub(b)), {
        div: x.div,
        mod: A
      }) : b.length > this.length || this.cmp(b) < 0 ? {
        div: new p(0),
        mod: this
      } : b.length === 1 ? E === "div" ? {
        div: this.divn(b.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(b.words[0]))
      } : {
        div: this.divn(b.words[0]),
        mod: new p(this.modn(b.words[0]))
      } : this._wordDiv(b, E);
    }, p.prototype.div = function(b) {
      return this.divmod(b, "div", !1).div;
    }, p.prototype.mod = function(b) {
      return this.divmod(b, "mod", !1).mod;
    }, p.prototype.umod = function(b) {
      return this.divmod(b, "mod", !0).mod;
    }, p.prototype.divRound = function(b) {
      var E = this.divmod(b);
      if (E.mod.isZero())
        return E.div;
      var k = E.div.negative !== 0 ? E.mod.isub(b) : E.mod, O = b.ushrn(1), A = b.andln(1), x = k.cmp(O);
      return x < 0 || A === 1 && x === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(b) {
      l(b <= 67108863);
      for (var E = (1 << 26) % b, k = 0, O = this.length - 1; O >= 0; O--)
        k = (E * k + (this.words[O] | 0)) % b;
      return k;
    }, p.prototype.idivn = function(b) {
      l(b <= 67108863);
      for (var E = 0, k = this.length - 1; k >= 0; k--) {
        var O = (this.words[k] | 0) + E * 67108864;
        this.words[k] = O / b | 0, E = O % b;
      }
      return this.strip();
    }, p.prototype.divn = function(b) {
      return this.clone().idivn(b);
    }, p.prototype.egcd = function(b) {
      l(b.negative === 0), l(!b.isZero());
      var E = this, k = b.clone();
      E.negative !== 0 ? E = E.umod(b) : E = E.clone();
      for (var O = new p(1), A = new p(0), x = new p(0), Y = new p(1), B = 0; E.isEven() && k.isEven(); )
        E.iushrn(1), k.iushrn(1), ++B;
      for (var T = k.clone(), D = E.clone(); !E.isZero(); ) {
        for (var te = 0, me = 1; !(E.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (O.isOdd() || A.isOdd()) && (O.iadd(T), A.isub(D)), O.iushrn(1), A.iushrn(1);
        for (var Ie = 0, $e = 1; !(k.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (k.iushrn(Ie); Ie-- > 0; )
            (x.isOdd() || Y.isOdd()) && (x.iadd(T), Y.isub(D)), x.iushrn(1), Y.iushrn(1);
        E.cmp(k) >= 0 ? (E.isub(k), O.isub(x), A.isub(Y)) : (k.isub(E), x.isub(O), Y.isub(A));
      }
      return {
        a: x,
        b: Y,
        gcd: k.iushln(B)
      };
    }, p.prototype._invmp = function(b) {
      l(b.negative === 0), l(!b.isZero());
      var E = this, k = b.clone();
      E.negative !== 0 ? E = E.umod(b) : E = E.clone();
      for (var O = new p(1), A = new p(0), x = k.clone(); E.cmpn(1) > 0 && k.cmpn(1) > 0; ) {
        for (var Y = 0, B = 1; !(E.words[0] & B) && Y < 26; ++Y, B <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            O.isOdd() && O.iadd(x), O.iushrn(1);
        for (var T = 0, D = 1; !(k.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (k.iushrn(T); T-- > 0; )
            A.isOdd() && A.iadd(x), A.iushrn(1);
        E.cmp(k) >= 0 ? (E.isub(k), O.isub(A)) : (k.isub(E), A.isub(O));
      }
      var te;
      return E.cmpn(1) === 0 ? te = O : te = A, te.cmpn(0) < 0 && te.iadd(b), te;
    }, p.prototype.gcd = function(b) {
      if (this.isZero())
        return b.abs();
      if (b.isZero())
        return this.abs();
      var E = this.clone(), k = b.clone();
      E.negative = 0, k.negative = 0;
      for (var O = 0; E.isEven() && k.isEven(); O++)
        E.iushrn(1), k.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; k.isEven(); )
          k.iushrn(1);
        var A = E.cmp(k);
        if (A < 0) {
          var x = E;
          E = k, k = x;
        } else if (A === 0 || k.cmpn(1) === 0)
          break;
        E.isub(k);
      } while (!0);
      return k.iushln(O);
    }, p.prototype.invm = function(b) {
      return this.egcd(b).a.umod(b);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(b) {
      return this.words[0] & b;
    }, p.prototype.bincn = function(b) {
      l(typeof b == "number");
      var E = b % 26, k = (b - E) / 26, O = 1 << E;
      if (this.length <= k)
        return this._expand(k + 1), this.words[k] |= O, this;
      for (var A = O, x = k; A !== 0 && x < this.length; x++) {
        var Y = this.words[x] | 0;
        Y += A, A = Y >>> 26, Y &= 67108863, this.words[x] = Y;
      }
      return A !== 0 && (this.words[x] = A, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(b) {
      var E = b < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var k;
      if (this.length > 1)
        k = 1;
      else {
        E && (b = -b), l(b <= 67108863, "Number is too big");
        var O = this.words[0] | 0;
        k = O === b ? 0 : O < b ? -1 : 1;
      }
      return this.negative !== 0 ? -k | 0 : k;
    }, p.prototype.cmp = function(b) {
      if (this.negative !== 0 && b.negative === 0)
        return -1;
      if (this.negative === 0 && b.negative !== 0)
        return 1;
      var E = this.ucmp(b);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(b) {
      if (this.length > b.length)
        return 1;
      if (this.length < b.length)
        return -1;
      for (var E = 0, k = this.length - 1; k >= 0; k--) {
        var O = this.words[k] | 0, A = b.words[k] | 0;
        if (O !== A) {
          O < A ? E = -1 : O > A && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(b) {
      return this.cmpn(b) === 1;
    }, p.prototype.gt = function(b) {
      return this.cmp(b) === 1;
    }, p.prototype.gten = function(b) {
      return this.cmpn(b) >= 0;
    }, p.prototype.gte = function(b) {
      return this.cmp(b) >= 0;
    }, p.prototype.ltn = function(b) {
      return this.cmpn(b) === -1;
    }, p.prototype.lt = function(b) {
      return this.cmp(b) === -1;
    }, p.prototype.lten = function(b) {
      return this.cmpn(b) <= 0;
    }, p.prototype.lte = function(b) {
      return this.cmp(b) <= 0;
    }, p.prototype.eqn = function(b) {
      return this.cmpn(b) === 0;
    }, p.prototype.eq = function(b) {
      return this.cmp(b) === 0;
    }, p.red = function(b) {
      return new q(b);
    }, p.prototype.toRed = function(b) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), b.convertTo(this)._forceRed(b);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(b) {
      return this.red = b, this;
    }, p.prototype.forceRed = function(b) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(b);
    }, p.prototype.redAdd = function(b) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, b);
    }, p.prototype.redIAdd = function(b) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, b);
    }, p.prototype.redSub = function(b) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, b);
    }, p.prototype.redISub = function(b) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, b);
    }, p.prototype.redShl = function(b) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, b);
    }, p.prototype.redMul = function(b) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.mul(this, b);
    }, p.prototype.redIMul = function(b) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.imul(this, b);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(b) {
      return l(this.red && !b.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, b);
    };
    var de = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function he(C, b) {
      this.name = C, this.p = new p(b, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    he.prototype._tmp = function() {
      var b = new p(null);
      return b.words = new Array(Math.ceil(this.n / 13)), b;
    }, he.prototype.ireduce = function(b) {
      var E = b, k;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), k = E.bitLength();
      while (k > this.n);
      var O = k < this.n ? -1 : E.ucmp(this.p);
      return O === 0 ? (E.words[0] = 0, E.length = 1) : O > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, he.prototype.split = function(b, E) {
      b.iushrn(this.n, 0, E);
    }, he.prototype.imulK = function(b) {
      return b.imul(this.k);
    };
    function pe() {
      he.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(pe, he), pe.prototype.split = function(b, E) {
      for (var k = 4194303, O = Math.min(b.length, 9), A = 0; A < O; A++)
        E.words[A] = b.words[A];
      if (E.length = O, b.length <= 9) {
        b.words[0] = 0, b.length = 1;
        return;
      }
      var x = b.words[9];
      for (E.words[E.length++] = x & k, A = 10; A < b.length; A++) {
        var Y = b.words[A] | 0;
        b.words[A - 10] = (Y & k) << 4 | x >>> 22, x = Y;
      }
      x >>>= 22, b.words[A - 10] = x, x === 0 && b.length > 10 ? b.length -= 10 : b.length -= 9;
    }, pe.prototype.imulK = function(b) {
      b.words[b.length] = 0, b.words[b.length + 1] = 0, b.length += 2;
      for (var E = 0, k = 0; k < b.length; k++) {
        var O = b.words[k] | 0;
        E += O * 977, b.words[k] = E & 67108863, E = O * 64 + (E / 67108864 | 0);
      }
      return b.words[b.length - 1] === 0 && (b.length--, b.words[b.length - 1] === 0 && b.length--), b;
    };
    function be() {
      he.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(be, he);
    function ke() {
      he.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(ke, he);
    function _e() {
      he.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(_e, he), _e.prototype.imulK = function(b) {
      for (var E = 0, k = 0; k < b.length; k++) {
        var O = (b.words[k] | 0) * 19 + E, A = O & 67108863;
        O >>>= 26, b.words[k] = A, E = O;
      }
      return E !== 0 && (b.words[b.length++] = E), b;
    }, p._prime = function(b) {
      if (de[b])
        return de[b];
      var E;
      if (b === "k256")
        E = new pe();
      else if (b === "p224")
        E = new be();
      else if (b === "p192")
        E = new ke();
      else if (b === "p25519")
        E = new _e();
      else
        throw new Error("Unknown prime " + b);
      return de[b] = E, E;
    };
    function q(C) {
      if (typeof C == "string") {
        var b = p._prime(C);
        this.m = b.p, this.prime = b;
      } else
        l(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    q.prototype._verify1 = function(b) {
      l(b.negative === 0, "red works only with positives"), l(b.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(b, E) {
      l((b.negative | E.negative) === 0, "red works only with positives"), l(
        b.red && b.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(b) {
      return this.prime ? this.prime.ireduce(b)._forceRed(this) : b.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(b) {
      return b.isZero() ? b.clone() : this.m.sub(b)._forceRed(this);
    }, q.prototype.add = function(b, E) {
      this._verify2(b, E);
      var k = b.add(E);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k._forceRed(this);
    }, q.prototype.iadd = function(b, E) {
      this._verify2(b, E);
      var k = b.iadd(E);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k;
    }, q.prototype.sub = function(b, E) {
      this._verify2(b, E);
      var k = b.sub(E);
      return k.cmpn(0) < 0 && k.iadd(this.m), k._forceRed(this);
    }, q.prototype.isub = function(b, E) {
      this._verify2(b, E);
      var k = b.isub(E);
      return k.cmpn(0) < 0 && k.iadd(this.m), k;
    }, q.prototype.shl = function(b, E) {
      return this._verify1(b), this.imod(b.ushln(E));
    }, q.prototype.imul = function(b, E) {
      return this._verify2(b, E), this.imod(b.imul(E));
    }, q.prototype.mul = function(b, E) {
      return this._verify2(b, E), this.imod(b.mul(E));
    }, q.prototype.isqr = function(b) {
      return this.imul(b, b.clone());
    }, q.prototype.sqr = function(b) {
      return this.mul(b, b);
    }, q.prototype.sqrt = function(b) {
      if (b.isZero())
        return b.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var k = this.m.add(new p(1)).iushrn(2);
        return this.pow(b, k);
      }
      for (var O = this.m.subn(1), A = 0; !O.isZero() && O.andln(1) === 0; )
        A++, O.iushrn(1);
      l(!O.isZero());
      var x = new p(1).toRed(this), Y = x.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var D = this.pow(T, O), te = this.pow(b, O.addn(1).iushrn(1)), me = this.pow(b, O), Ie = A; me.cmp(x) !== 0; ) {
        for (var $e = me, ye = 0; $e.cmp(x) !== 0; ye++)
          $e = $e.redSqr();
        l(ye < Ie);
        var fe = this.pow(D, new p(1).iushln(Ie - ye - 1));
        te = te.redMul(fe), D = fe.redSqr(), me = me.redMul(D), Ie = ye;
      }
      return te;
    }, q.prototype.invm = function(b) {
      var E = b._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(b, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return b.clone();
      var k = 4, O = new Array(1 << k);
      O[0] = new p(1).toRed(this), O[1] = b;
      for (var A = 2; A < O.length; A++)
        O[A] = this.mul(O[A - 1], b);
      var x = O[0], Y = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), A = E.length - 1; A >= 0; A--) {
        for (var D = E.words[A], te = T - 1; te >= 0; te--) {
          var me = D >> te & 1;
          if (x !== O[0] && (x = this.sqr(x)), me === 0 && Y === 0) {
            B = 0;
            continue;
          }
          Y <<= 1, Y |= me, B++, !(B !== k && (A !== 0 || te !== 0)) && (x = this.mul(x, O[Y]), B = 0, Y = 0);
        }
        T = 26;
      }
      return x;
    }, q.prototype.convertTo = function(b) {
      var E = b.umod(this.m);
      return E === b ? E.clone() : E;
    }, q.prototype.convertFrom = function(b) {
      var E = b.clone();
      return E.red = null, E;
    }, p.mont = function(b) {
      return new z(b);
    };
    function z(C) {
      q.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, q), z.prototype.convertTo = function(b) {
      return this.imod(b.ushln(this.shift));
    }, z.prototype.convertFrom = function(b) {
      var E = this.imod(b.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(b, E) {
      if (b.isZero() || E.isZero())
        return b.words[0] = 0, b.length = 1, b;
      var k = b.imul(E), O = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = k.isub(O).iushrn(this.shift), x = A;
      return A.cmp(this.m) >= 0 ? x = A.isub(this.m) : A.cmpn(0) < 0 && (x = A.iadd(this.m)), x._forceRed(this);
    }, z.prototype.mul = function(b, E) {
      if (b.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var k = b.mul(E), O = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = k.isub(O).iushrn(this.shift), x = A;
      return A.cmp(this.m) >= 0 ? x = A.isub(this.m) : A.cmpn(0) < 0 && (x = A.iadd(this.m)), x._forceRed(this);
    }, z.prototype.invm = function(b) {
      var E = this.imod(b._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$2);
var bnExports$2 = bn$2.exports, api = {}, encoders = {}, buffer$1 = require$$0$2, Buffer$f = buffer$1.Buffer, safer = {}, key;
for (key in buffer$1)
  buffer$1.hasOwnProperty(key) && (key === "SlowBuffer" || key === "Buffer" || (safer[key] = buffer$1[key]));
var Safer = safer.Buffer = {};
for (key in Buffer$f)
  Buffer$f.hasOwnProperty(key) && (key === "allocUnsafe" || key === "allocUnsafeSlow" || (Safer[key] = Buffer$f[key]));
safer.Buffer.prototype = Buffer$f.prototype;
(!Safer.from || Safer.from === Uint8Array.from) && (Safer.from = function(a, u, c) {
  if (typeof a == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof a);
  if (a && typeof a.length > "u")
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof a);
  return Buffer$f(a, u, c);
});
Safer.alloc || (Safer.alloc = function(a, u, c) {
  if (typeof a != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof a);
  if (a < 0 || a >= 2 * (1 << 30))
    throw new RangeError('The value "' + a + '" is invalid for option "size"');
  var l = Buffer$f(a);
  return !u || u.length === 0 ? l.fill(0) : typeof c == "string" ? l.fill(u, c) : l.fill(u), l;
});
if (!safer.kStringMaxLength)
  try {
    safer.kStringMaxLength = process$1.binding("buffer").kStringMaxLength;
  } catch {
  }
safer.constants || (safer.constants = {
  MAX_LENGTH: safer.kMaxLength
}, safer.kStringMaxLength && (safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength));
var safer_1 = safer, reporter = {};
const inherits$5 = inherits_browserExports;
function Reporter$2(a) {
  this._reporterState = {
    obj: null,
    path: [],
    options: a || {},
    errors: []
  };
}
reporter.Reporter = Reporter$2;
Reporter$2.prototype.isError = function a(u) {
  return u instanceof ReporterError;
};
Reporter$2.prototype.save = function a() {
  const u = this._reporterState;
  return { obj: u.obj, pathLen: u.path.length };
};
Reporter$2.prototype.restore = function a(u) {
  const c = this._reporterState;
  c.obj = u.obj, c.path = c.path.slice(0, u.pathLen);
};
Reporter$2.prototype.enterKey = function a(u) {
  return this._reporterState.path.push(u);
};
Reporter$2.prototype.exitKey = function a(u) {
  const c = this._reporterState;
  c.path = c.path.slice(0, u - 1);
};
Reporter$2.prototype.leaveKey = function a(u, c, l) {
  const v = this._reporterState;
  this.exitKey(u), v.obj !== null && (v.obj[c] = l);
};
Reporter$2.prototype.path = function a() {
  return this._reporterState.path.join("/");
};
Reporter$2.prototype.enterObject = function a() {
  const u = this._reporterState, c = u.obj;
  return u.obj = {}, c;
};
Reporter$2.prototype.leaveObject = function a(u) {
  const c = this._reporterState, l = c.obj;
  return c.obj = u, l;
};
Reporter$2.prototype.error = function a(u) {
  let c;
  const l = this._reporterState, v = u instanceof ReporterError;
  if (v ? c = u : c = new ReporterError(l.path.map(function(p) {
    return "[" + JSON.stringify(p) + "]";
  }).join(""), u.message || u, u.stack), !l.options.partial)
    throw c;
  return v || l.errors.push(c), c;
};
Reporter$2.prototype.wrapResult = function a(u) {
  const c = this._reporterState;
  return c.options.partial ? {
    result: this.isError(u) ? null : u,
    errors: c.errors
  } : u;
};
function ReporterError(a, u) {
  this.path = a, this.rethrow(u);
}
inherits$5(ReporterError, Error);
ReporterError.prototype.rethrow = function a(u) {
  if (this.message = u + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (c) {
      this.stack = c.stack;
    }
  return this;
};
var buffer = {};
const inherits$4 = inherits_browserExports, Reporter$1 = reporter.Reporter, Buffer$e = safer_1.Buffer;
function DecoderBuffer$2(a, u) {
  if (Reporter$1.call(this, u), !Buffer$e.isBuffer(a)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = a, this.offset = 0, this.length = a.length;
}
inherits$4(DecoderBuffer$2, Reporter$1);
buffer.DecoderBuffer = DecoderBuffer$2;
DecoderBuffer$2.isDecoderBuffer = function a(u) {
  return u instanceof DecoderBuffer$2 ? !0 : typeof u == "object" && Buffer$e.isBuffer(u.base) && u.constructor.name === "DecoderBuffer" && typeof u.offset == "number" && typeof u.length == "number" && typeof u.save == "function" && typeof u.restore == "function" && typeof u.isEmpty == "function" && typeof u.readUInt8 == "function" && typeof u.skip == "function" && typeof u.raw == "function";
};
DecoderBuffer$2.prototype.save = function a() {
  return { offset: this.offset, reporter: Reporter$1.prototype.save.call(this) };
};
DecoderBuffer$2.prototype.restore = function a(u) {
  const c = new DecoderBuffer$2(this.base);
  return c.offset = u.offset, c.length = this.offset, this.offset = u.offset, Reporter$1.prototype.restore.call(this, u.reporter), c;
};
DecoderBuffer$2.prototype.isEmpty = function a() {
  return this.offset === this.length;
};
DecoderBuffer$2.prototype.readUInt8 = function a(u) {
  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(u || "DecoderBuffer overrun");
};
DecoderBuffer$2.prototype.skip = function a(u, c) {
  if (!(this.offset + u <= this.length))
    return this.error(c || "DecoderBuffer overrun");
  const l = new DecoderBuffer$2(this.base);
  return l._reporterState = this._reporterState, l.offset = this.offset, l.length = this.offset + u, this.offset += u, l;
};
DecoderBuffer$2.prototype.raw = function a(u) {
  return this.base.slice(u ? u.offset : this.offset, this.length);
};
function EncoderBuffer$1(a, u) {
  if (Array.isArray(a))
    this.length = 0, this.value = a.map(function(c) {
      return EncoderBuffer$1.isEncoderBuffer(c) || (c = new EncoderBuffer$1(c, u)), this.length += c.length, c;
    }, this);
  else if (typeof a == "number") {
    if (!(0 <= a && a <= 255))
      return u.error("non-byte EncoderBuffer value");
    this.value = a, this.length = 1;
  } else if (typeof a == "string")
    this.value = a, this.length = Buffer$e.byteLength(a);
  else if (Buffer$e.isBuffer(a))
    this.value = a, this.length = a.length;
  else
    return u.error("Unsupported type: " + typeof a);
}
buffer.EncoderBuffer = EncoderBuffer$1;
EncoderBuffer$1.isEncoderBuffer = function a(u) {
  return u instanceof EncoderBuffer$1 ? !0 : typeof u == "object" && u.constructor.name === "EncoderBuffer" && typeof u.length == "number" && typeof u.join == "function";
};
EncoderBuffer$1.prototype.join = function a(u, c) {
  return u || (u = Buffer$e.alloc(this.length)), c || (c = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(l) {
    l.join(u, c), c += l.length;
  }) : (typeof this.value == "number" ? u[c] = this.value : typeof this.value == "string" ? u.write(this.value, c) : Buffer$e.isBuffer(this.value) && this.value.copy(u, c), c += this.length)), u;
};
const Reporter = reporter.Reporter, EncoderBuffer = buffer.EncoderBuffer, DecoderBuffer$1 = buffer.DecoderBuffer, assert = minimalisticAssert, tags = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
], methods = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(tags), overrided = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function Node$2(a, u, c) {
  const l = {};
  this._baseState = l, l.name = c, l.enc = a, l.parent = u || null, l.children = null, l.tag = null, l.args = null, l.reverseArgs = null, l.choice = null, l.optional = !1, l.any = !1, l.obj = !1, l.use = null, l.useDecoder = null, l.key = null, l.default = null, l.explicit = null, l.implicit = null, l.contains = null, l.parent || (l.children = [], this._wrap());
}
var node = Node$2;
const stateProps = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
Node$2.prototype.clone = function a() {
  const u = this._baseState, c = {};
  stateProps.forEach(function(v) {
    c[v] = u[v];
  });
  const l = new this.constructor(c.parent);
  return l._baseState = c, l;
};
Node$2.prototype._wrap = function a() {
  const u = this._baseState;
  methods.forEach(function(c) {
    this[c] = function() {
      const v = new this.constructor(this);
      return u.children.push(v), v[c].apply(v, arguments);
    };
  }, this);
};
Node$2.prototype._init = function a(u) {
  const c = this._baseState;
  assert(c.parent === null), u.call(this), c.children = c.children.filter(function(l) {
    return l._baseState.parent === this;
  }, this), assert.equal(c.children.length, 1, "Root node can have only one child");
};
Node$2.prototype._useArgs = function a(u) {
  const c = this._baseState, l = u.filter(function(v) {
    return v instanceof this.constructor;
  }, this);
  u = u.filter(function(v) {
    return !(v instanceof this.constructor);
  }, this), l.length !== 0 && (assert(c.children === null), c.children = l, l.forEach(function(v) {
    v._baseState.parent = this;
  }, this)), u.length !== 0 && (assert(c.args === null), c.args = u, c.reverseArgs = u.map(function(v) {
    if (typeof v != "object" || v.constructor !== Object)
      return v;
    const p = {};
    return Object.keys(v).forEach(function(_) {
      _ == (_ | 0) && (_ |= 0);
      const I = v[_];
      p[I] = _;
    }), p;
  }));
};
overrided.forEach(function(a) {
  Node$2.prototype[a] = function() {
    const c = this._baseState;
    throw new Error(a + " not implemented for encoding: " + c.enc);
  };
});
tags.forEach(function(a) {
  Node$2.prototype[a] = function() {
    const c = this._baseState, l = Array.prototype.slice.call(arguments);
    return assert(c.tag === null), c.tag = a, this._useArgs(l), this;
  };
});
Node$2.prototype.use = function a(u) {
  assert(u);
  const c = this._baseState;
  return assert(c.use === null), c.use = u, this;
};
Node$2.prototype.optional = function a() {
  const u = this._baseState;
  return u.optional = !0, this;
};
Node$2.prototype.def = function a(u) {
  const c = this._baseState;
  return assert(c.default === null), c.default = u, c.optional = !0, this;
};
Node$2.prototype.explicit = function a(u) {
  const c = this._baseState;
  return assert(c.explicit === null && c.implicit === null), c.explicit = u, this;
};
Node$2.prototype.implicit = function a(u) {
  const c = this._baseState;
  return assert(c.explicit === null && c.implicit === null), c.implicit = u, this;
};
Node$2.prototype.obj = function a() {
  const u = this._baseState, c = Array.prototype.slice.call(arguments);
  return u.obj = !0, c.length !== 0 && this._useArgs(c), this;
};
Node$2.prototype.key = function a(u) {
  const c = this._baseState;
  return assert(c.key === null), c.key = u, this;
};
Node$2.prototype.any = function a() {
  const u = this._baseState;
  return u.any = !0, this;
};
Node$2.prototype.choice = function a(u) {
  const c = this._baseState;
  return assert(c.choice === null), c.choice = u, this._useArgs(Object.keys(u).map(function(l) {
    return u[l];
  })), this;
};
Node$2.prototype.contains = function a(u) {
  const c = this._baseState;
  return assert(c.use === null), c.contains = u, this;
};
Node$2.prototype._decode = function a(u, c) {
  const l = this._baseState;
  if (l.parent === null)
    return u.wrapResult(l.children[0]._decode(u, c));
  let v = l.default, p = !0, _ = null;
  if (l.key !== null && (_ = u.enterKey(l.key)), l.optional) {
    let P = null;
    if (l.explicit !== null ? P = l.explicit : l.implicit !== null ? P = l.implicit : l.tag !== null && (P = l.tag), P === null && !l.any) {
      const $ = u.save();
      try {
        l.choice === null ? this._decodeGeneric(l.tag, u, c) : this._decodeChoice(u, c), p = !0;
      } catch {
        p = !1;
      }
      u.restore($);
    } else if (p = this._peekTag(u, P, l.any), u.isError(p))
      return p;
  }
  let I;
  if (l.obj && p && (I = u.enterObject()), p) {
    if (l.explicit !== null) {
      const $ = this._decodeTag(u, l.explicit);
      if (u.isError($))
        return $;
      u = $;
    }
    const P = u.offset;
    if (l.use === null && l.choice === null) {
      let $;
      l.any && ($ = u.save());
      const F = this._decodeTag(
        u,
        l.implicit !== null ? l.implicit : l.tag,
        l.any
      );
      if (u.isError(F))
        return F;
      l.any ? v = u.raw($) : u = F;
    }
    if (c && c.track && l.tag !== null && c.track(u.path(), P, u.length, "tagged"), c && c.track && l.tag !== null && c.track(u.path(), u.offset, u.length, "content"), l.any || (l.choice === null ? v = this._decodeGeneric(l.tag, u, c) : v = this._decodeChoice(u, c)), u.isError(v))
      return v;
    if (!l.any && l.choice === null && l.children !== null && l.children.forEach(function(F) {
      F._decode(u, c);
    }), l.contains && (l.tag === "octstr" || l.tag === "bitstr")) {
      const $ = new DecoderBuffer$1(v);
      v = this._getUse(l.contains, u._reporterState.obj)._decode($, c);
    }
  }
  return l.obj && p && (v = u.leaveObject(I)), l.key !== null && (v !== null || p === !0) ? u.leaveKey(_, l.key, v) : _ !== null && u.exitKey(_), v;
};
Node$2.prototype._decodeGeneric = function a(u, c, l) {
  const v = this._baseState;
  return u === "seq" || u === "set" ? null : u === "seqof" || u === "setof" ? this._decodeList(c, u, v.args[0], l) : /str$/.test(u) ? this._decodeStr(c, u, l) : u === "objid" && v.args ? this._decodeObjid(c, v.args[0], v.args[1], l) : u === "objid" ? this._decodeObjid(c, null, null, l) : u === "gentime" || u === "utctime" ? this._decodeTime(c, u, l) : u === "null_" ? this._decodeNull(c, l) : u === "bool" ? this._decodeBool(c, l) : u === "objDesc" ? this._decodeStr(c, u, l) : u === "int" || u === "enum" ? this._decodeInt(c, v.args && v.args[0], l) : v.use !== null ? this._getUse(v.use, c._reporterState.obj)._decode(c, l) : c.error("unknown tag: " + u);
};
Node$2.prototype._getUse = function a(u, c) {
  const l = this._baseState;
  return l.useDecoder = this._use(u, c), assert(l.useDecoder._baseState.parent === null), l.useDecoder = l.useDecoder._baseState.children[0], l.implicit !== l.useDecoder._baseState.implicit && (l.useDecoder = l.useDecoder.clone(), l.useDecoder._baseState.implicit = l.implicit), l.useDecoder;
};
Node$2.prototype._decodeChoice = function a(u, c) {
  const l = this._baseState;
  let v = null, p = !1;
  return Object.keys(l.choice).some(function(_) {
    const I = u.save(), P = l.choice[_];
    try {
      const $ = P._decode(u, c);
      if (u.isError($))
        return !1;
      v = { type: _, value: $ }, p = !0;
    } catch {
      return u.restore(I), !1;
    }
    return !0;
  }, this), p ? v : u.error("Choice not matched");
};
Node$2.prototype._createEncoderBuffer = function a(u) {
  return new EncoderBuffer(u, this.reporter);
};
Node$2.prototype._encode = function a(u, c, l) {
  const v = this._baseState;
  if (v.default !== null && v.default === u)
    return;
  const p = this._encodeValue(u, c, l);
  if (p !== void 0 && !this._skipDefault(p, c, l))
    return p;
};
Node$2.prototype._encodeValue = function a(u, c, l) {
  const v = this._baseState;
  if (v.parent === null)
    return v.children[0]._encode(u, c || new Reporter());
  let p = null;
  if (this.reporter = c, v.optional && u === void 0)
    if (v.default !== null)
      u = v.default;
    else
      return;
  let _ = null, I = !1;
  if (v.any)
    p = this._createEncoderBuffer(u);
  else if (v.choice)
    p = this._encodeChoice(u, c);
  else if (v.contains)
    _ = this._getUse(v.contains, l)._encode(u, c), I = !0;
  else if (v.children)
    _ = v.children.map(function(P) {
      if (P._baseState.tag === "null_")
        return P._encode(null, c, u);
      if (P._baseState.key === null)
        return c.error("Child should have a key");
      const $ = c.enterKey(P._baseState.key);
      if (typeof u != "object")
        return c.error("Child expected, but input is not object");
      const F = P._encode(u[P._baseState.key], c, u);
      return c.leaveKey($), F;
    }, this).filter(function(P) {
      return P;
    }), _ = this._createEncoderBuffer(_);
  else if (v.tag === "seqof" || v.tag === "setof") {
    if (!(v.args && v.args.length === 1))
      return c.error("Too many args for : " + v.tag);
    if (!Array.isArray(u))
      return c.error("seqof/setof, but data is not Array");
    const P = this.clone();
    P._baseState.implicit = null, _ = this._createEncoderBuffer(u.map(function($) {
      const F = this._baseState;
      return this._getUse(F.args[0], u)._encode($, c);
    }, P));
  } else
    v.use !== null ? p = this._getUse(v.use, l)._encode(u, c) : (_ = this._encodePrimitive(v.tag, u), I = !0);
  if (!v.any && v.choice === null) {
    const P = v.implicit !== null ? v.implicit : v.tag, $ = v.implicit === null ? "universal" : "context";
    P === null ? v.use === null && c.error("Tag could be omitted only for .use()") : v.use === null && (p = this._encodeComposite(P, I, $, _));
  }
  return v.explicit !== null && (p = this._encodeComposite(v.explicit, !1, "context", p)), p;
};
Node$2.prototype._encodeChoice = function a(u, c) {
  const l = this._baseState, v = l.choice[u.type];
  return v || assert(
    !1,
    u.type + " not found in " + JSON.stringify(Object.keys(l.choice))
  ), v._encode(u.value, c);
};
Node$2.prototype._encodePrimitive = function a(u, c) {
  const l = this._baseState;
  if (/str$/.test(u))
    return this._encodeStr(c, u);
  if (u === "objid" && l.args)
    return this._encodeObjid(c, l.reverseArgs[0], l.args[1]);
  if (u === "objid")
    return this._encodeObjid(c, null, null);
  if (u === "gentime" || u === "utctime")
    return this._encodeTime(c, u);
  if (u === "null_")
    return this._encodeNull();
  if (u === "int" || u === "enum")
    return this._encodeInt(c, l.args && l.reverseArgs[0]);
  if (u === "bool")
    return this._encodeBool(c);
  if (u === "objDesc")
    return this._encodeStr(c, u);
  throw new Error("Unsupported tag: " + u);
};
Node$2.prototype._isNumstr = function a(u) {
  return /^[0-9 ]*$/.test(u);
};
Node$2.prototype._isPrintstr = function a(u) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(u);
};
var der$2 = {};
(function(a) {
  function u(c) {
    const l = {};
    return Object.keys(c).forEach(function(v) {
      (v | 0) == v && (v = v | 0);
      const p = c[v];
      l[p] = v;
    }), l;
  }
  a.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  }, a.tagClassByName = u(a.tagClass), a.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  }, a.tagByName = u(a.tag);
})(der$2);
const inherits$3 = inherits_browserExports, Buffer$d = safer_1.Buffer, Node$1 = node, der$1 = der$2;
function DEREncoder$1(a) {
  this.enc = "der", this.name = a.name, this.entity = a, this.tree = new DERNode$1(), this.tree._init(a.body);
}
var der_1$1 = DEREncoder$1;
DEREncoder$1.prototype.encode = function a(u, c) {
  return this.tree._encode(u, c).join();
};
function DERNode$1(a) {
  Node$1.call(this, "der", a);
}
inherits$3(DERNode$1, Node$1);
DERNode$1.prototype._encodeComposite = function a(u, c, l, v) {
  const p = encodeTag(u, c, l, this.reporter);
  if (v.length < 128) {
    const P = Buffer$d.alloc(2);
    return P[0] = p, P[1] = v.length, this._createEncoderBuffer([P, v]);
  }
  let _ = 1;
  for (let P = v.length; P >= 256; P >>= 8)
    _++;
  const I = Buffer$d.alloc(2 + _);
  I[0] = p, I[1] = 128 | _;
  for (let P = 1 + _, $ = v.length; $ > 0; P--, $ >>= 8)
    I[P] = $ & 255;
  return this._createEncoderBuffer([I, v]);
};
DERNode$1.prototype._encodeStr = function a(u, c) {
  if (c === "bitstr")
    return this._createEncoderBuffer([u.unused | 0, u.data]);
  if (c === "bmpstr") {
    const l = Buffer$d.alloc(u.length * 2);
    for (let v = 0; v < u.length; v++)
      l.writeUInt16BE(u.charCodeAt(v), v * 2);
    return this._createEncoderBuffer(l);
  } else
    return c === "numstr" ? this._isNumstr(u) ? this._createEncoderBuffer(u) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : c === "printstr" ? this._isPrintstr(u) ? this._createEncoderBuffer(u) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(c) ? this._createEncoderBuffer(u) : c === "objDesc" ? this._createEncoderBuffer(u) : this.reporter.error("Encoding of string type: " + c + " unsupported");
};
DERNode$1.prototype._encodeObjid = function a(u, c, l) {
  if (typeof u == "string") {
    if (!c)
      return this.reporter.error("string objid given, but no values map found");
    if (!c.hasOwnProperty(u))
      return this.reporter.error("objid not found in values map");
    u = c[u].split(/[\s.]+/g);
    for (let I = 0; I < u.length; I++)
      u[I] |= 0;
  } else if (Array.isArray(u)) {
    u = u.slice();
    for (let I = 0; I < u.length; I++)
      u[I] |= 0;
  }
  if (!Array.isArray(u))
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(u));
  if (!l) {
    if (u[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    u.splice(0, 2, u[0] * 40 + u[1]);
  }
  let v = 0;
  for (let I = 0; I < u.length; I++) {
    let P = u[I];
    for (v++; P >= 128; P >>= 7)
      v++;
  }
  const p = Buffer$d.alloc(v);
  let _ = p.length - 1;
  for (let I = u.length - 1; I >= 0; I--) {
    let P = u[I];
    for (p[_--] = P & 127; (P >>= 7) > 0; )
      p[_--] = 128 | P & 127;
  }
  return this._createEncoderBuffer(p);
};
function two(a) {
  return a < 10 ? "0" + a : a;
}
DERNode$1.prototype._encodeTime = function a(u, c) {
  let l;
  const v = new Date(u);
  return c === "gentime" ? l = [
    two(v.getUTCFullYear()),
    two(v.getUTCMonth() + 1),
    two(v.getUTCDate()),
    two(v.getUTCHours()),
    two(v.getUTCMinutes()),
    two(v.getUTCSeconds()),
    "Z"
  ].join("") : c === "utctime" ? l = [
    two(v.getUTCFullYear() % 100),
    two(v.getUTCMonth() + 1),
    two(v.getUTCDate()),
    two(v.getUTCHours()),
    two(v.getUTCMinutes()),
    two(v.getUTCSeconds()),
    "Z"
  ].join("") : this.reporter.error("Encoding " + c + " time is not supported yet"), this._encodeStr(l, "octstr");
};
DERNode$1.prototype._encodeNull = function a() {
  return this._createEncoderBuffer("");
};
DERNode$1.prototype._encodeInt = function a(u, c) {
  if (typeof u == "string") {
    if (!c)
      return this.reporter.error("String int or enum given, but no values map");
    if (!c.hasOwnProperty(u))
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(u));
    u = c[u];
  }
  if (typeof u != "number" && !Buffer$d.isBuffer(u)) {
    const p = u.toArray();
    !u.sign && p[0] & 128 && p.unshift(0), u = Buffer$d.from(p);
  }
  if (Buffer$d.isBuffer(u)) {
    let p = u.length;
    u.length === 0 && p++;
    const _ = Buffer$d.alloc(p);
    return u.copy(_), u.length === 0 && (_[0] = 0), this._createEncoderBuffer(_);
  }
  if (u < 128)
    return this._createEncoderBuffer(u);
  if (u < 256)
    return this._createEncoderBuffer([0, u]);
  let l = 1;
  for (let p = u; p >= 256; p >>= 8)
    l++;
  const v = new Array(l);
  for (let p = v.length - 1; p >= 0; p--)
    v[p] = u & 255, u >>= 8;
  return v[0] & 128 && v.unshift(0), this._createEncoderBuffer(Buffer$d.from(v));
};
DERNode$1.prototype._encodeBool = function a(u) {
  return this._createEncoderBuffer(u ? 255 : 0);
};
DERNode$1.prototype._use = function a(u, c) {
  return typeof u == "function" && (u = u(c)), u._getEncoder("der").tree;
};
DERNode$1.prototype._skipDefault = function a(u, c, l) {
  const v = this._baseState;
  let p;
  if (v.default === null)
    return !1;
  const _ = u.join();
  if (v.defaultBuffer === void 0 && (v.defaultBuffer = this._encodeValue(v.default, c, l).join()), _.length !== v.defaultBuffer.length)
    return !1;
  for (p = 0; p < _.length; p++)
    if (_[p] !== v.defaultBuffer[p])
      return !1;
  return !0;
};
function encodeTag(a, u, c, l) {
  let v;
  if (a === "seqof" ? a = "seq" : a === "setof" && (a = "set"), der$1.tagByName.hasOwnProperty(a))
    v = der$1.tagByName[a];
  else if (typeof a == "number" && (a | 0) === a)
    v = a;
  else
    return l.error("Unknown tag: " + a);
  return v >= 31 ? l.error("Multi-octet tag encoding unsupported") : (u || (v |= 32), v |= der$1.tagClassByName[c || "universal"] << 6, v);
}
const inherits$2 = inherits_browserExports, DEREncoder = der_1$1;
function PEMEncoder(a) {
  DEREncoder.call(this, a), this.enc = "pem";
}
inherits$2(PEMEncoder, DEREncoder);
var pem$1 = PEMEncoder;
PEMEncoder.prototype.encode = function a(u, c) {
  const v = DEREncoder.prototype.encode.call(this, u).toString("base64"), p = ["-----BEGIN " + c.label + "-----"];
  for (let _ = 0; _ < v.length; _ += 64)
    p.push(v.slice(_, _ + 64));
  return p.push("-----END " + c.label + "-----"), p.join(`
`);
};
(function(a) {
  const u = a;
  u.der = der_1$1, u.pem = pem$1;
})(encoders);
var decoders = {};
const inherits$1 = inherits_browserExports, bignum = bnExports$2, DecoderBuffer = buffer.DecoderBuffer, Node = node, der = der$2;
function DERDecoder$1(a) {
  this.enc = "der", this.name = a.name, this.entity = a, this.tree = new DERNode(), this.tree._init(a.body);
}
var der_1 = DERDecoder$1;
DERDecoder$1.prototype.decode = function a(u, c) {
  return DecoderBuffer.isDecoderBuffer(u) || (u = new DecoderBuffer(u, c)), this.tree._decode(u, c);
};
function DERNode(a) {
  Node.call(this, "der", a);
}
inherits$1(DERNode, Node);
DERNode.prototype._peekTag = function a(u, c, l) {
  if (u.isEmpty())
    return !1;
  const v = u.save(), p = derDecodeTag(u, 'Failed to peek tag: "' + c + '"');
  return u.isError(p) ? p : (u.restore(v), p.tag === c || p.tagStr === c || p.tagStr + "of" === c || l);
};
DERNode.prototype._decodeTag = function a(u, c, l) {
  const v = derDecodeTag(
    u,
    'Failed to decode tag of "' + c + '"'
  );
  if (u.isError(v))
    return v;
  let p = derDecodeLen(
    u,
    v.primitive,
    'Failed to get length of "' + c + '"'
  );
  if (u.isError(p))
    return p;
  if (!l && v.tag !== c && v.tagStr !== c && v.tagStr + "of" !== c)
    return u.error('Failed to match tag: "' + c + '"');
  if (v.primitive || p !== null)
    return u.skip(p, 'Failed to match body of: "' + c + '"');
  const _ = u.save(), I = this._skipUntilEnd(
    u,
    'Failed to skip indefinite length body: "' + this.tag + '"'
  );
  return u.isError(I) ? I : (p = u.offset - _.offset, u.restore(_), u.skip(p, 'Failed to match body of: "' + c + '"'));
};
DERNode.prototype._skipUntilEnd = function a(u, c) {
  for (; ; ) {
    const l = derDecodeTag(u, c);
    if (u.isError(l))
      return l;
    const v = derDecodeLen(u, l.primitive, c);
    if (u.isError(v))
      return v;
    let p;
    if (l.primitive || v !== null ? p = u.skip(v) : p = this._skipUntilEnd(u, c), u.isError(p))
      return p;
    if (l.tagStr === "end")
      break;
  }
};
DERNode.prototype._decodeList = function a(u, c, l, v) {
  const p = [];
  for (; !u.isEmpty(); ) {
    const _ = this._peekTag(u, "end");
    if (u.isError(_))
      return _;
    const I = l.decode(u, "der", v);
    if (u.isError(I) && _)
      break;
    p.push(I);
  }
  return p;
};
DERNode.prototype._decodeStr = function a(u, c) {
  if (c === "bitstr") {
    const l = u.readUInt8();
    return u.isError(l) ? l : { unused: l, data: u.raw() };
  } else if (c === "bmpstr") {
    const l = u.raw();
    if (l.length % 2 === 1)
      return u.error("Decoding of string type: bmpstr length mismatch");
    let v = "";
    for (let p = 0; p < l.length / 2; p++)
      v += String.fromCharCode(l.readUInt16BE(p * 2));
    return v;
  } else if (c === "numstr") {
    const l = u.raw().toString("ascii");
    return this._isNumstr(l) ? l : u.error("Decoding of string type: numstr unsupported characters");
  } else {
    if (c === "octstr")
      return u.raw();
    if (c === "objDesc")
      return u.raw();
    if (c === "printstr") {
      const l = u.raw().toString("ascii");
      return this._isPrintstr(l) ? l : u.error("Decoding of string type: printstr unsupported characters");
    } else
      return /str$/.test(c) ? u.raw().toString() : u.error("Decoding of string type: " + c + " unsupported");
  }
};
DERNode.prototype._decodeObjid = function a(u, c, l) {
  let v;
  const p = [];
  let _ = 0, I = 0;
  for (; !u.isEmpty(); )
    I = u.readUInt8(), _ <<= 7, _ |= I & 127, I & 128 || (p.push(_), _ = 0);
  I & 128 && p.push(_);
  const P = p[0] / 40 | 0, $ = p[0] % 40;
  if (l ? v = p : v = [P, $].concat(p.slice(1)), c) {
    let F = c[v.join(" ")];
    F === void 0 && (F = c[v.join(".")]), F !== void 0 && (v = F);
  }
  return v;
};
DERNode.prototype._decodeTime = function a(u, c) {
  const l = u.raw().toString();
  let v, p, _, I, P, $;
  if (c === "gentime")
    v = l.slice(0, 4) | 0, p = l.slice(4, 6) | 0, _ = l.slice(6, 8) | 0, I = l.slice(8, 10) | 0, P = l.slice(10, 12) | 0, $ = l.slice(12, 14) | 0;
  else if (c === "utctime")
    v = l.slice(0, 2) | 0, p = l.slice(2, 4) | 0, _ = l.slice(4, 6) | 0, I = l.slice(6, 8) | 0, P = l.slice(8, 10) | 0, $ = l.slice(10, 12) | 0, v < 70 ? v = 2e3 + v : v = 1900 + v;
  else
    return u.error("Decoding " + c + " time is not supported yet");
  return Date.UTC(v, p - 1, _, I, P, $, 0);
};
DERNode.prototype._decodeNull = function a() {
  return null;
};
DERNode.prototype._decodeBool = function a(u) {
  const c = u.readUInt8();
  return u.isError(c) ? c : c !== 0;
};
DERNode.prototype._decodeInt = function a(u, c) {
  const l = u.raw();
  let v = new bignum(l);
  return c && (v = c[v.toString(10)] || v), v;
};
DERNode.prototype._use = function a(u, c) {
  return typeof u == "function" && (u = u(c)), u._getDecoder("der").tree;
};
function derDecodeTag(a, u) {
  let c = a.readUInt8(u);
  if (a.isError(c))
    return c;
  const l = der.tagClass[c >> 6], v = (c & 32) === 0;
  if ((c & 31) === 31) {
    let _ = c;
    for (c = 0; (_ & 128) === 128; ) {
      if (_ = a.readUInt8(u), a.isError(_))
        return _;
      c <<= 7, c |= _ & 127;
    }
  } else
    c &= 31;
  const p = der.tag[c];
  return {
    cls: l,
    primitive: v,
    tag: c,
    tagStr: p
  };
}
function derDecodeLen(a, u, c) {
  let l = a.readUInt8(c);
  if (a.isError(l))
    return l;
  if (!u && l === 128)
    return null;
  if (!(l & 128))
    return l;
  const v = l & 127;
  if (v > 4)
    return a.error("length octect is too long");
  l = 0;
  for (let p = 0; p < v; p++) {
    l <<= 8;
    const _ = a.readUInt8(c);
    if (a.isError(_))
      return _;
    l |= _;
  }
  return l;
}
const inherits = inherits_browserExports, Buffer$c = safer_1.Buffer, DERDecoder = der_1;
function PEMDecoder(a) {
  DERDecoder.call(this, a), this.enc = "pem";
}
inherits(PEMDecoder, DERDecoder);
var pem = PEMDecoder;
PEMDecoder.prototype.decode = function a(u, c) {
  const l = u.toString().split(/[\r\n]+/g), v = c.label.toUpperCase(), p = /^-----(BEGIN|END) ([^-]+)-----$/;
  let _ = -1, I = -1;
  for (let F = 0; F < l.length; F++) {
    const H = l[F].match(p);
    if (H !== null && H[2] === v)
      if (_ === -1) {
        if (H[1] !== "BEGIN")
          break;
        _ = F;
      } else {
        if (H[1] !== "END")
          break;
        I = F;
        break;
      }
  }
  if (_ === -1 || I === -1)
    throw new Error("PEM section not found for: " + v);
  const P = l.slice(_ + 1, I).join("");
  P.replace(/[^a-z0-9+/=]+/gi, "");
  const $ = Buffer$c.from(P, "base64");
  return DERDecoder.prototype.decode.call(this, $, c);
};
(function(a) {
  const u = a;
  u.der = der_1, u.pem = pem;
})(decoders);
(function(a) {
  const u = encoders, c = decoders, l = inherits_browserExports, v = a;
  v.define = function(I, P) {
    return new p(I, P);
  };
  function p(_, I) {
    this.name = _, this.body = I, this.decoders = {}, this.encoders = {};
  }
  p.prototype._createNamed = function(I) {
    const P = this.name;
    function $(F) {
      this._initNamed(F, P);
    }
    return l($, I), $.prototype._initNamed = function(H, j) {
      I.call(this, H, j);
    }, new $(this);
  }, p.prototype._getDecoder = function(I) {
    return I = I || "der", this.decoders.hasOwnProperty(I) || (this.decoders[I] = this._createNamed(c[I])), this.decoders[I];
  }, p.prototype.decode = function(I, P, $) {
    return this._getDecoder(P).decode(I, $);
  }, p.prototype._getEncoder = function(I) {
    return I = I || "der", this.encoders.hasOwnProperty(I) || (this.encoders[I] = this._createNamed(u[I])), this.encoders[I];
  }, p.prototype.encode = function(I, P, $) {
    return this._getEncoder(P).encode(I, $);
  };
})(api);
var base = {};
(function(a) {
  const u = a;
  u.Reporter = reporter.Reporter, u.DecoderBuffer = buffer.DecoderBuffer, u.EncoderBuffer = buffer.EncoderBuffer, u.Node = node;
})(base);
var constants = {};
(function(a) {
  const u = a;
  u._reverse = function(l) {
    const v = {};
    return Object.keys(l).forEach(function(p) {
      (p | 0) == p && (p = p | 0);
      const _ = l[p];
      v[_] = p;
    }), v;
  }, u.der = der$2;
})(constants);
(function(a) {
  const u = a;
  u.bignum = bnExports$2, u.define = api.define, u.base = base, u.constants = constants, u.decoders = decoders, u.encoders = encoders;
})(asn1$2);
var asn = asn1$2, Time = asn.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), AlgorithmIdentifier$1 = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
}), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
}), RDNSequence = asn.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
}), Name = asn.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
}), Validity = asn.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
}), Extension = asn.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), TBSCertificate = asn.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$1),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
}), X509Certificate = asn.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$1),
    this.key("signatureValue").bitstr()
  );
}), certificate = X509Certificate, asn1$1 = asn1$2;
asn1$3.certificate = certificate;
var RSAPrivateKey = asn1$1.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$3.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1$1.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$3.RSAPublicKey = RSAPublicKey;
var PublicKey = asn1$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$3.PublicKey = PublicKey;
var AlgorithmIdentifier = asn1$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), PrivateKeyInfo = asn1$1.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1$1.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$1.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$3.DSAPrivateKey = DSAPrivateKey;
asn1$3.DSAparam = asn1$1.define("DSAparam", function() {
  this.int();
});
var ECPrivateKey = asn1$1.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$3.ECPrivateKey = ECPrivateKey;
var ECParameters = asn1$1.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
});
asn1$3.signature = asn1$1.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = evp_bytestokey, ciphers$1 = browser$6, Buffer$b = safeBufferExports$3.Buffer, fixProc$1 = function(a, u) {
  var c = a.toString(), l = c.match(findProc), v;
  if (l) {
    var _ = "aes" + l[1], I = Buffer$b.from(l[2], "hex"), P = Buffer$b.from(l[3].replace(/[\r\n]/g, ""), "base64"), $ = evp(u, I.slice(0, 8), parseInt(l[1], 10)).key, F = [], H = ciphers$1.createDecipheriv(_, $, I);
    F.push(H.update(P)), F.push(H.final()), v = Buffer$b.concat(F);
  } else {
    var p = c.match(fullRegex);
    v = Buffer$b.from(p[2].replace(/[\r\n]/g, ""), "base64");
  }
  var j = c.match(startRegex)[1];
  return {
    tag: j,
    data: v
  };
}, asn1 = asn1$3, aesid = require$$1, fixProc = fixProc$1, ciphers = browser$6, compat = browser$8, Buffer$a = safeBufferExports$3.Buffer, parseAsn1 = parseKeys$2;
function parseKeys$2(a) {
  var u;
  typeof a == "object" && !Buffer$a.isBuffer(a) && (u = a.passphrase, a = a.key), typeof a == "string" && (a = Buffer$a.from(a));
  var c = fixProc(a, u), l = c.tag, v = c.data, p, _;
  switch (l) {
    case "CERTIFICATE":
      _ = asn1.certificate.decode(v, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (_ || (_ = asn1.PublicKey.decode(v, "der")), p = _.algorithm.algorithm.join("."), p) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPublicKey.decode(_.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return _.subjectPrivateKey = _.subjectPublicKey, {
            type: "ec",
            data: _
          };
        case "1.2.840.10040.4.1":
          return _.algorithm.params.pub_key = asn1.DSAparam.decode(_.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: _.algorithm.params
          };
        default:
          throw new Error("unknown key id " + p);
      }
    case "ENCRYPTED PRIVATE KEY":
      v = asn1.EncryptedPrivateKey.decode(v, "der"), v = decrypt(v, u);
    case "PRIVATE KEY":
      switch (_ = asn1.PrivateKey.decode(v, "der"), p = _.algorithm.algorithm.join("."), p) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPrivateKey.decode(_.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: _.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(_.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return _.algorithm.params.priv_key = asn1.DSAparam.decode(_.subjectPrivateKey, "der"), {
            type: "dsa",
            params: _.algorithm.params
          };
        default:
          throw new Error("unknown key id " + p);
      }
    case "RSA PUBLIC KEY":
      return asn1.RSAPublicKey.decode(v, "der");
    case "RSA PRIVATE KEY":
      return asn1.RSAPrivateKey.decode(v, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1.DSAPrivateKey.decode(v, "der")
      };
    case "EC PRIVATE KEY":
      return v = asn1.ECPrivateKey.decode(v, "der"), {
        curve: v.parameters.value,
        privateKey: v.privateKey
      };
    default:
      throw new Error("unknown key type " + l);
  }
}
parseKeys$2.signature = asn1.signature;
function decrypt(a, u) {
  var c = a.algorithm.decrypt.kde.kdeparams.salt, l = parseInt(a.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), v = aesid[a.algorithm.decrypt.cipher.algo.join(".")], p = a.algorithm.decrypt.cipher.iv, _ = a.subjectPrivateKey, I = parseInt(v.split("-")[1], 10) / 8, P = compat.pbkdf2Sync(u, c, l, I, "sha1"), $ = ciphers.createDecipheriv(v, P, p), F = [];
  return F.push($.update(_)), F.push($.final()), Buffer$a.concat(F);
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign)
    return sign$1.exports;
  hasRequiredSign = 1;
  var a = safeBufferExports.Buffer, u = browser$9, c = browserifyRsa, l = requireElliptic().ec, v = bnExports$4, p = parseAsn1, _ = require$$4, I = 1;
  function P(ne, Z, de, he, pe) {
    var be = p(Z);
    if (be.curve) {
      if (he !== "ecdsa" && he !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return $(ne, be);
    } else if (be.type === "dsa") {
      if (he !== "dsa")
        throw new Error("wrong private key type");
      return F(ne, be, de);
    }
    if (he !== "rsa" && he !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (Z.padding !== void 0 && Z.padding !== I)
      throw new Error("illegal or unsupported padding mode");
    ne = a.concat([pe, ne]);
    for (var ke = be.modulus.byteLength(), _e = [0, 1]; ne.length + _e.length + 1 < ke; )
      _e.push(255);
    _e.push(0);
    for (var q = -1; ++q < ne.length; )
      _e.push(ne[q]);
    var z = c(_e, be);
    return z;
  }
  function $(ne, Z) {
    var de = _[Z.curve.join(".")];
    if (!de)
      throw new Error("unknown curve " + Z.curve.join("."));
    var he = new l(de), pe = he.keyFromPrivate(Z.privateKey), be = pe.sign(ne);
    return a.from(be.toDER());
  }
  function F(ne, Z, de) {
    for (var he = Z.params.priv_key, pe = Z.params.p, be = Z.params.q, ke = Z.params.g, _e = new v(0), q, z = ee(ne, be).mod(be), C = !1, b = j(he, be, ne, de); C === !1; )
      q = ie(be, b, de), _e = Q(ke, q, pe, be), C = q.invm(be).imul(z.add(he.mul(_e))).mod(be), C.cmpn(0) === 0 && (C = !1, _e = new v(0));
    return H(_e, C);
  }
  function H(ne, Z) {
    ne = ne.toArray(), Z = Z.toArray(), ne[0] & 128 && (ne = [0].concat(ne)), Z[0] & 128 && (Z = [0].concat(Z));
    var de = ne.length + Z.length + 4, he = [
      48,
      de,
      2,
      ne.length
    ];
    return he = he.concat(ne, [2, Z.length], Z), a.from(he);
  }
  function j(ne, Z, de, he) {
    if (ne = a.from(ne.toArray()), ne.length < Z.byteLength()) {
      var pe = a.alloc(Z.byteLength() - ne.length);
      ne = a.concat([pe, ne]);
    }
    var be = de.length, ke = X(de, Z), _e = a.alloc(be);
    _e.fill(1);
    var q = a.alloc(be);
    return q = u(he, q).update(_e).update(a.from([0])).update(ne).update(ke).digest(), _e = u(he, q).update(_e).digest(), q = u(he, q).update(_e).update(a.from([1])).update(ne).update(ke).digest(), _e = u(he, q).update(_e).digest(), { k: q, v: _e };
  }
  function ee(ne, Z) {
    var de = new v(ne), he = (ne.length << 3) - Z.bitLength();
    return he > 0 && de.ishrn(he), de;
  }
  function X(ne, Z) {
    ne = ee(ne, Z), ne = ne.mod(Z);
    var de = a.from(ne.toArray());
    if (de.length < Z.byteLength()) {
      var he = a.alloc(Z.byteLength() - de.length);
      de = a.concat([he, de]);
    }
    return de;
  }
  function ie(ne, Z, de) {
    var he, pe;
    do {
      for (he = a.alloc(0); he.length * 8 < ne.bitLength(); )
        Z.v = u(de, Z.k).update(Z.v).digest(), he = a.concat([he, Z.v]);
      pe = ee(he, ne), Z.k = u(de, Z.k).update(Z.v).update(a.from([0])).digest(), Z.v = u(de, Z.k).update(Z.v).digest();
    } while (pe.cmp(ne) !== -1);
    return pe;
  }
  function Q(ne, Z, de, he) {
    return ne.toRed(v.mont(de)).redPow(Z).fromRed().mod(he);
  }
  return sign$1.exports = P, sign$1.exports.getKey = j, sign$1.exports.makeKey = ie, sign$1.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify)
    return verify_1;
  hasRequiredVerify = 1;
  var a = safeBufferExports.Buffer, u = bnExports$4, c = requireElliptic().ec, l = parseAsn1, v = require$$4;
  function p($, F, H, j, ee) {
    var X = l(H);
    if (X.type === "ec") {
      if (j !== "ecdsa" && j !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return _($, F, X);
    } else if (X.type === "dsa") {
      if (j !== "dsa")
        throw new Error("wrong public key type");
      return I($, F, X);
    }
    if (j !== "rsa" && j !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    F = a.concat([ee, F]);
    for (var ie = X.modulus.byteLength(), Q = [1], ne = 0; F.length + Q.length + 2 < ie; )
      Q.push(255), ne += 1;
    Q.push(0);
    for (var Z = -1; ++Z < F.length; )
      Q.push(F[Z]);
    Q = a.from(Q);
    var de = u.mont(X.modulus);
    $ = new u($).toRed(de), $ = $.redPow(new u(X.publicExponent)), $ = a.from($.fromRed().toArray());
    var he = ne < 8 ? 1 : 0;
    for (ie = Math.min($.length, Q.length), $.length !== Q.length && (he = 1), Z = -1; ++Z < ie; )
      he |= $[Z] ^ Q[Z];
    return he === 0;
  }
  function _($, F, H) {
    var j = v[H.data.algorithm.curve.join(".")];
    if (!j)
      throw new Error("unknown curve " + H.data.algorithm.curve.join("."));
    var ee = new c(j), X = H.data.subjectPrivateKey.data;
    return ee.verify(F, $, X);
  }
  function I($, F, H) {
    var j = H.data.p, ee = H.data.q, X = H.data.g, ie = H.data.pub_key, Q = l.signature.decode($, "der"), ne = Q.s, Z = Q.r;
    P(ne, ee), P(Z, ee);
    var de = u.mont(j), he = ne.invm(ee), pe = X.toRed(de).redPow(new u(F).mul(he).mod(ee)).fromRed().mul(ie.toRed(de).redPow(Z.mul(he).mod(ee)).fromRed()).mod(j).mod(ee);
    return pe.cmp(Z) === 0;
  }
  function P($, F) {
    if ($.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if ($.cmp(F) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = p, verify_1;
}
var browser$4, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browser$4;
  hasRequiredBrowser$1 = 1;
  var a = safeBufferExports.Buffer, u = browser$a, c = readableBrowserExports, l = inherits_browserExports, v = requireSign(), p = requireVerify(), _ = require$$6;
  Object.keys(_).forEach(function(H) {
    _[H].id = a.from(_[H].id, "hex"), _[H.toLowerCase()] = _[H];
  });
  function I(H) {
    c.Writable.call(this);
    var j = _[H];
    if (!j)
      throw new Error("Unknown message digest");
    this._hashType = j.hash, this._hash = u(j.hash), this._tag = j.id, this._signType = j.sign;
  }
  l(I, c.Writable), I.prototype._write = function(j, ee, X) {
    this._hash.update(j), X();
  }, I.prototype.update = function(j, ee) {
    return this._hash.update(typeof j == "string" ? a.from(j, ee) : j), this;
  }, I.prototype.sign = function(j, ee) {
    this.end();
    var X = this._hash.digest(), ie = v(X, j, this._hashType, this._signType, this._tag);
    return ee ? ie.toString(ee) : ie;
  };
  function P(H) {
    c.Writable.call(this);
    var j = _[H];
    if (!j)
      throw new Error("Unknown message digest");
    this._hash = u(j.hash), this._tag = j.id, this._signType = j.sign;
  }
  l(P, c.Writable), P.prototype._write = function(j, ee, X) {
    this._hash.update(j), X();
  }, P.prototype.update = function(j, ee) {
    return this._hash.update(typeof j == "string" ? a.from(j, ee) : j), this;
  }, P.prototype.verify = function(j, ee, X) {
    var ie = typeof ee == "string" ? a.from(ee, X) : ee;
    this.end();
    var Q = this._hash.digest();
    return p(ie, Q, j, this._signType, this._tag);
  };
  function $(H) {
    return new I(H);
  }
  function F(H) {
    return new P(H);
  }
  return browser$4 = {
    Sign: $,
    Verify: F,
    createSign: $,
    createVerify: F
  }, browser$4;
}
var bn$1 = { exports: {} };
bn$1.exports;
(function(a) {
  (function(u, c) {
    function l(C, b) {
      if (!C)
        throw new Error(b || "Assertion failed");
    }
    function v(C, b) {
      C.super_ = b;
      var E = function() {
      };
      E.prototype = b.prototype, C.prototype = new E(), C.prototype.constructor = C;
    }
    function p(C, b, E) {
      if (p.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((b === "le" || b === "be") && (E = b, b = 10), this._init(C || 0, b || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(b) {
      return b instanceof p ? !0 : b !== null && typeof b == "object" && b.constructor.wordSize === p.wordSize && Array.isArray(b.words);
    }, p.max = function(b, E) {
      return b.cmp(E) > 0 ? b : E;
    }, p.min = function(b, E) {
      return b.cmp(E) < 0 ? b : E;
    }, p.prototype._init = function(b, E, k) {
      if (typeof b == "number")
        return this._initNumber(b, E, k);
      if (typeof b == "object")
        return this._initArray(b, E, k);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), b = b.toString().replace(/\s+/g, "");
      var O = 0;
      b[0] === "-" && (O++, this.negative = 1), O < b.length && (E === 16 ? this._parseHex(b, O, k) : (this._parseBase(b, E, O), k === "le" && this._initArray(this.toArray(), E, k)));
    }, p.prototype._initNumber = function(b, E, k) {
      b < 0 && (this.negative = 1, b = -b), b < 67108864 ? (this.words = [b & 67108863], this.length = 1) : b < 4503599627370496 ? (this.words = [
        b & 67108863,
        b / 67108864 & 67108863
      ], this.length = 2) : (l(b < 9007199254740992), this.words = [
        b & 67108863,
        b / 67108864 & 67108863,
        1
      ], this.length = 3), k === "le" && this._initArray(this.toArray(), E, k);
    }, p.prototype._initArray = function(b, E, k) {
      if (l(typeof b.length == "number"), b.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(b.length / 3), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var A, x, Y = 0;
      if (k === "be")
        for (O = b.length - 1, A = 0; O >= 0; O -= 3)
          x = b[O] | b[O - 1] << 8 | b[O - 2] << 16, this.words[A] |= x << Y & 67108863, this.words[A + 1] = x >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, A++);
      else if (k === "le")
        for (O = 0, A = 0; O < b.length; O += 3)
          x = b[O] | b[O + 1] << 8 | b[O + 2] << 16, this.words[A] |= x << Y & 67108863, this.words[A + 1] = x >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, A++);
      return this.strip();
    };
    function I(C, b) {
      var E = C.charCodeAt(b);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function P(C, b, E) {
      var k = I(C, E);
      return E - 1 >= b && (k |= I(C, E - 1) << 4), k;
    }
    p.prototype._parseHex = function(b, E, k) {
      this.length = Math.ceil((b.length - E) / 6), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var A = 0, x = 0, Y;
      if (k === "be")
        for (O = b.length - 1; O >= E; O -= 2)
          Y = P(b, E, O) << A, this.words[x] |= Y & 67108863, A >= 18 ? (A -= 18, x += 1, this.words[x] |= Y >>> 26) : A += 8;
      else {
        var B = b.length - E;
        for (O = B % 2 === 0 ? E + 1 : E; O < b.length; O += 2)
          Y = P(b, E, O) << A, this.words[x] |= Y & 67108863, A >= 18 ? (A -= 18, x += 1, this.words[x] |= Y >>> 26) : A += 8;
      }
      this.strip();
    };
    function $(C, b, E, k) {
      for (var O = 0, A = Math.min(C.length, E), x = b; x < A; x++) {
        var Y = C.charCodeAt(x) - 48;
        O *= k, Y >= 49 ? O += Y - 49 + 10 : Y >= 17 ? O += Y - 17 + 10 : O += Y;
      }
      return O;
    }
    p.prototype._parseBase = function(b, E, k) {
      this.words = [0], this.length = 1;
      for (var O = 0, A = 1; A <= 67108863; A *= E)
        O++;
      O--, A = A / E | 0;
      for (var x = b.length - k, Y = x % O, B = Math.min(x, x - Y) + k, T = 0, D = k; D < B; D += O)
        T = $(b, D, D + O, E), this.imuln(A), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = $(b, D, b.length, E), D = 0; D < Y; D++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(b) {
      b.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        b.words[E] = this.words[E];
      b.length = this.length, b.negative = this.negative, b.red = this.red;
    }, p.prototype.clone = function() {
      var b = new p(null);
      return this.copy(b), b;
    }, p.prototype._expand = function(b) {
      for (; this.length < b; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], H = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], j = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(b, E) {
      b = b || 10, E = E | 0 || 1;
      var k;
      if (b === 16 || b === "hex") {
        k = "";
        for (var O = 0, A = 0, x = 0; x < this.length; x++) {
          var Y = this.words[x], B = ((Y << O | A) & 16777215).toString(16);
          A = Y >>> 24 - O & 16777215, A !== 0 || x !== this.length - 1 ? k = F[6 - B.length] + B + k : k = B + k, O += 2, O >= 26 && (O -= 26, x--);
        }
        for (A !== 0 && (k = A.toString(16) + k); k.length % E !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      if (b === (b | 0) && b >= 2 && b <= 36) {
        var T = H[b], D = j[b];
        k = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var me = te.modn(D).toString(b);
          te = te.idivn(D), te.isZero() ? k = me + k : k = F[T - me.length] + me + k;
        }
        for (this.isZero() && (k = "0" + k); k.length % E !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var b = this.words[0];
      return this.length === 2 ? b += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? b += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -b : b;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(b, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, b, E);
    }, p.prototype.toArray = function(b, E) {
      return this.toArrayLike(Array, b, E);
    }, p.prototype.toArrayLike = function(b, E, k) {
      var O = this.byteLength(), A = k || Math.max(1, O);
      l(O <= A, "byte array longer than desired length"), l(A > 0, "Requested array length <= 0"), this.strip();
      var x = E === "le", Y = new b(A), B, T, D = this.clone();
      if (x) {
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), Y[T] = B;
        for (; T < A; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < A - O; T++)
          Y[T] = 0;
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), Y[A - T - 1] = B;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(b) {
      return 32 - Math.clz32(b);
    } : p.prototype._countBits = function(b) {
      var E = b, k = 0;
      return E >= 4096 && (k += 13, E >>>= 13), E >= 64 && (k += 7, E >>>= 7), E >= 8 && (k += 4, E >>>= 4), E >= 2 && (k += 2, E >>>= 2), k + E;
    }, p.prototype._zeroBits = function(b) {
      if (b === 0)
        return 26;
      var E = b, k = 0;
      return E & 8191 || (k += 13, E >>>= 13), E & 127 || (k += 7, E >>>= 7), E & 15 || (k += 4, E >>>= 4), E & 3 || (k += 2, E >>>= 2), E & 1 || k++, k;
    }, p.prototype.bitLength = function() {
      var b = this.words[this.length - 1], E = this._countBits(b);
      return (this.length - 1) * 26 + E;
    };
    function ee(C) {
      for (var b = new Array(C.bitLength()), E = 0; E < b.length; E++) {
        var k = E / 26 | 0, O = E % 26;
        b[E] = (C.words[k] & 1 << O) >>> O;
      }
      return b;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var b = 0, E = 0; E < this.length; E++) {
        var k = this._zeroBits(this.words[E]);
        if (b += k, k !== 26)
          break;
      }
      return b;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(b) {
      return this.negative !== 0 ? this.abs().inotn(b).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(b) {
      return this.testn(b - 1) ? this.notn(b).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(b) {
      for (; this.length < b.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < b.length; E++)
        this.words[E] = this.words[E] | b.words[E];
      return this.strip();
    }, p.prototype.ior = function(b) {
      return l((this.negative | b.negative) === 0), this.iuor(b);
    }, p.prototype.or = function(b) {
      return this.length > b.length ? this.clone().ior(b) : b.clone().ior(this);
    }, p.prototype.uor = function(b) {
      return this.length > b.length ? this.clone().iuor(b) : b.clone().iuor(this);
    }, p.prototype.iuand = function(b) {
      var E;
      this.length > b.length ? E = b : E = this;
      for (var k = 0; k < E.length; k++)
        this.words[k] = this.words[k] & b.words[k];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(b) {
      return l((this.negative | b.negative) === 0), this.iuand(b);
    }, p.prototype.and = function(b) {
      return this.length > b.length ? this.clone().iand(b) : b.clone().iand(this);
    }, p.prototype.uand = function(b) {
      return this.length > b.length ? this.clone().iuand(b) : b.clone().iuand(this);
    }, p.prototype.iuxor = function(b) {
      var E, k;
      this.length > b.length ? (E = this, k = b) : (E = b, k = this);
      for (var O = 0; O < k.length; O++)
        this.words[O] = E.words[O] ^ k.words[O];
      if (this !== E)
        for (; O < E.length; O++)
          this.words[O] = E.words[O];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(b) {
      return l((this.negative | b.negative) === 0), this.iuxor(b);
    }, p.prototype.xor = function(b) {
      return this.length > b.length ? this.clone().ixor(b) : b.clone().ixor(this);
    }, p.prototype.uxor = function(b) {
      return this.length > b.length ? this.clone().iuxor(b) : b.clone().iuxor(this);
    }, p.prototype.inotn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = Math.ceil(b / 26) | 0, k = b % 26;
      this._expand(E), k > 0 && E--;
      for (var O = 0; O < E; O++)
        this.words[O] = ~this.words[O] & 67108863;
      return k > 0 && (this.words[O] = ~this.words[O] & 67108863 >> 26 - k), this.strip();
    }, p.prototype.notn = function(b) {
      return this.clone().inotn(b);
    }, p.prototype.setn = function(b, E) {
      l(typeof b == "number" && b >= 0);
      var k = b / 26 | 0, O = b % 26;
      return this._expand(k + 1), E ? this.words[k] = this.words[k] | 1 << O : this.words[k] = this.words[k] & ~(1 << O), this.strip();
    }, p.prototype.iadd = function(b) {
      var E;
      if (this.negative !== 0 && b.negative === 0)
        return this.negative = 0, E = this.isub(b), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && b.negative !== 0)
        return b.negative = 0, E = this.isub(b), b.negative = 1, E._normSign();
      var k, O;
      this.length > b.length ? (k = this, O = b) : (k = b, O = this);
      for (var A = 0, x = 0; x < O.length; x++)
        E = (k.words[x] | 0) + (O.words[x] | 0) + A, this.words[x] = E & 67108863, A = E >>> 26;
      for (; A !== 0 && x < k.length; x++)
        E = (k.words[x] | 0) + A, this.words[x] = E & 67108863, A = E >>> 26;
      if (this.length = k.length, A !== 0)
        this.words[this.length] = A, this.length++;
      else if (k !== this)
        for (; x < k.length; x++)
          this.words[x] = k.words[x];
      return this;
    }, p.prototype.add = function(b) {
      var E;
      return b.negative !== 0 && this.negative === 0 ? (b.negative = 0, E = this.sub(b), b.negative ^= 1, E) : b.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = b.sub(this), this.negative = 1, E) : this.length > b.length ? this.clone().iadd(b) : b.clone().iadd(this);
    }, p.prototype.isub = function(b) {
      if (b.negative !== 0) {
        b.negative = 0;
        var E = this.iadd(b);
        return b.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(b), this.negative = 1, this._normSign();
      var k = this.cmp(b);
      if (k === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var O, A;
      k > 0 ? (O = this, A = b) : (O = b, A = this);
      for (var x = 0, Y = 0; Y < A.length; Y++)
        E = (O.words[Y] | 0) - (A.words[Y] | 0) + x, x = E >> 26, this.words[Y] = E & 67108863;
      for (; x !== 0 && Y < O.length; Y++)
        E = (O.words[Y] | 0) + x, x = E >> 26, this.words[Y] = E & 67108863;
      if (x === 0 && Y < O.length && O !== this)
        for (; Y < O.length; Y++)
          this.words[Y] = O.words[Y];
      return this.length = Math.max(this.length, Y), O !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(b) {
      return this.clone().isub(b);
    };
    function X(C, b, E) {
      E.negative = b.negative ^ C.negative;
      var k = C.length + b.length | 0;
      E.length = k, k = k - 1 | 0;
      var O = C.words[0] | 0, A = b.words[0] | 0, x = O * A, Y = x & 67108863, B = x / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < k; T++) {
        for (var D = B >>> 26, te = B & 67108863, me = Math.min(T, b.length - 1), Ie = Math.max(0, T - C.length + 1); Ie <= me; Ie++) {
          var $e = T - Ie | 0;
          O = C.words[$e] | 0, A = b.words[Ie] | 0, x = O * A + te, D += x / 67108864 | 0, te = x & 67108863;
        }
        E.words[T] = te | 0, B = D | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ie = function(b, E, k) {
      var O = b.words, A = E.words, x = k.words, Y = 0, B, T, D, te = O[0] | 0, me = te & 8191, Ie = te >>> 13, $e = O[1] | 0, ye = $e & 8191, fe = $e >>> 13, Me = O[2] | 0, Ae = Me & 8191, xe = Me >>> 13, ae = O[3] | 0, N = ae & 8191, re = ae >>> 13, le = O[4] | 0, Ne = le & 8191, Oe = le >>> 13, qe = O[5] | 0, je = qe & 8191, Fe = qe >>> 13, yt = O[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, V = O[7] | 0, ge = V & 8191, Te = V >>> 13, We = O[8] | 0, Re = We & 8191, J = We >>> 13, Ee = O[9] | 0, ue = Ee & 8191, ce = Ee >>> 13, ve = A[0] | 0, Ce = ve & 8191, Be = ve >>> 13, He = A[1] | 0, Ve = He & 8191, Ze = He >>> 13, Ke = A[2] | 0, U = Ke & 8191, se = Ke >>> 13, Se = A[3] | 0, Ue = Se & 8191, De = Se >>> 13, Ye = A[4] | 0, Qe = Ye & 8191, st = Ye >>> 13, St = A[5] | 0, tt = St & 8191, it = St >>> 13, Tt = A[6] | 0, rt = Tt & 8191, dt = Tt >>> 13, wt = A[7] | 0, nt = wt & 8191, at = wt >>> 13, gt = A[8] | 0, ot = gt & 8191, ct = gt >>> 13, Ct = A[9] | 0, ut = Ct & 8191, lt = Ct >>> 13;
      k.negative = b.negative ^ E.negative, k.length = 19, B = Math.imul(me, Ce), T = Math.imul(me, Be), T = T + Math.imul(Ie, Ce) | 0, D = Math.imul(Ie, Be);
      var kt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, B = Math.imul(ye, Ce), T = Math.imul(ye, Be), T = T + Math.imul(fe, Ce) | 0, D = Math.imul(fe, Be), B = B + Math.imul(me, Ve) | 0, T = T + Math.imul(me, Ze) | 0, T = T + Math.imul(Ie, Ve) | 0, D = D + Math.imul(Ie, Ze) | 0;
      var Rt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(Ae, Ce), T = Math.imul(Ae, Be), T = T + Math.imul(xe, Ce) | 0, D = Math.imul(xe, Be), B = B + Math.imul(ye, Ve) | 0, T = T + Math.imul(ye, Ze) | 0, T = T + Math.imul(fe, Ve) | 0, D = D + Math.imul(fe, Ze) | 0, B = B + Math.imul(me, U) | 0, T = T + Math.imul(me, se) | 0, T = T + Math.imul(Ie, U) | 0, D = D + Math.imul(Ie, se) | 0;
      var Je = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, B = Math.imul(N, Ce), T = Math.imul(N, Be), T = T + Math.imul(re, Ce) | 0, D = Math.imul(re, Be), B = B + Math.imul(Ae, Ve) | 0, T = T + Math.imul(Ae, Ze) | 0, T = T + Math.imul(xe, Ve) | 0, D = D + Math.imul(xe, Ze) | 0, B = B + Math.imul(ye, U) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(fe, U) | 0, D = D + Math.imul(fe, se) | 0, B = B + Math.imul(me, Ue) | 0, T = T + Math.imul(me, De) | 0, T = T + Math.imul(Ie, Ue) | 0, D = D + Math.imul(Ie, De) | 0;
      var ze = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, B = Math.imul(Ne, Ce), T = Math.imul(Ne, Be), T = T + Math.imul(Oe, Ce) | 0, D = Math.imul(Oe, Be), B = B + Math.imul(N, Ve) | 0, T = T + Math.imul(N, Ze) | 0, T = T + Math.imul(re, Ve) | 0, D = D + Math.imul(re, Ze) | 0, B = B + Math.imul(Ae, U) | 0, T = T + Math.imul(Ae, se) | 0, T = T + Math.imul(xe, U) | 0, D = D + Math.imul(xe, se) | 0, B = B + Math.imul(ye, Ue) | 0, T = T + Math.imul(ye, De) | 0, T = T + Math.imul(fe, Ue) | 0, D = D + Math.imul(fe, De) | 0, B = B + Math.imul(me, Qe) | 0, T = T + Math.imul(me, st) | 0, T = T + Math.imul(Ie, Qe) | 0, D = D + Math.imul(Ie, st) | 0;
      var et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, B = Math.imul(je, Ce), T = Math.imul(je, Be), T = T + Math.imul(Fe, Ce) | 0, D = Math.imul(Fe, Be), B = B + Math.imul(Ne, Ve) | 0, T = T + Math.imul(Ne, Ze) | 0, T = T + Math.imul(Oe, Ve) | 0, D = D + Math.imul(Oe, Ze) | 0, B = B + Math.imul(N, U) | 0, T = T + Math.imul(N, se) | 0, T = T + Math.imul(re, U) | 0, D = D + Math.imul(re, se) | 0, B = B + Math.imul(Ae, Ue) | 0, T = T + Math.imul(Ae, De) | 0, T = T + Math.imul(xe, Ue) | 0, D = D + Math.imul(xe, De) | 0, B = B + Math.imul(ye, Qe) | 0, T = T + Math.imul(ye, st) | 0, T = T + Math.imul(fe, Qe) | 0, D = D + Math.imul(fe, st) | 0, B = B + Math.imul(me, tt) | 0, T = T + Math.imul(me, it) | 0, T = T + Math.imul(Ie, tt) | 0, D = D + Math.imul(Ie, it) | 0;
      var pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Ce), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Ce) | 0, D = Math.imul(Ge, Be), B = B + Math.imul(je, Ve) | 0, T = T + Math.imul(je, Ze) | 0, T = T + Math.imul(Fe, Ve) | 0, D = D + Math.imul(Fe, Ze) | 0, B = B + Math.imul(Ne, U) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Oe, U) | 0, D = D + Math.imul(Oe, se) | 0, B = B + Math.imul(N, Ue) | 0, T = T + Math.imul(N, De) | 0, T = T + Math.imul(re, Ue) | 0, D = D + Math.imul(re, De) | 0, B = B + Math.imul(Ae, Qe) | 0, T = T + Math.imul(Ae, st) | 0, T = T + Math.imul(xe, Qe) | 0, D = D + Math.imul(xe, st) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(fe, tt) | 0, D = D + Math.imul(fe, it) | 0, B = B + Math.imul(me, rt) | 0, T = T + Math.imul(me, dt) | 0, T = T + Math.imul(Ie, rt) | 0, D = D + Math.imul(Ie, dt) | 0;
      var mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ge, Ce), T = Math.imul(ge, Be), T = T + Math.imul(Te, Ce) | 0, D = Math.imul(Te, Be), B = B + Math.imul(Xe, Ve) | 0, T = T + Math.imul(Xe, Ze) | 0, T = T + Math.imul(Ge, Ve) | 0, D = D + Math.imul(Ge, Ze) | 0, B = B + Math.imul(je, U) | 0, T = T + Math.imul(je, se) | 0, T = T + Math.imul(Fe, U) | 0, D = D + Math.imul(Fe, se) | 0, B = B + Math.imul(Ne, Ue) | 0, T = T + Math.imul(Ne, De) | 0, T = T + Math.imul(Oe, Ue) | 0, D = D + Math.imul(Oe, De) | 0, B = B + Math.imul(N, Qe) | 0, T = T + Math.imul(N, st) | 0, T = T + Math.imul(re, Qe) | 0, D = D + Math.imul(re, st) | 0, B = B + Math.imul(Ae, tt) | 0, T = T + Math.imul(Ae, it) | 0, T = T + Math.imul(xe, tt) | 0, D = D + Math.imul(xe, it) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(fe, rt) | 0, D = D + Math.imul(fe, dt) | 0, B = B + Math.imul(me, nt) | 0, T = T + Math.imul(me, at) | 0, T = T + Math.imul(Ie, nt) | 0, D = D + Math.imul(Ie, at) | 0;
      var vt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, B = Math.imul(Re, Ce), T = Math.imul(Re, Be), T = T + Math.imul(J, Ce) | 0, D = Math.imul(J, Be), B = B + Math.imul(ge, Ve) | 0, T = T + Math.imul(ge, Ze) | 0, T = T + Math.imul(Te, Ve) | 0, D = D + Math.imul(Te, Ze) | 0, B = B + Math.imul(Xe, U) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, U) | 0, D = D + Math.imul(Ge, se) | 0, B = B + Math.imul(je, Ue) | 0, T = T + Math.imul(je, De) | 0, T = T + Math.imul(Fe, Ue) | 0, D = D + Math.imul(Fe, De) | 0, B = B + Math.imul(Ne, Qe) | 0, T = T + Math.imul(Ne, st) | 0, T = T + Math.imul(Oe, Qe) | 0, D = D + Math.imul(Oe, st) | 0, B = B + Math.imul(N, tt) | 0, T = T + Math.imul(N, it) | 0, T = T + Math.imul(re, tt) | 0, D = D + Math.imul(re, it) | 0, B = B + Math.imul(Ae, rt) | 0, T = T + Math.imul(Ae, dt) | 0, T = T + Math.imul(xe, rt) | 0, D = D + Math.imul(xe, dt) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(fe, nt) | 0, D = D + Math.imul(fe, at) | 0, B = B + Math.imul(me, ot) | 0, T = T + Math.imul(me, ct) | 0, T = T + Math.imul(Ie, ot) | 0, D = D + Math.imul(Ie, ct) | 0;
      var ht = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(ue, Ce), T = Math.imul(ue, Be), T = T + Math.imul(ce, Ce) | 0, D = Math.imul(ce, Be), B = B + Math.imul(Re, Ve) | 0, T = T + Math.imul(Re, Ze) | 0, T = T + Math.imul(J, Ve) | 0, D = D + Math.imul(J, Ze) | 0, B = B + Math.imul(ge, U) | 0, T = T + Math.imul(ge, se) | 0, T = T + Math.imul(Te, U) | 0, D = D + Math.imul(Te, se) | 0, B = B + Math.imul(Xe, Ue) | 0, T = T + Math.imul(Xe, De) | 0, T = T + Math.imul(Ge, Ue) | 0, D = D + Math.imul(Ge, De) | 0, B = B + Math.imul(je, Qe) | 0, T = T + Math.imul(je, st) | 0, T = T + Math.imul(Fe, Qe) | 0, D = D + Math.imul(Fe, st) | 0, B = B + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Oe, tt) | 0, D = D + Math.imul(Oe, it) | 0, B = B + Math.imul(N, rt) | 0, T = T + Math.imul(N, dt) | 0, T = T + Math.imul(re, rt) | 0, D = D + Math.imul(re, dt) | 0, B = B + Math.imul(Ae, nt) | 0, T = T + Math.imul(Ae, at) | 0, T = T + Math.imul(xe, nt) | 0, D = D + Math.imul(xe, at) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(fe, ot) | 0, D = D + Math.imul(fe, ct) | 0, B = B + Math.imul(me, ut) | 0, T = T + Math.imul(me, lt) | 0, T = T + Math.imul(Ie, ut) | 0, D = D + Math.imul(Ie, lt) | 0;
      var _t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, B = Math.imul(ue, Ve), T = Math.imul(ue, Ze), T = T + Math.imul(ce, Ve) | 0, D = Math.imul(ce, Ze), B = B + Math.imul(Re, U) | 0, T = T + Math.imul(Re, se) | 0, T = T + Math.imul(J, U) | 0, D = D + Math.imul(J, se) | 0, B = B + Math.imul(ge, Ue) | 0, T = T + Math.imul(ge, De) | 0, T = T + Math.imul(Te, Ue) | 0, D = D + Math.imul(Te, De) | 0, B = B + Math.imul(Xe, Qe) | 0, T = T + Math.imul(Xe, st) | 0, T = T + Math.imul(Ge, Qe) | 0, D = D + Math.imul(Ge, st) | 0, B = B + Math.imul(je, tt) | 0, T = T + Math.imul(je, it) | 0, T = T + Math.imul(Fe, tt) | 0, D = D + Math.imul(Fe, it) | 0, B = B + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Oe, rt) | 0, D = D + Math.imul(Oe, dt) | 0, B = B + Math.imul(N, nt) | 0, T = T + Math.imul(N, at) | 0, T = T + Math.imul(re, nt) | 0, D = D + Math.imul(re, at) | 0, B = B + Math.imul(Ae, ot) | 0, T = T + Math.imul(Ae, ct) | 0, T = T + Math.imul(xe, ot) | 0, D = D + Math.imul(xe, ct) | 0, B = B + Math.imul(ye, ut) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(fe, ut) | 0, D = D + Math.imul(fe, lt) | 0;
      var Et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(ue, U), T = Math.imul(ue, se), T = T + Math.imul(ce, U) | 0, D = Math.imul(ce, se), B = B + Math.imul(Re, Ue) | 0, T = T + Math.imul(Re, De) | 0, T = T + Math.imul(J, Ue) | 0, D = D + Math.imul(J, De) | 0, B = B + Math.imul(ge, Qe) | 0, T = T + Math.imul(ge, st) | 0, T = T + Math.imul(Te, Qe) | 0, D = D + Math.imul(Te, st) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, tt) | 0, D = D + Math.imul(Ge, it) | 0, B = B + Math.imul(je, rt) | 0, T = T + Math.imul(je, dt) | 0, T = T + Math.imul(Fe, rt) | 0, D = D + Math.imul(Fe, dt) | 0, B = B + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Oe, nt) | 0, D = D + Math.imul(Oe, at) | 0, B = B + Math.imul(N, ot) | 0, T = T + Math.imul(N, ct) | 0, T = T + Math.imul(re, ot) | 0, D = D + Math.imul(re, ct) | 0, B = B + Math.imul(Ae, ut) | 0, T = T + Math.imul(Ae, lt) | 0, T = T + Math.imul(xe, ut) | 0, D = D + Math.imul(xe, lt) | 0;
      var Pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, B = Math.imul(ue, Ue), T = Math.imul(ue, De), T = T + Math.imul(ce, Ue) | 0, D = Math.imul(ce, De), B = B + Math.imul(Re, Qe) | 0, T = T + Math.imul(Re, st) | 0, T = T + Math.imul(J, Qe) | 0, D = D + Math.imul(J, st) | 0, B = B + Math.imul(ge, tt) | 0, T = T + Math.imul(ge, it) | 0, T = T + Math.imul(Te, tt) | 0, D = D + Math.imul(Te, it) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, rt) | 0, D = D + Math.imul(Ge, dt) | 0, B = B + Math.imul(je, nt) | 0, T = T + Math.imul(je, at) | 0, T = T + Math.imul(Fe, nt) | 0, D = D + Math.imul(Fe, at) | 0, B = B + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Oe, ot) | 0, D = D + Math.imul(Oe, ct) | 0, B = B + Math.imul(N, ut) | 0, T = T + Math.imul(N, lt) | 0, T = T + Math.imul(re, ut) | 0, D = D + Math.imul(re, lt) | 0;
      var Nt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(ue, Qe), T = Math.imul(ue, st), T = T + Math.imul(ce, Qe) | 0, D = Math.imul(ce, st), B = B + Math.imul(Re, tt) | 0, T = T + Math.imul(Re, it) | 0, T = T + Math.imul(J, tt) | 0, D = D + Math.imul(J, it) | 0, B = B + Math.imul(ge, rt) | 0, T = T + Math.imul(ge, dt) | 0, T = T + Math.imul(Te, rt) | 0, D = D + Math.imul(Te, dt) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, nt) | 0, D = D + Math.imul(Ge, at) | 0, B = B + Math.imul(je, ot) | 0, T = T + Math.imul(je, ct) | 0, T = T + Math.imul(Fe, ot) | 0, D = D + Math.imul(Fe, ct) | 0, B = B + Math.imul(Ne, ut) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Oe, ut) | 0, D = D + Math.imul(Oe, lt) | 0;
      var Mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, B = Math.imul(ue, tt), T = Math.imul(ue, it), T = T + Math.imul(ce, tt) | 0, D = Math.imul(ce, it), B = B + Math.imul(Re, rt) | 0, T = T + Math.imul(Re, dt) | 0, T = T + Math.imul(J, rt) | 0, D = D + Math.imul(J, dt) | 0, B = B + Math.imul(ge, nt) | 0, T = T + Math.imul(ge, at) | 0, T = T + Math.imul(Te, nt) | 0, D = D + Math.imul(Te, at) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, D = D + Math.imul(Ge, ct) | 0, B = B + Math.imul(je, ut) | 0, T = T + Math.imul(je, lt) | 0, T = T + Math.imul(Fe, ut) | 0, D = D + Math.imul(Fe, lt) | 0;
      var Ot = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(ue, rt), T = Math.imul(ue, dt), T = T + Math.imul(ce, rt) | 0, D = Math.imul(ce, dt), B = B + Math.imul(Re, nt) | 0, T = T + Math.imul(Re, at) | 0, T = T + Math.imul(J, nt) | 0, D = D + Math.imul(J, at) | 0, B = B + Math.imul(ge, ot) | 0, T = T + Math.imul(ge, ct) | 0, T = T + Math.imul(Te, ot) | 0, D = D + Math.imul(Te, ct) | 0, B = B + Math.imul(Xe, ut) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, ut) | 0, D = D + Math.imul(Ge, lt) | 0;
      var $t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(ue, nt), T = Math.imul(ue, at), T = T + Math.imul(ce, nt) | 0, D = Math.imul(ce, at), B = B + Math.imul(Re, ot) | 0, T = T + Math.imul(Re, ct) | 0, T = T + Math.imul(J, ot) | 0, D = D + Math.imul(J, ct) | 0, B = B + Math.imul(ge, ut) | 0, T = T + Math.imul(ge, lt) | 0, T = T + Math.imul(Te, ut) | 0, D = D + Math.imul(Te, lt) | 0;
      var Bt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(ue, ot), T = Math.imul(ue, ct), T = T + Math.imul(ce, ot) | 0, D = Math.imul(ce, ct), B = B + Math.imul(Re, ut) | 0, T = T + Math.imul(Re, lt) | 0, T = T + Math.imul(J, ut) | 0, D = D + Math.imul(J, lt) | 0;
      var xt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, B = Math.imul(ue, ut), T = Math.imul(ue, lt), T = T + Math.imul(ce, ut) | 0, D = Math.imul(ce, lt);
      var Ut = (Y + B | 0) + ((T & 8191) << 13) | 0;
      return Y = (D + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, x[0] = kt, x[1] = Rt, x[2] = Je, x[3] = ze, x[4] = et, x[5] = pt, x[6] = mt, x[7] = vt, x[8] = ht, x[9] = _t, x[10] = Et, x[11] = Pt, x[12] = Nt, x[13] = Mt, x[14] = Ot, x[15] = $t, x[16] = Bt, x[17] = xt, x[18] = Ut, Y !== 0 && (x[19] = Y, k.length++), k;
    };
    Math.imul || (ie = X);
    function Q(C, b, E) {
      E.negative = b.negative ^ C.negative, E.length = C.length + b.length;
      for (var k = 0, O = 0, A = 0; A < E.length - 1; A++) {
        var x = O;
        O = 0;
        for (var Y = k & 67108863, B = Math.min(A, b.length - 1), T = Math.max(0, A - C.length + 1); T <= B; T++) {
          var D = A - T, te = C.words[D] | 0, me = b.words[T] | 0, Ie = te * me, $e = Ie & 67108863;
          x = x + (Ie / 67108864 | 0) | 0, $e = $e + Y | 0, Y = $e & 67108863, x = x + ($e >>> 26) | 0, O += x >>> 26, x &= 67108863;
        }
        E.words[A] = Y, k = x, x = O;
      }
      return k !== 0 ? E.words[A] = k : E.length--, E.strip();
    }
    function ne(C, b, E) {
      var k = new Z();
      return k.mulp(C, b, E);
    }
    p.prototype.mulTo = function(b, E) {
      var k, O = this.length + b.length;
      return this.length === 10 && b.length === 10 ? k = ie(this, b, E) : O < 63 ? k = X(this, b, E) : O < 1024 ? k = Q(this, b, E) : k = ne(this, b, E), k;
    };
    function Z(C, b) {
      this.x = C, this.y = b;
    }
    Z.prototype.makeRBT = function(b) {
      for (var E = new Array(b), k = p.prototype._countBits(b) - 1, O = 0; O < b; O++)
        E[O] = this.revBin(O, k, b);
      return E;
    }, Z.prototype.revBin = function(b, E, k) {
      if (b === 0 || b === k - 1)
        return b;
      for (var O = 0, A = 0; A < E; A++)
        O |= (b & 1) << E - A - 1, b >>= 1;
      return O;
    }, Z.prototype.permute = function(b, E, k, O, A, x) {
      for (var Y = 0; Y < x; Y++)
        O[Y] = E[b[Y]], A[Y] = k[b[Y]];
    }, Z.prototype.transform = function(b, E, k, O, A, x) {
      this.permute(x, b, E, k, O, A);
      for (var Y = 1; Y < A; Y <<= 1)
        for (var B = Y << 1, T = Math.cos(2 * Math.PI / B), D = Math.sin(2 * Math.PI / B), te = 0; te < A; te += B)
          for (var me = T, Ie = D, $e = 0; $e < Y; $e++) {
            var ye = k[te + $e], fe = O[te + $e], Me = k[te + $e + Y], Ae = O[te + $e + Y], xe = me * Me - Ie * Ae;
            Ae = me * Ae + Ie * Me, Me = xe, k[te + $e] = ye + Me, O[te + $e] = fe + Ae, k[te + $e + Y] = ye - Me, O[te + $e + Y] = fe - Ae, $e !== B && (xe = T * me - D * Ie, Ie = T * Ie + D * me, me = xe);
          }
    }, Z.prototype.guessLen13b = function(b, E) {
      var k = Math.max(E, b) | 1, O = k & 1, A = 0;
      for (k = k / 2 | 0; k; k = k >>> 1)
        A++;
      return 1 << A + 1 + O;
    }, Z.prototype.conjugate = function(b, E, k) {
      if (!(k <= 1))
        for (var O = 0; O < k / 2; O++) {
          var A = b[O];
          b[O] = b[k - O - 1], b[k - O - 1] = A, A = E[O], E[O] = -E[k - O - 1], E[k - O - 1] = -A;
        }
    }, Z.prototype.normalize13b = function(b, E) {
      for (var k = 0, O = 0; O < E / 2; O++) {
        var A = Math.round(b[2 * O + 1] / E) * 8192 + Math.round(b[2 * O] / E) + k;
        b[O] = A & 67108863, A < 67108864 ? k = 0 : k = A / 67108864 | 0;
      }
      return b;
    }, Z.prototype.convert13b = function(b, E, k, O) {
      for (var A = 0, x = 0; x < E; x++)
        A = A + (b[x] | 0), k[2 * x] = A & 8191, A = A >>> 13, k[2 * x + 1] = A & 8191, A = A >>> 13;
      for (x = 2 * E; x < O; ++x)
        k[x] = 0;
      l(A === 0), l((A & -8192) === 0);
    }, Z.prototype.stub = function(b) {
      for (var E = new Array(b), k = 0; k < b; k++)
        E[k] = 0;
      return E;
    }, Z.prototype.mulp = function(b, E, k) {
      var O = 2 * this.guessLen13b(b.length, E.length), A = this.makeRBT(O), x = this.stub(O), Y = new Array(O), B = new Array(O), T = new Array(O), D = new Array(O), te = new Array(O), me = new Array(O), Ie = k.words;
      Ie.length = O, this.convert13b(b.words, b.length, Y, O), this.convert13b(E.words, E.length, D, O), this.transform(Y, x, B, T, O, A), this.transform(D, x, te, me, O, A);
      for (var $e = 0; $e < O; $e++) {
        var ye = B[$e] * te[$e] - T[$e] * me[$e];
        T[$e] = B[$e] * me[$e] + T[$e] * te[$e], B[$e] = ye;
      }
      return this.conjugate(B, T, O), this.transform(B, T, Ie, x, O, A), this.conjugate(Ie, x, O), this.normalize13b(Ie, O), k.negative = b.negative ^ E.negative, k.length = b.length + E.length, k.strip();
    }, p.prototype.mul = function(b) {
      var E = new p(null);
      return E.words = new Array(this.length + b.length), this.mulTo(b, E);
    }, p.prototype.mulf = function(b) {
      var E = new p(null);
      return E.words = new Array(this.length + b.length), ne(this, b, E);
    }, p.prototype.imul = function(b) {
      return this.clone().mulTo(b, this);
    }, p.prototype.imuln = function(b) {
      l(typeof b == "number"), l(b < 67108864);
      for (var E = 0, k = 0; k < this.length; k++) {
        var O = (this.words[k] | 0) * b, A = (O & 67108863) + (E & 67108863);
        E >>= 26, E += O / 67108864 | 0, E += A >>> 26, this.words[k] = A & 67108863;
      }
      return E !== 0 && (this.words[k] = E, this.length++), this;
    }, p.prototype.muln = function(b) {
      return this.clone().imuln(b);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(b) {
      var E = ee(b);
      if (E.length === 0)
        return new p(1);
      for (var k = this, O = 0; O < E.length && E[O] === 0; O++, k = k.sqr())
        ;
      if (++O < E.length)
        for (var A = k.sqr(); O < E.length; O++, A = A.sqr())
          E[O] !== 0 && (k = k.mul(A));
      return k;
    }, p.prototype.iushln = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26, O = 67108863 >>> 26 - E << 26 - E, A;
      if (E !== 0) {
        var x = 0;
        for (A = 0; A < this.length; A++) {
          var Y = this.words[A] & O, B = (this.words[A] | 0) - Y << E;
          this.words[A] = B | x, x = Y >>> 26 - E;
        }
        x && (this.words[A] = x, this.length++);
      }
      if (k !== 0) {
        for (A = this.length - 1; A >= 0; A--)
          this.words[A + k] = this.words[A];
        for (A = 0; A < k; A++)
          this.words[A] = 0;
        this.length += k;
      }
      return this.strip();
    }, p.prototype.ishln = function(b) {
      return l(this.negative === 0), this.iushln(b);
    }, p.prototype.iushrn = function(b, E, k) {
      l(typeof b == "number" && b >= 0);
      var O;
      E ? O = (E - E % 26) / 26 : O = 0;
      var A = b % 26, x = Math.min((b - A) / 26, this.length), Y = 67108863 ^ 67108863 >>> A << A, B = k;
      if (O -= x, O = Math.max(0, O), B) {
        for (var T = 0; T < x; T++)
          B.words[T] = this.words[T];
        B.length = x;
      }
      if (x !== 0)
        if (this.length > x)
          for (this.length -= x, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + x];
        else
          this.words[0] = 0, this.length = 1;
      var D = 0;
      for (T = this.length - 1; T >= 0 && (D !== 0 || T >= O); T--) {
        var te = this.words[T] | 0;
        this.words[T] = D << 26 - A | te >>> A, D = te & Y;
      }
      return B && D !== 0 && (B.words[B.length++] = D), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(b, E, k) {
      return l(this.negative === 0), this.iushrn(b, E, k);
    }, p.prototype.shln = function(b) {
      return this.clone().ishln(b);
    }, p.prototype.ushln = function(b) {
      return this.clone().iushln(b);
    }, p.prototype.shrn = function(b) {
      return this.clone().ishrn(b);
    }, p.prototype.ushrn = function(b) {
      return this.clone().iushrn(b);
    }, p.prototype.testn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26, O = 1 << E;
      if (this.length <= k)
        return !1;
      var A = this.words[k];
      return !!(A & O);
    }, p.prototype.imaskn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= k)
        return this;
      if (E !== 0 && k++, this.length = Math.min(k, this.length), E !== 0) {
        var O = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= O;
      }
      return this.strip();
    }, p.prototype.maskn = function(b) {
      return this.clone().imaskn(b);
    }, p.prototype.iaddn = function(b) {
      return l(typeof b == "number"), l(b < 67108864), b < 0 ? this.isubn(-b) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < b ? (this.words[0] = b - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(b), this.negative = 1, this) : this._iaddn(b);
    }, p.prototype._iaddn = function(b) {
      this.words[0] += b;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(b) {
      if (l(typeof b == "number"), l(b < 67108864), b < 0)
        return this.iaddn(-b);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(b), this.negative = 1, this;
      if (this.words[0] -= b, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(b) {
      return this.clone().iaddn(b);
    }, p.prototype.subn = function(b) {
      return this.clone().isubn(b);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(b, E, k) {
      var O = b.length + k, A;
      this._expand(O);
      var x, Y = 0;
      for (A = 0; A < b.length; A++) {
        x = (this.words[A + k] | 0) + Y;
        var B = (b.words[A] | 0) * E;
        x -= B & 67108863, Y = (x >> 26) - (B / 67108864 | 0), this.words[A + k] = x & 67108863;
      }
      for (; A < this.length - k; A++)
        x = (this.words[A + k] | 0) + Y, Y = x >> 26, this.words[A + k] = x & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, A = 0; A < this.length; A++)
        x = -(this.words[A] | 0) + Y, Y = x >> 26, this.words[A] = x & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(b, E) {
      var k = this.length - b.length, O = this.clone(), A = b, x = A.words[A.length - 1] | 0, Y = this._countBits(x);
      k = 26 - Y, k !== 0 && (A = A.ushln(k), O.iushln(k), x = A.words[A.length - 1] | 0);
      var B = O.length - A.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var D = 0; D < T.length; D++)
          T.words[D] = 0;
      }
      var te = O.clone()._ishlnsubmul(A, 1, B);
      te.negative === 0 && (O = te, T && (T.words[B] = 1));
      for (var me = B - 1; me >= 0; me--) {
        var Ie = (O.words[A.length + me] | 0) * 67108864 + (O.words[A.length + me - 1] | 0);
        for (Ie = Math.min(Ie / x | 0, 67108863), O._ishlnsubmul(A, Ie, me); O.negative !== 0; )
          Ie--, O.negative = 0, O._ishlnsubmul(A, 1, me), O.isZero() || (O.negative ^= 1);
        T && (T.words[me] = Ie);
      }
      return T && T.strip(), O.strip(), E !== "div" && k !== 0 && O.iushrn(k), {
        div: T || null,
        mod: O
      };
    }, p.prototype.divmod = function(b, E, k) {
      if (l(!b.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var O, A, x;
      return this.negative !== 0 && b.negative === 0 ? (x = this.neg().divmod(b, E), E !== "mod" && (O = x.div.neg()), E !== "div" && (A = x.mod.neg(), k && A.negative !== 0 && A.iadd(b)), {
        div: O,
        mod: A
      }) : this.negative === 0 && b.negative !== 0 ? (x = this.divmod(b.neg(), E), E !== "mod" && (O = x.div.neg()), {
        div: O,
        mod: x.mod
      }) : this.negative & b.negative ? (x = this.neg().divmod(b.neg(), E), E !== "div" && (A = x.mod.neg(), k && A.negative !== 0 && A.isub(b)), {
        div: x.div,
        mod: A
      }) : b.length > this.length || this.cmp(b) < 0 ? {
        div: new p(0),
        mod: this
      } : b.length === 1 ? E === "div" ? {
        div: this.divn(b.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(b.words[0]))
      } : {
        div: this.divn(b.words[0]),
        mod: new p(this.modn(b.words[0]))
      } : this._wordDiv(b, E);
    }, p.prototype.div = function(b) {
      return this.divmod(b, "div", !1).div;
    }, p.prototype.mod = function(b) {
      return this.divmod(b, "mod", !1).mod;
    }, p.prototype.umod = function(b) {
      return this.divmod(b, "mod", !0).mod;
    }, p.prototype.divRound = function(b) {
      var E = this.divmod(b);
      if (E.mod.isZero())
        return E.div;
      var k = E.div.negative !== 0 ? E.mod.isub(b) : E.mod, O = b.ushrn(1), A = b.andln(1), x = k.cmp(O);
      return x < 0 || A === 1 && x === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(b) {
      l(b <= 67108863);
      for (var E = (1 << 26) % b, k = 0, O = this.length - 1; O >= 0; O--)
        k = (E * k + (this.words[O] | 0)) % b;
      return k;
    }, p.prototype.idivn = function(b) {
      l(b <= 67108863);
      for (var E = 0, k = this.length - 1; k >= 0; k--) {
        var O = (this.words[k] | 0) + E * 67108864;
        this.words[k] = O / b | 0, E = O % b;
      }
      return this.strip();
    }, p.prototype.divn = function(b) {
      return this.clone().idivn(b);
    }, p.prototype.egcd = function(b) {
      l(b.negative === 0), l(!b.isZero());
      var E = this, k = b.clone();
      E.negative !== 0 ? E = E.umod(b) : E = E.clone();
      for (var O = new p(1), A = new p(0), x = new p(0), Y = new p(1), B = 0; E.isEven() && k.isEven(); )
        E.iushrn(1), k.iushrn(1), ++B;
      for (var T = k.clone(), D = E.clone(); !E.isZero(); ) {
        for (var te = 0, me = 1; !(E.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (O.isOdd() || A.isOdd()) && (O.iadd(T), A.isub(D)), O.iushrn(1), A.iushrn(1);
        for (var Ie = 0, $e = 1; !(k.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (k.iushrn(Ie); Ie-- > 0; )
            (x.isOdd() || Y.isOdd()) && (x.iadd(T), Y.isub(D)), x.iushrn(1), Y.iushrn(1);
        E.cmp(k) >= 0 ? (E.isub(k), O.isub(x), A.isub(Y)) : (k.isub(E), x.isub(O), Y.isub(A));
      }
      return {
        a: x,
        b: Y,
        gcd: k.iushln(B)
      };
    }, p.prototype._invmp = function(b) {
      l(b.negative === 0), l(!b.isZero());
      var E = this, k = b.clone();
      E.negative !== 0 ? E = E.umod(b) : E = E.clone();
      for (var O = new p(1), A = new p(0), x = k.clone(); E.cmpn(1) > 0 && k.cmpn(1) > 0; ) {
        for (var Y = 0, B = 1; !(E.words[0] & B) && Y < 26; ++Y, B <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            O.isOdd() && O.iadd(x), O.iushrn(1);
        for (var T = 0, D = 1; !(k.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (k.iushrn(T); T-- > 0; )
            A.isOdd() && A.iadd(x), A.iushrn(1);
        E.cmp(k) >= 0 ? (E.isub(k), O.isub(A)) : (k.isub(E), A.isub(O));
      }
      var te;
      return E.cmpn(1) === 0 ? te = O : te = A, te.cmpn(0) < 0 && te.iadd(b), te;
    }, p.prototype.gcd = function(b) {
      if (this.isZero())
        return b.abs();
      if (b.isZero())
        return this.abs();
      var E = this.clone(), k = b.clone();
      E.negative = 0, k.negative = 0;
      for (var O = 0; E.isEven() && k.isEven(); O++)
        E.iushrn(1), k.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; k.isEven(); )
          k.iushrn(1);
        var A = E.cmp(k);
        if (A < 0) {
          var x = E;
          E = k, k = x;
        } else if (A === 0 || k.cmpn(1) === 0)
          break;
        E.isub(k);
      } while (!0);
      return k.iushln(O);
    }, p.prototype.invm = function(b) {
      return this.egcd(b).a.umod(b);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(b) {
      return this.words[0] & b;
    }, p.prototype.bincn = function(b) {
      l(typeof b == "number");
      var E = b % 26, k = (b - E) / 26, O = 1 << E;
      if (this.length <= k)
        return this._expand(k + 1), this.words[k] |= O, this;
      for (var A = O, x = k; A !== 0 && x < this.length; x++) {
        var Y = this.words[x] | 0;
        Y += A, A = Y >>> 26, Y &= 67108863, this.words[x] = Y;
      }
      return A !== 0 && (this.words[x] = A, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(b) {
      var E = b < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var k;
      if (this.length > 1)
        k = 1;
      else {
        E && (b = -b), l(b <= 67108863, "Number is too big");
        var O = this.words[0] | 0;
        k = O === b ? 0 : O < b ? -1 : 1;
      }
      return this.negative !== 0 ? -k | 0 : k;
    }, p.prototype.cmp = function(b) {
      if (this.negative !== 0 && b.negative === 0)
        return -1;
      if (this.negative === 0 && b.negative !== 0)
        return 1;
      var E = this.ucmp(b);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(b) {
      if (this.length > b.length)
        return 1;
      if (this.length < b.length)
        return -1;
      for (var E = 0, k = this.length - 1; k >= 0; k--) {
        var O = this.words[k] | 0, A = b.words[k] | 0;
        if (O !== A) {
          O < A ? E = -1 : O > A && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(b) {
      return this.cmpn(b) === 1;
    }, p.prototype.gt = function(b) {
      return this.cmp(b) === 1;
    }, p.prototype.gten = function(b) {
      return this.cmpn(b) >= 0;
    }, p.prototype.gte = function(b) {
      return this.cmp(b) >= 0;
    }, p.prototype.ltn = function(b) {
      return this.cmpn(b) === -1;
    }, p.prototype.lt = function(b) {
      return this.cmp(b) === -1;
    }, p.prototype.lten = function(b) {
      return this.cmpn(b) <= 0;
    }, p.prototype.lte = function(b) {
      return this.cmp(b) <= 0;
    }, p.prototype.eqn = function(b) {
      return this.cmpn(b) === 0;
    }, p.prototype.eq = function(b) {
      return this.cmp(b) === 0;
    }, p.red = function(b) {
      return new q(b);
    }, p.prototype.toRed = function(b) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), b.convertTo(this)._forceRed(b);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(b) {
      return this.red = b, this;
    }, p.prototype.forceRed = function(b) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(b);
    }, p.prototype.redAdd = function(b) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, b);
    }, p.prototype.redIAdd = function(b) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, b);
    }, p.prototype.redSub = function(b) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, b);
    }, p.prototype.redISub = function(b) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, b);
    }, p.prototype.redShl = function(b) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, b);
    }, p.prototype.redMul = function(b) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.mul(this, b);
    }, p.prototype.redIMul = function(b) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.imul(this, b);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(b) {
      return l(this.red && !b.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, b);
    };
    var de = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function he(C, b) {
      this.name = C, this.p = new p(b, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    he.prototype._tmp = function() {
      var b = new p(null);
      return b.words = new Array(Math.ceil(this.n / 13)), b;
    }, he.prototype.ireduce = function(b) {
      var E = b, k;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), k = E.bitLength();
      while (k > this.n);
      var O = k < this.n ? -1 : E.ucmp(this.p);
      return O === 0 ? (E.words[0] = 0, E.length = 1) : O > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, he.prototype.split = function(b, E) {
      b.iushrn(this.n, 0, E);
    }, he.prototype.imulK = function(b) {
      return b.imul(this.k);
    };
    function pe() {
      he.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(pe, he), pe.prototype.split = function(b, E) {
      for (var k = 4194303, O = Math.min(b.length, 9), A = 0; A < O; A++)
        E.words[A] = b.words[A];
      if (E.length = O, b.length <= 9) {
        b.words[0] = 0, b.length = 1;
        return;
      }
      var x = b.words[9];
      for (E.words[E.length++] = x & k, A = 10; A < b.length; A++) {
        var Y = b.words[A] | 0;
        b.words[A - 10] = (Y & k) << 4 | x >>> 22, x = Y;
      }
      x >>>= 22, b.words[A - 10] = x, x === 0 && b.length > 10 ? b.length -= 10 : b.length -= 9;
    }, pe.prototype.imulK = function(b) {
      b.words[b.length] = 0, b.words[b.length + 1] = 0, b.length += 2;
      for (var E = 0, k = 0; k < b.length; k++) {
        var O = b.words[k] | 0;
        E += O * 977, b.words[k] = E & 67108863, E = O * 64 + (E / 67108864 | 0);
      }
      return b.words[b.length - 1] === 0 && (b.length--, b.words[b.length - 1] === 0 && b.length--), b;
    };
    function be() {
      he.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(be, he);
    function ke() {
      he.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(ke, he);
    function _e() {
      he.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(_e, he), _e.prototype.imulK = function(b) {
      for (var E = 0, k = 0; k < b.length; k++) {
        var O = (b.words[k] | 0) * 19 + E, A = O & 67108863;
        O >>>= 26, b.words[k] = A, E = O;
      }
      return E !== 0 && (b.words[b.length++] = E), b;
    }, p._prime = function(b) {
      if (de[b])
        return de[b];
      var E;
      if (b === "k256")
        E = new pe();
      else if (b === "p224")
        E = new be();
      else if (b === "p192")
        E = new ke();
      else if (b === "p25519")
        E = new _e();
      else
        throw new Error("Unknown prime " + b);
      return de[b] = E, E;
    };
    function q(C) {
      if (typeof C == "string") {
        var b = p._prime(C);
        this.m = b.p, this.prime = b;
      } else
        l(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    q.prototype._verify1 = function(b) {
      l(b.negative === 0, "red works only with positives"), l(b.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(b, E) {
      l((b.negative | E.negative) === 0, "red works only with positives"), l(
        b.red && b.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(b) {
      return this.prime ? this.prime.ireduce(b)._forceRed(this) : b.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(b) {
      return b.isZero() ? b.clone() : this.m.sub(b)._forceRed(this);
    }, q.prototype.add = function(b, E) {
      this._verify2(b, E);
      var k = b.add(E);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k._forceRed(this);
    }, q.prototype.iadd = function(b, E) {
      this._verify2(b, E);
      var k = b.iadd(E);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k;
    }, q.prototype.sub = function(b, E) {
      this._verify2(b, E);
      var k = b.sub(E);
      return k.cmpn(0) < 0 && k.iadd(this.m), k._forceRed(this);
    }, q.prototype.isub = function(b, E) {
      this._verify2(b, E);
      var k = b.isub(E);
      return k.cmpn(0) < 0 && k.iadd(this.m), k;
    }, q.prototype.shl = function(b, E) {
      return this._verify1(b), this.imod(b.ushln(E));
    }, q.prototype.imul = function(b, E) {
      return this._verify2(b, E), this.imod(b.imul(E));
    }, q.prototype.mul = function(b, E) {
      return this._verify2(b, E), this.imod(b.mul(E));
    }, q.prototype.isqr = function(b) {
      return this.imul(b, b.clone());
    }, q.prototype.sqr = function(b) {
      return this.mul(b, b);
    }, q.prototype.sqrt = function(b) {
      if (b.isZero())
        return b.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var k = this.m.add(new p(1)).iushrn(2);
        return this.pow(b, k);
      }
      for (var O = this.m.subn(1), A = 0; !O.isZero() && O.andln(1) === 0; )
        A++, O.iushrn(1);
      l(!O.isZero());
      var x = new p(1).toRed(this), Y = x.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var D = this.pow(T, O), te = this.pow(b, O.addn(1).iushrn(1)), me = this.pow(b, O), Ie = A; me.cmp(x) !== 0; ) {
        for (var $e = me, ye = 0; $e.cmp(x) !== 0; ye++)
          $e = $e.redSqr();
        l(ye < Ie);
        var fe = this.pow(D, new p(1).iushln(Ie - ye - 1));
        te = te.redMul(fe), D = fe.redSqr(), me = me.redMul(D), Ie = ye;
      }
      return te;
    }, q.prototype.invm = function(b) {
      var E = b._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(b, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return b.clone();
      var k = 4, O = new Array(1 << k);
      O[0] = new p(1).toRed(this), O[1] = b;
      for (var A = 2; A < O.length; A++)
        O[A] = this.mul(O[A - 1], b);
      var x = O[0], Y = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), A = E.length - 1; A >= 0; A--) {
        for (var D = E.words[A], te = T - 1; te >= 0; te--) {
          var me = D >> te & 1;
          if (x !== O[0] && (x = this.sqr(x)), me === 0 && Y === 0) {
            B = 0;
            continue;
          }
          Y <<= 1, Y |= me, B++, !(B !== k && (A !== 0 || te !== 0)) && (x = this.mul(x, O[Y]), B = 0, Y = 0);
        }
        T = 26;
      }
      return x;
    }, q.prototype.convertTo = function(b) {
      var E = b.umod(this.m);
      return E === b ? E.clone() : E;
    }, q.prototype.convertFrom = function(b) {
      var E = b.clone();
      return E.red = null, E;
    }, p.mont = function(b) {
      return new z(b);
    };
    function z(C) {
      q.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, q), z.prototype.convertTo = function(b) {
      return this.imod(b.ushln(this.shift));
    }, z.prototype.convertFrom = function(b) {
      var E = this.imod(b.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(b, E) {
      if (b.isZero() || E.isZero())
        return b.words[0] = 0, b.length = 1, b;
      var k = b.imul(E), O = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = k.isub(O).iushrn(this.shift), x = A;
      return A.cmp(this.m) >= 0 ? x = A.isub(this.m) : A.cmpn(0) < 0 && (x = A.iadd(this.m)), x._forceRed(this);
    }, z.prototype.mul = function(b, E) {
      if (b.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var k = b.mul(E), O = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = k.isub(O).iushrn(this.shift), x = A;
      return A.cmp(this.m) >= 0 ? x = A.isub(this.m) : A.cmpn(0) < 0 && (x = A.iadd(this.m)), x._forceRed(this);
    }, z.prototype.invm = function(b) {
      var E = this.imod(b._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn$1);
var bnExports$1 = bn$1.exports, browser$3, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser$3;
  hasRequiredBrowser = 1;
  var a = requireElliptic(), u = bnExports$1;
  browser$3 = function(_) {
    return new l(_);
  };
  var c = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  c.p224 = c.secp224r1, c.p256 = c.secp256r1 = c.prime256v1, c.p192 = c.secp192r1 = c.prime192v1, c.p384 = c.secp384r1, c.p521 = c.secp521r1;
  function l(p) {
    this.curveType = c[p], this.curveType || (this.curveType = {
      name: p
    }), this.curve = new a.ec(this.curveType.name), this.keys = void 0;
  }
  l.prototype.generateKeys = function(p, _) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(p, _);
  }, l.prototype.computeSecret = function(p, _, I) {
    _ = _ || "utf8", Buffer$O.isBuffer(p) || (p = new Buffer$O(p, _));
    var P = this.curve.keyFromPublic(p).getPublic(), $ = P.mul(this.keys.getPrivate()).getX();
    return v($, I, this.curveType.byteLength);
  }, l.prototype.getPublicKey = function(p, _) {
    var I = this.keys.getPublic(_ === "compressed", !0);
    return _ === "hybrid" && (I[I.length - 1] % 2 ? I[0] = 7 : I[0] = 6), v(I, p);
  }, l.prototype.getPrivateKey = function(p) {
    return v(this.keys.getPrivate(), p);
  }, l.prototype.setPublicKey = function(p, _) {
    return _ = _ || "utf8", Buffer$O.isBuffer(p) || (p = new Buffer$O(p, _)), this.keys._importPublic(p), this;
  }, l.prototype.setPrivateKey = function(p, _) {
    _ = _ || "utf8", Buffer$O.isBuffer(p) || (p = new Buffer$O(p, _));
    var I = new u(p);
    return I = I.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(I), this;
  };
  function v(p, _, I) {
    Array.isArray(p) || (p = p.toArray());
    var P = new Buffer$O(p);
    if (I && P.length < I) {
      var $ = new Buffer$O(I - P.length);
      $.fill(0), P = Buffer$O.concat([$, P]);
    }
    return _ ? P.toString(_) : P;
  }
  return browser$3;
}
var browser$2 = {}, createHash$2 = browser$a, Buffer$9 = safeBufferExports$3.Buffer, mgf$2 = function(a, u) {
  for (var c = Buffer$9.alloc(0), l = 0, v; c.length < u; )
    v = i2ops(l++), c = Buffer$9.concat([c, createHash$2("sha1").update(a).update(v).digest()]);
  return c.slice(0, u);
};
function i2ops(a) {
  var u = Buffer$9.allocUnsafe(4);
  return u.writeUInt32BE(a, 0), u;
}
var xor$2 = function a(u, c) {
  for (var l = u.length, v = -1; ++v < l; )
    u[v] ^= c[v];
  return u;
}, bn = { exports: {} };
bn.exports;
(function(a) {
  (function(u, c) {
    function l(C, b) {
      if (!C)
        throw new Error(b || "Assertion failed");
    }
    function v(C, b) {
      C.super_ = b;
      var E = function() {
      };
      E.prototype = b.prototype, C.prototype = new E(), C.prototype.constructor = C;
    }
    function p(C, b, E) {
      if (p.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((b === "le" || b === "be") && (E = b, b = 10), this._init(C || 0, b || 10, E || "be"));
    }
    typeof u == "object" ? u.exports = p : c.BN = p, p.BN = p, p.wordSize = 26;
    var _;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? _ = window.Buffer : _ = require$$0$2.Buffer;
    } catch {
    }
    p.isBN = function(b) {
      return b instanceof p ? !0 : b !== null && typeof b == "object" && b.constructor.wordSize === p.wordSize && Array.isArray(b.words);
    }, p.max = function(b, E) {
      return b.cmp(E) > 0 ? b : E;
    }, p.min = function(b, E) {
      return b.cmp(E) < 0 ? b : E;
    }, p.prototype._init = function(b, E, k) {
      if (typeof b == "number")
        return this._initNumber(b, E, k);
      if (typeof b == "object")
        return this._initArray(b, E, k);
      E === "hex" && (E = 16), l(E === (E | 0) && E >= 2 && E <= 36), b = b.toString().replace(/\s+/g, "");
      var O = 0;
      b[0] === "-" && (O++, this.negative = 1), O < b.length && (E === 16 ? this._parseHex(b, O, k) : (this._parseBase(b, E, O), k === "le" && this._initArray(this.toArray(), E, k)));
    }, p.prototype._initNumber = function(b, E, k) {
      b < 0 && (this.negative = 1, b = -b), b < 67108864 ? (this.words = [b & 67108863], this.length = 1) : b < 4503599627370496 ? (this.words = [
        b & 67108863,
        b / 67108864 & 67108863
      ], this.length = 2) : (l(b < 9007199254740992), this.words = [
        b & 67108863,
        b / 67108864 & 67108863,
        1
      ], this.length = 3), k === "le" && this._initArray(this.toArray(), E, k);
    }, p.prototype._initArray = function(b, E, k) {
      if (l(typeof b.length == "number"), b.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(b.length / 3), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var A, x, Y = 0;
      if (k === "be")
        for (O = b.length - 1, A = 0; O >= 0; O -= 3)
          x = b[O] | b[O - 1] << 8 | b[O - 2] << 16, this.words[A] |= x << Y & 67108863, this.words[A + 1] = x >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, A++);
      else if (k === "le")
        for (O = 0, A = 0; O < b.length; O += 3)
          x = b[O] | b[O + 1] << 8 | b[O + 2] << 16, this.words[A] |= x << Y & 67108863, this.words[A + 1] = x >>> 26 - Y & 67108863, Y += 24, Y >= 26 && (Y -= 26, A++);
      return this.strip();
    };
    function I(C, b) {
      var E = C.charCodeAt(b);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function P(C, b, E) {
      var k = I(C, E);
      return E - 1 >= b && (k |= I(C, E - 1) << 4), k;
    }
    p.prototype._parseHex = function(b, E, k) {
      this.length = Math.ceil((b.length - E) / 6), this.words = new Array(this.length);
      for (var O = 0; O < this.length; O++)
        this.words[O] = 0;
      var A = 0, x = 0, Y;
      if (k === "be")
        for (O = b.length - 1; O >= E; O -= 2)
          Y = P(b, E, O) << A, this.words[x] |= Y & 67108863, A >= 18 ? (A -= 18, x += 1, this.words[x] |= Y >>> 26) : A += 8;
      else {
        var B = b.length - E;
        for (O = B % 2 === 0 ? E + 1 : E; O < b.length; O += 2)
          Y = P(b, E, O) << A, this.words[x] |= Y & 67108863, A >= 18 ? (A -= 18, x += 1, this.words[x] |= Y >>> 26) : A += 8;
      }
      this.strip();
    };
    function $(C, b, E, k) {
      for (var O = 0, A = Math.min(C.length, E), x = b; x < A; x++) {
        var Y = C.charCodeAt(x) - 48;
        O *= k, Y >= 49 ? O += Y - 49 + 10 : Y >= 17 ? O += Y - 17 + 10 : O += Y;
      }
      return O;
    }
    p.prototype._parseBase = function(b, E, k) {
      this.words = [0], this.length = 1;
      for (var O = 0, A = 1; A <= 67108863; A *= E)
        O++;
      O--, A = A / E | 0;
      for (var x = b.length - k, Y = x % O, B = Math.min(x, x - Y) + k, T = 0, D = k; D < B; D += O)
        T = $(b, D, D + O, E), this.imuln(A), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      if (Y !== 0) {
        var te = 1;
        for (T = $(b, D, b.length, E), D = 0; D < Y; D++)
          te *= E;
        this.imuln(te), this.words[0] + T < 67108864 ? this.words[0] += T : this._iaddn(T);
      }
      this.strip();
    }, p.prototype.copy = function(b) {
      b.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        b.words[E] = this.words[E];
      b.length = this.length, b.negative = this.negative, b.red = this.red;
    }, p.prototype.clone = function() {
      var b = new p(null);
      return this.copy(b), b;
    }, p.prototype._expand = function(b) {
      for (; this.length < b; )
        this.words[this.length++] = 0;
      return this;
    }, p.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, p.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, p.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var F = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], H = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], j = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    p.prototype.toString = function(b, E) {
      b = b || 10, E = E | 0 || 1;
      var k;
      if (b === 16 || b === "hex") {
        k = "";
        for (var O = 0, A = 0, x = 0; x < this.length; x++) {
          var Y = this.words[x], B = ((Y << O | A) & 16777215).toString(16);
          A = Y >>> 24 - O & 16777215, A !== 0 || x !== this.length - 1 ? k = F[6 - B.length] + B + k : k = B + k, O += 2, O >= 26 && (O -= 26, x--);
        }
        for (A !== 0 && (k = A.toString(16) + k); k.length % E !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      if (b === (b | 0) && b >= 2 && b <= 36) {
        var T = H[b], D = j[b];
        k = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var me = te.modn(D).toString(b);
          te = te.idivn(D), te.isZero() ? k = me + k : k = F[T - me.length] + me + k;
        }
        for (this.isZero() && (k = "0" + k); k.length % E !== 0; )
          k = "0" + k;
        return this.negative !== 0 && (k = "-" + k), k;
      }
      l(!1, "Base should be between 2 and 36");
    }, p.prototype.toNumber = function() {
      var b = this.words[0];
      return this.length === 2 ? b += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? b += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && l(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -b : b;
    }, p.prototype.toJSON = function() {
      return this.toString(16);
    }, p.prototype.toBuffer = function(b, E) {
      return l(typeof _ < "u"), this.toArrayLike(_, b, E);
    }, p.prototype.toArray = function(b, E) {
      return this.toArrayLike(Array, b, E);
    }, p.prototype.toArrayLike = function(b, E, k) {
      var O = this.byteLength(), A = k || Math.max(1, O);
      l(O <= A, "byte array longer than desired length"), l(A > 0, "Requested array length <= 0"), this.strip();
      var x = E === "le", Y = new b(A), B, T, D = this.clone();
      if (x) {
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), Y[T] = B;
        for (; T < A; T++)
          Y[T] = 0;
      } else {
        for (T = 0; T < A - O; T++)
          Y[T] = 0;
        for (T = 0; !D.isZero(); T++)
          B = D.andln(255), D.iushrn(8), Y[A - T - 1] = B;
      }
      return Y;
    }, Math.clz32 ? p.prototype._countBits = function(b) {
      return 32 - Math.clz32(b);
    } : p.prototype._countBits = function(b) {
      var E = b, k = 0;
      return E >= 4096 && (k += 13, E >>>= 13), E >= 64 && (k += 7, E >>>= 7), E >= 8 && (k += 4, E >>>= 4), E >= 2 && (k += 2, E >>>= 2), k + E;
    }, p.prototype._zeroBits = function(b) {
      if (b === 0)
        return 26;
      var E = b, k = 0;
      return E & 8191 || (k += 13, E >>>= 13), E & 127 || (k += 7, E >>>= 7), E & 15 || (k += 4, E >>>= 4), E & 3 || (k += 2, E >>>= 2), E & 1 || k++, k;
    }, p.prototype.bitLength = function() {
      var b = this.words[this.length - 1], E = this._countBits(b);
      return (this.length - 1) * 26 + E;
    };
    function ee(C) {
      for (var b = new Array(C.bitLength()), E = 0; E < b.length; E++) {
        var k = E / 26 | 0, O = E % 26;
        b[E] = (C.words[k] & 1 << O) >>> O;
      }
      return b;
    }
    p.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var b = 0, E = 0; E < this.length; E++) {
        var k = this._zeroBits(this.words[E]);
        if (b += k, k !== 26)
          break;
      }
      return b;
    }, p.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, p.prototype.toTwos = function(b) {
      return this.negative !== 0 ? this.abs().inotn(b).iaddn(1) : this.clone();
    }, p.prototype.fromTwos = function(b) {
      return this.testn(b - 1) ? this.notn(b).iaddn(1).ineg() : this.clone();
    }, p.prototype.isNeg = function() {
      return this.negative !== 0;
    }, p.prototype.neg = function() {
      return this.clone().ineg();
    }, p.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, p.prototype.iuor = function(b) {
      for (; this.length < b.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < b.length; E++)
        this.words[E] = this.words[E] | b.words[E];
      return this.strip();
    }, p.prototype.ior = function(b) {
      return l((this.negative | b.negative) === 0), this.iuor(b);
    }, p.prototype.or = function(b) {
      return this.length > b.length ? this.clone().ior(b) : b.clone().ior(this);
    }, p.prototype.uor = function(b) {
      return this.length > b.length ? this.clone().iuor(b) : b.clone().iuor(this);
    }, p.prototype.iuand = function(b) {
      var E;
      this.length > b.length ? E = b : E = this;
      for (var k = 0; k < E.length; k++)
        this.words[k] = this.words[k] & b.words[k];
      return this.length = E.length, this.strip();
    }, p.prototype.iand = function(b) {
      return l((this.negative | b.negative) === 0), this.iuand(b);
    }, p.prototype.and = function(b) {
      return this.length > b.length ? this.clone().iand(b) : b.clone().iand(this);
    }, p.prototype.uand = function(b) {
      return this.length > b.length ? this.clone().iuand(b) : b.clone().iuand(this);
    }, p.prototype.iuxor = function(b) {
      var E, k;
      this.length > b.length ? (E = this, k = b) : (E = b, k = this);
      for (var O = 0; O < k.length; O++)
        this.words[O] = E.words[O] ^ k.words[O];
      if (this !== E)
        for (; O < E.length; O++)
          this.words[O] = E.words[O];
      return this.length = E.length, this.strip();
    }, p.prototype.ixor = function(b) {
      return l((this.negative | b.negative) === 0), this.iuxor(b);
    }, p.prototype.xor = function(b) {
      return this.length > b.length ? this.clone().ixor(b) : b.clone().ixor(this);
    }, p.prototype.uxor = function(b) {
      return this.length > b.length ? this.clone().iuxor(b) : b.clone().iuxor(this);
    }, p.prototype.inotn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = Math.ceil(b / 26) | 0, k = b % 26;
      this._expand(E), k > 0 && E--;
      for (var O = 0; O < E; O++)
        this.words[O] = ~this.words[O] & 67108863;
      return k > 0 && (this.words[O] = ~this.words[O] & 67108863 >> 26 - k), this.strip();
    }, p.prototype.notn = function(b) {
      return this.clone().inotn(b);
    }, p.prototype.setn = function(b, E) {
      l(typeof b == "number" && b >= 0);
      var k = b / 26 | 0, O = b % 26;
      return this._expand(k + 1), E ? this.words[k] = this.words[k] | 1 << O : this.words[k] = this.words[k] & ~(1 << O), this.strip();
    }, p.prototype.iadd = function(b) {
      var E;
      if (this.negative !== 0 && b.negative === 0)
        return this.negative = 0, E = this.isub(b), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && b.negative !== 0)
        return b.negative = 0, E = this.isub(b), b.negative = 1, E._normSign();
      var k, O;
      this.length > b.length ? (k = this, O = b) : (k = b, O = this);
      for (var A = 0, x = 0; x < O.length; x++)
        E = (k.words[x] | 0) + (O.words[x] | 0) + A, this.words[x] = E & 67108863, A = E >>> 26;
      for (; A !== 0 && x < k.length; x++)
        E = (k.words[x] | 0) + A, this.words[x] = E & 67108863, A = E >>> 26;
      if (this.length = k.length, A !== 0)
        this.words[this.length] = A, this.length++;
      else if (k !== this)
        for (; x < k.length; x++)
          this.words[x] = k.words[x];
      return this;
    }, p.prototype.add = function(b) {
      var E;
      return b.negative !== 0 && this.negative === 0 ? (b.negative = 0, E = this.sub(b), b.negative ^= 1, E) : b.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = b.sub(this), this.negative = 1, E) : this.length > b.length ? this.clone().iadd(b) : b.clone().iadd(this);
    }, p.prototype.isub = function(b) {
      if (b.negative !== 0) {
        b.negative = 0;
        var E = this.iadd(b);
        return b.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(b), this.negative = 1, this._normSign();
      var k = this.cmp(b);
      if (k === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var O, A;
      k > 0 ? (O = this, A = b) : (O = b, A = this);
      for (var x = 0, Y = 0; Y < A.length; Y++)
        E = (O.words[Y] | 0) - (A.words[Y] | 0) + x, x = E >> 26, this.words[Y] = E & 67108863;
      for (; x !== 0 && Y < O.length; Y++)
        E = (O.words[Y] | 0) + x, x = E >> 26, this.words[Y] = E & 67108863;
      if (x === 0 && Y < O.length && O !== this)
        for (; Y < O.length; Y++)
          this.words[Y] = O.words[Y];
      return this.length = Math.max(this.length, Y), O !== this && (this.negative = 1), this.strip();
    }, p.prototype.sub = function(b) {
      return this.clone().isub(b);
    };
    function X(C, b, E) {
      E.negative = b.negative ^ C.negative;
      var k = C.length + b.length | 0;
      E.length = k, k = k - 1 | 0;
      var O = C.words[0] | 0, A = b.words[0] | 0, x = O * A, Y = x & 67108863, B = x / 67108864 | 0;
      E.words[0] = Y;
      for (var T = 1; T < k; T++) {
        for (var D = B >>> 26, te = B & 67108863, me = Math.min(T, b.length - 1), Ie = Math.max(0, T - C.length + 1); Ie <= me; Ie++) {
          var $e = T - Ie | 0;
          O = C.words[$e] | 0, A = b.words[Ie] | 0, x = O * A + te, D += x / 67108864 | 0, te = x & 67108863;
        }
        E.words[T] = te | 0, B = D | 0;
      }
      return B !== 0 ? E.words[T] = B | 0 : E.length--, E.strip();
    }
    var ie = function(b, E, k) {
      var O = b.words, A = E.words, x = k.words, Y = 0, B, T, D, te = O[0] | 0, me = te & 8191, Ie = te >>> 13, $e = O[1] | 0, ye = $e & 8191, fe = $e >>> 13, Me = O[2] | 0, Ae = Me & 8191, xe = Me >>> 13, ae = O[3] | 0, N = ae & 8191, re = ae >>> 13, le = O[4] | 0, Ne = le & 8191, Oe = le >>> 13, qe = O[5] | 0, je = qe & 8191, Fe = qe >>> 13, yt = O[6] | 0, Xe = yt & 8191, Ge = yt >>> 13, V = O[7] | 0, ge = V & 8191, Te = V >>> 13, We = O[8] | 0, Re = We & 8191, J = We >>> 13, Ee = O[9] | 0, ue = Ee & 8191, ce = Ee >>> 13, ve = A[0] | 0, Ce = ve & 8191, Be = ve >>> 13, He = A[1] | 0, Ve = He & 8191, Ze = He >>> 13, Ke = A[2] | 0, U = Ke & 8191, se = Ke >>> 13, Se = A[3] | 0, Ue = Se & 8191, De = Se >>> 13, Ye = A[4] | 0, Qe = Ye & 8191, st = Ye >>> 13, St = A[5] | 0, tt = St & 8191, it = St >>> 13, Tt = A[6] | 0, rt = Tt & 8191, dt = Tt >>> 13, wt = A[7] | 0, nt = wt & 8191, at = wt >>> 13, gt = A[8] | 0, ot = gt & 8191, ct = gt >>> 13, Ct = A[9] | 0, ut = Ct & 8191, lt = Ct >>> 13;
      k.negative = b.negative ^ E.negative, k.length = 19, B = Math.imul(me, Ce), T = Math.imul(me, Be), T = T + Math.imul(Ie, Ce) | 0, D = Math.imul(Ie, Be);
      var kt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, B = Math.imul(ye, Ce), T = Math.imul(ye, Be), T = T + Math.imul(fe, Ce) | 0, D = Math.imul(fe, Be), B = B + Math.imul(me, Ve) | 0, T = T + Math.imul(me, Ze) | 0, T = T + Math.imul(Ie, Ve) | 0, D = D + Math.imul(Ie, Ze) | 0;
      var Rt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, B = Math.imul(Ae, Ce), T = Math.imul(Ae, Be), T = T + Math.imul(xe, Ce) | 0, D = Math.imul(xe, Be), B = B + Math.imul(ye, Ve) | 0, T = T + Math.imul(ye, Ze) | 0, T = T + Math.imul(fe, Ve) | 0, D = D + Math.imul(fe, Ze) | 0, B = B + Math.imul(me, U) | 0, T = T + Math.imul(me, se) | 0, T = T + Math.imul(Ie, U) | 0, D = D + Math.imul(Ie, se) | 0;
      var Je = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, B = Math.imul(N, Ce), T = Math.imul(N, Be), T = T + Math.imul(re, Ce) | 0, D = Math.imul(re, Be), B = B + Math.imul(Ae, Ve) | 0, T = T + Math.imul(Ae, Ze) | 0, T = T + Math.imul(xe, Ve) | 0, D = D + Math.imul(xe, Ze) | 0, B = B + Math.imul(ye, U) | 0, T = T + Math.imul(ye, se) | 0, T = T + Math.imul(fe, U) | 0, D = D + Math.imul(fe, se) | 0, B = B + Math.imul(me, Ue) | 0, T = T + Math.imul(me, De) | 0, T = T + Math.imul(Ie, Ue) | 0, D = D + Math.imul(Ie, De) | 0;
      var ze = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, B = Math.imul(Ne, Ce), T = Math.imul(Ne, Be), T = T + Math.imul(Oe, Ce) | 0, D = Math.imul(Oe, Be), B = B + Math.imul(N, Ve) | 0, T = T + Math.imul(N, Ze) | 0, T = T + Math.imul(re, Ve) | 0, D = D + Math.imul(re, Ze) | 0, B = B + Math.imul(Ae, U) | 0, T = T + Math.imul(Ae, se) | 0, T = T + Math.imul(xe, U) | 0, D = D + Math.imul(xe, se) | 0, B = B + Math.imul(ye, Ue) | 0, T = T + Math.imul(ye, De) | 0, T = T + Math.imul(fe, Ue) | 0, D = D + Math.imul(fe, De) | 0, B = B + Math.imul(me, Qe) | 0, T = T + Math.imul(me, st) | 0, T = T + Math.imul(Ie, Qe) | 0, D = D + Math.imul(Ie, st) | 0;
      var et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (et >>> 26) | 0, et &= 67108863, B = Math.imul(je, Ce), T = Math.imul(je, Be), T = T + Math.imul(Fe, Ce) | 0, D = Math.imul(Fe, Be), B = B + Math.imul(Ne, Ve) | 0, T = T + Math.imul(Ne, Ze) | 0, T = T + Math.imul(Oe, Ve) | 0, D = D + Math.imul(Oe, Ze) | 0, B = B + Math.imul(N, U) | 0, T = T + Math.imul(N, se) | 0, T = T + Math.imul(re, U) | 0, D = D + Math.imul(re, se) | 0, B = B + Math.imul(Ae, Ue) | 0, T = T + Math.imul(Ae, De) | 0, T = T + Math.imul(xe, Ue) | 0, D = D + Math.imul(xe, De) | 0, B = B + Math.imul(ye, Qe) | 0, T = T + Math.imul(ye, st) | 0, T = T + Math.imul(fe, Qe) | 0, D = D + Math.imul(fe, st) | 0, B = B + Math.imul(me, tt) | 0, T = T + Math.imul(me, it) | 0, T = T + Math.imul(Ie, tt) | 0, D = D + Math.imul(Ie, it) | 0;
      var pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, B = Math.imul(Xe, Ce), T = Math.imul(Xe, Be), T = T + Math.imul(Ge, Ce) | 0, D = Math.imul(Ge, Be), B = B + Math.imul(je, Ve) | 0, T = T + Math.imul(je, Ze) | 0, T = T + Math.imul(Fe, Ve) | 0, D = D + Math.imul(Fe, Ze) | 0, B = B + Math.imul(Ne, U) | 0, T = T + Math.imul(Ne, se) | 0, T = T + Math.imul(Oe, U) | 0, D = D + Math.imul(Oe, se) | 0, B = B + Math.imul(N, Ue) | 0, T = T + Math.imul(N, De) | 0, T = T + Math.imul(re, Ue) | 0, D = D + Math.imul(re, De) | 0, B = B + Math.imul(Ae, Qe) | 0, T = T + Math.imul(Ae, st) | 0, T = T + Math.imul(xe, Qe) | 0, D = D + Math.imul(xe, st) | 0, B = B + Math.imul(ye, tt) | 0, T = T + Math.imul(ye, it) | 0, T = T + Math.imul(fe, tt) | 0, D = D + Math.imul(fe, it) | 0, B = B + Math.imul(me, rt) | 0, T = T + Math.imul(me, dt) | 0, T = T + Math.imul(Ie, rt) | 0, D = D + Math.imul(Ie, dt) | 0;
      var mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, B = Math.imul(ge, Ce), T = Math.imul(ge, Be), T = T + Math.imul(Te, Ce) | 0, D = Math.imul(Te, Be), B = B + Math.imul(Xe, Ve) | 0, T = T + Math.imul(Xe, Ze) | 0, T = T + Math.imul(Ge, Ve) | 0, D = D + Math.imul(Ge, Ze) | 0, B = B + Math.imul(je, U) | 0, T = T + Math.imul(je, se) | 0, T = T + Math.imul(Fe, U) | 0, D = D + Math.imul(Fe, se) | 0, B = B + Math.imul(Ne, Ue) | 0, T = T + Math.imul(Ne, De) | 0, T = T + Math.imul(Oe, Ue) | 0, D = D + Math.imul(Oe, De) | 0, B = B + Math.imul(N, Qe) | 0, T = T + Math.imul(N, st) | 0, T = T + Math.imul(re, Qe) | 0, D = D + Math.imul(re, st) | 0, B = B + Math.imul(Ae, tt) | 0, T = T + Math.imul(Ae, it) | 0, T = T + Math.imul(xe, tt) | 0, D = D + Math.imul(xe, it) | 0, B = B + Math.imul(ye, rt) | 0, T = T + Math.imul(ye, dt) | 0, T = T + Math.imul(fe, rt) | 0, D = D + Math.imul(fe, dt) | 0, B = B + Math.imul(me, nt) | 0, T = T + Math.imul(me, at) | 0, T = T + Math.imul(Ie, nt) | 0, D = D + Math.imul(Ie, at) | 0;
      var vt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, B = Math.imul(Re, Ce), T = Math.imul(Re, Be), T = T + Math.imul(J, Ce) | 0, D = Math.imul(J, Be), B = B + Math.imul(ge, Ve) | 0, T = T + Math.imul(ge, Ze) | 0, T = T + Math.imul(Te, Ve) | 0, D = D + Math.imul(Te, Ze) | 0, B = B + Math.imul(Xe, U) | 0, T = T + Math.imul(Xe, se) | 0, T = T + Math.imul(Ge, U) | 0, D = D + Math.imul(Ge, se) | 0, B = B + Math.imul(je, Ue) | 0, T = T + Math.imul(je, De) | 0, T = T + Math.imul(Fe, Ue) | 0, D = D + Math.imul(Fe, De) | 0, B = B + Math.imul(Ne, Qe) | 0, T = T + Math.imul(Ne, st) | 0, T = T + Math.imul(Oe, Qe) | 0, D = D + Math.imul(Oe, st) | 0, B = B + Math.imul(N, tt) | 0, T = T + Math.imul(N, it) | 0, T = T + Math.imul(re, tt) | 0, D = D + Math.imul(re, it) | 0, B = B + Math.imul(Ae, rt) | 0, T = T + Math.imul(Ae, dt) | 0, T = T + Math.imul(xe, rt) | 0, D = D + Math.imul(xe, dt) | 0, B = B + Math.imul(ye, nt) | 0, T = T + Math.imul(ye, at) | 0, T = T + Math.imul(fe, nt) | 0, D = D + Math.imul(fe, at) | 0, B = B + Math.imul(me, ot) | 0, T = T + Math.imul(me, ct) | 0, T = T + Math.imul(Ie, ot) | 0, D = D + Math.imul(Ie, ct) | 0;
      var ht = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, B = Math.imul(ue, Ce), T = Math.imul(ue, Be), T = T + Math.imul(ce, Ce) | 0, D = Math.imul(ce, Be), B = B + Math.imul(Re, Ve) | 0, T = T + Math.imul(Re, Ze) | 0, T = T + Math.imul(J, Ve) | 0, D = D + Math.imul(J, Ze) | 0, B = B + Math.imul(ge, U) | 0, T = T + Math.imul(ge, se) | 0, T = T + Math.imul(Te, U) | 0, D = D + Math.imul(Te, se) | 0, B = B + Math.imul(Xe, Ue) | 0, T = T + Math.imul(Xe, De) | 0, T = T + Math.imul(Ge, Ue) | 0, D = D + Math.imul(Ge, De) | 0, B = B + Math.imul(je, Qe) | 0, T = T + Math.imul(je, st) | 0, T = T + Math.imul(Fe, Qe) | 0, D = D + Math.imul(Fe, st) | 0, B = B + Math.imul(Ne, tt) | 0, T = T + Math.imul(Ne, it) | 0, T = T + Math.imul(Oe, tt) | 0, D = D + Math.imul(Oe, it) | 0, B = B + Math.imul(N, rt) | 0, T = T + Math.imul(N, dt) | 0, T = T + Math.imul(re, rt) | 0, D = D + Math.imul(re, dt) | 0, B = B + Math.imul(Ae, nt) | 0, T = T + Math.imul(Ae, at) | 0, T = T + Math.imul(xe, nt) | 0, D = D + Math.imul(xe, at) | 0, B = B + Math.imul(ye, ot) | 0, T = T + Math.imul(ye, ct) | 0, T = T + Math.imul(fe, ot) | 0, D = D + Math.imul(fe, ct) | 0, B = B + Math.imul(me, ut) | 0, T = T + Math.imul(me, lt) | 0, T = T + Math.imul(Ie, ut) | 0, D = D + Math.imul(Ie, lt) | 0;
      var _t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, B = Math.imul(ue, Ve), T = Math.imul(ue, Ze), T = T + Math.imul(ce, Ve) | 0, D = Math.imul(ce, Ze), B = B + Math.imul(Re, U) | 0, T = T + Math.imul(Re, se) | 0, T = T + Math.imul(J, U) | 0, D = D + Math.imul(J, se) | 0, B = B + Math.imul(ge, Ue) | 0, T = T + Math.imul(ge, De) | 0, T = T + Math.imul(Te, Ue) | 0, D = D + Math.imul(Te, De) | 0, B = B + Math.imul(Xe, Qe) | 0, T = T + Math.imul(Xe, st) | 0, T = T + Math.imul(Ge, Qe) | 0, D = D + Math.imul(Ge, st) | 0, B = B + Math.imul(je, tt) | 0, T = T + Math.imul(je, it) | 0, T = T + Math.imul(Fe, tt) | 0, D = D + Math.imul(Fe, it) | 0, B = B + Math.imul(Ne, rt) | 0, T = T + Math.imul(Ne, dt) | 0, T = T + Math.imul(Oe, rt) | 0, D = D + Math.imul(Oe, dt) | 0, B = B + Math.imul(N, nt) | 0, T = T + Math.imul(N, at) | 0, T = T + Math.imul(re, nt) | 0, D = D + Math.imul(re, at) | 0, B = B + Math.imul(Ae, ot) | 0, T = T + Math.imul(Ae, ct) | 0, T = T + Math.imul(xe, ot) | 0, D = D + Math.imul(xe, ct) | 0, B = B + Math.imul(ye, ut) | 0, T = T + Math.imul(ye, lt) | 0, T = T + Math.imul(fe, ut) | 0, D = D + Math.imul(fe, lt) | 0;
      var Et = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, B = Math.imul(ue, U), T = Math.imul(ue, se), T = T + Math.imul(ce, U) | 0, D = Math.imul(ce, se), B = B + Math.imul(Re, Ue) | 0, T = T + Math.imul(Re, De) | 0, T = T + Math.imul(J, Ue) | 0, D = D + Math.imul(J, De) | 0, B = B + Math.imul(ge, Qe) | 0, T = T + Math.imul(ge, st) | 0, T = T + Math.imul(Te, Qe) | 0, D = D + Math.imul(Te, st) | 0, B = B + Math.imul(Xe, tt) | 0, T = T + Math.imul(Xe, it) | 0, T = T + Math.imul(Ge, tt) | 0, D = D + Math.imul(Ge, it) | 0, B = B + Math.imul(je, rt) | 0, T = T + Math.imul(je, dt) | 0, T = T + Math.imul(Fe, rt) | 0, D = D + Math.imul(Fe, dt) | 0, B = B + Math.imul(Ne, nt) | 0, T = T + Math.imul(Ne, at) | 0, T = T + Math.imul(Oe, nt) | 0, D = D + Math.imul(Oe, at) | 0, B = B + Math.imul(N, ot) | 0, T = T + Math.imul(N, ct) | 0, T = T + Math.imul(re, ot) | 0, D = D + Math.imul(re, ct) | 0, B = B + Math.imul(Ae, ut) | 0, T = T + Math.imul(Ae, lt) | 0, T = T + Math.imul(xe, ut) | 0, D = D + Math.imul(xe, lt) | 0;
      var Pt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, B = Math.imul(ue, Ue), T = Math.imul(ue, De), T = T + Math.imul(ce, Ue) | 0, D = Math.imul(ce, De), B = B + Math.imul(Re, Qe) | 0, T = T + Math.imul(Re, st) | 0, T = T + Math.imul(J, Qe) | 0, D = D + Math.imul(J, st) | 0, B = B + Math.imul(ge, tt) | 0, T = T + Math.imul(ge, it) | 0, T = T + Math.imul(Te, tt) | 0, D = D + Math.imul(Te, it) | 0, B = B + Math.imul(Xe, rt) | 0, T = T + Math.imul(Xe, dt) | 0, T = T + Math.imul(Ge, rt) | 0, D = D + Math.imul(Ge, dt) | 0, B = B + Math.imul(je, nt) | 0, T = T + Math.imul(je, at) | 0, T = T + Math.imul(Fe, nt) | 0, D = D + Math.imul(Fe, at) | 0, B = B + Math.imul(Ne, ot) | 0, T = T + Math.imul(Ne, ct) | 0, T = T + Math.imul(Oe, ot) | 0, D = D + Math.imul(Oe, ct) | 0, B = B + Math.imul(N, ut) | 0, T = T + Math.imul(N, lt) | 0, T = T + Math.imul(re, ut) | 0, D = D + Math.imul(re, lt) | 0;
      var Nt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, B = Math.imul(ue, Qe), T = Math.imul(ue, st), T = T + Math.imul(ce, Qe) | 0, D = Math.imul(ce, st), B = B + Math.imul(Re, tt) | 0, T = T + Math.imul(Re, it) | 0, T = T + Math.imul(J, tt) | 0, D = D + Math.imul(J, it) | 0, B = B + Math.imul(ge, rt) | 0, T = T + Math.imul(ge, dt) | 0, T = T + Math.imul(Te, rt) | 0, D = D + Math.imul(Te, dt) | 0, B = B + Math.imul(Xe, nt) | 0, T = T + Math.imul(Xe, at) | 0, T = T + Math.imul(Ge, nt) | 0, D = D + Math.imul(Ge, at) | 0, B = B + Math.imul(je, ot) | 0, T = T + Math.imul(je, ct) | 0, T = T + Math.imul(Fe, ot) | 0, D = D + Math.imul(Fe, ct) | 0, B = B + Math.imul(Ne, ut) | 0, T = T + Math.imul(Ne, lt) | 0, T = T + Math.imul(Oe, ut) | 0, D = D + Math.imul(Oe, lt) | 0;
      var Mt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, B = Math.imul(ue, tt), T = Math.imul(ue, it), T = T + Math.imul(ce, tt) | 0, D = Math.imul(ce, it), B = B + Math.imul(Re, rt) | 0, T = T + Math.imul(Re, dt) | 0, T = T + Math.imul(J, rt) | 0, D = D + Math.imul(J, dt) | 0, B = B + Math.imul(ge, nt) | 0, T = T + Math.imul(ge, at) | 0, T = T + Math.imul(Te, nt) | 0, D = D + Math.imul(Te, at) | 0, B = B + Math.imul(Xe, ot) | 0, T = T + Math.imul(Xe, ct) | 0, T = T + Math.imul(Ge, ot) | 0, D = D + Math.imul(Ge, ct) | 0, B = B + Math.imul(je, ut) | 0, T = T + Math.imul(je, lt) | 0, T = T + Math.imul(Fe, ut) | 0, D = D + Math.imul(Fe, lt) | 0;
      var Ot = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, B = Math.imul(ue, rt), T = Math.imul(ue, dt), T = T + Math.imul(ce, rt) | 0, D = Math.imul(ce, dt), B = B + Math.imul(Re, nt) | 0, T = T + Math.imul(Re, at) | 0, T = T + Math.imul(J, nt) | 0, D = D + Math.imul(J, at) | 0, B = B + Math.imul(ge, ot) | 0, T = T + Math.imul(ge, ct) | 0, T = T + Math.imul(Te, ot) | 0, D = D + Math.imul(Te, ct) | 0, B = B + Math.imul(Xe, ut) | 0, T = T + Math.imul(Xe, lt) | 0, T = T + Math.imul(Ge, ut) | 0, D = D + Math.imul(Ge, lt) | 0;
      var $t = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, B = Math.imul(ue, nt), T = Math.imul(ue, at), T = T + Math.imul(ce, nt) | 0, D = Math.imul(ce, at), B = B + Math.imul(Re, ot) | 0, T = T + Math.imul(Re, ct) | 0, T = T + Math.imul(J, ot) | 0, D = D + Math.imul(J, ct) | 0, B = B + Math.imul(ge, ut) | 0, T = T + Math.imul(ge, lt) | 0, T = T + Math.imul(Te, ut) | 0, D = D + Math.imul(Te, lt) | 0;
      var Bt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, B = Math.imul(ue, ot), T = Math.imul(ue, ct), T = T + Math.imul(ce, ot) | 0, D = Math.imul(ce, ct), B = B + Math.imul(Re, ut) | 0, T = T + Math.imul(Re, lt) | 0, T = T + Math.imul(J, ut) | 0, D = D + Math.imul(J, lt) | 0;
      var xt = (Y + B | 0) + ((T & 8191) << 13) | 0;
      Y = (D + (T >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, B = Math.imul(ue, ut), T = Math.imul(ue, lt), T = T + Math.imul(ce, ut) | 0, D = Math.imul(ce, lt);
      var Ut = (Y + B | 0) + ((T & 8191) << 13) | 0;
      return Y = (D + (T >>> 13) | 0) + (Ut >>> 26) | 0, Ut &= 67108863, x[0] = kt, x[1] = Rt, x[2] = Je, x[3] = ze, x[4] = et, x[5] = pt, x[6] = mt, x[7] = vt, x[8] = ht, x[9] = _t, x[10] = Et, x[11] = Pt, x[12] = Nt, x[13] = Mt, x[14] = Ot, x[15] = $t, x[16] = Bt, x[17] = xt, x[18] = Ut, Y !== 0 && (x[19] = Y, k.length++), k;
    };
    Math.imul || (ie = X);
    function Q(C, b, E) {
      E.negative = b.negative ^ C.negative, E.length = C.length + b.length;
      for (var k = 0, O = 0, A = 0; A < E.length - 1; A++) {
        var x = O;
        O = 0;
        for (var Y = k & 67108863, B = Math.min(A, b.length - 1), T = Math.max(0, A - C.length + 1); T <= B; T++) {
          var D = A - T, te = C.words[D] | 0, me = b.words[T] | 0, Ie = te * me, $e = Ie & 67108863;
          x = x + (Ie / 67108864 | 0) | 0, $e = $e + Y | 0, Y = $e & 67108863, x = x + ($e >>> 26) | 0, O += x >>> 26, x &= 67108863;
        }
        E.words[A] = Y, k = x, x = O;
      }
      return k !== 0 ? E.words[A] = k : E.length--, E.strip();
    }
    function ne(C, b, E) {
      var k = new Z();
      return k.mulp(C, b, E);
    }
    p.prototype.mulTo = function(b, E) {
      var k, O = this.length + b.length;
      return this.length === 10 && b.length === 10 ? k = ie(this, b, E) : O < 63 ? k = X(this, b, E) : O < 1024 ? k = Q(this, b, E) : k = ne(this, b, E), k;
    };
    function Z(C, b) {
      this.x = C, this.y = b;
    }
    Z.prototype.makeRBT = function(b) {
      for (var E = new Array(b), k = p.prototype._countBits(b) - 1, O = 0; O < b; O++)
        E[O] = this.revBin(O, k, b);
      return E;
    }, Z.prototype.revBin = function(b, E, k) {
      if (b === 0 || b === k - 1)
        return b;
      for (var O = 0, A = 0; A < E; A++)
        O |= (b & 1) << E - A - 1, b >>= 1;
      return O;
    }, Z.prototype.permute = function(b, E, k, O, A, x) {
      for (var Y = 0; Y < x; Y++)
        O[Y] = E[b[Y]], A[Y] = k[b[Y]];
    }, Z.prototype.transform = function(b, E, k, O, A, x) {
      this.permute(x, b, E, k, O, A);
      for (var Y = 1; Y < A; Y <<= 1)
        for (var B = Y << 1, T = Math.cos(2 * Math.PI / B), D = Math.sin(2 * Math.PI / B), te = 0; te < A; te += B)
          for (var me = T, Ie = D, $e = 0; $e < Y; $e++) {
            var ye = k[te + $e], fe = O[te + $e], Me = k[te + $e + Y], Ae = O[te + $e + Y], xe = me * Me - Ie * Ae;
            Ae = me * Ae + Ie * Me, Me = xe, k[te + $e] = ye + Me, O[te + $e] = fe + Ae, k[te + $e + Y] = ye - Me, O[te + $e + Y] = fe - Ae, $e !== B && (xe = T * me - D * Ie, Ie = T * Ie + D * me, me = xe);
          }
    }, Z.prototype.guessLen13b = function(b, E) {
      var k = Math.max(E, b) | 1, O = k & 1, A = 0;
      for (k = k / 2 | 0; k; k = k >>> 1)
        A++;
      return 1 << A + 1 + O;
    }, Z.prototype.conjugate = function(b, E, k) {
      if (!(k <= 1))
        for (var O = 0; O < k / 2; O++) {
          var A = b[O];
          b[O] = b[k - O - 1], b[k - O - 1] = A, A = E[O], E[O] = -E[k - O - 1], E[k - O - 1] = -A;
        }
    }, Z.prototype.normalize13b = function(b, E) {
      for (var k = 0, O = 0; O < E / 2; O++) {
        var A = Math.round(b[2 * O + 1] / E) * 8192 + Math.round(b[2 * O] / E) + k;
        b[O] = A & 67108863, A < 67108864 ? k = 0 : k = A / 67108864 | 0;
      }
      return b;
    }, Z.prototype.convert13b = function(b, E, k, O) {
      for (var A = 0, x = 0; x < E; x++)
        A = A + (b[x] | 0), k[2 * x] = A & 8191, A = A >>> 13, k[2 * x + 1] = A & 8191, A = A >>> 13;
      for (x = 2 * E; x < O; ++x)
        k[x] = 0;
      l(A === 0), l((A & -8192) === 0);
    }, Z.prototype.stub = function(b) {
      for (var E = new Array(b), k = 0; k < b; k++)
        E[k] = 0;
      return E;
    }, Z.prototype.mulp = function(b, E, k) {
      var O = 2 * this.guessLen13b(b.length, E.length), A = this.makeRBT(O), x = this.stub(O), Y = new Array(O), B = new Array(O), T = new Array(O), D = new Array(O), te = new Array(O), me = new Array(O), Ie = k.words;
      Ie.length = O, this.convert13b(b.words, b.length, Y, O), this.convert13b(E.words, E.length, D, O), this.transform(Y, x, B, T, O, A), this.transform(D, x, te, me, O, A);
      for (var $e = 0; $e < O; $e++) {
        var ye = B[$e] * te[$e] - T[$e] * me[$e];
        T[$e] = B[$e] * me[$e] + T[$e] * te[$e], B[$e] = ye;
      }
      return this.conjugate(B, T, O), this.transform(B, T, Ie, x, O, A), this.conjugate(Ie, x, O), this.normalize13b(Ie, O), k.negative = b.negative ^ E.negative, k.length = b.length + E.length, k.strip();
    }, p.prototype.mul = function(b) {
      var E = new p(null);
      return E.words = new Array(this.length + b.length), this.mulTo(b, E);
    }, p.prototype.mulf = function(b) {
      var E = new p(null);
      return E.words = new Array(this.length + b.length), ne(this, b, E);
    }, p.prototype.imul = function(b) {
      return this.clone().mulTo(b, this);
    }, p.prototype.imuln = function(b) {
      l(typeof b == "number"), l(b < 67108864);
      for (var E = 0, k = 0; k < this.length; k++) {
        var O = (this.words[k] | 0) * b, A = (O & 67108863) + (E & 67108863);
        E >>= 26, E += O / 67108864 | 0, E += A >>> 26, this.words[k] = A & 67108863;
      }
      return E !== 0 && (this.words[k] = E, this.length++), this;
    }, p.prototype.muln = function(b) {
      return this.clone().imuln(b);
    }, p.prototype.sqr = function() {
      return this.mul(this);
    }, p.prototype.isqr = function() {
      return this.imul(this.clone());
    }, p.prototype.pow = function(b) {
      var E = ee(b);
      if (E.length === 0)
        return new p(1);
      for (var k = this, O = 0; O < E.length && E[O] === 0; O++, k = k.sqr())
        ;
      if (++O < E.length)
        for (var A = k.sqr(); O < E.length; O++, A = A.sqr())
          E[O] !== 0 && (k = k.mul(A));
      return k;
    }, p.prototype.iushln = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26, O = 67108863 >>> 26 - E << 26 - E, A;
      if (E !== 0) {
        var x = 0;
        for (A = 0; A < this.length; A++) {
          var Y = this.words[A] & O, B = (this.words[A] | 0) - Y << E;
          this.words[A] = B | x, x = Y >>> 26 - E;
        }
        x && (this.words[A] = x, this.length++);
      }
      if (k !== 0) {
        for (A = this.length - 1; A >= 0; A--)
          this.words[A + k] = this.words[A];
        for (A = 0; A < k; A++)
          this.words[A] = 0;
        this.length += k;
      }
      return this.strip();
    }, p.prototype.ishln = function(b) {
      return l(this.negative === 0), this.iushln(b);
    }, p.prototype.iushrn = function(b, E, k) {
      l(typeof b == "number" && b >= 0);
      var O;
      E ? O = (E - E % 26) / 26 : O = 0;
      var A = b % 26, x = Math.min((b - A) / 26, this.length), Y = 67108863 ^ 67108863 >>> A << A, B = k;
      if (O -= x, O = Math.max(0, O), B) {
        for (var T = 0; T < x; T++)
          B.words[T] = this.words[T];
        B.length = x;
      }
      if (x !== 0)
        if (this.length > x)
          for (this.length -= x, T = 0; T < this.length; T++)
            this.words[T] = this.words[T + x];
        else
          this.words[0] = 0, this.length = 1;
      var D = 0;
      for (T = this.length - 1; T >= 0 && (D !== 0 || T >= O); T--) {
        var te = this.words[T] | 0;
        this.words[T] = D << 26 - A | te >>> A, D = te & Y;
      }
      return B && D !== 0 && (B.words[B.length++] = D), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, p.prototype.ishrn = function(b, E, k) {
      return l(this.negative === 0), this.iushrn(b, E, k);
    }, p.prototype.shln = function(b) {
      return this.clone().ishln(b);
    }, p.prototype.ushln = function(b) {
      return this.clone().iushln(b);
    }, p.prototype.shrn = function(b) {
      return this.clone().ishrn(b);
    }, p.prototype.ushrn = function(b) {
      return this.clone().iushrn(b);
    }, p.prototype.testn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26, O = 1 << E;
      if (this.length <= k)
        return !1;
      var A = this.words[k];
      return !!(A & O);
    }, p.prototype.imaskn = function(b) {
      l(typeof b == "number" && b >= 0);
      var E = b % 26, k = (b - E) / 26;
      if (l(this.negative === 0, "imaskn works only with positive numbers"), this.length <= k)
        return this;
      if (E !== 0 && k++, this.length = Math.min(k, this.length), E !== 0) {
        var O = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= O;
      }
      return this.strip();
    }, p.prototype.maskn = function(b) {
      return this.clone().imaskn(b);
    }, p.prototype.iaddn = function(b) {
      return l(typeof b == "number"), l(b < 67108864), b < 0 ? this.isubn(-b) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < b ? (this.words[0] = b - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(b), this.negative = 1, this) : this._iaddn(b);
    }, p.prototype._iaddn = function(b) {
      this.words[0] += b;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, p.prototype.isubn = function(b) {
      if (l(typeof b == "number"), l(b < 67108864), b < 0)
        return this.iaddn(-b);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(b), this.negative = 1, this;
      if (this.words[0] -= b, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, p.prototype.addn = function(b) {
      return this.clone().iaddn(b);
    }, p.prototype.subn = function(b) {
      return this.clone().isubn(b);
    }, p.prototype.iabs = function() {
      return this.negative = 0, this;
    }, p.prototype.abs = function() {
      return this.clone().iabs();
    }, p.prototype._ishlnsubmul = function(b, E, k) {
      var O = b.length + k, A;
      this._expand(O);
      var x, Y = 0;
      for (A = 0; A < b.length; A++) {
        x = (this.words[A + k] | 0) + Y;
        var B = (b.words[A] | 0) * E;
        x -= B & 67108863, Y = (x >> 26) - (B / 67108864 | 0), this.words[A + k] = x & 67108863;
      }
      for (; A < this.length - k; A++)
        x = (this.words[A + k] | 0) + Y, Y = x >> 26, this.words[A + k] = x & 67108863;
      if (Y === 0)
        return this.strip();
      for (l(Y === -1), Y = 0, A = 0; A < this.length; A++)
        x = -(this.words[A] | 0) + Y, Y = x >> 26, this.words[A] = x & 67108863;
      return this.negative = 1, this.strip();
    }, p.prototype._wordDiv = function(b, E) {
      var k = this.length - b.length, O = this.clone(), A = b, x = A.words[A.length - 1] | 0, Y = this._countBits(x);
      k = 26 - Y, k !== 0 && (A = A.ushln(k), O.iushln(k), x = A.words[A.length - 1] | 0);
      var B = O.length - A.length, T;
      if (E !== "mod") {
        T = new p(null), T.length = B + 1, T.words = new Array(T.length);
        for (var D = 0; D < T.length; D++)
          T.words[D] = 0;
      }
      var te = O.clone()._ishlnsubmul(A, 1, B);
      te.negative === 0 && (O = te, T && (T.words[B] = 1));
      for (var me = B - 1; me >= 0; me--) {
        var Ie = (O.words[A.length + me] | 0) * 67108864 + (O.words[A.length + me - 1] | 0);
        for (Ie = Math.min(Ie / x | 0, 67108863), O._ishlnsubmul(A, Ie, me); O.negative !== 0; )
          Ie--, O.negative = 0, O._ishlnsubmul(A, 1, me), O.isZero() || (O.negative ^= 1);
        T && (T.words[me] = Ie);
      }
      return T && T.strip(), O.strip(), E !== "div" && k !== 0 && O.iushrn(k), {
        div: T || null,
        mod: O
      };
    }, p.prototype.divmod = function(b, E, k) {
      if (l(!b.isZero()), this.isZero())
        return {
          div: new p(0),
          mod: new p(0)
        };
      var O, A, x;
      return this.negative !== 0 && b.negative === 0 ? (x = this.neg().divmod(b, E), E !== "mod" && (O = x.div.neg()), E !== "div" && (A = x.mod.neg(), k && A.negative !== 0 && A.iadd(b)), {
        div: O,
        mod: A
      }) : this.negative === 0 && b.negative !== 0 ? (x = this.divmod(b.neg(), E), E !== "mod" && (O = x.div.neg()), {
        div: O,
        mod: x.mod
      }) : this.negative & b.negative ? (x = this.neg().divmod(b.neg(), E), E !== "div" && (A = x.mod.neg(), k && A.negative !== 0 && A.isub(b)), {
        div: x.div,
        mod: A
      }) : b.length > this.length || this.cmp(b) < 0 ? {
        div: new p(0),
        mod: this
      } : b.length === 1 ? E === "div" ? {
        div: this.divn(b.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new p(this.modn(b.words[0]))
      } : {
        div: this.divn(b.words[0]),
        mod: new p(this.modn(b.words[0]))
      } : this._wordDiv(b, E);
    }, p.prototype.div = function(b) {
      return this.divmod(b, "div", !1).div;
    }, p.prototype.mod = function(b) {
      return this.divmod(b, "mod", !1).mod;
    }, p.prototype.umod = function(b) {
      return this.divmod(b, "mod", !0).mod;
    }, p.prototype.divRound = function(b) {
      var E = this.divmod(b);
      if (E.mod.isZero())
        return E.div;
      var k = E.div.negative !== 0 ? E.mod.isub(b) : E.mod, O = b.ushrn(1), A = b.andln(1), x = k.cmp(O);
      return x < 0 || A === 1 && x === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, p.prototype.modn = function(b) {
      l(b <= 67108863);
      for (var E = (1 << 26) % b, k = 0, O = this.length - 1; O >= 0; O--)
        k = (E * k + (this.words[O] | 0)) % b;
      return k;
    }, p.prototype.idivn = function(b) {
      l(b <= 67108863);
      for (var E = 0, k = this.length - 1; k >= 0; k--) {
        var O = (this.words[k] | 0) + E * 67108864;
        this.words[k] = O / b | 0, E = O % b;
      }
      return this.strip();
    }, p.prototype.divn = function(b) {
      return this.clone().idivn(b);
    }, p.prototype.egcd = function(b) {
      l(b.negative === 0), l(!b.isZero());
      var E = this, k = b.clone();
      E.negative !== 0 ? E = E.umod(b) : E = E.clone();
      for (var O = new p(1), A = new p(0), x = new p(0), Y = new p(1), B = 0; E.isEven() && k.isEven(); )
        E.iushrn(1), k.iushrn(1), ++B;
      for (var T = k.clone(), D = E.clone(); !E.isZero(); ) {
        for (var te = 0, me = 1; !(E.words[0] & me) && te < 26; ++te, me <<= 1)
          ;
        if (te > 0)
          for (E.iushrn(te); te-- > 0; )
            (O.isOdd() || A.isOdd()) && (O.iadd(T), A.isub(D)), O.iushrn(1), A.iushrn(1);
        for (var Ie = 0, $e = 1; !(k.words[0] & $e) && Ie < 26; ++Ie, $e <<= 1)
          ;
        if (Ie > 0)
          for (k.iushrn(Ie); Ie-- > 0; )
            (x.isOdd() || Y.isOdd()) && (x.iadd(T), Y.isub(D)), x.iushrn(1), Y.iushrn(1);
        E.cmp(k) >= 0 ? (E.isub(k), O.isub(x), A.isub(Y)) : (k.isub(E), x.isub(O), Y.isub(A));
      }
      return {
        a: x,
        b: Y,
        gcd: k.iushln(B)
      };
    }, p.prototype._invmp = function(b) {
      l(b.negative === 0), l(!b.isZero());
      var E = this, k = b.clone();
      E.negative !== 0 ? E = E.umod(b) : E = E.clone();
      for (var O = new p(1), A = new p(0), x = k.clone(); E.cmpn(1) > 0 && k.cmpn(1) > 0; ) {
        for (var Y = 0, B = 1; !(E.words[0] & B) && Y < 26; ++Y, B <<= 1)
          ;
        if (Y > 0)
          for (E.iushrn(Y); Y-- > 0; )
            O.isOdd() && O.iadd(x), O.iushrn(1);
        for (var T = 0, D = 1; !(k.words[0] & D) && T < 26; ++T, D <<= 1)
          ;
        if (T > 0)
          for (k.iushrn(T); T-- > 0; )
            A.isOdd() && A.iadd(x), A.iushrn(1);
        E.cmp(k) >= 0 ? (E.isub(k), O.isub(A)) : (k.isub(E), A.isub(O));
      }
      var te;
      return E.cmpn(1) === 0 ? te = O : te = A, te.cmpn(0) < 0 && te.iadd(b), te;
    }, p.prototype.gcd = function(b) {
      if (this.isZero())
        return b.abs();
      if (b.isZero())
        return this.abs();
      var E = this.clone(), k = b.clone();
      E.negative = 0, k.negative = 0;
      for (var O = 0; E.isEven() && k.isEven(); O++)
        E.iushrn(1), k.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; k.isEven(); )
          k.iushrn(1);
        var A = E.cmp(k);
        if (A < 0) {
          var x = E;
          E = k, k = x;
        } else if (A === 0 || k.cmpn(1) === 0)
          break;
        E.isub(k);
      } while (!0);
      return k.iushln(O);
    }, p.prototype.invm = function(b) {
      return this.egcd(b).a.umod(b);
    }, p.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, p.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, p.prototype.andln = function(b) {
      return this.words[0] & b;
    }, p.prototype.bincn = function(b) {
      l(typeof b == "number");
      var E = b % 26, k = (b - E) / 26, O = 1 << E;
      if (this.length <= k)
        return this._expand(k + 1), this.words[k] |= O, this;
      for (var A = O, x = k; A !== 0 && x < this.length; x++) {
        var Y = this.words[x] | 0;
        Y += A, A = Y >>> 26, Y &= 67108863, this.words[x] = Y;
      }
      return A !== 0 && (this.words[x] = A, this.length++), this;
    }, p.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, p.prototype.cmpn = function(b) {
      var E = b < 0;
      if (this.negative !== 0 && !E)
        return -1;
      if (this.negative === 0 && E)
        return 1;
      this.strip();
      var k;
      if (this.length > 1)
        k = 1;
      else {
        E && (b = -b), l(b <= 67108863, "Number is too big");
        var O = this.words[0] | 0;
        k = O === b ? 0 : O < b ? -1 : 1;
      }
      return this.negative !== 0 ? -k | 0 : k;
    }, p.prototype.cmp = function(b) {
      if (this.negative !== 0 && b.negative === 0)
        return -1;
      if (this.negative === 0 && b.negative !== 0)
        return 1;
      var E = this.ucmp(b);
      return this.negative !== 0 ? -E | 0 : E;
    }, p.prototype.ucmp = function(b) {
      if (this.length > b.length)
        return 1;
      if (this.length < b.length)
        return -1;
      for (var E = 0, k = this.length - 1; k >= 0; k--) {
        var O = this.words[k] | 0, A = b.words[k] | 0;
        if (O !== A) {
          O < A ? E = -1 : O > A && (E = 1);
          break;
        }
      }
      return E;
    }, p.prototype.gtn = function(b) {
      return this.cmpn(b) === 1;
    }, p.prototype.gt = function(b) {
      return this.cmp(b) === 1;
    }, p.prototype.gten = function(b) {
      return this.cmpn(b) >= 0;
    }, p.prototype.gte = function(b) {
      return this.cmp(b) >= 0;
    }, p.prototype.ltn = function(b) {
      return this.cmpn(b) === -1;
    }, p.prototype.lt = function(b) {
      return this.cmp(b) === -1;
    }, p.prototype.lten = function(b) {
      return this.cmpn(b) <= 0;
    }, p.prototype.lte = function(b) {
      return this.cmp(b) <= 0;
    }, p.prototype.eqn = function(b) {
      return this.cmpn(b) === 0;
    }, p.prototype.eq = function(b) {
      return this.cmp(b) === 0;
    }, p.red = function(b) {
      return new q(b);
    }, p.prototype.toRed = function(b) {
      return l(!this.red, "Already a number in reduction context"), l(this.negative === 0, "red works only with positives"), b.convertTo(this)._forceRed(b);
    }, p.prototype.fromRed = function() {
      return l(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, p.prototype._forceRed = function(b) {
      return this.red = b, this;
    }, p.prototype.forceRed = function(b) {
      return l(!this.red, "Already a number in reduction context"), this._forceRed(b);
    }, p.prototype.redAdd = function(b) {
      return l(this.red, "redAdd works only with red numbers"), this.red.add(this, b);
    }, p.prototype.redIAdd = function(b) {
      return l(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, b);
    }, p.prototype.redSub = function(b) {
      return l(this.red, "redSub works only with red numbers"), this.red.sub(this, b);
    }, p.prototype.redISub = function(b) {
      return l(this.red, "redISub works only with red numbers"), this.red.isub(this, b);
    }, p.prototype.redShl = function(b) {
      return l(this.red, "redShl works only with red numbers"), this.red.shl(this, b);
    }, p.prototype.redMul = function(b) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.mul(this, b);
    }, p.prototype.redIMul = function(b) {
      return l(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.imul(this, b);
    }, p.prototype.redSqr = function() {
      return l(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, p.prototype.redISqr = function() {
      return l(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, p.prototype.redSqrt = function() {
      return l(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, p.prototype.redInvm = function() {
      return l(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, p.prototype.redNeg = function() {
      return l(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, p.prototype.redPow = function(b) {
      return l(this.red && !b.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, b);
    };
    var de = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function he(C, b) {
      this.name = C, this.p = new p(b, 16), this.n = this.p.bitLength(), this.k = new p(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    he.prototype._tmp = function() {
      var b = new p(null);
      return b.words = new Array(Math.ceil(this.n / 13)), b;
    }, he.prototype.ireduce = function(b) {
      var E = b, k;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), k = E.bitLength();
      while (k > this.n);
      var O = k < this.n ? -1 : E.ucmp(this.p);
      return O === 0 ? (E.words[0] = 0, E.length = 1) : O > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, he.prototype.split = function(b, E) {
      b.iushrn(this.n, 0, E);
    }, he.prototype.imulK = function(b) {
      return b.imul(this.k);
    };
    function pe() {
      he.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    v(pe, he), pe.prototype.split = function(b, E) {
      for (var k = 4194303, O = Math.min(b.length, 9), A = 0; A < O; A++)
        E.words[A] = b.words[A];
      if (E.length = O, b.length <= 9) {
        b.words[0] = 0, b.length = 1;
        return;
      }
      var x = b.words[9];
      for (E.words[E.length++] = x & k, A = 10; A < b.length; A++) {
        var Y = b.words[A] | 0;
        b.words[A - 10] = (Y & k) << 4 | x >>> 22, x = Y;
      }
      x >>>= 22, b.words[A - 10] = x, x === 0 && b.length > 10 ? b.length -= 10 : b.length -= 9;
    }, pe.prototype.imulK = function(b) {
      b.words[b.length] = 0, b.words[b.length + 1] = 0, b.length += 2;
      for (var E = 0, k = 0; k < b.length; k++) {
        var O = b.words[k] | 0;
        E += O * 977, b.words[k] = E & 67108863, E = O * 64 + (E / 67108864 | 0);
      }
      return b.words[b.length - 1] === 0 && (b.length--, b.words[b.length - 1] === 0 && b.length--), b;
    };
    function be() {
      he.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    v(be, he);
    function ke() {
      he.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    v(ke, he);
    function _e() {
      he.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    v(_e, he), _e.prototype.imulK = function(b) {
      for (var E = 0, k = 0; k < b.length; k++) {
        var O = (b.words[k] | 0) * 19 + E, A = O & 67108863;
        O >>>= 26, b.words[k] = A, E = O;
      }
      return E !== 0 && (b.words[b.length++] = E), b;
    }, p._prime = function(b) {
      if (de[b])
        return de[b];
      var E;
      if (b === "k256")
        E = new pe();
      else if (b === "p224")
        E = new be();
      else if (b === "p192")
        E = new ke();
      else if (b === "p25519")
        E = new _e();
      else
        throw new Error("Unknown prime " + b);
      return de[b] = E, E;
    };
    function q(C) {
      if (typeof C == "string") {
        var b = p._prime(C);
        this.m = b.p, this.prime = b;
      } else
        l(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    q.prototype._verify1 = function(b) {
      l(b.negative === 0, "red works only with positives"), l(b.red, "red works only with red numbers");
    }, q.prototype._verify2 = function(b, E) {
      l((b.negative | E.negative) === 0, "red works only with positives"), l(
        b.red && b.red === E.red,
        "red works only with red numbers"
      );
    }, q.prototype.imod = function(b) {
      return this.prime ? this.prime.ireduce(b)._forceRed(this) : b.umod(this.m)._forceRed(this);
    }, q.prototype.neg = function(b) {
      return b.isZero() ? b.clone() : this.m.sub(b)._forceRed(this);
    }, q.prototype.add = function(b, E) {
      this._verify2(b, E);
      var k = b.add(E);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k._forceRed(this);
    }, q.prototype.iadd = function(b, E) {
      this._verify2(b, E);
      var k = b.iadd(E);
      return k.cmp(this.m) >= 0 && k.isub(this.m), k;
    }, q.prototype.sub = function(b, E) {
      this._verify2(b, E);
      var k = b.sub(E);
      return k.cmpn(0) < 0 && k.iadd(this.m), k._forceRed(this);
    }, q.prototype.isub = function(b, E) {
      this._verify2(b, E);
      var k = b.isub(E);
      return k.cmpn(0) < 0 && k.iadd(this.m), k;
    }, q.prototype.shl = function(b, E) {
      return this._verify1(b), this.imod(b.ushln(E));
    }, q.prototype.imul = function(b, E) {
      return this._verify2(b, E), this.imod(b.imul(E));
    }, q.prototype.mul = function(b, E) {
      return this._verify2(b, E), this.imod(b.mul(E));
    }, q.prototype.isqr = function(b) {
      return this.imul(b, b.clone());
    }, q.prototype.sqr = function(b) {
      return this.mul(b, b);
    }, q.prototype.sqrt = function(b) {
      if (b.isZero())
        return b.clone();
      var E = this.m.andln(3);
      if (l(E % 2 === 1), E === 3) {
        var k = this.m.add(new p(1)).iushrn(2);
        return this.pow(b, k);
      }
      for (var O = this.m.subn(1), A = 0; !O.isZero() && O.andln(1) === 0; )
        A++, O.iushrn(1);
      l(!O.isZero());
      var x = new p(1).toRed(this), Y = x.redNeg(), B = this.m.subn(1).iushrn(1), T = this.m.bitLength();
      for (T = new p(2 * T * T).toRed(this); this.pow(T, B).cmp(Y) !== 0; )
        T.redIAdd(Y);
      for (var D = this.pow(T, O), te = this.pow(b, O.addn(1).iushrn(1)), me = this.pow(b, O), Ie = A; me.cmp(x) !== 0; ) {
        for (var $e = me, ye = 0; $e.cmp(x) !== 0; ye++)
          $e = $e.redSqr();
        l(ye < Ie);
        var fe = this.pow(D, new p(1).iushln(Ie - ye - 1));
        te = te.redMul(fe), D = fe.redSqr(), me = me.redMul(D), Ie = ye;
      }
      return te;
    }, q.prototype.invm = function(b) {
      var E = b._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, q.prototype.pow = function(b, E) {
      if (E.isZero())
        return new p(1).toRed(this);
      if (E.cmpn(1) === 0)
        return b.clone();
      var k = 4, O = new Array(1 << k);
      O[0] = new p(1).toRed(this), O[1] = b;
      for (var A = 2; A < O.length; A++)
        O[A] = this.mul(O[A - 1], b);
      var x = O[0], Y = 0, B = 0, T = E.bitLength() % 26;
      for (T === 0 && (T = 26), A = E.length - 1; A >= 0; A--) {
        for (var D = E.words[A], te = T - 1; te >= 0; te--) {
          var me = D >> te & 1;
          if (x !== O[0] && (x = this.sqr(x)), me === 0 && Y === 0) {
            B = 0;
            continue;
          }
          Y <<= 1, Y |= me, B++, !(B !== k && (A !== 0 || te !== 0)) && (x = this.mul(x, O[Y]), B = 0, Y = 0);
        }
        T = 26;
      }
      return x;
    }, q.prototype.convertTo = function(b) {
      var E = b.umod(this.m);
      return E === b ? E.clone() : E;
    }, q.prototype.convertFrom = function(b) {
      var E = b.clone();
      return E.red = null, E;
    }, p.mont = function(b) {
      return new z(b);
    };
    function z(C) {
      q.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new p(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    v(z, q), z.prototype.convertTo = function(b) {
      return this.imod(b.ushln(this.shift));
    }, z.prototype.convertFrom = function(b) {
      var E = this.imod(b.mul(this.rinv));
      return E.red = null, E;
    }, z.prototype.imul = function(b, E) {
      if (b.isZero() || E.isZero())
        return b.words[0] = 0, b.length = 1, b;
      var k = b.imul(E), O = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = k.isub(O).iushrn(this.shift), x = A;
      return A.cmp(this.m) >= 0 ? x = A.isub(this.m) : A.cmpn(0) < 0 && (x = A.iadd(this.m)), x._forceRed(this);
    }, z.prototype.mul = function(b, E) {
      if (b.isZero() || E.isZero())
        return new p(0)._forceRed(this);
      var k = b.mul(E), O = k.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = k.isub(O).iushrn(this.shift), x = A;
      return A.cmp(this.m) >= 0 ? x = A.isub(this.m) : A.cmpn(0) < 0 && (x = A.iadd(this.m)), x._forceRed(this);
    }, z.prototype.invm = function(b) {
      var E = this.imod(b._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(a, commonjsGlobal$1);
})(bn);
var bnExports = bn.exports, BN$2 = bnExports, Buffer$8 = safeBufferExports$3.Buffer;
function withPublic$2(a, u) {
  return Buffer$8.from(a.toRed(BN$2.mont(u.modulus)).redPow(new BN$2(u.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2, parseKeys$1 = parseAsn1, randomBytes = browserExports, createHash$1 = browser$a, mgf$1 = mgf$2, xor$1 = xor$2, BN$1 = bnExports, withPublic$1 = withPublic_1, crt$1 = browserifyRsa, Buffer$7 = safeBufferExports$3.Buffer, publicEncrypt = function a(u, c, l) {
  var v;
  u.padding ? v = u.padding : l ? v = 1 : v = 4;
  var p = parseKeys$1(u), _;
  if (v === 4)
    _ = oaep$1(p, c);
  else if (v === 1)
    _ = pkcs1$1(p, c, l);
  else if (v === 3) {
    if (_ = new BN$1(c), _.cmp(p.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return l ? crt$1(_, p) : withPublic$1(_, p);
};
function oaep$1(a, u) {
  var c = a.modulus.byteLength(), l = u.length, v = createHash$1("sha1").update(Buffer$7.alloc(0)).digest(), p = v.length, _ = 2 * p;
  if (l > c - _ - 2)
    throw new Error("message too long");
  var I = Buffer$7.alloc(c - l - _ - 2), P = c - p - 1, $ = randomBytes(p), F = xor$1(Buffer$7.concat([v, I, Buffer$7.alloc(1, 1), u], P), mgf$1($, P)), H = xor$1($, mgf$1(F, p));
  return new BN$1(Buffer$7.concat([Buffer$7.alloc(1), H, F], c));
}
function pkcs1$1(a, u, c) {
  var l = u.length, v = a.modulus.byteLength();
  if (l > v - 11)
    throw new Error("message too long");
  var p;
  return c ? p = Buffer$7.alloc(v - l - 3, 255) : p = nonZero(v - l - 3), new BN$1(Buffer$7.concat([Buffer$7.from([0, c ? 1 : 2]), p, Buffer$7.alloc(1), u], v));
}
function nonZero(a) {
  for (var u = Buffer$7.allocUnsafe(a), c = 0, l = randomBytes(a * 2), v = 0, p; c < a; )
    v === l.length && (l = randomBytes(a * 2), v = 0), p = l[v++], p && (u[c++] = p);
  return u;
}
var parseKeys = parseAsn1, mgf = mgf$2, xor = xor$2, BN = bnExports, crt = browserifyRsa, createHash = browser$a, withPublic = withPublic_1, Buffer$6 = safeBufferExports$3.Buffer, privateDecrypt = function a(u, c, l) {
  var v;
  u.padding ? v = u.padding : l ? v = 1 : v = 4;
  var p = parseKeys(u), _ = p.modulus.byteLength();
  if (c.length > _ || new BN(c).cmp(p.modulus) >= 0)
    throw new Error("decryption error");
  var I;
  l ? I = withPublic(new BN(c), p) : I = crt(c, p);
  var P = Buffer$6.alloc(_ - I.length);
  if (I = Buffer$6.concat([P, I], _), v === 4)
    return oaep(p, I);
  if (v === 1)
    return pkcs1(p, I, l);
  if (v === 3)
    return I;
  throw new Error("unknown padding");
};
function oaep(a, u) {
  var c = a.modulus.byteLength(), l = createHash("sha1").update(Buffer$6.alloc(0)).digest(), v = l.length;
  if (u[0] !== 0)
    throw new Error("decryption error");
  var p = u.slice(1, v + 1), _ = u.slice(v + 1), I = xor(p, mgf(_, v)), P = xor(_, mgf(I, c - v - 1));
  if (compare(l, P.slice(0, v)))
    throw new Error("decryption error");
  for (var $ = v; P[$] === 0; )
    $++;
  if (P[$++] !== 1)
    throw new Error("decryption error");
  return P.slice($);
}
function pkcs1(a, u, c) {
  for (var l = u.slice(0, 2), v = 2, p = 0; u[v++] !== 0; )
    if (v >= u.length) {
      p++;
      break;
    }
  var _ = u.slice(2, v - 1);
  if ((l.toString("hex") !== "0002" && !c || l.toString("hex") !== "0001" && c) && p++, _.length < 8 && p++, p)
    throw new Error("decryption error");
  return u.slice(v);
}
function compare(a, u) {
  a = Buffer$6.from(a), u = Buffer$6.from(u);
  var c = 0, l = a.length;
  a.length !== u.length && (c++, l = Math.min(a.length, u.length));
  for (var v = -1; ++v < l; )
    c += a[v] ^ u[v];
  return c;
}
(function(a) {
  a.publicEncrypt = publicEncrypt, a.privateDecrypt = privateDecrypt, a.privateEncrypt = function(c, l) {
    return a.publicEncrypt(c, l, !0);
  }, a.publicDecrypt = function(c, l) {
    return a.privateDecrypt(c, l, !0);
  };
})(browser$2);
var browser$1 = {};
function oldBrowser() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var safeBuffer = safeBufferExports$3, randombytes = browserExports, Buffer$5 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto$2 = commonjsGlobal$1.crypto || commonjsGlobal$1.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(a, u) {
  if (typeof a != "number" || a !== a)
    throw new TypeError("offset must be a number");
  if (a > kMaxUint32 || a < 0)
    throw new TypeError("offset must be a uint32");
  if (a > kBufferMaxLength || a > u)
    throw new RangeError("offset out of range");
}
function assertSize(a, u, c) {
  if (typeof a != "number" || a !== a)
    throw new TypeError("size must be a number");
  if (a > kMaxUint32 || a < 0)
    throw new TypeError("size must be a uint32");
  if (a + u > c || a > kBufferMaxLength)
    throw new RangeError("buffer too small");
}
crypto$2 && crypto$2.getRandomValues || !process$1.browser ? (browser$1.randomFill = randomFill, browser$1.randomFillSync = randomFillSync) : (browser$1.randomFill = oldBrowser, browser$1.randomFillSync = oldBrowser);
function randomFill(a, u, c, l) {
  if (!Buffer$5.isBuffer(a) && !(a instanceof commonjsGlobal$1.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof u == "function")
    l = u, u = 0, c = a.length;
  else if (typeof c == "function")
    l = c, c = a.length - u;
  else if (typeof l != "function")
    throw new TypeError('"cb" argument must be a function');
  return assertOffset(u, a.length), assertSize(c, u, a.length), actualFill(a, u, c, l);
}
function actualFill(a, u, c, l) {
  if (process$1.browser) {
    var v = a.buffer, p = new Uint8Array(v, u, c);
    if (crypto$2.getRandomValues(p), l) {
      process$1.nextTick(function() {
        l(null, a);
      });
      return;
    }
    return a;
  }
  if (l) {
    randombytes(c, function(I, P) {
      if (I)
        return l(I);
      P.copy(a, u), l(null, a);
    });
    return;
  }
  var _ = randombytes(c);
  return _.copy(a, u), a;
}
function randomFillSync(a, u, c) {
  if (typeof u > "u" && (u = 0), !Buffer$5.isBuffer(a) && !(a instanceof commonjsGlobal$1.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return assertOffset(u, a.length), c === void 0 && (c = a.length - u), assertSize(c, u, a.length), actualFill(a, u, c);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify)
    return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$a, cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$9;
  var a = algos, u = Object.keys(a), c = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(u);
  cryptoBrowserify.getHashes = function() {
    return c;
  };
  var l = browser$8;
  cryptoBrowserify.pbkdf2 = l.pbkdf2, cryptoBrowserify.pbkdf2Sync = l.pbkdf2Sync;
  var v = browser$7;
  cryptoBrowserify.Cipher = v.Cipher, cryptoBrowserify.createCipher = v.createCipher, cryptoBrowserify.Cipheriv = v.Cipheriv, cryptoBrowserify.createCipheriv = v.createCipheriv, cryptoBrowserify.Decipher = v.Decipher, cryptoBrowserify.createDecipher = v.createDecipher, cryptoBrowserify.Decipheriv = v.Decipheriv, cryptoBrowserify.createDecipheriv = v.createDecipheriv, cryptoBrowserify.getCiphers = v.getCiphers, cryptoBrowserify.listCiphers = v.listCiphers;
  var p = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = p.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = p.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = p.getDiffieHellman, cryptoBrowserify.createDiffieHellman = p.createDiffieHellman, cryptoBrowserify.DiffieHellman = p.DiffieHellman;
  var _ = requireBrowser$1();
  cryptoBrowserify.createSign = _.createSign, cryptoBrowserify.Sign = _.Sign, cryptoBrowserify.createVerify = _.createVerify, cryptoBrowserify.Verify = _.Verify, cryptoBrowserify.createECDH = requireBrowser();
  var I = browser$2;
  cryptoBrowserify.publicEncrypt = I.publicEncrypt, cryptoBrowserify.privateEncrypt = I.privateEncrypt, cryptoBrowserify.publicDecrypt = I.publicDecrypt, cryptoBrowserify.privateDecrypt = I.privateDecrypt;
  var P = browser$1;
  return cryptoBrowserify.randomFill = P.randomFill, cryptoBrowserify.randomFillSync = P.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
function getParamSize(a) {
  var u = (a / 8 | 0) + (a % 8 === 0 ? 0 : 1);
  return u;
}
var paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg$1(a) {
  var u = paramBytesForAlg[a];
  if (u)
    return u;
  throw new Error('Unknown algorithm "' + a + '"');
}
var paramBytesForAlg_1 = getParamBytesForAlg$1, Buffer$4 = safeBufferExports$3.Buffer, getParamBytesForAlg = paramBytesForAlg_1, MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function base64Url(a) {
  return a.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function signatureAsBuffer(a) {
  if (Buffer$4.isBuffer(a))
    return a;
  if (typeof a == "string")
    return Buffer$4.from(a, "base64");
  throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
}
function derToJose(a, u) {
  a = signatureAsBuffer(a);
  var c = getParamBytesForAlg(u), l = c + 1, v = a.length, p = 0;
  if (a[p++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  var _ = a[p++];
  if (_ === (MAX_OCTET | 1) && (_ = a[p++]), v - p < _)
    throw new Error('"seq" specified length of "' + _ + '", only "' + (v - p) + '" remaining');
  if (a[p++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  var I = a[p++];
  if (v - p - 2 < I)
    throw new Error('"r" specified length of "' + I + '", only "' + (v - p - 2) + '" available');
  if (l < I)
    throw new Error('"r" specified length of "' + I + '", max of "' + l + '" is acceptable');
  var P = p;
  if (p += I, a[p++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  var $ = a[p++];
  if (v - p !== $)
    throw new Error('"s" specified length of "' + $ + '", expected "' + (v - p) + '"');
  if (l < $)
    throw new Error('"s" specified length of "' + $ + '", max of "' + l + '" is acceptable');
  var F = p;
  if (p += $, p !== v)
    throw new Error('Expected to consume entire buffer, but "' + (v - p) + '" bytes remain');
  var H = c - I, j = c - $, ee = Buffer$4.allocUnsafe(H + I + j + $);
  for (p = 0; p < H; ++p)
    ee[p] = 0;
  a.copy(ee, p, P + Math.max(-H, 0), P + I), p = c;
  for (var X = p; p < X + j; ++p)
    ee[p] = 0;
  return a.copy(ee, p, F + Math.max(-j, 0), F + $), ee = ee.toString("base64"), ee = base64Url(ee), ee;
}
function countPadding(a, u, c) {
  for (var l = 0; u + l < c && a[u + l] === 0; )
    ++l;
  var v = a[u + l] >= MAX_OCTET;
  return v && --l, l;
}
function joseToDer(a, u) {
  a = signatureAsBuffer(a);
  var c = getParamBytesForAlg(u), l = a.length;
  if (l !== c * 2)
    throw new TypeError('"' + u + '" signatures must be "' + c * 2 + '" bytes, saw "' + l + '"');
  var v = countPadding(a, 0, c), p = countPadding(a, c, a.length), _ = c - v, I = c - p, P = 2 + _ + 1 + 1 + I, $ = P < MAX_OCTET, F = Buffer$4.allocUnsafe(($ ? 2 : 3) + P), H = 0;
  return F[H++] = ENCODED_TAG_SEQ, $ ? F[H++] = P : (F[H++] = MAX_OCTET | 1, F[H++] = P & 255), F[H++] = ENCODED_TAG_INT, F[H++] = _, v < 0 ? (F[H++] = 0, H += a.copy(F, H, 0, c)) : H += a.copy(F, H, v, c), F[H++] = ENCODED_TAG_INT, F[H++] = I, p < 0 ? (F[H++] = 0, a.copy(F, H, c)) : a.copy(F, H, c + p), F;
}
var ecdsaSigFormatter = {
  derToJose,
  joseToDer
}, bufferEqual = bufferEqualConstantTime, Buffer$3 = safeBufferExports$3.Buffer, crypto$1 = requireCryptoBrowserify(), formatEcdsa = ecdsaSigFormatter, util$2 = util$4, MSG_INVALID_ALGORITHM = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`, MSG_INVALID_SECRET = "secret must be a string or buffer", MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer", MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object", supportsKeyObjects = typeof crypto$1.createPublicKey == "function";
supportsKeyObjects && (MSG_INVALID_VERIFIER_KEY += " or a KeyObject", MSG_INVALID_SECRET += "or a KeyObject");
function checkIsPublicKey(a) {
  if (!Buffer$3.isBuffer(a) && typeof a != "string" && (!supportsKeyObjects || typeof a != "object" || typeof a.type != "string" || typeof a.asymmetricKeyType != "string" || typeof a.export != "function"))
    throw typeError(MSG_INVALID_VERIFIER_KEY);
}
function checkIsPrivateKey(a) {
  if (!Buffer$3.isBuffer(a) && typeof a != "string" && typeof a != "object")
    throw typeError(MSG_INVALID_SIGNER_KEY);
}
function checkIsSecretKey(a) {
  if (!Buffer$3.isBuffer(a)) {
    if (typeof a == "string")
      return a;
    if (!supportsKeyObjects || typeof a != "object" || a.type !== "secret" || typeof a.export != "function")
      throw typeError(MSG_INVALID_SECRET);
  }
}
function fromBase64(a) {
  return a.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBase64(a) {
  a = a.toString();
  var u = 4 - a.length % 4;
  if (u !== 4)
    for (var c = 0; c < u; ++c)
      a += "=";
  return a.replace(/\-/g, "+").replace(/_/g, "/");
}
function typeError(a) {
  var u = [].slice.call(arguments, 1), c = util$2.format.bind(util$2, a).apply(null, u);
  return new TypeError(c);
}
function bufferOrString(a) {
  return Buffer$3.isBuffer(a) || typeof a == "string";
}
function normalizeInput(a) {
  return bufferOrString(a) || (a = JSON.stringify(a)), a;
}
function createHmacSigner(a) {
  return function(c, l) {
    checkIsSecretKey(l), c = normalizeInput(c);
    var v = crypto$1.createHmac("sha" + a, l), p = (v.update(c), v.digest("base64"));
    return fromBase64(p);
  };
}
function createHmacVerifier(a) {
  return function(c, l, v) {
    var p = createHmacSigner(a)(c, v);
    return bufferEqual(Buffer$3.from(l), Buffer$3.from(p));
  };
}
function createKeySigner(a) {
  return function(c, l) {
    checkIsPrivateKey(l), c = normalizeInput(c);
    var v = crypto$1.createSign("RSA-SHA" + a), p = (v.update(c), v.sign(l, "base64"));
    return fromBase64(p);
  };
}
function createKeyVerifier(a) {
  return function(c, l, v) {
    checkIsPublicKey(v), c = normalizeInput(c), l = toBase64(l);
    var p = crypto$1.createVerify("RSA-SHA" + a);
    return p.update(c), p.verify(v, l, "base64");
  };
}
function createPSSKeySigner(a) {
  return function(c, l) {
    checkIsPrivateKey(l), c = normalizeInput(c);
    var v = crypto$1.createSign("RSA-SHA" + a), p = (v.update(c), v.sign({
      key: l,
      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
    }, "base64"));
    return fromBase64(p);
  };
}
function createPSSKeyVerifier(a) {
  return function(c, l, v) {
    checkIsPublicKey(v), c = normalizeInput(c), l = toBase64(l);
    var p = crypto$1.createVerify("RSA-SHA" + a);
    return p.update(c), p.verify({
      key: v,
      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
    }, l, "base64");
  };
}
function createECDSASigner(a) {
  var u = createKeySigner(a);
  return function() {
    var l = u.apply(null, arguments);
    return l = formatEcdsa.derToJose(l, "ES" + a), l;
  };
}
function createECDSAVerifer(a) {
  var u = createKeyVerifier(a);
  return function(l, v, p) {
    v = formatEcdsa.joseToDer(v, "ES" + a).toString("base64");
    var _ = u(l, v, p);
    return _;
  };
}
function createNoneSigner() {
  return function() {
    return "";
  };
}
function createNoneVerifier() {
  return function(u, c) {
    return c === "";
  };
}
var jwa$2 = function a(u) {
  var c = {
    hs: createHmacSigner,
    rs: createKeySigner,
    ps: createPSSKeySigner,
    es: createECDSASigner,
    none: createNoneSigner
  }, l = {
    hs: createHmacVerifier,
    rs: createKeyVerifier,
    ps: createPSSKeyVerifier,
    es: createECDSAVerifer,
    none: createNoneVerifier
  }, v = u.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
  if (!v)
    throw typeError(MSG_INVALID_ALGORITHM, u);
  var p = (v[1] || v[3]).toLowerCase(), _ = v[2];
  return {
    sign: c[p](_),
    verify: l[p](_)
  };
}, Buffer$2 = require$$0$2.Buffer, tostring = function a(u) {
  return typeof u == "string" ? u : typeof u == "number" || Buffer$2.isBuffer(u) ? u.toString() : JSON.stringify(u);
}, Buffer$1 = safeBufferExports$3.Buffer, DataStream$1 = dataStream, jwa$1 = jwa$2, Stream$1 = streamBrowserify, toString$2 = tostring, util$1 = util$4;
function base64url(a, u) {
  return Buffer$1.from(a, u).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function jwsSecuredInput(a, u, c) {
  c = c || "utf8";
  var l = base64url(toString$2(a), "binary"), v = base64url(toString$2(u), c);
  return util$1.format("%s.%s", l, v);
}
function jwsSign(a) {
  var u = a.header, c = a.payload, l = a.secret || a.privateKey, v = a.encoding, p = jwa$1(u.alg), _ = jwsSecuredInput(u, c, v), I = p.sign(_, l);
  return util$1.format("%s.%s", _, I);
}
function SignStream$1(a) {
  var u = a.secret || a.privateKey || a.key, c = new DataStream$1(u);
  this.readable = !0, this.header = a.header, this.encoding = a.encoding, this.secret = this.privateKey = this.key = c, this.payload = new DataStream$1(a.payload), this.secret.once("close", (function() {
    !this.payload.writable && this.readable && this.sign();
  }).bind(this)), this.payload.once("close", (function() {
    !this.secret.writable && this.readable && this.sign();
  }).bind(this));
}
util$1.inherits(SignStream$1, Stream$1);
SignStream$1.prototype.sign = function a() {
  try {
    var u = jwsSign({
      header: this.header,
      payload: this.payload.buffer,
      secret: this.secret.buffer,
      encoding: this.encoding
    });
    return this.emit("done", u), this.emit("data", u), this.emit("end"), this.readable = !1, u;
  } catch (c) {
    this.readable = !1, this.emit("error", c), this.emit("close");
  }
};
SignStream$1.sign = jwsSign;
var signStream = SignStream$1, Buffer = safeBufferExports$3.Buffer, DataStream = dataStream, jwa = jwa$2, Stream = streamBrowserify, toString$1 = tostring, util = util$4, JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
function isObject$6(a) {
  return Object.prototype.toString.call(a) === "[object Object]";
}
function safeJsonParse(a) {
  if (isObject$6(a))
    return a;
  try {
    return JSON.parse(a);
  } catch {
    return;
  }
}
function headerFromJWS(a) {
  var u = a.split(".", 1)[0];
  return safeJsonParse(Buffer.from(u, "base64").toString("binary"));
}
function securedInputFromJWS(a) {
  return a.split(".", 2).join(".");
}
function signatureFromJWS(a) {
  return a.split(".")[2];
}
function payloadFromJWS(a, u) {
  u = u || "utf8";
  var c = a.split(".")[1];
  return Buffer.from(c, "base64").toString(u);
}
function isValidJws(a) {
  return JWS_REGEX.test(a) && !!headerFromJWS(a);
}
function jwsVerify(a, u, c) {
  if (!u) {
    var l = new Error("Missing algorithm parameter for jws.verify");
    throw l.code = "MISSING_ALGORITHM", l;
  }
  a = toString$1(a);
  var v = signatureFromJWS(a), p = securedInputFromJWS(a), _ = jwa(u);
  return _.verify(p, v, c);
}
function jwsDecode(a, u) {
  if (u = u || {}, a = toString$1(a), !isValidJws(a))
    return null;
  var c = headerFromJWS(a);
  if (!c)
    return null;
  var l = payloadFromJWS(a);
  return (c.typ === "JWT" || u.json) && (l = JSON.parse(l, u.encoding)), {
    header: c,
    payload: l,
    signature: signatureFromJWS(a)
  };
}
function VerifyStream$1(a) {
  a = a || {};
  var u = a.secret || a.publicKey || a.key, c = new DataStream(u);
  this.readable = !0, this.algorithm = a.algorithm, this.encoding = a.encoding, this.secret = this.publicKey = this.key = c, this.signature = new DataStream(a.signature), this.secret.once("close", (function() {
    !this.signature.writable && this.readable && this.verify();
  }).bind(this)), this.signature.once("close", (function() {
    !this.secret.writable && this.readable && this.verify();
  }).bind(this));
}
util.inherits(VerifyStream$1, Stream);
VerifyStream$1.prototype.verify = function a() {
  try {
    var u = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer), c = jwsDecode(this.signature.buffer, this.encoding);
    return this.emit("done", u, c), this.emit("data", u), this.emit("end"), this.readable = !1, u;
  } catch (l) {
    this.readable = !1, this.emit("error", l), this.emit("close");
  }
};
VerifyStream$1.decode = jwsDecode;
VerifyStream$1.isValid = isValidJws;
VerifyStream$1.verify = jwsVerify;
var verifyStream = VerifyStream$1, SignStream = signStream, VerifyStream = verifyStream, ALGORITHMS = [
  "HS256",
  "HS384",
  "HS512",
  "RS256",
  "RS384",
  "RS512",
  "PS256",
  "PS384",
  "PS512",
  "ES256",
  "ES384",
  "ES512"
];
jws$3.ALGORITHMS = ALGORITHMS;
jws$3.sign = SignStream.sign;
jws$3.verify = VerifyStream.verify;
jws$3.decode = VerifyStream.decode;
jws$3.isValid = VerifyStream.isValid;
jws$3.createSign = function a(u) {
  return new SignStream(u);
};
jws$3.createVerify = function a(u) {
  return new VerifyStream(u);
};
var jws$2 = jws$3, decode$1 = function(a, u) {
  u = u || {};
  var c = jws$2.decode(a, u);
  if (!c)
    return null;
  var l = c.payload;
  if (typeof l == "string")
    try {
      var v = JSON.parse(l);
      v !== null && typeof v == "object" && (l = v);
    } catch {
    }
  return u.complete === !0 ? {
    header: c.header,
    payload: l,
    signature: c.signature
  } : l;
}, JsonWebTokenError$3 = function(a, u) {
  Error.call(this, a), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.name = "JsonWebTokenError", this.message = a, u && (this.inner = u);
};
JsonWebTokenError$3.prototype = Object.create(Error.prototype);
JsonWebTokenError$3.prototype.constructor = JsonWebTokenError$3;
var JsonWebTokenError_1 = JsonWebTokenError$3, JsonWebTokenError$2 = JsonWebTokenError_1, NotBeforeError$1 = function(a, u) {
  JsonWebTokenError$2.call(this, a), this.name = "NotBeforeError", this.date = u;
};
NotBeforeError$1.prototype = Object.create(JsonWebTokenError$2.prototype);
NotBeforeError$1.prototype.constructor = NotBeforeError$1;
var NotBeforeError_1 = NotBeforeError$1, JsonWebTokenError$1 = JsonWebTokenError_1, TokenExpiredError$1 = function(a, u) {
  JsonWebTokenError$1.call(this, a), this.name = "TokenExpiredError", this.expiredAt = u;
};
TokenExpiredError$1.prototype = Object.create(JsonWebTokenError$1.prototype);
TokenExpiredError$1.prototype.constructor = TokenExpiredError$1;
var TokenExpiredError_1 = TokenExpiredError$1, s = 1e3, m$1 = s * 60, h = m$1 * 60, d = h * 24, w = d * 7, y = d * 365.25, ms$1 = function(a, u) {
  u = u || {};
  var c = typeof a;
  if (c === "string" && a.length > 0)
    return parse$1(a);
  if (c === "number" && isFinite(a))
    return u.long ? fmtLong(a) : fmtShort(a);
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(a)
  );
};
function parse$1(a) {
  if (a = String(a), !(a.length > 100)) {
    var u = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      a
    );
    if (u) {
      var c = parseFloat(u[1]), l = (u[2] || "ms").toLowerCase();
      switch (l) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return c * y;
        case "weeks":
        case "week":
        case "w":
          return c * w;
        case "days":
        case "day":
        case "d":
          return c * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return c * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return c * m$1;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return c * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return c;
        default:
          return;
      }
    }
  }
}
function fmtShort(a) {
  var u = Math.abs(a);
  return u >= d ? Math.round(a / d) + "d" : u >= h ? Math.round(a / h) + "h" : u >= m$1 ? Math.round(a / m$1) + "m" : u >= s ? Math.round(a / s) + "s" : a + "ms";
}
function fmtLong(a) {
  var u = Math.abs(a);
  return u >= d ? plural(a, u, d, "day") : u >= h ? plural(a, u, h, "hour") : u >= m$1 ? plural(a, u, m$1, "minute") : u >= s ? plural(a, u, s, "second") : a + " ms";
}
function plural(a, u, c, l) {
  var v = u >= c * 1.5;
  return Math.round(a / c) + " " + l + (v ? "s" : "");
}
var ms = ms$1, timespan$2 = function(a, u) {
  var c = u || Math.floor(Date.now() / 1e3);
  if (typeof a == "string") {
    var l = ms(a);
    return typeof l > "u" ? void 0 : Math.floor(c + l / 1e3);
  } else
    return typeof a == "number" ? c + a : void 0;
}, semver$1 = { exports: {} };
(function(a, u) {
  u = a.exports = qe;
  var c;
  typeof process$1 == "object" && process$1.env && process$1.env.NODE_DEBUG && /\bsemver\b/i.test(process$1.env.NODE_DEBUG) ? c = function() {
    var Je = Array.prototype.slice.call(arguments, 0);
    Je.unshift("SEMVER"), console.log.apply(console, Je);
  } : c = function() {
  }, u.SEMVER_SPEC_VERSION = "2.0.0";
  var l = 256, v = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, p = 16, _ = u.re = [], I = u.src = [], P = 0, $ = P++;
  I[$] = "0|[1-9]\\d*";
  var F = P++;
  I[F] = "[0-9]+";
  var H = P++;
  I[H] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var j = P++;
  I[j] = "(" + I[$] + ")\\.(" + I[$] + ")\\.(" + I[$] + ")";
  var ee = P++;
  I[ee] = "(" + I[F] + ")\\.(" + I[F] + ")\\.(" + I[F] + ")";
  var X = P++;
  I[X] = "(?:" + I[$] + "|" + I[H] + ")";
  var ie = P++;
  I[ie] = "(?:" + I[F] + "|" + I[H] + ")";
  var Q = P++;
  I[Q] = "(?:-(" + I[X] + "(?:\\." + I[X] + ")*))";
  var ne = P++;
  I[ne] = "(?:-?(" + I[ie] + "(?:\\." + I[ie] + ")*))";
  var Z = P++;
  I[Z] = "[0-9A-Za-z-]+";
  var de = P++;
  I[de] = "(?:\\+(" + I[Z] + "(?:\\." + I[Z] + ")*))";
  var he = P++, pe = "v?" + I[j] + I[Q] + "?" + I[de] + "?";
  I[he] = "^" + pe + "$";
  var be = "[v=\\s]*" + I[ee] + I[ne] + "?" + I[de] + "?", ke = P++;
  I[ke] = "^" + be + "$";
  var _e = P++;
  I[_e] = "((?:<|>)?=?)";
  var q = P++;
  I[q] = I[F] + "|x|X|\\*";
  var z = P++;
  I[z] = I[$] + "|x|X|\\*";
  var C = P++;
  I[C] = "[v=\\s]*(" + I[z] + ")(?:\\.(" + I[z] + ")(?:\\.(" + I[z] + ")(?:" + I[Q] + ")?" + I[de] + "?)?)?";
  var b = P++;
  I[b] = "[v=\\s]*(" + I[q] + ")(?:\\.(" + I[q] + ")(?:\\.(" + I[q] + ")(?:" + I[ne] + ")?" + I[de] + "?)?)?";
  var E = P++;
  I[E] = "^" + I[_e] + "\\s*" + I[C] + "$";
  var k = P++;
  I[k] = "^" + I[_e] + "\\s*" + I[b] + "$";
  var O = P++;
  I[O] = "(?:^|[^\\d])(\\d{1," + p + "})(?:\\.(\\d{1," + p + "}))?(?:\\.(\\d{1," + p + "}))?(?:$|[^\\d])";
  var A = P++;
  I[A] = "(?:~>?)";
  var x = P++;
  I[x] = "(\\s*)" + I[A] + "\\s+", _[x] = new RegExp(I[x], "g");
  var Y = "$1~", B = P++;
  I[B] = "^" + I[A] + I[C] + "$";
  var T = P++;
  I[T] = "^" + I[A] + I[b] + "$";
  var D = P++;
  I[D] = "(?:\\^)";
  var te = P++;
  I[te] = "(\\s*)" + I[D] + "\\s+", _[te] = new RegExp(I[te], "g");
  var me = "$1^", Ie = P++;
  I[Ie] = "^" + I[D] + I[C] + "$";
  var $e = P++;
  I[$e] = "^" + I[D] + I[b] + "$";
  var ye = P++;
  I[ye] = "^" + I[_e] + "\\s*(" + be + ")$|^$";
  var fe = P++;
  I[fe] = "^" + I[_e] + "\\s*(" + pe + ")$|^$";
  var Me = P++;
  I[Me] = "(\\s*)" + I[_e] + "\\s*(" + be + "|" + I[C] + ")", _[Me] = new RegExp(I[Me], "g");
  var Ae = "$1$2$3", xe = P++;
  I[xe] = "^\\s*(" + I[C] + ")\\s+-\\s+(" + I[C] + ")\\s*$";
  var ae = P++;
  I[ae] = "^\\s*(" + I[b] + ")\\s+-\\s+(" + I[b] + ")\\s*$";
  var N = P++;
  I[N] = "(<|>)?=?\\s*\\*";
  for (var re = 0; re < P; re++)
    c(re, I[re]), _[re] || (_[re] = new RegExp(I[re]));
  u.parse = le;
  function le(Je, ze) {
    if ((!ze || typeof ze != "object") && (ze = {
      loose: !!ze,
      includePrerelease: !1
    }), Je instanceof qe)
      return Je;
    if (typeof Je != "string" || Je.length > l)
      return null;
    var et = ze.loose ? _[ke] : _[he];
    if (!et.test(Je))
      return null;
    try {
      return new qe(Je, ze);
    } catch {
      return null;
    }
  }
  u.valid = Ne;
  function Ne(Je, ze) {
    var et = le(Je, ze);
    return et ? et.version : null;
  }
  u.clean = Oe;
  function Oe(Je, ze) {
    var et = le(Je.trim().replace(/^[=v]+/, ""), ze);
    return et ? et.version : null;
  }
  u.SemVer = qe;
  function qe(Je, ze) {
    if ((!ze || typeof ze != "object") && (ze = {
      loose: !!ze,
      includePrerelease: !1
    }), Je instanceof qe) {
      if (Je.loose === ze.loose)
        return Je;
      Je = Je.version;
    } else if (typeof Je != "string")
      throw new TypeError("Invalid Version: " + Je);
    if (Je.length > l)
      throw new TypeError("version is longer than " + l + " characters");
    if (!(this instanceof qe))
      return new qe(Je, ze);
    c("SemVer", Je, ze), this.options = ze, this.loose = !!ze.loose;
    var et = Je.trim().match(ze.loose ? _[ke] : _[he]);
    if (!et)
      throw new TypeError("Invalid Version: " + Je);
    if (this.raw = Je, this.major = +et[1], this.minor = +et[2], this.patch = +et[3], this.major > v || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > v || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > v || this.patch < 0)
      throw new TypeError("Invalid patch version");
    et[4] ? this.prerelease = et[4].split(".").map(function(pt) {
      if (/^[0-9]+$/.test(pt)) {
        var mt = +pt;
        if (mt >= 0 && mt < v)
          return mt;
      }
      return pt;
    }) : this.prerelease = [], this.build = et[5] ? et[5].split(".") : [], this.format();
  }
  qe.prototype.format = function() {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
  }, qe.prototype.toString = function() {
    return this.version;
  }, qe.prototype.compare = function(Je) {
    return c("SemVer.compare", this.version, this.options, Je), Je instanceof qe || (Je = new qe(Je, this.options)), this.compareMain(Je) || this.comparePre(Je);
  }, qe.prototype.compareMain = function(Je) {
    return Je instanceof qe || (Je = new qe(Je, this.options)), Xe(this.major, Je.major) || Xe(this.minor, Je.minor) || Xe(this.patch, Je.patch);
  }, qe.prototype.comparePre = function(Je) {
    if (Je instanceof qe || (Je = new qe(Je, this.options)), this.prerelease.length && !Je.prerelease.length)
      return -1;
    if (!this.prerelease.length && Je.prerelease.length)
      return 1;
    if (!this.prerelease.length && !Je.prerelease.length)
      return 0;
    var ze = 0;
    do {
      var et = this.prerelease[ze], pt = Je.prerelease[ze];
      if (c("prerelease compare", ze, et, pt), et === void 0 && pt === void 0)
        return 0;
      if (pt === void 0)
        return 1;
      if (et === void 0)
        return -1;
      if (et === pt)
        continue;
      return Xe(et, pt);
    } while (++ze);
  }, qe.prototype.inc = function(Je, ze) {
    switch (Je) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", ze);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", ze);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", ze), this.inc("pre", ze);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", ze), this.inc("pre", ze);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          for (var et = this.prerelease.length; --et >= 0; )
            typeof this.prerelease[et] == "number" && (this.prerelease[et]++, et = -2);
          et === -1 && this.prerelease.push(0);
        }
        ze && (this.prerelease[0] === ze ? isNaN(this.prerelease[1]) && (this.prerelease = [ze, 0]) : this.prerelease = [ze, 0]);
        break;
      default:
        throw new Error("invalid increment argument: " + Je);
    }
    return this.format(), this.raw = this.version, this;
  }, u.inc = je;
  function je(Je, ze, et, pt) {
    typeof et == "string" && (pt = et, et = void 0);
    try {
      return new qe(Je, et).inc(ze, pt).version;
    } catch {
      return null;
    }
  }
  u.diff = Fe;
  function Fe(Je, ze) {
    if (Ce(Je, ze))
      return null;
    var et = le(Je), pt = le(ze), mt = "";
    if (et.prerelease.length || pt.prerelease.length) {
      mt = "pre";
      var vt = "prerelease";
    }
    for (var ht in et)
      if ((ht === "major" || ht === "minor" || ht === "patch") && et[ht] !== pt[ht])
        return mt + ht;
    return vt;
  }
  u.compareIdentifiers = Xe;
  var yt = /^[0-9]+$/;
  function Xe(Je, ze) {
    var et = yt.test(Je), pt = yt.test(ze);
    return et && pt && (Je = +Je, ze = +ze), Je === ze ? 0 : et && !pt ? -1 : pt && !et ? 1 : Je < ze ? -1 : 1;
  }
  u.rcompareIdentifiers = Ge;
  function Ge(Je, ze) {
    return Xe(ze, Je);
  }
  u.major = V;
  function V(Je, ze) {
    return new qe(Je, ze).major;
  }
  u.minor = ge;
  function ge(Je, ze) {
    return new qe(Je, ze).minor;
  }
  u.patch = Te;
  function Te(Je, ze) {
    return new qe(Je, ze).patch;
  }
  u.compare = We;
  function We(Je, ze, et) {
    return new qe(Je, et).compare(new qe(ze, et));
  }
  u.compareLoose = Re;
  function Re(Je, ze) {
    return We(Je, ze, !0);
  }
  u.rcompare = J;
  function J(Je, ze, et) {
    return We(ze, Je, et);
  }
  u.sort = Ee;
  function Ee(Je, ze) {
    return Je.sort(function(et, pt) {
      return u.compare(et, pt, ze);
    });
  }
  u.rsort = ue;
  function ue(Je, ze) {
    return Je.sort(function(et, pt) {
      return u.rcompare(et, pt, ze);
    });
  }
  u.gt = ce;
  function ce(Je, ze, et) {
    return We(Je, ze, et) > 0;
  }
  u.lt = ve;
  function ve(Je, ze, et) {
    return We(Je, ze, et) < 0;
  }
  u.eq = Ce;
  function Ce(Je, ze, et) {
    return We(Je, ze, et) === 0;
  }
  u.neq = Be;
  function Be(Je, ze, et) {
    return We(Je, ze, et) !== 0;
  }
  u.gte = He;
  function He(Je, ze, et) {
    return We(Je, ze, et) >= 0;
  }
  u.lte = Ve;
  function Ve(Je, ze, et) {
    return We(Je, ze, et) <= 0;
  }
  u.cmp = Ze;
  function Ze(Je, ze, et, pt) {
    switch (ze) {
      case "===":
        return typeof Je == "object" && (Je = Je.version), typeof et == "object" && (et = et.version), Je === et;
      case "!==":
        return typeof Je == "object" && (Je = Je.version), typeof et == "object" && (et = et.version), Je !== et;
      case "":
      case "=":
      case "==":
        return Ce(Je, et, pt);
      case "!=":
        return Be(Je, et, pt);
      case ">":
        return ce(Je, et, pt);
      case ">=":
        return He(Je, et, pt);
      case "<":
        return ve(Je, et, pt);
      case "<=":
        return Ve(Je, et, pt);
      default:
        throw new TypeError("Invalid operator: " + ze);
    }
  }
  u.Comparator = Ke;
  function Ke(Je, ze) {
    if ((!ze || typeof ze != "object") && (ze = {
      loose: !!ze,
      includePrerelease: !1
    }), Je instanceof Ke) {
      if (Je.loose === !!ze.loose)
        return Je;
      Je = Je.value;
    }
    if (!(this instanceof Ke))
      return new Ke(Je, ze);
    c("comparator", Je, ze), this.options = ze, this.loose = !!ze.loose, this.parse(Je), this.semver === U ? this.value = "" : this.value = this.operator + this.semver.version, c("comp", this);
  }
  var U = {};
  Ke.prototype.parse = function(Je) {
    var ze = this.options.loose ? _[ye] : _[fe], et = Je.match(ze);
    if (!et)
      throw new TypeError("Invalid comparator: " + Je);
    this.operator = et[1], this.operator === "=" && (this.operator = ""), et[2] ? this.semver = new qe(et[2], this.options.loose) : this.semver = U;
  }, Ke.prototype.toString = function() {
    return this.value;
  }, Ke.prototype.test = function(Je) {
    return c("Comparator.test", Je, this.options.loose), this.semver === U ? !0 : (typeof Je == "string" && (Je = new qe(Je, this.options)), Ze(Je, this.operator, this.semver, this.options));
  }, Ke.prototype.intersects = function(Je, ze) {
    if (!(Je instanceof Ke))
      throw new TypeError("a Comparator is required");
    (!ze || typeof ze != "object") && (ze = {
      loose: !!ze,
      includePrerelease: !1
    });
    var et;
    if (this.operator === "")
      return et = new se(Je.value, ze), wt(this.value, et, ze);
    if (Je.operator === "")
      return et = new se(this.value, ze), wt(Je.semver, et, ze);
    var pt = (this.operator === ">=" || this.operator === ">") && (Je.operator === ">=" || Je.operator === ">"), mt = (this.operator === "<=" || this.operator === "<") && (Je.operator === "<=" || Je.operator === "<"), vt = this.semver.version === Je.semver.version, ht = (this.operator === ">=" || this.operator === "<=") && (Je.operator === ">=" || Je.operator === "<="), _t = Ze(this.semver, "<", Je.semver, ze) && (this.operator === ">=" || this.operator === ">") && (Je.operator === "<=" || Je.operator === "<"), Et = Ze(this.semver, ">", Je.semver, ze) && (this.operator === "<=" || this.operator === "<") && (Je.operator === ">=" || Je.operator === ">");
    return pt || mt || vt && ht || _t || Et;
  }, u.Range = se;
  function se(Je, ze) {
    if ((!ze || typeof ze != "object") && (ze = {
      loose: !!ze,
      includePrerelease: !1
    }), Je instanceof se)
      return Je.loose === !!ze.loose && Je.includePrerelease === !!ze.includePrerelease ? Je : new se(Je.raw, ze);
    if (Je instanceof Ke)
      return new se(Je.value, ze);
    if (!(this instanceof se))
      return new se(Je, ze);
    if (this.options = ze, this.loose = !!ze.loose, this.includePrerelease = !!ze.includePrerelease, this.raw = Je, this.set = Je.split(/\s*\|\|\s*/).map(function(et) {
      return this.parseRange(et.trim());
    }, this).filter(function(et) {
      return et.length;
    }), !this.set.length)
      throw new TypeError("Invalid SemVer Range: " + Je);
    this.format();
  }
  se.prototype.format = function() {
    return this.range = this.set.map(function(Je) {
      return Je.join(" ").trim();
    }).join("||").trim(), this.range;
  }, se.prototype.toString = function() {
    return this.range;
  }, se.prototype.parseRange = function(Je) {
    var ze = this.options.loose;
    Je = Je.trim();
    var et = ze ? _[ae] : _[xe];
    Je = Je.replace(et, rt), c("hyphen replace", Je), Je = Je.replace(_[Me], Ae), c("comparator trim", Je, _[Me]), Je = Je.replace(_[x], Y), Je = Je.replace(_[te], me), Je = Je.split(/\s+/).join(" ");
    var pt = ze ? _[ye] : _[fe], mt = Je.split(" ").map(function(vt) {
      return Ue(vt, this.options);
    }, this).join(" ").split(/\s+/);
    return this.options.loose && (mt = mt.filter(function(vt) {
      return !!vt.match(pt);
    })), mt = mt.map(function(vt) {
      return new Ke(vt, this.options);
    }, this), mt;
  }, se.prototype.intersects = function(Je, ze) {
    if (!(Je instanceof se))
      throw new TypeError("a Range is required");
    return this.set.some(function(et) {
      return et.every(function(pt) {
        return Je.set.some(function(mt) {
          return mt.every(function(vt) {
            return pt.intersects(vt, ze);
          });
        });
      });
    });
  }, u.toComparators = Se;
  function Se(Je, ze) {
    return new se(Je, ze).set.map(function(et) {
      return et.map(function(pt) {
        return pt.value;
      }).join(" ").trim().split(" ");
    });
  }
  function Ue(Je, ze) {
    return c("comp", Je, ze), Je = st(Je, ze), c("caret", Je), Je = Ye(Je, ze), c("tildes", Je), Je = tt(Je, ze), c("xrange", Je), Je = Tt(Je, ze), c("stars", Je), Je;
  }
  function De(Je) {
    return !Je || Je.toLowerCase() === "x" || Je === "*";
  }
  function Ye(Je, ze) {
    return Je.trim().split(/\s+/).map(function(et) {
      return Qe(et, ze);
    }).join(" ");
  }
  function Qe(Je, ze) {
    var et = ze.loose ? _[T] : _[B];
    return Je.replace(et, function(pt, mt, vt, ht, _t) {
      c("tilde", Je, pt, mt, vt, ht, _t);
      var Et;
      return De(mt) ? Et = "" : De(vt) ? Et = ">=" + mt + ".0.0 <" + (+mt + 1) + ".0.0" : De(ht) ? Et = ">=" + mt + "." + vt + ".0 <" + mt + "." + (+vt + 1) + ".0" : _t ? (c("replaceTilde pr", _t), Et = ">=" + mt + "." + vt + "." + ht + "-" + _t + " <" + mt + "." + (+vt + 1) + ".0") : Et = ">=" + mt + "." + vt + "." + ht + " <" + mt + "." + (+vt + 1) + ".0", c("tilde return", Et), Et;
    });
  }
  function st(Je, ze) {
    return Je.trim().split(/\s+/).map(function(et) {
      return St(et, ze);
    }).join(" ");
  }
  function St(Je, ze) {
    c("caret", Je, ze);
    var et = ze.loose ? _[$e] : _[Ie];
    return Je.replace(et, function(pt, mt, vt, ht, _t) {
      c("caret", Je, pt, mt, vt, ht, _t);
      var Et;
      return De(mt) ? Et = "" : De(vt) ? Et = ">=" + mt + ".0.0 <" + (+mt + 1) + ".0.0" : De(ht) ? mt === "0" ? Et = ">=" + mt + "." + vt + ".0 <" + mt + "." + (+vt + 1) + ".0" : Et = ">=" + mt + "." + vt + ".0 <" + (+mt + 1) + ".0.0" : _t ? (c("replaceCaret pr", _t), mt === "0" ? vt === "0" ? Et = ">=" + mt + "." + vt + "." + ht + "-" + _t + " <" + mt + "." + vt + "." + (+ht + 1) : Et = ">=" + mt + "." + vt + "." + ht + "-" + _t + " <" + mt + "." + (+vt + 1) + ".0" : Et = ">=" + mt + "." + vt + "." + ht + "-" + _t + " <" + (+mt + 1) + ".0.0") : (c("no pr"), mt === "0" ? vt === "0" ? Et = ">=" + mt + "." + vt + "." + ht + " <" + mt + "." + vt + "." + (+ht + 1) : Et = ">=" + mt + "." + vt + "." + ht + " <" + mt + "." + (+vt + 1) + ".0" : Et = ">=" + mt + "." + vt + "." + ht + " <" + (+mt + 1) + ".0.0"), c("caret return", Et), Et;
    });
  }
  function tt(Je, ze) {
    return c("replaceXRanges", Je, ze), Je.split(/\s+/).map(function(et) {
      return it(et, ze);
    }).join(" ");
  }
  function it(Je, ze) {
    Je = Je.trim();
    var et = ze.loose ? _[k] : _[E];
    return Je.replace(et, function(pt, mt, vt, ht, _t, Et) {
      c("xRange", Je, pt, mt, vt, ht, _t, Et);
      var Pt = De(vt), Nt = Pt || De(ht), Mt = Nt || De(_t), Ot = Mt;
      return mt === "=" && Ot && (mt = ""), Pt ? mt === ">" || mt === "<" ? pt = "<0.0.0" : pt = "*" : mt && Ot ? (Nt && (ht = 0), _t = 0, mt === ">" ? (mt = ">=", Nt ? (vt = +vt + 1, ht = 0, _t = 0) : (ht = +ht + 1, _t = 0)) : mt === "<=" && (mt = "<", Nt ? vt = +vt + 1 : ht = +ht + 1), pt = mt + vt + "." + ht + "." + _t) : Nt ? pt = ">=" + vt + ".0.0 <" + (+vt + 1) + ".0.0" : Mt && (pt = ">=" + vt + "." + ht + ".0 <" + vt + "." + (+ht + 1) + ".0"), c("xRange return", pt), pt;
    });
  }
  function Tt(Je, ze) {
    return c("replaceStars", Je, ze), Je.trim().replace(_[N], "");
  }
  function rt(Je, ze, et, pt, mt, vt, ht, _t, Et, Pt, Nt, Mt, Ot) {
    return De(et) ? ze = "" : De(pt) ? ze = ">=" + et + ".0.0" : De(mt) ? ze = ">=" + et + "." + pt + ".0" : ze = ">=" + ze, De(Et) ? _t = "" : De(Pt) ? _t = "<" + (+Et + 1) + ".0.0" : De(Nt) ? _t = "<" + Et + "." + (+Pt + 1) + ".0" : Mt ? _t = "<=" + Et + "." + Pt + "." + Nt + "-" + Mt : _t = "<=" + _t, (ze + " " + _t).trim();
  }
  se.prototype.test = function(Je) {
    if (!Je)
      return !1;
    typeof Je == "string" && (Je = new qe(Je, this.options));
    for (var ze = 0; ze < this.set.length; ze++)
      if (dt(this.set[ze], Je, this.options))
        return !0;
    return !1;
  };
  function dt(Je, ze, et) {
    for (var pt = 0; pt < Je.length; pt++)
      if (!Je[pt].test(ze))
        return !1;
    if (ze.prerelease.length && !et.includePrerelease) {
      for (pt = 0; pt < Je.length; pt++)
        if (c(Je[pt].semver), Je[pt].semver !== U && Je[pt].semver.prerelease.length > 0) {
          var mt = Je[pt].semver;
          if (mt.major === ze.major && mt.minor === ze.minor && mt.patch === ze.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  }
  u.satisfies = wt;
  function wt(Je, ze, et) {
    try {
      ze = new se(ze, et);
    } catch {
      return !1;
    }
    return ze.test(Je);
  }
  u.maxSatisfying = nt;
  function nt(Je, ze, et) {
    var pt = null, mt = null;
    try {
      var vt = new se(ze, et);
    } catch {
      return null;
    }
    return Je.forEach(function(ht) {
      vt.test(ht) && (!pt || mt.compare(ht) === -1) && (pt = ht, mt = new qe(pt, et));
    }), pt;
  }
  u.minSatisfying = at;
  function at(Je, ze, et) {
    var pt = null, mt = null;
    try {
      var vt = new se(ze, et);
    } catch {
      return null;
    }
    return Je.forEach(function(ht) {
      vt.test(ht) && (!pt || mt.compare(ht) === 1) && (pt = ht, mt = new qe(pt, et));
    }), pt;
  }
  u.minVersion = gt;
  function gt(Je, ze) {
    Je = new se(Je, ze);
    var et = new qe("0.0.0");
    if (Je.test(et) || (et = new qe("0.0.0-0"), Je.test(et)))
      return et;
    et = null;
    for (var pt = 0; pt < Je.set.length; ++pt) {
      var mt = Je.set[pt];
      mt.forEach(function(vt) {
        var ht = new qe(vt.semver.version);
        switch (vt.operator) {
          case ">":
            ht.prerelease.length === 0 ? ht.patch++ : ht.prerelease.push(0), ht.raw = ht.format();
          case "":
          case ">=":
            (!et || ce(et, ht)) && (et = ht);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + vt.operator);
        }
      });
    }
    return et && Je.test(et) ? et : null;
  }
  u.validRange = ot;
  function ot(Je, ze) {
    try {
      return new se(Je, ze).range || "*";
    } catch {
      return null;
    }
  }
  u.ltr = ct;
  function ct(Je, ze, et) {
    return ut(Je, ze, "<", et);
  }
  u.gtr = Ct;
  function Ct(Je, ze, et) {
    return ut(Je, ze, ">", et);
  }
  u.outside = ut;
  function ut(Je, ze, et, pt) {
    Je = new qe(Je, pt), ze = new se(ze, pt);
    var mt, vt, ht, _t, Et;
    switch (et) {
      case ">":
        mt = ce, vt = Ve, ht = ve, _t = ">", Et = ">=";
        break;
      case "<":
        mt = ve, vt = He, ht = ce, _t = "<", Et = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (wt(Je, ze, pt))
      return !1;
    for (var Pt = 0; Pt < ze.set.length; ++Pt) {
      var Nt = ze.set[Pt], Mt = null, Ot = null;
      if (Nt.forEach(function($t) {
        $t.semver === U && ($t = new Ke(">=0.0.0")), Mt = Mt || $t, Ot = Ot || $t, mt($t.semver, Mt.semver, pt) ? Mt = $t : ht($t.semver, Ot.semver, pt) && (Ot = $t);
      }), Mt.operator === _t || Mt.operator === Et || (!Ot.operator || Ot.operator === _t) && vt(Je, Ot.semver))
        return !1;
      if (Ot.operator === Et && ht(Je, Ot.semver))
        return !1;
    }
    return !0;
  }
  u.prerelease = lt;
  function lt(Je, ze) {
    var et = le(Je, ze);
    return et && et.prerelease.length ? et.prerelease : null;
  }
  u.intersects = kt;
  function kt(Je, ze, et) {
    return Je = new se(Je, et), ze = new se(ze, et), Je.intersects(ze);
  }
  u.coerce = Rt;
  function Rt(Je) {
    if (Je instanceof qe)
      return Je;
    if (typeof Je != "string")
      return null;
    var ze = Je.match(_[O]);
    return ze == null ? null : le(ze[1] + "." + (ze[2] || "0") + "." + (ze[3] || "0"));
  }
})(semver$1, semver$1.exports);
var semverExports = semver$1.exports, semver = semverExports, psSupported = semver.satisfies(process$1.version, "^6.12.0 || >=8.0.0"), JsonWebTokenError = JsonWebTokenError_1, NotBeforeError = NotBeforeError_1, TokenExpiredError = TokenExpiredError_1, decode = decode$1, timespan$1 = timespan$2, PS_SUPPORTED$1 = psSupported, jws$1 = jws$3, PUB_KEY_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512"], RSA_KEY_ALGS = ["RS256", "RS384", "RS512"], HS_ALGS = ["HS256", "HS384", "HS512"];
PS_SUPPORTED$1 && (PUB_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512"), RSA_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512"));
var verify = function(a, u, c, l) {
  typeof c == "function" && !l && (l = c, c = {}), c || (c = {}), c = Object.assign({}, c);
  var v;
  if (l ? v = l : v = function(F, H) {
    if (F)
      throw F;
    return H;
  }, c.clockTimestamp && typeof c.clockTimestamp != "number")
    return v(new JsonWebTokenError("clockTimestamp must be a number"));
  if (c.nonce !== void 0 && (typeof c.nonce != "string" || c.nonce.trim() === ""))
    return v(new JsonWebTokenError("nonce must be a non-empty string"));
  var p = c.clockTimestamp || Math.floor(Date.now() / 1e3);
  if (!a)
    return v(new JsonWebTokenError("jwt must be provided"));
  if (typeof a != "string")
    return v(new JsonWebTokenError("jwt must be a string"));
  var _ = a.split(".");
  if (_.length !== 3)
    return v(new JsonWebTokenError("jwt malformed"));
  var I;
  try {
    I = decode(a, { complete: !0 });
  } catch (F) {
    return v(F);
  }
  if (!I)
    return v(new JsonWebTokenError("invalid token"));
  var P = I.header, $;
  if (typeof u == "function") {
    if (!l)
      return v(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
    $ = u;
  } else
    $ = function(F, H) {
      return H(null, u);
    };
  return $(P, function(F, H) {
    if (F)
      return v(new JsonWebTokenError("error in secret or public key callback: " + F.message));
    var j = _[2].trim() !== "";
    if (!j && H)
      return v(new JsonWebTokenError("jwt signature is required"));
    if (j && !H)
      return v(new JsonWebTokenError("secret or public key must be provided"));
    if (!j && !c.algorithms && (c.algorithms = ["none"]), c.algorithms || (c.algorithms = ~H.toString().indexOf("BEGIN CERTIFICATE") || ~H.toString().indexOf("BEGIN PUBLIC KEY") ? PUB_KEY_ALGS : ~H.toString().indexOf("BEGIN RSA PUBLIC KEY") ? RSA_KEY_ALGS : HS_ALGS), !~c.algorithms.indexOf(I.header.alg))
      return v(new JsonWebTokenError("invalid algorithm"));
    var ee;
    try {
      ee = jws$1.verify(a, I.header.alg, H);
    } catch (pe) {
      return v(pe);
    }
    if (!ee)
      return v(new JsonWebTokenError("invalid signature"));
    var X = I.payload;
    if (typeof X.nbf < "u" && !c.ignoreNotBefore) {
      if (typeof X.nbf != "number")
        return v(new JsonWebTokenError("invalid nbf value"));
      if (X.nbf > p + (c.clockTolerance || 0))
        return v(new NotBeforeError("jwt not active", new Date(X.nbf * 1e3)));
    }
    if (typeof X.exp < "u" && !c.ignoreExpiration) {
      if (typeof X.exp != "number")
        return v(new JsonWebTokenError("invalid exp value"));
      if (p >= X.exp + (c.clockTolerance || 0))
        return v(new TokenExpiredError("jwt expired", new Date(X.exp * 1e3)));
    }
    if (c.audience) {
      var ie = Array.isArray(c.audience) ? c.audience : [c.audience], Q = Array.isArray(X.aud) ? X.aud : [X.aud], ne = Q.some(function(pe) {
        return ie.some(function(be) {
          return be instanceof RegExp ? be.test(pe) : be === pe;
        });
      });
      if (!ne)
        return v(new JsonWebTokenError("jwt audience invalid. expected: " + ie.join(" or ")));
    }
    if (c.issuer) {
      var Z = typeof c.issuer == "string" && X.iss !== c.issuer || Array.isArray(c.issuer) && c.issuer.indexOf(X.iss) === -1;
      if (Z)
        return v(new JsonWebTokenError("jwt issuer invalid. expected: " + c.issuer));
    }
    if (c.subject && X.sub !== c.subject)
      return v(new JsonWebTokenError("jwt subject invalid. expected: " + c.subject));
    if (c.jwtid && X.jti !== c.jwtid)
      return v(new JsonWebTokenError("jwt jwtid invalid. expected: " + c.jwtid));
    if (c.nonce && X.nonce !== c.nonce)
      return v(new JsonWebTokenError("jwt nonce invalid. expected: " + c.nonce));
    if (c.maxAge) {
      if (typeof X.iat != "number")
        return v(new JsonWebTokenError("iat required when maxAge is specified"));
      var de = timespan$1(c.maxAge, X.iat);
      if (typeof de > "u")
        return v(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      if (p >= de + (c.clockTolerance || 0))
        return v(new TokenExpiredError("maxAge exceeded", new Date(de * 1e3)));
    }
    if (c.complete === !0) {
      var he = I.signature;
      return v(null, {
        header: P,
        payload: X,
        signature: he
      });
    }
    return v(null, X);
  });
}, INFINITY$2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER$2 = 17976931348623157e292, NAN$2 = NaN, argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]", reTrim$2 = /^\s+|\s+$/g, reIsBadHex$2 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$2 = /^0b[01]+$/i, reIsOctal$2 = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, freeParseInt$2 = parseInt;
function arrayMap(a, u) {
  for (var c = -1, l = a ? a.length : 0, v = Array(l); ++c < l; )
    v[c] = u(a[c], c, a);
  return v;
}
function baseFindIndex(a, u, c, l) {
  for (var v = a.length, p = c + (l ? 1 : -1); l ? p-- : ++p < v; )
    if (u(a[p], p, a))
      return p;
  return -1;
}
function baseIndexOf(a, u, c) {
  if (u !== u)
    return baseFindIndex(a, baseIsNaN, c);
  for (var l = c - 1, v = a.length; ++l < v; )
    if (a[l] === u)
      return l;
  return -1;
}
function baseIsNaN(a) {
  return a !== a;
}
function baseTimes(a, u) {
  for (var c = -1, l = Array(a); ++c < a; )
    l[c] = u(c);
  return l;
}
function baseValues(a, u) {
  return arrayMap(u, function(c) {
    return a[c];
  });
}
function overArg$1(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var objectProto$6 = Object.prototype, hasOwnProperty$1 = objectProto$6.hasOwnProperty, objectToString$6 = objectProto$6.toString, propertyIsEnumerable = objectProto$6.propertyIsEnumerable, nativeKeys = overArg$1(Object.keys, Object), nativeMax = Math.max;
function arrayLikeKeys(a, u) {
  var c = isArray$3(a) || isArguments(a) ? baseTimes(a.length, String) : [], l = c.length, v = !!l;
  for (var p in a)
    (u || hasOwnProperty$1.call(a, p)) && !(v && (p == "length" || isIndex(p, l))) && c.push(p);
  return c;
}
function baseKeys(a) {
  if (!isPrototype(a))
    return nativeKeys(a);
  var u = [];
  for (var c in Object(a))
    hasOwnProperty$1.call(a, c) && c != "constructor" && u.push(c);
  return u;
}
function isIndex(a, u) {
  return u = u ?? MAX_SAFE_INTEGER, !!u && (typeof a == "number" || reIsUint.test(a)) && a > -1 && a % 1 == 0 && a < u;
}
function isPrototype(a) {
  var u = a && a.constructor, c = typeof u == "function" && u.prototype || objectProto$6;
  return a === c;
}
function includes$1(a, u, c, l) {
  a = isArrayLike(a) ? a : values(a), c = c && !l ? toInteger$2(c) : 0;
  var v = a.length;
  return c < 0 && (c = nativeMax(v + c, 0)), isString$3(a) ? c <= v && a.indexOf(u, c) > -1 : !!v && baseIndexOf(a, u, c) > -1;
}
function isArguments(a) {
  return isArrayLikeObject(a) && hasOwnProperty$1.call(a, "callee") && (!propertyIsEnumerable.call(a, "callee") || objectToString$6.call(a) == argsTag);
}
var isArray$3 = Array.isArray;
function isArrayLike(a) {
  return a != null && isLength(a.length) && !isFunction$1(a);
}
function isArrayLikeObject(a) {
  return isObjectLike$6(a) && isArrayLike(a);
}
function isFunction$1(a) {
  var u = isObject$5(a) ? objectToString$6.call(a) : "";
  return u == funcTag || u == genTag;
}
function isLength(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= MAX_SAFE_INTEGER;
}
function isObject$5(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike$6(a) {
  return !!a && typeof a == "object";
}
function isString$3(a) {
  return typeof a == "string" || !isArray$3(a) && isObjectLike$6(a) && objectToString$6.call(a) == stringTag$1;
}
function isSymbol$2(a) {
  return typeof a == "symbol" || isObjectLike$6(a) && objectToString$6.call(a) == symbolTag$2;
}
function toFinite$2(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber$2(a), a === INFINITY$2 || a === -INFINITY$2) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER$2;
  }
  return a === a ? a : 0;
}
function toInteger$2(a) {
  var u = toFinite$2(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber$2(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$2(a))
    return NAN$2;
  if (isObject$5(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$5(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim$2, "");
  var c = reIsBinary$2.test(a);
  return c || reIsOctal$2.test(a) ? freeParseInt$2(a.slice(2), c ? 2 : 8) : reIsBadHex$2.test(a) ? NAN$2 : +a;
}
function keys$1(a) {
  return isArrayLike(a) ? arrayLikeKeys(a) : baseKeys(a);
}
function values(a) {
  return a ? baseValues(a, keys$1(a)) : [];
}
var lodash_includes = includes$1, boolTag = "[object Boolean]", objectProto$5 = Object.prototype, objectToString$5 = objectProto$5.toString;
function isBoolean$1(a) {
  return a === !0 || a === !1 || isObjectLike$5(a) && objectToString$5.call(a) == boolTag;
}
function isObjectLike$5(a) {
  return !!a && typeof a == "object";
}
var lodash_isboolean = isBoolean$1, INFINITY$1 = 1 / 0, MAX_INTEGER$1 = 17976931348623157e292, NAN$1 = NaN, symbolTag$1 = "[object Symbol]", reTrim$1 = /^\s+|\s+$/g, reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$1 = /^0b[01]+$/i, reIsOctal$1 = /^0o[0-7]+$/i, freeParseInt$1 = parseInt, objectProto$4 = Object.prototype, objectToString$4 = objectProto$4.toString;
function isInteger$1(a) {
  return typeof a == "number" && a == toInteger$1(a);
}
function isObject$4(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike$4(a) {
  return !!a && typeof a == "object";
}
function isSymbol$1(a) {
  return typeof a == "symbol" || isObjectLike$4(a) && objectToString$4.call(a) == symbolTag$1;
}
function toFinite$1(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber$1(a), a === INFINITY$1 || a === -INFINITY$1) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER$1;
  }
  return a === a ? a : 0;
}
function toInteger$1(a) {
  var u = toFinite$1(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber$1(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$1(a))
    return NAN$1;
  if (isObject$4(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$4(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim$1, "");
  var c = reIsBinary$1.test(a);
  return c || reIsOctal$1.test(a) ? freeParseInt$1(a.slice(2), c ? 2 : 8) : reIsBadHex$1.test(a) ? NAN$1 : +a;
}
var lodash_isinteger = isInteger$1, numberTag = "[object Number]", objectProto$3 = Object.prototype, objectToString$3 = objectProto$3.toString;
function isObjectLike$3(a) {
  return !!a && typeof a == "object";
}
function isNumber$2(a) {
  return typeof a == "number" || isObjectLike$3(a) && objectToString$3.call(a) == numberTag;
}
var lodash_isnumber = isNumber$2, objectTag = "[object Object]";
function isHostObject(a) {
  var u = !1;
  if (a != null && typeof a.toString != "function")
    try {
      u = !!(a + "");
    } catch {
    }
  return u;
}
function overArg(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var funcProto = Function.prototype, objectProto$2 = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto$2.hasOwnProperty, objectCtorString = funcToString.call(Object), objectToString$2 = objectProto$2.toString, getPrototype = overArg(Object.getPrototypeOf, Object);
function isObjectLike$2(a) {
  return !!a && typeof a == "object";
}
function isPlainObject$2(a) {
  if (!isObjectLike$2(a) || objectToString$2.call(a) != objectTag || isHostObject(a))
    return !1;
  var u = getPrototype(a);
  if (u === null)
    return !0;
  var c = hasOwnProperty.call(u, "constructor") && u.constructor;
  return typeof c == "function" && c instanceof c && funcToString.call(c) == objectCtorString;
}
var lodash_isplainobject = isPlainObject$2, stringTag = "[object String]", objectProto$1 = Object.prototype, objectToString$1 = objectProto$1.toString, isArray$2 = Array.isArray;
function isObjectLike$1(a) {
  return !!a && typeof a == "object";
}
function isString$2(a) {
  return typeof a == "string" || !isArray$2(a) && isObjectLike$1(a) && objectToString$1.call(a) == stringTag;
}
var lodash_isstring = isString$2, FUNC_ERROR_TEXT = "Expected a function", INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292, NAN = NaN, symbolTag = "[object Symbol]", reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt, objectProto = Object.prototype, objectToString = objectProto.toString;
function before(a, u) {
  var c;
  if (typeof u != "function")
    throw new TypeError(FUNC_ERROR_TEXT);
  return a = toInteger(a), function() {
    return --a > 0 && (c = u.apply(this, arguments)), a <= 1 && (u = void 0), c;
  };
}
function once$1(a) {
  return before(2, a);
}
function isObject$3(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike(a) {
  return !!a && typeof a == "object";
}
function isSymbol(a) {
  return typeof a == "symbol" || isObjectLike(a) && objectToString.call(a) == symbolTag;
}
function toFinite(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber(a), a === INFINITY || a === -INFINITY) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER;
  }
  return a === a ? a : 0;
}
function toInteger(a) {
  var u = toFinite(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol(a))
    return NAN;
  if (isObject$3(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$3(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim, "");
  var c = reIsBinary.test(a);
  return c || reIsOctal.test(a) ? freeParseInt(a.slice(2), c ? 2 : 8) : reIsBadHex.test(a) ? NAN : +a;
}
var lodash_once = once$1, timespan = timespan$2, PS_SUPPORTED = psSupported, jws = jws$3, includes = lodash_includes, isBoolean = lodash_isboolean, isInteger = lodash_isinteger, isNumber$1 = lodash_isnumber, isPlainObject$1 = lodash_isplainobject, isString$1 = lodash_isstring, once = lodash_once, SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
PS_SUPPORTED && SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
var sign_options_schema = {
  expiresIn: { isValid: function(a) {
    return isInteger(a) || isString$1(a) && a;
  }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
  notBefore: { isValid: function(a) {
    return isInteger(a) || isString$1(a) && a;
  }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
  audience: { isValid: function(a) {
    return isString$1(a) || Array.isArray(a);
  }, message: '"audience" must be a string or array' },
  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
  header: { isValid: isPlainObject$1, message: '"header" must be an object' },
  encoding: { isValid: isString$1, message: '"encoding" must be a string' },
  issuer: { isValid: isString$1, message: '"issuer" must be a string' },
  subject: { isValid: isString$1, message: '"subject" must be a string' },
  jwtid: { isValid: isString$1, message: '"jwtid" must be a string' },
  noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
  keyid: { isValid: isString$1, message: '"keyid" must be a string' },
  mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' }
}, registered_claims_schema = {
  iat: { isValid: isNumber$1, message: '"iat" should be a number of seconds' },
  exp: { isValid: isNumber$1, message: '"exp" should be a number of seconds' },
  nbf: { isValid: isNumber$1, message: '"nbf" should be a number of seconds' }
};
function validate(a, u, c, l) {
  if (!isPlainObject$1(c))
    throw new Error('Expected "' + l + '" to be a plain object.');
  Object.keys(c).forEach(function(v) {
    var p = a[v];
    if (!p) {
      if (!u)
        throw new Error('"' + v + '" is not allowed in "' + l + '"');
      return;
    }
    if (!p.isValid(c[v]))
      throw new Error(p.message);
  });
}
function validateOptions(a) {
  return validate(sign_options_schema, !1, a, "options");
}
function validatePayload(a) {
  return validate(registered_claims_schema, !0, a, "payload");
}
var options_to_payload = {
  audience: "aud",
  issuer: "iss",
  subject: "sub",
  jwtid: "jti"
}, options_for_objects = [
  "expiresIn",
  "notBefore",
  "noTimestamp",
  "audience",
  "issuer",
  "subject",
  "jwtid"
], sign = function(a, u, c, l) {
  typeof c == "function" ? (l = c, c = {}) : c = c || {};
  var v = typeof a == "object" && !Buffer$O.isBuffer(a), p = Object.assign({
    alg: c.algorithm || "HS256",
    typ: v ? "JWT" : void 0,
    kid: c.keyid
  }, c.header);
  function _(F) {
    if (l)
      return l(F);
    throw F;
  }
  if (!u && c.algorithm !== "none")
    return _(new Error("secretOrPrivateKey must have a value"));
  if (typeof a > "u")
    return _(new Error("payload is required"));
  if (v) {
    try {
      validatePayload(a);
    } catch (F) {
      return _(F);
    }
    c.mutatePayload || (a = Object.assign({}, a));
  } else {
    var I = options_for_objects.filter(function(F) {
      return typeof c[F] < "u";
    });
    if (I.length > 0)
      return _(new Error("invalid " + I.join(",") + " option for " + typeof a + " payload"));
  }
  if (typeof a.exp < "u" && typeof c.expiresIn < "u")
    return _(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  if (typeof a.nbf < "u" && typeof c.notBefore < "u")
    return _(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  try {
    validateOptions(c);
  } catch (F) {
    return _(F);
  }
  var P = a.iat || Math.floor(Date.now() / 1e3);
  if (c.noTimestamp ? delete a.iat : v && (a.iat = P), typeof c.notBefore < "u") {
    try {
      a.nbf = timespan(c.notBefore, P);
    } catch (F) {
      return _(F);
    }
    if (typeof a.nbf > "u")
      return _(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  }
  if (typeof c.expiresIn < "u" && typeof a == "object") {
    try {
      a.exp = timespan(c.expiresIn, P);
    } catch (F) {
      return _(F);
    }
    if (typeof a.exp > "u")
      return _(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  }
  Object.keys(options_to_payload).forEach(function(F) {
    var H = options_to_payload[F];
    if (typeof c[F] < "u") {
      if (typeof a[H] < "u")
        return _(new Error('Bad "options.' + F + '" option. The payload already has an "' + H + '" property.'));
      a[H] = c[F];
    }
  });
  var $ = c.encoding || "utf8";
  if (typeof l == "function")
    l = l && once(l), jws.createSign({
      header: p,
      privateKey: u,
      payload: a,
      encoding: $
    }).once("error", l).once("done", function(F) {
      l(null, F);
    });
  else
    return jws.sign({ header: p, payload: a, secret: u, encoding: $ });
}, jsonwebtoken = {
  decode: decode$1,
  verify,
  sign,
  JsonWebTokenError: JsonWebTokenError_1,
  NotBeforeError: NotBeforeError_1,
  TokenExpiredError: TokenExpiredError_1
}, __createBinding = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c), Object.defineProperty(a, l, { enumerable: !0, get: function() {
    return u[c];
  } });
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding(u, a, c);
  return __setModuleDefault(u, a), u;
};
Object.defineProperty(AccessToken$1, "__esModule", { value: !0 });
AccessToken$1.TokenVerifier = AccessToken$1.AccessToken = void 0;
const jwt = __importStar(jsonwebtoken), defaultTTL = 6 * 60 * 60;
class AccessToken {
  /**
   * Creates a new AccessToken
   * @param apiKey API Key, can be set in env LIVEKIT_API_KEY
   * @param apiSecret Secret, can be set in env LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    if (u || (u = process$1.env.LIVEKIT_API_KEY), c || (c = process$1.env.LIVEKIT_API_SECRET), !u || !c)
      throw Error("api-key and api-secret must be set");
    this.apiKey = u, this.apiSecret = c, this.grants = {}, this.identity = l == null ? void 0 : l.identity, this.ttl = (l == null ? void 0 : l.ttl) || defaultTTL, l != null && l.metadata && (this.metadata = l.metadata), l != null && l.name && (this.name = l.name);
  }
  /**
   * Adds a video grant to this token.
   * @param grant
   */
  addGrant(u) {
    this.grants.video = u;
  }
  /**
   * Set metadata to be passed to the Participant, used only when joining the room
   */
  set metadata(u) {
    this.grants.metadata = u;
  }
  set name(u) {
    this.grants.name = u;
  }
  get sha256() {
    return this.grants.sha256;
  }
  set sha256(u) {
    this.grants.sha256 = u;
  }
  /**
   * @returns JWT encoded token
   */
  toJwt() {
    var u;
    const c = {
      issuer: this.apiKey,
      expiresIn: this.ttl,
      notBefore: 0
    };
    if (this.identity)
      c.subject = this.identity, c.jwtid = this.identity;
    else if (!((u = this.grants.video) === null || u === void 0) && u.roomJoin)
      throw Error("identity is required for join but not set");
    return jwt.sign(this.grants, this.apiSecret, c);
  }
}
AccessToken$1.AccessToken = AccessToken;
class TokenVerifier {
  constructor(u, c) {
    this.apiKey = u, this.apiSecret = c;
  }
  verify(u) {
    const c = jwt.verify(u, this.apiSecret, { issuer: this.apiKey });
    if (!c)
      throw Error("invalid token");
    return c;
  }
}
AccessToken$1.TokenVerifier = TokenVerifier;
var EgressClient$1 = {}, livekit_egress = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(V) {
    return V && V.__esModule ? V : { default: V };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.AutoTrackEgress = a.SegmentsInfo = a.FileInfo = a.StreamInfo = a.StreamInfoList = a.EgressInfo = a.StopEgressRequest = a.ListEgressResponse = a.ListEgressRequest = a.UpdateStreamRequest = a.UpdateLayoutRequest = a.EncodingOptions = a.StreamOutput = a.AliOSSUpload = a.AzureBlobUpload = a.GCPUpload = a.S3Upload_MetadataEntry = a.S3Upload = a.DirectFileOutput = a.SegmentedFileOutput = a.EncodedFileOutput = a.WebEgressRequest = a.TrackEgressRequest = a.TrackCompositeEgressRequest = a.RoomCompositeEgressRequest = a.streamInfo_StatusToJSON = a.streamInfo_StatusFromJSON = a.StreamInfo_Status = a.egressStatusToJSON = a.egressStatusFromJSON = a.EgressStatus = a.encodingOptionsPresetToJSON = a.encodingOptionsPresetFromJSON = a.EncodingOptionsPreset = a.videoCodecToJSON = a.videoCodecFromJSON = a.VideoCodec = a.audioCodecToJSON = a.audioCodecFromJSON = a.AudioCodec = a.segmentedFileProtocolToJSON = a.segmentedFileProtocolFromJSON = a.SegmentedFileProtocol = a.streamProtocolToJSON = a.streamProtocolFromJSON = a.StreamProtocol = a.encodedFileTypeToJSON = a.encodedFileTypeFromJSON = a.EncodedFileType = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal);
  a.protobufPackage = "livekit";
  var v;
  (function(V) {
    V[V.DEFAULT_FILETYPE = 0] = "DEFAULT_FILETYPE", V[V.MP4 = 1] = "MP4", V[V.OGG = 2] = "OGG", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(v = a.EncodedFileType || (a.EncodedFileType = {}));
  function p(V) {
    switch (V) {
      case 0:
      case "DEFAULT_FILETYPE":
        return v.DEFAULT_FILETYPE;
      case 1:
      case "MP4":
        return v.MP4;
      case 2:
      case "OGG":
        return v.OGG;
      case -1:
      case "UNRECOGNIZED":
      default:
        return v.UNRECOGNIZED;
    }
  }
  a.encodedFileTypeFromJSON = p;
  function _(V) {
    switch (V) {
      case v.DEFAULT_FILETYPE:
        return "DEFAULT_FILETYPE";
      case v.MP4:
        return "MP4";
      case v.OGG:
        return "OGG";
      case v.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.encodedFileTypeToJSON = _;
  var I;
  (function(V) {
    V[V.DEFAULT_PROTOCOL = 0] = "DEFAULT_PROTOCOL", V[V.RTMP = 1] = "RTMP", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(I = a.StreamProtocol || (a.StreamProtocol = {}));
  function P(V) {
    switch (V) {
      case 0:
      case "DEFAULT_PROTOCOL":
        return I.DEFAULT_PROTOCOL;
      case 1:
      case "RTMP":
        return I.RTMP;
      case -1:
      case "UNRECOGNIZED":
      default:
        return I.UNRECOGNIZED;
    }
  }
  a.streamProtocolFromJSON = P;
  function $(V) {
    switch (V) {
      case I.DEFAULT_PROTOCOL:
        return "DEFAULT_PROTOCOL";
      case I.RTMP:
        return "RTMP";
      case I.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamProtocolToJSON = $;
  var F;
  (function(V) {
    V[V.DEFAULT_SEGMENTED_FILE_PROTOCOL = 0] = "DEFAULT_SEGMENTED_FILE_PROTOCOL", V[V.HLS_PROTOCOL = 1] = "HLS_PROTOCOL", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(F = a.SegmentedFileProtocol || (a.SegmentedFileProtocol = {}));
  function H(V) {
    switch (V) {
      case 0:
      case "DEFAULT_SEGMENTED_FILE_PROTOCOL":
        return F.DEFAULT_SEGMENTED_FILE_PROTOCOL;
      case 1:
      case "HLS_PROTOCOL":
        return F.HLS_PROTOCOL;
      case -1:
      case "UNRECOGNIZED":
      default:
        return F.UNRECOGNIZED;
    }
  }
  a.segmentedFileProtocolFromJSON = H;
  function j(V) {
    switch (V) {
      case F.DEFAULT_SEGMENTED_FILE_PROTOCOL:
        return "DEFAULT_SEGMENTED_FILE_PROTOCOL";
      case F.HLS_PROTOCOL:
        return "HLS_PROTOCOL";
      case F.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.segmentedFileProtocolToJSON = j;
  var ee;
  (function(V) {
    V[V.DEFAULT_AC = 0] = "DEFAULT_AC", V[V.OPUS = 1] = "OPUS", V[V.AAC = 2] = "AAC", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(ee = a.AudioCodec || (a.AudioCodec = {}));
  function X(V) {
    switch (V) {
      case 0:
      case "DEFAULT_AC":
        return ee.DEFAULT_AC;
      case 1:
      case "OPUS":
        return ee.OPUS;
      case 2:
      case "AAC":
        return ee.AAC;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ee.UNRECOGNIZED;
    }
  }
  a.audioCodecFromJSON = X;
  function ie(V) {
    switch (V) {
      case ee.DEFAULT_AC:
        return "DEFAULT_AC";
      case ee.OPUS:
        return "OPUS";
      case ee.AAC:
        return "AAC";
      case ee.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.audioCodecToJSON = ie;
  var Q;
  (function(V) {
    V[V.DEFAULT_VC = 0] = "DEFAULT_VC", V[V.H264_BASELINE = 1] = "H264_BASELINE", V[V.H264_MAIN = 2] = "H264_MAIN", V[V.H264_HIGH = 3] = "H264_HIGH", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(Q = a.VideoCodec || (a.VideoCodec = {}));
  function ne(V) {
    switch (V) {
      case 0:
      case "DEFAULT_VC":
        return Q.DEFAULT_VC;
      case 1:
      case "H264_BASELINE":
        return Q.H264_BASELINE;
      case 2:
      case "H264_MAIN":
        return Q.H264_MAIN;
      case 3:
      case "H264_HIGH":
        return Q.H264_HIGH;
      case -1:
      case "UNRECOGNIZED":
      default:
        return Q.UNRECOGNIZED;
    }
  }
  a.videoCodecFromJSON = ne;
  function Z(V) {
    switch (V) {
      case Q.DEFAULT_VC:
        return "DEFAULT_VC";
      case Q.H264_BASELINE:
        return "H264_BASELINE";
      case Q.H264_MAIN:
        return "H264_MAIN";
      case Q.H264_HIGH:
        return "H264_HIGH";
      case Q.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.videoCodecToJSON = Z;
  var de;
  (function(V) {
    V[V.H264_720P_30 = 0] = "H264_720P_30", V[V.H264_720P_60 = 1] = "H264_720P_60", V[V.H264_1080P_30 = 2] = "H264_1080P_30", V[V.H264_1080P_60 = 3] = "H264_1080P_60", V[V.PORTRAIT_H264_720P_30 = 4] = "PORTRAIT_H264_720P_30", V[V.PORTRAIT_H264_720P_60 = 5] = "PORTRAIT_H264_720P_60", V[V.PORTRAIT_H264_1080P_30 = 6] = "PORTRAIT_H264_1080P_30", V[V.PORTRAIT_H264_1080P_60 = 7] = "PORTRAIT_H264_1080P_60", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(de = a.EncodingOptionsPreset || (a.EncodingOptionsPreset = {}));
  function he(V) {
    switch (V) {
      case 0:
      case "H264_720P_30":
        return de.H264_720P_30;
      case 1:
      case "H264_720P_60":
        return de.H264_720P_60;
      case 2:
      case "H264_1080P_30":
        return de.H264_1080P_30;
      case 3:
      case "H264_1080P_60":
        return de.H264_1080P_60;
      case 4:
      case "PORTRAIT_H264_720P_30":
        return de.PORTRAIT_H264_720P_30;
      case 5:
      case "PORTRAIT_H264_720P_60":
        return de.PORTRAIT_H264_720P_60;
      case 6:
      case "PORTRAIT_H264_1080P_30":
        return de.PORTRAIT_H264_1080P_30;
      case 7:
      case "PORTRAIT_H264_1080P_60":
        return de.PORTRAIT_H264_1080P_60;
      case -1:
      case "UNRECOGNIZED":
      default:
        return de.UNRECOGNIZED;
    }
  }
  a.encodingOptionsPresetFromJSON = he;
  function pe(V) {
    switch (V) {
      case de.H264_720P_30:
        return "H264_720P_30";
      case de.H264_720P_60:
        return "H264_720P_60";
      case de.H264_1080P_30:
        return "H264_1080P_30";
      case de.H264_1080P_60:
        return "H264_1080P_60";
      case de.PORTRAIT_H264_720P_30:
        return "PORTRAIT_H264_720P_30";
      case de.PORTRAIT_H264_720P_60:
        return "PORTRAIT_H264_720P_60";
      case de.PORTRAIT_H264_1080P_30:
        return "PORTRAIT_H264_1080P_30";
      case de.PORTRAIT_H264_1080P_60:
        return "PORTRAIT_H264_1080P_60";
      case de.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.encodingOptionsPresetToJSON = pe;
  var be;
  (function(V) {
    V[V.EGRESS_STARTING = 0] = "EGRESS_STARTING", V[V.EGRESS_ACTIVE = 1] = "EGRESS_ACTIVE", V[V.EGRESS_ENDING = 2] = "EGRESS_ENDING", V[V.EGRESS_COMPLETE = 3] = "EGRESS_COMPLETE", V[V.EGRESS_FAILED = 4] = "EGRESS_FAILED", V[V.EGRESS_ABORTED = 5] = "EGRESS_ABORTED", V[V.EGRESS_LIMIT_REACHED = 6] = "EGRESS_LIMIT_REACHED", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(be = a.EgressStatus || (a.EgressStatus = {}));
  function ke(V) {
    switch (V) {
      case 0:
      case "EGRESS_STARTING":
        return be.EGRESS_STARTING;
      case 1:
      case "EGRESS_ACTIVE":
        return be.EGRESS_ACTIVE;
      case 2:
      case "EGRESS_ENDING":
        return be.EGRESS_ENDING;
      case 3:
      case "EGRESS_COMPLETE":
        return be.EGRESS_COMPLETE;
      case 4:
      case "EGRESS_FAILED":
        return be.EGRESS_FAILED;
      case 5:
      case "EGRESS_ABORTED":
        return be.EGRESS_ABORTED;
      case 6:
      case "EGRESS_LIMIT_REACHED":
        return be.EGRESS_LIMIT_REACHED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return be.UNRECOGNIZED;
    }
  }
  a.egressStatusFromJSON = ke;
  function _e(V) {
    switch (V) {
      case be.EGRESS_STARTING:
        return "EGRESS_STARTING";
      case be.EGRESS_ACTIVE:
        return "EGRESS_ACTIVE";
      case be.EGRESS_ENDING:
        return "EGRESS_ENDING";
      case be.EGRESS_COMPLETE:
        return "EGRESS_COMPLETE";
      case be.EGRESS_FAILED:
        return "EGRESS_FAILED";
      case be.EGRESS_ABORTED:
        return "EGRESS_ABORTED";
      case be.EGRESS_LIMIT_REACHED:
        return "EGRESS_LIMIT_REACHED";
      case be.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.egressStatusToJSON = _e;
  var q;
  (function(V) {
    V[V.ACTIVE = 0] = "ACTIVE", V[V.FINISHED = 1] = "FINISHED", V[V.FAILED = 2] = "FAILED", V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(q = a.StreamInfo_Status || (a.StreamInfo_Status = {}));
  function z(V) {
    switch (V) {
      case 0:
      case "ACTIVE":
        return q.ACTIVE;
      case 1:
      case "FINISHED":
        return q.FINISHED;
      case 2:
      case "FAILED":
        return q.FAILED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return q.UNRECOGNIZED;
    }
  }
  a.streamInfo_StatusFromJSON = z;
  function C(V) {
    switch (V) {
      case q.ACTIVE:
        return "ACTIVE";
      case q.FINISHED:
        return "FINISHED";
      case q.FAILED:
        return "FAILED";
      case q.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamInfo_StatusToJSON = C;
  function b() {
    return {
      roomName: "",
      layout: "",
      audioOnly: !1,
      videoOnly: !1,
      customBaseUrl: "",
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.RoomCompositeEgressRequest = {
    encode(V, ge = l.default.Writer.create()) {
      return V.roomName !== void 0 && V.roomName !== "" && ge.uint32(10).string(V.roomName), V.layout !== void 0 && V.layout !== "" && ge.uint32(18).string(V.layout), V.audioOnly === !0 && ge.uint32(24).bool(V.audioOnly), V.videoOnly === !0 && ge.uint32(32).bool(V.videoOnly), V.customBaseUrl !== void 0 && V.customBaseUrl !== "" && ge.uint32(42).string(V.customBaseUrl), V.file !== void 0 && a.EncodedFileOutput.encode(V.file, ge.uint32(50).fork()).ldelim(), V.stream !== void 0 && a.StreamOutput.encode(V.stream, ge.uint32(58).fork()).ldelim(), V.segments !== void 0 && a.SegmentedFileOutput.encode(V.segments, ge.uint32(82).fork()).ldelim(), V.preset !== void 0 && ge.uint32(64).int32(V.preset), V.advanced !== void 0 && a.EncodingOptions.encode(V.advanced, ge.uint32(74).fork()).ldelim(), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = b();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.roomName = Te.string();
            break;
          case 2:
            Re.layout = Te.string();
            break;
          case 3:
            Re.audioOnly = Te.bool();
            break;
          case 4:
            Re.videoOnly = Te.bool();
            break;
          case 5:
            Re.customBaseUrl = Te.string();
            break;
          case 6:
            Re.file = a.EncodedFileOutput.decode(Te, Te.uint32());
            break;
          case 7:
            Re.stream = a.StreamOutput.decode(Te, Te.uint32());
            break;
          case 10:
            Re.segments = a.SegmentedFileOutput.decode(Te, Te.uint32());
            break;
          case 8:
            Re.preset = Te.int32();
            break;
          case 9:
            Re.advanced = a.EncodingOptions.decode(Te, Te.uint32());
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        roomName: Ge(V.roomName) ? String(V.roomName) : "",
        layout: Ge(V.layout) ? String(V.layout) : "",
        audioOnly: Ge(V.audioOnly) ? !!V.audioOnly : !1,
        videoOnly: Ge(V.videoOnly) ? !!V.videoOnly : !1,
        customBaseUrl: Ge(V.customBaseUrl) ? String(V.customBaseUrl) : "",
        file: Ge(V.file) ? a.EncodedFileOutput.fromJSON(V.file) : void 0,
        stream: Ge(V.stream) ? a.StreamOutput.fromJSON(V.stream) : void 0,
        segments: Ge(V.segments) ? a.SegmentedFileOutput.fromJSON(V.segments) : void 0,
        preset: Ge(V.preset) ? he(V.preset) : void 0,
        advanced: Ge(V.advanced) ? a.EncodingOptions.fromJSON(V.advanced) : void 0
      };
    },
    toJSON(V) {
      const ge = {};
      return V.roomName !== void 0 && (ge.roomName = V.roomName), V.layout !== void 0 && (ge.layout = V.layout), V.audioOnly !== void 0 && (ge.audioOnly = V.audioOnly), V.videoOnly !== void 0 && (ge.videoOnly = V.videoOnly), V.customBaseUrl !== void 0 && (ge.customBaseUrl = V.customBaseUrl), V.file !== void 0 && (ge.file = V.file ? a.EncodedFileOutput.toJSON(V.file) : void 0), V.stream !== void 0 && (ge.stream = V.stream ? a.StreamOutput.toJSON(V.stream) : void 0), V.segments !== void 0 && (ge.segments = V.segments ? a.SegmentedFileOutput.toJSON(V.segments) : void 0), V.preset !== void 0 && (ge.preset = V.preset !== void 0 ? pe(V.preset) : void 0), V.advanced !== void 0 && (ge.advanced = V.advanced ? a.EncodingOptions.toJSON(V.advanced) : void 0), ge;
    },
    fromPartial(V) {
      var ge, Te, We, Re, J, Ee;
      const ue = b();
      return ue.roomName = (ge = V.roomName) !== null && ge !== void 0 ? ge : "", ue.layout = (Te = V.layout) !== null && Te !== void 0 ? Te : "", ue.audioOnly = (We = V.audioOnly) !== null && We !== void 0 ? We : !1, ue.videoOnly = (Re = V.videoOnly) !== null && Re !== void 0 ? Re : !1, ue.customBaseUrl = (J = V.customBaseUrl) !== null && J !== void 0 ? J : "", ue.file = V.file !== void 0 && V.file !== null ? a.EncodedFileOutput.fromPartial(V.file) : void 0, ue.stream = V.stream !== void 0 && V.stream !== null ? a.StreamOutput.fromPartial(V.stream) : void 0, ue.segments = V.segments !== void 0 && V.segments !== null ? a.SegmentedFileOutput.fromPartial(V.segments) : void 0, ue.preset = (Ee = V.preset) !== null && Ee !== void 0 ? Ee : void 0, ue.advanced = V.advanced !== void 0 && V.advanced !== null ? a.EncodingOptions.fromPartial(V.advanced) : void 0, ue;
    }
  };
  function E() {
    return {
      roomName: "",
      audioTrackId: "",
      videoTrackId: "",
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.TrackCompositeEgressRequest = {
    encode(V, ge = l.default.Writer.create()) {
      return V.roomName !== void 0 && V.roomName !== "" && ge.uint32(10).string(V.roomName), V.audioTrackId !== void 0 && V.audioTrackId !== "" && ge.uint32(18).string(V.audioTrackId), V.videoTrackId !== void 0 && V.videoTrackId !== "" && ge.uint32(26).string(V.videoTrackId), V.file !== void 0 && a.EncodedFileOutput.encode(V.file, ge.uint32(34).fork()).ldelim(), V.stream !== void 0 && a.StreamOutput.encode(V.stream, ge.uint32(42).fork()).ldelim(), V.segments !== void 0 && a.SegmentedFileOutput.encode(V.segments, ge.uint32(66).fork()).ldelim(), V.preset !== void 0 && ge.uint32(48).int32(V.preset), V.advanced !== void 0 && a.EncodingOptions.encode(V.advanced, ge.uint32(58).fork()).ldelim(), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = E();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.roomName = Te.string();
            break;
          case 2:
            Re.audioTrackId = Te.string();
            break;
          case 3:
            Re.videoTrackId = Te.string();
            break;
          case 4:
            Re.file = a.EncodedFileOutput.decode(Te, Te.uint32());
            break;
          case 5:
            Re.stream = a.StreamOutput.decode(Te, Te.uint32());
            break;
          case 8:
            Re.segments = a.SegmentedFileOutput.decode(Te, Te.uint32());
            break;
          case 6:
            Re.preset = Te.int32();
            break;
          case 7:
            Re.advanced = a.EncodingOptions.decode(Te, Te.uint32());
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        roomName: Ge(V.roomName) ? String(V.roomName) : "",
        audioTrackId: Ge(V.audioTrackId) ? String(V.audioTrackId) : "",
        videoTrackId: Ge(V.videoTrackId) ? String(V.videoTrackId) : "",
        file: Ge(V.file) ? a.EncodedFileOutput.fromJSON(V.file) : void 0,
        stream: Ge(V.stream) ? a.StreamOutput.fromJSON(V.stream) : void 0,
        segments: Ge(V.segments) ? a.SegmentedFileOutput.fromJSON(V.segments) : void 0,
        preset: Ge(V.preset) ? he(V.preset) : void 0,
        advanced: Ge(V.advanced) ? a.EncodingOptions.fromJSON(V.advanced) : void 0
      };
    },
    toJSON(V) {
      const ge = {};
      return V.roomName !== void 0 && (ge.roomName = V.roomName), V.audioTrackId !== void 0 && (ge.audioTrackId = V.audioTrackId), V.videoTrackId !== void 0 && (ge.videoTrackId = V.videoTrackId), V.file !== void 0 && (ge.file = V.file ? a.EncodedFileOutput.toJSON(V.file) : void 0), V.stream !== void 0 && (ge.stream = V.stream ? a.StreamOutput.toJSON(V.stream) : void 0), V.segments !== void 0 && (ge.segments = V.segments ? a.SegmentedFileOutput.toJSON(V.segments) : void 0), V.preset !== void 0 && (ge.preset = V.preset !== void 0 ? pe(V.preset) : void 0), V.advanced !== void 0 && (ge.advanced = V.advanced ? a.EncodingOptions.toJSON(V.advanced) : void 0), ge;
    },
    fromPartial(V) {
      var ge, Te, We, Re;
      const J = E();
      return J.roomName = (ge = V.roomName) !== null && ge !== void 0 ? ge : "", J.audioTrackId = (Te = V.audioTrackId) !== null && Te !== void 0 ? Te : "", J.videoTrackId = (We = V.videoTrackId) !== null && We !== void 0 ? We : "", J.file = V.file !== void 0 && V.file !== null ? a.EncodedFileOutput.fromPartial(V.file) : void 0, J.stream = V.stream !== void 0 && V.stream !== null ? a.StreamOutput.fromPartial(V.stream) : void 0, J.segments = V.segments !== void 0 && V.segments !== null ? a.SegmentedFileOutput.fromPartial(V.segments) : void 0, J.preset = (Re = V.preset) !== null && Re !== void 0 ? Re : void 0, J.advanced = V.advanced !== void 0 && V.advanced !== null ? a.EncodingOptions.fromPartial(V.advanced) : void 0, J;
    }
  };
  function k() {
    return { roomName: "", trackId: "", file: void 0, websocketUrl: void 0 };
  }
  a.TrackEgressRequest = {
    encode(V, ge = l.default.Writer.create()) {
      return V.roomName !== void 0 && V.roomName !== "" && ge.uint32(10).string(V.roomName), V.trackId !== void 0 && V.trackId !== "" && ge.uint32(18).string(V.trackId), V.file !== void 0 && a.DirectFileOutput.encode(V.file, ge.uint32(26).fork()).ldelim(), V.websocketUrl !== void 0 && ge.uint32(34).string(V.websocketUrl), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = k();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.roomName = Te.string();
            break;
          case 2:
            Re.trackId = Te.string();
            break;
          case 3:
            Re.file = a.DirectFileOutput.decode(Te, Te.uint32());
            break;
          case 4:
            Re.websocketUrl = Te.string();
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        roomName: Ge(V.roomName) ? String(V.roomName) : "",
        trackId: Ge(V.trackId) ? String(V.trackId) : "",
        file: Ge(V.file) ? a.DirectFileOutput.fromJSON(V.file) : void 0,
        websocketUrl: Ge(V.websocketUrl) ? String(V.websocketUrl) : void 0
      };
    },
    toJSON(V) {
      const ge = {};
      return V.roomName !== void 0 && (ge.roomName = V.roomName), V.trackId !== void 0 && (ge.trackId = V.trackId), V.file !== void 0 && (ge.file = V.file ? a.DirectFileOutput.toJSON(V.file) : void 0), V.websocketUrl !== void 0 && (ge.websocketUrl = V.websocketUrl), ge;
    },
    fromPartial(V) {
      var ge, Te, We;
      const Re = k();
      return Re.roomName = (ge = V.roomName) !== null && ge !== void 0 ? ge : "", Re.trackId = (Te = V.trackId) !== null && Te !== void 0 ? Te : "", Re.file = V.file !== void 0 && V.file !== null ? a.DirectFileOutput.fromPartial(V.file) : void 0, Re.websocketUrl = (We = V.websocketUrl) !== null && We !== void 0 ? We : void 0, Re;
    }
  };
  function O() {
    return {
      url: "",
      audioOnly: !1,
      videoOnly: !1,
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.WebEgressRequest = {
    encode(V, ge = l.default.Writer.create()) {
      return V.url !== void 0 && V.url !== "" && ge.uint32(10).string(V.url), V.audioOnly === !0 && ge.uint32(16).bool(V.audioOnly), V.videoOnly === !0 && ge.uint32(24).bool(V.videoOnly), V.file !== void 0 && a.EncodedFileOutput.encode(V.file, ge.uint32(34).fork()).ldelim(), V.stream !== void 0 && a.StreamOutput.encode(V.stream, ge.uint32(42).fork()).ldelim(), V.segments !== void 0 && a.SegmentedFileOutput.encode(V.segments, ge.uint32(50).fork()).ldelim(), V.preset !== void 0 && ge.uint32(56).int32(V.preset), V.advanced !== void 0 && a.EncodingOptions.encode(V.advanced, ge.uint32(66).fork()).ldelim(), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = O();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.url = Te.string();
            break;
          case 2:
            Re.audioOnly = Te.bool();
            break;
          case 3:
            Re.videoOnly = Te.bool();
            break;
          case 4:
            Re.file = a.EncodedFileOutput.decode(Te, Te.uint32());
            break;
          case 5:
            Re.stream = a.StreamOutput.decode(Te, Te.uint32());
            break;
          case 6:
            Re.segments = a.SegmentedFileOutput.decode(Te, Te.uint32());
            break;
          case 7:
            Re.preset = Te.int32();
            break;
          case 8:
            Re.advanced = a.EncodingOptions.decode(Te, Te.uint32());
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        url: Ge(V.url) ? String(V.url) : "",
        audioOnly: Ge(V.audioOnly) ? !!V.audioOnly : !1,
        videoOnly: Ge(V.videoOnly) ? !!V.videoOnly : !1,
        file: Ge(V.file) ? a.EncodedFileOutput.fromJSON(V.file) : void 0,
        stream: Ge(V.stream) ? a.StreamOutput.fromJSON(V.stream) : void 0,
        segments: Ge(V.segments) ? a.SegmentedFileOutput.fromJSON(V.segments) : void 0,
        preset: Ge(V.preset) ? he(V.preset) : void 0,
        advanced: Ge(V.advanced) ? a.EncodingOptions.fromJSON(V.advanced) : void 0
      };
    },
    toJSON(V) {
      const ge = {};
      return V.url !== void 0 && (ge.url = V.url), V.audioOnly !== void 0 && (ge.audioOnly = V.audioOnly), V.videoOnly !== void 0 && (ge.videoOnly = V.videoOnly), V.file !== void 0 && (ge.file = V.file ? a.EncodedFileOutput.toJSON(V.file) : void 0), V.stream !== void 0 && (ge.stream = V.stream ? a.StreamOutput.toJSON(V.stream) : void 0), V.segments !== void 0 && (ge.segments = V.segments ? a.SegmentedFileOutput.toJSON(V.segments) : void 0), V.preset !== void 0 && (ge.preset = V.preset !== void 0 ? pe(V.preset) : void 0), V.advanced !== void 0 && (ge.advanced = V.advanced ? a.EncodingOptions.toJSON(V.advanced) : void 0), ge;
    },
    fromPartial(V) {
      var ge, Te, We, Re;
      const J = O();
      return J.url = (ge = V.url) !== null && ge !== void 0 ? ge : "", J.audioOnly = (Te = V.audioOnly) !== null && Te !== void 0 ? Te : !1, J.videoOnly = (We = V.videoOnly) !== null && We !== void 0 ? We : !1, J.file = V.file !== void 0 && V.file !== null ? a.EncodedFileOutput.fromPartial(V.file) : void 0, J.stream = V.stream !== void 0 && V.stream !== null ? a.StreamOutput.fromPartial(V.stream) : void 0, J.segments = V.segments !== void 0 && V.segments !== null ? a.SegmentedFileOutput.fromPartial(V.segments) : void 0, J.preset = (Re = V.preset) !== null && Re !== void 0 ? Re : void 0, J.advanced = V.advanced !== void 0 && V.advanced !== null ? a.EncodingOptions.fromPartial(V.advanced) : void 0, J;
    }
  };
  function A() {
    return {
      fileType: 0,
      filepath: "",
      disableManifest: !1,
      s3: void 0,
      gcp: void 0,
      azure: void 0,
      aliOSS: void 0
    };
  }
  a.EncodedFileOutput = {
    encode(V, ge = l.default.Writer.create()) {
      return V.fileType !== void 0 && V.fileType !== 0 && ge.uint32(8).int32(V.fileType), V.filepath !== void 0 && V.filepath !== "" && ge.uint32(18).string(V.filepath), V.disableManifest === !0 && ge.uint32(48).bool(V.disableManifest), V.s3 !== void 0 && a.S3Upload.encode(V.s3, ge.uint32(26).fork()).ldelim(), V.gcp !== void 0 && a.GCPUpload.encode(V.gcp, ge.uint32(34).fork()).ldelim(), V.azure !== void 0 && a.AzureBlobUpload.encode(V.azure, ge.uint32(42).fork()).ldelim(), V.aliOSS !== void 0 && a.AliOSSUpload.encode(V.aliOSS, ge.uint32(58).fork()).ldelim(), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = A();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.fileType = Te.int32();
            break;
          case 2:
            Re.filepath = Te.string();
            break;
          case 6:
            Re.disableManifest = Te.bool();
            break;
          case 3:
            Re.s3 = a.S3Upload.decode(Te, Te.uint32());
            break;
          case 4:
            Re.gcp = a.GCPUpload.decode(Te, Te.uint32());
            break;
          case 5:
            Re.azure = a.AzureBlobUpload.decode(Te, Te.uint32());
            break;
          case 7:
            Re.aliOSS = a.AliOSSUpload.decode(Te, Te.uint32());
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        fileType: Ge(V.fileType) ? p(V.fileType) : 0,
        filepath: Ge(V.filepath) ? String(V.filepath) : "",
        disableManifest: Ge(V.disableManifest) ? !!V.disableManifest : !1,
        s3: Ge(V.s3) ? a.S3Upload.fromJSON(V.s3) : void 0,
        gcp: Ge(V.gcp) ? a.GCPUpload.fromJSON(V.gcp) : void 0,
        azure: Ge(V.azure) ? a.AzureBlobUpload.fromJSON(V.azure) : void 0,
        aliOSS: Ge(V.aliOSS) ? a.AliOSSUpload.fromJSON(V.aliOSS) : void 0
      };
    },
    toJSON(V) {
      const ge = {};
      return V.fileType !== void 0 && (ge.fileType = _(V.fileType)), V.filepath !== void 0 && (ge.filepath = V.filepath), V.disableManifest !== void 0 && (ge.disableManifest = V.disableManifest), V.s3 !== void 0 && (ge.s3 = V.s3 ? a.S3Upload.toJSON(V.s3) : void 0), V.gcp !== void 0 && (ge.gcp = V.gcp ? a.GCPUpload.toJSON(V.gcp) : void 0), V.azure !== void 0 && (ge.azure = V.azure ? a.AzureBlobUpload.toJSON(V.azure) : void 0), V.aliOSS !== void 0 && (ge.aliOSS = V.aliOSS ? a.AliOSSUpload.toJSON(V.aliOSS) : void 0), ge;
    },
    fromPartial(V) {
      var ge, Te, We;
      const Re = A();
      return Re.fileType = (ge = V.fileType) !== null && ge !== void 0 ? ge : 0, Re.filepath = (Te = V.filepath) !== null && Te !== void 0 ? Te : "", Re.disableManifest = (We = V.disableManifest) !== null && We !== void 0 ? We : !1, Re.s3 = V.s3 !== void 0 && V.s3 !== null ? a.S3Upload.fromPartial(V.s3) : void 0, Re.gcp = V.gcp !== void 0 && V.gcp !== null ? a.GCPUpload.fromPartial(V.gcp) : void 0, Re.azure = V.azure !== void 0 && V.azure !== null ? a.AzureBlobUpload.fromPartial(V.azure) : void 0, Re.aliOSS = V.aliOSS !== void 0 && V.aliOSS !== null ? a.AliOSSUpload.fromPartial(V.aliOSS) : void 0, Re;
    }
  };
  function x() {
    return {
      protocol: 0,
      filenamePrefix: "",
      playlistName: "",
      segmentDuration: 0,
      disableManifest: !1,
      s3: void 0,
      gcp: void 0,
      azure: void 0,
      aliOSS: void 0
    };
  }
  a.SegmentedFileOutput = {
    encode(V, ge = l.default.Writer.create()) {
      return V.protocol !== void 0 && V.protocol !== 0 && ge.uint32(8).int32(V.protocol), V.filenamePrefix !== void 0 && V.filenamePrefix !== "" && ge.uint32(18).string(V.filenamePrefix), V.playlistName !== void 0 && V.playlistName !== "" && ge.uint32(26).string(V.playlistName), V.segmentDuration !== void 0 && V.segmentDuration !== 0 && ge.uint32(32).uint32(V.segmentDuration), V.disableManifest === !0 && ge.uint32(64).bool(V.disableManifest), V.s3 !== void 0 && a.S3Upload.encode(V.s3, ge.uint32(42).fork()).ldelim(), V.gcp !== void 0 && a.GCPUpload.encode(V.gcp, ge.uint32(50).fork()).ldelim(), V.azure !== void 0 && a.AzureBlobUpload.encode(V.azure, ge.uint32(58).fork()).ldelim(), V.aliOSS !== void 0 && a.AliOSSUpload.encode(V.aliOSS, ge.uint32(74).fork()).ldelim(), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = x();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.protocol = Te.int32();
            break;
          case 2:
            Re.filenamePrefix = Te.string();
            break;
          case 3:
            Re.playlistName = Te.string();
            break;
          case 4:
            Re.segmentDuration = Te.uint32();
            break;
          case 8:
            Re.disableManifest = Te.bool();
            break;
          case 5:
            Re.s3 = a.S3Upload.decode(Te, Te.uint32());
            break;
          case 6:
            Re.gcp = a.GCPUpload.decode(Te, Te.uint32());
            break;
          case 7:
            Re.azure = a.AzureBlobUpload.decode(Te, Te.uint32());
            break;
          case 9:
            Re.aliOSS = a.AliOSSUpload.decode(Te, Te.uint32());
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        protocol: Ge(V.protocol) ? H(V.protocol) : 0,
        filenamePrefix: Ge(V.filenamePrefix) ? String(V.filenamePrefix) : "",
        playlistName: Ge(V.playlistName) ? String(V.playlistName) : "",
        segmentDuration: Ge(V.segmentDuration) ? Number(V.segmentDuration) : 0,
        disableManifest: Ge(V.disableManifest) ? !!V.disableManifest : !1,
        s3: Ge(V.s3) ? a.S3Upload.fromJSON(V.s3) : void 0,
        gcp: Ge(V.gcp) ? a.GCPUpload.fromJSON(V.gcp) : void 0,
        azure: Ge(V.azure) ? a.AzureBlobUpload.fromJSON(V.azure) : void 0,
        aliOSS: Ge(V.aliOSS) ? a.AliOSSUpload.fromJSON(V.aliOSS) : void 0
      };
    },
    toJSON(V) {
      const ge = {};
      return V.protocol !== void 0 && (ge.protocol = j(V.protocol)), V.filenamePrefix !== void 0 && (ge.filenamePrefix = V.filenamePrefix), V.playlistName !== void 0 && (ge.playlistName = V.playlistName), V.segmentDuration !== void 0 && (ge.segmentDuration = Math.round(V.segmentDuration)), V.disableManifest !== void 0 && (ge.disableManifest = V.disableManifest), V.s3 !== void 0 && (ge.s3 = V.s3 ? a.S3Upload.toJSON(V.s3) : void 0), V.gcp !== void 0 && (ge.gcp = V.gcp ? a.GCPUpload.toJSON(V.gcp) : void 0), V.azure !== void 0 && (ge.azure = V.azure ? a.AzureBlobUpload.toJSON(V.azure) : void 0), V.aliOSS !== void 0 && (ge.aliOSS = V.aliOSS ? a.AliOSSUpload.toJSON(V.aliOSS) : void 0), ge;
    },
    fromPartial(V) {
      var ge, Te, We, Re, J;
      const Ee = x();
      return Ee.protocol = (ge = V.protocol) !== null && ge !== void 0 ? ge : 0, Ee.filenamePrefix = (Te = V.filenamePrefix) !== null && Te !== void 0 ? Te : "", Ee.playlistName = (We = V.playlistName) !== null && We !== void 0 ? We : "", Ee.segmentDuration = (Re = V.segmentDuration) !== null && Re !== void 0 ? Re : 0, Ee.disableManifest = (J = V.disableManifest) !== null && J !== void 0 ? J : !1, Ee.s3 = V.s3 !== void 0 && V.s3 !== null ? a.S3Upload.fromPartial(V.s3) : void 0, Ee.gcp = V.gcp !== void 0 && V.gcp !== null ? a.GCPUpload.fromPartial(V.gcp) : void 0, Ee.azure = V.azure !== void 0 && V.azure !== null ? a.AzureBlobUpload.fromPartial(V.azure) : void 0, Ee.aliOSS = V.aliOSS !== void 0 && V.aliOSS !== null ? a.AliOSSUpload.fromPartial(V.aliOSS) : void 0, Ee;
    }
  };
  function Y() {
    return { filepath: "", disableManifest: !1, s3: void 0, gcp: void 0, azure: void 0, aliOSS: void 0 };
  }
  a.DirectFileOutput = {
    encode(V, ge = l.default.Writer.create()) {
      return V.filepath !== void 0 && V.filepath !== "" && ge.uint32(10).string(V.filepath), V.disableManifest === !0 && ge.uint32(40).bool(V.disableManifest), V.s3 !== void 0 && a.S3Upload.encode(V.s3, ge.uint32(18).fork()).ldelim(), V.gcp !== void 0 && a.GCPUpload.encode(V.gcp, ge.uint32(26).fork()).ldelim(), V.azure !== void 0 && a.AzureBlobUpload.encode(V.azure, ge.uint32(34).fork()).ldelim(), V.aliOSS !== void 0 && a.AliOSSUpload.encode(V.aliOSS, ge.uint32(50).fork()).ldelim(), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = Y();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.filepath = Te.string();
            break;
          case 5:
            Re.disableManifest = Te.bool();
            break;
          case 2:
            Re.s3 = a.S3Upload.decode(Te, Te.uint32());
            break;
          case 3:
            Re.gcp = a.GCPUpload.decode(Te, Te.uint32());
            break;
          case 4:
            Re.azure = a.AzureBlobUpload.decode(Te, Te.uint32());
            break;
          case 6:
            Re.aliOSS = a.AliOSSUpload.decode(Te, Te.uint32());
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        filepath: Ge(V.filepath) ? String(V.filepath) : "",
        disableManifest: Ge(V.disableManifest) ? !!V.disableManifest : !1,
        s3: Ge(V.s3) ? a.S3Upload.fromJSON(V.s3) : void 0,
        gcp: Ge(V.gcp) ? a.GCPUpload.fromJSON(V.gcp) : void 0,
        azure: Ge(V.azure) ? a.AzureBlobUpload.fromJSON(V.azure) : void 0,
        aliOSS: Ge(V.aliOSS) ? a.AliOSSUpload.fromJSON(V.aliOSS) : void 0
      };
    },
    toJSON(V) {
      const ge = {};
      return V.filepath !== void 0 && (ge.filepath = V.filepath), V.disableManifest !== void 0 && (ge.disableManifest = V.disableManifest), V.s3 !== void 0 && (ge.s3 = V.s3 ? a.S3Upload.toJSON(V.s3) : void 0), V.gcp !== void 0 && (ge.gcp = V.gcp ? a.GCPUpload.toJSON(V.gcp) : void 0), V.azure !== void 0 && (ge.azure = V.azure ? a.AzureBlobUpload.toJSON(V.azure) : void 0), V.aliOSS !== void 0 && (ge.aliOSS = V.aliOSS ? a.AliOSSUpload.toJSON(V.aliOSS) : void 0), ge;
    },
    fromPartial(V) {
      var ge, Te;
      const We = Y();
      return We.filepath = (ge = V.filepath) !== null && ge !== void 0 ? ge : "", We.disableManifest = (Te = V.disableManifest) !== null && Te !== void 0 ? Te : !1, We.s3 = V.s3 !== void 0 && V.s3 !== null ? a.S3Upload.fromPartial(V.s3) : void 0, We.gcp = V.gcp !== void 0 && V.gcp !== null ? a.GCPUpload.fromPartial(V.gcp) : void 0, We.azure = V.azure !== void 0 && V.azure !== null ? a.AzureBlobUpload.fromPartial(V.azure) : void 0, We.aliOSS = V.aliOSS !== void 0 && V.aliOSS !== null ? a.AliOSSUpload.fromPartial(V.aliOSS) : void 0, We;
    }
  };
  function B() {
    return {
      accessKey: "",
      secret: "",
      region: "",
      endpoint: "",
      bucket: "",
      forcePathStyle: !1,
      metadata: {},
      tagging: ""
    };
  }
  a.S3Upload = {
    encode(V, ge = l.default.Writer.create()) {
      return V.accessKey !== void 0 && V.accessKey !== "" && ge.uint32(10).string(V.accessKey), V.secret !== void 0 && V.secret !== "" && ge.uint32(18).string(V.secret), V.region !== void 0 && V.region !== "" && ge.uint32(26).string(V.region), V.endpoint !== void 0 && V.endpoint !== "" && ge.uint32(34).string(V.endpoint), V.bucket !== void 0 && V.bucket !== "" && ge.uint32(42).string(V.bucket), V.forcePathStyle === !0 && ge.uint32(48).bool(V.forcePathStyle), Object.entries(V.metadata || {}).forEach(([Te, We]) => {
        a.S3Upload_MetadataEntry.encode({ key: Te, value: We }, ge.uint32(58).fork()).ldelim();
      }), V.tagging !== void 0 && V.tagging !== "" && ge.uint32(66).string(V.tagging), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = B();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.accessKey = Te.string();
            break;
          case 2:
            Re.secret = Te.string();
            break;
          case 3:
            Re.region = Te.string();
            break;
          case 4:
            Re.endpoint = Te.string();
            break;
          case 5:
            Re.bucket = Te.string();
            break;
          case 6:
            Re.forcePathStyle = Te.bool();
            break;
          case 7:
            const Ee = a.S3Upload_MetadataEntry.decode(Te, Te.uint32());
            Ee.value !== void 0 && (Re.metadata[Ee.key] = Ee.value);
            break;
          case 8:
            Re.tagging = Te.string();
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        accessKey: Ge(V.accessKey) ? String(V.accessKey) : "",
        secret: Ge(V.secret) ? String(V.secret) : "",
        region: Ge(V.region) ? String(V.region) : "",
        endpoint: Ge(V.endpoint) ? String(V.endpoint) : "",
        bucket: Ge(V.bucket) ? String(V.bucket) : "",
        forcePathStyle: Ge(V.forcePathStyle) ? !!V.forcePathStyle : !1,
        metadata: Xe(V.metadata) ? Object.entries(V.metadata).reduce((ge, [Te, We]) => (ge[Te] = String(We), ge), {}) : {},
        tagging: Ge(V.tagging) ? String(V.tagging) : ""
      };
    },
    toJSON(V) {
      const ge = {};
      return V.accessKey !== void 0 && (ge.accessKey = V.accessKey), V.secret !== void 0 && (ge.secret = V.secret), V.region !== void 0 && (ge.region = V.region), V.endpoint !== void 0 && (ge.endpoint = V.endpoint), V.bucket !== void 0 && (ge.bucket = V.bucket), V.forcePathStyle !== void 0 && (ge.forcePathStyle = V.forcePathStyle), ge.metadata = {}, V.metadata && Object.entries(V.metadata).forEach(([Te, We]) => {
        ge.metadata[Te] = We;
      }), V.tagging !== void 0 && (ge.tagging = V.tagging), ge;
    },
    fromPartial(V) {
      var ge, Te, We, Re, J, Ee, ue, ce;
      const ve = B();
      return ve.accessKey = (ge = V.accessKey) !== null && ge !== void 0 ? ge : "", ve.secret = (Te = V.secret) !== null && Te !== void 0 ? Te : "", ve.region = (We = V.region) !== null && We !== void 0 ? We : "", ve.endpoint = (Re = V.endpoint) !== null && Re !== void 0 ? Re : "", ve.bucket = (J = V.bucket) !== null && J !== void 0 ? J : "", ve.forcePathStyle = (Ee = V.forcePathStyle) !== null && Ee !== void 0 ? Ee : !1, ve.metadata = Object.entries((ue = V.metadata) !== null && ue !== void 0 ? ue : {}).reduce((Ce, [Be, He]) => (He !== void 0 && (Ce[Be] = String(He)), Ce), {}), ve.tagging = (ce = V.tagging) !== null && ce !== void 0 ? ce : "", ve;
    }
  };
  function T() {
    return { key: "", value: "" };
  }
  a.S3Upload_MetadataEntry = {
    encode(V, ge = l.default.Writer.create()) {
      return V.key !== "" && ge.uint32(10).string(V.key), V.value !== "" && ge.uint32(18).string(V.value), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = T();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.key = Te.string();
            break;
          case 2:
            Re.value = Te.string();
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return { key: Ge(V.key) ? String(V.key) : "", value: Ge(V.value) ? String(V.value) : "" };
    },
    toJSON(V) {
      const ge = {};
      return V.key !== void 0 && (ge.key = V.key), V.value !== void 0 && (ge.value = V.value), ge;
    },
    fromPartial(V) {
      var ge, Te;
      const We = T();
      return We.key = (ge = V.key) !== null && ge !== void 0 ? ge : "", We.value = (Te = V.value) !== null && Te !== void 0 ? Te : "", We;
    }
  };
  function D() {
    return { credentials: new Uint8Array(), bucket: "" };
  }
  a.GCPUpload = {
    encode(V, ge = l.default.Writer.create()) {
      return V.credentials !== void 0 && V.credentials.length !== 0 && ge.uint32(10).bytes(V.credentials), V.bucket !== void 0 && V.bucket !== "" && ge.uint32(18).string(V.bucket), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = D();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.credentials = Te.bytes();
            break;
          case 2:
            Re.bucket = Te.string();
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        credentials: Ge(V.credentials) ? je(V.credentials) : new Uint8Array(),
        bucket: Ge(V.bucket) ? String(V.bucket) : ""
      };
    },
    toJSON(V) {
      const ge = {};
      return V.credentials !== void 0 && (ge.credentials = Fe(V.credentials !== void 0 ? V.credentials : new Uint8Array())), V.bucket !== void 0 && (ge.bucket = V.bucket), ge;
    },
    fromPartial(V) {
      var ge, Te;
      const We = D();
      return We.credentials = (ge = V.credentials) !== null && ge !== void 0 ? ge : new Uint8Array(), We.bucket = (Te = V.bucket) !== null && Te !== void 0 ? Te : "", We;
    }
  };
  function te() {
    return { accountName: "", accountKey: "", containerName: "" };
  }
  a.AzureBlobUpload = {
    encode(V, ge = l.default.Writer.create()) {
      return V.accountName !== void 0 && V.accountName !== "" && ge.uint32(10).string(V.accountName), V.accountKey !== void 0 && V.accountKey !== "" && ge.uint32(18).string(V.accountKey), V.containerName !== void 0 && V.containerName !== "" && ge.uint32(26).string(V.containerName), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = te();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.accountName = Te.string();
            break;
          case 2:
            Re.accountKey = Te.string();
            break;
          case 3:
            Re.containerName = Te.string();
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        accountName: Ge(V.accountName) ? String(V.accountName) : "",
        accountKey: Ge(V.accountKey) ? String(V.accountKey) : "",
        containerName: Ge(V.containerName) ? String(V.containerName) : ""
      };
    },
    toJSON(V) {
      const ge = {};
      return V.accountName !== void 0 && (ge.accountName = V.accountName), V.accountKey !== void 0 && (ge.accountKey = V.accountKey), V.containerName !== void 0 && (ge.containerName = V.containerName), ge;
    },
    fromPartial(V) {
      var ge, Te, We;
      const Re = te();
      return Re.accountName = (ge = V.accountName) !== null && ge !== void 0 ? ge : "", Re.accountKey = (Te = V.accountKey) !== null && Te !== void 0 ? Te : "", Re.containerName = (We = V.containerName) !== null && We !== void 0 ? We : "", Re;
    }
  };
  function me() {
    return { accessKey: "", secret: "", region: "", endpoint: "", bucket: "" };
  }
  a.AliOSSUpload = {
    encode(V, ge = l.default.Writer.create()) {
      return V.accessKey !== void 0 && V.accessKey !== "" && ge.uint32(10).string(V.accessKey), V.secret !== void 0 && V.secret !== "" && ge.uint32(18).string(V.secret), V.region !== void 0 && V.region !== "" && ge.uint32(26).string(V.region), V.endpoint !== void 0 && V.endpoint !== "" && ge.uint32(34).string(V.endpoint), V.bucket !== void 0 && V.bucket !== "" && ge.uint32(42).string(V.bucket), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = me();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.accessKey = Te.string();
            break;
          case 2:
            Re.secret = Te.string();
            break;
          case 3:
            Re.region = Te.string();
            break;
          case 4:
            Re.endpoint = Te.string();
            break;
          case 5:
            Re.bucket = Te.string();
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        accessKey: Ge(V.accessKey) ? String(V.accessKey) : "",
        secret: Ge(V.secret) ? String(V.secret) : "",
        region: Ge(V.region) ? String(V.region) : "",
        endpoint: Ge(V.endpoint) ? String(V.endpoint) : "",
        bucket: Ge(V.bucket) ? String(V.bucket) : ""
      };
    },
    toJSON(V) {
      const ge = {};
      return V.accessKey !== void 0 && (ge.accessKey = V.accessKey), V.secret !== void 0 && (ge.secret = V.secret), V.region !== void 0 && (ge.region = V.region), V.endpoint !== void 0 && (ge.endpoint = V.endpoint), V.bucket !== void 0 && (ge.bucket = V.bucket), ge;
    },
    fromPartial(V) {
      var ge, Te, We, Re, J;
      const Ee = me();
      return Ee.accessKey = (ge = V.accessKey) !== null && ge !== void 0 ? ge : "", Ee.secret = (Te = V.secret) !== null && Te !== void 0 ? Te : "", Ee.region = (We = V.region) !== null && We !== void 0 ? We : "", Ee.endpoint = (Re = V.endpoint) !== null && Re !== void 0 ? Re : "", Ee.bucket = (J = V.bucket) !== null && J !== void 0 ? J : "", Ee;
    }
  };
  function Ie() {
    return { protocol: 0, urls: [] };
  }
  a.StreamOutput = {
    encode(V, ge = l.default.Writer.create()) {
      if (V.protocol !== void 0 && V.protocol !== 0 && ge.uint32(8).int32(V.protocol), V.urls !== void 0 && V.urls.length !== 0)
        for (const Te of V.urls)
          ge.uint32(18).string(Te);
      return ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = Ie();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.protocol = Te.int32();
            break;
          case 2:
            Re.urls.push(Te.string());
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        protocol: Ge(V.protocol) ? P(V.protocol) : 0,
        urls: Array.isArray(V == null ? void 0 : V.urls) ? V.urls.map((ge) => String(ge)) : []
      };
    },
    toJSON(V) {
      const ge = {};
      return V.protocol !== void 0 && (ge.protocol = $(V.protocol)), V.urls ? ge.urls = V.urls.map((Te) => Te) : ge.urls = [], ge;
    },
    fromPartial(V) {
      var ge, Te;
      const We = Ie();
      return We.protocol = (ge = V.protocol) !== null && ge !== void 0 ? ge : 0, We.urls = ((Te = V.urls) === null || Te === void 0 ? void 0 : Te.map((Re) => Re)) || [], We;
    }
  };
  function $e() {
    return {
      width: 0,
      height: 0,
      depth: 0,
      framerate: 0,
      audioCodec: 0,
      audioBitrate: 0,
      audioFrequency: 0,
      videoCodec: 0,
      videoBitrate: 0
    };
  }
  a.EncodingOptions = {
    encode(V, ge = l.default.Writer.create()) {
      return V.width !== void 0 && V.width !== 0 && ge.uint32(8).int32(V.width), V.height !== void 0 && V.height !== 0 && ge.uint32(16).int32(V.height), V.depth !== void 0 && V.depth !== 0 && ge.uint32(24).int32(V.depth), V.framerate !== void 0 && V.framerate !== 0 && ge.uint32(32).int32(V.framerate), V.audioCodec !== void 0 && V.audioCodec !== 0 && ge.uint32(40).int32(V.audioCodec), V.audioBitrate !== void 0 && V.audioBitrate !== 0 && ge.uint32(48).int32(V.audioBitrate), V.audioFrequency !== void 0 && V.audioFrequency !== 0 && ge.uint32(56).int32(V.audioFrequency), V.videoCodec !== void 0 && V.videoCodec !== 0 && ge.uint32(64).int32(V.videoCodec), V.videoBitrate !== void 0 && V.videoBitrate !== 0 && ge.uint32(72).int32(V.videoBitrate), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = $e();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.width = Te.int32();
            break;
          case 2:
            Re.height = Te.int32();
            break;
          case 3:
            Re.depth = Te.int32();
            break;
          case 4:
            Re.framerate = Te.int32();
            break;
          case 5:
            Re.audioCodec = Te.int32();
            break;
          case 6:
            Re.audioBitrate = Te.int32();
            break;
          case 7:
            Re.audioFrequency = Te.int32();
            break;
          case 8:
            Re.videoCodec = Te.int32();
            break;
          case 9:
            Re.videoBitrate = Te.int32();
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        width: Ge(V.width) ? Number(V.width) : 0,
        height: Ge(V.height) ? Number(V.height) : 0,
        depth: Ge(V.depth) ? Number(V.depth) : 0,
        framerate: Ge(V.framerate) ? Number(V.framerate) : 0,
        audioCodec: Ge(V.audioCodec) ? X(V.audioCodec) : 0,
        audioBitrate: Ge(V.audioBitrate) ? Number(V.audioBitrate) : 0,
        audioFrequency: Ge(V.audioFrequency) ? Number(V.audioFrequency) : 0,
        videoCodec: Ge(V.videoCodec) ? ne(V.videoCodec) : 0,
        videoBitrate: Ge(V.videoBitrate) ? Number(V.videoBitrate) : 0
      };
    },
    toJSON(V) {
      const ge = {};
      return V.width !== void 0 && (ge.width = Math.round(V.width)), V.height !== void 0 && (ge.height = Math.round(V.height)), V.depth !== void 0 && (ge.depth = Math.round(V.depth)), V.framerate !== void 0 && (ge.framerate = Math.round(V.framerate)), V.audioCodec !== void 0 && (ge.audioCodec = ie(V.audioCodec)), V.audioBitrate !== void 0 && (ge.audioBitrate = Math.round(V.audioBitrate)), V.audioFrequency !== void 0 && (ge.audioFrequency = Math.round(V.audioFrequency)), V.videoCodec !== void 0 && (ge.videoCodec = Z(V.videoCodec)), V.videoBitrate !== void 0 && (ge.videoBitrate = Math.round(V.videoBitrate)), ge;
    },
    fromPartial(V) {
      var ge, Te, We, Re, J, Ee, ue, ce, ve;
      const Ce = $e();
      return Ce.width = (ge = V.width) !== null && ge !== void 0 ? ge : 0, Ce.height = (Te = V.height) !== null && Te !== void 0 ? Te : 0, Ce.depth = (We = V.depth) !== null && We !== void 0 ? We : 0, Ce.framerate = (Re = V.framerate) !== null && Re !== void 0 ? Re : 0, Ce.audioCodec = (J = V.audioCodec) !== null && J !== void 0 ? J : 0, Ce.audioBitrate = (Ee = V.audioBitrate) !== null && Ee !== void 0 ? Ee : 0, Ce.audioFrequency = (ue = V.audioFrequency) !== null && ue !== void 0 ? ue : 0, Ce.videoCodec = (ce = V.videoCodec) !== null && ce !== void 0 ? ce : 0, Ce.videoBitrate = (ve = V.videoBitrate) !== null && ve !== void 0 ? ve : 0, Ce;
    }
  };
  function ye() {
    return { egressId: "", layout: "" };
  }
  a.UpdateLayoutRequest = {
    encode(V, ge = l.default.Writer.create()) {
      return V.egressId !== void 0 && V.egressId !== "" && ge.uint32(10).string(V.egressId), V.layout !== void 0 && V.layout !== "" && ge.uint32(18).string(V.layout), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = ye();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.egressId = Te.string();
            break;
          case 2:
            Re.layout = Te.string();
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        egressId: Ge(V.egressId) ? String(V.egressId) : "",
        layout: Ge(V.layout) ? String(V.layout) : ""
      };
    },
    toJSON(V) {
      const ge = {};
      return V.egressId !== void 0 && (ge.egressId = V.egressId), V.layout !== void 0 && (ge.layout = V.layout), ge;
    },
    fromPartial(V) {
      var ge, Te;
      const We = ye();
      return We.egressId = (ge = V.egressId) !== null && ge !== void 0 ? ge : "", We.layout = (Te = V.layout) !== null && Te !== void 0 ? Te : "", We;
    }
  };
  function fe() {
    return { egressId: "", addOutputUrls: [], removeOutputUrls: [] };
  }
  a.UpdateStreamRequest = {
    encode(V, ge = l.default.Writer.create()) {
      if (V.egressId !== void 0 && V.egressId !== "" && ge.uint32(10).string(V.egressId), V.addOutputUrls !== void 0 && V.addOutputUrls.length !== 0)
        for (const Te of V.addOutputUrls)
          ge.uint32(18).string(Te);
      if (V.removeOutputUrls !== void 0 && V.removeOutputUrls.length !== 0)
        for (const Te of V.removeOutputUrls)
          ge.uint32(26).string(Te);
      return ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = fe();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.egressId = Te.string();
            break;
          case 2:
            Re.addOutputUrls.push(Te.string());
            break;
          case 3:
            Re.removeOutputUrls.push(Te.string());
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        egressId: Ge(V.egressId) ? String(V.egressId) : "",
        addOutputUrls: Array.isArray(V == null ? void 0 : V.addOutputUrls) ? V.addOutputUrls.map((ge) => String(ge)) : [],
        removeOutputUrls: Array.isArray(V == null ? void 0 : V.removeOutputUrls) ? V.removeOutputUrls.map((ge) => String(ge)) : []
      };
    },
    toJSON(V) {
      const ge = {};
      return V.egressId !== void 0 && (ge.egressId = V.egressId), V.addOutputUrls ? ge.addOutputUrls = V.addOutputUrls.map((Te) => Te) : ge.addOutputUrls = [], V.removeOutputUrls ? ge.removeOutputUrls = V.removeOutputUrls.map((Te) => Te) : ge.removeOutputUrls = [], ge;
    },
    fromPartial(V) {
      var ge, Te, We;
      const Re = fe();
      return Re.egressId = (ge = V.egressId) !== null && ge !== void 0 ? ge : "", Re.addOutputUrls = ((Te = V.addOutputUrls) === null || Te === void 0 ? void 0 : Te.map((J) => J)) || [], Re.removeOutputUrls = ((We = V.removeOutputUrls) === null || We === void 0 ? void 0 : We.map((J) => J)) || [], Re;
    }
  };
  function Me() {
    return { roomName: "" };
  }
  a.ListEgressRequest = {
    encode(V, ge = l.default.Writer.create()) {
      return V.roomName !== void 0 && V.roomName !== "" && ge.uint32(10).string(V.roomName), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = Me();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.roomName = Te.string();
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return { roomName: Ge(V.roomName) ? String(V.roomName) : "" };
    },
    toJSON(V) {
      const ge = {};
      return V.roomName !== void 0 && (ge.roomName = V.roomName), ge;
    },
    fromPartial(V) {
      var ge;
      const Te = Me();
      return Te.roomName = (ge = V.roomName) !== null && ge !== void 0 ? ge : "", Te;
    }
  };
  function Ae() {
    return { items: [] };
  }
  a.ListEgressResponse = {
    encode(V, ge = l.default.Writer.create()) {
      if (V.items !== void 0 && V.items.length !== 0)
        for (const Te of V.items)
          a.EgressInfo.encode(Te, ge.uint32(10).fork()).ldelim();
      return ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = Ae();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.items.push(a.EgressInfo.decode(Te, Te.uint32()));
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return { items: Array.isArray(V == null ? void 0 : V.items) ? V.items.map((ge) => a.EgressInfo.fromJSON(ge)) : [] };
    },
    toJSON(V) {
      const ge = {};
      return V.items ? ge.items = V.items.map((Te) => Te ? a.EgressInfo.toJSON(Te) : void 0) : ge.items = [], ge;
    },
    fromPartial(V) {
      var ge;
      const Te = Ae();
      return Te.items = ((ge = V.items) === null || ge === void 0 ? void 0 : ge.map((We) => a.EgressInfo.fromPartial(We))) || [], Te;
    }
  };
  function xe() {
    return { egressId: "" };
  }
  a.StopEgressRequest = {
    encode(V, ge = l.default.Writer.create()) {
      return V.egressId !== void 0 && V.egressId !== "" && ge.uint32(10).string(V.egressId), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = xe();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.egressId = Te.string();
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return { egressId: Ge(V.egressId) ? String(V.egressId) : "" };
    },
    toJSON(V) {
      const ge = {};
      return V.egressId !== void 0 && (ge.egressId = V.egressId), ge;
    },
    fromPartial(V) {
      var ge;
      const Te = xe();
      return Te.egressId = (ge = V.egressId) !== null && ge !== void 0 ? ge : "", Te;
    }
  };
  function ae() {
    return {
      egressId: "",
      roomId: "",
      roomName: "",
      status: 0,
      startedAt: 0,
      endedAt: 0,
      error: "",
      roomComposite: void 0,
      trackComposite: void 0,
      track: void 0,
      web: void 0,
      stream: void 0,
      file: void 0,
      segments: void 0
    };
  }
  a.EgressInfo = {
    encode(V, ge = l.default.Writer.create()) {
      return V.egressId !== void 0 && V.egressId !== "" && ge.uint32(10).string(V.egressId), V.roomId !== void 0 && V.roomId !== "" && ge.uint32(18).string(V.roomId), V.roomName !== void 0 && V.roomName !== "" && ge.uint32(106).string(V.roomName), V.status !== void 0 && V.status !== 0 && ge.uint32(24).int32(V.status), V.startedAt !== void 0 && V.startedAt !== 0 && ge.uint32(80).int64(V.startedAt), V.endedAt !== void 0 && V.endedAt !== 0 && ge.uint32(88).int64(V.endedAt), V.error !== void 0 && V.error !== "" && ge.uint32(74).string(V.error), V.roomComposite !== void 0 && a.RoomCompositeEgressRequest.encode(V.roomComposite, ge.uint32(34).fork()).ldelim(), V.trackComposite !== void 0 && a.TrackCompositeEgressRequest.encode(V.trackComposite, ge.uint32(42).fork()).ldelim(), V.track !== void 0 && a.TrackEgressRequest.encode(V.track, ge.uint32(50).fork()).ldelim(), V.web !== void 0 && a.WebEgressRequest.encode(V.web, ge.uint32(114).fork()).ldelim(), V.stream !== void 0 && a.StreamInfoList.encode(V.stream, ge.uint32(58).fork()).ldelim(), V.file !== void 0 && a.FileInfo.encode(V.file, ge.uint32(66).fork()).ldelim(), V.segments !== void 0 && a.SegmentsInfo.encode(V.segments, ge.uint32(98).fork()).ldelim(), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = ae();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.egressId = Te.string();
            break;
          case 2:
            Re.roomId = Te.string();
            break;
          case 13:
            Re.roomName = Te.string();
            break;
          case 3:
            Re.status = Te.int32();
            break;
          case 10:
            Re.startedAt = yt(Te.int64());
            break;
          case 11:
            Re.endedAt = yt(Te.int64());
            break;
          case 9:
            Re.error = Te.string();
            break;
          case 4:
            Re.roomComposite = a.RoomCompositeEgressRequest.decode(Te, Te.uint32());
            break;
          case 5:
            Re.trackComposite = a.TrackCompositeEgressRequest.decode(Te, Te.uint32());
            break;
          case 6:
            Re.track = a.TrackEgressRequest.decode(Te, Te.uint32());
            break;
          case 14:
            Re.web = a.WebEgressRequest.decode(Te, Te.uint32());
            break;
          case 7:
            Re.stream = a.StreamInfoList.decode(Te, Te.uint32());
            break;
          case 8:
            Re.file = a.FileInfo.decode(Te, Te.uint32());
            break;
          case 12:
            Re.segments = a.SegmentsInfo.decode(Te, Te.uint32());
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        egressId: Ge(V.egressId) ? String(V.egressId) : "",
        roomId: Ge(V.roomId) ? String(V.roomId) : "",
        roomName: Ge(V.roomName) ? String(V.roomName) : "",
        status: Ge(V.status) ? ke(V.status) : 0,
        startedAt: Ge(V.startedAt) ? Number(V.startedAt) : 0,
        endedAt: Ge(V.endedAt) ? Number(V.endedAt) : 0,
        error: Ge(V.error) ? String(V.error) : "",
        roomComposite: Ge(V.roomComposite) ? a.RoomCompositeEgressRequest.fromJSON(V.roomComposite) : void 0,
        trackComposite: Ge(V.trackComposite) ? a.TrackCompositeEgressRequest.fromJSON(V.trackComposite) : void 0,
        track: Ge(V.track) ? a.TrackEgressRequest.fromJSON(V.track) : void 0,
        web: Ge(V.web) ? a.WebEgressRequest.fromJSON(V.web) : void 0,
        stream: Ge(V.stream) ? a.StreamInfoList.fromJSON(V.stream) : void 0,
        file: Ge(V.file) ? a.FileInfo.fromJSON(V.file) : void 0,
        segments: Ge(V.segments) ? a.SegmentsInfo.fromJSON(V.segments) : void 0
      };
    },
    toJSON(V) {
      const ge = {};
      return V.egressId !== void 0 && (ge.egressId = V.egressId), V.roomId !== void 0 && (ge.roomId = V.roomId), V.roomName !== void 0 && (ge.roomName = V.roomName), V.status !== void 0 && (ge.status = _e(V.status)), V.startedAt !== void 0 && (ge.startedAt = Math.round(V.startedAt)), V.endedAt !== void 0 && (ge.endedAt = Math.round(V.endedAt)), V.error !== void 0 && (ge.error = V.error), V.roomComposite !== void 0 && (ge.roomComposite = V.roomComposite ? a.RoomCompositeEgressRequest.toJSON(V.roomComposite) : void 0), V.trackComposite !== void 0 && (ge.trackComposite = V.trackComposite ? a.TrackCompositeEgressRequest.toJSON(V.trackComposite) : void 0), V.track !== void 0 && (ge.track = V.track ? a.TrackEgressRequest.toJSON(V.track) : void 0), V.web !== void 0 && (ge.web = V.web ? a.WebEgressRequest.toJSON(V.web) : void 0), V.stream !== void 0 && (ge.stream = V.stream ? a.StreamInfoList.toJSON(V.stream) : void 0), V.file !== void 0 && (ge.file = V.file ? a.FileInfo.toJSON(V.file) : void 0), V.segments !== void 0 && (ge.segments = V.segments ? a.SegmentsInfo.toJSON(V.segments) : void 0), ge;
    },
    fromPartial(V) {
      var ge, Te, We, Re, J, Ee, ue;
      const ce = ae();
      return ce.egressId = (ge = V.egressId) !== null && ge !== void 0 ? ge : "", ce.roomId = (Te = V.roomId) !== null && Te !== void 0 ? Te : "", ce.roomName = (We = V.roomName) !== null && We !== void 0 ? We : "", ce.status = (Re = V.status) !== null && Re !== void 0 ? Re : 0, ce.startedAt = (J = V.startedAt) !== null && J !== void 0 ? J : 0, ce.endedAt = (Ee = V.endedAt) !== null && Ee !== void 0 ? Ee : 0, ce.error = (ue = V.error) !== null && ue !== void 0 ? ue : "", ce.roomComposite = V.roomComposite !== void 0 && V.roomComposite !== null ? a.RoomCompositeEgressRequest.fromPartial(V.roomComposite) : void 0, ce.trackComposite = V.trackComposite !== void 0 && V.trackComposite !== null ? a.TrackCompositeEgressRequest.fromPartial(V.trackComposite) : void 0, ce.track = V.track !== void 0 && V.track !== null ? a.TrackEgressRequest.fromPartial(V.track) : void 0, ce.web = V.web !== void 0 && V.web !== null ? a.WebEgressRequest.fromPartial(V.web) : void 0, ce.stream = V.stream !== void 0 && V.stream !== null ? a.StreamInfoList.fromPartial(V.stream) : void 0, ce.file = V.file !== void 0 && V.file !== null ? a.FileInfo.fromPartial(V.file) : void 0, ce.segments = V.segments !== void 0 && V.segments !== null ? a.SegmentsInfo.fromPartial(V.segments) : void 0, ce;
    }
  };
  function N() {
    return { info: [] };
  }
  a.StreamInfoList = {
    encode(V, ge = l.default.Writer.create()) {
      if (V.info !== void 0 && V.info.length !== 0)
        for (const Te of V.info)
          a.StreamInfo.encode(Te, ge.uint32(10).fork()).ldelim();
      return ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = N();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.info.push(a.StreamInfo.decode(Te, Te.uint32()));
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return { info: Array.isArray(V == null ? void 0 : V.info) ? V.info.map((ge) => a.StreamInfo.fromJSON(ge)) : [] };
    },
    toJSON(V) {
      const ge = {};
      return V.info ? ge.info = V.info.map((Te) => Te ? a.StreamInfo.toJSON(Te) : void 0) : ge.info = [], ge;
    },
    fromPartial(V) {
      var ge;
      const Te = N();
      return Te.info = ((ge = V.info) === null || ge === void 0 ? void 0 : ge.map((We) => a.StreamInfo.fromPartial(We))) || [], Te;
    }
  };
  function re() {
    return { url: "", startedAt: 0, endedAt: 0, duration: 0, status: 0 };
  }
  a.StreamInfo = {
    encode(V, ge = l.default.Writer.create()) {
      return V.url !== void 0 && V.url !== "" && ge.uint32(10).string(V.url), V.startedAt !== void 0 && V.startedAt !== 0 && ge.uint32(16).int64(V.startedAt), V.endedAt !== void 0 && V.endedAt !== 0 && ge.uint32(24).int64(V.endedAt), V.duration !== void 0 && V.duration !== 0 && ge.uint32(32).int64(V.duration), V.status !== void 0 && V.status !== 0 && ge.uint32(40).int32(V.status), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = re();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.url = Te.string();
            break;
          case 2:
            Re.startedAt = yt(Te.int64());
            break;
          case 3:
            Re.endedAt = yt(Te.int64());
            break;
          case 4:
            Re.duration = yt(Te.int64());
            break;
          case 5:
            Re.status = Te.int32();
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        url: Ge(V.url) ? String(V.url) : "",
        startedAt: Ge(V.startedAt) ? Number(V.startedAt) : 0,
        endedAt: Ge(V.endedAt) ? Number(V.endedAt) : 0,
        duration: Ge(V.duration) ? Number(V.duration) : 0,
        status: Ge(V.status) ? z(V.status) : 0
      };
    },
    toJSON(V) {
      const ge = {};
      return V.url !== void 0 && (ge.url = V.url), V.startedAt !== void 0 && (ge.startedAt = Math.round(V.startedAt)), V.endedAt !== void 0 && (ge.endedAt = Math.round(V.endedAt)), V.duration !== void 0 && (ge.duration = Math.round(V.duration)), V.status !== void 0 && (ge.status = C(V.status)), ge;
    },
    fromPartial(V) {
      var ge, Te, We, Re, J;
      const Ee = re();
      return Ee.url = (ge = V.url) !== null && ge !== void 0 ? ge : "", Ee.startedAt = (Te = V.startedAt) !== null && Te !== void 0 ? Te : 0, Ee.endedAt = (We = V.endedAt) !== null && We !== void 0 ? We : 0, Ee.duration = (Re = V.duration) !== null && Re !== void 0 ? Re : 0, Ee.status = (J = V.status) !== null && J !== void 0 ? J : 0, Ee;
    }
  };
  function le() {
    return { filename: "", startedAt: 0, endedAt: 0, duration: 0, size: 0, location: "" };
  }
  a.FileInfo = {
    encode(V, ge = l.default.Writer.create()) {
      return V.filename !== void 0 && V.filename !== "" && ge.uint32(10).string(V.filename), V.startedAt !== void 0 && V.startedAt !== 0 && ge.uint32(16).int64(V.startedAt), V.endedAt !== void 0 && V.endedAt !== 0 && ge.uint32(24).int64(V.endedAt), V.duration !== void 0 && V.duration !== 0 && ge.uint32(48).int64(V.duration), V.size !== void 0 && V.size !== 0 && ge.uint32(32).int64(V.size), V.location !== void 0 && V.location !== "" && ge.uint32(42).string(V.location), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = le();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.filename = Te.string();
            break;
          case 2:
            Re.startedAt = yt(Te.int64());
            break;
          case 3:
            Re.endedAt = yt(Te.int64());
            break;
          case 6:
            Re.duration = yt(Te.int64());
            break;
          case 4:
            Re.size = yt(Te.int64());
            break;
          case 5:
            Re.location = Te.string();
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        filename: Ge(V.filename) ? String(V.filename) : "",
        startedAt: Ge(V.startedAt) ? Number(V.startedAt) : 0,
        endedAt: Ge(V.endedAt) ? Number(V.endedAt) : 0,
        duration: Ge(V.duration) ? Number(V.duration) : 0,
        size: Ge(V.size) ? Number(V.size) : 0,
        location: Ge(V.location) ? String(V.location) : ""
      };
    },
    toJSON(V) {
      const ge = {};
      return V.filename !== void 0 && (ge.filename = V.filename), V.startedAt !== void 0 && (ge.startedAt = Math.round(V.startedAt)), V.endedAt !== void 0 && (ge.endedAt = Math.round(V.endedAt)), V.duration !== void 0 && (ge.duration = Math.round(V.duration)), V.size !== void 0 && (ge.size = Math.round(V.size)), V.location !== void 0 && (ge.location = V.location), ge;
    },
    fromPartial(V) {
      var ge, Te, We, Re, J, Ee;
      const ue = le();
      return ue.filename = (ge = V.filename) !== null && ge !== void 0 ? ge : "", ue.startedAt = (Te = V.startedAt) !== null && Te !== void 0 ? Te : 0, ue.endedAt = (We = V.endedAt) !== null && We !== void 0 ? We : 0, ue.duration = (Re = V.duration) !== null && Re !== void 0 ? Re : 0, ue.size = (J = V.size) !== null && J !== void 0 ? J : 0, ue.location = (Ee = V.location) !== null && Ee !== void 0 ? Ee : "", ue;
    }
  };
  function Ne() {
    return { playlistName: "", duration: 0, size: 0, playlistLocation: "", segmentCount: 0, startedAt: 0, endedAt: 0 };
  }
  a.SegmentsInfo = {
    encode(V, ge = l.default.Writer.create()) {
      return V.playlistName !== void 0 && V.playlistName !== "" && ge.uint32(10).string(V.playlistName), V.duration !== void 0 && V.duration !== 0 && ge.uint32(16).int64(V.duration), V.size !== void 0 && V.size !== 0 && ge.uint32(24).int64(V.size), V.playlistLocation !== void 0 && V.playlistLocation !== "" && ge.uint32(34).string(V.playlistLocation), V.segmentCount !== void 0 && V.segmentCount !== 0 && ge.uint32(40).int64(V.segmentCount), V.startedAt !== void 0 && V.startedAt !== 0 && ge.uint32(48).int64(V.startedAt), V.endedAt !== void 0 && V.endedAt !== 0 && ge.uint32(56).int64(V.endedAt), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = Ne();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.playlistName = Te.string();
            break;
          case 2:
            Re.duration = yt(Te.int64());
            break;
          case 3:
            Re.size = yt(Te.int64());
            break;
          case 4:
            Re.playlistLocation = Te.string();
            break;
          case 5:
            Re.segmentCount = yt(Te.int64());
            break;
          case 6:
            Re.startedAt = yt(Te.int64());
            break;
          case 7:
            Re.endedAt = yt(Te.int64());
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        playlistName: Ge(V.playlistName) ? String(V.playlistName) : "",
        duration: Ge(V.duration) ? Number(V.duration) : 0,
        size: Ge(V.size) ? Number(V.size) : 0,
        playlistLocation: Ge(V.playlistLocation) ? String(V.playlistLocation) : "",
        segmentCount: Ge(V.segmentCount) ? Number(V.segmentCount) : 0,
        startedAt: Ge(V.startedAt) ? Number(V.startedAt) : 0,
        endedAt: Ge(V.endedAt) ? Number(V.endedAt) : 0
      };
    },
    toJSON(V) {
      const ge = {};
      return V.playlistName !== void 0 && (ge.playlistName = V.playlistName), V.duration !== void 0 && (ge.duration = Math.round(V.duration)), V.size !== void 0 && (ge.size = Math.round(V.size)), V.playlistLocation !== void 0 && (ge.playlistLocation = V.playlistLocation), V.segmentCount !== void 0 && (ge.segmentCount = Math.round(V.segmentCount)), V.startedAt !== void 0 && (ge.startedAt = Math.round(V.startedAt)), V.endedAt !== void 0 && (ge.endedAt = Math.round(V.endedAt)), ge;
    },
    fromPartial(V) {
      var ge, Te, We, Re, J, Ee, ue;
      const ce = Ne();
      return ce.playlistName = (ge = V.playlistName) !== null && ge !== void 0 ? ge : "", ce.duration = (Te = V.duration) !== null && Te !== void 0 ? Te : 0, ce.size = (We = V.size) !== null && We !== void 0 ? We : 0, ce.playlistLocation = (Re = V.playlistLocation) !== null && Re !== void 0 ? Re : "", ce.segmentCount = (J = V.segmentCount) !== null && J !== void 0 ? J : 0, ce.startedAt = (Ee = V.startedAt) !== null && Ee !== void 0 ? Ee : 0, ce.endedAt = (ue = V.endedAt) !== null && ue !== void 0 ? ue : 0, ce;
    }
  };
  function Oe() {
    return { filepath: "", disableManifest: !1, s3: void 0, gcp: void 0, azure: void 0 };
  }
  a.AutoTrackEgress = {
    encode(V, ge = l.default.Writer.create()) {
      return V.filepath !== void 0 && V.filepath !== "" && ge.uint32(10).string(V.filepath), V.disableManifest === !0 && ge.uint32(40).bool(V.disableManifest), V.s3 !== void 0 && a.S3Upload.encode(V.s3, ge.uint32(18).fork()).ldelim(), V.gcp !== void 0 && a.GCPUpload.encode(V.gcp, ge.uint32(26).fork()).ldelim(), V.azure !== void 0 && a.AzureBlobUpload.encode(V.azure, ge.uint32(34).fork()).ldelim(), ge;
    },
    decode(V, ge) {
      const Te = V instanceof l.default.Reader ? V : new l.default.Reader(V);
      let We = ge === void 0 ? Te.len : Te.pos + ge;
      const Re = Oe();
      for (; Te.pos < We; ) {
        const J = Te.uint32();
        switch (J >>> 3) {
          case 1:
            Re.filepath = Te.string();
            break;
          case 5:
            Re.disableManifest = Te.bool();
            break;
          case 2:
            Re.s3 = a.S3Upload.decode(Te, Te.uint32());
            break;
          case 3:
            Re.gcp = a.GCPUpload.decode(Te, Te.uint32());
            break;
          case 4:
            Re.azure = a.AzureBlobUpload.decode(Te, Te.uint32());
            break;
          default:
            Te.skipType(J & 7);
            break;
        }
      }
      return Re;
    },
    fromJSON(V) {
      return {
        filepath: Ge(V.filepath) ? String(V.filepath) : "",
        disableManifest: Ge(V.disableManifest) ? !!V.disableManifest : !1,
        s3: Ge(V.s3) ? a.S3Upload.fromJSON(V.s3) : void 0,
        gcp: Ge(V.gcp) ? a.GCPUpload.fromJSON(V.gcp) : void 0,
        azure: Ge(V.azure) ? a.AzureBlobUpload.fromJSON(V.azure) : void 0
      };
    },
    toJSON(V) {
      const ge = {};
      return V.filepath !== void 0 && (ge.filepath = V.filepath), V.disableManifest !== void 0 && (ge.disableManifest = V.disableManifest), V.s3 !== void 0 && (ge.s3 = V.s3 ? a.S3Upload.toJSON(V.s3) : void 0), V.gcp !== void 0 && (ge.gcp = V.gcp ? a.GCPUpload.toJSON(V.gcp) : void 0), V.azure !== void 0 && (ge.azure = V.azure ? a.AzureBlobUpload.toJSON(V.azure) : void 0), ge;
    },
    fromPartial(V) {
      var ge, Te;
      const We = Oe();
      return We.filepath = (ge = V.filepath) !== null && ge !== void 0 ? ge : "", We.disableManifest = (Te = V.disableManifest) !== null && Te !== void 0 ? Te : !1, We.s3 = V.s3 !== void 0 && V.s3 !== null ? a.S3Upload.fromPartial(V.s3) : void 0, We.gcp = V.gcp !== void 0 && V.gcp !== null ? a.GCPUpload.fromPartial(V.gcp) : void 0, We.azure = V.azure !== void 0 && V.azure !== null ? a.AzureBlobUpload.fromPartial(V.azure) : void 0, We;
    }
  };
  var qe = (() => {
    if (typeof qe < "u")
      return qe;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function je(V) {
    if (qe.Buffer)
      return Uint8Array.from(qe.Buffer.from(V, "base64"));
    {
      const ge = qe.atob(V), Te = new Uint8Array(ge.length);
      for (let We = 0; We < ge.length; ++We)
        Te[We] = ge.charCodeAt(We);
      return Te;
    }
  }
  function Fe(V) {
    if (qe.Buffer)
      return qe.Buffer.from(V).toString("base64");
    {
      const ge = [];
      return V.forEach((Te) => {
        ge.push(String.fromCharCode(Te));
      }), qe.btoa(ge.join(""));
    }
  }
  function yt(V) {
    if (V.gt(Number.MAX_SAFE_INTEGER))
      throw new qe.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return V.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function Xe(V) {
    return typeof V == "object" && V !== null;
  }
  function Ge(V) {
    return V != null;
  }
})(livekit_egress);
var ServiceBase$1 = {};
Object.defineProperty(ServiceBase$1, "__esModule", { value: !0 });
const AccessToken_1$1 = AccessToken$1;
class ServiceBase {
  /**
   * @param apiKey API Key.
   * @param secret API Secret.
   * @param ttl token TTL
   */
  constructor(u, c, l) {
    this.apiKey = u, this.secret = c, this.ttl = l || "10m";
  }
  authHeader(u) {
    const c = new AccessToken_1$1.AccessToken(this.apiKey, this.secret, { ttl: this.ttl });
    return c.addGrant(u), {
      Authorization: `Bearer ${c.toJwt()}`
    };
  }
}
ServiceBase$1.default = ServiceBase;
var TwirpRPC = {}, axios$2 = { exports: {} }, bind$2 = function a(u, c) {
  return function() {
    for (var v = new Array(arguments.length), p = 0; p < v.length; p++)
      v[p] = arguments[p];
    return u.apply(c, v);
  };
}, bind$1 = bind$2, toString = Object.prototype.toString;
function isArray$1(a) {
  return toString.call(a) === "[object Array]";
}
function isUndefined(a) {
  return typeof a > "u";
}
function isBuffer(a) {
  return a !== null && !isUndefined(a) && a.constructor !== null && !isUndefined(a.constructor) && typeof a.constructor.isBuffer == "function" && a.constructor.isBuffer(a);
}
function isArrayBuffer(a) {
  return toString.call(a) === "[object ArrayBuffer]";
}
function isFormData(a) {
  return typeof FormData < "u" && a instanceof FormData;
}
function isArrayBufferView(a) {
  var u;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? u = ArrayBuffer.isView(a) : u = a && a.buffer && a.buffer instanceof ArrayBuffer, u;
}
function isString(a) {
  return typeof a == "string";
}
function isNumber(a) {
  return typeof a == "number";
}
function isObject$2(a) {
  return a !== null && typeof a == "object";
}
function isPlainObject(a) {
  if (toString.call(a) !== "[object Object]")
    return !1;
  var u = Object.getPrototypeOf(a);
  return u === null || u === Object.prototype;
}
function isDate(a) {
  return toString.call(a) === "[object Date]";
}
function isFile(a) {
  return toString.call(a) === "[object File]";
}
function isBlob(a) {
  return toString.call(a) === "[object Blob]";
}
function isFunction(a) {
  return toString.call(a) === "[object Function]";
}
function isStream(a) {
  return isObject$2(a) && isFunction(a.pipe);
}
function isURLSearchParams(a) {
  return typeof URLSearchParams < "u" && a instanceof URLSearchParams;
}
function trim$1(a) {
  return a.trim ? a.trim() : a.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window < "u" && typeof document < "u";
}
function forEach(a, u) {
  if (!(a === null || typeof a > "u"))
    if (typeof a != "object" && (a = [a]), isArray$1(a))
      for (var c = 0, l = a.length; c < l; c++)
        u.call(null, a[c], c, a);
    else
      for (var v in a)
        Object.prototype.hasOwnProperty.call(a, v) && u.call(null, a[v], v, a);
}
function merge() {
  var a = {};
  function u(v, p) {
    isPlainObject(a[p]) && isPlainObject(v) ? a[p] = merge(a[p], v) : isPlainObject(v) ? a[p] = merge({}, v) : isArray$1(v) ? a[p] = v.slice() : a[p] = v;
  }
  for (var c = 0, l = arguments.length; c < l; c++)
    forEach(arguments[c], u);
  return a;
}
function extend(a, u, c) {
  return forEach(u, function(v, p) {
    c && typeof v == "function" ? a[p] = bind$1(v, c) : a[p] = v;
  }), a;
}
function stripBOM(a) {
  return a.charCodeAt(0) === 65279 && (a = a.slice(1)), a;
}
var utils$9 = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isObject: isObject$2,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend,
  trim: trim$1,
  stripBOM
}, utils$8 = utils$9;
function encode(a) {
  return encodeURIComponent(a).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function a(u, c, l) {
  if (!c)
    return u;
  var v;
  if (l)
    v = l(c);
  else if (utils$8.isURLSearchParams(c))
    v = c.toString();
  else {
    var p = [];
    utils$8.forEach(c, function(P, $) {
      P === null || typeof P > "u" || (utils$8.isArray(P) ? $ = $ + "[]" : P = [P], utils$8.forEach(P, function(H) {
        utils$8.isDate(H) ? H = H.toISOString() : utils$8.isObject(H) && (H = JSON.stringify(H)), p.push(encode($) + "=" + encode(H));
      }));
    }), v = p.join("&");
  }
  if (v) {
    var _ = u.indexOf("#");
    _ !== -1 && (u = u.slice(0, _)), u += (u.indexOf("?") === -1 ? "?" : "&") + v;
  }
  return u;
}, utils$7 = utils$9;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function a(u, c, l) {
  return this.handlers.push({
    fulfilled: u,
    rejected: c,
    synchronous: l ? l.synchronous : !1,
    runWhen: l ? l.runWhen : null
  }), this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function a(u) {
  this.handlers[u] && (this.handlers[u] = null);
};
InterceptorManager$1.prototype.forEach = function a(u) {
  utils$7.forEach(this.handlers, function(l) {
    l !== null && u(l);
  });
};
var InterceptorManager_1 = InterceptorManager$1, utils$6 = utils$9, normalizeHeaderName$1 = function a(u, c) {
  utils$6.forEach(u, function(v, p) {
    p !== c && p.toUpperCase() === c.toUpperCase() && (u[c] = v, delete u[p]);
  });
}, enhanceError$1 = function a(u, c, l, v, p) {
  return u.config = c, l && (u.code = l), u.request = v, u.response = p, u.isAxiosError = !0, u.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  }, u;
}, createError, hasRequiredCreateError;
function requireCreateError() {
  if (hasRequiredCreateError)
    return createError;
  hasRequiredCreateError = 1;
  var a = enhanceError$1;
  return createError = function(c, l, v, p, _) {
    var I = new Error(c);
    return a(I, l, v, p, _);
  }, createError;
}
var settle, hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var a = requireCreateError();
  return settle = function(c, l, v) {
    var p = v.config.validateStatus;
    !v.status || !p || p(v.status) ? c(v) : l(a(
      "Request failed with status code " + v.status,
      v.config,
      null,
      v.request,
      v
    ));
  }, settle;
}
var cookies, hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var a = utils$9;
  return cookies = a.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    /* @__PURE__ */ function() {
      return {
        write: function(l, v, p, _, I, P) {
          var $ = [];
          $.push(l + "=" + encodeURIComponent(v)), a.isNumber(p) && $.push("expires=" + new Date(p).toGMTString()), a.isString(_) && $.push("path=" + _), a.isString(I) && $.push("domain=" + I), P === !0 && $.push("secure"), document.cookie = $.join("; ");
        },
        read: function(l) {
          var v = document.cookie.match(new RegExp("(^|;\\s*)(" + l + ")=([^;]*)"));
          return v ? decodeURIComponent(v[3]) : null;
        },
        remove: function(l) {
          this.write(l, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return {
        write: function() {
        },
        read: function() {
          return null;
        },
        remove: function() {
        }
      };
    }()
  ), cookies;
}
var isAbsoluteURL, hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  return hasRequiredIsAbsoluteURL || (hasRequiredIsAbsoluteURL = 1, isAbsoluteURL = function(u) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(u);
  }), isAbsoluteURL;
}
var combineURLs, hasRequiredCombineURLs;
function requireCombineURLs() {
  return hasRequiredCombineURLs || (hasRequiredCombineURLs = 1, combineURLs = function(u, c) {
    return c ? u.replace(/\/+$/, "") + "/" + c.replace(/^\/+/, "") : u;
  }), combineURLs;
}
var buildFullPath, hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath)
    return buildFullPath;
  hasRequiredBuildFullPath = 1;
  var a = requireIsAbsoluteURL(), u = requireCombineURLs();
  return buildFullPath = function(l, v) {
    return l && !a(v) ? u(l, v) : v;
  }, buildFullPath;
}
var parseHeaders, hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var a = utils$9, u = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  return parseHeaders = function(l) {
    var v = {}, p, _, I;
    return l && a.forEach(l.split(`
`), function($) {
      if (I = $.indexOf(":"), p = a.trim($.substr(0, I)).toLowerCase(), _ = a.trim($.substr(I + 1)), p) {
        if (v[p] && u.indexOf(p) >= 0)
          return;
        p === "set-cookie" ? v[p] = (v[p] ? v[p] : []).concat([_]) : v[p] = v[p] ? v[p] + ", " + _ : _;
      }
    }), v;
  }, parseHeaders;
}
var isURLSameOrigin, hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var a = utils$9;
  return isURLSameOrigin = a.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function() {
      var c = /(msie|trident)/i.test(navigator.userAgent), l = document.createElement("a"), v;
      function p(_) {
        var I = _;
        return c && (l.setAttribute("href", I), I = l.href), l.setAttribute("href", I), {
          href: l.href,
          protocol: l.protocol ? l.protocol.replace(/:$/, "") : "",
          host: l.host,
          search: l.search ? l.search.replace(/^\?/, "") : "",
          hash: l.hash ? l.hash.replace(/^#/, "") : "",
          hostname: l.hostname,
          port: l.port,
          pathname: l.pathname.charAt(0) === "/" ? l.pathname : "/" + l.pathname
        };
      }
      return v = p(window.location.href), function(I) {
        var P = a.isString(I) ? p(I) : I;
        return P.protocol === v.protocol && P.host === v.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return function() {
        return !0;
      };
    }()
  ), isURLSameOrigin;
}
var xhr, hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var a = utils$9, u = requireSettle(), c = requireCookies(), l = buildURL$1, v = requireBuildFullPath(), p = requireParseHeaders(), _ = requireIsURLSameOrigin(), I = requireCreateError();
  return xhr = function($) {
    return new Promise(function(H, j) {
      var ee = $.data, X = $.headers, ie = $.responseType;
      a.isFormData(ee) && delete X["Content-Type"];
      var Q = new XMLHttpRequest();
      if ($.auth) {
        var ne = $.auth.username || "", Z = $.auth.password ? unescape(encodeURIComponent($.auth.password)) : "";
        X.Authorization = "Basic " + btoa(ne + ":" + Z);
      }
      var de = v($.baseURL, $.url);
      Q.open($.method.toUpperCase(), l(de, $.params, $.paramsSerializer), !0), Q.timeout = $.timeout;
      function he() {
        if (Q) {
          var be = "getAllResponseHeaders" in Q ? p(Q.getAllResponseHeaders()) : null, ke = !ie || ie === "text" || ie === "json" ? Q.responseText : Q.response, _e = {
            data: ke,
            status: Q.status,
            statusText: Q.statusText,
            headers: be,
            config: $,
            request: Q
          };
          u(H, j, _e), Q = null;
        }
      }
      if ("onloadend" in Q ? Q.onloadend = he : Q.onreadystatechange = function() {
        !Q || Q.readyState !== 4 || Q.status === 0 && !(Q.responseURL && Q.responseURL.indexOf("file:") === 0) || setTimeout(he);
      }, Q.onabort = function() {
        Q && (j(I("Request aborted", $, "ECONNABORTED", Q)), Q = null);
      }, Q.onerror = function() {
        j(I("Network Error", $, null, Q)), Q = null;
      }, Q.ontimeout = function() {
        var ke = "timeout of " + $.timeout + "ms exceeded";
        $.timeoutErrorMessage && (ke = $.timeoutErrorMessage), j(I(
          ke,
          $,
          $.transitional && $.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          Q
        )), Q = null;
      }, a.isStandardBrowserEnv()) {
        var pe = ($.withCredentials || _(de)) && $.xsrfCookieName ? c.read($.xsrfCookieName) : void 0;
        pe && (X[$.xsrfHeaderName] = pe);
      }
      "setRequestHeader" in Q && a.forEach(X, function(ke, _e) {
        typeof ee > "u" && _e.toLowerCase() === "content-type" ? delete X[_e] : Q.setRequestHeader(_e, ke);
      }), a.isUndefined($.withCredentials) || (Q.withCredentials = !!$.withCredentials), ie && ie !== "json" && (Q.responseType = $.responseType), typeof $.onDownloadProgress == "function" && Q.addEventListener("progress", $.onDownloadProgress), typeof $.onUploadProgress == "function" && Q.upload && Q.upload.addEventListener("progress", $.onUploadProgress), $.cancelToken && $.cancelToken.promise.then(function(ke) {
        Q && (Q.abort(), j(ke), Q = null);
      }), ee || (ee = null), Q.send(ee);
    });
  }, xhr;
}
var utils$5 = utils$9, normalizeHeaderName = normalizeHeaderName$1, enhanceError = enhanceError$1, DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(a, u) {
  !utils$5.isUndefined(a) && utils$5.isUndefined(a["Content-Type"]) && (a["Content-Type"] = u);
}
function getDefaultAdapter() {
  var a;
  return (typeof XMLHttpRequest < "u" || typeof process$1 < "u" && Object.prototype.toString.call(process$1) === "[object process]") && (a = requireXhr()), a;
}
function stringifySafely(a, u, c) {
  if (utils$5.isString(a))
    try {
      return (u || JSON.parse)(a), utils$5.trim(a);
    } catch (l) {
      if (l.name !== "SyntaxError")
        throw l;
    }
  return (c || JSON.stringify)(a);
}
var defaults$3 = {
  transitional: {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function a(u, c) {
    return normalizeHeaderName(c, "Accept"), normalizeHeaderName(c, "Content-Type"), utils$5.isFormData(u) || utils$5.isArrayBuffer(u) || utils$5.isBuffer(u) || utils$5.isStream(u) || utils$5.isFile(u) || utils$5.isBlob(u) ? u : utils$5.isArrayBufferView(u) ? u.buffer : utils$5.isURLSearchParams(u) ? (setContentTypeIfUnset(c, "application/x-www-form-urlencoded;charset=utf-8"), u.toString()) : utils$5.isObject(u) || c && c["Content-Type"] === "application/json" ? (setContentTypeIfUnset(c, "application/json"), stringifySafely(u)) : u;
  }],
  transformResponse: [function a(u) {
    var c = this.transitional, l = c && c.silentJSONParsing, v = c && c.forcedJSONParsing, p = !l && this.responseType === "json";
    if (p || v && utils$5.isString(u) && u.length)
      try {
        return JSON.parse(u);
      } catch (_) {
        if (p)
          throw _.name === "SyntaxError" ? enhanceError(_, this, "E_JSON_PARSE") : _;
      }
    return u;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function a(u) {
    return u >= 200 && u < 300;
  }
};
defaults$3.headers = {
  common: {
    Accept: "application/json, text/plain, */*"
  }
};
utils$5.forEach(["delete", "get", "head"], function a(u) {
  defaults$3.headers[u] = {};
});
utils$5.forEach(["post", "put", "patch"], function a(u) {
  defaults$3.headers[u] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3, utils$4 = utils$9, defaults$2 = defaults_1, transformData$1 = function a(u, c, l) {
  var v = this || defaults$2;
  return utils$4.forEach(l, function(_) {
    u = _.call(v, u, c);
  }), u;
}, isCancel$1, hasRequiredIsCancel;
function requireIsCancel() {
  return hasRequiredIsCancel || (hasRequiredIsCancel = 1, isCancel$1 = function(u) {
    return !!(u && u.__CANCEL__);
  }), isCancel$1;
}
var utils$3 = utils$9, transformData = transformData$1, isCancel = requireIsCancel(), defaults$1 = defaults_1;
function throwIfCancellationRequested(a) {
  a.cancelToken && a.cancelToken.throwIfRequested();
}
var dispatchRequest$1 = function a(u) {
  throwIfCancellationRequested(u), u.headers = u.headers || {}, u.data = transformData.call(
    u,
    u.data,
    u.headers,
    u.transformRequest
  ), u.headers = utils$3.merge(
    u.headers.common || {},
    u.headers[u.method] || {},
    u.headers
  ), utils$3.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function(v) {
      delete u.headers[v];
    }
  );
  var c = u.adapter || defaults$1.adapter;
  return c(u).then(function(v) {
    return throwIfCancellationRequested(u), v.data = transformData.call(
      u,
      v.data,
      v.headers,
      u.transformResponse
    ), v;
  }, function(v) {
    return isCancel(v) || (throwIfCancellationRequested(u), v && v.response && (v.response.data = transformData.call(
      u,
      v.response.data,
      v.response.headers,
      u.transformResponse
    ))), Promise.reject(v);
  });
}, utils$2 = utils$9, mergeConfig$2 = function a(u, c) {
  c = c || {};
  var l = {}, v = ["url", "method", "data"], p = ["headers", "auth", "proxy", "params"], _ = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ], I = ["validateStatus"];
  function P(j, ee) {
    return utils$2.isPlainObject(j) && utils$2.isPlainObject(ee) ? utils$2.merge(j, ee) : utils$2.isPlainObject(ee) ? utils$2.merge({}, ee) : utils$2.isArray(ee) ? ee.slice() : ee;
  }
  function $(j) {
    utils$2.isUndefined(c[j]) ? utils$2.isUndefined(u[j]) || (l[j] = P(void 0, u[j])) : l[j] = P(u[j], c[j]);
  }
  utils$2.forEach(v, function(ee) {
    utils$2.isUndefined(c[ee]) || (l[ee] = P(void 0, c[ee]));
  }), utils$2.forEach(p, $), utils$2.forEach(_, function(ee) {
    utils$2.isUndefined(c[ee]) ? utils$2.isUndefined(u[ee]) || (l[ee] = P(void 0, u[ee])) : l[ee] = P(void 0, c[ee]);
  }), utils$2.forEach(I, function(ee) {
    ee in c ? l[ee] = P(u[ee], c[ee]) : ee in u && (l[ee] = P(void 0, u[ee]));
  });
  var F = v.concat(p).concat(_).concat(I), H = Object.keys(u).concat(Object.keys(c)).filter(function(ee) {
    return F.indexOf(ee) === -1;
  });
  return utils$2.forEach(H, $), l;
};
const name = "axios", version = "0.21.4", description = "Promise based HTTP client for the browser and node.js", main = "index.js", scripts = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
}, repository = {
  type: "git",
  url: "https://github.com/axios/axios.git"
}, keywords = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
], author = "Matt Zabriskie", license = "MIT", bugs = {
  url: "https://github.com/axios/axios/issues"
}, homepage = "https://axios-http.com", devDependencies = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
}, browser = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
}, jsdelivr = "dist/axios.min.js", unpkg = "dist/axios.min.js", typings = "./index.d.ts", dependencies = {
  "follow-redirects": "^1.14.0"
}, bundlesize = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
], require$$0 = {
  name,
  version,
  description,
  main,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  browser,
  jsdelivr,
  unpkg,
  typings,
  dependencies,
  bundlesize
};
var pkg = require$$0, validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(a, u) {
  validators$1[a] = function(l) {
    return typeof l === a || "a" + (u < 1 ? "n " : " ") + a;
  };
});
var deprecatedWarnings = {}, currentVerArr = pkg.version.split(".");
function isOlderVersion(a, u) {
  for (var c = u ? u.split(".") : currentVerArr, l = a.split("."), v = 0; v < 3; v++) {
    if (c[v] > l[v])
      return !0;
    if (c[v] < l[v])
      return !1;
  }
  return !1;
}
validators$1.transitional = function a(u, c, l) {
  var v = c && isOlderVersion(c);
  function p(_, I) {
    return "[Axios v" + pkg.version + "] Transitional option '" + _ + "'" + I + (l ? ". " + l : "");
  }
  return function(_, I, P) {
    if (u === !1)
      throw new Error(p(I, " has been removed in " + c));
    return v && !deprecatedWarnings[I] && (deprecatedWarnings[I] = !0, console.warn(
      p(
        I,
        " has been deprecated since v" + c + " and will be removed in the near future"
      )
    )), u ? u(_, I, P) : !0;
  };
};
function assertOptions(a, u, c) {
  if (typeof a != "object")
    throw new TypeError("options must be an object");
  for (var l = Object.keys(a), v = l.length; v-- > 0; ) {
    var p = l[v], _ = u[p];
    if (_) {
      var I = a[p], P = I === void 0 || _(I, p, a);
      if (P !== !0)
        throw new TypeError("option " + p + " must be " + P);
      continue;
    }
    if (c !== !0)
      throw Error("Unknown option " + p);
  }
}
var validator$1 = {
  isOlderVersion,
  assertOptions,
  validators: validators$1
}, utils$1 = utils$9, buildURL = buildURL$1, InterceptorManager = InterceptorManager_1, dispatchRequest = dispatchRequest$1, mergeConfig$1 = mergeConfig$2, validator = validator$1, validators = validator.validators;
function Axios$1(a) {
  this.defaults = a, this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function a(u) {
  typeof u == "string" ? (u = arguments[1] || {}, u.url = arguments[0]) : u = u || {}, u = mergeConfig$1(this.defaults, u), u.method ? u.method = u.method.toLowerCase() : this.defaults.method ? u.method = this.defaults.method.toLowerCase() : u.method = "get";
  var c = u.transitional;
  c !== void 0 && validator.assertOptions(c, {
    silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
    forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
    clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
  }, !1);
  var l = [], v = !0;
  this.interceptors.request.forEach(function(j) {
    typeof j.runWhen == "function" && j.runWhen(u) === !1 || (v = v && j.synchronous, l.unshift(j.fulfilled, j.rejected));
  });
  var p = [];
  this.interceptors.response.forEach(function(j) {
    p.push(j.fulfilled, j.rejected);
  });
  var _;
  if (!v) {
    var I = [dispatchRequest, void 0];
    for (Array.prototype.unshift.apply(I, l), I = I.concat(p), _ = Promise.resolve(u); I.length; )
      _ = _.then(I.shift(), I.shift());
    return _;
  }
  for (var P = u; l.length; ) {
    var $ = l.shift(), F = l.shift();
    try {
      P = $(P);
    } catch (H) {
      F(H);
      break;
    }
  }
  try {
    _ = dispatchRequest(P);
  } catch (H) {
    return Promise.reject(H);
  }
  for (; p.length; )
    _ = _.then(p.shift(), p.shift());
  return _;
};
Axios$1.prototype.getUri = function a(u) {
  return u = mergeConfig$1(this.defaults, u), buildURL(u.url, u.params, u.paramsSerializer).replace(/^\?/, "");
};
utils$1.forEach(["delete", "get", "head", "options"], function a(u) {
  Axios$1.prototype[u] = function(c, l) {
    return this.request(mergeConfig$1(l || {}, {
      method: u,
      url: c,
      data: (l || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function a(u) {
  Axios$1.prototype[u] = function(c, l, v) {
    return this.request(mergeConfig$1(v || {}, {
      method: u,
      url: c,
      data: l
    }));
  };
});
var Axios_1 = Axios$1, Cancel_1, hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel)
    return Cancel_1;
  hasRequiredCancel = 1;
  function a(u) {
    this.message = u;
  }
  return a.prototype.toString = function() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  }, a.prototype.__CANCEL__ = !0, Cancel_1 = a, Cancel_1;
}
var CancelToken_1, hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var a = requireCancel();
  function u(c) {
    if (typeof c != "function")
      throw new TypeError("executor must be a function.");
    var l;
    this.promise = new Promise(function(_) {
      l = _;
    });
    var v = this;
    c(function(_) {
      v.reason || (v.reason = new a(_), l(v.reason));
    });
  }
  return u.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, u.source = function() {
    var l, v = new u(function(_) {
      l = _;
    });
    return {
      token: v,
      cancel: l
    };
  }, CancelToken_1 = u, CancelToken_1;
}
var spread, hasRequiredSpread;
function requireSpread() {
  return hasRequiredSpread || (hasRequiredSpread = 1, spread = function(u) {
    return function(l) {
      return u.apply(null, l);
    };
  }), spread;
}
var isAxiosError, hasRequiredIsAxiosError;
function requireIsAxiosError() {
  return hasRequiredIsAxiosError || (hasRequiredIsAxiosError = 1, isAxiosError = function(u) {
    return typeof u == "object" && u.isAxiosError === !0;
  }), isAxiosError;
}
var utils = utils$9, bind = bind$2, Axios = Axios_1, mergeConfig = mergeConfig$2, defaults = defaults_1;
function createInstance(a) {
  var u = new Axios(a), c = bind(Axios.prototype.request, u);
  return utils.extend(c, Axios.prototype, u), utils.extend(c, u), c;
}
var axios$1 = createInstance(defaults);
axios$1.Axios = Axios;
axios$1.create = function a(u) {
  return createInstance(mergeConfig(axios$1.defaults, u));
};
axios$1.Cancel = requireCancel();
axios$1.CancelToken = requireCancelToken();
axios$1.isCancel = requireIsCancel();
axios$1.all = function a(u) {
  return Promise.all(u);
};
axios$1.spread = requireSpread();
axios$1.isAxiosError = requireIsAxiosError();
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axiosExports = axios$2.exports, axios = axiosExports, mapObj$1 = { exports: {} };
const isObject$1 = (a) => typeof a == "object" && a !== null, mapObjectSkip = Symbol("skip"), isObjectCustom = (a) => isObject$1(a) && !(a instanceof RegExp) && !(a instanceof Error) && !(a instanceof Date), mapObject = (a, u, c, l = /* @__PURE__ */ new WeakMap()) => {
  if (c = {
    deep: !1,
    target: {},
    ...c
  }, l.has(a))
    return l.get(a);
  l.set(a, c.target);
  const { target: v } = c;
  delete c.target;
  const p = (_) => _.map((I) => isObjectCustom(I) ? mapObject(I, u, c, l) : I);
  if (Array.isArray(a))
    return p(a);
  for (const [_, I] of Object.entries(a)) {
    const P = u(_, I, a);
    if (P === mapObjectSkip)
      continue;
    let [$, F, { shouldRecurse: H = !0 } = {}] = P;
    $ !== "__proto__" && (c.deep && H && isObjectCustom(F) && (F = Array.isArray(F) ? p(F) : mapObject(F, u, c, l)), v[$] = F);
  }
  return v;
};
mapObj$1.exports = (a, u, c) => {
  if (!isObject$1(a))
    throw new TypeError(`Expected an object, got \`${a}\` (${typeof a})`);
  return mapObject(a, u, c);
};
mapObj$1.exports.mapObjectSkip = mapObjectSkip;
var mapObjExports = mapObj$1.exports, camelcase = { exports: {} };
const UPPERCASE = /[\p{Lu}]/u, LOWERCASE = /[\p{Ll}]/u, LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu, IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u, SEPARATORS = /[_.\- ]+/, LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source), SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu"), NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu"), preserveCamelCase = (a, u, c) => {
  let l = !1, v = !1, p = !1;
  for (let _ = 0; _ < a.length; _++) {
    const I = a[_];
    l && UPPERCASE.test(I) ? (a = a.slice(0, _) + "-" + a.slice(_), l = !1, p = v, v = !0, _++) : v && p && LOWERCASE.test(I) ? (a = a.slice(0, _ - 1) + "-" + a.slice(_ - 1), p = v, v = !1, l = !0) : (l = u(I) === I && c(I) !== I, p = v, v = c(I) === I && u(I) !== I);
  }
  return a;
}, preserveConsecutiveUppercase = (a, u) => (LEADING_CAPITAL.lastIndex = 0, a.replace(LEADING_CAPITAL, (c) => u(c))), postProcess = (a, u) => (SEPARATORS_AND_IDENTIFIER.lastIndex = 0, NUMBERS_AND_IDENTIFIER.lastIndex = 0, a.replace(SEPARATORS_AND_IDENTIFIER, (c, l) => u(l)).replace(NUMBERS_AND_IDENTIFIER, (c) => u(c))), camelCase$1 = (a, u) => {
  if (!(typeof a == "string" || Array.isArray(a)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (u = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...u
  }, Array.isArray(a) ? a = a.map((p) => p.trim()).filter((p) => p.length).join("-") : a = a.trim(), a.length === 0)
    return "";
  const c = u.locale === !1 ? (p) => p.toLowerCase() : (p) => p.toLocaleLowerCase(u.locale), l = u.locale === !1 ? (p) => p.toUpperCase() : (p) => p.toLocaleUpperCase(u.locale);
  return a.length === 1 ? u.pascalCase ? l(a) : c(a) : (a !== c(a) && (a = preserveCamelCase(a, c, l)), a = a.replace(LEADING_SEPARATORS, ""), u.preserveConsecutiveUppercase ? a = preserveConsecutiveUppercase(a, c) : a = c(a), u.pascalCase && (a = l(a.charAt(0)) + a.slice(1)), postProcess(a, l));
};
camelcase.exports = camelCase$1;
camelcase.exports.default = camelCase$1;
var camelcaseExports = camelcase.exports;
class QuickLRU {
  constructor(u = {}) {
    if (!(u.maxSize && u.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    this.maxSize = u.maxSize, this.onEviction = u.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  _set(u, c) {
    if (this.cache.set(u, c), this._size++, this._size >= this.maxSize) {
      if (this._size = 0, typeof this.onEviction == "function")
        for (const [l, v] of this.oldCache.entries())
          this.onEviction(l, v);
      this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map();
    }
  }
  get(u) {
    if (this.cache.has(u))
      return this.cache.get(u);
    if (this.oldCache.has(u)) {
      const c = this.oldCache.get(u);
      return this.oldCache.delete(u), this._set(u, c), c;
    }
  }
  set(u, c) {
    return this.cache.has(u) ? this.cache.set(u, c) : this._set(u, c), this;
  }
  has(u) {
    return this.cache.has(u) || this.oldCache.has(u);
  }
  peek(u) {
    if (this.cache.has(u))
      return this.cache.get(u);
    if (this.oldCache.has(u))
      return this.oldCache.get(u);
  }
  delete(u) {
    const c = this.cache.delete(u);
    return c && this._size--, this.oldCache.delete(u) || c;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  *keys() {
    for (const [u] of this)
      yield u;
  }
  *values() {
    for (const [, u] of this)
      yield u;
  }
  *[Symbol.iterator]() {
    for (const u of this.cache)
      yield u;
    for (const u of this.oldCache) {
      const [c] = u;
      this.cache.has(c) || (yield u);
    }
  }
  get size() {
    let u = 0;
    for (const c of this.oldCache.keys())
      this.cache.has(c) || u++;
    return Math.min(this._size + u, this.maxSize);
  }
}
var quickLru = QuickLRU;
const mapObj = mapObjExports, camelCase = camelcaseExports, QuickLru = quickLru, has$1 = (a, u) => a.some((c) => typeof c == "string" ? c === u : (c.lastIndex = 0, c.test(u))), cache$1 = new QuickLru({ maxSize: 1e5 }), isObject = (a) => typeof a == "object" && a !== null && !(a instanceof RegExp) && !(a instanceof Error) && !(a instanceof Date), camelCaseConvert = (a, u) => {
  if (!isObject(a))
    return a;
  u = {
    deep: !1,
    pascalCase: !1,
    ...u
  };
  const { exclude: c, pascalCase: l, stopPaths: v, deep: p } = u, _ = new Set(v), I = (P) => ($, F) => {
    if (p && isObject(F)) {
      const H = P === void 0 ? $ : `${P}.${$}`;
      _.has(H) || (F = mapObj(F, I(H)));
    }
    if (!(c && has$1(c, $))) {
      const H = l ? `${$}_` : $;
      if (cache$1.has(H))
        $ = cache$1.get(H);
      else {
        const j = camelCase($, { pascalCase: l, locale: !1 });
        $.length < 100 && cache$1.set(H, j), $ = j;
      }
    }
    return [$, F];
  };
  return mapObj(a, I(void 0));
};
var camelcaseKeys = (a, u) => Array.isArray(a) ? Object.keys(a).map((c) => camelCaseConvert(a[c], u)) : camelCaseConvert(a, u), __importDefault$6 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(TwirpRPC, "__esModule", { value: !0 });
TwirpRPC.TwirpRpc = TwirpRPC.livekitPackage = void 0;
const axios_1 = __importDefault$6(axios), camelcase_keys_1 = __importDefault$6(camelcaseKeys), defaultPrefix = "/twirp";
TwirpRPC.livekitPackage = "livekit";
class TwirpRpc {
  constructor(u, c, l, v) {
    this.host = u, this.pkg = c, this.prefix = l || defaultPrefix, this.instance = axios_1.default.create({
      baseURL: u,
      headers: Object.assign({}, v ? { Host: v } : {})
    });
  }
  request(u, c, l, v) {
    return new Promise((p, _) => {
      const I = `${this.prefix}/${this.pkg}.${u}/${c}`;
      this.instance.post(I, l, { headers: v }).then((P) => {
        p(camelcase_keys_1.default(P.data, { deep: !0 }));
      }).catch(_);
    });
  }
}
TwirpRPC.TwirpRpc = TwirpRpc;
var __awaiter$2 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function I(F) {
      try {
        $(l.next(F));
      } catch (H) {
        _(H);
      }
    }
    function P(F) {
      try {
        $(l.throw(F));
      } catch (H) {
        _(H);
      }
    }
    function $(F) {
      F.done ? p(F.value) : v(F.value).then(I, P);
    }
    $((l = l.apply(a, u || [])).next());
  });
}, __importDefault$5 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(EgressClient$1, "__esModule", { value: !0 });
EgressClient$1.EgressClient = void 0;
const livekit_egress_1$1 = livekit_egress, ServiceBase_1$2 = __importDefault$5(ServiceBase$1), TwirpRPC_1$2 = TwirpRPC, svc$2 = "Egress";
class EgressClient extends ServiceBase_1$2.default {
  /**
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    super(c, l), this.rpc = new TwirpRPC_1$2.TwirpRpc(u, TwirpRPC_1$2.livekitPackage);
  }
  startRoomCompositeEgress(u, c, l, v, p, _, I) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let P;
      if (l !== void 0)
        if (typeof l == "string")
          P = l;
        else {
          const Q = l;
          P = Q.layout, v = Q.encodingOptions, p = Q.audioOnly, _ = Q.videoOnly, I = Q.customBaseUrl;
        }
      P ?? (P = ""), p ?? (p = !1), _ ?? (_ = !1), I ?? (I = "");
      const { file: $, segments: F, stream: H, preset: j, advanced: ee } = this.getOutputParams(c, v), X = livekit_egress_1$1.RoomCompositeEgressRequest.toJSON({
        roomName: u,
        layout: P,
        audioOnly: p,
        videoOnly: _,
        customBaseUrl: I,
        file: $,
        stream: H,
        segments: F,
        preset: j,
        advanced: ee
      }), ie = yield this.rpc.request(svc$2, "StartRoomCompositeEgress", X, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(ie);
    });
  }
  /**
   * @param url url
   * @param output file or stream output
   * @param opts WebOptions
   */
  startWebEgress(u, c, l) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const v = (l == null ? void 0 : l.audioOnly) || !1, p = (l == null ? void 0 : l.videoOnly) || !1, { file: _, segments: I, stream: P, preset: $, advanced: F } = this.getOutputParams(c, l == null ? void 0 : l.encodingOptions), H = livekit_egress_1$1.WebEgressRequest.toJSON({
        url: u,
        audioOnly: v,
        videoOnly: p,
        file: _,
        stream: P,
        segments: I,
        preset: $,
        advanced: F
      }), j = yield this.rpc.request(svc$2, "StartWebEgress", H, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(j);
    });
  }
  startTrackCompositeEgress(u, c, l, v, p) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let _;
      if (l !== void 0)
        if (typeof l == "string")
          _ = l;
        else {
          const X = l;
          _ = X.audioTrackId, v = X.videoTrackId, p = X.encodingOptions;
        }
      _ ?? (_ = ""), v ?? (v = "");
      const { file: I, segments: P, stream: $, preset: F, advanced: H } = this.getOutputParams(c, p), j = livekit_egress_1$1.TrackCompositeEgressRequest.toJSON({
        roomName: u,
        audioTrackId: _,
        videoTrackId: v,
        file: I,
        stream: $,
        segments: P,
        preset: F,
        advanced: H
      }), ee = yield this.rpc.request(svc$2, "StartTrackCompositeEgress", j, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(ee);
    });
  }
  getOutputParams(u, c) {
    let l, v, p, _, I;
    return u.filepath !== void 0 ? l = u : u.filenamePrefix !== void 0 ? p = u : v = u, c && (typeof c == "number" ? _ = c : I = c), { file: l, segments: p, stream: v, preset: _, advanced: I };
  }
  /**
   * @param roomName room name
   * @param output file or websocket output
   * @param trackId track Id
   */
  startTrackEgress(u, c, l) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let v, p;
      c.filepath !== void 0 ? v = c : p = c;
      const _ = livekit_egress_1$1.TrackEgressRequest.toJSON({
        roomName: u,
        trackId: l,
        file: v,
        websocketUrl: p
      }), I = yield this.rpc.request(svc$2, "StartTrackEgress", _, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(I);
    });
  }
  /**
   * @param egressId
   * @param layout
   */
  updateLayout(u, c) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc$2, "UpdateLayout", livekit_egress_1$1.UpdateLayoutRequest.toJSON({ egressId: u, layout: c }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(l);
    });
  }
  /**
   * @param egressId
   * @param addOutputUrls
   * @param removeOutputUrls
   */
  updateStream(u, c, l) {
    return __awaiter$2(this, void 0, void 0, function* () {
      c ?? (c = []), l ?? (l = []);
      const v = yield this.rpc.request(svc$2, "UpdateStream", livekit_egress_1$1.UpdateStreamRequest.toJSON({ egressId: u, addOutputUrls: c, removeOutputUrls: l }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(v);
    });
  }
  /**
   * @param roomName list egress for one room only
   */
  listEgress(u) {
    var c;
    return __awaiter$2(this, void 0, void 0, function* () {
      u ?? (u = "");
      const l = yield this.rpc.request(svc$2, "ListEgress", livekit_egress_1$1.ListEgressRequest.toJSON({ roomName: u }), this.authHeader({ roomRecord: !0 }));
      return (c = livekit_egress_1$1.ListEgressResponse.fromJSON(l).items) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * @param egressId
   */
  stopEgress(u) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc$2, "StopEgress", livekit_egress_1$1.StopEgressRequest.toJSON({ egressId: u }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(c);
    });
  }
}
EgressClient$1.EgressClient = EgressClient;
var grants = {};
Object.defineProperty(grants, "__esModule", { value: !0 });
var IngressClient$1 = {}, livekit_ingress = {}, livekit_models = {}, timestamp = {}, __importDefault$4 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(timestamp, "__esModule", { value: !0 });
timestamp.Timestamp = timestamp.protobufPackage = void 0;
const long_1$1 = __importDefault$4(umdExports), minimal_1$1 = __importDefault$4(minimal);
timestamp.protobufPackage = "google.protobuf";
function createBaseTimestamp() {
  return { seconds: 0, nanos: 0 };
}
timestamp.Timestamp = {
  encode(a, u = minimal_1$1.default.Writer.create()) {
    return a.seconds !== 0 && u.uint32(8).int64(a.seconds), a.nanos !== 0 && u.uint32(16).int32(a.nanos), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$1.default.Reader ? a : new minimal_1$1.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseTimestamp();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.seconds = longToNumber$1(c.int64());
          break;
        case 2:
          v.nanos = c.int32();
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      seconds: isSet$1(a.seconds) ? Number(a.seconds) : 0,
      nanos: isSet$1(a.nanos) ? Number(a.nanos) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.seconds !== void 0 && (u.seconds = Math.round(a.seconds)), a.nanos !== void 0 && (u.nanos = Math.round(a.nanos)), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseTimestamp();
    return l.seconds = (u = a.seconds) !== null && u !== void 0 ? u : 0, l.nanos = (c = a.nanos) !== null && c !== void 0 ? c : 0, l;
  }
};
var globalThis$2 = (() => {
  if (typeof globalThis$2 < "u")
    return globalThis$2;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber$1(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1$1.default.util.Long !== long_1$1.default && (minimal_1$1.default.util.Long = long_1$1.default, minimal_1$1.default.configure());
function isSet$1(a) {
  return a != null;
}
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(J) {
    return J && J.__esModule ? J : { default: J };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.RTPStats_GapHistogramEntry = a.RTPStats = a.DisabledCodecs = a.VideoConfiguration = a.ClientConfiguration = a.ClientInfo = a.ServerInfo = a.ParticipantTracks = a.UserPacket = a.SpeakerInfo = a.ActiveSpeakerUpdate = a.DataPacket = a.VideoLayer = a.TrackInfo = a.SimulcastCodecInfo = a.ParticipantInfo = a.ParticipantPermission = a.Codec = a.Room = a.clientInfo_SDKToJSON = a.clientInfo_SDKFromJSON = a.ClientInfo_SDK = a.serverInfo_EditionToJSON = a.serverInfo_EditionFromJSON = a.ServerInfo_Edition = a.dataPacket_KindToJSON = a.dataPacket_KindFromJSON = a.DataPacket_Kind = a.participantInfo_StateToJSON = a.participantInfo_StateFromJSON = a.ParticipantInfo_State = a.disconnectReasonToJSON = a.disconnectReasonFromJSON = a.DisconnectReason = a.clientConfigSettingToJSON = a.clientConfigSettingFromJSON = a.ClientConfigSetting = a.connectionQualityToJSON = a.connectionQualityFromJSON = a.ConnectionQuality = a.videoQualityToJSON = a.videoQualityFromJSON = a.VideoQuality = a.trackSourceToJSON = a.trackSourceFromJSON = a.TrackSource = a.trackTypeToJSON = a.trackTypeFromJSON = a.TrackType = a.protobufPackage = void 0, a.TimedVersion = void 0;
  const c = u(umdExports), l = u(minimal), v = timestamp;
  a.protobufPackage = "livekit";
  var p;
  (function(J) {
    J[J.AUDIO = 0] = "AUDIO", J[J.VIDEO = 1] = "VIDEO", J[J.DATA = 2] = "DATA", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p = a.TrackType || (a.TrackType = {}));
  function _(J) {
    switch (J) {
      case 0:
      case "AUDIO":
        return p.AUDIO;
      case 1:
      case "VIDEO":
        return p.VIDEO;
      case 2:
      case "DATA":
        return p.DATA;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  a.trackTypeFromJSON = _;
  function I(J) {
    switch (J) {
      case p.AUDIO:
        return "AUDIO";
      case p.VIDEO:
        return "VIDEO";
      case p.DATA:
        return "DATA";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.trackTypeToJSON = I;
  var P;
  (function(J) {
    J[J.UNKNOWN = 0] = "UNKNOWN", J[J.CAMERA = 1] = "CAMERA", J[J.MICROPHONE = 2] = "MICROPHONE", J[J.SCREEN_SHARE = 3] = "SCREEN_SHARE", J[J.SCREEN_SHARE_AUDIO = 4] = "SCREEN_SHARE_AUDIO", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(P = a.TrackSource || (a.TrackSource = {}));
  function $(J) {
    switch (J) {
      case 0:
      case "UNKNOWN":
        return P.UNKNOWN;
      case 1:
      case "CAMERA":
        return P.CAMERA;
      case 2:
      case "MICROPHONE":
        return P.MICROPHONE;
      case 3:
      case "SCREEN_SHARE":
        return P.SCREEN_SHARE;
      case 4:
      case "SCREEN_SHARE_AUDIO":
        return P.SCREEN_SHARE_AUDIO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return P.UNRECOGNIZED;
    }
  }
  a.trackSourceFromJSON = $;
  function F(J) {
    switch (J) {
      case P.UNKNOWN:
        return "UNKNOWN";
      case P.CAMERA:
        return "CAMERA";
      case P.MICROPHONE:
        return "MICROPHONE";
      case P.SCREEN_SHARE:
        return "SCREEN_SHARE";
      case P.SCREEN_SHARE_AUDIO:
        return "SCREEN_SHARE_AUDIO";
      case P.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.trackSourceToJSON = F;
  var H;
  (function(J) {
    J[J.LOW = 0] = "LOW", J[J.MEDIUM = 1] = "MEDIUM", J[J.HIGH = 2] = "HIGH", J[J.OFF = 3] = "OFF", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(H = a.VideoQuality || (a.VideoQuality = {}));
  function j(J) {
    switch (J) {
      case 0:
      case "LOW":
        return H.LOW;
      case 1:
      case "MEDIUM":
        return H.MEDIUM;
      case 2:
      case "HIGH":
        return H.HIGH;
      case 3:
      case "OFF":
        return H.OFF;
      case -1:
      case "UNRECOGNIZED":
      default:
        return H.UNRECOGNIZED;
    }
  }
  a.videoQualityFromJSON = j;
  function ee(J) {
    switch (J) {
      case H.LOW:
        return "LOW";
      case H.MEDIUM:
        return "MEDIUM";
      case H.HIGH:
        return "HIGH";
      case H.OFF:
        return "OFF";
      case H.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.videoQualityToJSON = ee;
  var X;
  (function(J) {
    J[J.POOR = 0] = "POOR", J[J.GOOD = 1] = "GOOD", J[J.EXCELLENT = 2] = "EXCELLENT", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(X = a.ConnectionQuality || (a.ConnectionQuality = {}));
  function ie(J) {
    switch (J) {
      case 0:
      case "POOR":
        return X.POOR;
      case 1:
      case "GOOD":
        return X.GOOD;
      case 2:
      case "EXCELLENT":
        return X.EXCELLENT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return X.UNRECOGNIZED;
    }
  }
  a.connectionQualityFromJSON = ie;
  function Q(J) {
    switch (J) {
      case X.POOR:
        return "POOR";
      case X.GOOD:
        return "GOOD";
      case X.EXCELLENT:
        return "EXCELLENT";
      case X.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.connectionQualityToJSON = Q;
  var ne;
  (function(J) {
    J[J.UNSET = 0] = "UNSET", J[J.DISABLED = 1] = "DISABLED", J[J.ENABLED = 2] = "ENABLED", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(ne = a.ClientConfigSetting || (a.ClientConfigSetting = {}));
  function Z(J) {
    switch (J) {
      case 0:
      case "UNSET":
        return ne.UNSET;
      case 1:
      case "DISABLED":
        return ne.DISABLED;
      case 2:
      case "ENABLED":
        return ne.ENABLED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ne.UNRECOGNIZED;
    }
  }
  a.clientConfigSettingFromJSON = Z;
  function de(J) {
    switch (J) {
      case ne.UNSET:
        return "UNSET";
      case ne.DISABLED:
        return "DISABLED";
      case ne.ENABLED:
        return "ENABLED";
      case ne.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.clientConfigSettingToJSON = de;
  var he;
  (function(J) {
    J[J.UNKNOWN_REASON = 0] = "UNKNOWN_REASON", J[J.CLIENT_INITIATED = 1] = "CLIENT_INITIATED", J[J.DUPLICATE_IDENTITY = 2] = "DUPLICATE_IDENTITY", J[J.SERVER_SHUTDOWN = 3] = "SERVER_SHUTDOWN", J[J.PARTICIPANT_REMOVED = 4] = "PARTICIPANT_REMOVED", J[J.ROOM_DELETED = 5] = "ROOM_DELETED", J[J.STATE_MISMATCH = 6] = "STATE_MISMATCH", J[J.JOIN_FAILURE = 7] = "JOIN_FAILURE", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(he = a.DisconnectReason || (a.DisconnectReason = {}));
  function pe(J) {
    switch (J) {
      case 0:
      case "UNKNOWN_REASON":
        return he.UNKNOWN_REASON;
      case 1:
      case "CLIENT_INITIATED":
        return he.CLIENT_INITIATED;
      case 2:
      case "DUPLICATE_IDENTITY":
        return he.DUPLICATE_IDENTITY;
      case 3:
      case "SERVER_SHUTDOWN":
        return he.SERVER_SHUTDOWN;
      case 4:
      case "PARTICIPANT_REMOVED":
        return he.PARTICIPANT_REMOVED;
      case 5:
      case "ROOM_DELETED":
        return he.ROOM_DELETED;
      case 6:
      case "STATE_MISMATCH":
        return he.STATE_MISMATCH;
      case 7:
      case "JOIN_FAILURE":
        return he.JOIN_FAILURE;
      case -1:
      case "UNRECOGNIZED":
      default:
        return he.UNRECOGNIZED;
    }
  }
  a.disconnectReasonFromJSON = pe;
  function be(J) {
    switch (J) {
      case he.UNKNOWN_REASON:
        return "UNKNOWN_REASON";
      case he.CLIENT_INITIATED:
        return "CLIENT_INITIATED";
      case he.DUPLICATE_IDENTITY:
        return "DUPLICATE_IDENTITY";
      case he.SERVER_SHUTDOWN:
        return "SERVER_SHUTDOWN";
      case he.PARTICIPANT_REMOVED:
        return "PARTICIPANT_REMOVED";
      case he.ROOM_DELETED:
        return "ROOM_DELETED";
      case he.STATE_MISMATCH:
        return "STATE_MISMATCH";
      case he.JOIN_FAILURE:
        return "JOIN_FAILURE";
      case he.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.disconnectReasonToJSON = be;
  var ke;
  (function(J) {
    J[J.JOINING = 0] = "JOINING", J[J.JOINED = 1] = "JOINED", J[J.ACTIVE = 2] = "ACTIVE", J[J.DISCONNECTED = 3] = "DISCONNECTED", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(ke = a.ParticipantInfo_State || (a.ParticipantInfo_State = {}));
  function _e(J) {
    switch (J) {
      case 0:
      case "JOINING":
        return ke.JOINING;
      case 1:
      case "JOINED":
        return ke.JOINED;
      case 2:
      case "ACTIVE":
        return ke.ACTIVE;
      case 3:
      case "DISCONNECTED":
        return ke.DISCONNECTED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ke.UNRECOGNIZED;
    }
  }
  a.participantInfo_StateFromJSON = _e;
  function q(J) {
    switch (J) {
      case ke.JOINING:
        return "JOINING";
      case ke.JOINED:
        return "JOINED";
      case ke.ACTIVE:
        return "ACTIVE";
      case ke.DISCONNECTED:
        return "DISCONNECTED";
      case ke.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.participantInfo_StateToJSON = q;
  var z;
  (function(J) {
    J[J.RELIABLE = 0] = "RELIABLE", J[J.LOSSY = 1] = "LOSSY", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(z = a.DataPacket_Kind || (a.DataPacket_Kind = {}));
  function C(J) {
    switch (J) {
      case 0:
      case "RELIABLE":
        return z.RELIABLE;
      case 1:
      case "LOSSY":
        return z.LOSSY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return z.UNRECOGNIZED;
    }
  }
  a.dataPacket_KindFromJSON = C;
  function b(J) {
    switch (J) {
      case z.RELIABLE:
        return "RELIABLE";
      case z.LOSSY:
        return "LOSSY";
      case z.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.dataPacket_KindToJSON = b;
  var E;
  (function(J) {
    J[J.Standard = 0] = "Standard", J[J.Cloud = 1] = "Cloud", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(E = a.ServerInfo_Edition || (a.ServerInfo_Edition = {}));
  function k(J) {
    switch (J) {
      case 0:
      case "Standard":
        return E.Standard;
      case 1:
      case "Cloud":
        return E.Cloud;
      case -1:
      case "UNRECOGNIZED":
      default:
        return E.UNRECOGNIZED;
    }
  }
  a.serverInfo_EditionFromJSON = k;
  function O(J) {
    switch (J) {
      case E.Standard:
        return "Standard";
      case E.Cloud:
        return "Cloud";
      case E.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.serverInfo_EditionToJSON = O;
  var A;
  (function(J) {
    J[J.UNKNOWN = 0] = "UNKNOWN", J[J.JS = 1] = "JS", J[J.SWIFT = 2] = "SWIFT", J[J.ANDROID = 3] = "ANDROID", J[J.FLUTTER = 4] = "FLUTTER", J[J.GO = 5] = "GO", J[J.UNITY = 6] = "UNITY", J[J.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(A = a.ClientInfo_SDK || (a.ClientInfo_SDK = {}));
  function x(J) {
    switch (J) {
      case 0:
      case "UNKNOWN":
        return A.UNKNOWN;
      case 1:
      case "JS":
        return A.JS;
      case 2:
      case "SWIFT":
        return A.SWIFT;
      case 3:
      case "ANDROID":
        return A.ANDROID;
      case 4:
      case "FLUTTER":
        return A.FLUTTER;
      case 5:
      case "GO":
        return A.GO;
      case 6:
      case "UNITY":
        return A.UNITY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return A.UNRECOGNIZED;
    }
  }
  a.clientInfo_SDKFromJSON = x;
  function Y(J) {
    switch (J) {
      case A.UNKNOWN:
        return "UNKNOWN";
      case A.JS:
        return "JS";
      case A.SWIFT:
        return "SWIFT";
      case A.ANDROID:
        return "ANDROID";
      case A.FLUTTER:
        return "FLUTTER";
      case A.GO:
        return "GO";
      case A.UNITY:
        return "UNITY";
      case A.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.clientInfo_SDKToJSON = Y;
  function B() {
    return {
      sid: "",
      name: "",
      emptyTimeout: 0,
      maxParticipants: 0,
      creationTime: 0,
      turnPassword: "",
      enabledCodecs: [],
      metadata: "",
      numParticipants: 0,
      activeRecording: !1
    };
  }
  a.Room = {
    encode(J, Ee = l.default.Writer.create()) {
      J.sid !== "" && Ee.uint32(10).string(J.sid), J.name !== "" && Ee.uint32(18).string(J.name), J.emptyTimeout !== 0 && Ee.uint32(24).uint32(J.emptyTimeout), J.maxParticipants !== 0 && Ee.uint32(32).uint32(J.maxParticipants), J.creationTime !== 0 && Ee.uint32(40).int64(J.creationTime), J.turnPassword !== "" && Ee.uint32(50).string(J.turnPassword);
      for (const ue of J.enabledCodecs)
        a.Codec.encode(ue, Ee.uint32(58).fork()).ldelim();
      return J.metadata !== "" && Ee.uint32(66).string(J.metadata), J.numParticipants !== 0 && Ee.uint32(72).uint32(J.numParticipants), J.activeRecording === !0 && Ee.uint32(80).bool(J.activeRecording), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = B();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.sid = ue.string();
            break;
          case 2:
            ve.name = ue.string();
            break;
          case 3:
            ve.emptyTimeout = ue.uint32();
            break;
          case 4:
            ve.maxParticipants = ue.uint32();
            break;
          case 5:
            ve.creationTime = Te(ue.int64());
            break;
          case 6:
            ve.turnPassword = ue.string();
            break;
          case 7:
            ve.enabledCodecs.push(a.Codec.decode(ue, ue.uint32()));
            break;
          case 8:
            ve.metadata = ue.string();
            break;
          case 9:
            ve.numParticipants = ue.uint32();
            break;
          case 10:
            ve.activeRecording = ue.bool();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        sid: Re(J.sid) ? String(J.sid) : "",
        name: Re(J.name) ? String(J.name) : "",
        emptyTimeout: Re(J.emptyTimeout) ? Number(J.emptyTimeout) : 0,
        maxParticipants: Re(J.maxParticipants) ? Number(J.maxParticipants) : 0,
        creationTime: Re(J.creationTime) ? Number(J.creationTime) : 0,
        turnPassword: Re(J.turnPassword) ? String(J.turnPassword) : "",
        enabledCodecs: Array.isArray(J == null ? void 0 : J.enabledCodecs) ? J.enabledCodecs.map((Ee) => a.Codec.fromJSON(Ee)) : [],
        metadata: Re(J.metadata) ? String(J.metadata) : "",
        numParticipants: Re(J.numParticipants) ? Number(J.numParticipants) : 0,
        activeRecording: Re(J.activeRecording) ? !!J.activeRecording : !1
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.sid !== void 0 && (Ee.sid = J.sid), J.name !== void 0 && (Ee.name = J.name), J.emptyTimeout !== void 0 && (Ee.emptyTimeout = Math.round(J.emptyTimeout)), J.maxParticipants !== void 0 && (Ee.maxParticipants = Math.round(J.maxParticipants)), J.creationTime !== void 0 && (Ee.creationTime = Math.round(J.creationTime)), J.turnPassword !== void 0 && (Ee.turnPassword = J.turnPassword), J.enabledCodecs ? Ee.enabledCodecs = J.enabledCodecs.map((ue) => ue ? a.Codec.toJSON(ue) : void 0) : Ee.enabledCodecs = [], J.metadata !== void 0 && (Ee.metadata = J.metadata), J.numParticipants !== void 0 && (Ee.numParticipants = Math.round(J.numParticipants)), J.activeRecording !== void 0 && (Ee.activeRecording = J.activeRecording), Ee;
    },
    fromPartial(J) {
      var Ee, ue, ce, ve, Ce, Be, He, Ve, Ze, Ke;
      const U = B();
      return U.sid = (Ee = J.sid) !== null && Ee !== void 0 ? Ee : "", U.name = (ue = J.name) !== null && ue !== void 0 ? ue : "", U.emptyTimeout = (ce = J.emptyTimeout) !== null && ce !== void 0 ? ce : 0, U.maxParticipants = (ve = J.maxParticipants) !== null && ve !== void 0 ? ve : 0, U.creationTime = (Ce = J.creationTime) !== null && Ce !== void 0 ? Ce : 0, U.turnPassword = (Be = J.turnPassword) !== null && Be !== void 0 ? Be : "", U.enabledCodecs = ((He = J.enabledCodecs) === null || He === void 0 ? void 0 : He.map((se) => a.Codec.fromPartial(se))) || [], U.metadata = (Ve = J.metadata) !== null && Ve !== void 0 ? Ve : "", U.numParticipants = (Ze = J.numParticipants) !== null && Ze !== void 0 ? Ze : 0, U.activeRecording = (Ke = J.activeRecording) !== null && Ke !== void 0 ? Ke : !1, U;
    }
  };
  function T() {
    return { mime: "", fmtpLine: "" };
  }
  a.Codec = {
    encode(J, Ee = l.default.Writer.create()) {
      return J.mime !== "" && Ee.uint32(10).string(J.mime), J.fmtpLine !== "" && Ee.uint32(18).string(J.fmtpLine), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = T();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.mime = ue.string();
            break;
          case 2:
            ve.fmtpLine = ue.string();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        mime: Re(J.mime) ? String(J.mime) : "",
        fmtpLine: Re(J.fmtpLine) ? String(J.fmtpLine) : ""
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.mime !== void 0 && (Ee.mime = J.mime), J.fmtpLine !== void 0 && (Ee.fmtpLine = J.fmtpLine), Ee;
    },
    fromPartial(J) {
      var Ee, ue;
      const ce = T();
      return ce.mime = (Ee = J.mime) !== null && Ee !== void 0 ? Ee : "", ce.fmtpLine = (ue = J.fmtpLine) !== null && ue !== void 0 ? ue : "", ce;
    }
  };
  function D() {
    return { canSubscribe: !1, canPublish: !1, canPublishData: !1, hidden: !1, recorder: !1 };
  }
  a.ParticipantPermission = {
    encode(J, Ee = l.default.Writer.create()) {
      return J.canSubscribe === !0 && Ee.uint32(8).bool(J.canSubscribe), J.canPublish === !0 && Ee.uint32(16).bool(J.canPublish), J.canPublishData === !0 && Ee.uint32(24).bool(J.canPublishData), J.hidden === !0 && Ee.uint32(56).bool(J.hidden), J.recorder === !0 && Ee.uint32(64).bool(J.recorder), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = D();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.canSubscribe = ue.bool();
            break;
          case 2:
            ve.canPublish = ue.bool();
            break;
          case 3:
            ve.canPublishData = ue.bool();
            break;
          case 7:
            ve.hidden = ue.bool();
            break;
          case 8:
            ve.recorder = ue.bool();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        canSubscribe: Re(J.canSubscribe) ? !!J.canSubscribe : !1,
        canPublish: Re(J.canPublish) ? !!J.canPublish : !1,
        canPublishData: Re(J.canPublishData) ? !!J.canPublishData : !1,
        hidden: Re(J.hidden) ? !!J.hidden : !1,
        recorder: Re(J.recorder) ? !!J.recorder : !1
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.canSubscribe !== void 0 && (Ee.canSubscribe = J.canSubscribe), J.canPublish !== void 0 && (Ee.canPublish = J.canPublish), J.canPublishData !== void 0 && (Ee.canPublishData = J.canPublishData), J.hidden !== void 0 && (Ee.hidden = J.hidden), J.recorder !== void 0 && (Ee.recorder = J.recorder), Ee;
    },
    fromPartial(J) {
      var Ee, ue, ce, ve, Ce;
      const Be = D();
      return Be.canSubscribe = (Ee = J.canSubscribe) !== null && Ee !== void 0 ? Ee : !1, Be.canPublish = (ue = J.canPublish) !== null && ue !== void 0 ? ue : !1, Be.canPublishData = (ce = J.canPublishData) !== null && ce !== void 0 ? ce : !1, Be.hidden = (ve = J.hidden) !== null && ve !== void 0 ? ve : !1, Be.recorder = (Ce = J.recorder) !== null && Ce !== void 0 ? Ce : !1, Be;
    }
  };
  function te() {
    return {
      sid: "",
      identity: "",
      state: 0,
      tracks: [],
      metadata: "",
      joinedAt: 0,
      name: "",
      version: 0,
      permission: void 0,
      region: "",
      isPublisher: !1
    };
  }
  a.ParticipantInfo = {
    encode(J, Ee = l.default.Writer.create()) {
      J.sid !== "" && Ee.uint32(10).string(J.sid), J.identity !== "" && Ee.uint32(18).string(J.identity), J.state !== 0 && Ee.uint32(24).int32(J.state);
      for (const ue of J.tracks)
        a.TrackInfo.encode(ue, Ee.uint32(34).fork()).ldelim();
      return J.metadata !== "" && Ee.uint32(42).string(J.metadata), J.joinedAt !== 0 && Ee.uint32(48).int64(J.joinedAt), J.name !== "" && Ee.uint32(74).string(J.name), J.version !== 0 && Ee.uint32(80).uint32(J.version), J.permission !== void 0 && a.ParticipantPermission.encode(J.permission, Ee.uint32(90).fork()).ldelim(), J.region !== "" && Ee.uint32(98).string(J.region), J.isPublisher === !0 && Ee.uint32(104).bool(J.isPublisher), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = te();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.sid = ue.string();
            break;
          case 2:
            ve.identity = ue.string();
            break;
          case 3:
            ve.state = ue.int32();
            break;
          case 4:
            ve.tracks.push(a.TrackInfo.decode(ue, ue.uint32()));
            break;
          case 5:
            ve.metadata = ue.string();
            break;
          case 6:
            ve.joinedAt = Te(ue.int64());
            break;
          case 9:
            ve.name = ue.string();
            break;
          case 10:
            ve.version = ue.uint32();
            break;
          case 11:
            ve.permission = a.ParticipantPermission.decode(ue, ue.uint32());
            break;
          case 12:
            ve.region = ue.string();
            break;
          case 13:
            ve.isPublisher = ue.bool();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        sid: Re(J.sid) ? String(J.sid) : "",
        identity: Re(J.identity) ? String(J.identity) : "",
        state: Re(J.state) ? _e(J.state) : 0,
        tracks: Array.isArray(J == null ? void 0 : J.tracks) ? J.tracks.map((Ee) => a.TrackInfo.fromJSON(Ee)) : [],
        metadata: Re(J.metadata) ? String(J.metadata) : "",
        joinedAt: Re(J.joinedAt) ? Number(J.joinedAt) : 0,
        name: Re(J.name) ? String(J.name) : "",
        version: Re(J.version) ? Number(J.version) : 0,
        permission: Re(J.permission) ? a.ParticipantPermission.fromJSON(J.permission) : void 0,
        region: Re(J.region) ? String(J.region) : "",
        isPublisher: Re(J.isPublisher) ? !!J.isPublisher : !1
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.sid !== void 0 && (Ee.sid = J.sid), J.identity !== void 0 && (Ee.identity = J.identity), J.state !== void 0 && (Ee.state = q(J.state)), J.tracks ? Ee.tracks = J.tracks.map((ue) => ue ? a.TrackInfo.toJSON(ue) : void 0) : Ee.tracks = [], J.metadata !== void 0 && (Ee.metadata = J.metadata), J.joinedAt !== void 0 && (Ee.joinedAt = Math.round(J.joinedAt)), J.name !== void 0 && (Ee.name = J.name), J.version !== void 0 && (Ee.version = Math.round(J.version)), J.permission !== void 0 && (Ee.permission = J.permission ? a.ParticipantPermission.toJSON(J.permission) : void 0), J.region !== void 0 && (Ee.region = J.region), J.isPublisher !== void 0 && (Ee.isPublisher = J.isPublisher), Ee;
    },
    fromPartial(J) {
      var Ee, ue, ce, ve, Ce, Be, He, Ve, Ze, Ke;
      const U = te();
      return U.sid = (Ee = J.sid) !== null && Ee !== void 0 ? Ee : "", U.identity = (ue = J.identity) !== null && ue !== void 0 ? ue : "", U.state = (ce = J.state) !== null && ce !== void 0 ? ce : 0, U.tracks = ((ve = J.tracks) === null || ve === void 0 ? void 0 : ve.map((se) => a.TrackInfo.fromPartial(se))) || [], U.metadata = (Ce = J.metadata) !== null && Ce !== void 0 ? Ce : "", U.joinedAt = (Be = J.joinedAt) !== null && Be !== void 0 ? Be : 0, U.name = (He = J.name) !== null && He !== void 0 ? He : "", U.version = (Ve = J.version) !== null && Ve !== void 0 ? Ve : 0, U.permission = J.permission !== void 0 && J.permission !== null ? a.ParticipantPermission.fromPartial(J.permission) : void 0, U.region = (Ze = J.region) !== null && Ze !== void 0 ? Ze : "", U.isPublisher = (Ke = J.isPublisher) !== null && Ke !== void 0 ? Ke : !1, U;
    }
  };
  function me() {
    return { mimeType: "", mid: "", cid: "", layers: [] };
  }
  a.SimulcastCodecInfo = {
    encode(J, Ee = l.default.Writer.create()) {
      J.mimeType !== "" && Ee.uint32(10).string(J.mimeType), J.mid !== "" && Ee.uint32(18).string(J.mid), J.cid !== "" && Ee.uint32(26).string(J.cid);
      for (const ue of J.layers)
        a.VideoLayer.encode(ue, Ee.uint32(34).fork()).ldelim();
      return Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = me();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.mimeType = ue.string();
            break;
          case 2:
            ve.mid = ue.string();
            break;
          case 3:
            ve.cid = ue.string();
            break;
          case 4:
            ve.layers.push(a.VideoLayer.decode(ue, ue.uint32()));
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        mimeType: Re(J.mimeType) ? String(J.mimeType) : "",
        mid: Re(J.mid) ? String(J.mid) : "",
        cid: Re(J.cid) ? String(J.cid) : "",
        layers: Array.isArray(J == null ? void 0 : J.layers) ? J.layers.map((Ee) => a.VideoLayer.fromJSON(Ee)) : []
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.mimeType !== void 0 && (Ee.mimeType = J.mimeType), J.mid !== void 0 && (Ee.mid = J.mid), J.cid !== void 0 && (Ee.cid = J.cid), J.layers ? Ee.layers = J.layers.map((ue) => ue ? a.VideoLayer.toJSON(ue) : void 0) : Ee.layers = [], Ee;
    },
    fromPartial(J) {
      var Ee, ue, ce, ve;
      const Ce = me();
      return Ce.mimeType = (Ee = J.mimeType) !== null && Ee !== void 0 ? Ee : "", Ce.mid = (ue = J.mid) !== null && ue !== void 0 ? ue : "", Ce.cid = (ce = J.cid) !== null && ce !== void 0 ? ce : "", Ce.layers = ((ve = J.layers) === null || ve === void 0 ? void 0 : ve.map((Be) => a.VideoLayer.fromPartial(Be))) || [], Ce;
    }
  };
  function Ie() {
    return {
      sid: "",
      type: 0,
      name: "",
      muted: !1,
      width: 0,
      height: 0,
      simulcast: !1,
      disableDtx: !1,
      source: 0,
      layers: [],
      mimeType: "",
      mid: "",
      codecs: [],
      stereo: !1,
      disableRed: !1
    };
  }
  a.TrackInfo = {
    encode(J, Ee = l.default.Writer.create()) {
      J.sid !== "" && Ee.uint32(10).string(J.sid), J.type !== 0 && Ee.uint32(16).int32(J.type), J.name !== "" && Ee.uint32(26).string(J.name), J.muted === !0 && Ee.uint32(32).bool(J.muted), J.width !== 0 && Ee.uint32(40).uint32(J.width), J.height !== 0 && Ee.uint32(48).uint32(J.height), J.simulcast === !0 && Ee.uint32(56).bool(J.simulcast), J.disableDtx === !0 && Ee.uint32(64).bool(J.disableDtx), J.source !== 0 && Ee.uint32(72).int32(J.source);
      for (const ue of J.layers)
        a.VideoLayer.encode(ue, Ee.uint32(82).fork()).ldelim();
      J.mimeType !== "" && Ee.uint32(90).string(J.mimeType), J.mid !== "" && Ee.uint32(98).string(J.mid);
      for (const ue of J.codecs)
        a.SimulcastCodecInfo.encode(ue, Ee.uint32(106).fork()).ldelim();
      return J.stereo === !0 && Ee.uint32(112).bool(J.stereo), J.disableRed === !0 && Ee.uint32(120).bool(J.disableRed), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = Ie();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.sid = ue.string();
            break;
          case 2:
            ve.type = ue.int32();
            break;
          case 3:
            ve.name = ue.string();
            break;
          case 4:
            ve.muted = ue.bool();
            break;
          case 5:
            ve.width = ue.uint32();
            break;
          case 6:
            ve.height = ue.uint32();
            break;
          case 7:
            ve.simulcast = ue.bool();
            break;
          case 8:
            ve.disableDtx = ue.bool();
            break;
          case 9:
            ve.source = ue.int32();
            break;
          case 10:
            ve.layers.push(a.VideoLayer.decode(ue, ue.uint32()));
            break;
          case 11:
            ve.mimeType = ue.string();
            break;
          case 12:
            ve.mid = ue.string();
            break;
          case 13:
            ve.codecs.push(a.SimulcastCodecInfo.decode(ue, ue.uint32()));
            break;
          case 14:
            ve.stereo = ue.bool();
            break;
          case 15:
            ve.disableRed = ue.bool();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        sid: Re(J.sid) ? String(J.sid) : "",
        type: Re(J.type) ? _(J.type) : 0,
        name: Re(J.name) ? String(J.name) : "",
        muted: Re(J.muted) ? !!J.muted : !1,
        width: Re(J.width) ? Number(J.width) : 0,
        height: Re(J.height) ? Number(J.height) : 0,
        simulcast: Re(J.simulcast) ? !!J.simulcast : !1,
        disableDtx: Re(J.disableDtx) ? !!J.disableDtx : !1,
        source: Re(J.source) ? $(J.source) : 0,
        layers: Array.isArray(J == null ? void 0 : J.layers) ? J.layers.map((Ee) => a.VideoLayer.fromJSON(Ee)) : [],
        mimeType: Re(J.mimeType) ? String(J.mimeType) : "",
        mid: Re(J.mid) ? String(J.mid) : "",
        codecs: Array.isArray(J == null ? void 0 : J.codecs) ? J.codecs.map((Ee) => a.SimulcastCodecInfo.fromJSON(Ee)) : [],
        stereo: Re(J.stereo) ? !!J.stereo : !1,
        disableRed: Re(J.disableRed) ? !!J.disableRed : !1
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.sid !== void 0 && (Ee.sid = J.sid), J.type !== void 0 && (Ee.type = I(J.type)), J.name !== void 0 && (Ee.name = J.name), J.muted !== void 0 && (Ee.muted = J.muted), J.width !== void 0 && (Ee.width = Math.round(J.width)), J.height !== void 0 && (Ee.height = Math.round(J.height)), J.simulcast !== void 0 && (Ee.simulcast = J.simulcast), J.disableDtx !== void 0 && (Ee.disableDtx = J.disableDtx), J.source !== void 0 && (Ee.source = F(J.source)), J.layers ? Ee.layers = J.layers.map((ue) => ue ? a.VideoLayer.toJSON(ue) : void 0) : Ee.layers = [], J.mimeType !== void 0 && (Ee.mimeType = J.mimeType), J.mid !== void 0 && (Ee.mid = J.mid), J.codecs ? Ee.codecs = J.codecs.map((ue) => ue ? a.SimulcastCodecInfo.toJSON(ue) : void 0) : Ee.codecs = [], J.stereo !== void 0 && (Ee.stereo = J.stereo), J.disableRed !== void 0 && (Ee.disableRed = J.disableRed), Ee;
    },
    fromPartial(J) {
      var Ee, ue, ce, ve, Ce, Be, He, Ve, Ze, Ke, U, se, Se, Ue, De;
      const Ye = Ie();
      return Ye.sid = (Ee = J.sid) !== null && Ee !== void 0 ? Ee : "", Ye.type = (ue = J.type) !== null && ue !== void 0 ? ue : 0, Ye.name = (ce = J.name) !== null && ce !== void 0 ? ce : "", Ye.muted = (ve = J.muted) !== null && ve !== void 0 ? ve : !1, Ye.width = (Ce = J.width) !== null && Ce !== void 0 ? Ce : 0, Ye.height = (Be = J.height) !== null && Be !== void 0 ? Be : 0, Ye.simulcast = (He = J.simulcast) !== null && He !== void 0 ? He : !1, Ye.disableDtx = (Ve = J.disableDtx) !== null && Ve !== void 0 ? Ve : !1, Ye.source = (Ze = J.source) !== null && Ze !== void 0 ? Ze : 0, Ye.layers = ((Ke = J.layers) === null || Ke === void 0 ? void 0 : Ke.map((Qe) => a.VideoLayer.fromPartial(Qe))) || [], Ye.mimeType = (U = J.mimeType) !== null && U !== void 0 ? U : "", Ye.mid = (se = J.mid) !== null && se !== void 0 ? se : "", Ye.codecs = ((Se = J.codecs) === null || Se === void 0 ? void 0 : Se.map((Qe) => a.SimulcastCodecInfo.fromPartial(Qe))) || [], Ye.stereo = (Ue = J.stereo) !== null && Ue !== void 0 ? Ue : !1, Ye.disableRed = (De = J.disableRed) !== null && De !== void 0 ? De : !1, Ye;
    }
  };
  function $e() {
    return { quality: 0, width: 0, height: 0, bitrate: 0, ssrc: 0 };
  }
  a.VideoLayer = {
    encode(J, Ee = l.default.Writer.create()) {
      return J.quality !== 0 && Ee.uint32(8).int32(J.quality), J.width !== 0 && Ee.uint32(16).uint32(J.width), J.height !== 0 && Ee.uint32(24).uint32(J.height), J.bitrate !== 0 && Ee.uint32(32).uint32(J.bitrate), J.ssrc !== 0 && Ee.uint32(40).uint32(J.ssrc), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = $e();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.quality = ue.int32();
            break;
          case 2:
            ve.width = ue.uint32();
            break;
          case 3:
            ve.height = ue.uint32();
            break;
          case 4:
            ve.bitrate = ue.uint32();
            break;
          case 5:
            ve.ssrc = ue.uint32();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        quality: Re(J.quality) ? j(J.quality) : 0,
        width: Re(J.width) ? Number(J.width) : 0,
        height: Re(J.height) ? Number(J.height) : 0,
        bitrate: Re(J.bitrate) ? Number(J.bitrate) : 0,
        ssrc: Re(J.ssrc) ? Number(J.ssrc) : 0
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.quality !== void 0 && (Ee.quality = ee(J.quality)), J.width !== void 0 && (Ee.width = Math.round(J.width)), J.height !== void 0 && (Ee.height = Math.round(J.height)), J.bitrate !== void 0 && (Ee.bitrate = Math.round(J.bitrate)), J.ssrc !== void 0 && (Ee.ssrc = Math.round(J.ssrc)), Ee;
    },
    fromPartial(J) {
      var Ee, ue, ce, ve, Ce;
      const Be = $e();
      return Be.quality = (Ee = J.quality) !== null && Ee !== void 0 ? Ee : 0, Be.width = (ue = J.width) !== null && ue !== void 0 ? ue : 0, Be.height = (ce = J.height) !== null && ce !== void 0 ? ce : 0, Be.bitrate = (ve = J.bitrate) !== null && ve !== void 0 ? ve : 0, Be.ssrc = (Ce = J.ssrc) !== null && Ce !== void 0 ? Ce : 0, Be;
    }
  };
  function ye() {
    return { kind: 0, user: void 0, speaker: void 0 };
  }
  a.DataPacket = {
    encode(J, Ee = l.default.Writer.create()) {
      return J.kind !== 0 && Ee.uint32(8).int32(J.kind), J.user !== void 0 && a.UserPacket.encode(J.user, Ee.uint32(18).fork()).ldelim(), J.speaker !== void 0 && a.ActiveSpeakerUpdate.encode(J.speaker, Ee.uint32(26).fork()).ldelim(), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = ye();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.kind = ue.int32();
            break;
          case 2:
            ve.user = a.UserPacket.decode(ue, ue.uint32());
            break;
          case 3:
            ve.speaker = a.ActiveSpeakerUpdate.decode(ue, ue.uint32());
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        kind: Re(J.kind) ? C(J.kind) : 0,
        user: Re(J.user) ? a.UserPacket.fromJSON(J.user) : void 0,
        speaker: Re(J.speaker) ? a.ActiveSpeakerUpdate.fromJSON(J.speaker) : void 0
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.kind !== void 0 && (Ee.kind = b(J.kind)), J.user !== void 0 && (Ee.user = J.user ? a.UserPacket.toJSON(J.user) : void 0), J.speaker !== void 0 && (Ee.speaker = J.speaker ? a.ActiveSpeakerUpdate.toJSON(J.speaker) : void 0), Ee;
    },
    fromPartial(J) {
      var Ee;
      const ue = ye();
      return ue.kind = (Ee = J.kind) !== null && Ee !== void 0 ? Ee : 0, ue.user = J.user !== void 0 && J.user !== null ? a.UserPacket.fromPartial(J.user) : void 0, ue.speaker = J.speaker !== void 0 && J.speaker !== null ? a.ActiveSpeakerUpdate.fromPartial(J.speaker) : void 0, ue;
    }
  };
  function fe() {
    return { speakers: [] };
  }
  a.ActiveSpeakerUpdate = {
    encode(J, Ee = l.default.Writer.create()) {
      for (const ue of J.speakers)
        a.SpeakerInfo.encode(ue, Ee.uint32(10).fork()).ldelim();
      return Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = fe();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.speakers.push(a.SpeakerInfo.decode(ue, ue.uint32()));
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        speakers: Array.isArray(J == null ? void 0 : J.speakers) ? J.speakers.map((Ee) => a.SpeakerInfo.fromJSON(Ee)) : []
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.speakers ? Ee.speakers = J.speakers.map((ue) => ue ? a.SpeakerInfo.toJSON(ue) : void 0) : Ee.speakers = [], Ee;
    },
    fromPartial(J) {
      var Ee;
      const ue = fe();
      return ue.speakers = ((Ee = J.speakers) === null || Ee === void 0 ? void 0 : Ee.map((ce) => a.SpeakerInfo.fromPartial(ce))) || [], ue;
    }
  };
  function Me() {
    return { sid: "", level: 0, active: !1 };
  }
  a.SpeakerInfo = {
    encode(J, Ee = l.default.Writer.create()) {
      return J.sid !== "" && Ee.uint32(10).string(J.sid), J.level !== 0 && Ee.uint32(21).float(J.level), J.active === !0 && Ee.uint32(24).bool(J.active), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = Me();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.sid = ue.string();
            break;
          case 2:
            ve.level = ue.float();
            break;
          case 3:
            ve.active = ue.bool();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        sid: Re(J.sid) ? String(J.sid) : "",
        level: Re(J.level) ? Number(J.level) : 0,
        active: Re(J.active) ? !!J.active : !1
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.sid !== void 0 && (Ee.sid = J.sid), J.level !== void 0 && (Ee.level = J.level), J.active !== void 0 && (Ee.active = J.active), Ee;
    },
    fromPartial(J) {
      var Ee, ue, ce;
      const ve = Me();
      return ve.sid = (Ee = J.sid) !== null && Ee !== void 0 ? Ee : "", ve.level = (ue = J.level) !== null && ue !== void 0 ? ue : 0, ve.active = (ce = J.active) !== null && ce !== void 0 ? ce : !1, ve;
    }
  };
  function Ae() {
    return { participantSid: "", payload: new Uint8Array(), destinationSids: [] };
  }
  a.UserPacket = {
    encode(J, Ee = l.default.Writer.create()) {
      J.participantSid !== "" && Ee.uint32(10).string(J.participantSid), J.payload.length !== 0 && Ee.uint32(18).bytes(J.payload);
      for (const ue of J.destinationSids)
        Ee.uint32(26).string(ue);
      return Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = Ae();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.participantSid = ue.string();
            break;
          case 2:
            ve.payload = ue.bytes();
            break;
          case 3:
            ve.destinationSids.push(ue.string());
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        participantSid: Re(J.participantSid) ? String(J.participantSid) : "",
        payload: Re(J.payload) ? yt(J.payload) : new Uint8Array(),
        destinationSids: Array.isArray(J == null ? void 0 : J.destinationSids) ? J.destinationSids.map((Ee) => String(Ee)) : []
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.participantSid !== void 0 && (Ee.participantSid = J.participantSid), J.payload !== void 0 && (Ee.payload = Xe(J.payload !== void 0 ? J.payload : new Uint8Array())), J.destinationSids ? Ee.destinationSids = J.destinationSids.map((ue) => ue) : Ee.destinationSids = [], Ee;
    },
    fromPartial(J) {
      var Ee, ue, ce;
      const ve = Ae();
      return ve.participantSid = (Ee = J.participantSid) !== null && Ee !== void 0 ? Ee : "", ve.payload = (ue = J.payload) !== null && ue !== void 0 ? ue : new Uint8Array(), ve.destinationSids = ((ce = J.destinationSids) === null || ce === void 0 ? void 0 : ce.map((Ce) => Ce)) || [], ve;
    }
  };
  function xe() {
    return { participantSid: "", trackSids: [] };
  }
  a.ParticipantTracks = {
    encode(J, Ee = l.default.Writer.create()) {
      J.participantSid !== "" && Ee.uint32(10).string(J.participantSid);
      for (const ue of J.trackSids)
        Ee.uint32(18).string(ue);
      return Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = xe();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.participantSid = ue.string();
            break;
          case 2:
            ve.trackSids.push(ue.string());
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        participantSid: Re(J.participantSid) ? String(J.participantSid) : "",
        trackSids: Array.isArray(J == null ? void 0 : J.trackSids) ? J.trackSids.map((Ee) => String(Ee)) : []
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.participantSid !== void 0 && (Ee.participantSid = J.participantSid), J.trackSids ? Ee.trackSids = J.trackSids.map((ue) => ue) : Ee.trackSids = [], Ee;
    },
    fromPartial(J) {
      var Ee, ue;
      const ce = xe();
      return ce.participantSid = (Ee = J.participantSid) !== null && Ee !== void 0 ? Ee : "", ce.trackSids = ((ue = J.trackSids) === null || ue === void 0 ? void 0 : ue.map((ve) => ve)) || [], ce;
    }
  };
  function ae() {
    return { edition: 0, version: "", protocol: 0, region: "", nodeId: "", debugInfo: "" };
  }
  a.ServerInfo = {
    encode(J, Ee = l.default.Writer.create()) {
      return J.edition !== 0 && Ee.uint32(8).int32(J.edition), J.version !== "" && Ee.uint32(18).string(J.version), J.protocol !== 0 && Ee.uint32(24).int32(J.protocol), J.region !== "" && Ee.uint32(34).string(J.region), J.nodeId !== "" && Ee.uint32(42).string(J.nodeId), J.debugInfo !== "" && Ee.uint32(50).string(J.debugInfo), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = ae();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.edition = ue.int32();
            break;
          case 2:
            ve.version = ue.string();
            break;
          case 3:
            ve.protocol = ue.int32();
            break;
          case 4:
            ve.region = ue.string();
            break;
          case 5:
            ve.nodeId = ue.string();
            break;
          case 6:
            ve.debugInfo = ue.string();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        edition: Re(J.edition) ? k(J.edition) : 0,
        version: Re(J.version) ? String(J.version) : "",
        protocol: Re(J.protocol) ? Number(J.protocol) : 0,
        region: Re(J.region) ? String(J.region) : "",
        nodeId: Re(J.nodeId) ? String(J.nodeId) : "",
        debugInfo: Re(J.debugInfo) ? String(J.debugInfo) : ""
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.edition !== void 0 && (Ee.edition = O(J.edition)), J.version !== void 0 && (Ee.version = J.version), J.protocol !== void 0 && (Ee.protocol = Math.round(J.protocol)), J.region !== void 0 && (Ee.region = J.region), J.nodeId !== void 0 && (Ee.nodeId = J.nodeId), J.debugInfo !== void 0 && (Ee.debugInfo = J.debugInfo), Ee;
    },
    fromPartial(J) {
      var Ee, ue, ce, ve, Ce, Be;
      const He = ae();
      return He.edition = (Ee = J.edition) !== null && Ee !== void 0 ? Ee : 0, He.version = (ue = J.version) !== null && ue !== void 0 ? ue : "", He.protocol = (ce = J.protocol) !== null && ce !== void 0 ? ce : 0, He.region = (ve = J.region) !== null && ve !== void 0 ? ve : "", He.nodeId = (Ce = J.nodeId) !== null && Ce !== void 0 ? Ce : "", He.debugInfo = (Be = J.debugInfo) !== null && Be !== void 0 ? Be : "", He;
    }
  };
  function N() {
    return {
      sdk: 0,
      version: "",
      protocol: 0,
      os: "",
      osVersion: "",
      deviceModel: "",
      browser: "",
      browserVersion: "",
      address: "",
      network: ""
    };
  }
  a.ClientInfo = {
    encode(J, Ee = l.default.Writer.create()) {
      return J.sdk !== 0 && Ee.uint32(8).int32(J.sdk), J.version !== "" && Ee.uint32(18).string(J.version), J.protocol !== 0 && Ee.uint32(24).int32(J.protocol), J.os !== "" && Ee.uint32(34).string(J.os), J.osVersion !== "" && Ee.uint32(42).string(J.osVersion), J.deviceModel !== "" && Ee.uint32(50).string(J.deviceModel), J.browser !== "" && Ee.uint32(58).string(J.browser), J.browserVersion !== "" && Ee.uint32(66).string(J.browserVersion), J.address !== "" && Ee.uint32(74).string(J.address), J.network !== "" && Ee.uint32(82).string(J.network), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = N();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.sdk = ue.int32();
            break;
          case 2:
            ve.version = ue.string();
            break;
          case 3:
            ve.protocol = ue.int32();
            break;
          case 4:
            ve.os = ue.string();
            break;
          case 5:
            ve.osVersion = ue.string();
            break;
          case 6:
            ve.deviceModel = ue.string();
            break;
          case 7:
            ve.browser = ue.string();
            break;
          case 8:
            ve.browserVersion = ue.string();
            break;
          case 9:
            ve.address = ue.string();
            break;
          case 10:
            ve.network = ue.string();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        sdk: Re(J.sdk) ? x(J.sdk) : 0,
        version: Re(J.version) ? String(J.version) : "",
        protocol: Re(J.protocol) ? Number(J.protocol) : 0,
        os: Re(J.os) ? String(J.os) : "",
        osVersion: Re(J.osVersion) ? String(J.osVersion) : "",
        deviceModel: Re(J.deviceModel) ? String(J.deviceModel) : "",
        browser: Re(J.browser) ? String(J.browser) : "",
        browserVersion: Re(J.browserVersion) ? String(J.browserVersion) : "",
        address: Re(J.address) ? String(J.address) : "",
        network: Re(J.network) ? String(J.network) : ""
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.sdk !== void 0 && (Ee.sdk = Y(J.sdk)), J.version !== void 0 && (Ee.version = J.version), J.protocol !== void 0 && (Ee.protocol = Math.round(J.protocol)), J.os !== void 0 && (Ee.os = J.os), J.osVersion !== void 0 && (Ee.osVersion = J.osVersion), J.deviceModel !== void 0 && (Ee.deviceModel = J.deviceModel), J.browser !== void 0 && (Ee.browser = J.browser), J.browserVersion !== void 0 && (Ee.browserVersion = J.browserVersion), J.address !== void 0 && (Ee.address = J.address), J.network !== void 0 && (Ee.network = J.network), Ee;
    },
    fromPartial(J) {
      var Ee, ue, ce, ve, Ce, Be, He, Ve, Ze, Ke;
      const U = N();
      return U.sdk = (Ee = J.sdk) !== null && Ee !== void 0 ? Ee : 0, U.version = (ue = J.version) !== null && ue !== void 0 ? ue : "", U.protocol = (ce = J.protocol) !== null && ce !== void 0 ? ce : 0, U.os = (ve = J.os) !== null && ve !== void 0 ? ve : "", U.osVersion = (Ce = J.osVersion) !== null && Ce !== void 0 ? Ce : "", U.deviceModel = (Be = J.deviceModel) !== null && Be !== void 0 ? Be : "", U.browser = (He = J.browser) !== null && He !== void 0 ? He : "", U.browserVersion = (Ve = J.browserVersion) !== null && Ve !== void 0 ? Ve : "", U.address = (Ze = J.address) !== null && Ze !== void 0 ? Ze : "", U.network = (Ke = J.network) !== null && Ke !== void 0 ? Ke : "", U;
    }
  };
  function re() {
    return { video: void 0, screen: void 0, resumeConnection: 0, disabledCodecs: void 0, forceRelay: 0 };
  }
  a.ClientConfiguration = {
    encode(J, Ee = l.default.Writer.create()) {
      return J.video !== void 0 && a.VideoConfiguration.encode(J.video, Ee.uint32(10).fork()).ldelim(), J.screen !== void 0 && a.VideoConfiguration.encode(J.screen, Ee.uint32(18).fork()).ldelim(), J.resumeConnection !== 0 && Ee.uint32(24).int32(J.resumeConnection), J.disabledCodecs !== void 0 && a.DisabledCodecs.encode(J.disabledCodecs, Ee.uint32(34).fork()).ldelim(), J.forceRelay !== 0 && Ee.uint32(40).int32(J.forceRelay), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = re();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.video = a.VideoConfiguration.decode(ue, ue.uint32());
            break;
          case 2:
            ve.screen = a.VideoConfiguration.decode(ue, ue.uint32());
            break;
          case 3:
            ve.resumeConnection = ue.int32();
            break;
          case 4:
            ve.disabledCodecs = a.DisabledCodecs.decode(ue, ue.uint32());
            break;
          case 5:
            ve.forceRelay = ue.int32();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        video: Re(J.video) ? a.VideoConfiguration.fromJSON(J.video) : void 0,
        screen: Re(J.screen) ? a.VideoConfiguration.fromJSON(J.screen) : void 0,
        resumeConnection: Re(J.resumeConnection) ? Z(J.resumeConnection) : 0,
        disabledCodecs: Re(J.disabledCodecs) ? a.DisabledCodecs.fromJSON(J.disabledCodecs) : void 0,
        forceRelay: Re(J.forceRelay) ? Z(J.forceRelay) : 0
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.video !== void 0 && (Ee.video = J.video ? a.VideoConfiguration.toJSON(J.video) : void 0), J.screen !== void 0 && (Ee.screen = J.screen ? a.VideoConfiguration.toJSON(J.screen) : void 0), J.resumeConnection !== void 0 && (Ee.resumeConnection = de(J.resumeConnection)), J.disabledCodecs !== void 0 && (Ee.disabledCodecs = J.disabledCodecs ? a.DisabledCodecs.toJSON(J.disabledCodecs) : void 0), J.forceRelay !== void 0 && (Ee.forceRelay = de(J.forceRelay)), Ee;
    },
    fromPartial(J) {
      var Ee, ue;
      const ce = re();
      return ce.video = J.video !== void 0 && J.video !== null ? a.VideoConfiguration.fromPartial(J.video) : void 0, ce.screen = J.screen !== void 0 && J.screen !== null ? a.VideoConfiguration.fromPartial(J.screen) : void 0, ce.resumeConnection = (Ee = J.resumeConnection) !== null && Ee !== void 0 ? Ee : 0, ce.disabledCodecs = J.disabledCodecs !== void 0 && J.disabledCodecs !== null ? a.DisabledCodecs.fromPartial(J.disabledCodecs) : void 0, ce.forceRelay = (ue = J.forceRelay) !== null && ue !== void 0 ? ue : 0, ce;
    }
  };
  function le() {
    return { hardwareEncoder: 0 };
  }
  a.VideoConfiguration = {
    encode(J, Ee = l.default.Writer.create()) {
      return J.hardwareEncoder !== 0 && Ee.uint32(8).int32(J.hardwareEncoder), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = le();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.hardwareEncoder = ue.int32();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return { hardwareEncoder: Re(J.hardwareEncoder) ? Z(J.hardwareEncoder) : 0 };
    },
    toJSON(J) {
      const Ee = {};
      return J.hardwareEncoder !== void 0 && (Ee.hardwareEncoder = de(J.hardwareEncoder)), Ee;
    },
    fromPartial(J) {
      var Ee;
      const ue = le();
      return ue.hardwareEncoder = (Ee = J.hardwareEncoder) !== null && Ee !== void 0 ? Ee : 0, ue;
    }
  };
  function Ne() {
    return { codecs: [] };
  }
  a.DisabledCodecs = {
    encode(J, Ee = l.default.Writer.create()) {
      for (const ue of J.codecs)
        a.Codec.encode(ue, Ee.uint32(10).fork()).ldelim();
      return Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = Ne();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.codecs.push(a.Codec.decode(ue, ue.uint32()));
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return { codecs: Array.isArray(J == null ? void 0 : J.codecs) ? J.codecs.map((Ee) => a.Codec.fromJSON(Ee)) : [] };
    },
    toJSON(J) {
      const Ee = {};
      return J.codecs ? Ee.codecs = J.codecs.map((ue) => ue ? a.Codec.toJSON(ue) : void 0) : Ee.codecs = [], Ee;
    },
    fromPartial(J) {
      var Ee;
      const ue = Ne();
      return ue.codecs = ((Ee = J.codecs) === null || Ee === void 0 ? void 0 : Ee.map((ce) => a.Codec.fromPartial(ce))) || [], ue;
    }
  };
  function Oe() {
    return {
      startTime: void 0,
      endTime: void 0,
      duration: 0,
      packets: 0,
      packetRate: 0,
      bytes: 0,
      headerBytes: 0,
      bitrate: 0,
      packetsLost: 0,
      packetLossRate: 0,
      packetLossPercentage: 0,
      packetsDuplicate: 0,
      packetDuplicateRate: 0,
      bytesDuplicate: 0,
      headerBytesDuplicate: 0,
      bitrateDuplicate: 0,
      packetsPadding: 0,
      packetPaddingRate: 0,
      bytesPadding: 0,
      headerBytesPadding: 0,
      bitratePadding: 0,
      packetsOutOfOrder: 0,
      frames: 0,
      frameRate: 0,
      jitterCurrent: 0,
      jitterMax: 0,
      gapHistogram: {},
      nacks: 0,
      nackAcks: 0,
      nackMisses: 0,
      nackRepeated: 0,
      plis: 0,
      lastPli: void 0,
      firs: 0,
      lastFir: void 0,
      rttCurrent: 0,
      rttMax: 0,
      keyFrames: 0,
      lastKeyFrame: void 0,
      layerLockPlis: 0,
      lastLayerLockPli: void 0
    };
  }
  a.RTPStats = {
    encode(J, Ee = l.default.Writer.create()) {
      return J.startTime !== void 0 && v.Timestamp.encode(Ge(J.startTime), Ee.uint32(10).fork()).ldelim(), J.endTime !== void 0 && v.Timestamp.encode(Ge(J.endTime), Ee.uint32(18).fork()).ldelim(), J.duration !== 0 && Ee.uint32(25).double(J.duration), J.packets !== 0 && Ee.uint32(32).uint32(J.packets), J.packetRate !== 0 && Ee.uint32(41).double(J.packetRate), J.bytes !== 0 && Ee.uint32(48).uint64(J.bytes), J.headerBytes !== 0 && Ee.uint32(312).uint64(J.headerBytes), J.bitrate !== 0 && Ee.uint32(57).double(J.bitrate), J.packetsLost !== 0 && Ee.uint32(64).uint32(J.packetsLost), J.packetLossRate !== 0 && Ee.uint32(73).double(J.packetLossRate), J.packetLossPercentage !== 0 && Ee.uint32(85).float(J.packetLossPercentage), J.packetsDuplicate !== 0 && Ee.uint32(88).uint32(J.packetsDuplicate), J.packetDuplicateRate !== 0 && Ee.uint32(97).double(J.packetDuplicateRate), J.bytesDuplicate !== 0 && Ee.uint32(104).uint64(J.bytesDuplicate), J.headerBytesDuplicate !== 0 && Ee.uint32(320).uint64(J.headerBytesDuplicate), J.bitrateDuplicate !== 0 && Ee.uint32(113).double(J.bitrateDuplicate), J.packetsPadding !== 0 && Ee.uint32(120).uint32(J.packetsPadding), J.packetPaddingRate !== 0 && Ee.uint32(129).double(J.packetPaddingRate), J.bytesPadding !== 0 && Ee.uint32(136).uint64(J.bytesPadding), J.headerBytesPadding !== 0 && Ee.uint32(328).uint64(J.headerBytesPadding), J.bitratePadding !== 0 && Ee.uint32(145).double(J.bitratePadding), J.packetsOutOfOrder !== 0 && Ee.uint32(152).uint32(J.packetsOutOfOrder), J.frames !== 0 && Ee.uint32(160).uint32(J.frames), J.frameRate !== 0 && Ee.uint32(169).double(J.frameRate), J.jitterCurrent !== 0 && Ee.uint32(177).double(J.jitterCurrent), J.jitterMax !== 0 && Ee.uint32(185).double(J.jitterMax), Object.entries(J.gapHistogram).forEach(([ue, ce]) => {
        a.RTPStats_GapHistogramEntry.encode({ key: ue, value: ce }, Ee.uint32(194).fork()).ldelim();
      }), J.nacks !== 0 && Ee.uint32(200).uint32(J.nacks), J.nackAcks !== 0 && Ee.uint32(296).uint32(J.nackAcks), J.nackMisses !== 0 && Ee.uint32(208).uint32(J.nackMisses), J.nackRepeated !== 0 && Ee.uint32(304).uint32(J.nackRepeated), J.plis !== 0 && Ee.uint32(216).uint32(J.plis), J.lastPli !== void 0 && v.Timestamp.encode(Ge(J.lastPli), Ee.uint32(226).fork()).ldelim(), J.firs !== 0 && Ee.uint32(232).uint32(J.firs), J.lastFir !== void 0 && v.Timestamp.encode(Ge(J.lastFir), Ee.uint32(242).fork()).ldelim(), J.rttCurrent !== 0 && Ee.uint32(248).uint32(J.rttCurrent), J.rttMax !== 0 && Ee.uint32(256).uint32(J.rttMax), J.keyFrames !== 0 && Ee.uint32(264).uint32(J.keyFrames), J.lastKeyFrame !== void 0 && v.Timestamp.encode(Ge(J.lastKeyFrame), Ee.uint32(274).fork()).ldelim(), J.layerLockPlis !== 0 && Ee.uint32(280).uint32(J.layerLockPlis), J.lastLayerLockPli !== void 0 && v.Timestamp.encode(Ge(J.lastLayerLockPli), Ee.uint32(290).fork()).ldelim(), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = Oe();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.startTime = V(v.Timestamp.decode(ue, ue.uint32()));
            break;
          case 2:
            ve.endTime = V(v.Timestamp.decode(ue, ue.uint32()));
            break;
          case 3:
            ve.duration = ue.double();
            break;
          case 4:
            ve.packets = ue.uint32();
            break;
          case 5:
            ve.packetRate = ue.double();
            break;
          case 6:
            ve.bytes = Te(ue.uint64());
            break;
          case 39:
            ve.headerBytes = Te(ue.uint64());
            break;
          case 7:
            ve.bitrate = ue.double();
            break;
          case 8:
            ve.packetsLost = ue.uint32();
            break;
          case 9:
            ve.packetLossRate = ue.double();
            break;
          case 10:
            ve.packetLossPercentage = ue.float();
            break;
          case 11:
            ve.packetsDuplicate = ue.uint32();
            break;
          case 12:
            ve.packetDuplicateRate = ue.double();
            break;
          case 13:
            ve.bytesDuplicate = Te(ue.uint64());
            break;
          case 40:
            ve.headerBytesDuplicate = Te(ue.uint64());
            break;
          case 14:
            ve.bitrateDuplicate = ue.double();
            break;
          case 15:
            ve.packetsPadding = ue.uint32();
            break;
          case 16:
            ve.packetPaddingRate = ue.double();
            break;
          case 17:
            ve.bytesPadding = Te(ue.uint64());
            break;
          case 41:
            ve.headerBytesPadding = Te(ue.uint64());
            break;
          case 18:
            ve.bitratePadding = ue.double();
            break;
          case 19:
            ve.packetsOutOfOrder = ue.uint32();
            break;
          case 20:
            ve.frames = ue.uint32();
            break;
          case 21:
            ve.frameRate = ue.double();
            break;
          case 22:
            ve.jitterCurrent = ue.double();
            break;
          case 23:
            ve.jitterMax = ue.double();
            break;
          case 24:
            const Be = a.RTPStats_GapHistogramEntry.decode(ue, ue.uint32());
            Be.value !== void 0 && (ve.gapHistogram[Be.key] = Be.value);
            break;
          case 25:
            ve.nacks = ue.uint32();
            break;
          case 37:
            ve.nackAcks = ue.uint32();
            break;
          case 26:
            ve.nackMisses = ue.uint32();
            break;
          case 38:
            ve.nackRepeated = ue.uint32();
            break;
          case 27:
            ve.plis = ue.uint32();
            break;
          case 28:
            ve.lastPli = V(v.Timestamp.decode(ue, ue.uint32()));
            break;
          case 29:
            ve.firs = ue.uint32();
            break;
          case 30:
            ve.lastFir = V(v.Timestamp.decode(ue, ue.uint32()));
            break;
          case 31:
            ve.rttCurrent = ue.uint32();
            break;
          case 32:
            ve.rttMax = ue.uint32();
            break;
          case 33:
            ve.keyFrames = ue.uint32();
            break;
          case 34:
            ve.lastKeyFrame = V(v.Timestamp.decode(ue, ue.uint32()));
            break;
          case 35:
            ve.layerLockPlis = ue.uint32();
            break;
          case 36:
            ve.lastLayerLockPli = V(v.Timestamp.decode(ue, ue.uint32()));
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        startTime: Re(J.startTime) ? ge(J.startTime) : void 0,
        endTime: Re(J.endTime) ? ge(J.endTime) : void 0,
        duration: Re(J.duration) ? Number(J.duration) : 0,
        packets: Re(J.packets) ? Number(J.packets) : 0,
        packetRate: Re(J.packetRate) ? Number(J.packetRate) : 0,
        bytes: Re(J.bytes) ? Number(J.bytes) : 0,
        headerBytes: Re(J.headerBytes) ? Number(J.headerBytes) : 0,
        bitrate: Re(J.bitrate) ? Number(J.bitrate) : 0,
        packetsLost: Re(J.packetsLost) ? Number(J.packetsLost) : 0,
        packetLossRate: Re(J.packetLossRate) ? Number(J.packetLossRate) : 0,
        packetLossPercentage: Re(J.packetLossPercentage) ? Number(J.packetLossPercentage) : 0,
        packetsDuplicate: Re(J.packetsDuplicate) ? Number(J.packetsDuplicate) : 0,
        packetDuplicateRate: Re(J.packetDuplicateRate) ? Number(J.packetDuplicateRate) : 0,
        bytesDuplicate: Re(J.bytesDuplicate) ? Number(J.bytesDuplicate) : 0,
        headerBytesDuplicate: Re(J.headerBytesDuplicate) ? Number(J.headerBytesDuplicate) : 0,
        bitrateDuplicate: Re(J.bitrateDuplicate) ? Number(J.bitrateDuplicate) : 0,
        packetsPadding: Re(J.packetsPadding) ? Number(J.packetsPadding) : 0,
        packetPaddingRate: Re(J.packetPaddingRate) ? Number(J.packetPaddingRate) : 0,
        bytesPadding: Re(J.bytesPadding) ? Number(J.bytesPadding) : 0,
        headerBytesPadding: Re(J.headerBytesPadding) ? Number(J.headerBytesPadding) : 0,
        bitratePadding: Re(J.bitratePadding) ? Number(J.bitratePadding) : 0,
        packetsOutOfOrder: Re(J.packetsOutOfOrder) ? Number(J.packetsOutOfOrder) : 0,
        frames: Re(J.frames) ? Number(J.frames) : 0,
        frameRate: Re(J.frameRate) ? Number(J.frameRate) : 0,
        jitterCurrent: Re(J.jitterCurrent) ? Number(J.jitterCurrent) : 0,
        jitterMax: Re(J.jitterMax) ? Number(J.jitterMax) : 0,
        gapHistogram: We(J.gapHistogram) ? Object.entries(J.gapHistogram).reduce((Ee, [ue, ce]) => (Ee[Number(ue)] = Number(ce), Ee), {}) : {},
        nacks: Re(J.nacks) ? Number(J.nacks) : 0,
        nackAcks: Re(J.nackAcks) ? Number(J.nackAcks) : 0,
        nackMisses: Re(J.nackMisses) ? Number(J.nackMisses) : 0,
        nackRepeated: Re(J.nackRepeated) ? Number(J.nackRepeated) : 0,
        plis: Re(J.plis) ? Number(J.plis) : 0,
        lastPli: Re(J.lastPli) ? ge(J.lastPli) : void 0,
        firs: Re(J.firs) ? Number(J.firs) : 0,
        lastFir: Re(J.lastFir) ? ge(J.lastFir) : void 0,
        rttCurrent: Re(J.rttCurrent) ? Number(J.rttCurrent) : 0,
        rttMax: Re(J.rttMax) ? Number(J.rttMax) : 0,
        keyFrames: Re(J.keyFrames) ? Number(J.keyFrames) : 0,
        lastKeyFrame: Re(J.lastKeyFrame) ? ge(J.lastKeyFrame) : void 0,
        layerLockPlis: Re(J.layerLockPlis) ? Number(J.layerLockPlis) : 0,
        lastLayerLockPli: Re(J.lastLayerLockPli) ? ge(J.lastLayerLockPli) : void 0
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.startTime !== void 0 && (Ee.startTime = J.startTime.toISOString()), J.endTime !== void 0 && (Ee.endTime = J.endTime.toISOString()), J.duration !== void 0 && (Ee.duration = J.duration), J.packets !== void 0 && (Ee.packets = Math.round(J.packets)), J.packetRate !== void 0 && (Ee.packetRate = J.packetRate), J.bytes !== void 0 && (Ee.bytes = Math.round(J.bytes)), J.headerBytes !== void 0 && (Ee.headerBytes = Math.round(J.headerBytes)), J.bitrate !== void 0 && (Ee.bitrate = J.bitrate), J.packetsLost !== void 0 && (Ee.packetsLost = Math.round(J.packetsLost)), J.packetLossRate !== void 0 && (Ee.packetLossRate = J.packetLossRate), J.packetLossPercentage !== void 0 && (Ee.packetLossPercentage = J.packetLossPercentage), J.packetsDuplicate !== void 0 && (Ee.packetsDuplicate = Math.round(J.packetsDuplicate)), J.packetDuplicateRate !== void 0 && (Ee.packetDuplicateRate = J.packetDuplicateRate), J.bytesDuplicate !== void 0 && (Ee.bytesDuplicate = Math.round(J.bytesDuplicate)), J.headerBytesDuplicate !== void 0 && (Ee.headerBytesDuplicate = Math.round(J.headerBytesDuplicate)), J.bitrateDuplicate !== void 0 && (Ee.bitrateDuplicate = J.bitrateDuplicate), J.packetsPadding !== void 0 && (Ee.packetsPadding = Math.round(J.packetsPadding)), J.packetPaddingRate !== void 0 && (Ee.packetPaddingRate = J.packetPaddingRate), J.bytesPadding !== void 0 && (Ee.bytesPadding = Math.round(J.bytesPadding)), J.headerBytesPadding !== void 0 && (Ee.headerBytesPadding = Math.round(J.headerBytesPadding)), J.bitratePadding !== void 0 && (Ee.bitratePadding = J.bitratePadding), J.packetsOutOfOrder !== void 0 && (Ee.packetsOutOfOrder = Math.round(J.packetsOutOfOrder)), J.frames !== void 0 && (Ee.frames = Math.round(J.frames)), J.frameRate !== void 0 && (Ee.frameRate = J.frameRate), J.jitterCurrent !== void 0 && (Ee.jitterCurrent = J.jitterCurrent), J.jitterMax !== void 0 && (Ee.jitterMax = J.jitterMax), Ee.gapHistogram = {}, J.gapHistogram && Object.entries(J.gapHistogram).forEach(([ue, ce]) => {
        Ee.gapHistogram[ue] = Math.round(ce);
      }), J.nacks !== void 0 && (Ee.nacks = Math.round(J.nacks)), J.nackAcks !== void 0 && (Ee.nackAcks = Math.round(J.nackAcks)), J.nackMisses !== void 0 && (Ee.nackMisses = Math.round(J.nackMisses)), J.nackRepeated !== void 0 && (Ee.nackRepeated = Math.round(J.nackRepeated)), J.plis !== void 0 && (Ee.plis = Math.round(J.plis)), J.lastPli !== void 0 && (Ee.lastPli = J.lastPli.toISOString()), J.firs !== void 0 && (Ee.firs = Math.round(J.firs)), J.lastFir !== void 0 && (Ee.lastFir = J.lastFir.toISOString()), J.rttCurrent !== void 0 && (Ee.rttCurrent = Math.round(J.rttCurrent)), J.rttMax !== void 0 && (Ee.rttMax = Math.round(J.rttMax)), J.keyFrames !== void 0 && (Ee.keyFrames = Math.round(J.keyFrames)), J.lastKeyFrame !== void 0 && (Ee.lastKeyFrame = J.lastKeyFrame.toISOString()), J.layerLockPlis !== void 0 && (Ee.layerLockPlis = Math.round(J.layerLockPlis)), J.lastLayerLockPli !== void 0 && (Ee.lastLayerLockPli = J.lastLayerLockPli.toISOString()), Ee;
    },
    fromPartial(J) {
      var Ee, ue, ce, ve, Ce, Be, He, Ve, Ze, Ke, U, se, Se, Ue, De, Ye, Qe, st, St, tt, it, Tt, rt, dt, wt, nt, at, gt, ot, ct, Ct, ut, lt, kt, Rt, Je, ze, et, pt, mt, vt;
      const ht = Oe();
      return ht.startTime = (Ee = J.startTime) !== null && Ee !== void 0 ? Ee : void 0, ht.endTime = (ue = J.endTime) !== null && ue !== void 0 ? ue : void 0, ht.duration = (ce = J.duration) !== null && ce !== void 0 ? ce : 0, ht.packets = (ve = J.packets) !== null && ve !== void 0 ? ve : 0, ht.packetRate = (Ce = J.packetRate) !== null && Ce !== void 0 ? Ce : 0, ht.bytes = (Be = J.bytes) !== null && Be !== void 0 ? Be : 0, ht.headerBytes = (He = J.headerBytes) !== null && He !== void 0 ? He : 0, ht.bitrate = (Ve = J.bitrate) !== null && Ve !== void 0 ? Ve : 0, ht.packetsLost = (Ze = J.packetsLost) !== null && Ze !== void 0 ? Ze : 0, ht.packetLossRate = (Ke = J.packetLossRate) !== null && Ke !== void 0 ? Ke : 0, ht.packetLossPercentage = (U = J.packetLossPercentage) !== null && U !== void 0 ? U : 0, ht.packetsDuplicate = (se = J.packetsDuplicate) !== null && se !== void 0 ? se : 0, ht.packetDuplicateRate = (Se = J.packetDuplicateRate) !== null && Se !== void 0 ? Se : 0, ht.bytesDuplicate = (Ue = J.bytesDuplicate) !== null && Ue !== void 0 ? Ue : 0, ht.headerBytesDuplicate = (De = J.headerBytesDuplicate) !== null && De !== void 0 ? De : 0, ht.bitrateDuplicate = (Ye = J.bitrateDuplicate) !== null && Ye !== void 0 ? Ye : 0, ht.packetsPadding = (Qe = J.packetsPadding) !== null && Qe !== void 0 ? Qe : 0, ht.packetPaddingRate = (st = J.packetPaddingRate) !== null && st !== void 0 ? st : 0, ht.bytesPadding = (St = J.bytesPadding) !== null && St !== void 0 ? St : 0, ht.headerBytesPadding = (tt = J.headerBytesPadding) !== null && tt !== void 0 ? tt : 0, ht.bitratePadding = (it = J.bitratePadding) !== null && it !== void 0 ? it : 0, ht.packetsOutOfOrder = (Tt = J.packetsOutOfOrder) !== null && Tt !== void 0 ? Tt : 0, ht.frames = (rt = J.frames) !== null && rt !== void 0 ? rt : 0, ht.frameRate = (dt = J.frameRate) !== null && dt !== void 0 ? dt : 0, ht.jitterCurrent = (wt = J.jitterCurrent) !== null && wt !== void 0 ? wt : 0, ht.jitterMax = (nt = J.jitterMax) !== null && nt !== void 0 ? nt : 0, ht.gapHistogram = Object.entries((at = J.gapHistogram) !== null && at !== void 0 ? at : {}).reduce((_t, [Et, Pt]) => (Pt !== void 0 && (_t[Number(Et)] = Number(Pt)), _t), {}), ht.nacks = (gt = J.nacks) !== null && gt !== void 0 ? gt : 0, ht.nackAcks = (ot = J.nackAcks) !== null && ot !== void 0 ? ot : 0, ht.nackMisses = (ct = J.nackMisses) !== null && ct !== void 0 ? ct : 0, ht.nackRepeated = (Ct = J.nackRepeated) !== null && Ct !== void 0 ? Ct : 0, ht.plis = (ut = J.plis) !== null && ut !== void 0 ? ut : 0, ht.lastPli = (lt = J.lastPli) !== null && lt !== void 0 ? lt : void 0, ht.firs = (kt = J.firs) !== null && kt !== void 0 ? kt : 0, ht.lastFir = (Rt = J.lastFir) !== null && Rt !== void 0 ? Rt : void 0, ht.rttCurrent = (Je = J.rttCurrent) !== null && Je !== void 0 ? Je : 0, ht.rttMax = (ze = J.rttMax) !== null && ze !== void 0 ? ze : 0, ht.keyFrames = (et = J.keyFrames) !== null && et !== void 0 ? et : 0, ht.lastKeyFrame = (pt = J.lastKeyFrame) !== null && pt !== void 0 ? pt : void 0, ht.layerLockPlis = (mt = J.layerLockPlis) !== null && mt !== void 0 ? mt : 0, ht.lastLayerLockPli = (vt = J.lastLayerLockPli) !== null && vt !== void 0 ? vt : void 0, ht;
    }
  };
  function qe() {
    return { key: 0, value: 0 };
  }
  a.RTPStats_GapHistogramEntry = {
    encode(J, Ee = l.default.Writer.create()) {
      return J.key !== 0 && Ee.uint32(8).int32(J.key), J.value !== 0 && Ee.uint32(16).uint32(J.value), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = qe();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.key = ue.int32();
            break;
          case 2:
            ve.value = ue.uint32();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return { key: Re(J.key) ? Number(J.key) : 0, value: Re(J.value) ? Number(J.value) : 0 };
    },
    toJSON(J) {
      const Ee = {};
      return J.key !== void 0 && (Ee.key = Math.round(J.key)), J.value !== void 0 && (Ee.value = Math.round(J.value)), Ee;
    },
    fromPartial(J) {
      var Ee, ue;
      const ce = qe();
      return ce.key = (Ee = J.key) !== null && Ee !== void 0 ? Ee : 0, ce.value = (ue = J.value) !== null && ue !== void 0 ? ue : 0, ce;
    }
  };
  function je() {
    return { unixMicro: 0, ticks: 0 };
  }
  a.TimedVersion = {
    encode(J, Ee = l.default.Writer.create()) {
      return J.unixMicro !== 0 && Ee.uint32(8).int64(J.unixMicro), J.ticks !== 0 && Ee.uint32(16).int32(J.ticks), Ee;
    },
    decode(J, Ee) {
      const ue = J instanceof l.default.Reader ? J : new l.default.Reader(J);
      let ce = Ee === void 0 ? ue.len : ue.pos + Ee;
      const ve = je();
      for (; ue.pos < ce; ) {
        const Ce = ue.uint32();
        switch (Ce >>> 3) {
          case 1:
            ve.unixMicro = Te(ue.int64());
            break;
          case 2:
            ve.ticks = ue.int32();
            break;
          default:
            ue.skipType(Ce & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(J) {
      return {
        unixMicro: Re(J.unixMicro) ? Number(J.unixMicro) : 0,
        ticks: Re(J.ticks) ? Number(J.ticks) : 0
      };
    },
    toJSON(J) {
      const Ee = {};
      return J.unixMicro !== void 0 && (Ee.unixMicro = Math.round(J.unixMicro)), J.ticks !== void 0 && (Ee.ticks = Math.round(J.ticks)), Ee;
    },
    fromPartial(J) {
      var Ee, ue;
      const ce = je();
      return ce.unixMicro = (Ee = J.unixMicro) !== null && Ee !== void 0 ? Ee : 0, ce.ticks = (ue = J.ticks) !== null && ue !== void 0 ? ue : 0, ce;
    }
  };
  var Fe = (() => {
    if (typeof Fe < "u")
      return Fe;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function yt(J) {
    if (Fe.Buffer)
      return Uint8Array.from(Fe.Buffer.from(J, "base64"));
    {
      const Ee = Fe.atob(J), ue = new Uint8Array(Ee.length);
      for (let ce = 0; ce < Ee.length; ++ce)
        ue[ce] = Ee.charCodeAt(ce);
      return ue;
    }
  }
  function Xe(J) {
    if (Fe.Buffer)
      return Fe.Buffer.from(J).toString("base64");
    {
      const Ee = [];
      return J.forEach((ue) => {
        Ee.push(String.fromCharCode(ue));
      }), Fe.btoa(Ee.join(""));
    }
  }
  function Ge(J) {
    const Ee = J.getTime() / 1e3, ue = J.getTime() % 1e3 * 1e6;
    return { seconds: Ee, nanos: ue };
  }
  function V(J) {
    let Ee = J.seconds * 1e3;
    return Ee += J.nanos / 1e6, new Date(Ee);
  }
  function ge(J) {
    return J instanceof Date ? J : typeof J == "string" ? new Date(J) : V(v.Timestamp.fromJSON(J));
  }
  function Te(J) {
    if (J.gt(Number.MAX_SAFE_INTEGER))
      throw new Fe.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return J.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function We(J) {
    return typeof J == "object" && J !== null;
  }
  function Re(J) {
    return J != null;
  }
})(livekit_models);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(q) {
    return q && q.__esModule ? q : { default: q };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.DeleteIngressRequest = a.ListIngressResponse = a.ListIngressRequest = a.UpdateIngressRequest = a.InputAudioState = a.InputVideoState = a.IngressState = a.IngressInfo = a.IngressVideoOptions = a.IngressAudioOptions = a.CreateIngressRequest = a.ingressState_StatusToJSON = a.ingressState_StatusFromJSON = a.IngressState_Status = a.ingressInputToJSON = a.ingressInputFromJSON = a.IngressInput = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_models;
  a.protobufPackage = "livekit";
  var p;
  (function(q) {
    q[q.RTMP_INPUT = 0] = "RTMP_INPUT", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p = a.IngressInput || (a.IngressInput = {}));
  function _(q) {
    switch (q) {
      case 0:
      case "RTMP_INPUT":
        return p.RTMP_INPUT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  a.ingressInputFromJSON = _;
  function I(q) {
    switch (q) {
      case p.RTMP_INPUT:
        return "RTMP_INPUT";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.ingressInputToJSON = I;
  var P;
  (function(q) {
    q[q.ENDPOINT_INACTIVE = 0] = "ENDPOINT_INACTIVE", q[q.ENDPOINT_BUFFERING = 1] = "ENDPOINT_BUFFERING", q[q.ENDPOINT_PUBLISHING = 2] = "ENDPOINT_PUBLISHING", q[q.ENDPOINT_ERROR = 3] = "ENDPOINT_ERROR", q[q.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(P = a.IngressState_Status || (a.IngressState_Status = {}));
  function $(q) {
    switch (q) {
      case 0:
      case "ENDPOINT_INACTIVE":
        return P.ENDPOINT_INACTIVE;
      case 1:
      case "ENDPOINT_BUFFERING":
        return P.ENDPOINT_BUFFERING;
      case 2:
      case "ENDPOINT_PUBLISHING":
        return P.ENDPOINT_PUBLISHING;
      case 3:
      case "ENDPOINT_ERROR":
        return P.ENDPOINT_ERROR;
      case -1:
      case "UNRECOGNIZED":
      default:
        return P.UNRECOGNIZED;
    }
  }
  a.ingressState_StatusFromJSON = $;
  function F(q) {
    switch (q) {
      case P.ENDPOINT_INACTIVE:
        return "ENDPOINT_INACTIVE";
      case P.ENDPOINT_BUFFERING:
        return "ENDPOINT_BUFFERING";
      case P.ENDPOINT_PUBLISHING:
        return "ENDPOINT_PUBLISHING";
      case P.ENDPOINT_ERROR:
        return "ENDPOINT_ERROR";
      case P.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.ingressState_StatusToJSON = F;
  function H() {
    return {
      inputType: 0,
      name: "",
      roomName: "",
      participantIdentity: "",
      participantName: "",
      audio: void 0,
      video: void 0
    };
  }
  a.CreateIngressRequest = {
    encode(q, z = l.default.Writer.create()) {
      return q.inputType !== void 0 && q.inputType !== 0 && z.uint32(8).int32(q.inputType), q.name !== void 0 && q.name !== "" && z.uint32(18).string(q.name), q.roomName !== void 0 && q.roomName !== "" && z.uint32(26).string(q.roomName), q.participantIdentity !== void 0 && q.participantIdentity !== "" && z.uint32(34).string(q.participantIdentity), q.participantName !== void 0 && q.participantName !== "" && z.uint32(42).string(q.participantName), q.audio !== void 0 && a.IngressAudioOptions.encode(q.audio, z.uint32(50).fork()).ldelim(), q.video !== void 0 && a.IngressVideoOptions.encode(q.video, z.uint32(58).fork()).ldelim(), z;
    },
    decode(q, z) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = H();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.inputType = C.int32();
            break;
          case 2:
            E.name = C.string();
            break;
          case 3:
            E.roomName = C.string();
            break;
          case 4:
            E.participantIdentity = C.string();
            break;
          case 5:
            E.participantName = C.string();
            break;
          case 6:
            E.audio = a.IngressAudioOptions.decode(C, C.uint32());
            break;
          case 7:
            E.video = a.IngressVideoOptions.decode(C, C.uint32());
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        inputType: _e(q.inputType) ? _(q.inputType) : 0,
        name: _e(q.name) ? String(q.name) : "",
        roomName: _e(q.roomName) ? String(q.roomName) : "",
        participantIdentity: _e(q.participantIdentity) ? String(q.participantIdentity) : "",
        participantName: _e(q.participantName) ? String(q.participantName) : "",
        audio: _e(q.audio) ? a.IngressAudioOptions.fromJSON(q.audio) : void 0,
        video: _e(q.video) ? a.IngressVideoOptions.fromJSON(q.video) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.inputType !== void 0 && (z.inputType = I(q.inputType)), q.name !== void 0 && (z.name = q.name), q.roomName !== void 0 && (z.roomName = q.roomName), q.participantIdentity !== void 0 && (z.participantIdentity = q.participantIdentity), q.participantName !== void 0 && (z.participantName = q.participantName), q.audio !== void 0 && (z.audio = q.audio ? a.IngressAudioOptions.toJSON(q.audio) : void 0), q.video !== void 0 && (z.video = q.video ? a.IngressVideoOptions.toJSON(q.video) : void 0), z;
    },
    fromPartial(q) {
      var z, C, b, E, k;
      const O = H();
      return O.inputType = (z = q.inputType) !== null && z !== void 0 ? z : 0, O.name = (C = q.name) !== null && C !== void 0 ? C : "", O.roomName = (b = q.roomName) !== null && b !== void 0 ? b : "", O.participantIdentity = (E = q.participantIdentity) !== null && E !== void 0 ? E : "", O.participantName = (k = q.participantName) !== null && k !== void 0 ? k : "", O.audio = q.audio !== void 0 && q.audio !== null ? a.IngressAudioOptions.fromPartial(q.audio) : void 0, O.video = q.video !== void 0 && q.video !== null ? a.IngressVideoOptions.fromPartial(q.video) : void 0, O;
    }
  };
  function j() {
    return { name: "", source: 0, mimeType: "", bitrate: 0, disableDtx: !1, channels: 0 };
  }
  a.IngressAudioOptions = {
    encode(q, z = l.default.Writer.create()) {
      return q.name !== void 0 && q.name !== "" && z.uint32(10).string(q.name), q.source !== void 0 && q.source !== 0 && z.uint32(16).int32(q.source), q.mimeType !== void 0 && q.mimeType !== "" && z.uint32(26).string(q.mimeType), q.bitrate !== void 0 && q.bitrate !== 0 && z.uint32(32).uint32(q.bitrate), q.disableDtx === !0 && z.uint32(40).bool(q.disableDtx), q.channels !== void 0 && q.channels !== 0 && z.uint32(48).uint32(q.channels), z;
    },
    decode(q, z) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = j();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.name = C.string();
            break;
          case 2:
            E.source = C.int32();
            break;
          case 3:
            E.mimeType = C.string();
            break;
          case 4:
            E.bitrate = C.uint32();
            break;
          case 5:
            E.disableDtx = C.bool();
            break;
          case 6:
            E.channels = C.uint32();
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: _e(q.name) ? String(q.name) : "",
        source: _e(q.source) ? v.trackSourceFromJSON(q.source) : 0,
        mimeType: _e(q.mimeType) ? String(q.mimeType) : "",
        bitrate: _e(q.bitrate) ? Number(q.bitrate) : 0,
        disableDtx: _e(q.disableDtx) ? !!q.disableDtx : !1,
        channels: _e(q.channels) ? Number(q.channels) : 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.name !== void 0 && (z.name = q.name), q.source !== void 0 && (z.source = v.trackSourceToJSON(q.source)), q.mimeType !== void 0 && (z.mimeType = q.mimeType), q.bitrate !== void 0 && (z.bitrate = Math.round(q.bitrate)), q.disableDtx !== void 0 && (z.disableDtx = q.disableDtx), q.channels !== void 0 && (z.channels = Math.round(q.channels)), z;
    },
    fromPartial(q) {
      var z, C, b, E, k, O;
      const A = j();
      return A.name = (z = q.name) !== null && z !== void 0 ? z : "", A.source = (C = q.source) !== null && C !== void 0 ? C : 0, A.mimeType = (b = q.mimeType) !== null && b !== void 0 ? b : "", A.bitrate = (E = q.bitrate) !== null && E !== void 0 ? E : 0, A.disableDtx = (k = q.disableDtx) !== null && k !== void 0 ? k : !1, A.channels = (O = q.channels) !== null && O !== void 0 ? O : 0, A;
    }
  };
  function ee() {
    return { name: "", source: 0, mimeType: "", layers: [] };
  }
  a.IngressVideoOptions = {
    encode(q, z = l.default.Writer.create()) {
      if (q.name !== void 0 && q.name !== "" && z.uint32(10).string(q.name), q.source !== void 0 && q.source !== 0 && z.uint32(16).int32(q.source), q.mimeType !== void 0 && q.mimeType !== "" && z.uint32(26).string(q.mimeType), q.layers !== void 0 && q.layers.length !== 0)
        for (const C of q.layers)
          v.VideoLayer.encode(C, z.uint32(34).fork()).ldelim();
      return z;
    },
    decode(q, z) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = ee();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.name = C.string();
            break;
          case 2:
            E.source = C.int32();
            break;
          case 3:
            E.mimeType = C.string();
            break;
          case 4:
            E.layers.push(v.VideoLayer.decode(C, C.uint32()));
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        name: _e(q.name) ? String(q.name) : "",
        source: _e(q.source) ? v.trackSourceFromJSON(q.source) : 0,
        mimeType: _e(q.mimeType) ? String(q.mimeType) : "",
        layers: Array.isArray(q == null ? void 0 : q.layers) ? q.layers.map((z) => v.VideoLayer.fromJSON(z)) : []
      };
    },
    toJSON(q) {
      const z = {};
      return q.name !== void 0 && (z.name = q.name), q.source !== void 0 && (z.source = v.trackSourceToJSON(q.source)), q.mimeType !== void 0 && (z.mimeType = q.mimeType), q.layers ? z.layers = q.layers.map((C) => C ? v.VideoLayer.toJSON(C) : void 0) : z.layers = [], z;
    },
    fromPartial(q) {
      var z, C, b, E;
      const k = ee();
      return k.name = (z = q.name) !== null && z !== void 0 ? z : "", k.source = (C = q.source) !== null && C !== void 0 ? C : 0, k.mimeType = (b = q.mimeType) !== null && b !== void 0 ? b : "", k.layers = ((E = q.layers) === null || E === void 0 ? void 0 : E.map((O) => v.VideoLayer.fromPartial(O))) || [], k;
    }
  };
  function X() {
    return {
      ingressId: "",
      name: "",
      streamKey: "",
      url: "",
      inputType: 0,
      audio: void 0,
      video: void 0,
      roomName: "",
      participantIdentity: "",
      participantName: "",
      reusable: !1,
      state: void 0
    };
  }
  a.IngressInfo = {
    encode(q, z = l.default.Writer.create()) {
      return q.ingressId !== void 0 && q.ingressId !== "" && z.uint32(10).string(q.ingressId), q.name !== void 0 && q.name !== "" && z.uint32(18).string(q.name), q.streamKey !== void 0 && q.streamKey !== "" && z.uint32(26).string(q.streamKey), q.url !== void 0 && q.url !== "" && z.uint32(34).string(q.url), q.inputType !== void 0 && q.inputType !== 0 && z.uint32(40).int32(q.inputType), q.audio !== void 0 && a.IngressAudioOptions.encode(q.audio, z.uint32(50).fork()).ldelim(), q.video !== void 0 && a.IngressVideoOptions.encode(q.video, z.uint32(58).fork()).ldelim(), q.roomName !== void 0 && q.roomName !== "" && z.uint32(66).string(q.roomName), q.participantIdentity !== void 0 && q.participantIdentity !== "" && z.uint32(74).string(q.participantIdentity), q.participantName !== void 0 && q.participantName !== "" && z.uint32(82).string(q.participantName), q.reusable === !0 && z.uint32(88).bool(q.reusable), q.state !== void 0 && a.IngressState.encode(q.state, z.uint32(98).fork()).ldelim(), z;
    },
    decode(q, z) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = X();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.ingressId = C.string();
            break;
          case 2:
            E.name = C.string();
            break;
          case 3:
            E.streamKey = C.string();
            break;
          case 4:
            E.url = C.string();
            break;
          case 5:
            E.inputType = C.int32();
            break;
          case 6:
            E.audio = a.IngressAudioOptions.decode(C, C.uint32());
            break;
          case 7:
            E.video = a.IngressVideoOptions.decode(C, C.uint32());
            break;
          case 8:
            E.roomName = C.string();
            break;
          case 9:
            E.participantIdentity = C.string();
            break;
          case 10:
            E.participantName = C.string();
            break;
          case 11:
            E.reusable = C.bool();
            break;
          case 12:
            E.state = a.IngressState.decode(C, C.uint32());
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        ingressId: _e(q.ingressId) ? String(q.ingressId) : "",
        name: _e(q.name) ? String(q.name) : "",
        streamKey: _e(q.streamKey) ? String(q.streamKey) : "",
        url: _e(q.url) ? String(q.url) : "",
        inputType: _e(q.inputType) ? _(q.inputType) : 0,
        audio: _e(q.audio) ? a.IngressAudioOptions.fromJSON(q.audio) : void 0,
        video: _e(q.video) ? a.IngressVideoOptions.fromJSON(q.video) : void 0,
        roomName: _e(q.roomName) ? String(q.roomName) : "",
        participantIdentity: _e(q.participantIdentity) ? String(q.participantIdentity) : "",
        participantName: _e(q.participantName) ? String(q.participantName) : "",
        reusable: _e(q.reusable) ? !!q.reusable : !1,
        state: _e(q.state) ? a.IngressState.fromJSON(q.state) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.ingressId !== void 0 && (z.ingressId = q.ingressId), q.name !== void 0 && (z.name = q.name), q.streamKey !== void 0 && (z.streamKey = q.streamKey), q.url !== void 0 && (z.url = q.url), q.inputType !== void 0 && (z.inputType = I(q.inputType)), q.audio !== void 0 && (z.audio = q.audio ? a.IngressAudioOptions.toJSON(q.audio) : void 0), q.video !== void 0 && (z.video = q.video ? a.IngressVideoOptions.toJSON(q.video) : void 0), q.roomName !== void 0 && (z.roomName = q.roomName), q.participantIdentity !== void 0 && (z.participantIdentity = q.participantIdentity), q.participantName !== void 0 && (z.participantName = q.participantName), q.reusable !== void 0 && (z.reusable = q.reusable), q.state !== void 0 && (z.state = q.state ? a.IngressState.toJSON(q.state) : void 0), z;
    },
    fromPartial(q) {
      var z, C, b, E, k, O, A, x, Y;
      const B = X();
      return B.ingressId = (z = q.ingressId) !== null && z !== void 0 ? z : "", B.name = (C = q.name) !== null && C !== void 0 ? C : "", B.streamKey = (b = q.streamKey) !== null && b !== void 0 ? b : "", B.url = (E = q.url) !== null && E !== void 0 ? E : "", B.inputType = (k = q.inputType) !== null && k !== void 0 ? k : 0, B.audio = q.audio !== void 0 && q.audio !== null ? a.IngressAudioOptions.fromPartial(q.audio) : void 0, B.video = q.video !== void 0 && q.video !== null ? a.IngressVideoOptions.fromPartial(q.video) : void 0, B.roomName = (O = q.roomName) !== null && O !== void 0 ? O : "", B.participantIdentity = (A = q.participantIdentity) !== null && A !== void 0 ? A : "", B.participantName = (x = q.participantName) !== null && x !== void 0 ? x : "", B.reusable = (Y = q.reusable) !== null && Y !== void 0 ? Y : !1, B.state = q.state !== void 0 && q.state !== null ? a.IngressState.fromPartial(q.state) : void 0, B;
    }
  };
  function ie() {
    return { status: 0, error: "", video: void 0, audio: void 0, roomId: "", startedAt: 0, tracks: [] };
  }
  a.IngressState = {
    encode(q, z = l.default.Writer.create()) {
      if (q.status !== void 0 && q.status !== 0 && z.uint32(8).int32(q.status), q.error !== void 0 && q.error !== "" && z.uint32(18).string(q.error), q.video !== void 0 && a.InputVideoState.encode(q.video, z.uint32(26).fork()).ldelim(), q.audio !== void 0 && a.InputAudioState.encode(q.audio, z.uint32(34).fork()).ldelim(), q.roomId !== void 0 && q.roomId !== "" && z.uint32(42).string(q.roomId), q.startedAt !== void 0 && q.startedAt !== 0 && z.uint32(56).int64(q.startedAt), q.tracks !== void 0 && q.tracks.length !== 0)
        for (const C of q.tracks)
          v.TrackInfo.encode(C, z.uint32(50).fork()).ldelim();
      return z;
    },
    decode(q, z) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = ie();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.status = C.int32();
            break;
          case 2:
            E.error = C.string();
            break;
          case 3:
            E.video = a.InputVideoState.decode(C, C.uint32());
            break;
          case 4:
            E.audio = a.InputAudioState.decode(C, C.uint32());
            break;
          case 5:
            E.roomId = C.string();
            break;
          case 7:
            E.startedAt = ke(C.int64());
            break;
          case 6:
            E.tracks.push(v.TrackInfo.decode(C, C.uint32()));
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        status: _e(q.status) ? $(q.status) : 0,
        error: _e(q.error) ? String(q.error) : "",
        video: _e(q.video) ? a.InputVideoState.fromJSON(q.video) : void 0,
        audio: _e(q.audio) ? a.InputAudioState.fromJSON(q.audio) : void 0,
        roomId: _e(q.roomId) ? String(q.roomId) : "",
        startedAt: _e(q.startedAt) ? Number(q.startedAt) : 0,
        tracks: Array.isArray(q == null ? void 0 : q.tracks) ? q.tracks.map((z) => v.TrackInfo.fromJSON(z)) : []
      };
    },
    toJSON(q) {
      const z = {};
      return q.status !== void 0 && (z.status = F(q.status)), q.error !== void 0 && (z.error = q.error), q.video !== void 0 && (z.video = q.video ? a.InputVideoState.toJSON(q.video) : void 0), q.audio !== void 0 && (z.audio = q.audio ? a.InputAudioState.toJSON(q.audio) : void 0), q.roomId !== void 0 && (z.roomId = q.roomId), q.startedAt !== void 0 && (z.startedAt = Math.round(q.startedAt)), q.tracks ? z.tracks = q.tracks.map((C) => C ? v.TrackInfo.toJSON(C) : void 0) : z.tracks = [], z;
    },
    fromPartial(q) {
      var z, C, b, E, k;
      const O = ie();
      return O.status = (z = q.status) !== null && z !== void 0 ? z : 0, O.error = (C = q.error) !== null && C !== void 0 ? C : "", O.video = q.video !== void 0 && q.video !== null ? a.InputVideoState.fromPartial(q.video) : void 0, O.audio = q.audio !== void 0 && q.audio !== null ? a.InputAudioState.fromPartial(q.audio) : void 0, O.roomId = (b = q.roomId) !== null && b !== void 0 ? b : "", O.startedAt = (E = q.startedAt) !== null && E !== void 0 ? E : 0, O.tracks = ((k = q.tracks) === null || k === void 0 ? void 0 : k.map((A) => v.TrackInfo.fromPartial(A))) || [], O;
    }
  };
  function Q() {
    return { mimeType: 0, width: 0, height: 0, framerate: 0 };
  }
  a.InputVideoState = {
    encode(q, z = l.default.Writer.create()) {
      return q.mimeType !== void 0 && q.mimeType !== 0 && z.uint32(8).uint32(q.mimeType), q.width !== void 0 && q.width !== 0 && z.uint32(24).uint32(q.width), q.height !== void 0 && q.height !== 0 && z.uint32(32).uint32(q.height), q.framerate !== void 0 && q.framerate !== 0 && z.uint32(40).uint32(q.framerate), z;
    },
    decode(q, z) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = Q();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.mimeType = C.uint32();
            break;
          case 3:
            E.width = C.uint32();
            break;
          case 4:
            E.height = C.uint32();
            break;
          case 5:
            E.framerate = C.uint32();
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        mimeType: _e(q.mimeType) ? Number(q.mimeType) : 0,
        width: _e(q.width) ? Number(q.width) : 0,
        height: _e(q.height) ? Number(q.height) : 0,
        framerate: _e(q.framerate) ? Number(q.framerate) : 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.mimeType !== void 0 && (z.mimeType = Math.round(q.mimeType)), q.width !== void 0 && (z.width = Math.round(q.width)), q.height !== void 0 && (z.height = Math.round(q.height)), q.framerate !== void 0 && (z.framerate = Math.round(q.framerate)), z;
    },
    fromPartial(q) {
      var z, C, b, E;
      const k = Q();
      return k.mimeType = (z = q.mimeType) !== null && z !== void 0 ? z : 0, k.width = (C = q.width) !== null && C !== void 0 ? C : 0, k.height = (b = q.height) !== null && b !== void 0 ? b : 0, k.framerate = (E = q.framerate) !== null && E !== void 0 ? E : 0, k;
    }
  };
  function ne() {
    return { mimeType: 0, channels: 0, sampleRate: 0 };
  }
  a.InputAudioState = {
    encode(q, z = l.default.Writer.create()) {
      return q.mimeType !== void 0 && q.mimeType !== 0 && z.uint32(8).uint32(q.mimeType), q.channels !== void 0 && q.channels !== 0 && z.uint32(24).uint32(q.channels), q.sampleRate !== void 0 && q.sampleRate !== 0 && z.uint32(32).uint32(q.sampleRate), z;
    },
    decode(q, z) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = ne();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.mimeType = C.uint32();
            break;
          case 3:
            E.channels = C.uint32();
            break;
          case 4:
            E.sampleRate = C.uint32();
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        mimeType: _e(q.mimeType) ? Number(q.mimeType) : 0,
        channels: _e(q.channels) ? Number(q.channels) : 0,
        sampleRate: _e(q.sampleRate) ? Number(q.sampleRate) : 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.mimeType !== void 0 && (z.mimeType = Math.round(q.mimeType)), q.channels !== void 0 && (z.channels = Math.round(q.channels)), q.sampleRate !== void 0 && (z.sampleRate = Math.round(q.sampleRate)), z;
    },
    fromPartial(q) {
      var z, C, b;
      const E = ne();
      return E.mimeType = (z = q.mimeType) !== null && z !== void 0 ? z : 0, E.channels = (C = q.channels) !== null && C !== void 0 ? C : 0, E.sampleRate = (b = q.sampleRate) !== null && b !== void 0 ? b : 0, E;
    }
  };
  function Z() {
    return {
      ingressId: "",
      name: "",
      roomName: "",
      participantIdentity: "",
      participantName: "",
      audio: void 0,
      video: void 0
    };
  }
  a.UpdateIngressRequest = {
    encode(q, z = l.default.Writer.create()) {
      return q.ingressId !== void 0 && q.ingressId !== "" && z.uint32(10).string(q.ingressId), q.name !== void 0 && q.name !== "" && z.uint32(18).string(q.name), q.roomName !== void 0 && q.roomName !== "" && z.uint32(26).string(q.roomName), q.participantIdentity !== void 0 && q.participantIdentity !== "" && z.uint32(34).string(q.participantIdentity), q.participantName !== void 0 && q.participantName !== "" && z.uint32(42).string(q.participantName), q.audio !== void 0 && a.IngressAudioOptions.encode(q.audio, z.uint32(50).fork()).ldelim(), q.video !== void 0 && a.IngressVideoOptions.encode(q.video, z.uint32(58).fork()).ldelim(), z;
    },
    decode(q, z) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = Z();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.ingressId = C.string();
            break;
          case 2:
            E.name = C.string();
            break;
          case 3:
            E.roomName = C.string();
            break;
          case 4:
            E.participantIdentity = C.string();
            break;
          case 5:
            E.participantName = C.string();
            break;
          case 6:
            E.audio = a.IngressAudioOptions.decode(C, C.uint32());
            break;
          case 7:
            E.video = a.IngressVideoOptions.decode(C, C.uint32());
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return {
        ingressId: _e(q.ingressId) ? String(q.ingressId) : "",
        name: _e(q.name) ? String(q.name) : "",
        roomName: _e(q.roomName) ? String(q.roomName) : "",
        participantIdentity: _e(q.participantIdentity) ? String(q.participantIdentity) : "",
        participantName: _e(q.participantName) ? String(q.participantName) : "",
        audio: _e(q.audio) ? a.IngressAudioOptions.fromJSON(q.audio) : void 0,
        video: _e(q.video) ? a.IngressVideoOptions.fromJSON(q.video) : void 0
      };
    },
    toJSON(q) {
      const z = {};
      return q.ingressId !== void 0 && (z.ingressId = q.ingressId), q.name !== void 0 && (z.name = q.name), q.roomName !== void 0 && (z.roomName = q.roomName), q.participantIdentity !== void 0 && (z.participantIdentity = q.participantIdentity), q.participantName !== void 0 && (z.participantName = q.participantName), q.audio !== void 0 && (z.audio = q.audio ? a.IngressAudioOptions.toJSON(q.audio) : void 0), q.video !== void 0 && (z.video = q.video ? a.IngressVideoOptions.toJSON(q.video) : void 0), z;
    },
    fromPartial(q) {
      var z, C, b, E, k;
      const O = Z();
      return O.ingressId = (z = q.ingressId) !== null && z !== void 0 ? z : "", O.name = (C = q.name) !== null && C !== void 0 ? C : "", O.roomName = (b = q.roomName) !== null && b !== void 0 ? b : "", O.participantIdentity = (E = q.participantIdentity) !== null && E !== void 0 ? E : "", O.participantName = (k = q.participantName) !== null && k !== void 0 ? k : "", O.audio = q.audio !== void 0 && q.audio !== null ? a.IngressAudioOptions.fromPartial(q.audio) : void 0, O.video = q.video !== void 0 && q.video !== null ? a.IngressVideoOptions.fromPartial(q.video) : void 0, O;
    }
  };
  function de() {
    return { roomName: "" };
  }
  a.ListIngressRequest = {
    encode(q, z = l.default.Writer.create()) {
      return q.roomName !== void 0 && q.roomName !== "" && z.uint32(10).string(q.roomName), z;
    },
    decode(q, z) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = de();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.roomName = C.string();
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return { roomName: _e(q.roomName) ? String(q.roomName) : "" };
    },
    toJSON(q) {
      const z = {};
      return q.roomName !== void 0 && (z.roomName = q.roomName), z;
    },
    fromPartial(q) {
      var z;
      const C = de();
      return C.roomName = (z = q.roomName) !== null && z !== void 0 ? z : "", C;
    }
  };
  function he() {
    return { items: [] };
  }
  a.ListIngressResponse = {
    encode(q, z = l.default.Writer.create()) {
      if (q.items !== void 0 && q.items.length !== 0)
        for (const C of q.items)
          a.IngressInfo.encode(C, z.uint32(10).fork()).ldelim();
      return z;
    },
    decode(q, z) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = he();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.items.push(a.IngressInfo.decode(C, C.uint32()));
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return { items: Array.isArray(q == null ? void 0 : q.items) ? q.items.map((z) => a.IngressInfo.fromJSON(z)) : [] };
    },
    toJSON(q) {
      const z = {};
      return q.items ? z.items = q.items.map((C) => C ? a.IngressInfo.toJSON(C) : void 0) : z.items = [], z;
    },
    fromPartial(q) {
      var z;
      const C = he();
      return C.items = ((z = q.items) === null || z === void 0 ? void 0 : z.map((b) => a.IngressInfo.fromPartial(b))) || [], C;
    }
  };
  function pe() {
    return { ingressId: "" };
  }
  a.DeleteIngressRequest = {
    encode(q, z = l.default.Writer.create()) {
      return q.ingressId !== void 0 && q.ingressId !== "" && z.uint32(10).string(q.ingressId), z;
    },
    decode(q, z) {
      const C = q instanceof l.default.Reader ? q : new l.default.Reader(q);
      let b = z === void 0 ? C.len : C.pos + z;
      const E = pe();
      for (; C.pos < b; ) {
        const k = C.uint32();
        switch (k >>> 3) {
          case 1:
            E.ingressId = C.string();
            break;
          default:
            C.skipType(k & 7);
            break;
        }
      }
      return E;
    },
    fromJSON(q) {
      return { ingressId: _e(q.ingressId) ? String(q.ingressId) : "" };
    },
    toJSON(q) {
      const z = {};
      return q.ingressId !== void 0 && (z.ingressId = q.ingressId), z;
    },
    fromPartial(q) {
      var z;
      const C = pe();
      return C.ingressId = (z = q.ingressId) !== null && z !== void 0 ? z : "", C;
    }
  };
  var be = (() => {
    if (typeof be < "u")
      return be;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function ke(q) {
    if (q.gt(Number.MAX_SAFE_INTEGER))
      throw new be.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return q.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function _e(q) {
    return q != null;
  }
})(livekit_ingress);
var __awaiter$1 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function I(F) {
      try {
        $(l.next(F));
      } catch (H) {
        _(H);
      }
    }
    function P(F) {
      try {
        $(l.throw(F));
      } catch (H) {
        _(H);
      }
    }
    function $(F) {
      F.done ? p(F.value) : v(F.value).then(I, P);
    }
    $((l = l.apply(a, u || [])).next());
  });
}, __importDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(IngressClient$1, "__esModule", { value: !0 });
IngressClient$1.IngressClient = void 0;
const livekit_ingress_1$1 = livekit_ingress, ServiceBase_1$1 = __importDefault$3(ServiceBase$1), TwirpRPC_1$1 = TwirpRPC, svc$1 = "Ingress";
class IngressClient extends ServiceBase_1$1.default {
  /**
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    super(c, l), this.rpc = new TwirpRPC_1$1.TwirpRpc(u, TwirpRPC_1$1.livekitPackage);
  }
  /**
   * @param inputType protocol for the ingress
   * @param opts CreateIngressOptions
   */
  createIngress(u, c) {
    return __awaiter$1(this, void 0, void 0, function* () {
      let l = "", v = "", p = "", _ = "", I, P;
      c !== void 0 && (l = c.name || "", v = c.roomName || "", p = c.participantName || "", _ = c.participantIdentity || "", I = c.audioParams, P = c.videoParams);
      const $ = livekit_ingress_1$1.CreateIngressRequest.toJSON({
        inputType: u,
        name: l,
        roomName: v,
        participantIdentity: _,
        participantName: p,
        audio: I,
        video: P
      }), F = yield this.rpc.request(svc$1, "CreateIngress", $, this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(F);
    });
  }
  /**
   * @param ingressId ID of the ingress to update
   * @param opts UpdateIngressOptions
   */
  updateIngress(u, c) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const l = c.name || "", v = c.roomName || "", p = c.participantName || "", _ = c.participantIdentity || "", I = c.audioParams, P = c.videoParams, $ = livekit_ingress_1$1.UpdateIngressRequest.toJSON({
        ingressId: u,
        name: l,
        roomName: v,
        participantIdentity: _,
        participantName: p,
        audio: I,
        video: P
      }), F = yield this.rpc.request(svc$1, "UpdateIngress", $, this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(F);
    });
  }
  /**
   * @param roomName list ingress for one room only
   */
  listIngress(u) {
    var c;
    return __awaiter$1(this, void 0, void 0, function* () {
      u ?? (u = "");
      const l = yield this.rpc.request(svc$1, "ListIngress", livekit_ingress_1$1.ListIngressRequest.toJSON({ roomName: u }), this.authHeader({ ingressAdmin: !0 }));
      return (c = livekit_ingress_1$1.ListIngressResponse.fromJSON(l).items) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * @param ingressId ingress to delete
   */
  deleteIngress(u) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc$1, "DeleteIngress", livekit_ingress_1$1.DeleteIngressRequest.toJSON({ ingressId: u }), this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(c);
    });
  }
}
IngressClient$1.IngressClient = IngressClient;
var RoomServiceClient$1 = {}, livekit_room = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(C) {
    return C && C.__esModule ? C : { default: C };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.UpdateRoomMetadataRequest = a.SendDataResponse = a.SendDataRequest = a.UpdateSubscriptionsResponse = a.UpdateSubscriptionsRequest = a.UpdateParticipantRequest = a.MuteRoomTrackResponse = a.MuteRoomTrackRequest = a.RemoveParticipantResponse = a.RoomParticipantIdentity = a.ListParticipantsResponse = a.ListParticipantsRequest = a.DeleteRoomResponse = a.DeleteRoomRequest = a.ListRoomsResponse = a.ListRoomsRequest = a.RoomEgress = a.CreateRoomRequest = a.protobufPackage = void 0;
  const c = u(minimal), l = livekit_egress, v = livekit_models;
  a.protobufPackage = "livekit";
  function p() {
    return { name: "", emptyTimeout: 0, maxParticipants: 0, nodeId: "", metadata: "", egress: void 0 };
  }
  a.CreateRoomRequest = {
    encode(C, b = c.default.Writer.create()) {
      return C.name !== void 0 && C.name !== "" && b.uint32(10).string(C.name), C.emptyTimeout !== void 0 && C.emptyTimeout !== 0 && b.uint32(16).uint32(C.emptyTimeout), C.maxParticipants !== void 0 && C.maxParticipants !== 0 && b.uint32(24).uint32(C.maxParticipants), C.nodeId !== void 0 && C.nodeId !== "" && b.uint32(34).string(C.nodeId), C.metadata !== void 0 && C.metadata !== "" && b.uint32(42).string(C.metadata), C.egress !== void 0 && a.RoomEgress.encode(C.egress, b.uint32(50).fork()).ldelim(), b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = p();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.name = E.string();
            break;
          case 2:
            O.emptyTimeout = E.uint32();
            break;
          case 3:
            O.maxParticipants = E.uint32();
            break;
          case 4:
            O.nodeId = E.string();
            break;
          case 5:
            O.metadata = E.string();
            break;
          case 6:
            O.egress = a.RoomEgress.decode(E, E.uint32());
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return {
        name: z(C.name) ? String(C.name) : "",
        emptyTimeout: z(C.emptyTimeout) ? Number(C.emptyTimeout) : 0,
        maxParticipants: z(C.maxParticipants) ? Number(C.maxParticipants) : 0,
        nodeId: z(C.nodeId) ? String(C.nodeId) : "",
        metadata: z(C.metadata) ? String(C.metadata) : "",
        egress: z(C.egress) ? a.RoomEgress.fromJSON(C.egress) : void 0
      };
    },
    toJSON(C) {
      const b = {};
      return C.name !== void 0 && (b.name = C.name), C.emptyTimeout !== void 0 && (b.emptyTimeout = Math.round(C.emptyTimeout)), C.maxParticipants !== void 0 && (b.maxParticipants = Math.round(C.maxParticipants)), C.nodeId !== void 0 && (b.nodeId = C.nodeId), C.metadata !== void 0 && (b.metadata = C.metadata), C.egress !== void 0 && (b.egress = C.egress ? a.RoomEgress.toJSON(C.egress) : void 0), b;
    },
    fromPartial(C) {
      var b, E, k, O, A;
      const x = p();
      return x.name = (b = C.name) !== null && b !== void 0 ? b : "", x.emptyTimeout = (E = C.emptyTimeout) !== null && E !== void 0 ? E : 0, x.maxParticipants = (k = C.maxParticipants) !== null && k !== void 0 ? k : 0, x.nodeId = (O = C.nodeId) !== null && O !== void 0 ? O : "", x.metadata = (A = C.metadata) !== null && A !== void 0 ? A : "", x.egress = C.egress !== void 0 && C.egress !== null ? a.RoomEgress.fromPartial(C.egress) : void 0, x;
    }
  };
  function _() {
    return { room: void 0, tracks: void 0 };
  }
  a.RoomEgress = {
    encode(C, b = c.default.Writer.create()) {
      return C.room !== void 0 && l.RoomCompositeEgressRequest.encode(C.room, b.uint32(10).fork()).ldelim(), C.tracks !== void 0 && l.AutoTrackEgress.encode(C.tracks, b.uint32(18).fork()).ldelim(), b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = _();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.room = l.RoomCompositeEgressRequest.decode(E, E.uint32());
            break;
          case 2:
            O.tracks = l.AutoTrackEgress.decode(E, E.uint32());
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return {
        room: z(C.room) ? l.RoomCompositeEgressRequest.fromJSON(C.room) : void 0,
        tracks: z(C.tracks) ? l.AutoTrackEgress.fromJSON(C.tracks) : void 0
      };
    },
    toJSON(C) {
      const b = {};
      return C.room !== void 0 && (b.room = C.room ? l.RoomCompositeEgressRequest.toJSON(C.room) : void 0), C.tracks !== void 0 && (b.tracks = C.tracks ? l.AutoTrackEgress.toJSON(C.tracks) : void 0), b;
    },
    fromPartial(C) {
      const b = _();
      return b.room = C.room !== void 0 && C.room !== null ? l.RoomCompositeEgressRequest.fromPartial(C.room) : void 0, b.tracks = C.tracks !== void 0 && C.tracks !== null ? l.AutoTrackEgress.fromPartial(C.tracks) : void 0, b;
    }
  };
  function I() {
    return { names: [] };
  }
  a.ListRoomsRequest = {
    encode(C, b = c.default.Writer.create()) {
      if (C.names !== void 0 && C.names.length !== 0)
        for (const E of C.names)
          b.uint32(10).string(E);
      return b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = I();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.names.push(E.string());
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return { names: Array.isArray(C == null ? void 0 : C.names) ? C.names.map((b) => String(b)) : [] };
    },
    toJSON(C) {
      const b = {};
      return C.names ? b.names = C.names.map((E) => E) : b.names = [], b;
    },
    fromPartial(C) {
      var b;
      const E = I();
      return E.names = ((b = C.names) === null || b === void 0 ? void 0 : b.map((k) => k)) || [], E;
    }
  };
  function P() {
    return { rooms: [] };
  }
  a.ListRoomsResponse = {
    encode(C, b = c.default.Writer.create()) {
      if (C.rooms !== void 0 && C.rooms.length !== 0)
        for (const E of C.rooms)
          v.Room.encode(E, b.uint32(10).fork()).ldelim();
      return b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = P();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.rooms.push(v.Room.decode(E, E.uint32()));
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return { rooms: Array.isArray(C == null ? void 0 : C.rooms) ? C.rooms.map((b) => v.Room.fromJSON(b)) : [] };
    },
    toJSON(C) {
      const b = {};
      return C.rooms ? b.rooms = C.rooms.map((E) => E ? v.Room.toJSON(E) : void 0) : b.rooms = [], b;
    },
    fromPartial(C) {
      var b;
      const E = P();
      return E.rooms = ((b = C.rooms) === null || b === void 0 ? void 0 : b.map((k) => v.Room.fromPartial(k))) || [], E;
    }
  };
  function $() {
    return { room: "" };
  }
  a.DeleteRoomRequest = {
    encode(C, b = c.default.Writer.create()) {
      return C.room !== void 0 && C.room !== "" && b.uint32(10).string(C.room), b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = $();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.room = E.string();
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return { room: z(C.room) ? String(C.room) : "" };
    },
    toJSON(C) {
      const b = {};
      return C.room !== void 0 && (b.room = C.room), b;
    },
    fromPartial(C) {
      var b;
      const E = $();
      return E.room = (b = C.room) !== null && b !== void 0 ? b : "", E;
    }
  };
  function F() {
    return {};
  }
  a.DeleteRoomResponse = {
    encode(C, b = c.default.Writer.create()) {
      return b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = F();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return {};
    },
    toJSON(C) {
      return {};
    },
    fromPartial(C) {
      return F();
    }
  };
  function H() {
    return { room: "" };
  }
  a.ListParticipantsRequest = {
    encode(C, b = c.default.Writer.create()) {
      return C.room !== void 0 && C.room !== "" && b.uint32(10).string(C.room), b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = H();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.room = E.string();
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return { room: z(C.room) ? String(C.room) : "" };
    },
    toJSON(C) {
      const b = {};
      return C.room !== void 0 && (b.room = C.room), b;
    },
    fromPartial(C) {
      var b;
      const E = H();
      return E.room = (b = C.room) !== null && b !== void 0 ? b : "", E;
    }
  };
  function j() {
    return { participants: [] };
  }
  a.ListParticipantsResponse = {
    encode(C, b = c.default.Writer.create()) {
      if (C.participants !== void 0 && C.participants.length !== 0)
        for (const E of C.participants)
          v.ParticipantInfo.encode(E, b.uint32(10).fork()).ldelim();
      return b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = j();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.participants.push(v.ParticipantInfo.decode(E, E.uint32()));
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return {
        participants: Array.isArray(C == null ? void 0 : C.participants) ? C.participants.map((b) => v.ParticipantInfo.fromJSON(b)) : []
      };
    },
    toJSON(C) {
      const b = {};
      return C.participants ? b.participants = C.participants.map((E) => E ? v.ParticipantInfo.toJSON(E) : void 0) : b.participants = [], b;
    },
    fromPartial(C) {
      var b;
      const E = j();
      return E.participants = ((b = C.participants) === null || b === void 0 ? void 0 : b.map((k) => v.ParticipantInfo.fromPartial(k))) || [], E;
    }
  };
  function ee() {
    return { room: "", identity: "" };
  }
  a.RoomParticipantIdentity = {
    encode(C, b = c.default.Writer.create()) {
      return C.room !== void 0 && C.room !== "" && b.uint32(10).string(C.room), C.identity !== void 0 && C.identity !== "" && b.uint32(18).string(C.identity), b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = ee();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.room = E.string();
            break;
          case 2:
            O.identity = E.string();
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return {
        room: z(C.room) ? String(C.room) : "",
        identity: z(C.identity) ? String(C.identity) : ""
      };
    },
    toJSON(C) {
      const b = {};
      return C.room !== void 0 && (b.room = C.room), C.identity !== void 0 && (b.identity = C.identity), b;
    },
    fromPartial(C) {
      var b, E;
      const k = ee();
      return k.room = (b = C.room) !== null && b !== void 0 ? b : "", k.identity = (E = C.identity) !== null && E !== void 0 ? E : "", k;
    }
  };
  function X() {
    return {};
  }
  a.RemoveParticipantResponse = {
    encode(C, b = c.default.Writer.create()) {
      return b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = X();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return {};
    },
    toJSON(C) {
      return {};
    },
    fromPartial(C) {
      return X();
    }
  };
  function ie() {
    return { room: "", identity: "", trackSid: "", muted: !1 };
  }
  a.MuteRoomTrackRequest = {
    encode(C, b = c.default.Writer.create()) {
      return C.room !== void 0 && C.room !== "" && b.uint32(10).string(C.room), C.identity !== void 0 && C.identity !== "" && b.uint32(18).string(C.identity), C.trackSid !== void 0 && C.trackSid !== "" && b.uint32(26).string(C.trackSid), C.muted === !0 && b.uint32(32).bool(C.muted), b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = ie();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.room = E.string();
            break;
          case 2:
            O.identity = E.string();
            break;
          case 3:
            O.trackSid = E.string();
            break;
          case 4:
            O.muted = E.bool();
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return {
        room: z(C.room) ? String(C.room) : "",
        identity: z(C.identity) ? String(C.identity) : "",
        trackSid: z(C.trackSid) ? String(C.trackSid) : "",
        muted: z(C.muted) ? !!C.muted : !1
      };
    },
    toJSON(C) {
      const b = {};
      return C.room !== void 0 && (b.room = C.room), C.identity !== void 0 && (b.identity = C.identity), C.trackSid !== void 0 && (b.trackSid = C.trackSid), C.muted !== void 0 && (b.muted = C.muted), b;
    },
    fromPartial(C) {
      var b, E, k, O;
      const A = ie();
      return A.room = (b = C.room) !== null && b !== void 0 ? b : "", A.identity = (E = C.identity) !== null && E !== void 0 ? E : "", A.trackSid = (k = C.trackSid) !== null && k !== void 0 ? k : "", A.muted = (O = C.muted) !== null && O !== void 0 ? O : !1, A;
    }
  };
  function Q() {
    return { track: void 0 };
  }
  a.MuteRoomTrackResponse = {
    encode(C, b = c.default.Writer.create()) {
      return C.track !== void 0 && v.TrackInfo.encode(C.track, b.uint32(10).fork()).ldelim(), b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = Q();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.track = v.TrackInfo.decode(E, E.uint32());
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return { track: z(C.track) ? v.TrackInfo.fromJSON(C.track) : void 0 };
    },
    toJSON(C) {
      const b = {};
      return C.track !== void 0 && (b.track = C.track ? v.TrackInfo.toJSON(C.track) : void 0), b;
    },
    fromPartial(C) {
      const b = Q();
      return b.track = C.track !== void 0 && C.track !== null ? v.TrackInfo.fromPartial(C.track) : void 0, b;
    }
  };
  function ne() {
    return { room: "", identity: "", metadata: "", permission: void 0, name: "" };
  }
  a.UpdateParticipantRequest = {
    encode(C, b = c.default.Writer.create()) {
      return C.room !== void 0 && C.room !== "" && b.uint32(10).string(C.room), C.identity !== void 0 && C.identity !== "" && b.uint32(18).string(C.identity), C.metadata !== void 0 && C.metadata !== "" && b.uint32(26).string(C.metadata), C.permission !== void 0 && v.ParticipantPermission.encode(C.permission, b.uint32(34).fork()).ldelim(), C.name !== void 0 && C.name !== "" && b.uint32(42).string(C.name), b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = ne();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.room = E.string();
            break;
          case 2:
            O.identity = E.string();
            break;
          case 3:
            O.metadata = E.string();
            break;
          case 4:
            O.permission = v.ParticipantPermission.decode(E, E.uint32());
            break;
          case 5:
            O.name = E.string();
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return {
        room: z(C.room) ? String(C.room) : "",
        identity: z(C.identity) ? String(C.identity) : "",
        metadata: z(C.metadata) ? String(C.metadata) : "",
        permission: z(C.permission) ? v.ParticipantPermission.fromJSON(C.permission) : void 0,
        name: z(C.name) ? String(C.name) : ""
      };
    },
    toJSON(C) {
      const b = {};
      return C.room !== void 0 && (b.room = C.room), C.identity !== void 0 && (b.identity = C.identity), C.metadata !== void 0 && (b.metadata = C.metadata), C.permission !== void 0 && (b.permission = C.permission ? v.ParticipantPermission.toJSON(C.permission) : void 0), C.name !== void 0 && (b.name = C.name), b;
    },
    fromPartial(C) {
      var b, E, k, O;
      const A = ne();
      return A.room = (b = C.room) !== null && b !== void 0 ? b : "", A.identity = (E = C.identity) !== null && E !== void 0 ? E : "", A.metadata = (k = C.metadata) !== null && k !== void 0 ? k : "", A.permission = C.permission !== void 0 && C.permission !== null ? v.ParticipantPermission.fromPartial(C.permission) : void 0, A.name = (O = C.name) !== null && O !== void 0 ? O : "", A;
    }
  };
  function Z() {
    return { room: "", identity: "", trackSids: [], subscribe: !1, participantTracks: [] };
  }
  a.UpdateSubscriptionsRequest = {
    encode(C, b = c.default.Writer.create()) {
      if (C.room !== void 0 && C.room !== "" && b.uint32(10).string(C.room), C.identity !== void 0 && C.identity !== "" && b.uint32(18).string(C.identity), C.trackSids !== void 0 && C.trackSids.length !== 0)
        for (const E of C.trackSids)
          b.uint32(26).string(E);
      if (C.subscribe === !0 && b.uint32(32).bool(C.subscribe), C.participantTracks !== void 0 && C.participantTracks.length !== 0)
        for (const E of C.participantTracks)
          v.ParticipantTracks.encode(E, b.uint32(42).fork()).ldelim();
      return b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = Z();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.room = E.string();
            break;
          case 2:
            O.identity = E.string();
            break;
          case 3:
            O.trackSids.push(E.string());
            break;
          case 4:
            O.subscribe = E.bool();
            break;
          case 5:
            O.participantTracks.push(v.ParticipantTracks.decode(E, E.uint32()));
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return {
        room: z(C.room) ? String(C.room) : "",
        identity: z(C.identity) ? String(C.identity) : "",
        trackSids: Array.isArray(C == null ? void 0 : C.trackSids) ? C.trackSids.map((b) => String(b)) : [],
        subscribe: z(C.subscribe) ? !!C.subscribe : !1,
        participantTracks: Array.isArray(C == null ? void 0 : C.participantTracks) ? C.participantTracks.map((b) => v.ParticipantTracks.fromJSON(b)) : []
      };
    },
    toJSON(C) {
      const b = {};
      return C.room !== void 0 && (b.room = C.room), C.identity !== void 0 && (b.identity = C.identity), C.trackSids ? b.trackSids = C.trackSids.map((E) => E) : b.trackSids = [], C.subscribe !== void 0 && (b.subscribe = C.subscribe), C.participantTracks ? b.participantTracks = C.participantTracks.map((E) => E ? v.ParticipantTracks.toJSON(E) : void 0) : b.participantTracks = [], b;
    },
    fromPartial(C) {
      var b, E, k, O, A;
      const x = Z();
      return x.room = (b = C.room) !== null && b !== void 0 ? b : "", x.identity = (E = C.identity) !== null && E !== void 0 ? E : "", x.trackSids = ((k = C.trackSids) === null || k === void 0 ? void 0 : k.map((Y) => Y)) || [], x.subscribe = (O = C.subscribe) !== null && O !== void 0 ? O : !1, x.participantTracks = ((A = C.participantTracks) === null || A === void 0 ? void 0 : A.map((Y) => v.ParticipantTracks.fromPartial(Y))) || [], x;
    }
  };
  function de() {
    return {};
  }
  a.UpdateSubscriptionsResponse = {
    encode(C, b = c.default.Writer.create()) {
      return b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = de();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return {};
    },
    toJSON(C) {
      return {};
    },
    fromPartial(C) {
      return de();
    }
  };
  function he() {
    return { room: "", data: new Uint8Array(), kind: 0, destinationSids: [] };
  }
  a.SendDataRequest = {
    encode(C, b = c.default.Writer.create()) {
      if (C.room !== void 0 && C.room !== "" && b.uint32(10).string(C.room), C.data !== void 0 && C.data.length !== 0 && b.uint32(18).bytes(C.data), C.kind !== void 0 && C.kind !== 0 && b.uint32(24).int32(C.kind), C.destinationSids !== void 0 && C.destinationSids.length !== 0)
        for (const E of C.destinationSids)
          b.uint32(34).string(E);
      return b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = he();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.room = E.string();
            break;
          case 2:
            O.data = E.bytes();
            break;
          case 3:
            O.kind = E.int32();
            break;
          case 4:
            O.destinationSids.push(E.string());
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return {
        room: z(C.room) ? String(C.room) : "",
        data: z(C.data) ? _e(C.data) : new Uint8Array(),
        kind: z(C.kind) ? v.dataPacket_KindFromJSON(C.kind) : 0,
        destinationSids: Array.isArray(C == null ? void 0 : C.destinationSids) ? C.destinationSids.map((b) => String(b)) : []
      };
    },
    toJSON(C) {
      const b = {};
      return C.room !== void 0 && (b.room = C.room), C.data !== void 0 && (b.data = q(C.data !== void 0 ? C.data : new Uint8Array())), C.kind !== void 0 && (b.kind = v.dataPacket_KindToJSON(C.kind)), C.destinationSids ? b.destinationSids = C.destinationSids.map((E) => E) : b.destinationSids = [], b;
    },
    fromPartial(C) {
      var b, E, k, O;
      const A = he();
      return A.room = (b = C.room) !== null && b !== void 0 ? b : "", A.data = (E = C.data) !== null && E !== void 0 ? E : new Uint8Array(), A.kind = (k = C.kind) !== null && k !== void 0 ? k : 0, A.destinationSids = ((O = C.destinationSids) === null || O === void 0 ? void 0 : O.map((x) => x)) || [], A;
    }
  };
  function pe() {
    return {};
  }
  a.SendDataResponse = {
    encode(C, b = c.default.Writer.create()) {
      return b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = pe();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return {};
    },
    toJSON(C) {
      return {};
    },
    fromPartial(C) {
      return pe();
    }
  };
  function be() {
    return { room: "", metadata: "" };
  }
  a.UpdateRoomMetadataRequest = {
    encode(C, b = c.default.Writer.create()) {
      return C.room !== void 0 && C.room !== "" && b.uint32(10).string(C.room), C.metadata !== void 0 && C.metadata !== "" && b.uint32(18).string(C.metadata), b;
    },
    decode(C, b) {
      const E = C instanceof c.default.Reader ? C : new c.default.Reader(C);
      let k = b === void 0 ? E.len : E.pos + b;
      const O = be();
      for (; E.pos < k; ) {
        const A = E.uint32();
        switch (A >>> 3) {
          case 1:
            O.room = E.string();
            break;
          case 2:
            O.metadata = E.string();
            break;
          default:
            E.skipType(A & 7);
            break;
        }
      }
      return O;
    },
    fromJSON(C) {
      return {
        room: z(C.room) ? String(C.room) : "",
        metadata: z(C.metadata) ? String(C.metadata) : ""
      };
    },
    toJSON(C) {
      const b = {};
      return C.room !== void 0 && (b.room = C.room), C.metadata !== void 0 && (b.metadata = C.metadata), b;
    },
    fromPartial(C) {
      var b, E;
      const k = be();
      return k.room = (b = C.room) !== null && b !== void 0 ? b : "", k.metadata = (E = C.metadata) !== null && E !== void 0 ? E : "", k;
    }
  };
  var ke = (() => {
    if (typeof ke < "u")
      return ke;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function _e(C) {
    if (ke.Buffer)
      return Uint8Array.from(ke.Buffer.from(C, "base64"));
    {
      const b = ke.atob(C), E = new Uint8Array(b.length);
      for (let k = 0; k < b.length; ++k)
        E[k] = b.charCodeAt(k);
      return E;
    }
  }
  function q(C) {
    if (ke.Buffer)
      return ke.Buffer.from(C).toString("base64");
    {
      const b = [];
      return C.forEach((E) => {
        b.push(String.fromCharCode(E));
      }), ke.btoa(b.join(""));
    }
  }
  function z(C) {
    return C != null;
  }
})(livekit_room);
var __awaiter = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(p) {
    return p instanceof c ? p : new c(function(_) {
      _(p);
    });
  }
  return new (c || (c = Promise))(function(p, _) {
    function I(F) {
      try {
        $(l.next(F));
      } catch (H) {
        _(H);
      }
    }
    function P(F) {
      try {
        $(l.throw(F));
      } catch (H) {
        _(H);
      }
    }
    function $(F) {
      F.done ? p(F.value) : v(F.value).then(I, P);
    }
    $((l = l.apply(a, u || [])).next());
  });
}, __importDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(RoomServiceClient$1, "__esModule", { value: !0 });
RoomServiceClient$1.RoomServiceClient = void 0;
const livekit_models_1$1 = livekit_models, livekit_room_1 = livekit_room, ServiceBase_1 = __importDefault$2(ServiceBase$1), TwirpRPC_1 = TwirpRPC, svc = "RoomService";
class RoomServiceClient extends ServiceBase_1.default {
  /**
   *
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   * @param jwt JWT Token, a pregenerated JWT token for authentication.
   * @param hostHeader A host header to send with the request.
   *
   */
  constructor(u, c, l, v, p) {
    super(c, l), this.jwt = v, this.rpc = new TwirpRPC_1.TwirpRpc(u, TwirpRPC_1.livekitPackage, void 0, p);
  }
  /**
   * Creates a new room. Explicit room creation is not required, since rooms will
   * be automatically created when the first participant joins. This method can be
   * used to customize room settings.
   * @param options
   */
  createRoom(u) {
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc, "CreateRoom", livekit_room_1.CreateRoomRequest.toJSON(livekit_room_1.CreateRoomRequest.fromPartial(u)), this.authHeader({ roomCreate: !0 }));
      return livekit_models_1$1.Room.fromJSON(c);
    });
  }
  /**
   * List active rooms
   * @param names when undefined or empty, list all rooms.
   *              otherwise returns rooms with matching names
   * @returns
   */
  listRooms(u) {
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "ListRooms", livekit_room_1.ListRoomsRequest.toJSON({ names: u ?? [] }), this.authHeader({ roomList: !0 }));
      return (c = livekit_room_1.ListRoomsResponse.fromJSON(l).rooms) !== null && c !== void 0 ? c : [];
    });
  }
  deleteRoom(u) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "DeleteRoom", livekit_room_1.DeleteRoomRequest.toJSON({ room: u }), this.authHeader({ roomCreate: !0 }));
    });
  }
  /**
   * Update metadata of a room
   * @param room name of the room
   * @param metadata the new metadata for the room
   */
  updateRoomMetadata(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "UpdateRoomMetadata", livekit_room_1.UpdateRoomMetadataRequest.toJSON({ room: u, metadata: c }), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.Room.fromJSON(l);
    });
  }
  /**
   * List participants in a room
   * @param room name of the room
   */
  listParticipants(u) {
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "ListParticipants", livekit_room_1.ListParticipantsRequest.toJSON({ room: u }), this.authHeader({ roomAdmin: !0, room: u }));
      return (c = livekit_room_1.ListParticipantsResponse.fromJSON(l).participants) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * Get information on a specific participant, including the tracks that participant
   * has published
   * @param room name of the room
   * @param identity identity of the participant to return
   */
  getParticipant(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "GetParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room: u, identity: c }), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.ParticipantInfo.fromJSON(l);
    });
  }
  /**
   * Removes a participant in the room. This will disconnect the participant
   * and will emit a Disconnected event for that participant.
   * Even after being removed, the participant can still re-join the room.
   * @param room
   * @param identity
   */
  removeParticipant(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "RemoveParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room: u, identity: c }), this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  /**
   * Mutes a track that the participant has published.
   * @param room
   * @param identity
   * @param trackSid sid of the track to be muted
   * @param muted true to mute, false to unmute
   */
  mutePublishedTrack(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      const p = livekit_room_1.MuteRoomTrackRequest.toJSON({
        room: u,
        identity: c,
        trackSid: l,
        muted: v
      }), _ = yield this.rpc.request(svc, "MutePublishedTrack", p, this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_room_1.MuteRoomTrackResponse.fromJSON(_).track;
    });
  }
  /**
   * Updates a participant's metadata or permissions
   * @param room
   * @param identity
   * @param metadata optional, metadata to update
   * @param permission optional, new permissions to assign to participant
   * @param name optional, new name for participant
   */
  updateParticipant(u, c, l, v, p) {
    return __awaiter(this, void 0, void 0, function* () {
      const _ = {
        room: u,
        identity: c,
        metadata: l || "",
        permission: v,
        name: p || ""
      }, I = yield this.rpc.request(svc, "UpdateParticipant", livekit_room_1.UpdateParticipantRequest.toJSON(_), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.ParticipantInfo.fromJSON(I);
    });
  }
  /**
   * Updates a participant's subscription to tracks
   * @param room
   * @param identity
   * @param trackSids
   * @param subscribe true to subscribe, false to unsubscribe
   */
  updateSubscriptions(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      const p = livekit_room_1.UpdateSubscriptionsRequest.toJSON({
        room: u,
        identity: c,
        trackSids: l,
        subscribe: v,
        participantTracks: []
      });
      yield this.rpc.request(svc, "UpdateSubscriptions", p, this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  /**
   * Sends data message to participants in the room
   * @param room
   * @param data opaque payload to send
   * @param kind delivery reliability
   * @param destinationSids optional. when empty, message is sent to everyone
   */
  sendData(u, c, l, v = []) {
    return __awaiter(this, void 0, void 0, function* () {
      const p = livekit_room_1.SendDataRequest.toJSON({
        room: u,
        data: c,
        kind: l,
        destinationSids: v
      });
      yield this.rpc.request(svc, "SendData", p, this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  authHeader(u) {
    return this.jwt ? { Authorization: `Bearer ${this.jwt}` } : super.authHeader(u);
  }
}
RoomServiceClient$1.RoomServiceClient = RoomServiceClient;
var WebhookReceiver$1 = {}, livekit_webhook = {}, __importDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(livekit_webhook, "__esModule", { value: !0 });
livekit_webhook.WebhookEvent = livekit_webhook.protobufPackage = void 0;
const long_1 = __importDefault$1(umdExports), minimal_1 = __importDefault$1(minimal), livekit_egress_1 = livekit_egress, livekit_ingress_1 = livekit_ingress, livekit_models_1 = livekit_models;
livekit_webhook.protobufPackage = "livekit";
function createBaseWebhookEvent() {
  return {
    event: "",
    room: void 0,
    participant: void 0,
    egressInfo: void 0,
    ingressInfo: void 0,
    track: void 0,
    id: "",
    createdAt: 0
  };
}
livekit_webhook.WebhookEvent = {
  encode(a, u = minimal_1.default.Writer.create()) {
    return a.event !== void 0 && a.event !== "" && u.uint32(10).string(a.event), a.room !== void 0 && livekit_models_1.Room.encode(a.room, u.uint32(18).fork()).ldelim(), a.participant !== void 0 && livekit_models_1.ParticipantInfo.encode(a.participant, u.uint32(26).fork()).ldelim(), a.egressInfo !== void 0 && livekit_egress_1.EgressInfo.encode(a.egressInfo, u.uint32(74).fork()).ldelim(), a.ingressInfo !== void 0 && livekit_ingress_1.IngressInfo.encode(a.ingressInfo, u.uint32(82).fork()).ldelim(), a.track !== void 0 && livekit_models_1.TrackInfo.encode(a.track, u.uint32(66).fork()).ldelim(), a.id !== void 0 && a.id !== "" && u.uint32(50).string(a.id), a.createdAt !== void 0 && a.createdAt !== 0 && u.uint32(56).int64(a.createdAt), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1.default.Reader ? a : new minimal_1.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseWebhookEvent();
    for (; c.pos < l; ) {
      const p = c.uint32();
      switch (p >>> 3) {
        case 1:
          v.event = c.string();
          break;
        case 2:
          v.room = livekit_models_1.Room.decode(c, c.uint32());
          break;
        case 3:
          v.participant = livekit_models_1.ParticipantInfo.decode(c, c.uint32());
          break;
        case 9:
          v.egressInfo = livekit_egress_1.EgressInfo.decode(c, c.uint32());
          break;
        case 10:
          v.ingressInfo = livekit_ingress_1.IngressInfo.decode(c, c.uint32());
          break;
        case 8:
          v.track = livekit_models_1.TrackInfo.decode(c, c.uint32());
          break;
        case 6:
          v.id = c.string();
          break;
        case 7:
          v.createdAt = longToNumber(c.int64());
          break;
        default:
          c.skipType(p & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      event: isSet(a.event) ? String(a.event) : "",
      room: isSet(a.room) ? livekit_models_1.Room.fromJSON(a.room) : void 0,
      participant: isSet(a.participant) ? livekit_models_1.ParticipantInfo.fromJSON(a.participant) : void 0,
      egressInfo: isSet(a.egressInfo) ? livekit_egress_1.EgressInfo.fromJSON(a.egressInfo) : void 0,
      ingressInfo: isSet(a.ingressInfo) ? livekit_ingress_1.IngressInfo.fromJSON(a.ingressInfo) : void 0,
      track: isSet(a.track) ? livekit_models_1.TrackInfo.fromJSON(a.track) : void 0,
      id: isSet(a.id) ? String(a.id) : "",
      createdAt: isSet(a.createdAt) ? Number(a.createdAt) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.event !== void 0 && (u.event = a.event), a.room !== void 0 && (u.room = a.room ? livekit_models_1.Room.toJSON(a.room) : void 0), a.participant !== void 0 && (u.participant = a.participant ? livekit_models_1.ParticipantInfo.toJSON(a.participant) : void 0), a.egressInfo !== void 0 && (u.egressInfo = a.egressInfo ? livekit_egress_1.EgressInfo.toJSON(a.egressInfo) : void 0), a.ingressInfo !== void 0 && (u.ingressInfo = a.ingressInfo ? livekit_ingress_1.IngressInfo.toJSON(a.ingressInfo) : void 0), a.track !== void 0 && (u.track = a.track ? livekit_models_1.TrackInfo.toJSON(a.track) : void 0), a.id !== void 0 && (u.id = a.id), a.createdAt !== void 0 && (u.createdAt = Math.round(a.createdAt)), u;
  },
  fromPartial(a) {
    var u, c, l;
    const v = createBaseWebhookEvent();
    return v.event = (u = a.event) !== null && u !== void 0 ? u : "", v.room = a.room !== void 0 && a.room !== null ? livekit_models_1.Room.fromPartial(a.room) : void 0, v.participant = a.participant !== void 0 && a.participant !== null ? livekit_models_1.ParticipantInfo.fromPartial(a.participant) : void 0, v.egressInfo = a.egressInfo !== void 0 && a.egressInfo !== null ? livekit_egress_1.EgressInfo.fromPartial(a.egressInfo) : void 0, v.ingressInfo = a.ingressInfo !== void 0 && a.ingressInfo !== null ? livekit_ingress_1.IngressInfo.fromPartial(a.ingressInfo) : void 0, v.track = a.track !== void 0 && a.track !== null ? livekit_models_1.TrackInfo.fromPartial(a.track) : void 0, v.id = (c = a.id) !== null && c !== void 0 ? c : "", v.createdAt = (l = a.createdAt) !== null && l !== void 0 ? l : 0, v;
  }
};
var globalThis$1 = (() => {
  if (typeof globalThis$1 < "u")
    return globalThis$1;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$1.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1.default.util.Long !== long_1.default && (minimal_1.default.util.Long = long_1.default, minimal_1.default.configure());
function isSet(a) {
  return a != null;
}
var __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(WebhookReceiver$1, "__esModule", { value: !0 });
WebhookReceiver$1.WebhookReceiver = WebhookReceiver$1.authorizeHeader = void 0;
const crypto_1 = __importDefault(requireCryptoBrowserify()), AccessToken_1 = AccessToken$1, livekit_webhook_1 = livekit_webhook;
WebhookReceiver$1.authorizeHeader = "Authorize";
class WebhookReceiver {
  constructor(u, c) {
    this.verifier = new AccessToken_1.TokenVerifier(u, c);
  }
  /**
   *
   * @param body string of the posted body
   * @param authHeader `Authorization` header from the request
   * @param skipAuth true to skip auth validation
   * @returns
   */
  receive(u, c, l = !1) {
    if (!l) {
      if (!c)
        throw new Error("authorization header is empty");
      const v = this.verifier.verify(c), p = crypto_1.default.createHash("sha256");
      if (p.update(u), v.sha256 !== p.digest("base64"))
        throw new Error("sha256 checksum of body does not match");
    }
    return livekit_webhook_1.WebhookEvent.fromJSON(JSON.parse(u));
  }
}
WebhookReceiver$1.WebhookReceiver = WebhookReceiver;
var livekit_internal = {}, livekit_rtc = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(N) {
    return N && N.__esModule ? N : { default: N };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.SimulateScenario = a.DataChannelInfo = a.SyncState = a.SubscriptionPermissionUpdate = a.SubscriptionPermission = a.TrackPermission = a.SubscribedQualityUpdate = a.SubscribedCodec = a.SubscribedQuality = a.StreamStateUpdate = a.StreamStateInfo = a.ConnectionQualityUpdate = a.ConnectionQualityInfo = a.RoomUpdate = a.SpeakersChanged = a.ICEServer = a.UpdateVideoLayers = a.LeaveRequest = a.UpdateTrackSettings = a.UpdateSubscription = a.ParticipantUpdate = a.SessionDescription = a.TrackUnpublishedResponse = a.TrackPublishedResponse = a.JoinResponse = a.MuteTrackRequest = a.TrickleRequest = a.AddTrackRequest = a.SimulcastCodec = a.SignalResponse = a.SignalRequest = a.candidateProtocolToJSON = a.candidateProtocolFromJSON = a.CandidateProtocol = a.streamStateToJSON = a.streamStateFromJSON = a.StreamState = a.signalTargetToJSON = a.signalTargetFromJSON = a.SignalTarget = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_models;
  a.protobufPackage = "livekit";
  var p;
  (function(N) {
    N[N.PUBLISHER = 0] = "PUBLISHER", N[N.SUBSCRIBER = 1] = "SUBSCRIBER", N[N.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(p = a.SignalTarget || (a.SignalTarget = {}));
  function _(N) {
    switch (N) {
      case 0:
      case "PUBLISHER":
        return p.PUBLISHER;
      case 1:
      case "SUBSCRIBER":
        return p.SUBSCRIBER;
      case -1:
      case "UNRECOGNIZED":
      default:
        return p.UNRECOGNIZED;
    }
  }
  a.signalTargetFromJSON = _;
  function I(N) {
    switch (N) {
      case p.PUBLISHER:
        return "PUBLISHER";
      case p.SUBSCRIBER:
        return "SUBSCRIBER";
      case p.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.signalTargetToJSON = I;
  var P;
  (function(N) {
    N[N.ACTIVE = 0] = "ACTIVE", N[N.PAUSED = 1] = "PAUSED", N[N.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(P = a.StreamState || (a.StreamState = {}));
  function $(N) {
    switch (N) {
      case 0:
      case "ACTIVE":
        return P.ACTIVE;
      case 1:
      case "PAUSED":
        return P.PAUSED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return P.UNRECOGNIZED;
    }
  }
  a.streamStateFromJSON = $;
  function F(N) {
    switch (N) {
      case P.ACTIVE:
        return "ACTIVE";
      case P.PAUSED:
        return "PAUSED";
      case P.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamStateToJSON = F;
  var H;
  (function(N) {
    N[N.UDP = 0] = "UDP", N[N.TCP = 1] = "TCP", N[N.TLS = 2] = "TLS", N[N.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(H = a.CandidateProtocol || (a.CandidateProtocol = {}));
  function j(N) {
    switch (N) {
      case 0:
      case "UDP":
        return H.UDP;
      case 1:
      case "TCP":
        return H.TCP;
      case 2:
      case "TLS":
        return H.TLS;
      case -1:
      case "UNRECOGNIZED":
      default:
        return H.UNRECOGNIZED;
    }
  }
  a.candidateProtocolFromJSON = j;
  function ee(N) {
    switch (N) {
      case H.UDP:
        return "UDP";
      case H.TCP:
        return "TCP";
      case H.TLS:
        return "TLS";
      case H.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.candidateProtocolToJSON = ee;
  function X() {
    return {
      offer: void 0,
      answer: void 0,
      trickle: void 0,
      addTrack: void 0,
      mute: void 0,
      subscription: void 0,
      trackSetting: void 0,
      leave: void 0,
      updateLayers: void 0,
      subscriptionPermission: void 0,
      syncState: void 0,
      simulate: void 0,
      ping: void 0
    };
  }
  a.SignalRequest = {
    encode(N, re = l.default.Writer.create()) {
      return N.offer !== void 0 && a.SessionDescription.encode(N.offer, re.uint32(10).fork()).ldelim(), N.answer !== void 0 && a.SessionDescription.encode(N.answer, re.uint32(18).fork()).ldelim(), N.trickle !== void 0 && a.TrickleRequest.encode(N.trickle, re.uint32(26).fork()).ldelim(), N.addTrack !== void 0 && a.AddTrackRequest.encode(N.addTrack, re.uint32(34).fork()).ldelim(), N.mute !== void 0 && a.MuteTrackRequest.encode(N.mute, re.uint32(42).fork()).ldelim(), N.subscription !== void 0 && a.UpdateSubscription.encode(N.subscription, re.uint32(50).fork()).ldelim(), N.trackSetting !== void 0 && a.UpdateTrackSettings.encode(N.trackSetting, re.uint32(58).fork()).ldelim(), N.leave !== void 0 && a.LeaveRequest.encode(N.leave, re.uint32(66).fork()).ldelim(), N.updateLayers !== void 0 && a.UpdateVideoLayers.encode(N.updateLayers, re.uint32(82).fork()).ldelim(), N.subscriptionPermission !== void 0 && a.SubscriptionPermission.encode(N.subscriptionPermission, re.uint32(90).fork()).ldelim(), N.syncState !== void 0 && a.SyncState.encode(N.syncState, re.uint32(98).fork()).ldelim(), N.simulate !== void 0 && a.SimulateScenario.encode(N.simulate, re.uint32(106).fork()).ldelim(), N.ping !== void 0 && re.uint32(112).int64(N.ping), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = X();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.offer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 2:
            Oe.answer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 3:
            Oe.trickle = a.TrickleRequest.decode(le, le.uint32());
            break;
          case 4:
            Oe.addTrack = a.AddTrackRequest.decode(le, le.uint32());
            break;
          case 5:
            Oe.mute = a.MuteTrackRequest.decode(le, le.uint32());
            break;
          case 6:
            Oe.subscription = a.UpdateSubscription.decode(le, le.uint32());
            break;
          case 7:
            Oe.trackSetting = a.UpdateTrackSettings.decode(le, le.uint32());
            break;
          case 8:
            Oe.leave = a.LeaveRequest.decode(le, le.uint32());
            break;
          case 10:
            Oe.updateLayers = a.UpdateVideoLayers.decode(le, le.uint32());
            break;
          case 11:
            Oe.subscriptionPermission = a.SubscriptionPermission.decode(le, le.uint32());
            break;
          case 12:
            Oe.syncState = a.SyncState.decode(le, le.uint32());
            break;
          case 13:
            Oe.simulate = a.SimulateScenario.decode(le, le.uint32());
            break;
          case 14:
            Oe.ping = xe(le.int64());
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        offer: ae(N.offer) ? a.SessionDescription.fromJSON(N.offer) : void 0,
        answer: ae(N.answer) ? a.SessionDescription.fromJSON(N.answer) : void 0,
        trickle: ae(N.trickle) ? a.TrickleRequest.fromJSON(N.trickle) : void 0,
        addTrack: ae(N.addTrack) ? a.AddTrackRequest.fromJSON(N.addTrack) : void 0,
        mute: ae(N.mute) ? a.MuteTrackRequest.fromJSON(N.mute) : void 0,
        subscription: ae(N.subscription) ? a.UpdateSubscription.fromJSON(N.subscription) : void 0,
        trackSetting: ae(N.trackSetting) ? a.UpdateTrackSettings.fromJSON(N.trackSetting) : void 0,
        leave: ae(N.leave) ? a.LeaveRequest.fromJSON(N.leave) : void 0,
        updateLayers: ae(N.updateLayers) ? a.UpdateVideoLayers.fromJSON(N.updateLayers) : void 0,
        subscriptionPermission: ae(N.subscriptionPermission) ? a.SubscriptionPermission.fromJSON(N.subscriptionPermission) : void 0,
        syncState: ae(N.syncState) ? a.SyncState.fromJSON(N.syncState) : void 0,
        simulate: ae(N.simulate) ? a.SimulateScenario.fromJSON(N.simulate) : void 0,
        ping: ae(N.ping) ? Number(N.ping) : void 0
      };
    },
    toJSON(N) {
      const re = {};
      return N.offer !== void 0 && (re.offer = N.offer ? a.SessionDescription.toJSON(N.offer) : void 0), N.answer !== void 0 && (re.answer = N.answer ? a.SessionDescription.toJSON(N.answer) : void 0), N.trickle !== void 0 && (re.trickle = N.trickle ? a.TrickleRequest.toJSON(N.trickle) : void 0), N.addTrack !== void 0 && (re.addTrack = N.addTrack ? a.AddTrackRequest.toJSON(N.addTrack) : void 0), N.mute !== void 0 && (re.mute = N.mute ? a.MuteTrackRequest.toJSON(N.mute) : void 0), N.subscription !== void 0 && (re.subscription = N.subscription ? a.UpdateSubscription.toJSON(N.subscription) : void 0), N.trackSetting !== void 0 && (re.trackSetting = N.trackSetting ? a.UpdateTrackSettings.toJSON(N.trackSetting) : void 0), N.leave !== void 0 && (re.leave = N.leave ? a.LeaveRequest.toJSON(N.leave) : void 0), N.updateLayers !== void 0 && (re.updateLayers = N.updateLayers ? a.UpdateVideoLayers.toJSON(N.updateLayers) : void 0), N.subscriptionPermission !== void 0 && (re.subscriptionPermission = N.subscriptionPermission ? a.SubscriptionPermission.toJSON(N.subscriptionPermission) : void 0), N.syncState !== void 0 && (re.syncState = N.syncState ? a.SyncState.toJSON(N.syncState) : void 0), N.simulate !== void 0 && (re.simulate = N.simulate ? a.SimulateScenario.toJSON(N.simulate) : void 0), N.ping !== void 0 && (re.ping = Math.round(N.ping)), re;
    },
    fromPartial(N) {
      var re;
      const le = X();
      return le.offer = N.offer !== void 0 && N.offer !== null ? a.SessionDescription.fromPartial(N.offer) : void 0, le.answer = N.answer !== void 0 && N.answer !== null ? a.SessionDescription.fromPartial(N.answer) : void 0, le.trickle = N.trickle !== void 0 && N.trickle !== null ? a.TrickleRequest.fromPartial(N.trickle) : void 0, le.addTrack = N.addTrack !== void 0 && N.addTrack !== null ? a.AddTrackRequest.fromPartial(N.addTrack) : void 0, le.mute = N.mute !== void 0 && N.mute !== null ? a.MuteTrackRequest.fromPartial(N.mute) : void 0, le.subscription = N.subscription !== void 0 && N.subscription !== null ? a.UpdateSubscription.fromPartial(N.subscription) : void 0, le.trackSetting = N.trackSetting !== void 0 && N.trackSetting !== null ? a.UpdateTrackSettings.fromPartial(N.trackSetting) : void 0, le.leave = N.leave !== void 0 && N.leave !== null ? a.LeaveRequest.fromPartial(N.leave) : void 0, le.updateLayers = N.updateLayers !== void 0 && N.updateLayers !== null ? a.UpdateVideoLayers.fromPartial(N.updateLayers) : void 0, le.subscriptionPermission = N.subscriptionPermission !== void 0 && N.subscriptionPermission !== null ? a.SubscriptionPermission.fromPartial(N.subscriptionPermission) : void 0, le.syncState = N.syncState !== void 0 && N.syncState !== null ? a.SyncState.fromPartial(N.syncState) : void 0, le.simulate = N.simulate !== void 0 && N.simulate !== null ? a.SimulateScenario.fromPartial(N.simulate) : void 0, le.ping = (re = N.ping) !== null && re !== void 0 ? re : void 0, le;
    }
  };
  function ie() {
    return {
      join: void 0,
      answer: void 0,
      offer: void 0,
      trickle: void 0,
      update: void 0,
      trackPublished: void 0,
      leave: void 0,
      mute: void 0,
      speakersChanged: void 0,
      roomUpdate: void 0,
      connectionQuality: void 0,
      streamStateUpdate: void 0,
      subscribedQualityUpdate: void 0,
      subscriptionPermissionUpdate: void 0,
      refreshToken: void 0,
      trackUnpublished: void 0,
      pong: void 0
    };
  }
  a.SignalResponse = {
    encode(N, re = l.default.Writer.create()) {
      return N.join !== void 0 && a.JoinResponse.encode(N.join, re.uint32(10).fork()).ldelim(), N.answer !== void 0 && a.SessionDescription.encode(N.answer, re.uint32(18).fork()).ldelim(), N.offer !== void 0 && a.SessionDescription.encode(N.offer, re.uint32(26).fork()).ldelim(), N.trickle !== void 0 && a.TrickleRequest.encode(N.trickle, re.uint32(34).fork()).ldelim(), N.update !== void 0 && a.ParticipantUpdate.encode(N.update, re.uint32(42).fork()).ldelim(), N.trackPublished !== void 0 && a.TrackPublishedResponse.encode(N.trackPublished, re.uint32(50).fork()).ldelim(), N.leave !== void 0 && a.LeaveRequest.encode(N.leave, re.uint32(66).fork()).ldelim(), N.mute !== void 0 && a.MuteTrackRequest.encode(N.mute, re.uint32(74).fork()).ldelim(), N.speakersChanged !== void 0 && a.SpeakersChanged.encode(N.speakersChanged, re.uint32(82).fork()).ldelim(), N.roomUpdate !== void 0 && a.RoomUpdate.encode(N.roomUpdate, re.uint32(90).fork()).ldelim(), N.connectionQuality !== void 0 && a.ConnectionQualityUpdate.encode(N.connectionQuality, re.uint32(98).fork()).ldelim(), N.streamStateUpdate !== void 0 && a.StreamStateUpdate.encode(N.streamStateUpdate, re.uint32(106).fork()).ldelim(), N.subscribedQualityUpdate !== void 0 && a.SubscribedQualityUpdate.encode(N.subscribedQualityUpdate, re.uint32(114).fork()).ldelim(), N.subscriptionPermissionUpdate !== void 0 && a.SubscriptionPermissionUpdate.encode(N.subscriptionPermissionUpdate, re.uint32(122).fork()).ldelim(), N.refreshToken !== void 0 && re.uint32(130).string(N.refreshToken), N.trackUnpublished !== void 0 && a.TrackUnpublishedResponse.encode(N.trackUnpublished, re.uint32(138).fork()).ldelim(), N.pong !== void 0 && re.uint32(144).int64(N.pong), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = ie();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.join = a.JoinResponse.decode(le, le.uint32());
            break;
          case 2:
            Oe.answer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 3:
            Oe.offer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 4:
            Oe.trickle = a.TrickleRequest.decode(le, le.uint32());
            break;
          case 5:
            Oe.update = a.ParticipantUpdate.decode(le, le.uint32());
            break;
          case 6:
            Oe.trackPublished = a.TrackPublishedResponse.decode(le, le.uint32());
            break;
          case 8:
            Oe.leave = a.LeaveRequest.decode(le, le.uint32());
            break;
          case 9:
            Oe.mute = a.MuteTrackRequest.decode(le, le.uint32());
            break;
          case 10:
            Oe.speakersChanged = a.SpeakersChanged.decode(le, le.uint32());
            break;
          case 11:
            Oe.roomUpdate = a.RoomUpdate.decode(le, le.uint32());
            break;
          case 12:
            Oe.connectionQuality = a.ConnectionQualityUpdate.decode(le, le.uint32());
            break;
          case 13:
            Oe.streamStateUpdate = a.StreamStateUpdate.decode(le, le.uint32());
            break;
          case 14:
            Oe.subscribedQualityUpdate = a.SubscribedQualityUpdate.decode(le, le.uint32());
            break;
          case 15:
            Oe.subscriptionPermissionUpdate = a.SubscriptionPermissionUpdate.decode(le, le.uint32());
            break;
          case 16:
            Oe.refreshToken = le.string();
            break;
          case 17:
            Oe.trackUnpublished = a.TrackUnpublishedResponse.decode(le, le.uint32());
            break;
          case 18:
            Oe.pong = xe(le.int64());
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        join: ae(N.join) ? a.JoinResponse.fromJSON(N.join) : void 0,
        answer: ae(N.answer) ? a.SessionDescription.fromJSON(N.answer) : void 0,
        offer: ae(N.offer) ? a.SessionDescription.fromJSON(N.offer) : void 0,
        trickle: ae(N.trickle) ? a.TrickleRequest.fromJSON(N.trickle) : void 0,
        update: ae(N.update) ? a.ParticipantUpdate.fromJSON(N.update) : void 0,
        trackPublished: ae(N.trackPublished) ? a.TrackPublishedResponse.fromJSON(N.trackPublished) : void 0,
        leave: ae(N.leave) ? a.LeaveRequest.fromJSON(N.leave) : void 0,
        mute: ae(N.mute) ? a.MuteTrackRequest.fromJSON(N.mute) : void 0,
        speakersChanged: ae(N.speakersChanged) ? a.SpeakersChanged.fromJSON(N.speakersChanged) : void 0,
        roomUpdate: ae(N.roomUpdate) ? a.RoomUpdate.fromJSON(N.roomUpdate) : void 0,
        connectionQuality: ae(N.connectionQuality) ? a.ConnectionQualityUpdate.fromJSON(N.connectionQuality) : void 0,
        streamStateUpdate: ae(N.streamStateUpdate) ? a.StreamStateUpdate.fromJSON(N.streamStateUpdate) : void 0,
        subscribedQualityUpdate: ae(N.subscribedQualityUpdate) ? a.SubscribedQualityUpdate.fromJSON(N.subscribedQualityUpdate) : void 0,
        subscriptionPermissionUpdate: ae(N.subscriptionPermissionUpdate) ? a.SubscriptionPermissionUpdate.fromJSON(N.subscriptionPermissionUpdate) : void 0,
        refreshToken: ae(N.refreshToken) ? String(N.refreshToken) : void 0,
        trackUnpublished: ae(N.trackUnpublished) ? a.TrackUnpublishedResponse.fromJSON(N.trackUnpublished) : void 0,
        pong: ae(N.pong) ? Number(N.pong) : void 0
      };
    },
    toJSON(N) {
      const re = {};
      return N.join !== void 0 && (re.join = N.join ? a.JoinResponse.toJSON(N.join) : void 0), N.answer !== void 0 && (re.answer = N.answer ? a.SessionDescription.toJSON(N.answer) : void 0), N.offer !== void 0 && (re.offer = N.offer ? a.SessionDescription.toJSON(N.offer) : void 0), N.trickle !== void 0 && (re.trickle = N.trickle ? a.TrickleRequest.toJSON(N.trickle) : void 0), N.update !== void 0 && (re.update = N.update ? a.ParticipantUpdate.toJSON(N.update) : void 0), N.trackPublished !== void 0 && (re.trackPublished = N.trackPublished ? a.TrackPublishedResponse.toJSON(N.trackPublished) : void 0), N.leave !== void 0 && (re.leave = N.leave ? a.LeaveRequest.toJSON(N.leave) : void 0), N.mute !== void 0 && (re.mute = N.mute ? a.MuteTrackRequest.toJSON(N.mute) : void 0), N.speakersChanged !== void 0 && (re.speakersChanged = N.speakersChanged ? a.SpeakersChanged.toJSON(N.speakersChanged) : void 0), N.roomUpdate !== void 0 && (re.roomUpdate = N.roomUpdate ? a.RoomUpdate.toJSON(N.roomUpdate) : void 0), N.connectionQuality !== void 0 && (re.connectionQuality = N.connectionQuality ? a.ConnectionQualityUpdate.toJSON(N.connectionQuality) : void 0), N.streamStateUpdate !== void 0 && (re.streamStateUpdate = N.streamStateUpdate ? a.StreamStateUpdate.toJSON(N.streamStateUpdate) : void 0), N.subscribedQualityUpdate !== void 0 && (re.subscribedQualityUpdate = N.subscribedQualityUpdate ? a.SubscribedQualityUpdate.toJSON(N.subscribedQualityUpdate) : void 0), N.subscriptionPermissionUpdate !== void 0 && (re.subscriptionPermissionUpdate = N.subscriptionPermissionUpdate ? a.SubscriptionPermissionUpdate.toJSON(N.subscriptionPermissionUpdate) : void 0), N.refreshToken !== void 0 && (re.refreshToken = N.refreshToken), N.trackUnpublished !== void 0 && (re.trackUnpublished = N.trackUnpublished ? a.TrackUnpublishedResponse.toJSON(N.trackUnpublished) : void 0), N.pong !== void 0 && (re.pong = Math.round(N.pong)), re;
    },
    fromPartial(N) {
      var re, le;
      const Ne = ie();
      return Ne.join = N.join !== void 0 && N.join !== null ? a.JoinResponse.fromPartial(N.join) : void 0, Ne.answer = N.answer !== void 0 && N.answer !== null ? a.SessionDescription.fromPartial(N.answer) : void 0, Ne.offer = N.offer !== void 0 && N.offer !== null ? a.SessionDescription.fromPartial(N.offer) : void 0, Ne.trickle = N.trickle !== void 0 && N.trickle !== null ? a.TrickleRequest.fromPartial(N.trickle) : void 0, Ne.update = N.update !== void 0 && N.update !== null ? a.ParticipantUpdate.fromPartial(N.update) : void 0, Ne.trackPublished = N.trackPublished !== void 0 && N.trackPublished !== null ? a.TrackPublishedResponse.fromPartial(N.trackPublished) : void 0, Ne.leave = N.leave !== void 0 && N.leave !== null ? a.LeaveRequest.fromPartial(N.leave) : void 0, Ne.mute = N.mute !== void 0 && N.mute !== null ? a.MuteTrackRequest.fromPartial(N.mute) : void 0, Ne.speakersChanged = N.speakersChanged !== void 0 && N.speakersChanged !== null ? a.SpeakersChanged.fromPartial(N.speakersChanged) : void 0, Ne.roomUpdate = N.roomUpdate !== void 0 && N.roomUpdate !== null ? a.RoomUpdate.fromPartial(N.roomUpdate) : void 0, Ne.connectionQuality = N.connectionQuality !== void 0 && N.connectionQuality !== null ? a.ConnectionQualityUpdate.fromPartial(N.connectionQuality) : void 0, Ne.streamStateUpdate = N.streamStateUpdate !== void 0 && N.streamStateUpdate !== null ? a.StreamStateUpdate.fromPartial(N.streamStateUpdate) : void 0, Ne.subscribedQualityUpdate = N.subscribedQualityUpdate !== void 0 && N.subscribedQualityUpdate !== null ? a.SubscribedQualityUpdate.fromPartial(N.subscribedQualityUpdate) : void 0, Ne.subscriptionPermissionUpdate = N.subscriptionPermissionUpdate !== void 0 && N.subscriptionPermissionUpdate !== null ? a.SubscriptionPermissionUpdate.fromPartial(N.subscriptionPermissionUpdate) : void 0, Ne.refreshToken = (re = N.refreshToken) !== null && re !== void 0 ? re : void 0, Ne.trackUnpublished = N.trackUnpublished !== void 0 && N.trackUnpublished !== null ? a.TrackUnpublishedResponse.fromPartial(N.trackUnpublished) : void 0, Ne.pong = (le = N.pong) !== null && le !== void 0 ? le : void 0, Ne;
    }
  };
  function Q() {
    return { codec: "", cid: "", enableSimulcastLayers: !1 };
  }
  a.SimulcastCodec = {
    encode(N, re = l.default.Writer.create()) {
      return N.codec !== void 0 && N.codec !== "" && re.uint32(10).string(N.codec), N.cid !== void 0 && N.cid !== "" && re.uint32(18).string(N.cid), N.enableSimulcastLayers === !0 && re.uint32(24).bool(N.enableSimulcastLayers), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = Q();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.codec = le.string();
            break;
          case 2:
            Oe.cid = le.string();
            break;
          case 3:
            Oe.enableSimulcastLayers = le.bool();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        codec: ae(N.codec) ? String(N.codec) : "",
        cid: ae(N.cid) ? String(N.cid) : "",
        enableSimulcastLayers: ae(N.enableSimulcastLayers) ? !!N.enableSimulcastLayers : !1
      };
    },
    toJSON(N) {
      const re = {};
      return N.codec !== void 0 && (re.codec = N.codec), N.cid !== void 0 && (re.cid = N.cid), N.enableSimulcastLayers !== void 0 && (re.enableSimulcastLayers = N.enableSimulcastLayers), re;
    },
    fromPartial(N) {
      var re, le, Ne;
      const Oe = Q();
      return Oe.codec = (re = N.codec) !== null && re !== void 0 ? re : "", Oe.cid = (le = N.cid) !== null && le !== void 0 ? le : "", Oe.enableSimulcastLayers = (Ne = N.enableSimulcastLayers) !== null && Ne !== void 0 ? Ne : !1, Oe;
    }
  };
  function ne() {
    return {
      cid: "",
      name: "",
      type: 0,
      width: 0,
      height: 0,
      muted: !1,
      disableDtx: !1,
      source: 0,
      layers: [],
      simulcastCodecs: [],
      sid: "",
      stereo: !1,
      disableRed: !1
    };
  }
  a.AddTrackRequest = {
    encode(N, re = l.default.Writer.create()) {
      if (N.cid !== void 0 && N.cid !== "" && re.uint32(10).string(N.cid), N.name !== void 0 && N.name !== "" && re.uint32(18).string(N.name), N.type !== void 0 && N.type !== 0 && re.uint32(24).int32(N.type), N.width !== void 0 && N.width !== 0 && re.uint32(32).uint32(N.width), N.height !== void 0 && N.height !== 0 && re.uint32(40).uint32(N.height), N.muted === !0 && re.uint32(48).bool(N.muted), N.disableDtx === !0 && re.uint32(56).bool(N.disableDtx), N.source !== void 0 && N.source !== 0 && re.uint32(64).int32(N.source), N.layers !== void 0 && N.layers.length !== 0)
        for (const le of N.layers)
          v.VideoLayer.encode(le, re.uint32(74).fork()).ldelim();
      if (N.simulcastCodecs !== void 0 && N.simulcastCodecs.length !== 0)
        for (const le of N.simulcastCodecs)
          a.SimulcastCodec.encode(le, re.uint32(82).fork()).ldelim();
      return N.sid !== void 0 && N.sid !== "" && re.uint32(90).string(N.sid), N.stereo === !0 && re.uint32(96).bool(N.stereo), N.disableRed === !0 && re.uint32(104).bool(N.disableRed), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = ne();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.cid = le.string();
            break;
          case 2:
            Oe.name = le.string();
            break;
          case 3:
            Oe.type = le.int32();
            break;
          case 4:
            Oe.width = le.uint32();
            break;
          case 5:
            Oe.height = le.uint32();
            break;
          case 6:
            Oe.muted = le.bool();
            break;
          case 7:
            Oe.disableDtx = le.bool();
            break;
          case 8:
            Oe.source = le.int32();
            break;
          case 9:
            Oe.layers.push(v.VideoLayer.decode(le, le.uint32()));
            break;
          case 10:
            Oe.simulcastCodecs.push(a.SimulcastCodec.decode(le, le.uint32()));
            break;
          case 11:
            Oe.sid = le.string();
            break;
          case 12:
            Oe.stereo = le.bool();
            break;
          case 13:
            Oe.disableRed = le.bool();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        cid: ae(N.cid) ? String(N.cid) : "",
        name: ae(N.name) ? String(N.name) : "",
        type: ae(N.type) ? v.trackTypeFromJSON(N.type) : 0,
        width: ae(N.width) ? Number(N.width) : 0,
        height: ae(N.height) ? Number(N.height) : 0,
        muted: ae(N.muted) ? !!N.muted : !1,
        disableDtx: ae(N.disableDtx) ? !!N.disableDtx : !1,
        source: ae(N.source) ? v.trackSourceFromJSON(N.source) : 0,
        layers: Array.isArray(N == null ? void 0 : N.layers) ? N.layers.map((re) => v.VideoLayer.fromJSON(re)) : [],
        simulcastCodecs: Array.isArray(N == null ? void 0 : N.simulcastCodecs) ? N.simulcastCodecs.map((re) => a.SimulcastCodec.fromJSON(re)) : [],
        sid: ae(N.sid) ? String(N.sid) : "",
        stereo: ae(N.stereo) ? !!N.stereo : !1,
        disableRed: ae(N.disableRed) ? !!N.disableRed : !1
      };
    },
    toJSON(N) {
      const re = {};
      return N.cid !== void 0 && (re.cid = N.cid), N.name !== void 0 && (re.name = N.name), N.type !== void 0 && (re.type = v.trackTypeToJSON(N.type)), N.width !== void 0 && (re.width = Math.round(N.width)), N.height !== void 0 && (re.height = Math.round(N.height)), N.muted !== void 0 && (re.muted = N.muted), N.disableDtx !== void 0 && (re.disableDtx = N.disableDtx), N.source !== void 0 && (re.source = v.trackSourceToJSON(N.source)), N.layers ? re.layers = N.layers.map((le) => le ? v.VideoLayer.toJSON(le) : void 0) : re.layers = [], N.simulcastCodecs ? re.simulcastCodecs = N.simulcastCodecs.map((le) => le ? a.SimulcastCodec.toJSON(le) : void 0) : re.simulcastCodecs = [], N.sid !== void 0 && (re.sid = N.sid), N.stereo !== void 0 && (re.stereo = N.stereo), N.disableRed !== void 0 && (re.disableRed = N.disableRed), re;
    },
    fromPartial(N) {
      var re, le, Ne, Oe, qe, je, Fe, yt, Xe, Ge, V, ge, Te;
      const We = ne();
      return We.cid = (re = N.cid) !== null && re !== void 0 ? re : "", We.name = (le = N.name) !== null && le !== void 0 ? le : "", We.type = (Ne = N.type) !== null && Ne !== void 0 ? Ne : 0, We.width = (Oe = N.width) !== null && Oe !== void 0 ? Oe : 0, We.height = (qe = N.height) !== null && qe !== void 0 ? qe : 0, We.muted = (je = N.muted) !== null && je !== void 0 ? je : !1, We.disableDtx = (Fe = N.disableDtx) !== null && Fe !== void 0 ? Fe : !1, We.source = (yt = N.source) !== null && yt !== void 0 ? yt : 0, We.layers = ((Xe = N.layers) === null || Xe === void 0 ? void 0 : Xe.map((Re) => v.VideoLayer.fromPartial(Re))) || [], We.simulcastCodecs = ((Ge = N.simulcastCodecs) === null || Ge === void 0 ? void 0 : Ge.map((Re) => a.SimulcastCodec.fromPartial(Re))) || [], We.sid = (V = N.sid) !== null && V !== void 0 ? V : "", We.stereo = (ge = N.stereo) !== null && ge !== void 0 ? ge : !1, We.disableRed = (Te = N.disableRed) !== null && Te !== void 0 ? Te : !1, We;
    }
  };
  function Z() {
    return { candidateInit: "", target: 0 };
  }
  a.TrickleRequest = {
    encode(N, re = l.default.Writer.create()) {
      return N.candidateInit !== void 0 && N.candidateInit !== "" && re.uint32(10).string(N.candidateInit), N.target !== void 0 && N.target !== 0 && re.uint32(16).int32(N.target), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = Z();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.candidateInit = le.string();
            break;
          case 2:
            Oe.target = le.int32();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        candidateInit: ae(N.candidateInit) ? String(N.candidateInit) : "",
        target: ae(N.target) ? _(N.target) : 0
      };
    },
    toJSON(N) {
      const re = {};
      return N.candidateInit !== void 0 && (re.candidateInit = N.candidateInit), N.target !== void 0 && (re.target = I(N.target)), re;
    },
    fromPartial(N) {
      var re, le;
      const Ne = Z();
      return Ne.candidateInit = (re = N.candidateInit) !== null && re !== void 0 ? re : "", Ne.target = (le = N.target) !== null && le !== void 0 ? le : 0, Ne;
    }
  };
  function de() {
    return { sid: "", muted: !1 };
  }
  a.MuteTrackRequest = {
    encode(N, re = l.default.Writer.create()) {
      return N.sid !== void 0 && N.sid !== "" && re.uint32(10).string(N.sid), N.muted === !0 && re.uint32(16).bool(N.muted), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = de();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.sid = le.string();
            break;
          case 2:
            Oe.muted = le.bool();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        sid: ae(N.sid) ? String(N.sid) : "",
        muted: ae(N.muted) ? !!N.muted : !1
      };
    },
    toJSON(N) {
      const re = {};
      return N.sid !== void 0 && (re.sid = N.sid), N.muted !== void 0 && (re.muted = N.muted), re;
    },
    fromPartial(N) {
      var re, le;
      const Ne = de();
      return Ne.sid = (re = N.sid) !== null && re !== void 0 ? re : "", Ne.muted = (le = N.muted) !== null && le !== void 0 ? le : !1, Ne;
    }
  };
  function he() {
    return {
      room: void 0,
      participant: void 0,
      otherParticipants: [],
      serverVersion: "",
      iceServers: [],
      subscriberPrimary: !1,
      alternativeUrl: "",
      clientConfiguration: void 0,
      serverRegion: "",
      pingTimeout: 0,
      pingInterval: 0,
      serverInfo: void 0
    };
  }
  a.JoinResponse = {
    encode(N, re = l.default.Writer.create()) {
      if (N.room !== void 0 && v.Room.encode(N.room, re.uint32(10).fork()).ldelim(), N.participant !== void 0 && v.ParticipantInfo.encode(N.participant, re.uint32(18).fork()).ldelim(), N.otherParticipants !== void 0 && N.otherParticipants.length !== 0)
        for (const le of N.otherParticipants)
          v.ParticipantInfo.encode(le, re.uint32(26).fork()).ldelim();
      if (N.serverVersion !== void 0 && N.serverVersion !== "" && re.uint32(34).string(N.serverVersion), N.iceServers !== void 0 && N.iceServers.length !== 0)
        for (const le of N.iceServers)
          a.ICEServer.encode(le, re.uint32(42).fork()).ldelim();
      return N.subscriberPrimary === !0 && re.uint32(48).bool(N.subscriberPrimary), N.alternativeUrl !== void 0 && N.alternativeUrl !== "" && re.uint32(58).string(N.alternativeUrl), N.clientConfiguration !== void 0 && v.ClientConfiguration.encode(N.clientConfiguration, re.uint32(66).fork()).ldelim(), N.serverRegion !== void 0 && N.serverRegion !== "" && re.uint32(74).string(N.serverRegion), N.pingTimeout !== void 0 && N.pingTimeout !== 0 && re.uint32(80).int32(N.pingTimeout), N.pingInterval !== void 0 && N.pingInterval !== 0 && re.uint32(88).int32(N.pingInterval), N.serverInfo !== void 0 && v.ServerInfo.encode(N.serverInfo, re.uint32(98).fork()).ldelim(), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = he();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.room = v.Room.decode(le, le.uint32());
            break;
          case 2:
            Oe.participant = v.ParticipantInfo.decode(le, le.uint32());
            break;
          case 3:
            Oe.otherParticipants.push(v.ParticipantInfo.decode(le, le.uint32()));
            break;
          case 4:
            Oe.serverVersion = le.string();
            break;
          case 5:
            Oe.iceServers.push(a.ICEServer.decode(le, le.uint32()));
            break;
          case 6:
            Oe.subscriberPrimary = le.bool();
            break;
          case 7:
            Oe.alternativeUrl = le.string();
            break;
          case 8:
            Oe.clientConfiguration = v.ClientConfiguration.decode(le, le.uint32());
            break;
          case 9:
            Oe.serverRegion = le.string();
            break;
          case 10:
            Oe.pingTimeout = le.int32();
            break;
          case 11:
            Oe.pingInterval = le.int32();
            break;
          case 12:
            Oe.serverInfo = v.ServerInfo.decode(le, le.uint32());
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        room: ae(N.room) ? v.Room.fromJSON(N.room) : void 0,
        participant: ae(N.participant) ? v.ParticipantInfo.fromJSON(N.participant) : void 0,
        otherParticipants: Array.isArray(N == null ? void 0 : N.otherParticipants) ? N.otherParticipants.map((re) => v.ParticipantInfo.fromJSON(re)) : [],
        serverVersion: ae(N.serverVersion) ? String(N.serverVersion) : "",
        iceServers: Array.isArray(N == null ? void 0 : N.iceServers) ? N.iceServers.map((re) => a.ICEServer.fromJSON(re)) : [],
        subscriberPrimary: ae(N.subscriberPrimary) ? !!N.subscriberPrimary : !1,
        alternativeUrl: ae(N.alternativeUrl) ? String(N.alternativeUrl) : "",
        clientConfiguration: ae(N.clientConfiguration) ? v.ClientConfiguration.fromJSON(N.clientConfiguration) : void 0,
        serverRegion: ae(N.serverRegion) ? String(N.serverRegion) : "",
        pingTimeout: ae(N.pingTimeout) ? Number(N.pingTimeout) : 0,
        pingInterval: ae(N.pingInterval) ? Number(N.pingInterval) : 0,
        serverInfo: ae(N.serverInfo) ? v.ServerInfo.fromJSON(N.serverInfo) : void 0
      };
    },
    toJSON(N) {
      const re = {};
      return N.room !== void 0 && (re.room = N.room ? v.Room.toJSON(N.room) : void 0), N.participant !== void 0 && (re.participant = N.participant ? v.ParticipantInfo.toJSON(N.participant) : void 0), N.otherParticipants ? re.otherParticipants = N.otherParticipants.map((le) => le ? v.ParticipantInfo.toJSON(le) : void 0) : re.otherParticipants = [], N.serverVersion !== void 0 && (re.serverVersion = N.serverVersion), N.iceServers ? re.iceServers = N.iceServers.map((le) => le ? a.ICEServer.toJSON(le) : void 0) : re.iceServers = [], N.subscriberPrimary !== void 0 && (re.subscriberPrimary = N.subscriberPrimary), N.alternativeUrl !== void 0 && (re.alternativeUrl = N.alternativeUrl), N.clientConfiguration !== void 0 && (re.clientConfiguration = N.clientConfiguration ? v.ClientConfiguration.toJSON(N.clientConfiguration) : void 0), N.serverRegion !== void 0 && (re.serverRegion = N.serverRegion), N.pingTimeout !== void 0 && (re.pingTimeout = Math.round(N.pingTimeout)), N.pingInterval !== void 0 && (re.pingInterval = Math.round(N.pingInterval)), N.serverInfo !== void 0 && (re.serverInfo = N.serverInfo ? v.ServerInfo.toJSON(N.serverInfo) : void 0), re;
    },
    fromPartial(N) {
      var re, le, Ne, Oe, qe, je, Fe, yt;
      const Xe = he();
      return Xe.room = N.room !== void 0 && N.room !== null ? v.Room.fromPartial(N.room) : void 0, Xe.participant = N.participant !== void 0 && N.participant !== null ? v.ParticipantInfo.fromPartial(N.participant) : void 0, Xe.otherParticipants = ((re = N.otherParticipants) === null || re === void 0 ? void 0 : re.map((Ge) => v.ParticipantInfo.fromPartial(Ge))) || [], Xe.serverVersion = (le = N.serverVersion) !== null && le !== void 0 ? le : "", Xe.iceServers = ((Ne = N.iceServers) === null || Ne === void 0 ? void 0 : Ne.map((Ge) => a.ICEServer.fromPartial(Ge))) || [], Xe.subscriberPrimary = (Oe = N.subscriberPrimary) !== null && Oe !== void 0 ? Oe : !1, Xe.alternativeUrl = (qe = N.alternativeUrl) !== null && qe !== void 0 ? qe : "", Xe.clientConfiguration = N.clientConfiguration !== void 0 && N.clientConfiguration !== null ? v.ClientConfiguration.fromPartial(N.clientConfiguration) : void 0, Xe.serverRegion = (je = N.serverRegion) !== null && je !== void 0 ? je : "", Xe.pingTimeout = (Fe = N.pingTimeout) !== null && Fe !== void 0 ? Fe : 0, Xe.pingInterval = (yt = N.pingInterval) !== null && yt !== void 0 ? yt : 0, Xe.serverInfo = N.serverInfo !== void 0 && N.serverInfo !== null ? v.ServerInfo.fromPartial(N.serverInfo) : void 0, Xe;
    }
  };
  function pe() {
    return { cid: "", track: void 0 };
  }
  a.TrackPublishedResponse = {
    encode(N, re = l.default.Writer.create()) {
      return N.cid !== void 0 && N.cid !== "" && re.uint32(10).string(N.cid), N.track !== void 0 && v.TrackInfo.encode(N.track, re.uint32(18).fork()).ldelim(), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = pe();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.cid = le.string();
            break;
          case 2:
            Oe.track = v.TrackInfo.decode(le, le.uint32());
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        cid: ae(N.cid) ? String(N.cid) : "",
        track: ae(N.track) ? v.TrackInfo.fromJSON(N.track) : void 0
      };
    },
    toJSON(N) {
      const re = {};
      return N.cid !== void 0 && (re.cid = N.cid), N.track !== void 0 && (re.track = N.track ? v.TrackInfo.toJSON(N.track) : void 0), re;
    },
    fromPartial(N) {
      var re;
      const le = pe();
      return le.cid = (re = N.cid) !== null && re !== void 0 ? re : "", le.track = N.track !== void 0 && N.track !== null ? v.TrackInfo.fromPartial(N.track) : void 0, le;
    }
  };
  function be() {
    return { trackSid: "" };
  }
  a.TrackUnpublishedResponse = {
    encode(N, re = l.default.Writer.create()) {
      return N.trackSid !== void 0 && N.trackSid !== "" && re.uint32(10).string(N.trackSid), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = be();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.trackSid = le.string();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return { trackSid: ae(N.trackSid) ? String(N.trackSid) : "" };
    },
    toJSON(N) {
      const re = {};
      return N.trackSid !== void 0 && (re.trackSid = N.trackSid), re;
    },
    fromPartial(N) {
      var re;
      const le = be();
      return le.trackSid = (re = N.trackSid) !== null && re !== void 0 ? re : "", le;
    }
  };
  function ke() {
    return { type: "", sdp: "" };
  }
  a.SessionDescription = {
    encode(N, re = l.default.Writer.create()) {
      return N.type !== void 0 && N.type !== "" && re.uint32(10).string(N.type), N.sdp !== void 0 && N.sdp !== "" && re.uint32(18).string(N.sdp), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = ke();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.type = le.string();
            break;
          case 2:
            Oe.sdp = le.string();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return { type: ae(N.type) ? String(N.type) : "", sdp: ae(N.sdp) ? String(N.sdp) : "" };
    },
    toJSON(N) {
      const re = {};
      return N.type !== void 0 && (re.type = N.type), N.sdp !== void 0 && (re.sdp = N.sdp), re;
    },
    fromPartial(N) {
      var re, le;
      const Ne = ke();
      return Ne.type = (re = N.type) !== null && re !== void 0 ? re : "", Ne.sdp = (le = N.sdp) !== null && le !== void 0 ? le : "", Ne;
    }
  };
  function _e() {
    return { participants: [] };
  }
  a.ParticipantUpdate = {
    encode(N, re = l.default.Writer.create()) {
      if (N.participants !== void 0 && N.participants.length !== 0)
        for (const le of N.participants)
          v.ParticipantInfo.encode(le, re.uint32(10).fork()).ldelim();
      return re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = _e();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.participants.push(v.ParticipantInfo.decode(le, le.uint32()));
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        participants: Array.isArray(N == null ? void 0 : N.participants) ? N.participants.map((re) => v.ParticipantInfo.fromJSON(re)) : []
      };
    },
    toJSON(N) {
      const re = {};
      return N.participants ? re.participants = N.participants.map((le) => le ? v.ParticipantInfo.toJSON(le) : void 0) : re.participants = [], re;
    },
    fromPartial(N) {
      var re;
      const le = _e();
      return le.participants = ((re = N.participants) === null || re === void 0 ? void 0 : re.map((Ne) => v.ParticipantInfo.fromPartial(Ne))) || [], le;
    }
  };
  function q() {
    return { trackSids: [], subscribe: !1, participantTracks: [] };
  }
  a.UpdateSubscription = {
    encode(N, re = l.default.Writer.create()) {
      if (N.trackSids !== void 0 && N.trackSids.length !== 0)
        for (const le of N.trackSids)
          re.uint32(10).string(le);
      if (N.subscribe === !0 && re.uint32(16).bool(N.subscribe), N.participantTracks !== void 0 && N.participantTracks.length !== 0)
        for (const le of N.participantTracks)
          v.ParticipantTracks.encode(le, re.uint32(26).fork()).ldelim();
      return re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = q();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.trackSids.push(le.string());
            break;
          case 2:
            Oe.subscribe = le.bool();
            break;
          case 3:
            Oe.participantTracks.push(v.ParticipantTracks.decode(le, le.uint32()));
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        trackSids: Array.isArray(N == null ? void 0 : N.trackSids) ? N.trackSids.map((re) => String(re)) : [],
        subscribe: ae(N.subscribe) ? !!N.subscribe : !1,
        participantTracks: Array.isArray(N == null ? void 0 : N.participantTracks) ? N.participantTracks.map((re) => v.ParticipantTracks.fromJSON(re)) : []
      };
    },
    toJSON(N) {
      const re = {};
      return N.trackSids ? re.trackSids = N.trackSids.map((le) => le) : re.trackSids = [], N.subscribe !== void 0 && (re.subscribe = N.subscribe), N.participantTracks ? re.participantTracks = N.participantTracks.map((le) => le ? v.ParticipantTracks.toJSON(le) : void 0) : re.participantTracks = [], re;
    },
    fromPartial(N) {
      var re, le, Ne;
      const Oe = q();
      return Oe.trackSids = ((re = N.trackSids) === null || re === void 0 ? void 0 : re.map((qe) => qe)) || [], Oe.subscribe = (le = N.subscribe) !== null && le !== void 0 ? le : !1, Oe.participantTracks = ((Ne = N.participantTracks) === null || Ne === void 0 ? void 0 : Ne.map((qe) => v.ParticipantTracks.fromPartial(qe))) || [], Oe;
    }
  };
  function z() {
    return { trackSids: [], disabled: !1, quality: 0, width: 0, height: 0, fps: 0 };
  }
  a.UpdateTrackSettings = {
    encode(N, re = l.default.Writer.create()) {
      if (N.trackSids !== void 0 && N.trackSids.length !== 0)
        for (const le of N.trackSids)
          re.uint32(10).string(le);
      return N.disabled === !0 && re.uint32(24).bool(N.disabled), N.quality !== void 0 && N.quality !== 0 && re.uint32(32).int32(N.quality), N.width !== void 0 && N.width !== 0 && re.uint32(40).uint32(N.width), N.height !== void 0 && N.height !== 0 && re.uint32(48).uint32(N.height), N.fps !== void 0 && N.fps !== 0 && re.uint32(56).uint32(N.fps), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = z();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.trackSids.push(le.string());
            break;
          case 3:
            Oe.disabled = le.bool();
            break;
          case 4:
            Oe.quality = le.int32();
            break;
          case 5:
            Oe.width = le.uint32();
            break;
          case 6:
            Oe.height = le.uint32();
            break;
          case 7:
            Oe.fps = le.uint32();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        trackSids: Array.isArray(N == null ? void 0 : N.trackSids) ? N.trackSids.map((re) => String(re)) : [],
        disabled: ae(N.disabled) ? !!N.disabled : !1,
        quality: ae(N.quality) ? v.videoQualityFromJSON(N.quality) : 0,
        width: ae(N.width) ? Number(N.width) : 0,
        height: ae(N.height) ? Number(N.height) : 0,
        fps: ae(N.fps) ? Number(N.fps) : 0
      };
    },
    toJSON(N) {
      const re = {};
      return N.trackSids ? re.trackSids = N.trackSids.map((le) => le) : re.trackSids = [], N.disabled !== void 0 && (re.disabled = N.disabled), N.quality !== void 0 && (re.quality = v.videoQualityToJSON(N.quality)), N.width !== void 0 && (re.width = Math.round(N.width)), N.height !== void 0 && (re.height = Math.round(N.height)), N.fps !== void 0 && (re.fps = Math.round(N.fps)), re;
    },
    fromPartial(N) {
      var re, le, Ne, Oe, qe, je;
      const Fe = z();
      return Fe.trackSids = ((re = N.trackSids) === null || re === void 0 ? void 0 : re.map((yt) => yt)) || [], Fe.disabled = (le = N.disabled) !== null && le !== void 0 ? le : !1, Fe.quality = (Ne = N.quality) !== null && Ne !== void 0 ? Ne : 0, Fe.width = (Oe = N.width) !== null && Oe !== void 0 ? Oe : 0, Fe.height = (qe = N.height) !== null && qe !== void 0 ? qe : 0, Fe.fps = (je = N.fps) !== null && je !== void 0 ? je : 0, Fe;
    }
  };
  function C() {
    return { canReconnect: !1, reason: 0 };
  }
  a.LeaveRequest = {
    encode(N, re = l.default.Writer.create()) {
      return N.canReconnect === !0 && re.uint32(8).bool(N.canReconnect), N.reason !== void 0 && N.reason !== 0 && re.uint32(16).int32(N.reason), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = C();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.canReconnect = le.bool();
            break;
          case 2:
            Oe.reason = le.int32();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        canReconnect: ae(N.canReconnect) ? !!N.canReconnect : !1,
        reason: ae(N.reason) ? v.disconnectReasonFromJSON(N.reason) : 0
      };
    },
    toJSON(N) {
      const re = {};
      return N.canReconnect !== void 0 && (re.canReconnect = N.canReconnect), N.reason !== void 0 && (re.reason = v.disconnectReasonToJSON(N.reason)), re;
    },
    fromPartial(N) {
      var re, le;
      const Ne = C();
      return Ne.canReconnect = (re = N.canReconnect) !== null && re !== void 0 ? re : !1, Ne.reason = (le = N.reason) !== null && le !== void 0 ? le : 0, Ne;
    }
  };
  function b() {
    return { trackSid: "", layers: [] };
  }
  a.UpdateVideoLayers = {
    encode(N, re = l.default.Writer.create()) {
      if (N.trackSid !== void 0 && N.trackSid !== "" && re.uint32(10).string(N.trackSid), N.layers !== void 0 && N.layers.length !== 0)
        for (const le of N.layers)
          v.VideoLayer.encode(le, re.uint32(18).fork()).ldelim();
      return re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = b();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.trackSid = le.string();
            break;
          case 2:
            Oe.layers.push(v.VideoLayer.decode(le, le.uint32()));
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        trackSid: ae(N.trackSid) ? String(N.trackSid) : "",
        layers: Array.isArray(N == null ? void 0 : N.layers) ? N.layers.map((re) => v.VideoLayer.fromJSON(re)) : []
      };
    },
    toJSON(N) {
      const re = {};
      return N.trackSid !== void 0 && (re.trackSid = N.trackSid), N.layers ? re.layers = N.layers.map((le) => le ? v.VideoLayer.toJSON(le) : void 0) : re.layers = [], re;
    },
    fromPartial(N) {
      var re, le;
      const Ne = b();
      return Ne.trackSid = (re = N.trackSid) !== null && re !== void 0 ? re : "", Ne.layers = ((le = N.layers) === null || le === void 0 ? void 0 : le.map((Oe) => v.VideoLayer.fromPartial(Oe))) || [], Ne;
    }
  };
  function E() {
    return { urls: [], username: "", credential: "" };
  }
  a.ICEServer = {
    encode(N, re = l.default.Writer.create()) {
      if (N.urls !== void 0 && N.urls.length !== 0)
        for (const le of N.urls)
          re.uint32(10).string(le);
      return N.username !== void 0 && N.username !== "" && re.uint32(18).string(N.username), N.credential !== void 0 && N.credential !== "" && re.uint32(26).string(N.credential), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = E();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.urls.push(le.string());
            break;
          case 2:
            Oe.username = le.string();
            break;
          case 3:
            Oe.credential = le.string();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        urls: Array.isArray(N == null ? void 0 : N.urls) ? N.urls.map((re) => String(re)) : [],
        username: ae(N.username) ? String(N.username) : "",
        credential: ae(N.credential) ? String(N.credential) : ""
      };
    },
    toJSON(N) {
      const re = {};
      return N.urls ? re.urls = N.urls.map((le) => le) : re.urls = [], N.username !== void 0 && (re.username = N.username), N.credential !== void 0 && (re.credential = N.credential), re;
    },
    fromPartial(N) {
      var re, le, Ne;
      const Oe = E();
      return Oe.urls = ((re = N.urls) === null || re === void 0 ? void 0 : re.map((qe) => qe)) || [], Oe.username = (le = N.username) !== null && le !== void 0 ? le : "", Oe.credential = (Ne = N.credential) !== null && Ne !== void 0 ? Ne : "", Oe;
    }
  };
  function k() {
    return { speakers: [] };
  }
  a.SpeakersChanged = {
    encode(N, re = l.default.Writer.create()) {
      if (N.speakers !== void 0 && N.speakers.length !== 0)
        for (const le of N.speakers)
          v.SpeakerInfo.encode(le, re.uint32(10).fork()).ldelim();
      return re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = k();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.speakers.push(v.SpeakerInfo.decode(le, le.uint32()));
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        speakers: Array.isArray(N == null ? void 0 : N.speakers) ? N.speakers.map((re) => v.SpeakerInfo.fromJSON(re)) : []
      };
    },
    toJSON(N) {
      const re = {};
      return N.speakers ? re.speakers = N.speakers.map((le) => le ? v.SpeakerInfo.toJSON(le) : void 0) : re.speakers = [], re;
    },
    fromPartial(N) {
      var re;
      const le = k();
      return le.speakers = ((re = N.speakers) === null || re === void 0 ? void 0 : re.map((Ne) => v.SpeakerInfo.fromPartial(Ne))) || [], le;
    }
  };
  function O() {
    return { room: void 0 };
  }
  a.RoomUpdate = {
    encode(N, re = l.default.Writer.create()) {
      return N.room !== void 0 && v.Room.encode(N.room, re.uint32(10).fork()).ldelim(), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = O();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.room = v.Room.decode(le, le.uint32());
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return { room: ae(N.room) ? v.Room.fromJSON(N.room) : void 0 };
    },
    toJSON(N) {
      const re = {};
      return N.room !== void 0 && (re.room = N.room ? v.Room.toJSON(N.room) : void 0), re;
    },
    fromPartial(N) {
      const re = O();
      return re.room = N.room !== void 0 && N.room !== null ? v.Room.fromPartial(N.room) : void 0, re;
    }
  };
  function A() {
    return { participantSid: "", quality: 0, score: 0 };
  }
  a.ConnectionQualityInfo = {
    encode(N, re = l.default.Writer.create()) {
      return N.participantSid !== void 0 && N.participantSid !== "" && re.uint32(10).string(N.participantSid), N.quality !== void 0 && N.quality !== 0 && re.uint32(16).int32(N.quality), N.score !== void 0 && N.score !== 0 && re.uint32(29).float(N.score), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = A();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.participantSid = le.string();
            break;
          case 2:
            Oe.quality = le.int32();
            break;
          case 3:
            Oe.score = le.float();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        participantSid: ae(N.participantSid) ? String(N.participantSid) : "",
        quality: ae(N.quality) ? v.connectionQualityFromJSON(N.quality) : 0,
        score: ae(N.score) ? Number(N.score) : 0
      };
    },
    toJSON(N) {
      const re = {};
      return N.participantSid !== void 0 && (re.participantSid = N.participantSid), N.quality !== void 0 && (re.quality = v.connectionQualityToJSON(N.quality)), N.score !== void 0 && (re.score = N.score), re;
    },
    fromPartial(N) {
      var re, le, Ne;
      const Oe = A();
      return Oe.participantSid = (re = N.participantSid) !== null && re !== void 0 ? re : "", Oe.quality = (le = N.quality) !== null && le !== void 0 ? le : 0, Oe.score = (Ne = N.score) !== null && Ne !== void 0 ? Ne : 0, Oe;
    }
  };
  function x() {
    return { updates: [] };
  }
  a.ConnectionQualityUpdate = {
    encode(N, re = l.default.Writer.create()) {
      if (N.updates !== void 0 && N.updates.length !== 0)
        for (const le of N.updates)
          a.ConnectionQualityInfo.encode(le, re.uint32(10).fork()).ldelim();
      return re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = x();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.updates.push(a.ConnectionQualityInfo.decode(le, le.uint32()));
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        updates: Array.isArray(N == null ? void 0 : N.updates) ? N.updates.map((re) => a.ConnectionQualityInfo.fromJSON(re)) : []
      };
    },
    toJSON(N) {
      const re = {};
      return N.updates ? re.updates = N.updates.map((le) => le ? a.ConnectionQualityInfo.toJSON(le) : void 0) : re.updates = [], re;
    },
    fromPartial(N) {
      var re;
      const le = x();
      return le.updates = ((re = N.updates) === null || re === void 0 ? void 0 : re.map((Ne) => a.ConnectionQualityInfo.fromPartial(Ne))) || [], le;
    }
  };
  function Y() {
    return { participantSid: "", trackSid: "", state: 0 };
  }
  a.StreamStateInfo = {
    encode(N, re = l.default.Writer.create()) {
      return N.participantSid !== void 0 && N.participantSid !== "" && re.uint32(10).string(N.participantSid), N.trackSid !== void 0 && N.trackSid !== "" && re.uint32(18).string(N.trackSid), N.state !== void 0 && N.state !== 0 && re.uint32(24).int32(N.state), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = Y();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.participantSid = le.string();
            break;
          case 2:
            Oe.trackSid = le.string();
            break;
          case 3:
            Oe.state = le.int32();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        participantSid: ae(N.participantSid) ? String(N.participantSid) : "",
        trackSid: ae(N.trackSid) ? String(N.trackSid) : "",
        state: ae(N.state) ? $(N.state) : 0
      };
    },
    toJSON(N) {
      const re = {};
      return N.participantSid !== void 0 && (re.participantSid = N.participantSid), N.trackSid !== void 0 && (re.trackSid = N.trackSid), N.state !== void 0 && (re.state = F(N.state)), re;
    },
    fromPartial(N) {
      var re, le, Ne;
      const Oe = Y();
      return Oe.participantSid = (re = N.participantSid) !== null && re !== void 0 ? re : "", Oe.trackSid = (le = N.trackSid) !== null && le !== void 0 ? le : "", Oe.state = (Ne = N.state) !== null && Ne !== void 0 ? Ne : 0, Oe;
    }
  };
  function B() {
    return { streamStates: [] };
  }
  a.StreamStateUpdate = {
    encode(N, re = l.default.Writer.create()) {
      if (N.streamStates !== void 0 && N.streamStates.length !== 0)
        for (const le of N.streamStates)
          a.StreamStateInfo.encode(le, re.uint32(10).fork()).ldelim();
      return re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = B();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.streamStates.push(a.StreamStateInfo.decode(le, le.uint32()));
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        streamStates: Array.isArray(N == null ? void 0 : N.streamStates) ? N.streamStates.map((re) => a.StreamStateInfo.fromJSON(re)) : []
      };
    },
    toJSON(N) {
      const re = {};
      return N.streamStates ? re.streamStates = N.streamStates.map((le) => le ? a.StreamStateInfo.toJSON(le) : void 0) : re.streamStates = [], re;
    },
    fromPartial(N) {
      var re;
      const le = B();
      return le.streamStates = ((re = N.streamStates) === null || re === void 0 ? void 0 : re.map((Ne) => a.StreamStateInfo.fromPartial(Ne))) || [], le;
    }
  };
  function T() {
    return { quality: 0, enabled: !1 };
  }
  a.SubscribedQuality = {
    encode(N, re = l.default.Writer.create()) {
      return N.quality !== void 0 && N.quality !== 0 && re.uint32(8).int32(N.quality), N.enabled === !0 && re.uint32(16).bool(N.enabled), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = T();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.quality = le.int32();
            break;
          case 2:
            Oe.enabled = le.bool();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        quality: ae(N.quality) ? v.videoQualityFromJSON(N.quality) : 0,
        enabled: ae(N.enabled) ? !!N.enabled : !1
      };
    },
    toJSON(N) {
      const re = {};
      return N.quality !== void 0 && (re.quality = v.videoQualityToJSON(N.quality)), N.enabled !== void 0 && (re.enabled = N.enabled), re;
    },
    fromPartial(N) {
      var re, le;
      const Ne = T();
      return Ne.quality = (re = N.quality) !== null && re !== void 0 ? re : 0, Ne.enabled = (le = N.enabled) !== null && le !== void 0 ? le : !1, Ne;
    }
  };
  function D() {
    return { codec: "", qualities: [] };
  }
  a.SubscribedCodec = {
    encode(N, re = l.default.Writer.create()) {
      if (N.codec !== void 0 && N.codec !== "" && re.uint32(10).string(N.codec), N.qualities !== void 0 && N.qualities.length !== 0)
        for (const le of N.qualities)
          a.SubscribedQuality.encode(le, re.uint32(18).fork()).ldelim();
      return re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = D();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.codec = le.string();
            break;
          case 2:
            Oe.qualities.push(a.SubscribedQuality.decode(le, le.uint32()));
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        codec: ae(N.codec) ? String(N.codec) : "",
        qualities: Array.isArray(N == null ? void 0 : N.qualities) ? N.qualities.map((re) => a.SubscribedQuality.fromJSON(re)) : []
      };
    },
    toJSON(N) {
      const re = {};
      return N.codec !== void 0 && (re.codec = N.codec), N.qualities ? re.qualities = N.qualities.map((le) => le ? a.SubscribedQuality.toJSON(le) : void 0) : re.qualities = [], re;
    },
    fromPartial(N) {
      var re, le;
      const Ne = D();
      return Ne.codec = (re = N.codec) !== null && re !== void 0 ? re : "", Ne.qualities = ((le = N.qualities) === null || le === void 0 ? void 0 : le.map((Oe) => a.SubscribedQuality.fromPartial(Oe))) || [], Ne;
    }
  };
  function te() {
    return { trackSid: "", subscribedQualities: [], subscribedCodecs: [] };
  }
  a.SubscribedQualityUpdate = {
    encode(N, re = l.default.Writer.create()) {
      if (N.trackSid !== void 0 && N.trackSid !== "" && re.uint32(10).string(N.trackSid), N.subscribedQualities !== void 0 && N.subscribedQualities.length !== 0)
        for (const le of N.subscribedQualities)
          a.SubscribedQuality.encode(le, re.uint32(18).fork()).ldelim();
      if (N.subscribedCodecs !== void 0 && N.subscribedCodecs.length !== 0)
        for (const le of N.subscribedCodecs)
          a.SubscribedCodec.encode(le, re.uint32(26).fork()).ldelim();
      return re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = te();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.trackSid = le.string();
            break;
          case 2:
            Oe.subscribedQualities.push(a.SubscribedQuality.decode(le, le.uint32()));
            break;
          case 3:
            Oe.subscribedCodecs.push(a.SubscribedCodec.decode(le, le.uint32()));
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        trackSid: ae(N.trackSid) ? String(N.trackSid) : "",
        subscribedQualities: Array.isArray(N == null ? void 0 : N.subscribedQualities) ? N.subscribedQualities.map((re) => a.SubscribedQuality.fromJSON(re)) : [],
        subscribedCodecs: Array.isArray(N == null ? void 0 : N.subscribedCodecs) ? N.subscribedCodecs.map((re) => a.SubscribedCodec.fromJSON(re)) : []
      };
    },
    toJSON(N) {
      const re = {};
      return N.trackSid !== void 0 && (re.trackSid = N.trackSid), N.subscribedQualities ? re.subscribedQualities = N.subscribedQualities.map((le) => le ? a.SubscribedQuality.toJSON(le) : void 0) : re.subscribedQualities = [], N.subscribedCodecs ? re.subscribedCodecs = N.subscribedCodecs.map((le) => le ? a.SubscribedCodec.toJSON(le) : void 0) : re.subscribedCodecs = [], re;
    },
    fromPartial(N) {
      var re, le, Ne;
      const Oe = te();
      return Oe.trackSid = (re = N.trackSid) !== null && re !== void 0 ? re : "", Oe.subscribedQualities = ((le = N.subscribedQualities) === null || le === void 0 ? void 0 : le.map((qe) => a.SubscribedQuality.fromPartial(qe))) || [], Oe.subscribedCodecs = ((Ne = N.subscribedCodecs) === null || Ne === void 0 ? void 0 : Ne.map((qe) => a.SubscribedCodec.fromPartial(qe))) || [], Oe;
    }
  };
  function me() {
    return { participantSid: "", allTracks: !1, trackSids: [], participantIdentity: "" };
  }
  a.TrackPermission = {
    encode(N, re = l.default.Writer.create()) {
      if (N.participantSid !== void 0 && N.participantSid !== "" && re.uint32(10).string(N.participantSid), N.allTracks === !0 && re.uint32(16).bool(N.allTracks), N.trackSids !== void 0 && N.trackSids.length !== 0)
        for (const le of N.trackSids)
          re.uint32(26).string(le);
      return N.participantIdentity !== void 0 && N.participantIdentity !== "" && re.uint32(34).string(N.participantIdentity), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = me();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.participantSid = le.string();
            break;
          case 2:
            Oe.allTracks = le.bool();
            break;
          case 3:
            Oe.trackSids.push(le.string());
            break;
          case 4:
            Oe.participantIdentity = le.string();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        participantSid: ae(N.participantSid) ? String(N.participantSid) : "",
        allTracks: ae(N.allTracks) ? !!N.allTracks : !1,
        trackSids: Array.isArray(N == null ? void 0 : N.trackSids) ? N.trackSids.map((re) => String(re)) : [],
        participantIdentity: ae(N.participantIdentity) ? String(N.participantIdentity) : ""
      };
    },
    toJSON(N) {
      const re = {};
      return N.participantSid !== void 0 && (re.participantSid = N.participantSid), N.allTracks !== void 0 && (re.allTracks = N.allTracks), N.trackSids ? re.trackSids = N.trackSids.map((le) => le) : re.trackSids = [], N.participantIdentity !== void 0 && (re.participantIdentity = N.participantIdentity), re;
    },
    fromPartial(N) {
      var re, le, Ne, Oe;
      const qe = me();
      return qe.participantSid = (re = N.participantSid) !== null && re !== void 0 ? re : "", qe.allTracks = (le = N.allTracks) !== null && le !== void 0 ? le : !1, qe.trackSids = ((Ne = N.trackSids) === null || Ne === void 0 ? void 0 : Ne.map((je) => je)) || [], qe.participantIdentity = (Oe = N.participantIdentity) !== null && Oe !== void 0 ? Oe : "", qe;
    }
  };
  function Ie() {
    return { allParticipants: !1, trackPermissions: [] };
  }
  a.SubscriptionPermission = {
    encode(N, re = l.default.Writer.create()) {
      if (N.allParticipants === !0 && re.uint32(8).bool(N.allParticipants), N.trackPermissions !== void 0 && N.trackPermissions.length !== 0)
        for (const le of N.trackPermissions)
          a.TrackPermission.encode(le, re.uint32(18).fork()).ldelim();
      return re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = Ie();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.allParticipants = le.bool();
            break;
          case 2:
            Oe.trackPermissions.push(a.TrackPermission.decode(le, le.uint32()));
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        allParticipants: ae(N.allParticipants) ? !!N.allParticipants : !1,
        trackPermissions: Array.isArray(N == null ? void 0 : N.trackPermissions) ? N.trackPermissions.map((re) => a.TrackPermission.fromJSON(re)) : []
      };
    },
    toJSON(N) {
      const re = {};
      return N.allParticipants !== void 0 && (re.allParticipants = N.allParticipants), N.trackPermissions ? re.trackPermissions = N.trackPermissions.map((le) => le ? a.TrackPermission.toJSON(le) : void 0) : re.trackPermissions = [], re;
    },
    fromPartial(N) {
      var re, le;
      const Ne = Ie();
      return Ne.allParticipants = (re = N.allParticipants) !== null && re !== void 0 ? re : !1, Ne.trackPermissions = ((le = N.trackPermissions) === null || le === void 0 ? void 0 : le.map((Oe) => a.TrackPermission.fromPartial(Oe))) || [], Ne;
    }
  };
  function $e() {
    return { participantSid: "", trackSid: "", allowed: !1 };
  }
  a.SubscriptionPermissionUpdate = {
    encode(N, re = l.default.Writer.create()) {
      return N.participantSid !== void 0 && N.participantSid !== "" && re.uint32(10).string(N.participantSid), N.trackSid !== void 0 && N.trackSid !== "" && re.uint32(18).string(N.trackSid), N.allowed === !0 && re.uint32(24).bool(N.allowed), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = $e();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.participantSid = le.string();
            break;
          case 2:
            Oe.trackSid = le.string();
            break;
          case 3:
            Oe.allowed = le.bool();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        participantSid: ae(N.participantSid) ? String(N.participantSid) : "",
        trackSid: ae(N.trackSid) ? String(N.trackSid) : "",
        allowed: ae(N.allowed) ? !!N.allowed : !1
      };
    },
    toJSON(N) {
      const re = {};
      return N.participantSid !== void 0 && (re.participantSid = N.participantSid), N.trackSid !== void 0 && (re.trackSid = N.trackSid), N.allowed !== void 0 && (re.allowed = N.allowed), re;
    },
    fromPartial(N) {
      var re, le, Ne;
      const Oe = $e();
      return Oe.participantSid = (re = N.participantSid) !== null && re !== void 0 ? re : "", Oe.trackSid = (le = N.trackSid) !== null && le !== void 0 ? le : "", Oe.allowed = (Ne = N.allowed) !== null && Ne !== void 0 ? Ne : !1, Oe;
    }
  };
  function ye() {
    return { answer: void 0, subscription: void 0, publishTracks: [], dataChannels: [], offer: void 0 };
  }
  a.SyncState = {
    encode(N, re = l.default.Writer.create()) {
      if (N.answer !== void 0 && a.SessionDescription.encode(N.answer, re.uint32(10).fork()).ldelim(), N.subscription !== void 0 && a.UpdateSubscription.encode(N.subscription, re.uint32(18).fork()).ldelim(), N.publishTracks !== void 0 && N.publishTracks.length !== 0)
        for (const le of N.publishTracks)
          a.TrackPublishedResponse.encode(le, re.uint32(26).fork()).ldelim();
      if (N.dataChannels !== void 0 && N.dataChannels.length !== 0)
        for (const le of N.dataChannels)
          a.DataChannelInfo.encode(le, re.uint32(34).fork()).ldelim();
      return N.offer !== void 0 && a.SessionDescription.encode(N.offer, re.uint32(42).fork()).ldelim(), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = ye();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.answer = a.SessionDescription.decode(le, le.uint32());
            break;
          case 2:
            Oe.subscription = a.UpdateSubscription.decode(le, le.uint32());
            break;
          case 3:
            Oe.publishTracks.push(a.TrackPublishedResponse.decode(le, le.uint32()));
            break;
          case 4:
            Oe.dataChannels.push(a.DataChannelInfo.decode(le, le.uint32()));
            break;
          case 5:
            Oe.offer = a.SessionDescription.decode(le, le.uint32());
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        answer: ae(N.answer) ? a.SessionDescription.fromJSON(N.answer) : void 0,
        subscription: ae(N.subscription) ? a.UpdateSubscription.fromJSON(N.subscription) : void 0,
        publishTracks: Array.isArray(N == null ? void 0 : N.publishTracks) ? N.publishTracks.map((re) => a.TrackPublishedResponse.fromJSON(re)) : [],
        dataChannels: Array.isArray(N == null ? void 0 : N.dataChannels) ? N.dataChannels.map((re) => a.DataChannelInfo.fromJSON(re)) : [],
        offer: ae(N.offer) ? a.SessionDescription.fromJSON(N.offer) : void 0
      };
    },
    toJSON(N) {
      const re = {};
      return N.answer !== void 0 && (re.answer = N.answer ? a.SessionDescription.toJSON(N.answer) : void 0), N.subscription !== void 0 && (re.subscription = N.subscription ? a.UpdateSubscription.toJSON(N.subscription) : void 0), N.publishTracks ? re.publishTracks = N.publishTracks.map((le) => le ? a.TrackPublishedResponse.toJSON(le) : void 0) : re.publishTracks = [], N.dataChannels ? re.dataChannels = N.dataChannels.map((le) => le ? a.DataChannelInfo.toJSON(le) : void 0) : re.dataChannels = [], N.offer !== void 0 && (re.offer = N.offer ? a.SessionDescription.toJSON(N.offer) : void 0), re;
    },
    fromPartial(N) {
      var re, le;
      const Ne = ye();
      return Ne.answer = N.answer !== void 0 && N.answer !== null ? a.SessionDescription.fromPartial(N.answer) : void 0, Ne.subscription = N.subscription !== void 0 && N.subscription !== null ? a.UpdateSubscription.fromPartial(N.subscription) : void 0, Ne.publishTracks = ((re = N.publishTracks) === null || re === void 0 ? void 0 : re.map((Oe) => a.TrackPublishedResponse.fromPartial(Oe))) || [], Ne.dataChannels = ((le = N.dataChannels) === null || le === void 0 ? void 0 : le.map((Oe) => a.DataChannelInfo.fromPartial(Oe))) || [], Ne.offer = N.offer !== void 0 && N.offer !== null ? a.SessionDescription.fromPartial(N.offer) : void 0, Ne;
    }
  };
  function fe() {
    return { label: "", id: 0, target: 0 };
  }
  a.DataChannelInfo = {
    encode(N, re = l.default.Writer.create()) {
      return N.label !== void 0 && N.label !== "" && re.uint32(10).string(N.label), N.id !== void 0 && N.id !== 0 && re.uint32(16).uint32(N.id), N.target !== void 0 && N.target !== 0 && re.uint32(24).int32(N.target), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = fe();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.label = le.string();
            break;
          case 2:
            Oe.id = le.uint32();
            break;
          case 3:
            Oe.target = le.int32();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        label: ae(N.label) ? String(N.label) : "",
        id: ae(N.id) ? Number(N.id) : 0,
        target: ae(N.target) ? _(N.target) : 0
      };
    },
    toJSON(N) {
      const re = {};
      return N.label !== void 0 && (re.label = N.label), N.id !== void 0 && (re.id = Math.round(N.id)), N.target !== void 0 && (re.target = I(N.target)), re;
    },
    fromPartial(N) {
      var re, le, Ne;
      const Oe = fe();
      return Oe.label = (re = N.label) !== null && re !== void 0 ? re : "", Oe.id = (le = N.id) !== null && le !== void 0 ? le : 0, Oe.target = (Ne = N.target) !== null && Ne !== void 0 ? Ne : 0, Oe;
    }
  };
  function Me() {
    return {
      speakerUpdate: void 0,
      nodeFailure: void 0,
      migration: void 0,
      serverLeave: void 0,
      switchCandidateProtocol: void 0
    };
  }
  a.SimulateScenario = {
    encode(N, re = l.default.Writer.create()) {
      return N.speakerUpdate !== void 0 && re.uint32(8).int32(N.speakerUpdate), N.nodeFailure !== void 0 && re.uint32(16).bool(N.nodeFailure), N.migration !== void 0 && re.uint32(24).bool(N.migration), N.serverLeave !== void 0 && re.uint32(32).bool(N.serverLeave), N.switchCandidateProtocol !== void 0 && re.uint32(40).int32(N.switchCandidateProtocol), re;
    },
    decode(N, re) {
      const le = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let Ne = re === void 0 ? le.len : le.pos + re;
      const Oe = Me();
      for (; le.pos < Ne; ) {
        const qe = le.uint32();
        switch (qe >>> 3) {
          case 1:
            Oe.speakerUpdate = le.int32();
            break;
          case 2:
            Oe.nodeFailure = le.bool();
            break;
          case 3:
            Oe.migration = le.bool();
            break;
          case 4:
            Oe.serverLeave = le.bool();
            break;
          case 5:
            Oe.switchCandidateProtocol = le.int32();
            break;
          default:
            le.skipType(qe & 7);
            break;
        }
      }
      return Oe;
    },
    fromJSON(N) {
      return {
        speakerUpdate: ae(N.speakerUpdate) ? Number(N.speakerUpdate) : void 0,
        nodeFailure: ae(N.nodeFailure) ? !!N.nodeFailure : void 0,
        migration: ae(N.migration) ? !!N.migration : void 0,
        serverLeave: ae(N.serverLeave) ? !!N.serverLeave : void 0,
        switchCandidateProtocol: ae(N.switchCandidateProtocol) ? j(N.switchCandidateProtocol) : void 0
      };
    },
    toJSON(N) {
      const re = {};
      return N.speakerUpdate !== void 0 && (re.speakerUpdate = Math.round(N.speakerUpdate)), N.nodeFailure !== void 0 && (re.nodeFailure = N.nodeFailure), N.migration !== void 0 && (re.migration = N.migration), N.serverLeave !== void 0 && (re.serverLeave = N.serverLeave), N.switchCandidateProtocol !== void 0 && (re.switchCandidateProtocol = N.switchCandidateProtocol !== void 0 ? ee(N.switchCandidateProtocol) : void 0), re;
    },
    fromPartial(N) {
      var re, le, Ne, Oe, qe;
      const je = Me();
      return je.speakerUpdate = (re = N.speakerUpdate) !== null && re !== void 0 ? re : void 0, je.nodeFailure = (le = N.nodeFailure) !== null && le !== void 0 ? le : void 0, je.migration = (Ne = N.migration) !== null && Ne !== void 0 ? Ne : void 0, je.serverLeave = (Oe = N.serverLeave) !== null && Oe !== void 0 ? Oe : void 0, je.switchCandidateProtocol = (qe = N.switchCandidateProtocol) !== null && qe !== void 0 ? qe : void 0, je;
    }
  };
  var Ae = (() => {
    if (typeof Ae < "u")
      return Ae;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function xe(N) {
    if (N.gt(Number.MAX_SAFE_INTEGER))
      throw new Ae.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return N.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function ae(N) {
    return N != null;
  }
})(livekit_rtc);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(z) {
    return z && z.__esModule ? z : { default: z };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.RoomInternal = a.KeepAlive = a.RemoveParticipant = a.EndSession = a.StartSession = a.SignalNodeMessage = a.RTCNodeMessage = a.NodeStats = a.Node = a.nodeStateToJSON = a.nodeStateFromJSON = a.NodeState = a.nodeTypeToJSON = a.nodeTypeFromJSON = a.NodeType = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_egress, p = livekit_models, _ = livekit_room, I = livekit_rtc;
  a.protobufPackage = "livekit";
  var P;
  (function(z) {
    z[z.SERVER = 0] = "SERVER", z[z.CONTROLLER = 1] = "CONTROLLER", z[z.MEDIA = 2] = "MEDIA", z[z.TURN = 4] = "TURN", z[z.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(P = a.NodeType || (a.NodeType = {}));
  function $(z) {
    switch (z) {
      case 0:
      case "SERVER":
        return P.SERVER;
      case 1:
      case "CONTROLLER":
        return P.CONTROLLER;
      case 2:
      case "MEDIA":
        return P.MEDIA;
      case 4:
      case "TURN":
        return P.TURN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return P.UNRECOGNIZED;
    }
  }
  a.nodeTypeFromJSON = $;
  function F(z) {
    switch (z) {
      case P.SERVER:
        return "SERVER";
      case P.CONTROLLER:
        return "CONTROLLER";
      case P.MEDIA:
        return "MEDIA";
      case P.TURN:
        return "TURN";
      case P.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.nodeTypeToJSON = F;
  var H;
  (function(z) {
    z[z.STARTING_UP = 0] = "STARTING_UP", z[z.SERVING = 1] = "SERVING", z[z.SHUTTING_DOWN = 2] = "SHUTTING_DOWN", z[z.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(H = a.NodeState || (a.NodeState = {}));
  function j(z) {
    switch (z) {
      case 0:
      case "STARTING_UP":
        return H.STARTING_UP;
      case 1:
      case "SERVING":
        return H.SERVING;
      case 2:
      case "SHUTTING_DOWN":
        return H.SHUTTING_DOWN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return H.UNRECOGNIZED;
    }
  }
  a.nodeStateFromJSON = j;
  function ee(z) {
    switch (z) {
      case H.STARTING_UP:
        return "STARTING_UP";
      case H.SERVING:
        return "SERVING";
      case H.SHUTTING_DOWN:
        return "SHUTTING_DOWN";
      case H.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.nodeStateToJSON = ee;
  function X() {
    return { id: "", ip: "", numCpus: 0, stats: void 0, type: 0, state: 0, region: "" };
  }
  a.Node = {
    encode(z, C = l.default.Writer.create()) {
      return z.id !== void 0 && z.id !== "" && C.uint32(10).string(z.id), z.ip !== void 0 && z.ip !== "" && C.uint32(18).string(z.ip), z.numCpus !== void 0 && z.numCpus !== 0 && C.uint32(24).uint32(z.numCpus), z.stats !== void 0 && a.NodeStats.encode(z.stats, C.uint32(34).fork()).ldelim(), z.type !== void 0 && z.type !== 0 && C.uint32(40).int32(z.type), z.state !== void 0 && z.state !== 0 && C.uint32(48).int32(z.state), z.region !== void 0 && z.region !== "" && C.uint32(58).string(z.region), C;
    },
    decode(z, C) {
      const b = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = C === void 0 ? b.len : b.pos + C;
      const k = X();
      for (; b.pos < E; ) {
        const O = b.uint32();
        switch (O >>> 3) {
          case 1:
            k.id = b.string();
            break;
          case 2:
            k.ip = b.string();
            break;
          case 3:
            k.numCpus = b.uint32();
            break;
          case 4:
            k.stats = a.NodeStats.decode(b, b.uint32());
            break;
          case 5:
            k.type = b.int32();
            break;
          case 6:
            k.state = b.int32();
            break;
          case 7:
            k.region = b.string();
            break;
          default:
            b.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(z) {
      return {
        id: q(z.id) ? String(z.id) : "",
        ip: q(z.ip) ? String(z.ip) : "",
        numCpus: q(z.numCpus) ? Number(z.numCpus) : 0,
        stats: q(z.stats) ? a.NodeStats.fromJSON(z.stats) : void 0,
        type: q(z.type) ? $(z.type) : 0,
        state: q(z.state) ? j(z.state) : 0,
        region: q(z.region) ? String(z.region) : ""
      };
    },
    toJSON(z) {
      const C = {};
      return z.id !== void 0 && (C.id = z.id), z.ip !== void 0 && (C.ip = z.ip), z.numCpus !== void 0 && (C.numCpus = Math.round(z.numCpus)), z.stats !== void 0 && (C.stats = z.stats ? a.NodeStats.toJSON(z.stats) : void 0), z.type !== void 0 && (C.type = F(z.type)), z.state !== void 0 && (C.state = ee(z.state)), z.region !== void 0 && (C.region = z.region), C;
    },
    fromPartial(z) {
      var C, b, E, k, O, A;
      const x = X();
      return x.id = (C = z.id) !== null && C !== void 0 ? C : "", x.ip = (b = z.ip) !== null && b !== void 0 ? b : "", x.numCpus = (E = z.numCpus) !== null && E !== void 0 ? E : 0, x.stats = z.stats !== void 0 && z.stats !== null ? a.NodeStats.fromPartial(z.stats) : void 0, x.type = (k = z.type) !== null && k !== void 0 ? k : 0, x.state = (O = z.state) !== null && O !== void 0 ? O : 0, x.region = (A = z.region) !== null && A !== void 0 ? A : "", x;
    }
  };
  function ie() {
    return {
      startedAt: 0,
      updatedAt: 0,
      numRooms: 0,
      numClients: 0,
      numTracksIn: 0,
      numTracksOut: 0,
      bytesIn: 0,
      bytesOut: 0,
      packetsIn: 0,
      packetsOut: 0,
      nackTotal: 0,
      bytesInPerSec: 0,
      bytesOutPerSec: 0,
      packetsInPerSec: 0,
      packetsOutPerSec: 0,
      nackPerSec: 0,
      numCpus: 0,
      loadAvgLast1min: 0,
      loadAvgLast5min: 0,
      loadAvgLast15min: 0,
      cpuLoad: 0,
      memoryLoad: 0,
      sysPacketsOut: 0,
      sysPacketsDropped: 0,
      sysPacketsOutPerSec: 0,
      sysPacketsDroppedPerSec: 0,
      sysPacketsDroppedPctPerSec: 0,
      retransmitBytesOut: 0,
      retransmitPacketsOut: 0,
      retransmitBytesOutPerSec: 0,
      retransmitPacketsOutPerSec: 0,
      participantJoin: 0,
      participantJoinPerSec: 0
    };
  }
  a.NodeStats = {
    encode(z, C = l.default.Writer.create()) {
      return z.startedAt !== void 0 && z.startedAt !== 0 && C.uint32(8).int64(z.startedAt), z.updatedAt !== void 0 && z.updatedAt !== 0 && C.uint32(16).int64(z.updatedAt), z.numRooms !== void 0 && z.numRooms !== 0 && C.uint32(24).int32(z.numRooms), z.numClients !== void 0 && z.numClients !== 0 && C.uint32(32).int32(z.numClients), z.numTracksIn !== void 0 && z.numTracksIn !== 0 && C.uint32(40).int32(z.numTracksIn), z.numTracksOut !== void 0 && z.numTracksOut !== 0 && C.uint32(48).int32(z.numTracksOut), z.bytesIn !== void 0 && z.bytesIn !== 0 && C.uint32(56).uint64(z.bytesIn), z.bytesOut !== void 0 && z.bytesOut !== 0 && C.uint32(64).uint64(z.bytesOut), z.packetsIn !== void 0 && z.packetsIn !== 0 && C.uint32(72).uint64(z.packetsIn), z.packetsOut !== void 0 && z.packetsOut !== 0 && C.uint32(80).uint64(z.packetsOut), z.nackTotal !== void 0 && z.nackTotal !== 0 && C.uint32(88).uint64(z.nackTotal), z.bytesInPerSec !== void 0 && z.bytesInPerSec !== 0 && C.uint32(101).float(z.bytesInPerSec), z.bytesOutPerSec !== void 0 && z.bytesOutPerSec !== 0 && C.uint32(109).float(z.bytesOutPerSec), z.packetsInPerSec !== void 0 && z.packetsInPerSec !== 0 && C.uint32(117).float(z.packetsInPerSec), z.packetsOutPerSec !== void 0 && z.packetsOutPerSec !== 0 && C.uint32(125).float(z.packetsOutPerSec), z.nackPerSec !== void 0 && z.nackPerSec !== 0 && C.uint32(133).float(z.nackPerSec), z.numCpus !== void 0 && z.numCpus !== 0 && C.uint32(136).uint32(z.numCpus), z.loadAvgLast1min !== void 0 && z.loadAvgLast1min !== 0 && C.uint32(149).float(z.loadAvgLast1min), z.loadAvgLast5min !== void 0 && z.loadAvgLast5min !== 0 && C.uint32(157).float(z.loadAvgLast5min), z.loadAvgLast15min !== void 0 && z.loadAvgLast15min !== 0 && C.uint32(165).float(z.loadAvgLast15min), z.cpuLoad !== void 0 && z.cpuLoad !== 0 && C.uint32(173).float(z.cpuLoad), z.memoryLoad !== void 0 && z.memoryLoad !== 0 && C.uint32(269).float(z.memoryLoad), z.sysPacketsOut !== void 0 && z.sysPacketsOut !== 0 && C.uint32(224).uint32(z.sysPacketsOut), z.sysPacketsDropped !== void 0 && z.sysPacketsDropped !== 0 && C.uint32(232).uint32(z.sysPacketsDropped), z.sysPacketsOutPerSec !== void 0 && z.sysPacketsOutPerSec !== 0 && C.uint32(245).float(z.sysPacketsOutPerSec), z.sysPacketsDroppedPerSec !== void 0 && z.sysPacketsDroppedPerSec !== 0 && C.uint32(253).float(z.sysPacketsDroppedPerSec), z.sysPacketsDroppedPctPerSec !== void 0 && z.sysPacketsDroppedPctPerSec !== 0 && C.uint32(261).float(z.sysPacketsDroppedPctPerSec), z.retransmitBytesOut !== void 0 && z.retransmitBytesOut !== 0 && C.uint32(176).uint64(z.retransmitBytesOut), z.retransmitPacketsOut !== void 0 && z.retransmitPacketsOut !== 0 && C.uint32(184).uint64(z.retransmitPacketsOut), z.retransmitBytesOutPerSec !== void 0 && z.retransmitBytesOutPerSec !== 0 && C.uint32(197).float(z.retransmitBytesOutPerSec), z.retransmitPacketsOutPerSec !== void 0 && z.retransmitPacketsOutPerSec !== 0 && C.uint32(205).float(z.retransmitPacketsOutPerSec), z.participantJoin !== void 0 && z.participantJoin !== 0 && C.uint32(208).uint64(z.participantJoin), z.participantJoinPerSec !== void 0 && z.participantJoinPerSec !== 0 && C.uint32(221).float(z.participantJoinPerSec), C;
    },
    decode(z, C) {
      const b = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = C === void 0 ? b.len : b.pos + C;
      const k = ie();
      for (; b.pos < E; ) {
        const O = b.uint32();
        switch (O >>> 3) {
          case 1:
            k.startedAt = _e(b.int64());
            break;
          case 2:
            k.updatedAt = _e(b.int64());
            break;
          case 3:
            k.numRooms = b.int32();
            break;
          case 4:
            k.numClients = b.int32();
            break;
          case 5:
            k.numTracksIn = b.int32();
            break;
          case 6:
            k.numTracksOut = b.int32();
            break;
          case 7:
            k.bytesIn = _e(b.uint64());
            break;
          case 8:
            k.bytesOut = _e(b.uint64());
            break;
          case 9:
            k.packetsIn = _e(b.uint64());
            break;
          case 10:
            k.packetsOut = _e(b.uint64());
            break;
          case 11:
            k.nackTotal = _e(b.uint64());
            break;
          case 12:
            k.bytesInPerSec = b.float();
            break;
          case 13:
            k.bytesOutPerSec = b.float();
            break;
          case 14:
            k.packetsInPerSec = b.float();
            break;
          case 15:
            k.packetsOutPerSec = b.float();
            break;
          case 16:
            k.nackPerSec = b.float();
            break;
          case 17:
            k.numCpus = b.uint32();
            break;
          case 18:
            k.loadAvgLast1min = b.float();
            break;
          case 19:
            k.loadAvgLast5min = b.float();
            break;
          case 20:
            k.loadAvgLast15min = b.float();
            break;
          case 21:
            k.cpuLoad = b.float();
            break;
          case 33:
            k.memoryLoad = b.float();
            break;
          case 28:
            k.sysPacketsOut = b.uint32();
            break;
          case 29:
            k.sysPacketsDropped = b.uint32();
            break;
          case 30:
            k.sysPacketsOutPerSec = b.float();
            break;
          case 31:
            k.sysPacketsDroppedPerSec = b.float();
            break;
          case 32:
            k.sysPacketsDroppedPctPerSec = b.float();
            break;
          case 22:
            k.retransmitBytesOut = _e(b.uint64());
            break;
          case 23:
            k.retransmitPacketsOut = _e(b.uint64());
            break;
          case 24:
            k.retransmitBytesOutPerSec = b.float();
            break;
          case 25:
            k.retransmitPacketsOutPerSec = b.float();
            break;
          case 26:
            k.participantJoin = _e(b.uint64());
            break;
          case 27:
            k.participantJoinPerSec = b.float();
            break;
          default:
            b.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(z) {
      return {
        startedAt: q(z.startedAt) ? Number(z.startedAt) : 0,
        updatedAt: q(z.updatedAt) ? Number(z.updatedAt) : 0,
        numRooms: q(z.numRooms) ? Number(z.numRooms) : 0,
        numClients: q(z.numClients) ? Number(z.numClients) : 0,
        numTracksIn: q(z.numTracksIn) ? Number(z.numTracksIn) : 0,
        numTracksOut: q(z.numTracksOut) ? Number(z.numTracksOut) : 0,
        bytesIn: q(z.bytesIn) ? Number(z.bytesIn) : 0,
        bytesOut: q(z.bytesOut) ? Number(z.bytesOut) : 0,
        packetsIn: q(z.packetsIn) ? Number(z.packetsIn) : 0,
        packetsOut: q(z.packetsOut) ? Number(z.packetsOut) : 0,
        nackTotal: q(z.nackTotal) ? Number(z.nackTotal) : 0,
        bytesInPerSec: q(z.bytesInPerSec) ? Number(z.bytesInPerSec) : 0,
        bytesOutPerSec: q(z.bytesOutPerSec) ? Number(z.bytesOutPerSec) : 0,
        packetsInPerSec: q(z.packetsInPerSec) ? Number(z.packetsInPerSec) : 0,
        packetsOutPerSec: q(z.packetsOutPerSec) ? Number(z.packetsOutPerSec) : 0,
        nackPerSec: q(z.nackPerSec) ? Number(z.nackPerSec) : 0,
        numCpus: q(z.numCpus) ? Number(z.numCpus) : 0,
        loadAvgLast1min: q(z.loadAvgLast1min) ? Number(z.loadAvgLast1min) : 0,
        loadAvgLast5min: q(z.loadAvgLast5min) ? Number(z.loadAvgLast5min) : 0,
        loadAvgLast15min: q(z.loadAvgLast15min) ? Number(z.loadAvgLast15min) : 0,
        cpuLoad: q(z.cpuLoad) ? Number(z.cpuLoad) : 0,
        memoryLoad: q(z.memoryLoad) ? Number(z.memoryLoad) : 0,
        sysPacketsOut: q(z.sysPacketsOut) ? Number(z.sysPacketsOut) : 0,
        sysPacketsDropped: q(z.sysPacketsDropped) ? Number(z.sysPacketsDropped) : 0,
        sysPacketsOutPerSec: q(z.sysPacketsOutPerSec) ? Number(z.sysPacketsOutPerSec) : 0,
        sysPacketsDroppedPerSec: q(z.sysPacketsDroppedPerSec) ? Number(z.sysPacketsDroppedPerSec) : 0,
        sysPacketsDroppedPctPerSec: q(z.sysPacketsDroppedPctPerSec) ? Number(z.sysPacketsDroppedPctPerSec) : 0,
        retransmitBytesOut: q(z.retransmitBytesOut) ? Number(z.retransmitBytesOut) : 0,
        retransmitPacketsOut: q(z.retransmitPacketsOut) ? Number(z.retransmitPacketsOut) : 0,
        retransmitBytesOutPerSec: q(z.retransmitBytesOutPerSec) ? Number(z.retransmitBytesOutPerSec) : 0,
        retransmitPacketsOutPerSec: q(z.retransmitPacketsOutPerSec) ? Number(z.retransmitPacketsOutPerSec) : 0,
        participantJoin: q(z.participantJoin) ? Number(z.participantJoin) : 0,
        participantJoinPerSec: q(z.participantJoinPerSec) ? Number(z.participantJoinPerSec) : 0
      };
    },
    toJSON(z) {
      const C = {};
      return z.startedAt !== void 0 && (C.startedAt = Math.round(z.startedAt)), z.updatedAt !== void 0 && (C.updatedAt = Math.round(z.updatedAt)), z.numRooms !== void 0 && (C.numRooms = Math.round(z.numRooms)), z.numClients !== void 0 && (C.numClients = Math.round(z.numClients)), z.numTracksIn !== void 0 && (C.numTracksIn = Math.round(z.numTracksIn)), z.numTracksOut !== void 0 && (C.numTracksOut = Math.round(z.numTracksOut)), z.bytesIn !== void 0 && (C.bytesIn = Math.round(z.bytesIn)), z.bytesOut !== void 0 && (C.bytesOut = Math.round(z.bytesOut)), z.packetsIn !== void 0 && (C.packetsIn = Math.round(z.packetsIn)), z.packetsOut !== void 0 && (C.packetsOut = Math.round(z.packetsOut)), z.nackTotal !== void 0 && (C.nackTotal = Math.round(z.nackTotal)), z.bytesInPerSec !== void 0 && (C.bytesInPerSec = z.bytesInPerSec), z.bytesOutPerSec !== void 0 && (C.bytesOutPerSec = z.bytesOutPerSec), z.packetsInPerSec !== void 0 && (C.packetsInPerSec = z.packetsInPerSec), z.packetsOutPerSec !== void 0 && (C.packetsOutPerSec = z.packetsOutPerSec), z.nackPerSec !== void 0 && (C.nackPerSec = z.nackPerSec), z.numCpus !== void 0 && (C.numCpus = Math.round(z.numCpus)), z.loadAvgLast1min !== void 0 && (C.loadAvgLast1min = z.loadAvgLast1min), z.loadAvgLast5min !== void 0 && (C.loadAvgLast5min = z.loadAvgLast5min), z.loadAvgLast15min !== void 0 && (C.loadAvgLast15min = z.loadAvgLast15min), z.cpuLoad !== void 0 && (C.cpuLoad = z.cpuLoad), z.memoryLoad !== void 0 && (C.memoryLoad = z.memoryLoad), z.sysPacketsOut !== void 0 && (C.sysPacketsOut = Math.round(z.sysPacketsOut)), z.sysPacketsDropped !== void 0 && (C.sysPacketsDropped = Math.round(z.sysPacketsDropped)), z.sysPacketsOutPerSec !== void 0 && (C.sysPacketsOutPerSec = z.sysPacketsOutPerSec), z.sysPacketsDroppedPerSec !== void 0 && (C.sysPacketsDroppedPerSec = z.sysPacketsDroppedPerSec), z.sysPacketsDroppedPctPerSec !== void 0 && (C.sysPacketsDroppedPctPerSec = z.sysPacketsDroppedPctPerSec), z.retransmitBytesOut !== void 0 && (C.retransmitBytesOut = Math.round(z.retransmitBytesOut)), z.retransmitPacketsOut !== void 0 && (C.retransmitPacketsOut = Math.round(z.retransmitPacketsOut)), z.retransmitBytesOutPerSec !== void 0 && (C.retransmitBytesOutPerSec = z.retransmitBytesOutPerSec), z.retransmitPacketsOutPerSec !== void 0 && (C.retransmitPacketsOutPerSec = z.retransmitPacketsOutPerSec), z.participantJoin !== void 0 && (C.participantJoin = Math.round(z.participantJoin)), z.participantJoinPerSec !== void 0 && (C.participantJoinPerSec = z.participantJoinPerSec), C;
    },
    fromPartial(z) {
      var C, b, E, k, O, A, x, Y, B, T, D, te, me, Ie, $e, ye, fe, Me, Ae, xe, ae, N, re, le, Ne, Oe, qe, je, Fe, yt, Xe, Ge, V;
      const ge = ie();
      return ge.startedAt = (C = z.startedAt) !== null && C !== void 0 ? C : 0, ge.updatedAt = (b = z.updatedAt) !== null && b !== void 0 ? b : 0, ge.numRooms = (E = z.numRooms) !== null && E !== void 0 ? E : 0, ge.numClients = (k = z.numClients) !== null && k !== void 0 ? k : 0, ge.numTracksIn = (O = z.numTracksIn) !== null && O !== void 0 ? O : 0, ge.numTracksOut = (A = z.numTracksOut) !== null && A !== void 0 ? A : 0, ge.bytesIn = (x = z.bytesIn) !== null && x !== void 0 ? x : 0, ge.bytesOut = (Y = z.bytesOut) !== null && Y !== void 0 ? Y : 0, ge.packetsIn = (B = z.packetsIn) !== null && B !== void 0 ? B : 0, ge.packetsOut = (T = z.packetsOut) !== null && T !== void 0 ? T : 0, ge.nackTotal = (D = z.nackTotal) !== null && D !== void 0 ? D : 0, ge.bytesInPerSec = (te = z.bytesInPerSec) !== null && te !== void 0 ? te : 0, ge.bytesOutPerSec = (me = z.bytesOutPerSec) !== null && me !== void 0 ? me : 0, ge.packetsInPerSec = (Ie = z.packetsInPerSec) !== null && Ie !== void 0 ? Ie : 0, ge.packetsOutPerSec = ($e = z.packetsOutPerSec) !== null && $e !== void 0 ? $e : 0, ge.nackPerSec = (ye = z.nackPerSec) !== null && ye !== void 0 ? ye : 0, ge.numCpus = (fe = z.numCpus) !== null && fe !== void 0 ? fe : 0, ge.loadAvgLast1min = (Me = z.loadAvgLast1min) !== null && Me !== void 0 ? Me : 0, ge.loadAvgLast5min = (Ae = z.loadAvgLast5min) !== null && Ae !== void 0 ? Ae : 0, ge.loadAvgLast15min = (xe = z.loadAvgLast15min) !== null && xe !== void 0 ? xe : 0, ge.cpuLoad = (ae = z.cpuLoad) !== null && ae !== void 0 ? ae : 0, ge.memoryLoad = (N = z.memoryLoad) !== null && N !== void 0 ? N : 0, ge.sysPacketsOut = (re = z.sysPacketsOut) !== null && re !== void 0 ? re : 0, ge.sysPacketsDropped = (le = z.sysPacketsDropped) !== null && le !== void 0 ? le : 0, ge.sysPacketsOutPerSec = (Ne = z.sysPacketsOutPerSec) !== null && Ne !== void 0 ? Ne : 0, ge.sysPacketsDroppedPerSec = (Oe = z.sysPacketsDroppedPerSec) !== null && Oe !== void 0 ? Oe : 0, ge.sysPacketsDroppedPctPerSec = (qe = z.sysPacketsDroppedPctPerSec) !== null && qe !== void 0 ? qe : 0, ge.retransmitBytesOut = (je = z.retransmitBytesOut) !== null && je !== void 0 ? je : 0, ge.retransmitPacketsOut = (Fe = z.retransmitPacketsOut) !== null && Fe !== void 0 ? Fe : 0, ge.retransmitBytesOutPerSec = (yt = z.retransmitBytesOutPerSec) !== null && yt !== void 0 ? yt : 0, ge.retransmitPacketsOutPerSec = (Xe = z.retransmitPacketsOutPerSec) !== null && Xe !== void 0 ? Xe : 0, ge.participantJoin = (Ge = z.participantJoin) !== null && Ge !== void 0 ? Ge : 0, ge.participantJoinPerSec = (V = z.participantJoinPerSec) !== null && V !== void 0 ? V : 0, ge;
    }
  };
  function Q() {
    return {
      participantKey: "",
      senderTime: 0,
      connectionId: "",
      startSession: void 0,
      request: void 0,
      removeParticipant: void 0,
      muteTrack: void 0,
      updateParticipant: void 0,
      deleteRoom: void 0,
      updateSubscriptions: void 0,
      sendData: void 0,
      updateRoomMetadata: void 0,
      keepAlive: void 0
    };
  }
  a.RTCNodeMessage = {
    encode(z, C = l.default.Writer.create()) {
      return z.participantKey !== void 0 && z.participantKey !== "" && C.uint32(10).string(z.participantKey), z.senderTime !== void 0 && z.senderTime !== 0 && C.uint32(88).int64(z.senderTime), z.connectionId !== void 0 && z.connectionId !== "" && C.uint32(106).string(z.connectionId), z.startSession !== void 0 && a.StartSession.encode(z.startSession, C.uint32(18).fork()).ldelim(), z.request !== void 0 && I.SignalRequest.encode(z.request, C.uint32(26).fork()).ldelim(), z.removeParticipant !== void 0 && _.RoomParticipantIdentity.encode(z.removeParticipant, C.uint32(34).fork()).ldelim(), z.muteTrack !== void 0 && _.MuteRoomTrackRequest.encode(z.muteTrack, C.uint32(42).fork()).ldelim(), z.updateParticipant !== void 0 && _.UpdateParticipantRequest.encode(z.updateParticipant, C.uint32(50).fork()).ldelim(), z.deleteRoom !== void 0 && _.DeleteRoomRequest.encode(z.deleteRoom, C.uint32(58).fork()).ldelim(), z.updateSubscriptions !== void 0 && _.UpdateSubscriptionsRequest.encode(z.updateSubscriptions, C.uint32(66).fork()).ldelim(), z.sendData !== void 0 && _.SendDataRequest.encode(z.sendData, C.uint32(74).fork()).ldelim(), z.updateRoomMetadata !== void 0 && _.UpdateRoomMetadataRequest.encode(z.updateRoomMetadata, C.uint32(82).fork()).ldelim(), z.keepAlive !== void 0 && a.KeepAlive.encode(z.keepAlive, C.uint32(98).fork()).ldelim(), C;
    },
    decode(z, C) {
      const b = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = C === void 0 ? b.len : b.pos + C;
      const k = Q();
      for (; b.pos < E; ) {
        const O = b.uint32();
        switch (O >>> 3) {
          case 1:
            k.participantKey = b.string();
            break;
          case 11:
            k.senderTime = _e(b.int64());
            break;
          case 13:
            k.connectionId = b.string();
            break;
          case 2:
            k.startSession = a.StartSession.decode(b, b.uint32());
            break;
          case 3:
            k.request = I.SignalRequest.decode(b, b.uint32());
            break;
          case 4:
            k.removeParticipant = _.RoomParticipantIdentity.decode(b, b.uint32());
            break;
          case 5:
            k.muteTrack = _.MuteRoomTrackRequest.decode(b, b.uint32());
            break;
          case 6:
            k.updateParticipant = _.UpdateParticipantRequest.decode(b, b.uint32());
            break;
          case 7:
            k.deleteRoom = _.DeleteRoomRequest.decode(b, b.uint32());
            break;
          case 8:
            k.updateSubscriptions = _.UpdateSubscriptionsRequest.decode(b, b.uint32());
            break;
          case 9:
            k.sendData = _.SendDataRequest.decode(b, b.uint32());
            break;
          case 10:
            k.updateRoomMetadata = _.UpdateRoomMetadataRequest.decode(b, b.uint32());
            break;
          case 12:
            k.keepAlive = a.KeepAlive.decode(b, b.uint32());
            break;
          default:
            b.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(z) {
      return {
        participantKey: q(z.participantKey) ? String(z.participantKey) : "",
        senderTime: q(z.senderTime) ? Number(z.senderTime) : 0,
        connectionId: q(z.connectionId) ? String(z.connectionId) : "",
        startSession: q(z.startSession) ? a.StartSession.fromJSON(z.startSession) : void 0,
        request: q(z.request) ? I.SignalRequest.fromJSON(z.request) : void 0,
        removeParticipant: q(z.removeParticipant) ? _.RoomParticipantIdentity.fromJSON(z.removeParticipant) : void 0,
        muteTrack: q(z.muteTrack) ? _.MuteRoomTrackRequest.fromJSON(z.muteTrack) : void 0,
        updateParticipant: q(z.updateParticipant) ? _.UpdateParticipantRequest.fromJSON(z.updateParticipant) : void 0,
        deleteRoom: q(z.deleteRoom) ? _.DeleteRoomRequest.fromJSON(z.deleteRoom) : void 0,
        updateSubscriptions: q(z.updateSubscriptions) ? _.UpdateSubscriptionsRequest.fromJSON(z.updateSubscriptions) : void 0,
        sendData: q(z.sendData) ? _.SendDataRequest.fromJSON(z.sendData) : void 0,
        updateRoomMetadata: q(z.updateRoomMetadata) ? _.UpdateRoomMetadataRequest.fromJSON(z.updateRoomMetadata) : void 0,
        keepAlive: q(z.keepAlive) ? a.KeepAlive.fromJSON(z.keepAlive) : void 0
      };
    },
    toJSON(z) {
      const C = {};
      return z.participantKey !== void 0 && (C.participantKey = z.participantKey), z.senderTime !== void 0 && (C.senderTime = Math.round(z.senderTime)), z.connectionId !== void 0 && (C.connectionId = z.connectionId), z.startSession !== void 0 && (C.startSession = z.startSession ? a.StartSession.toJSON(z.startSession) : void 0), z.request !== void 0 && (C.request = z.request ? I.SignalRequest.toJSON(z.request) : void 0), z.removeParticipant !== void 0 && (C.removeParticipant = z.removeParticipant ? _.RoomParticipantIdentity.toJSON(z.removeParticipant) : void 0), z.muteTrack !== void 0 && (C.muteTrack = z.muteTrack ? _.MuteRoomTrackRequest.toJSON(z.muteTrack) : void 0), z.updateParticipant !== void 0 && (C.updateParticipant = z.updateParticipant ? _.UpdateParticipantRequest.toJSON(z.updateParticipant) : void 0), z.deleteRoom !== void 0 && (C.deleteRoom = z.deleteRoom ? _.DeleteRoomRequest.toJSON(z.deleteRoom) : void 0), z.updateSubscriptions !== void 0 && (C.updateSubscriptions = z.updateSubscriptions ? _.UpdateSubscriptionsRequest.toJSON(z.updateSubscriptions) : void 0), z.sendData !== void 0 && (C.sendData = z.sendData ? _.SendDataRequest.toJSON(z.sendData) : void 0), z.updateRoomMetadata !== void 0 && (C.updateRoomMetadata = z.updateRoomMetadata ? _.UpdateRoomMetadataRequest.toJSON(z.updateRoomMetadata) : void 0), z.keepAlive !== void 0 && (C.keepAlive = z.keepAlive ? a.KeepAlive.toJSON(z.keepAlive) : void 0), C;
    },
    fromPartial(z) {
      var C, b, E;
      const k = Q();
      return k.participantKey = (C = z.participantKey) !== null && C !== void 0 ? C : "", k.senderTime = (b = z.senderTime) !== null && b !== void 0 ? b : 0, k.connectionId = (E = z.connectionId) !== null && E !== void 0 ? E : "", k.startSession = z.startSession !== void 0 && z.startSession !== null ? a.StartSession.fromPartial(z.startSession) : void 0, k.request = z.request !== void 0 && z.request !== null ? I.SignalRequest.fromPartial(z.request) : void 0, k.removeParticipant = z.removeParticipant !== void 0 && z.removeParticipant !== null ? _.RoomParticipantIdentity.fromPartial(z.removeParticipant) : void 0, k.muteTrack = z.muteTrack !== void 0 && z.muteTrack !== null ? _.MuteRoomTrackRequest.fromPartial(z.muteTrack) : void 0, k.updateParticipant = z.updateParticipant !== void 0 && z.updateParticipant !== null ? _.UpdateParticipantRequest.fromPartial(z.updateParticipant) : void 0, k.deleteRoom = z.deleteRoom !== void 0 && z.deleteRoom !== null ? _.DeleteRoomRequest.fromPartial(z.deleteRoom) : void 0, k.updateSubscriptions = z.updateSubscriptions !== void 0 && z.updateSubscriptions !== null ? _.UpdateSubscriptionsRequest.fromPartial(z.updateSubscriptions) : void 0, k.sendData = z.sendData !== void 0 && z.sendData !== null ? _.SendDataRequest.fromPartial(z.sendData) : void 0, k.updateRoomMetadata = z.updateRoomMetadata !== void 0 && z.updateRoomMetadata !== null ? _.UpdateRoomMetadataRequest.fromPartial(z.updateRoomMetadata) : void 0, k.keepAlive = z.keepAlive !== void 0 && z.keepAlive !== null ? a.KeepAlive.fromPartial(z.keepAlive) : void 0, k;
    }
  };
  function ne() {
    return { connectionId: "", response: void 0, endSession: void 0 };
  }
  a.SignalNodeMessage = {
    encode(z, C = l.default.Writer.create()) {
      return z.connectionId !== void 0 && z.connectionId !== "" && C.uint32(10).string(z.connectionId), z.response !== void 0 && I.SignalResponse.encode(z.response, C.uint32(18).fork()).ldelim(), z.endSession !== void 0 && a.EndSession.encode(z.endSession, C.uint32(26).fork()).ldelim(), C;
    },
    decode(z, C) {
      const b = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = C === void 0 ? b.len : b.pos + C;
      const k = ne();
      for (; b.pos < E; ) {
        const O = b.uint32();
        switch (O >>> 3) {
          case 1:
            k.connectionId = b.string();
            break;
          case 2:
            k.response = I.SignalResponse.decode(b, b.uint32());
            break;
          case 3:
            k.endSession = a.EndSession.decode(b, b.uint32());
            break;
          default:
            b.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(z) {
      return {
        connectionId: q(z.connectionId) ? String(z.connectionId) : "",
        response: q(z.response) ? I.SignalResponse.fromJSON(z.response) : void 0,
        endSession: q(z.endSession) ? a.EndSession.fromJSON(z.endSession) : void 0
      };
    },
    toJSON(z) {
      const C = {};
      return z.connectionId !== void 0 && (C.connectionId = z.connectionId), z.response !== void 0 && (C.response = z.response ? I.SignalResponse.toJSON(z.response) : void 0), z.endSession !== void 0 && (C.endSession = z.endSession ? a.EndSession.toJSON(z.endSession) : void 0), C;
    },
    fromPartial(z) {
      var C;
      const b = ne();
      return b.connectionId = (C = z.connectionId) !== null && C !== void 0 ? C : "", b.response = z.response !== void 0 && z.response !== null ? I.SignalResponse.fromPartial(z.response) : void 0, b.endSession = z.endSession !== void 0 && z.endSession !== null ? a.EndSession.fromPartial(z.endSession) : void 0, b;
    }
  };
  function Z() {
    return {
      roomName: "",
      identity: "",
      connectionId: "",
      reconnect: !1,
      autoSubscribe: !1,
      hidden: !1,
      client: void 0,
      recorder: !1,
      name: "",
      grantsJson: "",
      adaptiveStream: !1,
      participantId: ""
    };
  }
  a.StartSession = {
    encode(z, C = l.default.Writer.create()) {
      return z.roomName !== void 0 && z.roomName !== "" && C.uint32(10).string(z.roomName), z.identity !== void 0 && z.identity !== "" && C.uint32(18).string(z.identity), z.connectionId !== void 0 && z.connectionId !== "" && C.uint32(26).string(z.connectionId), z.reconnect === !0 && C.uint32(32).bool(z.reconnect), z.autoSubscribe === !0 && C.uint32(72).bool(z.autoSubscribe), z.hidden === !0 && C.uint32(80).bool(z.hidden), z.client !== void 0 && p.ClientInfo.encode(z.client, C.uint32(90).fork()).ldelim(), z.recorder === !0 && C.uint32(96).bool(z.recorder), z.name !== void 0 && z.name !== "" && C.uint32(106).string(z.name), z.grantsJson !== void 0 && z.grantsJson !== "" && C.uint32(114).string(z.grantsJson), z.adaptiveStream === !0 && C.uint32(120).bool(z.adaptiveStream), z.participantId !== void 0 && z.participantId !== "" && C.uint32(130).string(z.participantId), C;
    },
    decode(z, C) {
      const b = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = C === void 0 ? b.len : b.pos + C;
      const k = Z();
      for (; b.pos < E; ) {
        const O = b.uint32();
        switch (O >>> 3) {
          case 1:
            k.roomName = b.string();
            break;
          case 2:
            k.identity = b.string();
            break;
          case 3:
            k.connectionId = b.string();
            break;
          case 4:
            k.reconnect = b.bool();
            break;
          case 9:
            k.autoSubscribe = b.bool();
            break;
          case 10:
            k.hidden = b.bool();
            break;
          case 11:
            k.client = p.ClientInfo.decode(b, b.uint32());
            break;
          case 12:
            k.recorder = b.bool();
            break;
          case 13:
            k.name = b.string();
            break;
          case 14:
            k.grantsJson = b.string();
            break;
          case 15:
            k.adaptiveStream = b.bool();
            break;
          case 16:
            k.participantId = b.string();
            break;
          default:
            b.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(z) {
      return {
        roomName: q(z.roomName) ? String(z.roomName) : "",
        identity: q(z.identity) ? String(z.identity) : "",
        connectionId: q(z.connectionId) ? String(z.connectionId) : "",
        reconnect: q(z.reconnect) ? !!z.reconnect : !1,
        autoSubscribe: q(z.autoSubscribe) ? !!z.autoSubscribe : !1,
        hidden: q(z.hidden) ? !!z.hidden : !1,
        client: q(z.client) ? p.ClientInfo.fromJSON(z.client) : void 0,
        recorder: q(z.recorder) ? !!z.recorder : !1,
        name: q(z.name) ? String(z.name) : "",
        grantsJson: q(z.grantsJson) ? String(z.grantsJson) : "",
        adaptiveStream: q(z.adaptiveStream) ? !!z.adaptiveStream : !1,
        participantId: q(z.participantId) ? String(z.participantId) : ""
      };
    },
    toJSON(z) {
      const C = {};
      return z.roomName !== void 0 && (C.roomName = z.roomName), z.identity !== void 0 && (C.identity = z.identity), z.connectionId !== void 0 && (C.connectionId = z.connectionId), z.reconnect !== void 0 && (C.reconnect = z.reconnect), z.autoSubscribe !== void 0 && (C.autoSubscribe = z.autoSubscribe), z.hidden !== void 0 && (C.hidden = z.hidden), z.client !== void 0 && (C.client = z.client ? p.ClientInfo.toJSON(z.client) : void 0), z.recorder !== void 0 && (C.recorder = z.recorder), z.name !== void 0 && (C.name = z.name), z.grantsJson !== void 0 && (C.grantsJson = z.grantsJson), z.adaptiveStream !== void 0 && (C.adaptiveStream = z.adaptiveStream), z.participantId !== void 0 && (C.participantId = z.participantId), C;
    },
    fromPartial(z) {
      var C, b, E, k, O, A, x, Y, B, T, D;
      const te = Z();
      return te.roomName = (C = z.roomName) !== null && C !== void 0 ? C : "", te.identity = (b = z.identity) !== null && b !== void 0 ? b : "", te.connectionId = (E = z.connectionId) !== null && E !== void 0 ? E : "", te.reconnect = (k = z.reconnect) !== null && k !== void 0 ? k : !1, te.autoSubscribe = (O = z.autoSubscribe) !== null && O !== void 0 ? O : !1, te.hidden = (A = z.hidden) !== null && A !== void 0 ? A : !1, te.client = z.client !== void 0 && z.client !== null ? p.ClientInfo.fromPartial(z.client) : void 0, te.recorder = (x = z.recorder) !== null && x !== void 0 ? x : !1, te.name = (Y = z.name) !== null && Y !== void 0 ? Y : "", te.grantsJson = (B = z.grantsJson) !== null && B !== void 0 ? B : "", te.adaptiveStream = (T = z.adaptiveStream) !== null && T !== void 0 ? T : !1, te.participantId = (D = z.participantId) !== null && D !== void 0 ? D : "", te;
    }
  };
  function de() {
    return {};
  }
  a.EndSession = {
    encode(z, C = l.default.Writer.create()) {
      return C;
    },
    decode(z, C) {
      const b = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = C === void 0 ? b.len : b.pos + C;
      const k = de();
      for (; b.pos < E; ) {
        const O = b.uint32();
        switch (O >>> 3) {
          default:
            b.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(z) {
      return {};
    },
    toJSON(z) {
      return {};
    },
    fromPartial(z) {
      return de();
    }
  };
  function he() {
    return { participantId: "" };
  }
  a.RemoveParticipant = {
    encode(z, C = l.default.Writer.create()) {
      return z.participantId !== void 0 && z.participantId !== "" && C.uint32(10).string(z.participantId), C;
    },
    decode(z, C) {
      const b = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = C === void 0 ? b.len : b.pos + C;
      const k = he();
      for (; b.pos < E; ) {
        const O = b.uint32();
        switch (O >>> 3) {
          case 1:
            k.participantId = b.string();
            break;
          default:
            b.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(z) {
      return { participantId: q(z.participantId) ? String(z.participantId) : "" };
    },
    toJSON(z) {
      const C = {};
      return z.participantId !== void 0 && (C.participantId = z.participantId), C;
    },
    fromPartial(z) {
      var C;
      const b = he();
      return b.participantId = (C = z.participantId) !== null && C !== void 0 ? C : "", b;
    }
  };
  function pe() {
    return {};
  }
  a.KeepAlive = {
    encode(z, C = l.default.Writer.create()) {
      return C;
    },
    decode(z, C) {
      const b = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = C === void 0 ? b.len : b.pos + C;
      const k = pe();
      for (; b.pos < E; ) {
        const O = b.uint32();
        switch (O >>> 3) {
          default:
            b.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(z) {
      return {};
    },
    toJSON(z) {
      return {};
    },
    fromPartial(z) {
      return pe();
    }
  };
  function be() {
    return { trackEgress: void 0 };
  }
  a.RoomInternal = {
    encode(z, C = l.default.Writer.create()) {
      return z.trackEgress !== void 0 && v.AutoTrackEgress.encode(z.trackEgress, C.uint32(10).fork()).ldelim(), C;
    },
    decode(z, C) {
      const b = z instanceof l.default.Reader ? z : new l.default.Reader(z);
      let E = C === void 0 ? b.len : b.pos + C;
      const k = be();
      for (; b.pos < E; ) {
        const O = b.uint32();
        switch (O >>> 3) {
          case 1:
            k.trackEgress = v.AutoTrackEgress.decode(b, b.uint32());
            break;
          default:
            b.skipType(O & 7);
            break;
        }
      }
      return k;
    },
    fromJSON(z) {
      return { trackEgress: q(z.trackEgress) ? v.AutoTrackEgress.fromJSON(z.trackEgress) : void 0 };
    },
    toJSON(z) {
      const C = {};
      return z.trackEgress !== void 0 && (C.trackEgress = z.trackEgress ? v.AutoTrackEgress.toJSON(z.trackEgress) : void 0), C;
    },
    fromPartial(z) {
      const C = be();
      return C.trackEgress = z.trackEgress !== void 0 && z.trackEgress !== null ? v.AutoTrackEgress.fromPartial(z.trackEgress) : void 0, C;
    }
  };
  var ke = (() => {
    if (typeof ke < "u")
      return ke;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function _e(z) {
    if (z.gt(Number.MAX_SAFE_INTEGER))
      throw new ke.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return z.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function q(z) {
    return z != null;
  }
})(livekit_internal);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(P, $, F, H) {
    H === void 0 && (H = F), Object.defineProperty(P, H, { enumerable: !0, get: function() {
      return $[F];
    } });
  } : function(P, $, F, H) {
    H === void 0 && (H = F), P[H] = $[F];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(P, $) {
    Object.defineProperty(P, "default", { enumerable: !0, value: $ });
  } : function(P, $) {
    P.default = $;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(P, $) {
    for (var F in P)
      F !== "default" && !Object.prototype.hasOwnProperty.call($, F) && u($, P, F);
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(P) {
    if (P && P.__esModule)
      return P;
    var $ = {};
    if (P != null)
      for (var F in P)
        F !== "default" && Object.prototype.hasOwnProperty.call(P, F) && u($, P, F);
    return c($, P), $;
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LivekitInternal = a.TrackType = a.TrackInfo = a.Room = a.ParticipantPermission = a.ParticipantInfo_State = a.ParticipantInfo = a.DataPacket_Kind = a.IngressVideoOptions = a.IngressState = a.IngressInput = a.IngressInfo = a.IngressAudioOptions = a.StreamProtocol = a.StreamOutput = a.SegmentedFileProtocol = a.SegmentedFileOutput = a.EncodingOptionsPreset = a.EncodingOptions = a.EncodedFileType = a.EncodedFileOutput = a.EgressInfo = a.DirectFileOutput = void 0, l(AccessToken$1, a), l(EgressClient$1, a), l(grants, a), l(IngressClient$1, a);
  var p = livekit_egress;
  Object.defineProperty(a, "DirectFileOutput", { enumerable: !0, get: function() {
    return p.DirectFileOutput;
  } }), Object.defineProperty(a, "EgressInfo", { enumerable: !0, get: function() {
    return p.EgressInfo;
  } }), Object.defineProperty(a, "EncodedFileOutput", { enumerable: !0, get: function() {
    return p.EncodedFileOutput;
  } }), Object.defineProperty(a, "EncodedFileType", { enumerable: !0, get: function() {
    return p.EncodedFileType;
  } }), Object.defineProperty(a, "EncodingOptions", { enumerable: !0, get: function() {
    return p.EncodingOptions;
  } }), Object.defineProperty(a, "EncodingOptionsPreset", { enumerable: !0, get: function() {
    return p.EncodingOptionsPreset;
  } }), Object.defineProperty(a, "SegmentedFileOutput", { enumerable: !0, get: function() {
    return p.SegmentedFileOutput;
  } }), Object.defineProperty(a, "SegmentedFileProtocol", { enumerable: !0, get: function() {
    return p.SegmentedFileProtocol;
  } }), Object.defineProperty(a, "StreamOutput", { enumerable: !0, get: function() {
    return p.StreamOutput;
  } }), Object.defineProperty(a, "StreamProtocol", { enumerable: !0, get: function() {
    return p.StreamProtocol;
  } });
  var _ = livekit_ingress;
  Object.defineProperty(a, "IngressAudioOptions", { enumerable: !0, get: function() {
    return _.IngressAudioOptions;
  } }), Object.defineProperty(a, "IngressInfo", { enumerable: !0, get: function() {
    return _.IngressInfo;
  } }), Object.defineProperty(a, "IngressInput", { enumerable: !0, get: function() {
    return _.IngressInput;
  } }), Object.defineProperty(a, "IngressState", { enumerable: !0, get: function() {
    return _.IngressState;
  } }), Object.defineProperty(a, "IngressVideoOptions", { enumerable: !0, get: function() {
    return _.IngressVideoOptions;
  } });
  var I = livekit_models;
  Object.defineProperty(a, "DataPacket_Kind", { enumerable: !0, get: function() {
    return I.DataPacket_Kind;
  } }), Object.defineProperty(a, "ParticipantInfo", { enumerable: !0, get: function() {
    return I.ParticipantInfo;
  } }), Object.defineProperty(a, "ParticipantInfo_State", { enumerable: !0, get: function() {
    return I.ParticipantInfo_State;
  } }), Object.defineProperty(a, "ParticipantPermission", { enumerable: !0, get: function() {
    return I.ParticipantPermission;
  } }), Object.defineProperty(a, "Room", { enumerable: !0, get: function() {
    return I.Room;
  } }), Object.defineProperty(a, "TrackInfo", { enumerable: !0, get: function() {
    return I.TrackInfo;
  } }), Object.defineProperty(a, "TrackType", { enumerable: !0, get: function() {
    return I.TrackType;
  } }), l(RoomServiceClient$1, a), l(WebhookReceiver$1, a), a.LivekitInternal = v(livekit_internal);
})(dist);
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(a) {
  return decodeURIComponent(atob(a).replace(/(.)/g, (u, c) => {
    let l = c.charCodeAt(0).toString(16).toUpperCase();
    return l.length < 2 && (l = "0" + l), "%" + l;
  }));
}
function base64UrlDecode(a) {
  let u = a.replace(/-/g, "+").replace(/_/g, "/");
  switch (u.length % 4) {
    case 0:
      break;
    case 2:
      u += "==";
      break;
    case 3:
      u += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(u);
  } catch {
    return atob(u);
  }
}
function jwtDecode(a, u) {
  if (typeof a != "string")
    throw new InvalidTokenError("Invalid token specified: must be a string");
  u || (u = {});
  const c = u.header === !0 ? 0 : 1, l = a.split(".")[c];
  if (typeof l != "string")
    throw new InvalidTokenError(`Invalid token specified: missing part #${c + 1}`);
  let v;
  try {
    v = base64UrlDecode(l);
  } catch (p) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${c + 1} (${p.message})`);
  }
  try {
    return JSON.parse(v);
  } catch (p) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${c + 1} (${p.message})`);
  }
}
var DataType = /* @__PURE__ */ ((a) => (a.ChatMessage = "ChatMessage", a.ParticipantMetadataUpdate = "ParticipantMetadataUpdate", a))(DataType || {}), SpecialEvent = /* @__PURE__ */ ((a) => (a.Chat = "Chat", a))(SpecialEvent || {});
const decoder$1 = new TextDecoder(), encoder$1 = new TextEncoder();
class RoomsManager {
  constructor() {
    qt(this, "rooms");
    this.rooms = /* @__PURE__ */ new Map(), this.addRoom = this.addRoom.bind(this), this.ensureRoom = this.ensureRoom.bind(this), this.removeRoom = this.removeRoom.bind(this);
  }
  addRoom(u, c, l) {
    const v = new RoomContext(u, c, l, this);
    return this.rooms.set(c, v), v;
  }
  ensureRoom(u, c, l) {
    return this.rooms.get(c) ? (this.rooms.get(c).token = l, this.rooms.get(c)) : this.addRoom(u, c, l);
  }
  async removeRoom(u) {
    const c = this.rooms.get(u);
    if (!Room)
      throw new Error("room not found!");
    if (c.isConnecting)
      throw new Error("Cannot remove room: Room is in connecting state");
    c.livekitRoom && await c.livekitRoom.disconnect(!0), this.rooms.delete(u);
  }
}
class RoomContext {
  /**
   * @param baseUrl base url for the webrtc server
   * @param token get
   */
  constructor(u, c, l, v) {
    /**
     * base URL for the webrtc server
     */
    qt(this, "_baseUrl");
    qt(this, "_chatHistory");
    /**
     * event listeners just for livekit room connect
     */
    qt(this, "_connectListeners");
    /**
     * Event listeners that are registered OR to be registered upon connection
     * Keys are of type RoomEvent
     */
    qt(this, "_roomEventListenerRegistry");
    /**
     * Event listeners that are registered OR to be registered on the localParticipant upon connection
     * Keys are of type ParticipantEvent
     */
    qt(this, "_localParticipantEventListenerRegistry");
    /**
     * Registry for special/custom events such as chat events
     */
    qt(this, "_specialEventListenerRegistry");
    /**
     * access token for our connection
     * Should be acquired from vapi
     */
    qt(this, "_jwt");
    /**
     * reference to the rooms manager that contains it
     */
    qt(this, "_manager");
    qt(this, "_apiClient");
    qt(this, "audioTracks");
    qt(this, "isConnecting");
    qt(this, "livekitRoom");
    qt(this, "participants");
    qt(this, "guestParticipantMetadata");
    qt(this, "roomName");
    /**
     * Livekit Room Service client, for performing admin functions
     * Should only be defined if user is room admin
     */
    qt(this, "_admin");
    let p = CoreContext.logLevel.toLowerCase();
    setLogLevel(p), this.livekitRoom = new Room({
      // automatically manage subscribed video quality
      // adaptiveStream: true,
      // optimize publishing bandwidth and CPU for published tracks
      dynacast: !0,
      // default capture settings
      videoCaptureDefaults: {
        resolution: VideoPresets.h720.resolution
      }
    }), this._baseUrl = u, this._connectListeners = [], this._roomEventListenerRegistry = {}, this._jwt = l, Object.values(RoomEvent).forEach((_) => {
      this._roomEventListenerRegistry[_] = /* @__PURE__ */ new Set();
    }), this._localParticipantEventListenerRegistry = {}, Object.values(ParticipantEvent).forEach((_) => {
      this._localParticipantEventListenerRegistry[_] = /* @__PURE__ */ new Set();
    }), this._specialEventListenerRegistry = {}, this._manager = v, this._chatHistory = [], this.roomName = c, this.audioTracks = [], this.participants = [], this.guestParticipantMetadata = [], this.isConnecting = !1, this.subscribeToRoomEvent(RoomEvent.DataReceived, (_, I) => {
      var F;
      const P = decoder$1.decode(_);
      switch (JSON.parse(P).type) {
        case "ChatMessage":
          return this._appendChat(_, I);
        case "ParticipantMetadataUpdate": {
          const H = decoder$1.decode(_), j = JSON.parse(H);
          hasPermission((F = j == null ? void 0 : j.metadata) == null ? void 0 : F.participantRole, Permission.ManageSelf) && this._updateGuestParticipantsStore(j);
          return;
        }
        default:
          return;
      }
    }), this.connect = this.connect.bind(this), this.subscribeToRoomEvent = this.subscribeToRoomEvent.bind(this), this.subscribeToConnect = this.subscribeToConnect.bind(this), this.subscribeToLocalParticipantEvent = this.subscribeToLocalParticipantEvent.bind(this), this.subscribeToSpecialEvent = this.subscribeToSpecialEvent.bind(this), this.unsubscribeFromRoomEvent = this.unsubscribeFromRoomEvent.bind(this), this.unsubscribeFromSpecialEvent = this.unsubscribeFromSpecialEvent.bind(this), this.unsubscribeFromConnect = this.unsubscribeFromConnect.bind(this), this.unsubscribeFromLocalParticipantEvent = this.unsubscribeFromLocalParticipantEvent.bind(this), this.sendChatMessage = this.sendChatMessage.bind(this), this.kickParticipant = this.kickParticipant.bind(this), this.updateParticipant = this.updateParticipant.bind(this), this.muteTrackAsAdmin = this.muteTrackAsAdmin.bind(this), this._updateParticipants = this._updateParticipants.bind(this), this.subscribeToRoomEvent(RoomEvent.ParticipantConnected, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.ParticipantDisconnected, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.TrackSubscribed, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.TrackUnsubscribed, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.LocalTrackPublished, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.LocalTrackUnpublished, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.Disconnected, () => {
      this._updateParticipants();
    }), this.subscribeToRoomEvent(RoomEvent.ParticipantMetadataChanged, (_, I) => {
      if (_ !== (I == null ? void 0 : I.metadata)) {
        const P = JSON.parse(I == null ? void 0 : I.metadata);
        if (hasPermission(P == null ? void 0 : P.participantRole, Permission.ManageSelf)) {
          if (P.hasOwnProperty("isMirrored")) {
            const $ = {
              participantId: I == null ? void 0 : I.identity,
              metadata: P,
              type: "ParticipantMetadataUpdate"
              /* ParticipantMetadataUpdate */
            };
            this._updateGuestParticipantsStore($);
          }
          return;
        }
      }
    });
  }
  bindApiClient(u) {
    this._apiClient = u;
  }
  get isAdmin() {
    return jwtDecode(this._jwt).video.roomAdmin;
  }
  set isAdmin(u) {
    log.warn("isAdmin cannot be set");
  }
  get token() {
    return this._jwt;
  }
  set token(u) {
    this._jwt = u;
  }
  get url() {
    return this._baseUrl;
  }
  set url(u) {
  }
  get chatHistory() {
    return this._chatHistory;
  }
  set chatHistory(u) {
    this._chatHistory = u;
  }
  _updateGuestParticipantsStore(u) {
    if (!this.guestParticipantMetadata.length)
      this.guestParticipantMetadata.push(u);
    else {
      const c = this.guestParticipantMetadata.findIndex((l) => l.participantId === (u == null ? void 0 : u.participantId));
      c > -1 ? this.guestParticipantMetadata[c] = u : this.guestParticipantMetadata.push(u);
    }
  }
  _updateParticipants() {
    if (!this.livekitRoom || this.livekitRoom.state === ConnectionState.Disconnected) {
      this.participants = [];
      return;
    } else {
      const u = Array.from(this.livekitRoom.remoteParticipants.values()), c = [this.livekitRoom.localParticipant];
      c.push(...u), this.guestParticipantMetadata = this.guestParticipantMetadata.filter((l) => c.find((v) => (v == null ? void 0 : v.identity) === (l == null ? void 0 : l.participantId))), this.participants = c;
    }
  }
  /**
   * @param identity Identity of the user that you wish to kick
   */
  async kickParticipant(u) {
    if (this._admin)
      this._admin.removeParticipant(this.roomName, u);
    else
      throw new Error("no admin permissions");
  }
  updateParticipant(u, c) {
    if (this._admin) {
      const l = JSON.stringify(c);
      this._admin.updateParticipant(this.roomName, u, l);
    } else
      throw new Error("no admin permissions");
  }
  muteTrackAsAdmin(u, c = !0) {
    if (this._admin) {
      const l = this.participants.find((v) => [...v.audioTrackPublications.values(), ...v.videoTrackPublications.values()].find((p) => p.trackSid === u));
      if (!l) {
        log.warn("Could not find participant for track:", {
          trackSid: u
        });
        return;
      }
      this._admin.mutePublishedTrack(this.roomName, l == null ? void 0 : l.identity, u, c);
    } else
      throw new Error("no admin permissions");
  }
  _appendChat(u, c) {
    const l = decoder$1.decode(u), v = JSON.parse(l), p = c.identity, _ = c.name, I = {
      ...v,
      displayName: _,
      sender: p
    };
    this.chatHistory = [...this.chatHistory, I], this._triggerSpecialEvents("Chat", I);
  }
  subscribeToConnect(u) {
    return this._connectListeners.push(u), () => this.unsubscribeFromConnect(u);
  }
  unsubscribeFromConnect(u) {
    this._connectListeners = this._connectListeners.filter((c) => c !== u);
  }
  subscribeToSpecialEvent(u, c) {
    return this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromSpecialEvent(u, c);
    };
  }
  unsubscribeFromSpecialEvent(u, c) {
    this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].delete(c);
  }
  _triggerSpecialEvents(u, ...c) {
    this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].forEach((l) => {
      l(...c);
    });
  }
  /**
   * connect to livekit webrtc room
   * @param {string} identity unique user name to be displayed to other users
   */
  async connect(u = {}) {
    var c, l;
    try {
      if (this.livekitRoom.state === "connected" || this.isConnecting)
        return;
      this.isConnecting = !0, await this.livekitRoom.connect(`wss://${this._baseUrl}`, this._jwt, {
        ...u
      }), this.isConnecting = !1, Object.values(RoomEvent).forEach((v) => {
        this.livekitRoom.on(v, (...p) => {
          this._roomEventListenerRegistry[v].forEach((_) => {
            _(...p);
          });
        });
      }), Object.values(ParticipantEvent).forEach((v) => {
        this.livekitRoom.localParticipant.on(v, (...p) => {
          this._localParticipantEventListenerRegistry[v].forEach((_) => {
            _(...p);
          });
        });
      }), this._updateParticipants(), this._connectListeners.forEach((v) => v(this.livekitRoom)), lib$2.LiveKitUtils.isRoomAdmin(this._jwt) ? (log.info("Room: Granting admin permissions"), log.debug("Livekit server: ", (c = this._apiClient) == null ? void 0 : c.getLiveKitServer(!0)), this._admin = new dist.RoomServiceClient((l = this._apiClient) == null ? void 0 : l.getLiveKitServer(!0), void 0, void 0, this._jwt)) : log.debug("Room: Not an admin");
    } catch (v) {
      this.isConnecting = !1, log.error(v);
    }
  }
  subscribeToLocalParticipantEvent(u, c) {
    return this._localParticipantEventListenerRegistry[u] || (this._localParticipantEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._localParticipantEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromLocalParticipantEvent(u, c);
    };
  }
  unsubscribeFromLocalParticipantEvent(u, c) {
    this._localParticipantEventListenerRegistry[u] || (this._localParticipantEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._localParticipantEventListenerRegistry[u].delete(c);
  }
  subscribeToRoomEvent(u, c) {
    return this._roomEventListenerRegistry[u] || (this._roomEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._roomEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromRoomEvent(u, c);
    };
  }
  unsubscribeFromRoomEvent(u, c) {
    this._roomEventListenerRegistry[u] || (this._roomEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._roomEventListenerRegistry[u].delete(c);
  }
  /**
   * Sends chat message to entire livekit room, or a private message (if specified) from local participant
   * @param {string[]} [recipients] The identities of the recipient participants. If undefined, will send message to all participants in the chat.
   * Only specify for private messages.
   * Do not include the local participant's identity in this.
   */
  sendChatMessage(u) {
    const {
      message: c,
      recipients: l,
      metadata: v
    } = u;
    if (!this.livekitRoom || this.livekitRoom.state !== "connected")
      return;
    const p = {
      type: "ChatMessage",
      recipients: l,
      metadata: v,
      content: c,
      timestamp: Date.now()
    }, _ = JSON.stringify(p), I = encoder$1.encode(_);
    if ({
      ...p,
      sender: this.livekitRoom.localParticipant.identity,
      displayName: this.livekitRoom.localParticipant.identity
    }, l) {
      const P = l.map(this.livekitRoom.getParticipantByIdentity);
      return this.livekitRoom.localParticipant.publishData(I, {
        reliable: !0,
        destinationIdentities: P.map(($) => $.identity)
      }).then(() => {
        this._appendChat(I, this.livekitRoom.localParticipant);
      });
    } else
      return this.livekitRoom.localParticipant.publishData(I, {
        reliable: !0
      }).then(() => {
        this._appendChat(I, this.livekitRoom.localParticipant);
      });
  }
}
const webrtcManager = new RoomsManager(), index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  webrtcManager
}, Symbol.toStringTag, { value: "Module" })), encoder = new TextEncoder(), decoder = new TextDecoder(), simpleRooms = /* @__PURE__ */ new Map(), getRoom = (a) => {
  if (!a)
    return null;
  if (simpleRooms.get(a))
    return simpleRooms.get(a);
  const u = webrtcManager.rooms.get(a);
  if (!u)
    return null;
  const c = u.livekitRoom, l = c == null ? void 0 : c.localParticipant;
  window.__StudioRoom = c, l || log.warn("No local participant!");
  const v = {
    useTracks: /* @__PURE__ */ new Set(),
    useTrack: /* @__PURE__ */ new Map(),
    useParticipants: /* @__PURE__ */ new Set(),
    useParticipant: /* @__PURE__ */ new Map(),
    useChatHistory: /* @__PURE__ */ new Set()
  };
  let p = {
    tracks: [],
    participants: [],
    result: {
      participants: [],
      tracks: []
    },
    chat: u.chatHistory
  };
  const _ = () => {
    const ie = u.participants, Q = u.guestParticipantMetadata, ne = ie.flatMap((de) => de.getTrackPublications().map((he) => ({
      ...he,
      participant: de
    }))), Z = {
      participants: ie.map((de) => {
        const he = Q.find((be) => be.participantId === de.identity);
        if (he) {
          let be = JSON.parse(de.metadata);
          be = {
            ...be,
            ...he.metadata
          }, de.metadata = JSON.stringify(be);
        }
        const pe = JSON.parse(de.metadata);
        return {
          id: de.identity,
          isSelf: de === l,
          connectionQuality: de.connectionQuality,
          displayName: pe.displayName || de.name,
          joinedAt: de.joinedAt,
          role: pe.participantRole,
          meta: pe,
          trackIds: ne.filter((be) => be.participant.sid === de.sid).map((be) => be.trackSid)
        };
      }),
      tracks: ne.map((de) => {
        var pe, be, ke, _e;
        const he = JSON.parse((pe = de == null ? void 0 : de.participant) == null ? void 0 : pe.metadata);
        return {
          mediaStreamTrack: (be = de.track) == null ? void 0 : be.mediaStreamTrack,
          id: de.trackSid,
          participantId: (ke = de.participant) == null ? void 0 : ke.identity,
          isMuted: (_e = de.track) == null ? void 0 : _e.isMuted,
          type: de.source,
          isExternal: !!(he != null && he[de.trackSid])
        };
      })
    };
    p = {
      tracks: ne,
      participants: ie,
      result: Z,
      chat: u.chatHistory
    }, v.useTracks.forEach((de) => de(Z.tracks)), v.useTrack.forEach((de, he) => {
      he($(de));
    }), v.useParticipants.forEach((de) => de(Z.participants)), v.useParticipant.forEach((de, he) => {
      he(F(de));
    }), v.useChatHistory.forEach((de) => {
      de(p.chat);
    });
  }, I = [RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ParticipantMetadataChanged, RoomEvent.Disconnected, RoomEvent.TrackSubscribed, RoomEvent.TrackUnsubscribed, RoomEvent.LocalTrackPublished, RoomEvent.LocalTrackUnpublished, RoomEvent.ConnectionQualityChanged, RoomEvent.TrackMuted, RoomEvent.TrackUnmuted, RoomEvent.TrackStreamStateChanged];
  u.subscribeToRoomEvent(RoomEvent.DataReceived, (ie, Q, ne) => {
    const Z = decoder.decode(ie);
    JSON.parse(Z).type === DataType.ParticipantMetadataUpdate && _();
  }), I.map((ie) => u.subscribeToRoomEvent(ie, () => _())).push(u.subscribeToSpecialEvent(SpecialEvent.Chat, _));
  const $ = (ie) => p.result.tracks.find((Q) => Q.id === ie), F = (ie) => p.result.participants.find((Q) => Q.id === ie), H = (ie, Q) => {
    const ne = l.getTrackPublications().find((Z) => Z.trackSid === ie);
    ne && (Q ? ne.mute() : ne.unmute());
  };
  let j, ee;
  const X = {
    id: u.roomName,
    participantId: l.identity,
    setTrackEnabled: H,
    setCameraEnabled: (ie = !0) => l.setCameraEnabled(ie),
    setMicrophoneEnabled: (ie = !0) => l.setMicrophoneEnabled(ie),
    setCamera: async (ie = {}) => {
      var ne;
      if (j) {
        log.warn("Cannot set camera until previous has resolved");
        return;
      }
      j = !0;
      let Q;
      try {
        const de = l.getTrackPublications().filter((pe) => (pe == null ? void 0 : pe.source) === Track.Source.Camera).find((pe) => !$(pe == null ? void 0 : pe.trackSid).isExternal), he = await l.createTracks({
          video: {
            deviceId: ie.deviceId,
            resolution: ie.resolution || {
              width: 1280,
              height: 720,
              frameRate: 30,
              aspectRatio: 16 / 9
            }
          }
        });
        de != null && de.isMuted && he.forEach((pe) => {
          pe.mute();
        }), Q = await Promise.all(he.map((pe) => l.publishTrack(pe))), de && l.unpublishTrack(de.track);
      } catch (Z) {
        throw Z;
      } finally {
        return j = !1, $((ne = Q[0]) == null ? void 0 : ne.trackSid);
      }
    },
    setMicrophone: async (ie) => {
      var ne;
      if (ee) {
        log.warn("Cannot set microphone until previous has resolved");
        return;
      }
      ee = !0;
      let Q;
      try {
        const de = l.getTrackPublications().filter((pe) => pe.source === Track.Source.Microphone).find((pe) => !$(pe == null ? void 0 : pe.trackSid).isExternal), he = await l.createTracks({
          audio: ie || !0
        });
        de != null && de.isMuted && he.forEach((pe) => {
          pe.mute();
        }), Q = await Promise.all(he.map((pe) => l.publishTrack(pe))), de && l.unpublishTrack(de.track);
      } catch (Z) {
        throw Z;
      } finally {
        return ee = !1, $((ne = Q[0]) == null ? void 0 : ne.trackSid);
      }
    },
    addMicrophone: async (ie) => {
      var he;
      if (ee) {
        log.warn("Cannot set microphone until previous has resolved");
        return;
      }
      ee = !0;
      const Q = await l.createTracks({
        audio: ie || !0
      }), Z = l.getTrackPublications().filter((pe) => pe.source === Track.Source.Microphone).find((pe) => {
        var ke, _e;
        const be = $(pe == null ? void 0 : pe.trackSid);
        ((_e = (ke = be == null ? void 0 : be.mediaStreamTrack) == null ? void 0 : ke.getSettings()) == null ? void 0 : _e.deviceId) === ie.deviceId && (be == null || be.isExternal);
      });
      Z != null && Z.isMuted && Q.forEach((pe) => {
        pe.mute();
      });
      const de = await Promise.all(Q.map((pe) => l.publishTrack(pe)));
      return Z && l.unpublishTrack(Z.track), ee = !1, $((he = de[0]) == null ? void 0 : he.trackSid);
    },
    addCamera: async (ie = {}) => {
      var de;
      const Q = await l.createTracks({
        video: {
          deviceId: ie.deviceId,
          resolution: ie.resolution || {
            width: 1280,
            height: 720,
            frameRate: 30,
            aspectRatio: 1.7777777777777777
          }
        }
      }), ne = l.getTrackPublications().find((he) => {
        var pe, be, ke;
        return (he == null ? void 0 : he.source) === Track.Source.Camera && ((ke = (be = (pe = he == null ? void 0 : he.track) == null ? void 0 : pe.mediaStreamTrack) == null ? void 0 : be.getSettings()) == null ? void 0 : ke.deviceId) === ie.deviceId;
      });
      ne != null && ne.isMuted && Q.forEach((he) => {
        he.mute();
      });
      const Z = await Promise.all(Q.map((he) => l.publishTrack(he)));
      return ne && l.unpublishTrack(ne.track), ee = !1, $((de = Z[0]) == null ? void 0 : de.trackSid);
    },
    addScreen: async (ie = {
      audio: !1
    }) => {
      const Q = await l.createScreenTracks(ie), ne = await Promise.all(Q.map((he) => l.publishTrack(he))), Z = ne.find((he) => he.kind === "video"), de = ne.find((he) => he.kind === "audio");
      return {
        screen: $(Z == null ? void 0 : Z.trackSid),
        audio: $(de == null ? void 0 : de.trackSid)
      };
    },
    removeTrack: async (ie) => {
      const Q = p.tracks.find((ne) => ne.trackSid === ie);
      l.unpublishTrack(Q.track);
    },
    /* Setting the local participant metadata. */
    setLocalParticipantMetadata: async (ie, Q) => {
      const ne = JSON.stringify(Q), Z = encoder.encode(JSON.stringify({
        metadata: Q,
        type: DataType.ParticipantMetadataUpdate,
        participantId: ie
      }));
      return l.setMetadata(ne), await l.publishData(Z, {
        reliable: !0
      });
    },
    setParticipantMetadata: (ie, Q) => u.updateParticipant(ie, Q),
    kickParticipant: u.kickParticipant,
    muteTrackAsAdmin: u.muteTrackAsAdmin,
    sendChatMessage: u.sendChatMessage,
    // Callbacks
    getTracks: () => p.result.tracks,
    useTracks: (ie) => (v.useTracks.add(ie), ie(p.result.tracks), () => {
      v.useTracks.delete(ie);
    }),
    getTrack: $,
    useTrack: (ie, Q) => (v.useTrack.set(Q, ie), Q($(ie)), () => {
      v.useTrack.delete(Q);
    }),
    getParticipant: F,
    getParticipants: () => p.result.participants,
    useParticipants: (ie) => (v.useParticipants.add(ie), ie(p.result.participants), () => {
      v.useParticipants.delete(ie);
    }),
    useParticipant: (ie, Q) => (v.useParticipant.set(Q, ie), Q(F(ie)), () => {
      v.useTrack.delete(Q);
    }),
    useChatHistory: (ie) => (v.useChatHistory.add(ie), ie(p.chat), () => {
      v.useChatHistory.delete(ie);
    }),
    useActiveSpeakers: (ie) => {
      var ne, Z;
      const Q = (de) => {
        ie(de.map((he) => he.identity));
      };
      return (ne = u.livekitRoom) == null || ne.on(RoomEvent.ActiveSpeakersChanged, Q), Q((Z = u.livekitRoom) == null ? void 0 : Z.activeSpeakers), () => {
        var de;
        (de = u.livekitRoom) == null || de.off(RoomEvent.ActiveSpeakersChanged, Q);
      };
    },
    sendData: (ie, Q = []) => {
      const ne = encoder.encode(JSON.stringify(ie)), Z = Q == null ? void 0 : Q.map((de) => {
        var he;
        return (he = u.livekitRoom) == null ? void 0 : he.getParticipantByIdentity(de);
      }).filter(Boolean);
      return l.publishData(ne, {
        reliable: !0,
        destinationIdentities: Z.map((de) => de.identity)
      });
    },
    onData: (ie) => {
      var ne;
      const Q = (Z, de) => {
        const he = JSON.parse(decoder.decode(Z));
        ie(he, de == null ? void 0 : de.identity);
      };
      return (ne = u.livekitRoom) == null || ne.on(RoomEvent.DataReceived, Q), () => {
        var Z;
        (Z = u.livekitRoom) == null || Z.off(RoomEvent.DataReceived, Q);
      };
    },
    connect: () => u.connect(),
    disconnect: () => {
      var ie;
      return (ie = u.livekitRoom) == null ? void 0 : ie.disconnect();
    },
    onDisconnected: (ie) => {
      var Q;
      return (Q = u.livekitRoom) == null || Q.on(RoomEvent.Disconnected, ie), () => {
        var ne;
        (ne = u.livekitRoom) == null || ne.off(RoomEvent.DataReceived, ie);
      };
    },
    setAudioOutput: (ie) => {
      var Q;
      return (Q = u.livekitRoom) == null ? void 0 : Q.switchActiveDevice("audiooutput", ie);
    }
  };
  return _(), simpleRooms.set(a, X), X;
}, {
  state: state$2
} = CoreContext, getAccessTokenData = () => {
  var a;
  return ((a = CoreContext.clients.accessTokenClaims) == null ? void 0 : a.user) || {};
}, getBaseUser = () => state$2.user ? {
  id: state$2.user.id,
  props: state$2.user.props,
  name: state$2.user.name,
  projects: state$2.projects.map(toBaseProject),
  sources: state$2.sources.map(toBaseSource)
} : null, toBaseProject = (a) => {
  const {
    compositor: u,
    videoApi: c,
    props: l = {},
    role: v
  } = a, {
    destinations: p,
    encoding: _,
    rendering: I,
    sources: P
  } = c.project, $ = {
    get: u.get,
    getRoot: u.getRoot,
    getParent: u.getParent
  };
  Object.defineProperty($, "nodes", {
    get() {
      return u.nodes.filter((j) => !j._deleted);
    }
  });
  const F = a.videoApi.phase, H = a.videoApi.broadcastId || null;
  return {
    broadcastPhase: F,
    role: v,
    broadcastId: H,
    isLive: [ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPING].includes(F),
    scene: $,
    joinRoom: async (j = {}) => CoreContext.Command.joinRoom({
      projectId: a.id,
      ...j
    }),
    subscribe: (j) => CoreContext.subscribe((ee, X) => {
      X.projectId && (X == null ? void 0 : X.projectId) === a.id && j(ee, X);
    }),
    destinations: p.map(toBaseDestination),
    sources: P.map(toBaseSource),
    encoding: _,
    rendering: I,
    id: a.id,
    hostDisplayName: a.props.hostDisplayName,
    props: l
  };
}, toBaseDestination = (a) => {
  var u;
  return {
    id: a.destinationId,
    enabled: a.enabled,
    address: a.address,
    // For backward compatibility, fall back to "metadata" as props.
    //  All new projects have a dedicated "props" field
    props: ((u = a.metadata) == null ? void 0 : u.props) || (a == null ? void 0 : a.metadata) || {}
  };
}, toBaseSource = (a) => {
  var u;
  return {
    id: a.sourceId,
    address: a.address,
    preview: a.preview,
    props: ((u = a.metadata) == null ? void 0 : u.props) || {}
  };
}, hydrateProject = async (a, u, c) => {
  const l = a.metadata || {}, v = {
    collectionId: a.collectionId,
    projectId: a.projectId,
    updateMask: []
  };
  hasPermission(u, Permission.ManageBroadcast) && a.composition.studioSdk.version !== CoreContext.rendererVersion && (v.composition = {
    studioSdk: {
      version: CoreContext.rendererVersion
    }
  }, v.updateMask.push("composition.studioSdk.version")), c && (v.rendering = {
    video: {
      width: c.x,
      height: c.y,
      framerate: 30
    }
  }, v.updateMask.push("rendering")), v.updateMask.length && await CoreContext.clients.LiveApi().project.updateProject(v);
  const _ = await layoutToProject(l.layoutId, c);
  return {
    id: a.projectId,
    compositor: _,
    role: u,
    videoApi: {
      project: a,
      phase: ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_UNSPECIFIED
    },
    layoutApi: {
      layoutId: l.layoutId
    },
    // For backward compatibility, fall back to "metadata" as props.
    //  All new projects have a dedicated "props" field
    props: (l == null ? void 0 : l.props) || l
  };
}, sceneNodeToLayer = (a) => {
  const {
    id: u,
    props: c = {},
    children: l = []
  } = a;
  return {
    ...u ? {
      id: u
    } : {},
    type: c.type,
    data: {
      ...c
    },
    children: l.map((v) => v.id)
  };
}, nodeToLayer = (a) => ({
  id: a.id,
  type: a.props.type,
  data: {
    ...a.props
  },
  children: a.childIds.map((u) => u)
}), layerToNode = (a) => ({
  id: String(a.id),
  props: {
    type: a.type,
    ...a.data
  },
  childIds: a.children.map((u) => String(u))
}), layoutToProject = async (a, u) => {
  const {
    layers: c
  } = await CoreContext.clients.LayoutApi().layer.listLayers({
    layoutId: a
  });
  if (u && c) {
    const {
      x: _,
      y: I
    } = u, P = c == null ? void 0 : c.reduce(($, F) => $ ? $.data.isRoot ? $ : F.data.isRoot || !c.some((H) => H.children.includes(F.id)) ? F : $ : F, null);
    if (P) {
      const $ = await CoreContext.clients.LayoutApi().layer.updateLayer({
        layoutId: P.layoutId,
        layerId: P.id,
        layer: {
          x: _,
          y: I,
          data: {
            ...P.data,
            size: {
              x: _,
              y: I
            }
          }
        }
      }), F = c.findIndex((H) => H.id === $.id);
      c[F] = $;
    }
  }
  const l = c.map(layerToNode), v = l.reduce((_, I) => _ ? _.props.isRoot ? _ : I.props.isRoot || !l.some((P) => P.childIds.includes(I.id)) ? I : _ : I, null), p = v ? toSceneTree(l, v.id) : null;
  return CoreContext.compositor.loadProject(p, a);
}, getUser = () => {
  const a = state$2.user;
  if (!a)
    throw new Error("User not loaded");
  return a;
}, getProject = (a) => state$2.projects.find((u) => u.id === a), getProjectByLayoutId = (a) => state$2.projects.find((u) => u.compositor.id === a), getProjectRoom = (a) => {
  var u;
  return getRoom((u = getProject(a)) == null ? void 0 : u.roomId);
}, {
  connectionId
} = CoreContext, latestUpdateVersion = {}, getNextNodeVersion = (a) => (latestUpdateVersion[a] || (latestUpdateVersion[a] = 0), ++latestUpdateVersion[a]), request = (a, u) => {
  const c = u.map((l) => {
    const [v, p] = l;
    return {
      [v]: p
    };
  });
  return log.debug("Batch request", c), CoreContext.clients.LayoutApi().layer.batch({
    layoutId: a,
    layers: c,
    requestMetadata: {
      connectionId,
      layoutId: a,
      updateVersions: u.filter(([l]) => l === "update").map(([l, v]) => ({
        [v.id]: getNextNodeVersion(v.id)
      })).reduce((l, v) => ({
        ...v,
        ...l
      }), {})
    }
  });
}, compositorAdapter = (a, u) => ({
  async insert(c = {}, l, v) {
    const p = nodeToLayer({
      id: null,
      props: c,
      childIds: []
    });
    l ? p.type = "child" : p.type = "root", log.debug("Insert layer", p);
    const _ = await CoreContext.clients.LayoutApi().layer.createLayer({
      layoutId: a,
      layer: {
        ...p,
        requestMetadata: {
          connectionId,
          layoutId: a
        }
      }
    });
    if (_.code)
      throw new Error(_.message);
    const I = await u.get(l);
    if (l && !I)
      throw Error("Parent not found with ID");
    if (I) {
      const P = nodeToLayer(I), $ = insertAt$1(v, _.id, P.children), F = {
        layoutId: a,
        layerId: P.id,
        layer: {
          children: $,
          requestMetadata: {
            connectionId,
            layoutId: a,
            updateVersion: {
              [p.id]: getNextNodeVersion(p.id)
            }
          }
        }
      };
      await CoreContext.clients.LayoutApi().layer.updateLayer(F);
    }
    return String(_.id);
  },
  async update(c, l = {}) {
    const v = u.get(c), p = nodeToLayer({
      ...v,
      props: {
        ...v.props,
        ...l
      }
    }), _ = {
      layoutId: a,
      layerId: p.id,
      layer: {
        ...p,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [p.id]: getNextNodeVersion(p.id)
          }
        }
      }
    };
    log.debug("Update layer", _), await CoreContext.clients.LayoutApi().layer.updateLayer(_);
  },
  async remove(c) {
    const l = await u.getParent(c);
    if (l) {
      const v = nodeToLayer(l), p = v.children.filter((I) => I !== c), _ = {
        layoutId: a,
        layerId: v.id,
        layer: {
          children: p,
          requestMetadata: {
            connectionId,
            layoutId: a,
            updateVersions: {
              [v.id]: getNextNodeVersion(v.id)
            }
          }
        }
      };
      await CoreContext.clients.LayoutApi().layer.updateLayer(_);
    }
    await CoreContext.clients.LayoutApi().layer.deleteLayer({
      layoutId: a,
      layerId: c,
      payload: {
        requestMetadata: {
          connectionId,
          layoutId: a
        }
      }
    });
  },
  // @ts-ignore
  async reorder(c, l) {
    const v = u.get(c), p = nodeToLayer({
      ...v,
      childIds: l
    });
    log.debug("Reorder layer children", p), await CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: p.id,
      layer: {
        children: p.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [p.id]: getNextNodeVersion(p.id)
          }
        }
      }
    });
  },
  // @ts-ignore
  async move(c, l, v) {
    const p = u.get(c), _ = u.get(u.getParent(c).id), I = nodeToLayer({
      ..._,
      childIds: pull$1(_.childIds, p.id)
    }), P = u.get(l), $ = nodeToLayer({
      ...P,
      childIds: insertAt$1(v, p.id, P.childIds)
    });
    log.debug("Move layers"), await Promise.all([CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: I.id,
      layer: {
        children: I.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [I.id]: getNextNodeVersion(I.id)
          }
        }
      }
    }), CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: $.id,
      layer: {
        children: $.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [$.id]: getNextNodeVersion($.id)
          }
        }
      }
    })]);
  },
  async batch(c) {
    const l = c.map(([p, _]) => [p, sceneNodeToLayer(_)]), v = await request(a, l);
    return log.debug("Batch response", v), v;
  }
}), {
  state: state$1
} = CoreContext, prepareInternalEvents = () => {
  subscribeInternal(async (a, u) => {
    var c, l, v;
    switch (a) {
      case "UserChanged": {
        const {
          metadata: p
        } = u;
        state$1.user.metadata = p || {}, state$1.user.props = (p == null ? void 0 : p.props) || {}, trigger$1("UserChanged", {
          user: getBaseUser()
        });
        return;
      }
      case "ActiveProjectChanged": {
        const {
          projectId: p
        } = u;
        state$1.activeProjectId = p, trigger$1("ActiveProjectChanged", {
          projectId: p
        });
        return;
      }
      case "ProjectAdded": {
        const _ = await hydrateProject(u, "ROLE_HOST"), I = toBaseProject(_);
        state$1.projects = [...state$1.projects, _], trigger$1("ProjectAdded", {
          project: I
        });
        return;
      }
      case "ProjectRemoved": {
        const {
          projectId: p
        } = u;
        state$1.projects = state$1.projects.filter((_) => _.id !== p), trigger$1("ProjectRemoved", {
          projectId: p
        });
        return;
      }
      case "ProjectChanged": {
        const {
          project: p,
          phase: _,
          broadcastId: I
        } = u, P = getProject(p.projectId);
        if (!P)
          return;
        _ && (P.videoApi.phase = _), typeof I < "u" && (P.videoApi.broadcastId = I);
        const $ = (c = p.metadata) == null ? void 0 : c.layoutId;
        $ !== P.layoutApi.layoutId && (P.layoutApi.layoutId = (l = p.metadata) == null ? void 0 : l.layoutId, P.compositor = await layoutToProject($)), P.videoApi.project = p, P.props = ((v = p.metadata) == null ? void 0 : v.props) ?? {}, trigger$1("ProjectChanged", {
          project: toBaseProject(P)
        });
        return;
      }
      case "DestinationAdded": {
        const {
          projectId: p
        } = u, _ = getProject(p);
        if (!_)
          return;
        _.videoApi.project.destinations.push(u), trigger$1("DestinationAdded", {
          projectId: p,
          destination: toBaseDestination(u)
        });
        return;
      }
      case "DestinationRemoved": {
        const {
          projectId: p,
          destinationId: _
        } = u, I = getProject(p);
        if (!I)
          return;
        I.videoApi.project.destinations = I.videoApi.project.destinations.filter((P) => P.destinationId !== _), trigger$1("DestinationRemoved", {
          projectId: p,
          destinationId: _
        });
        return;
      }
      case "DestinationChanged": {
        const p = u, {
          projectId: _,
          destinationId: I
        } = p, P = getProject(_);
        if (!P)
          return;
        const $ = P.videoApi.project.destinations.find((F) => F.destinationId === I);
        if (!$)
          return;
        Object.assign($, p), trigger$1("DestinationChanged", {
          projectId: _,
          destination: toBaseDestination($)
        });
        return;
      }
      case "SourceAdded": {
        trigger$1("SourceAdded", {
          source: toBaseSource(u)
        });
        return;
      }
      case "SourceRemoved":
        return;
      case "SourceChanged":
        return;
      case "ProjectSourceAdded": {
        const {
          projectId: p,
          source: _
        } = u, I = getProject(p);
        if (!I)
          return;
        I.videoApi.project.sources.push(_), trigger$1("ProjectSourceAdded", {
          source: toBaseSource(_),
          projectId: p
        });
        return;
      }
      case "ProjectSourceRemoved": {
        const {
          projectId: p,
          sourceId: _
        } = u, I = getProject(p);
        if (!I)
          return;
        I.videoApi.project.sources = I.videoApi.project.sources.filter((P) => P.sourceId !== _), trigger$1("ProjectSourceRemoved", {
          sourceId: _,
          projectId: p
        });
      }
      case "NodeAdded":
        return;
      case "NodeRemoved":
        return;
      case "NodeChanged":
        return;
    }
  }), subscribeInternal(() => log.debug({
    nextState: {
      ...state$1
    }
  }));
};
/*! (c) Andrea Giammarchi - ISC */
var self$1 = {};
try {
  self$1.WeakMap = WeakMap;
} catch (a) {
  self$1.WeakMap = function(u, c) {
    var l = c.defineProperty, v = c.hasOwnProperty, p = _.prototype;
    return p.delete = function(P) {
      return this.has(P) && delete P[this._];
    }, p.get = function(P) {
      return this.has(P) ? P[this._] : void 0;
    }, p.has = function(P) {
      return v.call(P, this._);
    }, p.set = function(P, $) {
      return l(P, this._, { configurable: !0, value: $ }), this;
    }, _;
    function _(P) {
      l(this, "_", { value: "_@ungap/weakmap" + u++ }), P && P.forEach(I, this);
    }
    function I(P) {
      this.set(P[0], P[1]);
    }
  }(Math.random(), Object);
}
const WeakMap$1 = self$1.WeakMap;
/*! (c) Andrea Giammarchi - ISC */
var UID = "-" + Math.random().toFixed(6) + "%", UID_IE = !1;
try {
  (function(a, u, c) {
    return u in a && (a.innerHTML = "<p " + c + '="' + UID + '"></p>', a[u].childNodes[0].getAttribute(c) == UID);
  })(document.createElement("template"), "content", "tabindex") || (UID = "_dt: " + UID.slice(1, -1) + ";", UID_IE = !0);
} catch (a) {
}
var UIDC = "<!--" + UID + "-->", COMMENT_NODE = 8, ELEMENT_NODE$1 = 1, TEXT_NODE = 3, SHOULD_USE_TEXT_CONTENT = /^(?:plaintext|script|style|textarea|title|xmp)$/i, VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
/*! (c) Andrea Giammarchi - ISC */
function domsanitizer(a) {
  return a.join(UIDC).replace(selfClosing, fullClosing).replace(attrSeeker, attrReplacer);
}
var spaces = " \\f\\n\\r\\t", almostEverything = "[^" + spaces + `\\/>"'=]+`, attrName = "[" + spaces + "]+" + almostEverything, tagName = "<([A-Za-z]+[A-Za-z0-9:._-]*)((?:", attrPartials = `(?:\\s*=\\s*(?:'[^']*?'|"[^"]*?"|<[^>]*?>|` + almostEverything.replace("\\/", "") + "))?)", attrSeeker = new RegExp(tagName + attrName + attrPartials + "+)([" + spaces + "]*/?>)", "g"), selfClosing = new RegExp(tagName + attrName + attrPartials + "*)([" + spaces + "]*/>)", "g"), findAttributes = new RegExp("(" + attrName + `\\s*=\\s*)(['"]?)` + UIDC + "\\2", "gi");
function attrReplacer(a, u, c, l) {
  return "<" + u + c.replace(findAttributes, replaceAttributes) + l;
}
function replaceAttributes(a, u, c) {
  return u + (c || '"') + UID + (c || '"');
}
function fullClosing(a, u, c) {
  return VOID_ELEMENTS.test(u) ? a : "<" + u + c + "></" + u + ">";
}
const { isArray } = Array, { indexOf, slice } = [], umap = (a) => ({
  // About: get: _.get.bind(_)
  // It looks like WebKit/Safari didn't optimize bind at all,
  // so that using bind slows it down by 60%.
  // Firefox and Chrome are just fine in both cases,
  // so let's use the approach that works fast everywhere 
  get: (u) => a.get(u),
  set: (u, c) => (a.set(u, c), c)
}), ELEMENT_NODE = 1, nodeType = 111, remove = ({ firstChild: a, lastChild: u }) => {
  const c = document.createRange();
  return c.setStartAfter(a), c.setEndAfter(u), c.deleteContents(), a;
}, diffable = (a, u) => a.nodeType === nodeType ? 1 / u < 0 ? u ? remove(a) : a.lastChild : u ? a.valueOf() : a.firstChild : a, persistent = (a) => {
  const { childNodes: u } = a, { length: c } = u;
  if (c < 2)
    return c ? u[0] : a;
  const l = slice.call(u, 0), v = l[0], p = l[c - 1];
  return {
    ELEMENT_NODE,
    nodeType,
    firstChild: v,
    lastChild: p,
    valueOf() {
      if (u.length !== c) {
        let _ = 0;
        for (; _ < c; )
          a.appendChild(l[_++]);
      }
      return a;
    }
  };
};
/*! (c) Andrea Giammarchi - ISC */
var createContent = function(a) {
  var u = "fragment", c = "template", l = "content" in _(c), v = l ? function(P) {
    var $ = _(c);
    return $.innerHTML = P, $.content;
  } : function(P) {
    var $ = _(u), F = _(c), H = null;
    if (/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(P)) {
      var j = RegExp.$1;
      F.innerHTML = "<table>" + P + "</table>", H = F.querySelectorAll(j);
    } else
      F.innerHTML = P, H = F.childNodes;
    return p($, H), $;
  };
  return function($, F) {
    return (F === "svg" ? I : v)($);
  };
  function p(P, $) {
    for (var F = $.length; F--; )
      P.appendChild($[0]);
  }
  function _(P) {
    return P === u ? a.createDocumentFragment() : a.createElementNS("http://www.w3.org/1999/xhtml", P);
  }
  function I(P) {
    var $ = _(u), F = _("div");
    return F.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + P + "</svg>", p($, F.firstChild.childNodes), $;
  }
}(document);
const udomdiff = (a, u, c, l, v) => {
  const p = c.length;
  let _ = u.length, I = p, P = 0, $ = 0, F = null;
  for (; P < _ || $ < I; )
    if (_ === P) {
      const H = I < p ? $ ? l(c[$ - 1], -0).nextSibling : l(c[I - $], 0) : v;
      for (; $ < I; )
        a.insertBefore(l(c[$++], 1), H);
    } else if (I === $)
      for (; P < _; )
        (!F || !F.has(u[P])) && a.removeChild(l(u[P], -1)), P++;
    else if (u[P] === c[$])
      P++, $++;
    else if (u[_ - 1] === c[I - 1])
      _--, I--;
    else if (u[P] === c[I - 1] && c[$] === u[_ - 1]) {
      const H = l(u[--_], -1).nextSibling;
      a.insertBefore(
        l(c[$++], 1),
        l(u[P++], -1).nextSibling
      ), a.insertBefore(l(c[--I], 1), H), u[_] = c[I];
    } else {
      if (!F) {
        F = /* @__PURE__ */ new Map();
        let H = $;
        for (; H < I; )
          F.set(c[H], H++);
      }
      if (F.has(u[P])) {
        const H = F.get(u[P]);
        if ($ < H && H < I) {
          let j = P, ee = 1;
          for (; ++j < _ && j < I && F.get(u[j]) === H + ee; )
            ee++;
          if (ee > H - $) {
            const X = l(u[P], 0);
            for (; $ < H; )
              a.insertBefore(l(c[$++], 1), X);
          } else
            a.replaceChild(
              l(c[$++], 1),
              l(u[P++], -1)
            );
        } else
          P++;
      } else
        a.removeChild(l(u[P++], -1));
    }
  return c;
};
/*! (c) Andrea Giammarchi - ISC */
var importNode = function(a, u, c, l, v) {
  var p = v in a, _ = a.createDocumentFragment();
  _[u](a[l]("g")), _[u](a[l](""));
  var I = p ? a[v](_, !0) : _[c](!0);
  return I.childNodes.length < 2 ? function P($, F) {
    for (var H = $[c](), j = $.childNodes || [], ee = j.length, X = 0; F && X < ee; X++)
      H[u](P(j[X], F));
    return H;
  } : (
    /* istanbul ignore next */
    p ? a[v] : function(P, $) {
      return P[c](!!$);
    }
  );
}(
  document,
  "appendChild",
  "cloneNode",
  "createTextNode",
  "importNode"
), trim = "".trim || /* istanbul ignore next */
function() {
  return String(this).replace(/^\s+|\s+/g, "");
}, normalizeAttributes = UID_IE ? function(a, u) {
  var c = u.join(" ");
  return u.slice.call(a, 0).sort(function(l, v) {
    return c.indexOf(l.name) <= c.indexOf(v.name) ? -1 : 1;
  });
} : function(a, u) {
  return u.slice.call(a, 0);
};
function find(a, u) {
  for (var c = u.length, l = 0; l < c; )
    a = a.childNodes[u[l++]];
  return a;
}
function parse(a, u, c, l) {
  for (var v = a.childNodes, p = v.length, _ = 0; _ < p; ) {
    var I = v[_];
    switch (I.nodeType) {
      case ELEMENT_NODE$1:
        var P = l.concat(_);
        parseAttributes(I, u, c, P), parse(I, u, c, P);
        break;
      case COMMENT_NODE:
        var $ = I.textContent;
        if ($ === UID)
          c.shift(), u.push(
            // basicHTML or other non standard engines
            // might end up having comments in nodes
            // where they shouldn't, hence this check.
            SHOULD_USE_TEXT_CONTENT.test(a.nodeName) ? Text(a, l) : Any(I, l.concat(_))
          );
        else
          switch ($.slice(0, 2)) {
            case "/*":
              if ($.slice(-2) !== "*/")
                break;
            case "":
              a.removeChild(I), _--, p--;
          }
        break;
      case TEXT_NODE:
        SHOULD_USE_TEXT_CONTENT.test(a.nodeName) && trim.call(I.textContent) === UIDC && (c.shift(), u.push(Text(a, l)));
        break;
    }
    _++;
  }
}
function parseAttributes(a, u, c, l) {
  for (var v = a.attributes, p = [], _ = [], I = normalizeAttributes(v, c), P = I.length, $ = 0; $ < P; ) {
    var F = I[$++], H = F.value === UID, j;
    if (H || 1 < (j = F.value.split(UIDC)).length) {
      var ee = F.name;
      if (p.indexOf(ee) < 0) {
        p.push(ee);
        var X = c.shift().replace(
          H ? /^(?:|[\S\s]*?\s)(\S+?)\s*=\s*('|")?$/ : new RegExp(
            "^(?:|[\\S\\s]*?\\s)(" + ee + `)\\s*=\\s*('|")[\\S\\s]*`,
            "i"
          ),
          "$1"
        ), ie = v[X] || // the following ignore is covered by browsers
        // while basicHTML is already case-sensitive
        /* istanbul ignore next */
        v[X.toLowerCase()];
        if (H)
          u.push(Attr(ie, l, X, null));
        else {
          for (var Q = j.length - 2; Q--; )
            c.shift();
          u.push(Attr(ie, l, X, j));
        }
      }
      _.push(F);
    }
  }
  P = _.length, $ = 0;
  for (var ne = 0 < P && UID_IE && !("ownerSVGElement" in a); $ < P; ) {
    var Z = _[$++];
    ne && (Z.value = ""), a.removeAttribute(Z.name);
  }
  var de = a.nodeName;
  if (/^script$/i.test(de)) {
    var he = document.createElement(de);
    for (P = v.length, $ = 0; $ < P; )
      he.setAttributeNode(v[$++].cloneNode(!0));
    he.textContent = a.textContent, a.parentNode.replaceChild(he, a);
  }
}
function Any(a, u) {
  return {
    type: "any",
    node: a,
    path: u
  };
}
function Attr(a, u, c, l) {
  return {
    type: "attr",
    node: a,
    path: u,
    name: c,
    sparse: l
  };
}
function Text(a, u) {
  return {
    type: "text",
    node: a,
    path: u
  };
}
var parsed = umap(new WeakMap$1());
function createInfo(a, u) {
  var c = (a.convert || domsanitizer)(u), l = a.transform;
  l && (c = l(c));
  var v = createContent(c, a.type);
  cleanContent(v);
  var p = [];
  return parse(v, p, u.slice(0), []), {
    content: v,
    updates: function(_) {
      for (var I = [], P = p.length, $ = 0, F = 0; $ < P; ) {
        var H = p[$++], j = find(_, H.path);
        switch (H.type) {
          case "any":
            I.push({ fn: a.any(j, []), sparse: !1 });
            break;
          case "attr":
            var ee = H.sparse, X = a.attribute(j, H.name, H.node);
            ee === null ? I.push({ fn: X, sparse: !1 }) : (F += ee.length - 2, I.push({ fn: X, sparse: !0, values: ee }));
            break;
          case "text":
            I.push({ fn: a.text(j), sparse: !1 }), j.textContent = "";
            break;
        }
      }
      return P += F, function() {
        var ie = arguments.length;
        if (P !== ie - 1)
          throw new Error(
            ie - 1 + " values instead of " + P + `
` + u.join("${value}")
          );
        for (var Q = 1, ne = 1; Q < ie; ) {
          var Z = I[Q - ne];
          if (Z.sparse) {
            var de = Z.values, he = de[0], pe = 1, be = de.length;
            for (ne += be - 2; pe < be; )
              he += arguments[Q++] + de[pe++];
            Z.fn(he);
          } else
            Z.fn(arguments[Q++]);
        }
        return _;
      };
    }
  };
}
function createDetails(a, u) {
  var c = parsed.get(u) || parsed.set(u, createInfo(a, u));
  return c.updates(importNode.call(document, c.content, !0));
}
var empty = [];
function domtagger(a) {
  var u = empty, c = cleanContent;
  return function(l) {
    return u !== l && (c = createDetails(a, u = l)), c.apply(null, arguments);
  };
}
function cleanContent(a) {
  for (var u = a.childNodes, c = u.length; c--; ) {
    var l = u[c];
    l.nodeType !== 1 && trim.call(l.textContent).length === 0 && a.removeChild(l);
  }
}
/*! (c) Andrea Giammarchi - ISC */
var hyperStyle = /* @__PURE__ */ function() {
  var a = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i, u = /([^A-Z])([A-Z]+)/g;
  return function(I, P) {
    return "ownerSVGElement" in I ? l(I, P) : p(I.style, !1);
  };
  function c(_, I, P) {
    return I + "-" + P.toLowerCase();
  }
  function l(_, I) {
    var P;
    return I ? P = I.cloneNode(!0) : (_.setAttribute("style", "--hyper:style;"), P = _.getAttributeNode("style")), P.value = "", _.setAttributeNode(P), p(P, !0);
  }
  function v(_) {
    var I, P = [];
    for (I in _)
      P.push(I.replace(u, c), ":", _[I], ";");
    return P.join("");
  }
  function p(_, I) {
    var P, $;
    return function(F) {
      var H, j, ee, X;
      switch (typeof F) {
        case "object":
          if (F) {
            if (P === "object") {
              if (!I && $ !== F)
                for (j in $)
                  j in F || (_[j] = "");
            } else
              I ? _.value = "" : _.cssText = "";
            H = I ? {} : _;
            for (j in F)
              X = F[j], ee = typeof X == "number" && !a.test(j) ? X + "px" : X, !I && /^--/.test(j) ? H.setProperty(j, ee) : H[j] = ee;
            P = "object", I ? _.value = v($ = H) : $ = F;
            break;
          }
        default:
          $ != F && (P = "string", $ = F, I ? _.value = F || "" : _.cssText = F || "");
          break;
      }
    };
  }
}();
const aria = (a) => (u) => {
  for (const c in u) {
    const l = c === "role" ? c : `aria-${c}`, v = u[c];
    v == null ? a.removeAttribute(l) : a.setAttribute(l, v);
  }
}, attribute = (a, u) => {
  let c, l = !0;
  const v = document.createAttributeNS(null, u);
  return (p) => {
    c !== p && (c = p, c == null ? l || (a.removeAttributeNode(v), l = !0) : (v.value = p, l && (a.setAttributeNodeNS(v), l = !1)));
  };
}, boolean = (a, u, c) => (l) => {
  c !== !!l && ((c = !!l) ? a.setAttribute(u, "") : a.removeAttribute(u));
}, data = ({ dataset: a }) => (u) => {
  for (const c in u) {
    const l = u[c];
    l == null ? delete a[c] : a[c] = l;
  }
}, event = (a, u) => {
  let c, l = u.slice(2);
  return !(u in a) && u.toLowerCase() in a && (l = l.toLowerCase()), (v) => {
    const p = isArray(v) ? v : [v, !1];
    c !== p[0] && (c && a.removeEventListener(l, c, p[1]), (c = p[0]) && a.addEventListener(l, c, p[1]));
  };
}, ref = (a) => (u) => {
  typeof u == "function" ? u(a) : u.current = a;
}, setter = (a, u) => u === "dataset" ? data(a) : (c) => {
  a[u] = c;
}, hyperProperty = (a, u) => {
  let c;
  return (l) => {
    c !== l && (c = l, a[u] !== l && (l == null ? (a[u] = "", a.removeAttribute(u)) : a[u] = l));
  };
}, readOnly = /^(?:form|list)$/i, text = (a, u) => a.ownerDocument.createTextNode(u);
function Tagger(a) {
  return this.type = a, domtagger(this);
}
Tagger.prototype = {
  // there are four kind of attributes, and related behavior:
  //  * events, with a name starting with `on`, to add/remove event listeners
  //  * special, with a name present in their inherited prototype, accessed directly
  //  * regular, accessed through get/setAttribute standard DOM methods
  //  * style, the only regular attribute that also accepts an object as value
  //    so that you can style=${{width: 120}}. In this case, the behavior has been
  //    fully inspired by Preact library and its simplicity.
  attribute(a, u, c) {
    const l = this.type === "svg";
    switch (u) {
      case "class":
        if (l)
          return attribute(a, u);
        u = "className";
      case "props":
        return setter(a, u);
      case "aria":
        return aria(a);
      case "style":
        return hyperStyle(a, c, l);
      case "ref":
        return ref(a);
      case ".dataset":
        return data(a);
      default:
        return u.slice(0, 1) === "." ? setter(a, u.slice(1)) : u.slice(0, 1) === "?" ? boolean(a, u.slice(1)) : u.slice(0, 2) === "on" ? event(a, u) : u in a && !(l || readOnly.test(u)) ? hyperProperty(a, u) : attribute(a, u);
    }
  },
  // in a hyper(node)`<div>${content}</div>` case
  // everything could happen:
  //  * it's a JS primitive, stored as text
  //  * it's null or undefined, the node should be cleaned
  //  * it's a promise, update the content once resolved
  //  * it's an explicit intent, perform the desired operation
  //  * it's an Array, resolve all values if Promises and/or
  //    update the node with the resulting list of content
  any(a, u) {
    const { type: c } = this;
    let l = !1, v;
    const p = (_) => {
      switch (typeof _) {
        case "string":
        case "number":
        case "boolean":
          l ? v !== _ && (v = _, u[0].textContent = _) : (l = !0, v = _, u = udomdiff(
            a.parentNode,
            u,
            [text(a, _)],
            diffable,
            a
          ));
          break;
        case "function":
          p(_(a));
          break;
        case "object":
        case "undefined":
          if (_ == null) {
            l = !1, u = udomdiff(
              a.parentNode,
              u,
              [],
              diffable,
              a
            );
            break;
          }
        default:
          if (l = !1, v = _, isArray(_))
            if (_.length === 0)
              u.length && (u = udomdiff(
                a.parentNode,
                u,
                [],
                diffable,
                a
              ));
            else
              switch (typeof _[0]) {
                case "string":
                case "number":
                case "boolean":
                  p(String(_));
                  break;
                case "function":
                  p(_.map(invoke, a));
                  break;
                case "object":
                  isArray(_[0]) && (_ = _.concat.apply([], _));
                default:
                  u = udomdiff(
                    a.parentNode,
                    u,
                    _,
                    diffable,
                    a
                  );
                  break;
              }
          else
            "ELEMENT_NODE" in _ ? u = udomdiff(
              a.parentNode,
              u,
              _.nodeType === 11 ? slice.call(_.childNodes) : [_],
              diffable,
              a
            ) : "text" in _ ? p(String(_.text)) : "any" in _ ? p(_.any) : "html" in _ ? u = udomdiff(
              a.parentNode,
              u,
              slice.call(
                createContent(
                  [].concat(_.html).join(""),
                  c
                ).childNodes
              ),
              diffable,
              a
            ) : "length" in _ && p(slice.call(_));
          break;
      }
    };
    return p;
  },
  // style or textareas don't accept HTML as content
  // it's pointless to transform or analyze anything
  // different from text there but it's worth checking
  // for possible defined intents.
  text(a) {
    let u;
    const c = (l) => {
      if (u !== l) {
        u = l;
        const v = typeof l;
        v === "object" && l ? "text" in l ? c(String(l.text)) : "any" in l ? c(l.any) : "html" in l ? c([].concat(l.html).join("")) : "length" in l && c(slice.call(l).join("")) : v === "function" ? c(l(a)) : a.textContent = l ?? "";
      }
    };
    return c;
  }
};
function invoke(a) {
  return a(this);
}
const { create: create$1, freeze, keys } = Object, cache = umap(new WeakMap$1()), createRender = (a) => ({
  html: outer("html", a),
  svg: outer("svg", a),
  render(u, c) {
    const l = typeof c == "function" ? c() : c, v = cache.get(u) || cache.set(u, createCache()), p = l instanceof LighterHole ? unroll(a, v, l) : l;
    return p !== v.wire && (v.wire = p, u.textContent = "", u.appendChild(p.valueOf())), u;
  }
}), createCache = () => ({ stack: [], entry: null, wire: null }), outer = (a, u) => {
  const c = umap(new WeakMap$1()), l = (p) => function() {
    return unroll(u, p, v.apply(null, arguments));
  };
  return v.for = (p, _) => {
    const I = c.get(p) || c.set(p, create$1(null));
    return I[_] || (I[_] = l(createCache()));
  }, v.node = function() {
    return unroll(
      u,
      createCache(),
      v.apply(null, arguments)
    ).valueOf();
  }, v;
  function v() {
    return new LighterHole(a, tta.apply(null, arguments));
  }
}, unroll = (a, u, { type: c, template: l, values: v }) => {
  const { length: p } = v;
  unrollValues(a, u, v, p);
  let { entry: _ } = u;
  if (!_ || _.template !== l || _.type !== c) {
    const I = new a(c);
    u.entry = _ = {
      type: c,
      template: l,
      tag: I,
      wire: persistent(I(l, ...v))
    };
  } else
    _.tag(l, ...v);
  return _.wire;
}, unrollValues = (a, { stack: u }, c, l) => {
  for (let v = 0; v < l; v++) {
    const p = c[v];
    p instanceof Hole ? c[v] = unroll(
      a,
      u[v] || (u[v] = createCache()),
      p
    ) : isArray(p) ? unrollValues(
      a,
      u[v] || (u[v] = createCache()),
      p,
      p.length
    ) : u[v] = null;
  }
  l < u.length && u.splice(l);
};
freeze(LighterHole);
function LighterHole(a, u) {
  this.type = a, this.template = u.shift(), this.values = u;
}
const Hole = LighterHole, { render: render$1, html, svg } = createRender(Tagger);
function tta() {
  let a = [], u = 0, { length: c } = arguments;
  for (; u < c; )
    a.push(arguments[u++]);
  return a;
}
const Free = {
  name: "Free",
  layout: ({
    props: a,
    children: u,
    size: c
  }) => u.reduce((l, v) => {
    const {
      size: p = {
        x: "100%",
        y: "100%"
      },
      position: _ = {
        x: 0,
        y: 0
      },
      opacity: I = 1
    } = v.props;
    return {
      ...l,
      [v.id]: {
        position: {
          x: _.x,
          y: _.y
        },
        size: {
          x: p.x,
          y: p.y
        },
        opacity: I
      }
    };
  }, {})
}, Column = {
  name: "Column",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      justify: l = "center",
      align: v = "center",
      cover: p = !1,
      margin: _ = {},
      dimensions: I = 16 / 9,
      reverse: P = !1
    } = a;
    const $ = p ? 0 : Math.min(c.y / 6, 12);
    _ = {
      left: $,
      right: $,
      top: $,
      bottom: $,
      between: $,
      ..._
    };
    const F = c.y - _.top - _.bottom, H = c.x - _.left - _.right, j = _.between * ((u.length || 1) - 1), ee = Math.min(H, (F - j) / (u.length || 1) * I), X = ee / I;
    return html.node`
      <div style=${{
      height: "100%",
      width: p ? c.x + "px" : "auto",
      display: "flex",
      flexDirection: P ? "column-reverse" : "column",
      justifyContent: l,
      alignItems: v,
      paddingLeft: _.left + "px",
      paddingTop: _.top + "px",
      paddingBottom: _.bottom + "px",
      paddingRight: _.right + "px"
    }}>
      ${u.map((ie, Q) => html.node`<div data-node-id=${ie.id} .data=${{
      entryTransition: {
        delay: 400 + Q * 100,
        offset: {
          x: 0,
          y: "100%"
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      borderRadius: p ? 0 : 5
    }} style=${{
      display: "flex",
      width: p ? "100%" : ee + "px",
      height: p ? X + "px" : "auto",
      aspectRatio: I,
      marginBottom: Q === u.length - 1 ? 0 : _.between + "px",
      flexGrow: 0,
      flexShrink: 1,
      flexBasis: X + "px"
    }}></div>`)}
      </div>
    `;
  }
}, Row = {
  name: "Row",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      justify: l = "center",
      align: v = "center",
      cover: p = !1,
      margin: _ = {},
      dimensions: I,
      maxWidth: P = 1,
      reverse: $ = !1
    } = a;
    const F = p ? 0 : Math.min(c.y / 6, 12);
    _ = {
      left: F,
      right: F,
      top: F,
      bottom: F,
      between: F,
      ..._
    };
    const H = c.y - _.top - _.bottom, j = c.x - _.left - _.right, ee = _.between * ((u.length || 1) - 1);
    let X = H, ie = Math.min((j - ee) / (u.length || 1), I ? H * I : j, P * c.x);
    return I && (X = ie / I), html.node`
      <div style=${{
      height: p ? c.y + "px" : "auto",
      width: "100%",
      display: "flex",
      flexDirection: $ ? "row-reverse" : "row",
      justifyContent: l,
      alignItems: v,
      paddingLeft: _.left + "px",
      paddingTop: _.top + "px",
      paddingBottom: _.bottom + "px",
      paddingRight: _.right + "px"
    }}>
          ${u.map((Q, ne) => html.node`<div data-node-id=${Q.id} .data=${{
      entryTransition: {
        delay: 400 + ne * 100,
        offset: {
          x: 0,
          y: "100%"
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      borderRadius: p ? 0 : 5
    }} style=${{
      display: "flex",
      height: p ? "100%" : X + "px",
      width: ie + "px",
      marginRight: ne === u.length - 1 ? 0 : _.between + "px",
      flexGrow: 0,
      flexShrink: 1,
      flexBasis: ie + "px"
    }}></div>`)}
      </div>
    `;
  }
}, toMatrix = (a, u) => a.reduce((c, l, v) => (v % u == 0 ? c.push([v]) : c[c.length - 1].push(v)) && c, []), Grid = {
  name: "Grid",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      dimensions: l,
      numPerRow: v,
      margin: p,
      cover: _ = !1,
      maxWidth: I,
      between: P
    } = a;
    const $ = u.length === 0 || _ ? 0 : P || Math.min(c.y / u.length / 10, 30);
    p = p ?? $;
    const F = c.x < c.y;
    P = typeof P == "number" ? P : p;
    let H = [];
    v ? H = toMatrix(u, v) : H = F ? getTallGrid(u.length) : getWideGrid(u.length);
    const j = (c.y - (p * 2 + P * (H.length - 1))) / H.length, ee = c.x - p * 2;
    return html.node`
    <div style=${{
      display: "flex",
      width: "100%",
      height: "100%",
      flexDirection: "column",
      justifyContent: "center",
      padding: p + "px",
      gap: P + "px",
      flexGrow: 0
    }}>${H.map((X, ie) => Row.layout({
      props: {
        justify: "center",
        dimensions: l,
        cover: _,
        maxWidth: I || 1 / (H[0].length || 1),
        margin: {
          top: 0,
          right: 0,
          left: 0,
          bottom: 0,
          between: P
        }
      },
      children: X.map((Q) => u[Q]),
      size: {
        y: j,
        x: ee
      }
    }))}</div>`;
  }
}, Presentation = {
  name: "Presentation",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      margin: l,
      cover: v = !1,
      barWidth: p = 0.2,
      barPosition: _ = "side",
      presentationDimensions: I = 16 / 9,
      viewerDimensions: P = 16 / 9,
      justifyViewers: $ = "center",
      useGrid: F = !1,
      reverse: H = !1
    } = a;
    const j = _ === "side" ? c.x * p : c.y * p, ee = u[0], X = u.filter((pe) => pe !== ee), ie = u.length <= 1 ? 0 : Math.min(c.x / 80, 30);
    if (l = l ?? ie, !ee)
      return Grid.layout({
        props: a,
        children: u,
        size: c
      });
    const Q = u[1], ne = {
      ...c
    };
    Q && (_ === "side" ? (ne.x = c.x - j, ne.y = ne.x / I) : (ne.y = c.y - j, ne.x = ne.y * I));
    let Z, de = {};
    F ? (Z = Grid.layout, de = {
      cover: v,
      ...v ? {
        maxWidth: 1
      } : {
        margin: l
      }
    }) : (Z = _ === "side" ? Column.layout : Row.layout, de = {
      margin: {
        top: l,
        left: l,
        bottom: l,
        right: l,
        between: l
      },
      dimensions: P,
      justify: $,
      align: "flex-end"
    });
    const he = _ === "side" ? H ? "left" : "right" : H ? "top" : "bottom";
    return html.node`
      <div style=${{
      display: "flex",
      flexDirection: (_ === "side" ? "row" : "column") + (H ? "-reverse" : ""),
      justifyContent: "space-around",
      alignItems: "center",
      position: "relative",
      padding: v ? 0 : l,
      [`padding-${he}`]: 0
    }}>
        ${u[0] && html.node`<div style=${{
      // aspectRatio: String(presentationDimensions),
      width: ne.x,
      height: ne.y,
      display: "flex",
      flexGrow: 1
    }}>
            <div data-node-id=${ee.id} .data=${{
      dimensions: I,
      borderRadius: v ? 0 : 5,
      entryTransition: {
        delay: 0,
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.5,
          y: 0.5
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 2,
          y: 2
        },
        opacity: 0
      }
    }} style=${{
      width: "100%",
      height: "100%",
      ...v ? {
        position: "absolute",
        top: 0,
        left: 0,
        width: F && Q ? 100 - p * 100 + "%" : "100%",
        height: "100%"
      } : {}
    }} />
          </div>`}
        ${html.node`<div style=${{
      ..._ === "side" ? {
        maxWidth: p * 100 + "%",
        height: "100%"
      } : {
        maxHeight: p * 100 + "%",
        width: "100%"
      }
    }}>${Q && Z({
      props: de,
      children: X,
      size: _ === "side" ? {
        x: j,
        y: c.y
      } : {
        x: c.x,
        y: j
      }
    })}</div>`}
      </div>
    `;
  }
}, Layered = {
  name: "Layered",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => html.node`<div style=${{
    width: "100%",
    height: "100%",
    position: "relative"
  }}>
      ${u.map((l, v) => html.node`<div data-node-id=${l.id} .data=${{
    zIndex: v + 1
  }} style=${{
    position: "absolute",
    inset: "0px"
  }}></div>`)}
    </div>`
}, getWideGrid = (a = 0) => {
  switch (a) {
    case 0:
      return [[]];
    case 1:
      return [[0]];
    case 2:
      return [[0, 1]];
    case 3:
      return [[0, 1], [2]];
    case 4:
      return [[0, 1], [2, 3]];
    case 5:
      return [[0, 1, 2], [3, 4]];
    case 6:
      return [[0, 1, 2], [3, 4, 5]];
    case 7:
      return [[0, 1, 2], [3, 4, 5], [6]];
    case 8:
      return [[0, 1, 2], [3, 4, 5], [6, 7]];
  }
  const u = Array(a).fill(null).map((c, l) => l);
  return toMatrix(u, Math.round(Math.sqrt(a)));
}, getTallGrid = (a = 0) => {
  switch (a) {
    case 0:
      return [[]];
    case 1:
      return [[0]];
    case 2:
      return [[0], [1]];
    case 3:
      return [[0, 1], [2]];
    case 4:
      return [[0, 1], [2, 3]];
    case 5:
      return [[0, 1], [2, 3], [4]];
    case 6:
      return [[0, 1], [2, 3], [4, 5]];
    case 7:
      return [[0, 1], [2, 3], [4, 5], [6]];
    case 8:
      return [[0, 1], [2, 3], [4, 5], [6, 7]];
  }
  const u = Array(a).fill(null).map((c, l) => l);
  return toMatrix(u, Math.ceil(Math.sqrt(u.length)) - 1);
}, Layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Column,
  Free,
  Grid,
  Layered,
  Presentation,
  Row
}, Symbol.toStringTag, { value: "Module" })), deviceWatchers = /* @__PURE__ */ new Set(), updateMediaStreamTracks = (a, u) => {
  const c = {
    audio: a.getAudioTracks()[0],
    video: a.getVideoTracks()[0]
  };
  c.audio !== u.audio && (c.audio && a.removeTrack(c.audio), u.audio && a.addTrack(u.audio)), c.video !== u.video && (c.video && a.removeTrack(c.video), u.video && a.addTrack(u.video));
}, getDevicePermissions = async () => {
  const a = {
    audio: !0,
    video: !0
  };
  return Promise.all([navigator.mediaDevices.getUserMedia({
    video: !0
  }).then((u) => {
    u.getTracks().forEach((c) => c.stop());
  }).catch((u) => {
    u.name === "NotAllowedError" && (a.video = !1);
  }), navigator.mediaDevices.getUserMedia({
    audio: !0
  }).then((u) => {
    u.getTracks().forEach((c) => c.stop());
  }).catch((u) => {
    u.name === "NotAllowedError" && (a.audio = !1);
  })]).then(() => a);
}, ensureDevicePermissions = async () => getDevicePermissions(), watchDevices = (a) => (deviceWatchers.size === 0 && navigator.mediaDevices.addEventListener("devicechange", reportDevices), deviceWatchers.add(a), reportDevices().catch(() => {
}), () => {
  deviceWatchers.delete(a), deviceWatchers.size === 0 && navigator.mediaDevices.removeEventListener("devicechange", reportDevices);
}), getUserMedia = async (...a) => {
  const u = await navigator.mediaDevices.getUserMedia(...a);
  return reportDevices(), u;
}, deviceWithDefaultLabel = (a, u) => ({
  deviceId: a.deviceId,
  groupId: a.groupId,
  kind: a.kind,
  label: a.label || u
}), reportDevices = async () => {
  const a = await navigator.mediaDevices.enumerateDevices(), u = a.filter((v) => v.kind === "videoinput").map((v, p) => deviceWithDefaultLabel(v, "Camera " + (p + 1))), c = a.filter((v) => v.kind === "audioinput").map((v, p) => deviceWithDefaultLabel(v, "Microphone " + (p + 1))), l = a.filter((v) => v.kind === "audiooutput").map((v, p) => deviceWithDefaultLabel(v, "Speaker " + (p + 1)));
  deviceWatchers.forEach((v) => v({
    webcams: u,
    microphones: c,
    speakers: l
  }));
}, webrtc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureDevicePermissions,
  getDevicePermissions,
  getUserMedia,
  updateMediaStreamTracks,
  watchDevices
}, Symbol.toStringTag, { value: "Module" })), RoomParticipant$1 = {
  type: "RoomParticipant",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    // 'screen' | 'camera'
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l
  }) {
    CoreContext.on("RoomJoined", ({
      room: v
    }) => {
      let p = {}, _ = [], I = [], P = {};
      const $ = () => {
        _.filter((F) => (F == null ? void 0 : F.type) === "camera" && (F == null ? void 0 : F.isExternal) === !0).forEach((F) => {
          var H, j, ee;
          if (F.type === "camera") {
            const X = P[F.id], ie = v.getParticipant(F.participantId), Q = v.getTrack(F.id);
            if (l(F == null ? void 0 : F.id)) {
              const Z = v.getTrack((H = ie == null ? void 0 : ie.meta[F.id]) == null ? void 0 : H.microphone);
              updateMediaStreamTracks(X, {
                video: Q == null ? void 0 : Q.mediaStreamTrack,
                audio: Z == null ? void 0 : Z.mediaStreamTrack
              }), c(F.id, {
                videoEnabled: !!(Q && !Q.isMuted),
                audioEnabled: !!(Z && !Z.isMuted),
                displayName: ((j = ie == null ? void 0 : ie.meta[F.id]) == null ? void 0 : j.displayName) || "External Track",
                mirrored: (ee = ie == null ? void 0 : ie.meta[F.id]) == null ? void 0 : ee.isMirrored,
                microphone: Z,
                external: F == null ? void 0 : F.isExternal
              });
            }
          }
        }), I.forEach((F) => {
          var de;
          const H = P[F.id], j = P[F.id + "-screen"], ee = F.trackIds.find((he) => {
            const pe = v.getTrack(he);
            return (pe == null ? void 0 : pe.type) === "camera" && !(pe != null && pe.isExternal);
          }), X = F.trackIds.find((he) => {
            const pe = v.getTrack(he);
            return (pe == null ? void 0 : pe.type) === "microphone" && !(pe != null && pe.isExternal);
          }), ie = F.trackIds.find((he) => {
            const pe = v.getTrack(he);
            return (pe == null ? void 0 : pe.type) === "screen_share";
          }), Q = v.getTrack(ee), ne = v.getTrack(X), Z = v.getTrack(ie);
          updateMediaStreamTracks(H, {
            video: Q == null ? void 0 : Q.mediaStreamTrack,
            audio: ne == null ? void 0 : ne.mediaStreamTrack
          }), updateMediaStreamTracks(j, {
            video: Z == null ? void 0 : Z.mediaStreamTrack
          }), c(F.id, {
            videoEnabled: !!(Q && !Q.isMuted),
            audioEnabled: !!(ne && !ne.isMuted),
            displayName: F.displayName,
            mirrored: (de = F == null ? void 0 : F.meta) == null ? void 0 : de.isMirrored,
            external: Q == null ? void 0 : Q.isExternal
          }), c(F.id + "-screen", {
            videoEnabled: !!(Z && !Z.isMuted),
            displayName: F.meta.screenDisplayName || `${F.displayName}'s Screen`
          });
        });
      };
      v.useTracks((F) => {
        const H = F.filter((ee) => !_.some((X) => X.id === ee.id) && !!(ee != null && ee.mediaStreamTrack)), j = _.filter((ee) => !F.some((X) => X.id === ee.id));
        _ = F.filter((ee) => !!(ee != null && ee.mediaStreamTrack)), H.forEach((ee) => {
          const X = new MediaStream([]);
          P[ee.id] = X;
          const {
            id: ie,
            participantId: Q,
            type: ne,
            mediaStreamTrack: Z
          } = v.getTrack(ee.id);
          Z && a({
            id: ie,
            isActive: !0,
            value: X,
            props: {
              id: ie,
              trackId: ie,
              participantId: Q,
              isMuted: ee.isMuted,
              type: ne
            }
          });
        }), j.forEach((ee) => {
          var X;
          u(ee.id), (X = p[ee.id]) == null || X.call(p);
        }), $();
      }), v.useParticipants((F) => {
        const H = F.filter((ee) => !I.some((X) => X.id === ee.id)), j = I.filter((ee) => !F.some((X) => X.id === ee.id));
        I = F, H.forEach((ee) => {
          var ne;
          const {
            id: X
          } = ee, ie = new MediaStream([]), Q = new MediaStream([]);
          P[X] = ie, P[X + "-screen"] = Q, a({
            id: X,
            isActive: !0,
            value: ie,
            props: {
              id: X,
              type: "camera",
              displayName: ee.displayName || ee.id,
              audioEnabled: !1,
              videoEnabled: !1,
              mirrored: (ne = ee == null ? void 0 : ee.meta) == null ? void 0 : ne.isMirrored
            }
          }), a({
            id: X + "-screen",
            isActive: !0,
            value: Q,
            props: {
              id: X,
              type: "screen",
              displayName: ee.displayName || ee.id,
              audioEnabled: !1,
              videoEnabled: !1
            }
          });
        }), $(), j.forEach((ee) => {
          var X;
          u(ee.id), (X = p[ee.id]) == null || X.call(p);
        });
      });
    });
  }
}, Banner$1 = {
  type: "Banner",
  valueType: Object,
  props: {},
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l,
    modifySourceValue: v
  }) {
    let p = [];
    const _ = (I = []) => {
      const P = I.filter((H) => !p.some((j) => j.id === H.id)), $ = p.filter((H) => !I.some((j) => j.id === H.id)), F = I.filter((H) => {
        const j = p.find((ee) => ee.id === H.id);
        return !deepEqual(H, j);
      });
      P.forEach((H) => a({
        id: H.id,
        value: {
          headerText: H.props.headerText,
          bodyText: H.props.bodyText
        },
        // TODO: It feels odd to have "props" match "value" exactly.
        //  They probably shouldn't be necessary here.
        props: H.props
      })), $.forEach((H) => u(H.id)), F.forEach((H) => {
        c(H.id, H.props), v(H.id, (j) => {
          j.headerText = H.props.headerText, j.bodyText = H.props.bodyText;
        });
      }), p = I;
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId: I
    }) => {
      var $;
      if (p = [], !I)
        return;
      const P = getProject(I);
      _((($ = P.props) == null ? void 0 : $.banners) ?? []);
    }), CoreContext.on("ProjectChanged", ({
      project: I
    }) => {
      var P;
      _(((P = I.props) == null ? void 0 : P.banners) ?? []);
    });
  }
}, {
  state
} = CoreContext, updateUserProps = async (a) => {
  const u = getUser();
  if (!u)
    return;
  const c = {
    ...u.props,
    ...a.props
  }, l = await CoreContext.clients.LiveApi().collection.updateCollection({
    collectionId: u.id,
    updateMask: ["metadata"],
    metadata: {
      ...u.metadata,
      props: c
    }
  });
  await triggerInternal$1("UserChanged", l.collection);
}, createSource = async (a) => {
  const u = getUser().id, {
    source: c
  } = await CoreContext.clients.LiveApi().source.createSource({
    metadata: {
      props: a.props || {}
    },
    collectionId: u,
    address: a.address,
    preview: {
      webrtc: {
        enabled: !0,
        displayName: a.displayName || "RTMP Source"
      }
    }
  });
  await triggerInternal$1("SourceAdded", c);
  const l = await CoreContext.clients.LiveApi().source.addSourceToProject({
    collectionId: u,
    projectId: a.projectId,
    sourceId: c.sourceId
  });
  return await triggerInternal$1("ProjectSourceAdded", {
    projectId: l.project.projectId,
    source: c
  }), c;
}, updateSource = async (a) => {
  const u = getUser().id;
  let c = [], l = {};
  a.metadata && (c.push("metadata"), l.metadata = a.metadata), a.displayName && (c.push("preview.webrtc.displayName"), l = {
    ...l,
    preview: {
      webrtc: {
        displayName: a.displayName
      }
    }
  });
  const {
    source: v
  } = await CoreContext.clients.LiveApi().source.updateSource({
    collectionId: u,
    updateMask: c,
    sourceId: a.sourceId,
    ...l
  });
  return await triggerInternal$1("SourceChanged", v), v;
}, deleteSource = async (a) => {
  const u = getUser().id;
  await CoreContext.clients.LiveApi().source.removeSourceFromProject({
    collectionId: u,
    projectId: a.projectId,
    sourceId: a.sourceId
  }), await triggerInternal$1("ProjectSourceRemoved", {
    projectId: a.projectId,
    sourceId: a.sourceId
  });
  const c = await CoreContext.clients.LiveApi().source.deleteSource({
    sourceId: a.sourceId,
    collectionId: u
  });
  return await triggerInternal$1("SourceRemoved", a.sourceId), c;
}, createProject$1 = async (a = {}) => {
  const {
    props: u = {},
    size: c,
    settings: l = {}
  } = a, v = await CoreContext.Request.createProject({
    settings: l,
    props: u,
    size: c
  });
  await triggerInternal$1("ProjectAdded", v.project);
  const p = await hydrateProject(v.project, "ROLE_HOST");
  return toBaseProject(p);
}, recreateLayout = async (a) => {
  const {
    projectId: u,
    props: c = {}
  } = a, l = getUser().id, v = await CoreContext.clients.LiveApi().project.getProject({
    collectionId: l,
    projectId: u,
    status: !0
  });
  if ([ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STARTING].includes(v.status.phase))
    return;
  const p = v.project.metadata || {}, {
    layoutId: _
  } = p, {
    video: I
  } = v.project.rendering, {
    type: P
  } = v.project.metadata.props || {}, $ = await CoreContext.Request.createLayout({
    collectionId: l,
    projectId: u,
    type: P || "sceneless",
    settings: {},
    size: {
      x: I.width,
      y: I.height
    }
  }), F = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: l,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...p,
      layoutId: $.id
    }
  });
  CoreContext.log.debug("New layout assigned to project:", {
    layout: $
  }), await triggerInternal$1("ProjectChanged", {
    project: F.project
  }), await CoreContext.clients.LayoutApi().layout.deleteLayout({
    layoutId: _
  }), CoreContext.log.debug("Previous layout deleted:", {
    layoutId: _
  });
  const H = await hydrateProject(F.project, "ROLE_HOST");
  return await H.compositor.update(H.compositor.getRoot().id, c), {
    project: toBaseProject(H),
    internalProject: H
  };
}, deleteProject$1 = async (a) => {
  const {
    projectId: u
  } = a;
  await CoreContext.Request.deleteProject({
    projectId: u
  }), await triggerInternal$1("ProjectRemoved", {
    projectId: u
  });
}, updateProjectProps = async (a) => {
  const {
    projectId: u
  } = a, c = getUser().id, l = getProject(u), v = {
    ...l.props,
    ...a.props
  }, p = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: c,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...l.videoApi.project.metadata,
      props: v
    }
  });
  await triggerInternal$1("ProjectChanged", {
    project: p.project
  });
}, updateProjectPropsWithoutTrigger = async (a) => {
  const {
    projectId: u
  } = a, c = getUser().id, l = getProject(u), v = {
    ...l.props,
    ...a.props
  };
  await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: c,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...l.videoApi.project.metadata,
      props: v
    }
  });
}, setActiveProject = async (a) => {
  const u = state.projects.find((l) => l.id === a.projectId);
  if (!u) {
    state.activeProjectId = null, triggerInternal$1("ActiveProjectChanged", {
      projectId: null
    });
    return;
  }
  const c = state.projects.find((l) => l.id === state.activeProjectId);
  if (u !== c)
    return c && (Array.from(webrtcManager.rooms.keys()).map(webrtcManager.removeRoom), await CoreContext.clients.LayoutApi().unsubscribeFromLayout(c.layoutApi.layoutId), await CoreContext.clients.LiveApi().unsubscribeFromProject(c.videoApi.project.collectionId, c.videoApi.project.projectId), await CoreContext.clients.LiveApi().unsubscribeFromCollection(c.videoApi.project.collectionId)), await CoreContext.clients.LayoutApi().subscribeToLayout(u.layoutApi.layoutId), await CoreContext.clients.LiveApi().subscribeToProject(u.videoApi.project.collectionId, u.videoApi.project.projectId), await CoreContext.clients.LiveApi().subscribeToCollection(u.videoApi.project.collectionId), CoreContext.clients.LiveApi().project.getProject({
      collectionId: u.videoApi.project.collectionId,
      projectId: u.videoApi.project.projectId,
      status: !0
    }).then((l) => {
      var v, p;
      triggerInternal$1("ProjectChanged", {
        project: l.project,
        phase: (v = l.status) == null ? void 0 : v.phase,
        broadcastId: (p = l.status) == null ? void 0 : p.broadcastId
      });
    }), triggerInternal$1("ActiveProjectChanged", {
      projectId: u.id
    }), toBaseProject(u);
}, joinRoom = async (a) => {
  const {
    projectId: u,
    displayName: c = "Guest"
  } = a, l = state.projects.find((H) => H.id === u);
  let v = l.sfuToken;
  if (!v) {
    let {
      webrtcAccess: H
    } = await CoreContext.clients.LiveApi().authentication.createWebRtcAccessToken({
      collectionId: l.videoApi.project.collectionId,
      projectId: l.videoApi.project.projectId,
      displayName: c
    });
    v = H.accessToken;
  }
  const _ = jwtDecode(v).video.room, I = new URL(CoreContext.clients.getLiveKitServer()), P = I.host + I.pathname, $ = webrtcManager.ensureRoom(P, _, v);
  $.bindApiClient(CoreContext.clients), await $.connect(), l.sfuToken = v, l.roomId = _;
  const F = getRoom(_);
  return trigger$1("RoomJoined", {
    projectId: l.id,
    room: F
  }), F;
}, createNode = async (a) => {
  let {
    props: u = {},
    parentId: c,
    index: l,
    projectId: v = state.activeProjectId
  } = a;
  const p = getProject(v), _ = await p.compositor.insert(u, c, l);
  return triggerInternal$1("NodeAdded", {
    projectId: v,
    nodeId: _
  }), triggerInternal$1("NodeChanged", {
    projectId: v,
    nodeId: c
  }), p.compositor.get(_);
}, deleteNode = async (a) => {
  var p;
  let {
    nodeId: u,
    projectId: c = state.activeProjectId
  } = a;
  const l = getProject(c), v = (p = l.compositor.getParent(u)) == null ? void 0 : p.id;
  l.compositor.remove(u), triggerInternal$1("NodeRemoved", {
    projectId: c,
    nodeId: u
  }), triggerInternal$1("NodeChanged", {
    projectId: c,
    nodeId: v
  });
}, updateNode = async (a) => {
  let {
    nodeId: u,
    props: c = {},
    projectId: l = state.activeProjectId
  } = a;
  const v = getProject(l);
  return delete c.type, delete c.sourceType, v.compositor.update(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  }), v.compositor.get(u);
}, setNodeLayout = async (a) => {
  let {
    nodeId: u,
    layout: c,
    projectId: l = state.activeProjectId,
    layoutProps: v = {}
  } = a;
  getProject(l).compositor.update(u, {
    layout: c,
    layoutProps: v
  }), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, moveNode = async (a) => {
  const {
    nodeId: u,
    parentId: c,
    projectId: l = state.activeProjectId,
    index: v
  } = a;
  getProject(l).compositor.move(u, c, v), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, swapNodes = async (a) => {
  var I, P;
  const {
    nodeAId: u,
    nodeBId: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l), p = (I = v.compositor.getParent(u)) == null ? void 0 : I.id, _ = (P = v.compositor.getParent(c)) == null ? void 0 : P.id;
  v.compositor.swap(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: p
  }), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: _
  });
}, reorderNodes = async (a) => {
  const {
    parentId: u,
    childIds: c,
    projectId: l = state.activeProjectId
  } = a;
  getProject(l).compositor.reorder(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, startBroadcast = async (a) => {
  const {
    projectId: u = state.activeProjectId
  } = a, c = getProject(u);
  await CoreContext.clients.LiveApi().project.startProjectBroadcast({
    collectionId: c.videoApi.project.collectionId,
    projectId: c.videoApi.project.projectId
  });
}, stopBroadcast = async (a) => {
  const {
    projectId: u = state.activeProjectId
  } = a, c = getProject(u);
  await CoreContext.clients.LiveApi().project.stopProjectBroadcast({
    collectionId: c.videoApi.project.collectionId,
    projectId: c.videoApi.project.projectId
  });
}, addDestination = async (a) => {
  var $;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    enabled: l,
    projectId: v = state.activeProjectId,
    props: p = {}
  } = a, _ = getProject(v), I = {
    rtmpPush: {
      key: c,
      url: u
    }
  }, P = await (($ = CoreContext.clients.LiveApi().destination) == null ? void 0 : $.createDestination({
    collectionId: _.videoApi.project.collectionId,
    projectId: _.videoApi.project.projectId,
    address: I,
    enabled: l,
    metadata: {
      props: p
    }
  }));
  return await triggerInternal$1("DestinationAdded", P.destination), toBaseDestination(P.destination);
}, removeDestination = async (a) => {
  var v;
  const {
    destinationId: u,
    projectId: c = state.activeProjectId
  } = a, l = getProject(c);
  await ((v = CoreContext.clients.LiveApi().destination) == null ? void 0 : v.deleteDestination({
    collectionId: l.videoApi.project.collectionId,
    projectId: l.videoApi.project.projectId,
    destinationId: u
  })), await triggerInternal$1("DestinationRemoved", {
    projectId: c,
    destinationId: u
  });
}, updateDestination = async (a) => {
  var P;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    destinationId: l,
    projectId: v = state.activeProjectId
  } = a, p = getProject(v), _ = {
    key: c,
    url: u
  }, I = await ((P = CoreContext.clients.LiveApi().destination) == null ? void 0 : P.updateDestination({
    collectionId: p.videoApi.project.collectionId,
    projectId: p.videoApi.project.projectId,
    destinationId: l,
    updateMask: ["address.rtmpPush"],
    address: {
      rtmpPush: _
    }
  }));
  await triggerInternal$1("DestinationChanged", I.destination);
}, updateDestinationProps = async (a) => {
  var I, P;
  const {
    projectId: u = state.activeProjectId,
    destinationId: c,
    props: l = {}
  } = a, v = getProject(u), p = v.videoApi.project.destinations.find(($) => $.destinationId === c);
  if (!p)
    return;
  const _ = await ((P = CoreContext.clients.LiveApi().destination) == null ? void 0 : P.updateDestination({
    collectionId: v.videoApi.project.collectionId,
    projectId: v.videoApi.project.projectId,
    destinationId: c,
    updateMask: ["metadata"],
    metadata: {
      ...p.metadata || {},
      props: {
        ...((I = p.metadata) == null ? void 0 : I.props) || {},
        ...l
      }
    }
  }));
  await triggerInternal$1("DestinationChanged", _.destination);
}, setDestinationEnabled = async (a) => {
  var I;
  const {
    enabled: u,
    destinationId: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l);
  if (v.videoApi.project.destinations.find((P) => c === P.destinationId).enabled === u)
    return;
  const _ = await ((I = CoreContext.clients.LiveApi().destination) == null ? void 0 : I.updateDestination({
    collectionId: v.videoApi.project.collectionId,
    projectId: v.videoApi.project.projectId,
    destinationId: c,
    updateMask: ["enabled"],
    enabled: u
  }));
  await triggerInternal$1("DestinationChanged", _.destination);
}, setDestination = async (a) => {
  var I, P;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l), p = {
    key: c,
    url: u
  }, _ = !0;
  if (v.videoApi.project.destinations.length > 0) {
    const $ = await ((I = CoreContext.clients.LiveApi().destination) == null ? void 0 : I.updateDestination({
      collectionId: v.videoApi.project.collectionId,
      projectId: v.videoApi.project.projectId,
      destinationId: v.videoApi.project.destinations[0].destinationId,
      updateMask: ["address.rtmpPush"],
      address: {
        rtmpPush: p
      }
    }));
    await triggerInternal$1("DestinationChanged", $.destination);
  } else {
    const $ = await ((P = CoreContext.clients.LiveApi().destination) == null ? void 0 : P.createDestination({
      collectionId: v.videoApi.project.collectionId,
      projectId: v.videoApi.project.projectId,
      address: {
        rtmpPush: p
      },
      enabled: _
    }));
    await triggerInternal$1("DestinationAdded", $.destination);
  }
}, commands$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addDestination,
  createNode,
  createProject: createProject$1,
  createSource,
  deleteNode,
  deleteProject: deleteProject$1,
  deleteSource,
  joinRoom,
  moveNode,
  recreateLayout,
  removeDestination,
  reorderNodes,
  setActiveProject,
  setDestination,
  setDestinationEnabled,
  setNodeLayout,
  startBroadcast,
  stopBroadcast,
  swapNodes,
  updateDestination,
  updateDestinationProps,
  updateNode,
  updateProjectProps,
  updateProjectPropsWithoutTrigger,
  updateSource,
  updateUserProps
}, Symbol.toStringTag, { value: "Module" })), useActiveProjectRoom$1 = () => {
  const [a, u] = useState(null);
  return useEffect(() => useActiveProjectRoom(u), []), a;
}, useDevices = () => {
  const [a, u] = useState({
    webcams: [],
    microphones: [],
    speakers: []
  });
  return useEffect(() => watchDevices(u), []), a;
}, StudioContext = React.createContext({
  studio: null,
  project: null,
  room: null,
  webcamId: null,
  microphoneId: null,
  setStudio: () => {
  },
  setProject: () => {
  },
  setRoom: () => {
  },
  setWebcamId: () => {
  },
  setMicrophoneId: () => {
  },
  projectCommands: {}
}), useStudio = () => useContext(StudioContext);
let stored = {
  webcamId: null,
  microphoneId: null
};
try {
  stored.webcamId = localStorage == null ? void 0 : localStorage.getItem("__LS_webcam"), stored.microphoneId = localStorage == null ? void 0 : localStorage.getItem("__LS_microphone");
} catch {
}
const StudioProvider = ({
  children: a
}) => {
  const [u, c] = useState(), [l, v] = useState(), [p, _] = useState(), [I, P] = useState(stored.webcamId), [$, F] = useState(stored.microphoneId), H = useMemo(() => l ? commands(l) : null, [l]);
  return useEffect(() => {
  }, [l]), useEffect(() => {
    u && (I && u.setCamera({
      deviceId: I
    }).catch((j) => {
      console.warn(j);
    }), $ && u.setMicrophone({
      deviceId: $
    }).catch((j) => {
      console.warn(j);
    }));
  }, [u, I, $]), /* @__PURE__ */ React.createElement(StudioContext.Provider, {
    value: {
      studio: p,
      project: l,
      room: u,
      webcamId: I,
      microphoneId: $,
      setStudio: _,
      setProject: v,
      setRoom: c,
      setWebcamId: (j) => {
        try {
          localStorage == null || localStorage.setItem("__LS_webcam", j);
        } catch {
        }
        P(j);
      },
      setMicrophoneId: (j) => {
        try {
          localStorage == null || localStorage.setItem("__LS_microphone", j);
        } catch {
        }
        F(j);
      },
      projectCommands: H
    }
  }, a);
}, react = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StudioContext,
  StudioProvider,
  useActiveProjectRoom: useActiveProjectRoom$1,
  useDevices,
  useStudio
}, Symbol.toStringTag, { value: "Module" })), ForegroundLayers = [{
  name: "ImageIframeOverlayContainer",
  id: "fg-image-iframe",
  layout: "Free"
}, {
  name: "BannerContainer",
  id: "fg-banners",
  layout: "Column",
  layoutProps: {
    cover: !0
  }
}, {
  name: "VideoOverlayContainer",
  id: "fg-video",
  layout: "Free"
}, {
  name: "LogoContainer",
  layout: "Free",
  id: "logo"
}], defaultStyles = {
  custom: {
    display: "block"
  },
  video: {
    height: "100%",
    width: "100%"
  },
  image: {
    height: "100%",
    width: "100%"
  },
  logo: {
    objectFit: "contain",
    position: "unset"
  }
}, validateEachChildren = (a, u) => {
  let c = !0;
  return a.forEach((l) => {
    var v, p;
    (v = l.props) != null && v.sourceType && !u.includes((p = l.props) == null ? void 0 : p.sourceType) ? c = !1 : l.children.length > 0 && (c = c && validateEachChildren(l.children, u));
  }), c;
}, addingCache = {
  camera: /* @__PURE__ */ new Set(),
  screen: /* @__PURE__ */ new Set(),
  rtmp: /* @__PURE__ */ new Set(),
  game: /* @__PURE__ */ new Set()
}, commands = (a) => {
  var ne, Z, de, he;
  const u = a.id, c = a.scene.getRoot(), {
    Command: l
  } = CoreContext, v = c.children.find((pe) => pe.props.id === "bg"), p = c.children.find((pe) => pe.props.id === "content"), _ = c.children.find((pe) => pe.props.id === "foreground");
  let I = (ne = _ == null ? void 0 : _.children) == null ? void 0 : ne.find((pe) => pe.props.id === "fg-image-iframe"), P = (Z = _ == null ? void 0 : _.children) == null ? void 0 : Z.find((pe) => pe.props.id === "logo"), $ = (de = _ == null ? void 0 : _.children) == null ? void 0 : de.find((pe) => pe.props.id === "fg-video");
  const F = getProject(a.id);
  let H = (he = _ == null ? void 0 : _.children) == null ? void 0 : he.find((pe) => pe.props.id === "fg-banners");
  const j = async () => {
    var pe, be;
    ((pe = v == null ? void 0 : v.props) == null ? void 0 : pe.layout) !== "Layered" && await F.compositor.update(v.id, {
      name: "Background",
      id: "bg",
      layout: "Layered"
    }), ((be = _ == null ? void 0 : _.props) == null ? void 0 : be.layout) !== "Layered" && await F.compositor.update(_.id, {
      id: "foreground",
      name: "Overlays",
      layout: "Layered"
    });
  }, ee = async () => {
    validateEachChildren(v.children, ["Background"]) || v.children.forEach(async (pe) => {
      await CoreContext.Command.deleteNode({
        nodeId: pe.id
      });
    });
  }, X = async () => {
    const pe = async () => {
      var q;
      if (H)
        return H.id;
      {
        const z = await F.compositor.insert({
          name: "BannerContainer",
          id: "fg-banners",
          layout: "Column",
          layoutProps: {
            cover: !0
          }
        }, _.id);
        return H = (q = _ == null ? void 0 : _.children) == null ? void 0 : q.find((C) => C.id === z), z;
      }
    }, be = async () => {
      var q;
      if (I)
        return I.id;
      {
        const z = await F.compositor.insert({
          name: "ImageIframeOverlay",
          id: "fg-image-iframe",
          layout: "Free"
        }, _.id);
        return I = (q = _ == null ? void 0 : _.children) == null ? void 0 : q.find((C) => C.id === z), z;
      }
    }, ke = async () => {
      var q;
      if ($)
        return $.id;
      {
        const z = await F.compositor.insert({
          name: "VideoOverlay",
          id: "fg-video",
          layout: "Free"
        }, _.id);
        return $ = (q = _ == null ? void 0 : _.children) == null ? void 0 : q.find((C) => C.id === z), z;
      }
    }, _e = async () => {
      var q;
      if (P)
        return P.id;
      {
        const z = await F.compositor.insert({
          name: "Logo",
          layout: "Free",
          sourceType: "Logo",
          id: "logo",
          style: {
            width: "100%",
            height: "100%",
            objectFit: "contain",
            position: "unset"
          }
        }, _.id);
        return P = (q = _ == null ? void 0 : _.children) == null ? void 0 : q.find((C) => C.id === z), z;
      }
    };
    try {
      const q = await Promise.all([pe(), be(), ke(), _e()]);
      await F.compositor.reorder(_.id, q);
    } catch {
    }
  }, ie = {
    getBackground() {
      return v;
    },
    getContent() {
      return p;
    },
    getForeground() {
      return _;
    },
    getLayout() {
      return p.props.layout;
    },
    getBanners() {
      var pe;
      return ((pe = getProject(a.id).props) == null ? void 0 : pe.banners) || [];
    },
    getParticipants() {
      return p.children.filter((pe) => pe.props.sourceType === "RoomParticipant");
    },
    getLogo() {
      var pe, be;
      return (be = (pe = P == null ? void 0 : P.children[0]) == null ? void 0 : pe.props) == null ? void 0 : be.id;
    },
    async removeLogo() {
      const [pe, ...be] = (P == null ? void 0 : P.children) || [];
      be.forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      }), pe && await CoreContext.Command.deleteNode({
        nodeId: pe.id
      });
    },
    getImageOverlay() {
      var be, ke;
      const pe = (be = I == null ? void 0 : I.children) == null ? void 0 : be.find((_e) => {
        var q, z;
        return ((z = (q = _e == null ? void 0 : _e.props) == null ? void 0 : q.sourceProps) == null ? void 0 : z.type) === "image";
      });
      return (ke = pe == null ? void 0 : pe.props) == null ? void 0 : ke.id;
    },
    getVideoOverlay() {
      var be, ke;
      const pe = (be = $ == null ? void 0 : $.children) == null ? void 0 : be.find((_e) => {
        var q, z;
        return ((z = (q = _e == null ? void 0 : _e.props) == null ? void 0 : q.sourceProps) == null ? void 0 : z.type) === "video";
      });
      return (ke = pe == null ? void 0 : pe.props) == null ? void 0 : ke.id;
    },
    autoPlayBackgroundVideo(pe = {
      muted: !0,
      autoplay: !0
    }) {
      const be = v.children.find((ke) => ke.props.id === "bg-video");
      be && CoreContext.Command.updateNode({
        nodeId: be.id,
        props: {
          ...be.props,
          attributes: {
            ...be.props.attributes,
            ...pe
          }
        }
      });
    },
    autoPlayVideoOverlay(pe, be = {
      muted: !0,
      autoplay: !0
    }) {
      var _e;
      const ke = (_e = $ == null ? void 0 : $.children) == null ? void 0 : _e.find((q) => {
        var z, C;
        return ((C = (z = q.props) == null ? void 0 : z.sourceProps) == null ? void 0 : C.id) === pe;
      });
      ke && ke.props.sourceProps.type === "video" && CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          ...ke.props,
          attributes: {
            ...ke.props.attributes,
            ...be
          }
        }
      });
    },
    getBackgroundMedia() {
      var be, ke;
      return (ke = (be = v.children.filter((_e) => _e)[0]) == null ? void 0 : be.props) == null ? void 0 : ke.id;
    },
    getBackgroundImage() {
      var be;
      const pe = v.children.find((ke) => {
        var _e, q;
        return ((q = (_e = ke.props) == null ? void 0 : _e.sourceProps) == null ? void 0 : q.type) === "image";
      });
      return (be = pe == null ? void 0 : pe.props) == null ? void 0 : be.id;
    },
    getBackgroundVideo() {
      var be;
      const pe = v.children.find((ke) => {
        var _e, q;
        return ((q = (_e = ke.props) == null ? void 0 : _e.sourceProps) == null ? void 0 : q.type) === "video";
      });
      return (be = pe == null ? void 0 : pe.props) == null ? void 0 : be.id;
    },
    async addLogo(pe, be) {
      const [ke, ..._e] = (P == null ? void 0 : P.children) || [];
      _e.forEach((q) => {
        CoreContext.Command.deleteNode({
          nodeId: q.id
        });
      }), ke ? await CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          sourceType: "Logo",
          id: pe,
          sourceProps: {
            ...be,
            meta: {
              style: {
                ...defaultStyles.logo
              },
              ...be.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: P == null ? void 0 : P.id,
        props: {
          sourceType: "Logo",
          id: pe,
          sourceProps: {
            ...be,
            meta: {
              style: {
                ...defaultStyles.logo
              },
              ...be.meta
            }
          }
        }
      });
    },
    addBanner(pe = {}) {
      var q;
      const be = pe.meta || {}, ke = {
        id: generateId(),
        props: {
          ...pe,
          meta: be
        }
      }, _e = ((q = getProject(u).props) == null ? void 0 : q.banners) || [];
      return l.updateProjectProps({
        projectId: u,
        props: {
          banners: [..._e, ke]
        }
      });
    },
    editBanner(pe, be = {}) {
      const _e = ie.getBanners().map((q) => q.id !== pe ? q : {
        ...q,
        props: be
      });
      return l.updateProjectProps({
        projectId: u,
        props: {
          banners: _e
        }
      });
    },
    removeBanner(pe) {
      var ke;
      const be = ie.getBanners();
      return (ke = H == null ? void 0 : H.children) == null || ke.forEach((_e) => {
        _e.props.bannerId === pe && CoreContext.Command.deleteNode({
          nodeId: _e.id
        });
      }), l.updateProjectProps({
        projectId: u,
        props: {
          banners: be.filter((_e) => _e.id !== pe)
        }
      });
    },
    async setActiveBanner(pe) {
      var q, z;
      const [be, ...{}] = (H == null ? void 0 : H.children) || [];
      ((z = (q = be == null ? void 0 : be.props) == null ? void 0 : q.sourceType) == null ? void 0 : z.toLowerCase()) === "chatoverlay" && await CoreContext.Command.deleteNode({
        nodeId: be.id
      });
      const [ke, ..._e] = (H == null ? void 0 : H.children) || [];
      if (_e.forEach((C) => {
        CoreContext.Command.deleteNode({
          nodeId: C.id
        });
      }), ke)
        CoreContext.Command.updateNode({
          nodeId: ke.id,
          props: {
            sourceType: "Banner",
            bannerId: pe
          }
        });
      else
        return CoreContext.Command.createNode({
          parentId: H == null ? void 0 : H.id,
          props: {
            sourceType: "Banner",
            bannerId: pe
          }
        });
    },
    getActiveBanner() {
      var pe, be, ke;
      return ((ke = (be = (pe = H.children) == null ? void 0 : pe[0]) == null ? void 0 : be.props) == null ? void 0 : ke.bannerId) ?? null;
    },
    async addChatOverlay(pe, be) {
      var z, C;
      const [ke, ...{}] = (H == null ? void 0 : H.children) || [];
      ((C = (z = ke == null ? void 0 : ke.props) == null ? void 0 : z.sourceType) == null ? void 0 : C.toLowerCase()) === "banner" && await CoreContext.Command.deleteNode({
        nodeId: ke.id
      });
      const [_e, ...q] = (H == null ? void 0 : H.children) || [];
      q.forEach((b) => {
        CoreContext.Command.deleteNode({
          nodeId: b.id
        });
      }), _e ? await CoreContext.Command.updateNode({
        nodeId: _e.id,
        props: {
          sourceType: "ChatOverlay",
          chatOverlayId: pe,
          id: pe,
          ...be
        }
      }) : await CoreContext.Command.createNode({
        parentId: H == null ? void 0 : H.id,
        props: {
          sourceType: "ChatOverlay",
          chatOverlayId: pe,
          id: pe,
          ...be
        }
      });
    },
    async removeChatOverlay(pe) {
      var be;
      (be = H == null ? void 0 : H.children) == null || be.forEach(async (ke) => {
        ke.props.chatOverlayId === pe && await CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      });
    },
    getChatOverlay() {
      var pe, be, ke, _e, q;
      return (ke = (be = (pe = H.children) == null ? void 0 : pe[0]) == null ? void 0 : be.props) != null && ke.chatOverlayId && ((q = (_e = H.children) == null ? void 0 : _e[0]) == null ? void 0 : q.props) || null;
    },
    getCustomOverlay() {
      var be, ke;
      const pe = (be = I == null ? void 0 : I.children) == null ? void 0 : be.find((_e) => {
        var q, z;
        return ((z = (q = _e == null ? void 0 : _e.props) == null ? void 0 : q.sourceProps) == null ? void 0 : z.type) === "custom";
      });
      return (ke = pe == null ? void 0 : pe.props) == null ? void 0 : ke.id;
    },
    async addImageOverlay(pe, be) {
      const [ke, ..._e] = (I == null ? void 0 : I.children) || [];
      _e.forEach((z) => {
        CoreContext.Command.deleteNode({
          nodeId: z.id
        });
      });
      const q = {
        ...defaultStyles.image,
        ...($ == null ? void 0 : $.children.length) && {
          opacity: 0
        }
      };
      ke ? await CoreContext.Command.updateNode({
        nodeId: ke == null ? void 0 : ke.id,
        props: {
          sourceType: "Overlay",
          id: pe,
          sourceProps: {
            ...be,
            type: "image",
            meta: {
              style: {
                ...q
              }
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: I == null ? void 0 : I.id,
        props: {
          sourceType: "Overlay",
          id: pe,
          sourceProps: {
            ...be,
            type: "image",
            meta: {
              style: {
                ...q
              }
            }
          }
        }
      });
    },
    async addVideoOverlay(pe, be) {
      const [ke, ..._e] = ($ == null ? void 0 : $.children) || [];
      _e.forEach((q) => {
        CoreContext.Command.deleteNode({
          nodeId: q.id
        });
      }), I.children.forEach(({
        id: q,
        props: z
      }) => {
        var C, b;
        if (((b = (C = z.sourceProps.meta) == null ? void 0 : C.style) == null ? void 0 : b.opacity) !== 0) {
          const E = z.sourceProps.type, k = {
            ...defaultStyles[E],
            opacity: 0
          };
          CoreContext.Command.updateNode({
            nodeId: q,
            props: {
              ...z,
              sourceProps: {
                ...z.sourceProps,
                meta: {
                  style: {
                    ...k
                  }
                }
              }
            }
          });
        }
      }), ke ? await CoreContext.Command.updateNode({
        nodeId: ke == null ? void 0 : ke.id,
        props: {
          sourceType: "Overlay",
          id: pe,
          sourceProps: {
            ...be,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...be.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: $ == null ? void 0 : $.id,
        props: {
          sourceType: "Overlay",
          id: pe,
          sourceProps: {
            ...be,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...be.meta
            }
          }
        }
      });
    },
    async updateVideoOverlayProps(pe, be) {
      var _e, q;
      const ke = ((_e = $ == null ? void 0 : $.children) == null ? void 0 : _e.find((z) => {
        var C;
        return ((C = z == null ? void 0 : z.props) == null ? void 0 : C.id) === pe;
      })) || null;
      ke && await CoreContext.Command.updateNode({
        nodeId: ke == null ? void 0 : ke.id,
        props: {
          sourceType: "Overlay",
          id: pe,
          sourceProps: {
            ...(q = ke == null ? void 0 : ke.props) == null ? void 0 : q.sourceProps,
            ...be,
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...be.meta
            }
          }
        }
      });
    },
    async addCustomOverlay(pe, be) {
      const [ke, ..._e] = (I == null ? void 0 : I.children) || [];
      _e.forEach((z) => {
        CoreContext.Command.deleteNode({
          nodeId: z.id
        });
      });
      const q = {
        ...defaultStyles.custom,
        ...($ == null ? void 0 : $.children.length) && {
          opacity: 0
        }
      };
      ke ? await CoreContext.Command.updateNode({
        nodeId: ke == null ? void 0 : ke.id,
        props: {
          sourceType: "Overlay",
          id: pe,
          sourceProps: {
            ...be,
            type: "custom",
            meta: {
              style: {
                ...q
              }
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: I == null ? void 0 : I.id,
        props: {
          sourceType: "Overlay",
          id: pe,
          sourceProps: {
            ...be,
            type: "custom",
            meta: {
              style: {
                ...q
              }
            }
          }
        }
      });
    },
    async removeCustomOverlay() {
      var ke, _e;
      const [pe, ...be] = (I == null ? void 0 : I.children) || [];
      be.forEach((q) => {
        CoreContext.Command.deleteNode({
          nodeId: q.id
        });
      }), pe && ((_e = (ke = pe == null ? void 0 : pe.props) == null ? void 0 : ke.sourceProps) == null ? void 0 : _e.type) === "custom" && await CoreContext.Command.deleteNode({
        nodeId: pe.id
      });
    },
    async removeImageOverlay() {
      var ke, _e;
      const [pe, ...be] = (I == null ? void 0 : I.children) || [];
      be.forEach((q) => {
        CoreContext.Command.deleteNode({
          nodeId: q.id
        });
      }), pe && ((_e = (ke = pe == null ? void 0 : pe.props) == null ? void 0 : ke.sourceProps) == null ? void 0 : _e.type) === "image" && await CoreContext.Command.deleteNode({
        nodeId: pe.id
      });
    },
    async removeVideoOverlay() {
      const [pe, ...be] = ($ == null ? void 0 : $.children) || [];
      be.forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      }), pe && await CoreContext.Command.deleteNode({
        nodeId: pe.id
      }), I == null || I.children.forEach(({
        id: ke,
        props: _e
      }) => {
        var q, z;
        if (((z = (q = _e.sourceProps.meta) == null ? void 0 : q.style) == null ? void 0 : z.opacity) === 0) {
          const C = _e.sourceProps.type, b = {
            ...defaultStyles[C],
            opacity: 1
          };
          CoreContext.Command.updateNode({
            nodeId: ke,
            props: {
              ..._e,
              sourceProps: {
                ..._e.sourceProps,
                meta: {
                  style: {
                    ...b
                  }
                }
              }
            }
          });
        }
      });
    },
    setLayout(pe, be = {}) {
      const ke = p.props.layoutProps.showcase;
      l.setNodeLayout({
        nodeId: p.id,
        layout: pe,
        layoutProps: {
          showcase: ke,
          ...be
        }
      });
    },
    async setBackgroundImage(pe, be) {
      const [ke, ..._e] = (v == null ? void 0 : v.children) || [];
      _e.forEach((q) => {
        CoreContext.Command.deleteNode({
          nodeId: q.id
        });
      }), ke ? await CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          id: pe,
          sourceType: "Background",
          sourceProps: {
            ...be,
            type: "image",
            meta: {
              style: {
                ...defaultStyles.image
              },
              ...be == null ? void 0 : be.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: v == null ? void 0 : v.id,
        props: {
          id: pe,
          sourceType: "Background",
          sourceProps: {
            ...be,
            type: "image",
            meta: {
              style: {
                ...defaultStyles.image
              },
              ...be == null ? void 0 : be.meta
            }
          }
        }
      });
    },
    async setBackgroundVideo(pe, be) {
      const [ke, ..._e] = (v == null ? void 0 : v.children) || [];
      _e.forEach((q) => {
        CoreContext.Command.deleteNode({
          nodeId: q.id
        });
      }), ke ? await CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          id: pe,
          sourceType: "Background",
          sourceProps: {
            ...be,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...be == null ? void 0 : be.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: v == null ? void 0 : v.id,
        props: {
          id: pe,
          sourceType: "Background",
          sourceProps: {
            ...be,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...be == null ? void 0 : be.meta
            }
          }
        }
      });
    },
    async updateBackgroundVideoProps(pe, be) {
      var _e, q;
      const ke = ((_e = v == null ? void 0 : v.children) == null ? void 0 : _e.find((z) => {
        var C;
        return ((C = z == null ? void 0 : z.props) == null ? void 0 : C.id) === pe;
      })) || null;
      ke && await CoreContext.Command.updateNode({
        nodeId: ke == null ? void 0 : ke.id,
        props: {
          sourceType: "Background",
          id: pe,
          sourceProps: {
            ...(q = ke == null ? void 0 : ke.props) == null ? void 0 : q.sourceProps,
            ...be,
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...be.meta
            }
          }
        }
      });
    },
    async removeBackgroundImage() {
      const [pe, ...be] = (v == null ? void 0 : v.children) || [];
      be.forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      }), pe && pe.props.sourceProps.type === "image" && await CoreContext.Command.deleteNode({
        nodeId: pe.id
      });
    },
    async removeBackgroundVideo() {
      const [pe, ...be] = (v == null ? void 0 : v.children) || [];
      be.forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      }), pe && pe.props.sourceProps.type === "video" && await CoreContext.Command.deleteNode({
        nodeId: pe.id
      });
    },
    /* A function that takes in a sourceType and a callback function. It then creates a shallow copy of
      the root node and finds all the nodes that have the same sourceType as the one passed in. It then
      creates a listener for when the node changes, is added, or is removed. When any of these events
      happen, it will call the callback function with the new state. */
    useLayerState(pe, be) {
      const ke = cloneDeep$1(c);
      let _e = findAll(ke, (E) => E.props.sourceType === pe);
      const q = () => {
        be((_e == null ? void 0 : _e.map((E) => E.props)) || {});
      }, z = CoreContext.onInternal("NodeChanged", (E) => {
        const k = _e == null ? void 0 : _e.find((x) => x.id === E.nodeId);
        if (_e != null && _e.length && !k)
          return;
        const O = _e, A = cloneDeep$1(c);
        _e = findAll(A, (x) => {
          var Y;
          return ((Y = x == null ? void 0 : x.props) == null ? void 0 : Y.sourceType) === pe;
        }), deepEqual(O, _e) || q();
      }), C = CoreContext.onInternal("NodeAdded", (E) => {
        var x;
        if (_e == null ? void 0 : _e.find((Y) => Y.id === E.nodeId))
          return;
        const O = cloneDeep$1(c);
        _e = findAll(O, (Y) => {
          var B;
          return ((B = Y == null ? void 0 : Y.props) == null ? void 0 : B.sourceType) === pe;
        });
        const A = _e == null ? void 0 : _e.find((Y) => Y.id === E.nodeId);
        ((x = A == null ? void 0 : A.props) == null ? void 0 : x.sourceType) === pe && q();
      }), b = CoreContext.onInternal("NodeRemoved", (E) => {
        var O;
        const k = _e == null ? void 0 : _e.find((A) => A.id === E.nodeId);
        k && (_e = _e == null ? void 0 : _e.filter((A) => A.id !== E.nodeId), ((O = k == null ? void 0 : k.props) == null ? void 0 : O.sourceType) === pe && q());
      });
      return q(), () => {
        z(), C(), b();
      };
    },
    setShowcase(pe, be = "camera") {
      const ke = ie.getParticipantNode(pe, be);
      return CoreContext.Command.updateNode({
        nodeId: p.id,
        props: {
          layoutProps: {
            ...p.props.layoutProps,
            showcase: (ke == null ? void 0 : ke.id) ?? null
          }
        }
      });
    },
    useShowcase(pe) {
      const be = () => {
        const ke = p.props.layoutProps.showcase, _e = p.children.find((z) => z.id === ke);
        if (!_e)
          return pe({
            participantId: null,
            type: null
          });
        const {
          sourceProps: q
        } = _e.props;
        return pe({
          participantId: q.id,
          type: q.type
        });
      };
      return be(), CoreContext.onInternal("NodeChanged", (ke) => {
        ke.nodeId === p.id && be();
      });
    },
    getRTMPNode(pe) {
      return p.children.find((be) => {
        var ke, _e;
        return ((ke = be.props.sourceProps) == null ? void 0 : ke.id) === pe && ((_e = be.props.sourceProps) == null ? void 0 : _e.type) === "rtmp";
      });
    },
    useRTMPNodes(pe) {
      let be = [];
      const ke = () => {
        const z = p.children.filter((C) => {
          var b, E;
          return ((E = (b = C.props) == null ? void 0 : b.sourceProps) == null ? void 0 : E.type) === "rtmp";
        });
        return be = z.map((C) => C.id), pe(z);
      };
      ke();
      const _e = CoreContext.onInternal("NodeAdded", (z) => {
        var b, E;
        const C = a.scene.get(z.nodeId);
        ((E = (b = C == null ? void 0 : C.props) == null ? void 0 : b.sourceProps) == null ? void 0 : E.type) === "rtmp" && ke();
      }), q = CoreContext.onInternal("NodeRemoved", (z) => {
        be.indexOf(z.nodeId) !== -1 && ke();
      });
      return () => {
        _e(), q();
      };
    },
    async addRTMPSource(pe, be = {
      isMuted: !0,
      isHidden: !1,
      volume: 0
    }) {
      const ke = "rtmp";
      if (addingCache[ke].has(pe))
        return;
      const {
        isMuted: _e = !1,
        isHidden: q = !1,
        volume: z = 1
      } = be;
      if (p.children.find((E) => {
        var k, O;
        return ((k = E.props.sourceProps) == null ? void 0 : k.id) === pe && ((O = E.props.sourceProps) == null ? void 0 : O.type) === ke;
      }))
        return;
      addingCache[ke].add(pe), p.children[0];
      let b = p.children.length;
      await CoreContext.Command.createNode({
        props: {
          name: "RTMP",
          sourceType: "RTMP",
          sourceProps: {
            type: ke,
            id: pe
          },
          volume: z,
          isMuted: _e,
          isHidden: q
        },
        parentId: p.id,
        index: b
      }).finally(() => {
        addingCache[ke].delete(pe);
      });
    },
    removeRTMPSource(pe) {
      const be = "rtmp";
      p.children.filter((ke) => {
        var _e, q;
        return ((_e = ke.props.sourceProps) == null ? void 0 : _e.id) === pe && ((q = ke.props.sourceProps) == null ? void 0 : q.type) === be && ke.props.sourceType === "RTMP";
      }).forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      });
    },
    getGameSourceNode(pe) {
      return p.children.find((be) => {
        var ke, _e;
        return ((ke = be.props.sourceProps) == null ? void 0 : ke.id) === pe && ((_e = be.props.sourceProps) == null ? void 0 : _e.type) === "game";
      });
    },
    useGameSourceNodes(pe) {
      let be = [];
      const ke = () => {
        const z = p.children.filter((C) => {
          var b, E;
          return ((E = (b = C.props) == null ? void 0 : b.sourceProps) == null ? void 0 : E.type) === "game";
        });
        return be = z.map((C) => C.id), pe(z);
      };
      ke();
      const _e = CoreContext.onInternal("NodeAdded", (z) => {
        var b, E;
        const C = a.scene.get(z.nodeId);
        ((E = (b = C == null ? void 0 : C.props) == null ? void 0 : b.sourceProps) == null ? void 0 : E.type) === "game" && ke();
      }), q = CoreContext.onInternal("NodeRemoved", (z) => {
        be.indexOf(z.nodeId) !== -1 && ke();
      });
      return () => {
        _e(), q();
      };
    },
    async addGameSource(pe, be = {
      isMuted: !0,
      isHidden: !1,
      volume: 0
    }) {
      const ke = "game";
      if (addingCache[ke].has(pe))
        return;
      const {
        isMuted: _e = !1,
        isHidden: q = !1,
        volume: z = 1
      } = be;
      if (p.children.find((E) => {
        var k, O;
        return ((k = E.props.sourceProps) == null ? void 0 : k.id) === pe && ((O = E.props.sourceProps) == null ? void 0 : O.type) === ke;
      }))
        return;
      addingCache[ke].add(pe), p.children[0];
      let b = p.children.length;
      await CoreContext.Command.createNode({
        props: {
          name: "Game",
          sourceType: "Game",
          sourceProps: {
            type: ke,
            id: pe
          },
          volume: z,
          isMuted: _e,
          isHidden: q
        },
        parentId: p.id,
        index: b
      }).finally(() => {
        addingCache[ke].delete(pe);
      });
    },
    removeGameSource(pe) {
      const be = "game";
      p.children.filter((ke) => {
        var _e, q;
        return ((_e = ke.props.sourceProps) == null ? void 0 : _e.id) === pe && ((q = ke.props.sourceProps) == null ? void 0 : q.type) === be && ke.props.sourceType === "Game";
      }).forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      });
    },
    async addParticipantTrack(pe, be = {
      isMuted: !0,
      isHidden: !1,
      volume: 0
    }, ke = "camera") {
      if (addingCache[ke].has(pe))
        return;
      const {
        isMuted: _e = !1,
        isHidden: q = !1,
        volume: z = 1
      } = be;
      if (p.children.find((k) => {
        var O, A;
        return ((O = k.props.sourceProps) == null ? void 0 : O.id) === pe && ((A = k.props.sourceProps) == null ? void 0 : A.type) === ke;
      }))
        return;
      addingCache[ke].add(pe);
      const b = p.children[0];
      let E = p.children.length;
      ke === "screen" && (b == null ? void 0 : b.props.sourceProps.type) !== "screen" && (E = 0), await CoreContext.Command.createNode({
        props: {
          name: "Participant",
          sourceType: "RoomParticipant",
          sourceProps: {
            type: ke,
            id: pe
          },
          volume: z,
          isMuted: _e,
          isHidden: q
        },
        parentId: p.id,
        index: E
      }).finally(() => {
        addingCache[ke].delete(pe);
      });
    },
    removeParticipantTrack(pe, be = "camera") {
      p.children.filter((ke) => {
        var _e, q;
        return ((_e = ke.props.sourceProps) == null ? void 0 : _e.id) === pe && ((q = ke.props.sourceProps) == null ? void 0 : q.type) === be && ke.props.sourceType === "RoomParticipant";
      }).forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      });
    },
    async addParticipant(pe, be = {}, ke = "camera") {
      if (addingCache[ke].has(pe))
        return;
      const {
        isMuted: _e = !1,
        isHidden: q = !1,
        volume: z = 1
      } = be;
      if (p.children.find((k) => {
        var O, A;
        return ((O = k.props.sourceProps) == null ? void 0 : O.id) === pe && ((A = k.props.sourceProps) == null ? void 0 : A.type) === ke;
      }))
        return;
      addingCache[ke].add(pe);
      const b = p.children[0];
      let E = p.children.length;
      ke === "screen" && (b == null ? void 0 : b.props.sourceProps.type) !== "screen" && (E = 0), await CoreContext.Command.createNode({
        props: {
          name: "Participant",
          sourceType: "RoomParticipant",
          sourceProps: {
            type: ke,
            id: pe
          },
          volume: z,
          isMuted: _e,
          isHidden: q
        },
        parentId: p.id,
        index: E
      }).finally(() => {
        addingCache[ke].delete(pe);
      });
    },
    removeParticipant(pe, be = "camera") {
      p.children.filter((ke) => {
        var _e, q;
        return ((_e = ke.props.sourceProps) == null ? void 0 : _e.id) === pe && ((q = ke.props.sourceProps) == null ? void 0 : q.type) === be && ke.props.sourceType === "RoomParticipant";
      }).forEach((ke) => {
        CoreContext.Command.deleteNode({
          nodeId: ke.id
        });
      });
    },
    getParticipantNode(pe, be = "camera") {
      return p.children.find((ke) => {
        var _e, q;
        return ((_e = ke.props.sourceProps) == null ? void 0 : _e.id) === pe && ((q = ke.props.sourceProps) == null ? void 0 : q.type) === be;
      });
    },
    getParticipantState(pe, be = "camera") {
      var ke;
      return (ke = ie.getParticipantNode(pe, be)) == null ? void 0 : ke.props;
    },
    useParticipantState(pe, be, ke = "camera") {
      let _e = ie.getParticipantNode(pe, ke);
      const q = () => {
        be(_e == null ? void 0 : _e.props);
      }, z = CoreContext.onInternal("NodeChanged", (b) => {
        if (b.nodeId !== p.id)
          return;
        const E = _e;
        _e = ie.getParticipantNode(pe, ke), E !== _e && q();
      }), C = CoreContext.onInternal("NodeChanged", (b) => {
        !_e || b.nodeId !== _e.id || q();
      });
      return q(), () => {
        z(), C();
      };
    },
    setParticipantVolume(pe, be) {
      const ke = ie.getParticipantNode(pe);
      ke && CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          volume: be
        }
      });
    },
    setParticipantMuted(pe, be) {
      const ke = ie.getParticipantNode(pe);
      ke && CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          isMuted: be
        }
      });
    },
    setParticipantHidden(pe, be) {
      const ke = ie.getParticipantNode(pe);
      ke && CoreContext.Command.updateNode({
        nodeId: ke.id,
        props: {
          isHidden: be
        }
      });
    },
    pruneParticipants() {
      const pe = getProjectRoom(u);
      pe && p.children.filter((be) => {
        var b, E, k;
        if (be.props.sourceType !== "RoomParticipant")
          return !1;
        const ke = (b = be.props.sourceProps) == null ? void 0 : b.type, _e = pe.getParticipant((E = be.props.sourceProps) == null ? void 0 : E.id), q = pe.getTrack((k = be.props.sourceProps) == null ? void 0 : k.id);
        return !_e && !q ? !0 : ke === "camera" ? !1 : !_e.trackIds.map((O) => pe.getTrack(O)).filter(Boolean).some((O) => (O.type === Track.Source.Camera || O.type === Track.Source.Microphone ? "camera" : "screen") === ke);
      }).forEach((be) => {
        CoreContext.Command.deleteNode({
          nodeId: be.id
        });
      });
    },
    getProp(pe) {
      return getProject(a.id).props[pe];
    },
    setProp(pe, be) {
      return l.updateProjectProps({
        projectId: u,
        props: {
          [pe]: be
        }
      });
    },
    useProp(pe, be) {
      return CoreContext.on("ProjectChanged", (ke) => {
        u === ke.project.id && be(ke.project.props[pe]);
      });
    },
    createSource(pe) {
      return CoreContext.Command.createSource(pe);
    },
    deleteSource(pe) {
      return CoreContext.Command.deleteSource(pe);
    }
  };
  return (async () => {
    await j(), await ee(), await X();
  })(), ie;
}, create = async (a = {}, u = {}, c) => CoreContext.Command.createProject({
  settings: a,
  props: u,
  size: c
}), createCompositor = async (a, u, c) => {
  const {
    layout: l,
    layoutProps: v = {}
  } = c, p = await CoreContext.compositor.createProject({
    props: {
      name: "Root",
      type: "sceneless-project",
      sourceType: "Element",
      layout: "Layered",
      size: u,
      isRoot: !0,
      tagName: "div",
      version: "beta",
      fields: {
        style: {
          background: "black"
        }
      }
    }
  }, a), _ = p.getRoot(), I = await Promise.all([p.insert({
    name: "Background",
    id: "bg",
    layout: "Layered"
  }, _.id), p.insert({
    id: "content",
    name: "Content",
    layout: l,
    layoutProps: v
  }, _.id), p.insert({
    id: "foreground",
    name: "Overlays",
    layout: "Layered"
  }, _.id)]);
  await p.reorder(_.id, I);
  const P = _.children.find((H) => H.props.id === "foreground"), $ = ForegroundLayers.map((H) => p.insert(H, P.id)), F = await Promise.all($);
  return await p.reorder(P.id, F), p;
}, scenelessProject = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  commands,
  create,
  createCompositor
}, Symbol.toStringTag, { value: "Module" })), useActiveProjectRoom = (a) => {
  const u = getProject(CoreContext.state.activeProjectId);
  return a(u ? getRoom(u.roomId) : null), CoreContext.on("RoomJoined", () => {
    const c = getProject(CoreContext.state.activeProjectId);
    a(c ? getRoom(c.roomId) : null);
  });
}, callbacks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useActiveProjectRoom
}, Symbol.toStringTag, { value: "Module" })), index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Callback: callbacks,
  React: react,
  Room: webrtc,
  ScenelessProject: scenelessProject
}, Symbol.toStringTag, { value: "Module" })), runFilters = (a, u = []) => u.reduce((c, l) => l(c), a), transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  runFilters
}, Symbol.toStringTag, { value: "Module" })), createDefault = () => ({
  root: document.createElement("div")
}), init$2 = (a = {}, u, c) => {
  const l = {}, v = a.defaultTransforms || {}, p = (Q) => {
    asArray(Q).forEach((ne) => {
      l[ne.name] = ne;
    });
  }, _ = {}, I = {}, P = {}, $ = (Q) => P[Q] || [], F = (Q) => I[Q] || [], H = (Q) => _[Q], j = (Q) => l[Q];
  u.on("SourceChanged", (Q) => {
    F(Q.id).forEach((Z) => {
      const de = u.getNode(Z.nodeId);
      Z._onUpdateHandlers.forEach((he) => he(de.props || {}));
    });
  }), u.on("AvailableSourcesChanged", ({
    type: Q,
    sources: ne
  }) => {
    $(Q).forEach((de) => {
      ee(de.nodeId);
    });
  });
  const ee = (Q) => {
    var q, z, C;
    const ne = H(Q);
    if (!ne)
      return;
    const Z = j(ne.transformName);
    if (!Z.useSource)
      return;
    const de = u.getNode(Q), he = ne.sourceType, pe = c.getSources(he), be = Z.useSource(pe, de.props), ke = ne.sourceValue, _e = be == null ? void 0 : be.value;
    ne.source !== be && (I[(q = ne.source) == null ? void 0 : q.id] && (I[(z = ne.source) == null ? void 0 : z.id] = I[(C = ne.source) == null ? void 0 : C.id].filter((b) => b.nodeId !== Q)), I[be == null ? void 0 : be.id] = [...I[be == null ? void 0 : be.id] || [], ne]), ne.source = be, ne.sourceValue = _e, Object.is(ke, _e) || ne._onNewSourceHandlers.forEach((b) => b(be));
  }, X = (Q) => {
    const ne = ie(Q), de = runFilters(Q, []);
    return ee(Q.id), ne == null || ne._onUpdateHandlers.forEach((he) => he(Q.props || {})), {
      ...de,
      children: de.children.map(X)
    };
  }, ie = (Q) => {
    if (_[Q.id])
      return _[Q.id];
    const {
      props: ne = {}
    } = Q, {
      sourceType: Z
    } = ne;
    if (!Z)
      return null;
    let de = v[Z], he;
    if (de ? he = l[de] : he = Object.values(l).find((E) => E.sourceType === Z), !he)
      throw new Error("Could not find matching transform for sourceType: " + Z);
    const pe = [], be = [], ke = [], _e = [], z = {
      ...(he.create || createDefault)({
        onEvent: (E, k, ...O) => {
          const A = u.on(E, k, ...O);
          return _e.push(A), A;
        },
        onNewSource: (E) => pe.push(E),
        onUpdate: (E) => be.push(E),
        onRemove: (E) => ke.push(E)
      }, Q.props),
      sourceType: Z,
      nodeId: Q.id,
      transformName: he.name,
      _onNewSourceHandlers: pe,
      _onUpdateHandlers: be,
      _disposables: _e
    };
    _[Q.id] = z;
    const C = Z;
    P[C] = [...P[C] || [], z], he.useSource && ee(Q.id);
    const b = [
      // Dispose when node is removed
      u.on("NodeRemoved", ({
        nodeId: E
      }) => {
        if (E === Q.id) {
          const k = u.getNode(E), {
            sourceType: O = "Element"
          } = k.props;
          b.forEach((x) => x == null ? void 0 : x()), _e.forEach((x) => x == null ? void 0 : x()), ke.forEach((x) => x == null ? void 0 : x()), delete _[k.id];
          const A = O;
          P[A] = P[A].filter((x) => x !== _[k.id]);
        }
      })
    ];
    return z;
  };
  return {
    transforms: l,
    nodeElementIndex: _,
    elementSourceTypeIndex: P,
    registerTransform: p,
    getElementsBySourceType: $,
    getElementByNodeId: H,
    getTransformByName: j,
    updateSourceForNode: ee,
    renderTree: X,
    getElement: ie
  };
}, TRANSITION_DURATION = 300, findLayoutUp = (a, u, c = 0) => {
  const v = a.parentElement;
  return v instanceof Layout && (c = 0, !u || u(v)) ? v : v ? c > 4 ? null : findLayoutUp(v, u, c + 1) : null;
}, TRANSITION_FIELDS = "opacity, transform, width, height, left, right, top, bottom, inset", layoutIndex = {}, parentIdIndex = {}, childIndex = {};
let rootLayout, _cid = 1;
const ignoredAttributes = ["style", "id", "className"];
let tickOps = {};
const tick = () => {
  if (nextTick = null, window.__dragging) {
    nextTick = nextTick || requestAnimationFrame(tick);
    return;
  }
  const a = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  Object.entries(tickOps).forEach(([l, v]) => {
    v.forEach(([p, _, I]) => {
      switch (p) {
        case "childInserted": {
          u.has(I) ? u.delete(I) : a.add(I);
          break;
        }
        case "childRemoved": {
          a.has(I) ? a.delete(I) : u.add(I);
          break;
        }
        case "childRemoveFinished": {
          c.add(I);
          break;
        }
      }
    });
  });
  try {
    u.forEach((v) => {
      var I, P, $;
      const p = childIndex[v], _ = Array.from(((I = p.parentEl) == null ? void 0 : I.children) || []);
      p.nextSiblingEl && _.includes(p.nextSiblingEl) ? (P = p.parentEl) == null || P.insertBefore(p, p.nextSiblingEl) : (p.nextSiblingEl = null, ($ = p.parentEl) == null || $.append(p)), p.runRemove();
    }), c.forEach((v) => {
      const p = childIndex[v];
      if (p.removed) {
        p.previousSiblingEl && (p.previousSiblingEl.nextSiblingEl = p.nextSiblingEl), p.nextSiblingEl && (p.nextSiblingEl.previousSiblingEl = p.previousSiblingEl);
        return;
      }
    });
    const l = window.__scale;
    Object.entries(tickOps).forEach(([v, p]) => {
      const _ = layoutIndex[v], I = _.getBoundingClientRect(), P = {
        x: I.width / l,
        y: I.height / l
      };
      _.updatePositions({
        size: P,
        inserted: a,
        removed: u
      });
    });
  } catch (l) {
    log.warn("Failed to run Layout ops", l);
  }
  tickOps = {};
};
let nextTick;
const queueOp = (a) => {
  const [u, c] = a, l = tickOps[c] || [];
  tickOps[c] = [...l, a], nextTick = nextTick || requestAnimationFrame(tick);
};
class Layout extends HTMLElement {
  constructor() {
    super();
    qt(this, "parentEl");
    qt(this, "slotEl");
    qt(this, "parentLayout");
    qt(this, "nodes");
    qt(this, "mutationObserver");
    qt(this, "latestSize");
    qt(this, "isFirst", !0);
    qt(this, "isUpdating", !1);
    qt(this, "cid");
    this.cid = ++_cid;
  }
  log(...c) {
    var l;
    log.debug(...c, {
      id: this.dataset.id,
      parent: (l = this.parentLayout) == null ? void 0 : l.dataset.id
    }, this);
  }
  connectedCallback() {
    var c;
    this.parentEl = this.parentElement, this.parentLayout = findLayoutUp(this), this.slotEl = this.closest("[data-layout-child]"), Array.from(this.children).forEach((l) => this.initializeChild(l)), rootLayout || (rootLayout = this), layoutIndex[this.dataset.id] = this, parentIdIndex[this.dataset.id] = (c = this.parentLayout) == null ? void 0 : c.id, Object.assign(this.style, {
      width: "100%",
      height: "100%",
      position: "absolute",
      top: "0px",
      left: "0px",
      pointerEvents: "none",
      boxSizing: "border-box"
    }), this.mutationObserver && this.mutationObserver.disconnect(), this.mutationObserver = new MutationObserver((l) => {
      this.isConnected && l.forEach((v) => {
        v.type === "attributes" && !ignoredAttributes.includes(v.attributeName) ? queueOp(["attributesChanged", this.dataset.id]) : v.type === "childList" && (v.addedNodes.forEach((p) => {
          const _ = childIndex[p.dataset.id];
          p.removed || (_ ? _ !== p && (this.initializeChild(p), p.setAttribute("style", _.getAttribute("style")), p.data = _.data) : this.initializeChild(p), queueOp(["childInserted", this.dataset.id, p.dataset.id]));
        }), v.removedNodes.forEach((p) => {
          p.removed || queueOp(["childRemoved", this.dataset.id, p.dataset.id]);
        }));
      });
    }), this.mutationObserver.observe(this, {
      childList: !0,
      attributes: !0
    }), this.latestSize || queueOp(["attributesChanged", this.dataset.id]);
  }
  disconnectedCallback() {
  }
  adoptedCallback() {
  }
  updatePositions(c) {
    if (this.isUpdating)
      return;
    this.isUpdating = !0;
    const {
      size: l,
      inserted: v = /* @__PURE__ */ new Set(),
      removed: p = /* @__PURE__ */ new Set()
    } = c;
    this.nodes = Array.from(this.children || []).filter(($) => !$.removed).map(($, F) => {
      const H = getElementAttributes($);
      return {
        // TODO: Does this work well enough? Think through keying
        id: $.dataset.id,
        props: H,
        children: []
      };
    });
    const _ = JSON.parse(this.getAttribute("props") || "{}");
    this.latestSize = l;
    const I = {
      id: this.dataset.id,
      props: _,
      children: this.nodes,
      size: l
    };
    let P = layoutChildren(I);
    Promise.all(Object.entries(P).map(async ([$, F]) => {
      var he, pe, be, ke;
      let H = childIndex[$] || this.querySelector(`[data-layout-child][data-id="${$}"]`);
      const j = {
        ...H.data,
        ...F
      };
      H.data = j;
      const {
        size: ee,
        position: X,
        zIndex: ie = 1,
        opacity: Q = 1,
        borderRadius: ne = 0,
        entryTransition: Z = {},
        exitTransition: de = {}
      } = j;
      if (H) {
        if (H.removed)
          return;
        de && (H.data.exitTransition = de), Z && (H.data.entryTransition = Z), H.data.size = ee, H.data.position = X;
        const _e = window.__scale, q = this.getBoundingClientRect(), z = q.width / _e, C = z - sizeToNum(X.x, z) - sizeToNum(ee.x, z), b = q.height / _e, E = b - sizeToNum(X.y, b) - sizeToNum(ee.y, b);
        Object.assign(H.style, {
          position: "absolute",
          transformOrigin: "50% 50%",
          transitionDuration: "0ms",
          transitionDelay: "0ms",
          transform: "translate3d(0, 0, 0) scaleX(1) scaleY(1)",
          visibility: "visible",
          boxSizing: "border-box",
          overflow: "hidden",
          borderRadius: ne + "px",
          width: "auto",
          height: "auto"
        });
        let k = "0ms", O = this.isFirst ? asDuration(0) : asDuration(TRANSITION_DURATION);
        if (v.has($))
          Object.assign(H.style, {
            transitionProperty: TRANSITION_FIELDS,
            transitionDuration: "0ms",
            transitionTimingFunction: Z.timingFn ?? "ease",
            transform: `translate3d(calc(${asSize(((he = Z.offset) == null ? void 0 : he.x) ?? 0)}), calc(${asSize(((pe = Z.offset) == null ? void 0 : pe.y) ?? 0)}), 0) scaleX(${((be = Z.scale) == null ? void 0 : be.x) ?? 1}) scaleY(${((ke = Z.scale) == null ? void 0 : ke.y) ?? 1})`,
            opacity: Z.opacity ?? Q,
            left: asSize(X.x) || 0,
            right: asSize(C) || 0,
            top: asSize(X.y) || 0,
            bottom: asSize(E) || 0
          }), k = asDuration(Z.delay ?? 0);
        else if (H.data.rootOffset) {
          const Y = rootLayout.getBoundingClientRect(), B = this.getBoundingClientRect(), T = {
            x: B.x / _e - Y.x / _e,
            y: B.y / _e - Y.y / _e
          }, D = T.x + B.width / _e, te = H.data.rootOffset.x + Number(H.data.size.x), me = T.y + B.height / _e, Ie = H.data.rootOffset.y + Number(H.data.size.y);
          H.data.rootOffset.x - T.x, H.data.rootOffset.y - T.y, D - te, me - Ie;
        }
        H.addEventListener("transitionstart", () => {
          H.style.zIndex = String(ie + 1);
        }), await new Promise((Y) => window.setTimeout(Y)), Object.assign(H.style, {
          transitionProperty: TRANSITION_FIELDS,
          transitionDuration: O,
          transitionDelay: k,
          transform: "translate3d(0, 0, 0) scaleX(1) scaleY(1)",
          opacity: Q,
          left: asSize(X.x) || 0,
          top: asSize(X.y) || 0,
          width: z ? "auto" : ee.x,
          right: z ? asSize(C) || 0 : "auto",
          height: b ? "auto" : ee.y,
          bottom: b ? asSize(E) || 0 : "auto",
          zIndex: ie
        });
        const x = () => {
          const Y = rootLayout.getBoundingClientRect(), B = H.getBoundingClientRect();
          H.data.rootOffset = {
            x: B.x / _e - Y.x / _e,
            y: B.y / _e - Y.y / _e
          };
        };
        x(), H.addEventListener("transitionend", () => {
          H.style.zIndex = String(ie), x();
        });
      }
    })).then(() => {
      this.isUpdating = !1;
    }), this.isFirst = !1, Array.from(this.querySelectorAll("ls-layout")).forEach(($) => {
      if (!P[$.dataset.id])
        return;
      const F = P[$.dataset.id].size;
      $.updatePositions({
        size: {
          x: sizeToNum(F.x, l.x),
          y: sizeToNum(F.y, l.y)
        }
      });
    });
  }
  initializeChild(c) {
    var v;
    if (!((v = c.dataset) != null && v.id))
      return log.warn("Layout: Child requires `data-id` at the time it is added to a Layout");
    c._remove = c.remove, c.remove = () => {
      this.removeChild(c);
    }, c.mutationObserver || (c.mutationObserver = new MutationObserver((p) => {
      p.forEach((_) => {
        if (_.type === "attributes") {
          if (_.attributeName === "style")
            return;
          queueOp(["childAttributesChanged", this.dataset.id, c.dataset.id]);
        }
      });
    }), c.mutationObserver.observe(c, {
      childList: !0,
      attributes: !0
    }));
    const l = {
      entryTransition: {
        delay: 0,
        opacity: 0,
        scale: {
          x: 1,
          y: 1
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      exitTransition: {
        delay: 0,
        opacity: 0,
        scale: {
          x: 1,
          y: 1
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      position: {
        x: 0,
        y: 0
      },
      size: {
        x: 0,
        y: 0
      },
      opacity: 0,
      fit: "cover",
      borderRadius: 0,
      zIndex: 1
    };
    c.data = l, c.parentEl = c.parentElement, c.nextSiblingEl = c.nextSibling, c.previousSiblingEl = c.previousSibling, c.previousSiblingEl && (c.previousSiblingEl.nextSiblingEl = c), c.toggleAttribute("data-layout-child", !0), childIndex[c.dataset.id] = c, c.runRemove = async () => {
      var _, I, P, $;
      c.removed = !0;
      const p = TRANSITION_DURATION;
      return await new Promise((F) => window.setTimeout(F)), Object.assign(c.style, {
        zIndex: 0,
        transitionDelay: asDuration(0),
        transitionDuration: asDuration(p),
        transitionProperty: TRANSITION_FIELDS,
        transitionTimingFunction: l.exitTransition.timingFn ?? "ease",
        transform: `translate3d(calc(${asSize(((_ = l.exitTransition.offset) == null ? void 0 : _.x) ?? 0)}), calc( ${asSize(((I = l.exitTransition.offset) == null ? void 0 : I.y) ?? 0)}), 0) scaleX(${((P = l.exitTransition.scale) == null ? void 0 : P.x) ?? 1}) scaleY(${(($ = l.exitTransition.scale) == null ? void 0 : $.y) ?? 1})`,
        opacity: l.exitTransition.opacity ?? 0
      }), c.removed = !0, c.transition = new Promise((F) => {
        const H = () => {
          c.transition = null, c._remove(), queueOp(["childRemoveFinished", this.dataset.id, c.dataset.id]), clearTimeout(j), F();
        }, j = window.setTimeout(H, parseInt(String(p)) + 600);
        c.addEventListener("transitionend", H, {
          once: !0
        });
      }), c.transition;
    };
  }
}
const ensureLayoutContainer = (a) => {
  const u = document.getElementById("__ls-layout-container");
  if (u)
    return Object.assign(u.style, {
      width: a.x + "px",
      height: a.y + "px"
    }), u;
  const c = document.createElement("div");
  return c.id = "__ls-layout-container", Object.assign(c.style, {
    position: "fixed",
    // pointerEvents: 'none',
    visibility: "hidden",
    top: "0px",
    left: "0px",
    zIndex: -1,
    width: a.x + "px",
    height: a.y + "px"
  }), document.body.append(c), c;
}, layoutChildren = ({
  id: a,
  props: u = {},
  children: c,
  size: l
}) => {
  const v = {
    props: u,
    children: c,
    size: l
  }, p = htmlLayouts[u.layout] ? htmlLayouts[u.layout].layout(v) : htmlLayouts.Free.layout(v);
  if (!(p instanceof HTMLElement))
    return p;
  const _ = Array.from(p.querySelectorAll("[data-node-id]")), I = document.createElement("div");
  I.style.height = p.style.height = l.y + "px", I.style.width = p.style.width = l.x + "px", I.style.position = "absolute", I.style.top = "0px", I.style.left = "0px", I.style.boxSizing = "border-box", I.setAttribute("data-wrapper-id", a), I.append(p);
  const P = ensureLayoutContainer(l), $ = P.querySelector(`[data-wrapper-id="${a}"]`);
  $ ? $.replaceWith(I) : P.append(I);
  const F = p.getBoundingClientRect(), H = {};
  return _.forEach((j) => {
    var ne, Z, de, he;
    const ee = j.dataset.nodeId;
    if (!ee)
      return;
    const X = Number(j.dataset.opacity ?? (j.style.opacity || 1)), ie = j.getBoundingClientRect();
    let Q = {
      position: {
        x: ie.x - F.x + "px",
        y: ie.y - F.y + "px"
      },
      size: {
        x: ie.width + "px",
        y: ie.height + "px"
      },
      opacity: X,
      zIndex: (ne = j.data) == null ? void 0 : ne.zIndex,
      entryTransition: ((Z = j.data) == null ? void 0 : Z.entryTransition) ?? {},
      exitTransition: ((de = j.data) == null ? void 0 : de.exitTransition) ?? {},
      borderRadius: ((he = j.data) == null ? void 0 : he.borderRadius) ?? 0
    };
    `${u.showcase}-x` === ee && (Q.position = {
      x: F.x + "px",
      y: F.y + "px"
    }, Q.size = {
      x: F.width + "px",
      y: F.height + "px"
    }, Q.zIndex = 10), H[ee] = Q, positionIndex[j.dataset.nodeId] = Q;
  }), H;
}, positionIndex = {}, htmlLayouts = {}, registerLayout = (a) => {
  asArray(a).forEach((u) => {
    htmlLayouts[u.name] = u;
  });
}, sourceTypes = {}, init$1 = (a = {}, u) => {
  const c = {}, l = {}, v = (P) => {
    u.triggerEvent("SourceChanged", P);
  }, p = (P) => {
    u.triggerEvent("AvailableSourcesChanged", {
      type: P,
      sources: l[P]
    });
  }, I = {
    sourceIndex: c,
    sourceTypeIndex: l,
    registerSource: (P) => {
      asArray(P).forEach(($) => {
        var H;
        const F = (j) => {
          const ee = c[j];
          if (ee && ee.type !== $.type)
            throw new Error(`Attempted to modify source of type ${ee.type} from ${$.type}`);
        };
        (H = $.init) == null || H.call($, {
          getSource: (j) => I.getSource(j),
          removeSource: (j) => (F(j), I.removeSource(j)),
          setSourceActive: (j, ee) => (F(j), I.setSourceActive(j, ee)),
          updateSource: (j, ee) => (F(j), I.updateSource(j, ee)),
          modifySourceValue(j, ee) {
            return F(j), I.modifySourceValue(j, ee);
          },
          addSource: (j) => I.addSource($.type, j)
        }), sourceTypes[$.type] = $;
      });
    },
    getSource: (P) => c[P],
    getSources: (P) => l[P] || [],
    useSource: (P, $) => ($(c[P]), u.on("SourceChanged", (F) => {
      F.id === P && $(F);
    })),
    useSources: (P, $) => ($(l[P] || []), u.on("AvailableSourcesChanged", (F) => {
      F.type === P && $(F.sources);
    })),
    addSource: (P, $) => {
      if (!$.id)
        throw new Error('Cannot add source without field "id"');
      if (c[$.id])
        return;
      if (!$.value)
        throw new Error('Cannot add source with an empty field "value"');
      if (!sourceTypes[P])
        throw new Error("Could not find definition for source type: " + P);
      const {
        id: H,
        value: j = null,
        props: ee = {},
        isActive: X = !0
      } = $;
      c[H] = {
        id: H,
        type: P,
        props: ee,
        value: j,
        isActive: X
      }, l[P] = [...l[P] || [], c[H]], v(c[H]), p(P);
    },
    removeSource: (P) => {
      const $ = c[P];
      $ && (delete c[P], l[$.type] = l[$.type].filter((F) => F.id !== P), p($.type));
    },
    updateSource: (P, $) => {
      const F = c[P];
      F.props = {
        ...F.props,
        ...$
      }, v(F), p(F.type);
    },
    /**
     * Imperatively update a Source's value.
     * Triggers an event to inform elements to re-render.
     */
    modifySourceValue: async (P, $) => {
      const F = c[P];
      await $(F.value), v(F);
    },
    setSourceActive: (P, $ = !0) => {
      const F = c[P];
      F.isActive = $, p(F.type);
    }
  };
  return I;
}, sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  init: init$1,
  sourceTypes
}, Symbol.toStringTag, { value: "Module" })), layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), {
  forEachDown,
  insertAt,
  toDataNode,
  pull,
  replaceItem
} = Logic;
let compositor;
const start = (a) => {
  if (compositor)
    return compositor;
  const {
    dbAdapter: u,
    transformSettings: c = {},
    sourceSettings: l = {}
  } = a, v = {}, p = {};
  try {
    customElements.define("ls-layout", Layout);
  } catch (ne) {
    log.warn(ne);
  }
  const _ = {}, I = {}, P = {};
  let $ = 0;
  const F = /* @__PURE__ */ new Map(), H = (ne, Z) => {
    if (typeof ne != "function")
      return;
    const de = ++$;
    return F.set(de, ne), ne.nodeId = Z, () => {
      F.delete(de);
    };
  }, j = (ne, Z, de) => H((he, pe) => {
    he === ne && Z(pe);
  }, de), ee = (ne, Z) => {
    F.forEach((de) => {
      de.nodeId ? Z != null && Z.nodeId && (Z == null ? void 0 : Z.nodeId) === de.nodeId && de(ne, Z) : de(ne, Z);
    });
  }, X = {
    projects: p,
    subscribe: H,
    on: j,
    triggerEvent: ee,
    getProject: (ne) => p[ne],
    getNodeProject: (ne) => p[_[ne]],
    getNodeParent: (ne) => P[I[ne]],
    getNode: (ne) => P[ne],
    createProject: async (ne = {}, Z) => {
      const {
        id: de,
        props: he = {},
        children: pe = []
      } = ne, be = await u(Z, {
        get: () => null,
        getParent: () => null
      }).insert(he), ke = {
        id: be,
        props: he,
        children: pe
      };
      return forEachDown(ne, (_e) => {
      }), P[be] = ke, compositor.loadProject(ke, Z);
    },
    loadProject: (ne, Z) => {
      if (!ne)
        return;
      if (Z = Z || ne.id, p[Z])
        return p[Z];
      forEachDown(ne, (be, ke) => {
        P[be.id] = be, I[be.id] = ke == null ? void 0 : ke.id, _[be.id] = Z;
      });
      const de = {
        insert: async (be, ke, _e = 0) => {
          if (be.id && P[be.id])
            return P[be.id];
          if (be.children || (be.children = []), be.props || (be.props = {}), ke) {
            const q = P[ke];
            if (!q)
              throw "Parent node not found with ID";
            q.children = insertAt(_e, be, q.children || []), I[be.id] = ke;
          }
          return P[be.id] = be, _[be.id] = Z, be.id;
        },
        update: async (be, ke = {}, _e) => {
          const q = P[be];
          if (_e) {
            const z = _e.map((C) => {
              const b = P[C];
              return I[b.id] = be, b;
            });
            q.children = z;
          }
          q.props = {
            ...q.props,
            ...ke
          };
        },
        remove: async (be) => {
          const ke = P[I[be]];
          ke && (ke.children = ke.children.filter((q) => q.id !== be));
          const _e = P[be];
          forEachDown(_e, (q) => {
            P[q.id] && (P[q.id]._deleted = !0), ee("NodeRemoved", {
              projectId: he.id,
              nodeId: q.id
            });
          });
        }
      }, he = {
        id: Z,
        getRoot: () => ne,
        get(be) {
          return P[be];
        },
        getParent(be) {
          return P[I[be]];
        },
        renderTree() {
          return Q.renderTree(ne);
        },
        local: de,
        insert: async (be = {}, ke, _e = 0) => {
          const z = {
            id: await pe.insert(be, ke, _e),
            props: be,
            children: []
          };
          return de.insert(z, ke, _e);
        },
        update: async (be, ke) => (await de.update(be, ke), pe.update(be, ke)),
        remove: async (be) => {
          await de.remove(be);
          const ke = P[I[be]], _e = ke.children.filter((q) => q.id !== be);
          return pe.batch([["delete", {
            id: be
          }], ["update", {
            ...ke,
            children: _e
          }]]);
        },
        reorder: async (be, ke) => {
          const _e = P[be];
          return _e.children = ke.map((q) => _e.children.find((z) => z.id === q)), pe.batch([["update", _e]]);
        },
        move: async (be, ke, _e = 0) => {
          const q = P[be], z = P[I[be]], C = P[ke];
          z.children = pull(z.children, q), C.children = insertAt(_e, q, C.children), pe.batch([["update", C], ["update", z]]), I[be] = ke;
        },
        swap: async (be, ke) => {
          const _e = P[be], q = P[ke], z = P[I[be]], C = P[I[ke]];
          z.children = replaceItem((b) => b.id === be, q, z.children), C.children = replaceItem((b) => b.id === ke, _e, C.children), I[be] = C.id, I[ke] = z.id, pe.batch([["update", z], ["update", C]]);
        }
      };
      Object.defineProperty(he, "nodes", {
        get() {
          return Object.values(P).filter((be) => _[be.id] === he.id);
        }
      });
      const pe = v[Z] || u(Z, {
        get: (be) => toDataNode(he.get(be)),
        getParent: (be) => toDataNode(he.getParent(be))
      });
      return v[Z] = pe, p[Z] = he, he;
    }
  }, ie = init$1(l, X), Q = init$2(c, X, ie);
  return compositor = {
    registerLayout,
    registerTransform: Q.registerTransform,
    registerSource: ie.registerSource,
    getElement: Q.getElement,
    getSource: ie.getSource,
    getSources: ie.getSources,
    useSource: ie.useSource,
    useSources: ie.useSources,
    ...X
  }, compositor;
}, index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Layout: layouts,
  Source: sources,
  Transform: transforms,
  start
}, Symbol.toStringTag, { value: "Module" })), createProject = async (a) => {
  const u = getUser().id, c = a.type || "sceneless", l = a.size || {
    x: 1280,
    y: 720
  }, v = a.settings || {};
  let p = await CoreContext.clients.LiveApi().project.createProject({
    collectionId: u,
    rendering: {
      video: {
        width: l.x,
        height: l.y,
        framerate: 30
      }
    },
    composition: {
      studioSdk: {
        version: CoreContext.rendererVersion
      }
    },
    metadata: {},
    webrtc: {
      hosted: {}
    }
  });
  const _ = await createLayout({
    projectId: p.project.projectId,
    collectionId: p.project.collectionId,
    settings: v,
    size: l,
    type: c
  }), {
    displayName: I
  } = getAccessTokenData(), P = {
    type: c,
    layoutId: _.id,
    hostDisplayName: I,
    props: a.props || {}
  };
  let $ = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: u,
    projectId: p.project.projectId,
    updateMask: ["metadata"],
    metadata: P
  });
  return p.project = $.project, p.project.metadata = P, p;
}, deleteProject = async (a) => {
  const {
    projectId: u
  } = a, c = getProject(u), l = getUser().id;
  await Promise.all([CoreContext.clients.LiveApi().project.deleteProject({
    collectionId: l,
    projectId: u
  }), CoreContext.clients.LayoutApi().layout.deleteLayout({
    layoutId: c.layoutApi.layoutId
  })]);
}, loadUser = async (a) => {
  var _;
  const u = await loadCollections();
  let c;
  const {
    displayName: l,
    serviceUserId: v
  } = getAccessTokenData();
  u.length === 0 ? c = (await CoreContext.clients.LiveApi().collection.createCollection({
    metadata: {
      serviceUserId: v,
      displayName: l,
      props: {}
    }
  })).collection : c = u[0], await CoreContext.clients.LiveApi().subscribeToCollection(c.collectionId);
  const p = await Promise.all(c.projects.filter((I) => {
    var P;
    return !!((P = I.metadata) != null && P.layoutId);
  }).map((I) => hydrateProject(I, "ROLE_HOST", a)));
  return {
    user: {
      id: c.collectionId,
      metadata: c.metadata,
      props: ((_ = c.metadata) == null ? void 0 : _.props) || {},
      name: l
    },
    projects: p,
    sources: c.sources
  };
}, loadCollections = async () => (await CoreContext.clients.LiveApi().collection.getCollections({})).collections, createLayout = async (a) => {
  const {
    settings: u,
    size: c,
    type: l,
    projectId: v,
    collectionId: p
  } = a, _ = await CoreContext.clients.LayoutApi().layout.createLayout({
    layout: {
      projectId: v,
      collectionId: p
    }
  });
  return l === "sceneless" ? await createCompositor(_.id, c, u) : await CoreContext.compositor.createProject({
    props: {
      name: "Root",
      layout: "Free",
      ...u,
      isRoot: !0,
      size: c
    }
  }, _.id), _;
}, requests = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayout,
  createProject,
  deleteProject,
  loadCollections,
  loadUser
}, Symbol.toStringTag, { value: "Module" })), RTMP = {
  type: "RTMP",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l
  }) {
    let v = {}, p = [], _ = [];
    const I = (P) => {
      const $ = P.filter((H) => !_.some((j) => j.id === H.id)), F = _.filter((H) => !P.some((j) => j.id === H.id));
      _ = P, $.forEach(async (H) => {
        const j = new MediaStream([]);
        v[H.id] = j;
        const ee = j.getVideoTracks();
        a({
          id: `rtmp-${H.id}`,
          isActive: !0,
          value: j,
          props: {
            id: H.id,
            isMuted: !1,
            participantId: H.id,
            type: "rtmp",
            videoEnabled: !!ee.length,
            audioEnabled: !0
          }
        });
      }), F.forEach((H) => {
        u(`rtmp-${H.id}`);
      });
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId: P
    }) => {
      const $ = toBaseProject(getProject(P));
      I($.sources.filter((F) => F.props.type !== "integration"));
    }), CoreContext.on("RoomJoined", ({
      projectId: P,
      room: $
    }) => {
      if (toBaseProject(getProject(P)).role !== Role.ROLE_RENDERER) {
        const H = () => {
          p.filter((j) => (j == null ? void 0 : j.type) === "screen_share" && (j == null ? void 0 : j.isExternal) === !0).forEach((j) => {
            var ee;
            if (j.type === "screen_share") {
              const X = v[j.participantId], ie = $.getParticipant(j.participantId);
              if (_.some((Q) => Q.id === ie.id)) {
                const Q = $.getTrack(j.id);
                if (l(`rtmp-${ie == null ? void 0 : ie.id}`)) {
                  const Z = $.getTracks().find((de) => de.participantId === ie.id && de.mediaStreamTrack.kind === "audio");
                  updateMediaStreamTracks(X, {
                    video: Q == null ? void 0 : Q.mediaStreamTrack,
                    audio: Z == null ? void 0 : Z.mediaStreamTrack
                  }), c(`rtmp-${ie == null ? void 0 : ie.id}`, {
                    videoEnabled: !!(Q != null && Q.mediaStreamTrack && !Q.isMuted),
                    audioEnabled: !!(Z && !Z.isMuted),
                    mirrored: (ee = ie == null ? void 0 : ie.meta[j.id]) == null ? void 0 : ee.isMirrored,
                    external: j == null ? void 0 : j.isExternal
                  });
                }
              }
            }
          });
        };
        $.useTracks((j) => {
          const ee = j.filter((Q) => _.some((ne) => ne.id === Q.participantId)).filter((Q) => ["screen_share"].includes(Q.type)), X = ee.filter((Q) => !p.some((ne) => ne.id === Q.id) && !!(Q != null && Q.mediaStreamTrack)), ie = p.filter((Q) => !ee.some((ne) => ne.id === Q.id));
          p = ee.filter((Q) => !!(Q != null && Q.mediaStreamTrack)), ie.forEach((Q) => {
            const ne = v[Q.participantId];
            Q.mediaStreamTrack.kind === "video" && (updateMediaStreamTracks(ne, {
              video: null
            }), c(`rtmp-${Q.participantId}`, {
              videoEnabled: !1
            })), Q.mediaStreamTrack.kind === "audio" && (updateMediaStreamTracks(ne, {
              audio: null
            }), c(`rtmp-${Q.participantId}`, {
              audioEnabled: !1
            }));
          }), X.forEach((Q) => {
            if (Q.type === "screen_share" && Q.mediaStreamTrack.kind === "video") {
              const ne = v[Q.participantId], Z = p.find((de) => {
                var he;
                return de.participantId === Q.participantId && ((he = de.mediaStreamTrack) == null ? void 0 : he.kind) === "audio";
              });
              updateMediaStreamTracks(ne, {
                video: Q == null ? void 0 : Q.mediaStreamTrack,
                audio: Z == null ? void 0 : Z.mediaStreamTrack
              }), c(`rtmp-${Q.participantId}`, {
                videoEnabled: !!(Q && !(Q != null && Q.isMuted)),
                audioEnabled: !!(Z && !(Z != null && Z.isMuted))
              });
            }
          }), H();
        });
      }
    }), CoreContext.onInternal("SourceConnected", async (P) => {
      const $ = v[P];
      if ($) {
        const F = await connectDevice(P);
        if (l(`rtmp-${P}`) && F) {
          const j = F.getAudioTracks()[0], ee = F.getVideoTracks()[0];
          updateMediaStreamTracks($, {
            video: ee,
            audio: j
          }), c(`rtmp-${P}`, {
            videoEnabled: !!ee,
            audioEnabled: !!j,
            mirrored: !1,
            external: !0
          });
        }
      }
    }), CoreContext.onInternal("SourceDisconnected", (P) => {
      const $ = v[P];
      $ && ($ == null ? void 0 : $.getTracks()).forEach((H) => {
        var j;
        (j = v[P]) == null || j.removeTrack(H);
      });
    }), CoreContext.on("ProjectSourceAdded", ({
      source: P,
      projectId: $
    }) => {
      const F = toBaseProject(getProject($));
      I(F.sources.filter((H) => H.props.type !== "integration"));
    }), CoreContext.on("ProjectSourceRemoved", ({
      sourceId: P,
      projectId: $
    }) => {
      const F = toBaseProject(getProject($));
      I(F.sources.filter((H) => H.props.type !== "integration"));
    });
  }
}, Game = {
  type: "Game",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l
  }) {
    let v = {}, p = [], _ = [];
    const I = (P) => {
      const $ = P.filter((H) => !_.some((j) => j.id === H.id)), F = _.filter((H) => !P.some((j) => j.id === H.id));
      _ = P, $.forEach(async (H) => {
        const j = new MediaStream([]);
        v[H.id] = j;
        const ee = j.getVideoTracks();
        a({
          id: `game-${H.id}`,
          isActive: !0,
          value: j,
          props: {
            id: H.id,
            isMuted: !1,
            participantId: H.id,
            type: "game",
            videoEnabled: !!ee.length,
            audioEnabled: !0
          }
        });
      }), F.forEach((H) => {
        u(`game-${H.id}`);
      });
    };
    CoreContext.on("RoomJoined", ({
      projectId: P,
      room: $
    }) => {
      if (toBaseProject(getProject(P)).role !== Role.ROLE_RENDERER) {
        const H = () => {
          p.filter((j) => (j == null ? void 0 : j.type) === "screen_share" && (j == null ? void 0 : j.isExternal) === !0).forEach((j) => {
            var ee;
            if (j.type === "screen_share") {
              const X = v[j.participantId], ie = $.getParticipant(j.participantId);
              if (_.some((ne) => ne.id === ie.id)) {
                const ne = $.getTrack(j.id);
                if (l(`game-${ie == null ? void 0 : ie.id}`)) {
                  const de = $.getTracks().find((he) => he.participantId === ie.id && he.mediaStreamTrack.kind === "audio");
                  updateMediaStreamTracks(X, {
                    video: ne == null ? void 0 : ne.mediaStreamTrack,
                    audio: de == null ? void 0 : de.mediaStreamTrack
                  }), c(`game-${ie == null ? void 0 : ie.id}`, {
                    videoEnabled: !!(ne != null && ne.mediaStreamTrack && !ne.isMuted),
                    audioEnabled: !!(de && !de.isMuted),
                    mirrored: (ee = ie == null ? void 0 : ie.meta[j.id]) == null ? void 0 : ee.isMirrored,
                    external: j == null ? void 0 : j.isExternal
                  });
                }
              }
            }
          });
        };
        $.useTracks((j) => {
          const ee = j.filter((Q) => _.some((ne) => ne.id === Q.participantId)).filter((Q) => ["screen_share"].includes(Q.type)), X = ee.filter((Q) => !p.some((ne) => ne.id === Q.id) && !!(Q != null && Q.mediaStreamTrack)), ie = p.filter((Q) => !ee.some((ne) => ne.id === Q.id));
          p = ee.filter((Q) => !!(Q != null && Q.mediaStreamTrack)), ie.forEach((Q) => {
            const {
              participantId: ne
            } = Q, Z = v[ne];
            Q.mediaStreamTrack.kind === "video" && (updateMediaStreamTracks(Z, {
              video: null
            }), c(`game-${ne}`, {
              videoEnabled: !1
            })), Q.mediaStreamTrack.kind === "audio" && (updateMediaStreamTracks(Z, {
              audio: null
            }), c(`game-${ne}`, {
              audioEnabled: !1
            }));
          }), X.forEach((Q) => {
            if (Q.type === "screen_share" && Q.mediaStreamTrack.kind === "video") {
              const ne = v[Q.participantId], Z = p.find((de) => {
                var he;
                return de.participantId === Q.participantId && ((he = de.mediaStreamTrack) == null ? void 0 : he.kind) === "audio";
              });
              updateMediaStreamTracks(ne, {
                video: Q == null ? void 0 : Q.mediaStreamTrack,
                audio: Z == null ? void 0 : Z.mediaStreamTrack
              }), c(`game-${Q.participantId}`, {
                videoEnabled: !!(Q && !(Q != null && Q.isMuted)),
                audioEnabled: !!(Z && !(Z != null && Z.isMuted))
              });
            }
          }), H();
        });
      }
    }), CoreContext.on("ActiveProjectChanged", ({
      projectId: P
    }) => {
      const F = toBaseProject(getProject(P)).sources.filter((H) => H.props.type === "integration");
      I(F);
    }), CoreContext.onInternal("SourceConnected", async (P) => {
      const $ = v[P];
      if ($) {
        const F = await connectDevice(P);
        if (l(`game-${P}`) && F) {
          const j = F.getAudioTracks()[0], ee = F.getVideoTracks()[0];
          updateMediaStreamTracks($, {
            video: ee,
            audio: j
          }), c(`game-${P}`, {
            videoEnabled: !!ee,
            audioEnabled: !!j,
            mirrored: !1,
            external: !0
          });
        }
      }
    }), CoreContext.onInternal("SourceDisconnected", (P) => {
      const $ = v[P];
      $ && ($ == null ? void 0 : $.getTracks()).forEach((H) => {
        var j;
        (j = v[P]) == null || j.removeTrack(H);
      });
    }), CoreContext.on("ProjectSourceAdded", ({
      source: P,
      projectId: $
    }) => {
      const F = toBaseProject(getProject($));
      I(F.sources.filter((H) => {
        var j;
        return ((j = H == null ? void 0 : H.props) == null ? void 0 : j.type) === "integration";
      }));
    }), CoreContext.on("ProjectSourceRemoved", ({
      sourceId: P,
      projectId: $
    }) => {
      const F = toBaseProject(getProject($));
      I(F.sources.filter((H) => {
        var j;
        return ((j = H == null ? void 0 : H.props) == null ? void 0 : j.type) === "integration";
      }));
    });
  }
}, Sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Banner: Banner$1,
  Game,
  RTMP,
  RoomParticipant: RoomParticipant$1
}, Symbol.toStringTag, { value: "Module" }));
var createRoot, m = ReactDOM;
if (process$1.env.NODE_ENV === "production")
  createRoot = m.createRoot, m.hydrateRoot;
else {
  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  createRoot = function(a, u) {
    i.usingClientEntryPoint = !0;
    try {
      return m.createRoot(a, u);
    } finally {
      i.usingClientEntryPoint = !1;
    }
  };
}
var APIKitAnimationTypes = /* @__PURE__ */ ((a) => (a.FADE_IN = "fade-in", a.FADE_OUT = "fade-out", a.SLIDE_IN_BLURRED_TOP = "slide-in-blurred-top", a.SLIDE_IN_LEFT = "slide-in-left", a.SLIDE_OUT_LEFT = "slide-out-left", a))(APIKitAnimationTypes || {});
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(a) {
    for (var u = 1; u < arguments.length; u++) {
      var c = arguments[u];
      for (var l in c)
        Object.prototype.hasOwnProperty.call(c, l) && (a[l] = c[l]);
    }
    return a;
  }, _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(a, u) {
  if (a == null)
    return {};
  var c = {}, l = Object.keys(a), v, p;
  for (p = 0; p < l.length; p++)
    v = l[p], !(u.indexOf(v) >= 0) && (c[v] = a[v]);
  return c;
}
function _setPrototypeOf(a, u) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(l, v) {
    return l.__proto__ = v, l;
  }, _setPrototypeOf(a, u);
}
function _inheritsLoose(a, u) {
  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, _setPrototypeOf(a, u);
}
var propTypes = { exports: {} }, reactIs = { exports: {} }, reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min)
    return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var a = typeof Symbol == "function" && Symbol.for, u = a ? Symbol.for("react.element") : 60103, c = a ? Symbol.for("react.portal") : 60106, l = a ? Symbol.for("react.fragment") : 60107, v = a ? Symbol.for("react.strict_mode") : 60108, p = a ? Symbol.for("react.profiler") : 60114, _ = a ? Symbol.for("react.provider") : 60109, I = a ? Symbol.for("react.context") : 60110, P = a ? Symbol.for("react.async_mode") : 60111, $ = a ? Symbol.for("react.concurrent_mode") : 60111, F = a ? Symbol.for("react.forward_ref") : 60112, H = a ? Symbol.for("react.suspense") : 60113, j = a ? Symbol.for("react.suspense_list") : 60120, ee = a ? Symbol.for("react.memo") : 60115, X = a ? Symbol.for("react.lazy") : 60116, ie = a ? Symbol.for("react.block") : 60121, Q = a ? Symbol.for("react.fundamental") : 60117, ne = a ? Symbol.for("react.responder") : 60118, Z = a ? Symbol.for("react.scope") : 60119;
  function de(pe) {
    if (typeof pe == "object" && pe !== null) {
      var be = pe.$$typeof;
      switch (be) {
        case u:
          switch (pe = pe.type, pe) {
            case P:
            case $:
            case l:
            case p:
            case v:
            case H:
              return pe;
            default:
              switch (pe = pe && pe.$$typeof, pe) {
                case I:
                case F:
                case X:
                case ee:
                case _:
                  return pe;
                default:
                  return be;
              }
          }
        case c:
          return be;
      }
    }
  }
  function he(pe) {
    return de(pe) === $;
  }
  return reactIs_production_min.AsyncMode = P, reactIs_production_min.ConcurrentMode = $, reactIs_production_min.ContextConsumer = I, reactIs_production_min.ContextProvider = _, reactIs_production_min.Element = u, reactIs_production_min.ForwardRef = F, reactIs_production_min.Fragment = l, reactIs_production_min.Lazy = X, reactIs_production_min.Memo = ee, reactIs_production_min.Portal = c, reactIs_production_min.Profiler = p, reactIs_production_min.StrictMode = v, reactIs_production_min.Suspense = H, reactIs_production_min.isAsyncMode = function(pe) {
    return he(pe) || de(pe) === P;
  }, reactIs_production_min.isConcurrentMode = he, reactIs_production_min.isContextConsumer = function(pe) {
    return de(pe) === I;
  }, reactIs_production_min.isContextProvider = function(pe) {
    return de(pe) === _;
  }, reactIs_production_min.isElement = function(pe) {
    return typeof pe == "object" && pe !== null && pe.$$typeof === u;
  }, reactIs_production_min.isForwardRef = function(pe) {
    return de(pe) === F;
  }, reactIs_production_min.isFragment = function(pe) {
    return de(pe) === l;
  }, reactIs_production_min.isLazy = function(pe) {
    return de(pe) === X;
  }, reactIs_production_min.isMemo = function(pe) {
    return de(pe) === ee;
  }, reactIs_production_min.isPortal = function(pe) {
    return de(pe) === c;
  }, reactIs_production_min.isProfiler = function(pe) {
    return de(pe) === p;
  }, reactIs_production_min.isStrictMode = function(pe) {
    return de(pe) === v;
  }, reactIs_production_min.isSuspense = function(pe) {
    return de(pe) === H;
  }, reactIs_production_min.isValidElementType = function(pe) {
    return typeof pe == "string" || typeof pe == "function" || pe === l || pe === $ || pe === p || pe === v || pe === H || pe === j || typeof pe == "object" && pe !== null && (pe.$$typeof === X || pe.$$typeof === ee || pe.$$typeof === _ || pe.$$typeof === I || pe.$$typeof === F || pe.$$typeof === Q || pe.$$typeof === ne || pe.$$typeof === Z || pe.$$typeof === ie);
  }, reactIs_production_min.typeOf = de, reactIs_production_min;
}
var reactIs_development = {}, hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var a = typeof Symbol == "function" && Symbol.for, u = a ? Symbol.for("react.element") : 60103, c = a ? Symbol.for("react.portal") : 60106, l = a ? Symbol.for("react.fragment") : 60107, v = a ? Symbol.for("react.strict_mode") : 60108, p = a ? Symbol.for("react.profiler") : 60114, _ = a ? Symbol.for("react.provider") : 60109, I = a ? Symbol.for("react.context") : 60110, P = a ? Symbol.for("react.async_mode") : 60111, $ = a ? Symbol.for("react.concurrent_mode") : 60111, F = a ? Symbol.for("react.forward_ref") : 60112, H = a ? Symbol.for("react.suspense") : 60113, j = a ? Symbol.for("react.suspense_list") : 60120, ee = a ? Symbol.for("react.memo") : 60115, X = a ? Symbol.for("react.lazy") : 60116, ie = a ? Symbol.for("react.block") : 60121, Q = a ? Symbol.for("react.fundamental") : 60117, ne = a ? Symbol.for("react.responder") : 60118, Z = a ? Symbol.for("react.scope") : 60119;
    function de(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === l || N === $ || N === p || N === v || N === H || N === j || typeof N == "object" && N !== null && (N.$$typeof === X || N.$$typeof === ee || N.$$typeof === _ || N.$$typeof === I || N.$$typeof === F || N.$$typeof === Q || N.$$typeof === ne || N.$$typeof === Z || N.$$typeof === ie);
    }
    function he(N) {
      if (typeof N == "object" && N !== null) {
        var re = N.$$typeof;
        switch (re) {
          case u:
            var le = N.type;
            switch (le) {
              case P:
              case $:
              case l:
              case p:
              case v:
              case H:
                return le;
              default:
                var Ne = le && le.$$typeof;
                switch (Ne) {
                  case I:
                  case F:
                  case X:
                  case ee:
                  case _:
                    return Ne;
                  default:
                    return re;
                }
            }
          case c:
            return re;
        }
      }
    }
    var pe = P, be = $, ke = I, _e = _, q = u, z = F, C = l, b = X, E = ee, k = c, O = p, A = v, x = H, Y = !1;
    function B(N) {
      return Y || (Y = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), T(N) || he(N) === P;
    }
    function T(N) {
      return he(N) === $;
    }
    function D(N) {
      return he(N) === I;
    }
    function te(N) {
      return he(N) === _;
    }
    function me(N) {
      return typeof N == "object" && N !== null && N.$$typeof === u;
    }
    function Ie(N) {
      return he(N) === F;
    }
    function $e(N) {
      return he(N) === l;
    }
    function ye(N) {
      return he(N) === X;
    }
    function fe(N) {
      return he(N) === ee;
    }
    function Me(N) {
      return he(N) === c;
    }
    function Ae(N) {
      return he(N) === p;
    }
    function xe(N) {
      return he(N) === v;
    }
    function ae(N) {
      return he(N) === H;
    }
    reactIs_development.AsyncMode = pe, reactIs_development.ConcurrentMode = be, reactIs_development.ContextConsumer = ke, reactIs_development.ContextProvider = _e, reactIs_development.Element = q, reactIs_development.ForwardRef = z, reactIs_development.Fragment = C, reactIs_development.Lazy = b, reactIs_development.Memo = E, reactIs_development.Portal = k, reactIs_development.Profiler = O, reactIs_development.StrictMode = A, reactIs_development.Suspense = x, reactIs_development.isAsyncMode = B, reactIs_development.isConcurrentMode = T, reactIs_development.isContextConsumer = D, reactIs_development.isContextProvider = te, reactIs_development.isElement = me, reactIs_development.isForwardRef = Ie, reactIs_development.isFragment = $e, reactIs_development.isLazy = ye, reactIs_development.isMemo = fe, reactIs_development.isPortal = Me, reactIs_development.isProfiler = Ae, reactIs_development.isStrictMode = xe, reactIs_development.isSuspense = ae, reactIs_development.isValidElementType = de, reactIs_development.typeOf = he;
  }()), reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, process$1.env.NODE_ENV === "production" ? reactIs.exports = requireReactIs_production_min() : reactIs.exports = requireReactIs_development()), reactIs.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign, hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var a = Object.getOwnPropertySymbols, u = Object.prototype.hasOwnProperty, c = Object.prototype.propertyIsEnumerable;
  function l(p) {
    if (p == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(p);
  }
  function v() {
    try {
      if (!Object.assign)
        return !1;
      var p = new String("abc");
      if (p[5] = "de", Object.getOwnPropertyNames(p)[0] === "5")
        return !1;
      for (var _ = {}, I = 0; I < 10; I++)
        _["_" + String.fromCharCode(I)] = I;
      var P = Object.getOwnPropertyNames(_).map(function(F) {
        return _[F];
      });
      if (P.join("") !== "0123456789")
        return !1;
      var $ = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(F) {
        $[F] = F;
      }), Object.keys(Object.assign({}, $)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return objectAssign = v() ? Object.assign : function(p, _) {
    for (var I, P = l(p), $, F = 1; F < arguments.length; F++) {
      I = Object(arguments[F]);
      for (var H in I)
        u.call(I, H) && (P[H] = I[H]);
      if (a) {
        $ = a(I);
        for (var j = 0; j < $.length; j++)
          c.call(I, $[j]) && (P[$[j]] = I[$[j]]);
      }
    }
    return P;
  }, objectAssign;
}
var ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret)
    return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var a = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ReactPropTypesSecret_1 = a, ReactPropTypesSecret_1;
}
var has, hasRequiredHas;
function requireHas() {
  return hasRequiredHas || (hasRequiredHas = 1, has = Function.call.bind(Object.prototype.hasOwnProperty)), has;
}
var checkPropTypes_1, hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes)
    return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var a = function() {
  };
  if (process$1.env.NODE_ENV !== "production") {
    var u = requireReactPropTypesSecret(), c = {}, l = requireHas();
    a = function(p) {
      var _ = "Warning: " + p;
      typeof console < "u" && console.error(_);
      try {
        throw new Error(_);
      } catch {
      }
    };
  }
  function v(p, _, I, P, $) {
    if (process$1.env.NODE_ENV !== "production") {
      for (var F in p)
        if (l(p, F)) {
          var H;
          try {
            if (typeof p[F] != "function") {
              var j = Error(
                (P || "React class") + ": " + I + " type `" + F + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof p[F] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw j.name = "Invariant Violation", j;
            }
            H = p[F](_, F, P, I, null, u);
          } catch (X) {
            H = X;
          }
          if (H && !(H instanceof Error) && a(
            (P || "React class") + ": type specification of " + I + " `" + F + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof H + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), H instanceof Error && !(H.message in c)) {
            c[H.message] = !0;
            var ee = $ ? $() : "";
            a(
              "Failed " + I + " type: " + H.message + (ee ?? "")
            );
          }
        }
    }
  }
  return v.resetWarningCache = function() {
    process$1.env.NODE_ENV !== "production" && (c = {});
  }, checkPropTypes_1 = v, checkPropTypes_1;
}
var factoryWithTypeCheckers, hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers)
    return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var a = requireReactIs(), u = requireObjectAssign(), c = requireReactPropTypesSecret(), l = requireHas(), v = requireCheckPropTypes(), p = function() {
  };
  process$1.env.NODE_ENV !== "production" && (p = function(I) {
    var P = "Warning: " + I;
    typeof console < "u" && console.error(P);
    try {
      throw new Error(P);
    } catch {
    }
  });
  function _() {
    return null;
  }
  return factoryWithTypeCheckers = function(I, P) {
    var $ = typeof Symbol == "function" && Symbol.iterator, F = "@@iterator";
    function H(T) {
      var D = T && ($ && T[$] || T[F]);
      if (typeof D == "function")
        return D;
    }
    var j = "<<anonymous>>", ee = {
      array: ne("array"),
      bigint: ne("bigint"),
      bool: ne("boolean"),
      func: ne("function"),
      number: ne("number"),
      object: ne("object"),
      string: ne("string"),
      symbol: ne("symbol"),
      any: Z(),
      arrayOf: de,
      element: he(),
      elementType: pe(),
      instanceOf: be,
      node: z(),
      objectOf: _e,
      oneOf: ke,
      oneOfType: q,
      shape: b,
      exact: E
    };
    function X(T, D) {
      return T === D ? T !== 0 || 1 / T === 1 / D : T !== T && D !== D;
    }
    function ie(T, D) {
      this.message = T, this.data = D && typeof D == "object" ? D : {}, this.stack = "";
    }
    ie.prototype = Error.prototype;
    function Q(T) {
      if (process$1.env.NODE_ENV !== "production")
        var D = {}, te = 0;
      function me($e, ye, fe, Me, Ae, xe, ae) {
        if (Me = Me || j, xe = xe || fe, ae !== c) {
          if (P) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process$1.env.NODE_ENV !== "production" && typeof console < "u") {
            var re = Me + ":" + fe;
            !D[re] && // Avoid spamming the console because they are often not actionable except for lib authors
            te < 3 && (p(
              "You are manually calling a React.PropTypes validation function for the `" + xe + "` prop on `" + Me + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), D[re] = !0, te++);
          }
        }
        return ye[fe] == null ? $e ? ye[fe] === null ? new ie("The " + Ae + " `" + xe + "` is marked as required " + ("in `" + Me + "`, but its value is `null`.")) : new ie("The " + Ae + " `" + xe + "` is marked as required in " + ("`" + Me + "`, but its value is `undefined`.")) : null : T(ye, fe, Me, Ae, xe);
      }
      var Ie = me.bind(null, !1);
      return Ie.isRequired = me.bind(null, !0), Ie;
    }
    function ne(T) {
      function D(te, me, Ie, $e, ye, fe) {
        var Me = te[me], Ae = A(Me);
        if (Ae !== T) {
          var xe = x(Me);
          return new ie(
            "Invalid " + $e + " `" + ye + "` of type " + ("`" + xe + "` supplied to `" + Ie + "`, expected ") + ("`" + T + "`."),
            { expectedType: T }
          );
        }
        return null;
      }
      return Q(D);
    }
    function Z() {
      return Q(_);
    }
    function de(T) {
      function D(te, me, Ie, $e, ye) {
        if (typeof T != "function")
          return new ie("Property `" + ye + "` of component `" + Ie + "` has invalid PropType notation inside arrayOf.");
        var fe = te[me];
        if (!Array.isArray(fe)) {
          var Me = A(fe);
          return new ie("Invalid " + $e + " `" + ye + "` of type " + ("`" + Me + "` supplied to `" + Ie + "`, expected an array."));
        }
        for (var Ae = 0; Ae < fe.length; Ae++) {
          var xe = T(fe, Ae, Ie, $e, ye + "[" + Ae + "]", c);
          if (xe instanceof Error)
            return xe;
        }
        return null;
      }
      return Q(D);
    }
    function he() {
      function T(D, te, me, Ie, $e) {
        var ye = D[te];
        if (!I(ye)) {
          var fe = A(ye);
          return new ie("Invalid " + Ie + " `" + $e + "` of type " + ("`" + fe + "` supplied to `" + me + "`, expected a single ReactElement."));
        }
        return null;
      }
      return Q(T);
    }
    function pe() {
      function T(D, te, me, Ie, $e) {
        var ye = D[te];
        if (!a.isValidElementType(ye)) {
          var fe = A(ye);
          return new ie("Invalid " + Ie + " `" + $e + "` of type " + ("`" + fe + "` supplied to `" + me + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return Q(T);
    }
    function be(T) {
      function D(te, me, Ie, $e, ye) {
        if (!(te[me] instanceof T)) {
          var fe = T.name || j, Me = B(te[me]);
          return new ie("Invalid " + $e + " `" + ye + "` of type " + ("`" + Me + "` supplied to `" + Ie + "`, expected ") + ("instance of `" + fe + "`."));
        }
        return null;
      }
      return Q(D);
    }
    function ke(T) {
      if (!Array.isArray(T))
        return process$1.env.NODE_ENV !== "production" && (arguments.length > 1 ? p(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : p("Invalid argument supplied to oneOf, expected an array.")), _;
      function D(te, me, Ie, $e, ye) {
        for (var fe = te[me], Me = 0; Me < T.length; Me++)
          if (X(fe, T[Me]))
            return null;
        var Ae = JSON.stringify(T, function(ae, N) {
          var re = x(N);
          return re === "symbol" ? String(N) : N;
        });
        return new ie("Invalid " + $e + " `" + ye + "` of value `" + String(fe) + "` " + ("supplied to `" + Ie + "`, expected one of " + Ae + "."));
      }
      return Q(D);
    }
    function _e(T) {
      function D(te, me, Ie, $e, ye) {
        if (typeof T != "function")
          return new ie("Property `" + ye + "` of component `" + Ie + "` has invalid PropType notation inside objectOf.");
        var fe = te[me], Me = A(fe);
        if (Me !== "object")
          return new ie("Invalid " + $e + " `" + ye + "` of type " + ("`" + Me + "` supplied to `" + Ie + "`, expected an object."));
        for (var Ae in fe)
          if (l(fe, Ae)) {
            var xe = T(fe, Ae, Ie, $e, ye + "." + Ae, c);
            if (xe instanceof Error)
              return xe;
          }
        return null;
      }
      return Q(D);
    }
    function q(T) {
      if (!Array.isArray(T))
        return process$1.env.NODE_ENV !== "production" && p("Invalid argument supplied to oneOfType, expected an instance of array."), _;
      for (var D = 0; D < T.length; D++) {
        var te = T[D];
        if (typeof te != "function")
          return p(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + Y(te) + " at index " + D + "."
          ), _;
      }
      function me(Ie, $e, ye, fe, Me) {
        for (var Ae = [], xe = 0; xe < T.length; xe++) {
          var ae = T[xe], N = ae(Ie, $e, ye, fe, Me, c);
          if (N == null)
            return null;
          N.data && l(N.data, "expectedType") && Ae.push(N.data.expectedType);
        }
        var re = Ae.length > 0 ? ", expected one of type [" + Ae.join(", ") + "]" : "";
        return new ie("Invalid " + fe + " `" + Me + "` supplied to " + ("`" + ye + "`" + re + "."));
      }
      return Q(me);
    }
    function z() {
      function T(D, te, me, Ie, $e) {
        return k(D[te]) ? null : new ie("Invalid " + Ie + " `" + $e + "` supplied to " + ("`" + me + "`, expected a ReactNode."));
      }
      return Q(T);
    }
    function C(T, D, te, me, Ie) {
      return new ie(
        (T || "React class") + ": " + D + " type `" + te + "." + me + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Ie + "`."
      );
    }
    function b(T) {
      function D(te, me, Ie, $e, ye) {
        var fe = te[me], Me = A(fe);
        if (Me !== "object")
          return new ie("Invalid " + $e + " `" + ye + "` of type `" + Me + "` " + ("supplied to `" + Ie + "`, expected `object`."));
        for (var Ae in T) {
          var xe = T[Ae];
          if (typeof xe != "function")
            return C(Ie, $e, ye, Ae, x(xe));
          var ae = xe(fe, Ae, Ie, $e, ye + "." + Ae, c);
          if (ae)
            return ae;
        }
        return null;
      }
      return Q(D);
    }
    function E(T) {
      function D(te, me, Ie, $e, ye) {
        var fe = te[me], Me = A(fe);
        if (Me !== "object")
          return new ie("Invalid " + $e + " `" + ye + "` of type `" + Me + "` " + ("supplied to `" + Ie + "`, expected `object`."));
        var Ae = u({}, te[me], T);
        for (var xe in Ae) {
          var ae = T[xe];
          if (l(T, xe) && typeof ae != "function")
            return C(Ie, $e, ye, xe, x(ae));
          if (!ae)
            return new ie(
              "Invalid " + $e + " `" + ye + "` key `" + xe + "` supplied to `" + Ie + "`.\nBad object: " + JSON.stringify(te[me], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(T), null, "  ")
            );
          var N = ae(fe, xe, Ie, $e, ye + "." + xe, c);
          if (N)
            return N;
        }
        return null;
      }
      return Q(D);
    }
    function k(T) {
      switch (typeof T) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !T;
        case "object":
          if (Array.isArray(T))
            return T.every(k);
          if (T === null || I(T))
            return !0;
          var D = H(T);
          if (D) {
            var te = D.call(T), me;
            if (D !== T.entries) {
              for (; !(me = te.next()).done; )
                if (!k(me.value))
                  return !1;
            } else
              for (; !(me = te.next()).done; ) {
                var Ie = me.value;
                if (Ie && !k(Ie[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function O(T, D) {
      return T === "symbol" ? !0 : D ? D["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && D instanceof Symbol : !1;
    }
    function A(T) {
      var D = typeof T;
      return Array.isArray(T) ? "array" : T instanceof RegExp ? "object" : O(D, T) ? "symbol" : D;
    }
    function x(T) {
      if (typeof T > "u" || T === null)
        return "" + T;
      var D = A(T);
      if (D === "object") {
        if (T instanceof Date)
          return "date";
        if (T instanceof RegExp)
          return "regexp";
      }
      return D;
    }
    function Y(T) {
      var D = x(T);
      switch (D) {
        case "array":
        case "object":
          return "an " + D;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + D;
        default:
          return D;
      }
    }
    function B(T) {
      return !T.constructor || !T.constructor.name ? j : T.constructor.name;
    }
    return ee.checkPropTypes = v, ee.resetWarningCache = v.resetWarningCache, ee.PropTypes = ee, ee;
  }, factoryWithTypeCheckers;
}
var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims)
    return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var a = requireReactPropTypesSecret();
  function u() {
  }
  function c() {
  }
  return c.resetWarningCache = u, factoryWithThrowingShims = function() {
    function l(_, I, P, $, F, H) {
      if (H !== a) {
        var j = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw j.name = "Invariant Violation", j;
      }
    }
    l.isRequired = l;
    function v() {
      return l;
    }
    var p = {
      array: l,
      bigint: l,
      bool: l,
      func: l,
      number: l,
      object: l,
      string: l,
      symbol: l,
      any: l,
      arrayOf: v,
      element: l,
      elementType: l,
      instanceOf: v,
      node: l,
      objectOf: v,
      oneOf: v,
      oneOfType: v,
      shape: v,
      exact: v,
      checkPropTypes: c,
      resetWarningCache: u
    };
    return p.PropTypes = p, p;
  }, factoryWithThrowingShims;
}
if (process$1.env.NODE_ENV !== "production") {
  var ReactIs = requireReactIs(), throwOnDirectAccess = !0;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else
  propTypes.exports = requireFactoryWithThrowingShims()();
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs$2(propTypesExports);
function hasClass(a, u) {
  return a.classList ? !!u && a.classList.contains(u) : (" " + (a.className.baseVal || a.className) + " ").indexOf(" " + u + " ") !== -1;
}
function addClass(a, u) {
  a.classList ? a.classList.add(u) : hasClass(a, u) || (typeof a.className == "string" ? a.className = a.className + " " + u : a.setAttribute("class", (a.className && a.className.baseVal || "") + " " + u));
}
function replaceClassName(a, u) {
  return a.replace(new RegExp("(^|\\s)" + u + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(a, u) {
  a.classList ? a.classList.remove(u) : typeof a.className == "string" ? a.className = replaceClassName(a.className, u) : a.setAttribute("class", replaceClassName(a.className && a.className.baseVal || "", u));
}
const config = {
  disabled: !1
};
var timeoutsShape = process$1.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
  enter: PropTypes.number,
  exit: PropTypes.number,
  appear: PropTypes.number
}).isRequired]) : null, classNamesShape = process$1.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
  enter: PropTypes.string,
  exit: PropTypes.string,
  active: PropTypes.string
}), PropTypes.shape({
  enter: PropTypes.string,
  enterDone: PropTypes.string,
  enterActive: PropTypes.string,
  exit: PropTypes.string,
  exitDone: PropTypes.string,
  exitActive: PropTypes.string
})]) : null;
const TransitionGroupContext = React.createContext(null);
var forceReflow = function a(u) {
  return u.scrollTop;
}, UNMOUNTED = "unmounted", EXITED = "exited", ENTERING = "entering", ENTERED = "entered", EXITING = "exiting", Transition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u(l, v) {
    var p;
    p = a.call(this, l, v) || this;
    var _ = v, I = _ && !_.isMounting ? l.enter : l.appear, P;
    return p.appearStatus = null, l.in ? I ? (P = EXITED, p.appearStatus = ENTERING) : P = ENTERED : l.unmountOnExit || l.mountOnEnter ? P = UNMOUNTED : P = EXITED, p.state = {
      status: P
    }, p.nextCallback = null, p;
  }
  u.getDerivedStateFromProps = function(v, p) {
    var _ = v.in;
    return _ && p.status === UNMOUNTED ? {
      status: EXITED
    } : null;
  };
  var c = u.prototype;
  return c.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, c.componentDidUpdate = function(v) {
    var p = null;
    if (v !== this.props) {
      var _ = this.state.status;
      this.props.in ? _ !== ENTERING && _ !== ENTERED && (p = ENTERING) : (_ === ENTERING || _ === ENTERED) && (p = EXITING);
    }
    this.updateStatus(!1, p);
  }, c.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, c.getTimeouts = function() {
    var v = this.props.timeout, p, _, I;
    return p = _ = I = v, v != null && typeof v != "number" && (p = v.exit, _ = v.enter, I = v.appear !== void 0 ? v.appear : _), {
      exit: p,
      enter: _,
      appear: I
    };
  }, c.updateStatus = function(v, p) {
    if (v === void 0 && (v = !1), p !== null)
      if (this.cancelNextCallback(), p === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var _ = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          _ && forceReflow(_);
        }
        this.performEnter(v);
      } else
        this.performExit();
    else
      this.props.unmountOnExit && this.state.status === EXITED && this.setState({
        status: UNMOUNTED
      });
  }, c.performEnter = function(v) {
    var p = this, _ = this.props.enter, I = this.context ? this.context.isMounting : v, P = this.props.nodeRef ? [I] : [ReactDOM.findDOMNode(this), I], $ = P[0], F = P[1], H = this.getTimeouts(), j = I ? H.appear : H.enter;
    if (!v && !_ || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        p.props.onEntered($);
      });
      return;
    }
    this.props.onEnter($, F), this.safeSetState({
      status: ENTERING
    }, function() {
      p.props.onEntering($, F), p.onTransitionEnd(j, function() {
        p.safeSetState({
          status: ENTERED
        }, function() {
          p.props.onEntered($, F);
        });
      });
    });
  }, c.performExit = function() {
    var v = this, p = this.props.exit, _ = this.getTimeouts(), I = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!p || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        v.props.onExited(I);
      });
      return;
    }
    this.props.onExit(I), this.safeSetState({
      status: EXITING
    }, function() {
      v.props.onExiting(I), v.onTransitionEnd(_.exit, function() {
        v.safeSetState({
          status: EXITED
        }, function() {
          v.props.onExited(I);
        });
      });
    });
  }, c.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, c.safeSetState = function(v, p) {
    p = this.setNextCallback(p), this.setState(v, p);
  }, c.setNextCallback = function(v) {
    var p = this, _ = !0;
    return this.nextCallback = function(I) {
      _ && (_ = !1, p.nextCallback = null, v(I));
    }, this.nextCallback.cancel = function() {
      _ = !1;
    }, this.nextCallback;
  }, c.onTransitionEnd = function(v, p) {
    this.setNextCallback(p);
    var _ = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this), I = v == null && !this.props.addEndListener;
    if (!_ || I) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var P = this.props.nodeRef ? [this.nextCallback] : [_, this.nextCallback], $ = P[0], F = P[1];
      this.props.addEndListener($, F);
    }
    v != null && setTimeout(this.nextCallback, v);
  }, c.render = function() {
    var v = this.state.status;
    if (v === UNMOUNTED)
      return null;
    var p = this.props, _ = p.children;
    p.in, p.mountOnEnter, p.unmountOnExit, p.appear, p.enter, p.exit, p.timeout, p.addEndListener, p.onEnter, p.onEntering, p.onEntered, p.onExit, p.onExiting, p.onExited, p.nodeRef;
    var I = _objectWithoutPropertiesLoose(p, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof _ == "function" ? _(v, I) : React.cloneElement(React.Children.only(_), I))
    );
  }, u;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = process$1.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: PropTypes.shape({
    current: typeof Element > "u" ? PropTypes.any : function(a, u, c, l, v, p) {
      var _ = a[u];
      return PropTypes.instanceOf(_ && "ownerDocument" in _ ? _.ownerDocument.defaultView.Element : Element)(a, u, c, l, v, p);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: PropTypes.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: PropTypes.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: PropTypes.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: PropTypes.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: PropTypes.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: PropTypes.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function a(u) {
    var c = timeoutsShape;
    u.addEndListener || (c = c.isRequired);
    for (var l = arguments.length, v = new Array(l > 1 ? l - 1 : 0), p = 1; p < l; p++)
      v[p - 1] = arguments[p];
    return c.apply(void 0, [u].concat(v));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: PropTypes.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: PropTypes.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: PropTypes.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: PropTypes.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: PropTypes.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: PropTypes.func
} : {};
function noop() {
}
Transition.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
var _addClass = function a(u, c) {
  return u && c && c.split(" ").forEach(function(l) {
    return addClass(u, l);
  });
}, removeClass = function a(u, c) {
  return u && c && c.split(" ").forEach(function(l) {
    return removeClass$1(u, l);
  });
}, CSSTransition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u() {
    for (var l, v = arguments.length, p = new Array(v), _ = 0; _ < v; _++)
      p[_] = arguments[_];
    return l = a.call.apply(a, [this].concat(p)) || this, l.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    }, l.onEnter = function(I, P) {
      var $ = l.resolveArguments(I, P), F = $[0], H = $[1];
      l.removeClasses(F, "exit"), l.addClass(F, H ? "appear" : "enter", "base"), l.props.onEnter && l.props.onEnter(I, P);
    }, l.onEntering = function(I, P) {
      var $ = l.resolveArguments(I, P), F = $[0], H = $[1], j = H ? "appear" : "enter";
      l.addClass(F, j, "active"), l.props.onEntering && l.props.onEntering(I, P);
    }, l.onEntered = function(I, P) {
      var $ = l.resolveArguments(I, P), F = $[0], H = $[1], j = H ? "appear" : "enter";
      l.removeClasses(F, j), l.addClass(F, j, "done"), l.props.onEntered && l.props.onEntered(I, P);
    }, l.onExit = function(I) {
      var P = l.resolveArguments(I), $ = P[0];
      l.removeClasses($, "appear"), l.removeClasses($, "enter"), l.addClass($, "exit", "base"), l.props.onExit && l.props.onExit(I);
    }, l.onExiting = function(I) {
      var P = l.resolveArguments(I), $ = P[0];
      l.addClass($, "exit", "active"), l.props.onExiting && l.props.onExiting(I);
    }, l.onExited = function(I) {
      var P = l.resolveArguments(I), $ = P[0];
      l.removeClasses($, "exit"), l.addClass($, "exit", "done"), l.props.onExited && l.props.onExited(I);
    }, l.resolveArguments = function(I, P) {
      return l.props.nodeRef ? [l.props.nodeRef.current, I] : [I, P];
    }, l.getClassNames = function(I) {
      var P = l.props.classNames, $ = typeof P == "string", F = $ && P ? P + "-" : "", H = $ ? "" + F + I : P[I], j = $ ? H + "-active" : P[I + "Active"], ee = $ ? H + "-done" : P[I + "Done"];
      return {
        baseClassName: H,
        activeClassName: j,
        doneClassName: ee
      };
    }, l;
  }
  var c = u.prototype;
  return c.addClass = function(v, p, _) {
    var I = this.getClassNames(p)[_ + "ClassName"], P = this.getClassNames("enter"), $ = P.doneClassName;
    p === "appear" && _ === "done" && $ && (I += " " + $), _ === "active" && v && forceReflow(v), I && (this.appliedClasses[p][_] = I, _addClass(v, I));
  }, c.removeClasses = function(v, p) {
    var _ = this.appliedClasses[p], I = _.base, P = _.active, $ = _.done;
    this.appliedClasses[p] = {}, I && removeClass(v, I), P && removeClass(v, P), $ && removeClass(v, $);
  }, c.render = function() {
    var v = this.props;
    v.classNames;
    var p = _objectWithoutPropertiesLoose(v, ["classNames"]);
    return /* @__PURE__ */ React.createElement(Transition$1, _extends({}, p, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  }, u;
}(React.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = process$1.env.NODE_ENV !== "production" ? _extends({}, Transition$1.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: classNamesShape,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: PropTypes.func
}) : {};
const CSSTransition$1 = CSSTransition;
var _leaveRenders, _enterRenders;
function areChildrenDifferent(a, u) {
  return !(a === u || React.isValidElement(a) && React.isValidElement(u) && a.key != null && a.key === u.key);
}
var modes = {
  out: "out-in",
  in: "in-out"
}, callHook = function a(u, c, l) {
  return function() {
    var v;
    u.props[c] && (v = u.props)[c].apply(v, arguments), l();
  };
}, leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(a) {
  var u = a.current, c = a.changeState;
  return React.cloneElement(u, {
    in: !1,
    onExited: callHook(u, "onExited", function() {
      c(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(a) {
  var u = a.current, c = a.changeState, l = a.children;
  return [u, React.cloneElement(l, {
    in: !0,
    onEntered: callHook(l, "onEntered", function() {
      c(ENTERING);
    })
  })];
}, _leaveRenders), enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(a) {
  var u = a.children, c = a.changeState;
  return React.cloneElement(u, {
    in: !0,
    onEntered: callHook(u, "onEntered", function() {
      c(ENTERED, React.cloneElement(u, {
        in: !0
      }));
    })
  });
}, _enterRenders[modes.in] = function(a) {
  var u = a.current, c = a.children, l = a.changeState;
  return [React.cloneElement(u, {
    in: !1,
    onExited: callHook(u, "onExited", function() {
      l(ENTERED, React.cloneElement(c, {
        in: !0
      }));
    })
  }), React.cloneElement(c, {
    in: !0
  })];
}, _enterRenders), SwitchTransition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u() {
    for (var l, v = arguments.length, p = new Array(v), _ = 0; _ < v; _++)
      p[_] = arguments[_];
    return l = a.call.apply(a, [this].concat(p)) || this, l.state = {
      status: ENTERED,
      current: null
    }, l.appeared = !1, l.changeState = function(I, P) {
      P === void 0 && (P = l.state.current), l.setState({
        status: I,
        current: P
      });
    }, l;
  }
  var c = u.prototype;
  return c.componentDidMount = function() {
    this.appeared = !0;
  }, u.getDerivedStateFromProps = function(v, p) {
    return v.children == null ? {
      current: null
    } : p.status === ENTERING && v.mode === modes.in ? {
      status: ENTERING
    } : p.current && areChildrenDifferent(p.current, v.children) ? {
      status: EXITING
    } : {
      current: React.cloneElement(v.children, {
        in: !0
      })
    };
  }, c.render = function() {
    var v = this.props, p = v.children, _ = v.mode, I = this.state, P = I.status, $ = I.current, F = {
      children: p,
      current: $,
      changeState: this.changeState,
      status: P
    }, H;
    switch (P) {
      case ENTERING:
        H = enterRenders[_](F);
        break;
      case EXITING:
        H = leaveRenders[_](F);
        break;
      case ENTERED:
        H = $;
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, H);
  }, u;
}(React.Component);
SwitchTransition.propTypes = process$1.env.NODE_ENV !== "production" ? {
  /**
   * Transition modes.
   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
   * `in-out`: New element transitions in first, then when complete, the current element transitions out.
   *
   * @type {'out-in'|'in-out'}
   */
  mode: PropTypes.oneOf([modes.in, modes.out]),
  /**
   * Any `Transition` or `CSSTransition` component.
   */
  children: PropTypes.oneOfType([PropTypes.element.isRequired])
} : {};
SwitchTransition.defaultProps = {
  mode: modes.out
};
const SwitchTransition$1 = SwitchTransition, Animations = {
  "fade-in": ".fade-in{-webkit-animation:fade-in;animation:fade-in}@-webkit-keyframes fade-in{0%{opacity:0}100%{opacity:1}}@keyframes fade-in{0%{opacity:0}100%{opacity:1}}",
  "fade-out": ".fade-out{-webkit-animation:fade-out;animation:fade-out}@-webkit-keyframes fade-out{0%{opacity:1}100%{opacity:0}}@keyframes fade-out{0%{opacity:1}100%{opacity:0}}",
  "slide-in-blurred-top": ".slide-in-blurred-top{-webkit-animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both;animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both}@-webkit-keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}@keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}",
  "slide-in-left": ".slide-in-left{-webkit-animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both;animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both}@-webkit-keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}@keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}",
  "slide-out-left": ".slide-out-left{-webkit-animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both;animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both}@-webkit-keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}@keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}"
}, APIKitAnimation = (a) => {
  const {
    enter: u,
    exit: c,
    children: l,
    tag: v = "div",
    direction: p = "normal",
    duration: _ = 500,
    id: I,
    type: P
  } = a, $ = I ? `${P}-${I}` : `${P}-api-kit-animation`;
  return /* @__PURE__ */ React.createElement("div", {
    style: {
      height: "100%",
      width: "100%"
    }
  }, /* @__PURE__ */ React.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: renderStyle(P, u, c, _, p)
    }
  }), /* @__PURE__ */ React.createElement(SwitchTransition$1, {
    mode: "out-in"
  }, /* @__PURE__ */ React.createElement(CSSTransition$1, {
    key: $,
    addEndListener: (F, H) => {
      F.addEventListener("transitionend", H, !1);
    },
    classNames: {
      enter: `${P}-default-enter`,
      enterActive: u,
      exit: `${P}-default-leave`,
      exitActive: c
    },
    timeout: _
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      height: "100%",
      width: "100%"
    }
  }, l))));
}, renderStyle = (a, u, c, l, v) => `
        body {
          margin: 0;
          padding: 0;
        }
        
        ${Animations[u]}
        
        ${Animations[c]}

        .${a}-transition {
          transition: opacity ${l}ms ease-out};
        }

        .${a}-default-enter {
          opacity: 0;
        }

        .${a}-default-enter.${u} {
          animation-direction: ${v};
          animation-duration: ${l / 1e3}s;
          animation-fill-mode: both;
          animation-timing-function: ease-out;
        }

        .${a}-default-leave {
          opacity: 1;
        }

        .${a}-default-leave.${c} {
          animation-direction: ${v};
          animation-duration: ${l / 1e3}s;
          animation-timing-function: ease-out;
          animation-fill-mode: both;
        }
        `, APIKitAnimation$1 = APIKitAnimation, Background = {
  name: "LS-Background",
  sourceType: "Background",
  create({
    onUpdate: a,
    onRemove: u
  }, {
    sourceProps: c
  }) {
    u(() => {
      clearInterval(p);
    });
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).role;
    let p;
    const _ = ({
      source: H,
      setStartAnimation: j
    }) => {
      var q, z;
      const {
        src: ee,
        type: X,
        meta: ie,
        loop: Q
      } = (H == null ? void 0 : H.sourceProps) || {}, {
        id: ne,
        sourceType: Z
      } = H || {}, [de, he] = React.useState(null), pe = React.useRef(null);
      console.log("Updated current time", (q = pe == null ? void 0 : pe.current) == null ? void 0 : q.currentTime);
      const be = React.useCallback((C) => {
        pe.current = C, he(C ? C.id : null);
      }, []), ke = React.useCallback(() => {
        pe != null && pe.current && pe.current.play().catch(() => {
          var C;
          pe.current.muted = !0, (C = pe.current) == null || C.play();
        });
      }, [ee]), _e = React.useCallback(() => {
        p && clearInterval(p), hasPermission(v, Permission.UpdateProject) && trigger$1("VideoEnded", {
          id: ne,
          category: X
        });
      }, [ee]);
      return React.useEffect(() => {
        ie && (pe != null && pe.current) && de && hasPermission(v, Permission.ManageSelf) && ie != null && ie.time && (pe.current.currentTime = Number(ie == null ? void 0 : ie.time));
      }, [ie == null ? void 0 : ie.time, de]), React.useEffect(() => () => {
        p && clearInterval(p);
      }, [ne]), React.useEffect(() => {
        de ? pe.current && (pe.current.src = ee, pe.current.play().catch(() => {
          pe.current.muted = !0, pe.current.play();
        }), hasPermission(v, Permission.UpdateProject) && (p = setInterval(() => {
          if (pe.current.duration) {
            const C = pe.current.duration - pe.current.currentTime;
            trigger$1("VideoTimeUpdate", {
              category: Z,
              id: ne,
              time: Math.floor(C)
            });
          }
        }, 1e3))) : p && clearInterval(p);
      }, [de]), /* @__PURE__ */ React.createElement(React.Fragment, {
        key: ne
      }, ee && /* @__PURE__ */ React.createElement("video", {
        loop: Q,
        id: ne,
        ref: be,
        style: {
          ...(z = c == null ? void 0 : c.meta) == null ? void 0 : z.style,
          ...ie.style
        },
        onLoadedData: ke,
        onEnded: _e,
        onCanPlay: () => j(!0)
      }));
    }, I = ({
      source: H,
      setStartAnimation: j
    }) => {
      var ne;
      const {
        src: ee,
        meta: X,
        type: ie
      } = (H == null ? void 0 : H.sourceProps) || {}, {
        id: Q
      } = H || {};
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: Q
      }, ee && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...(ne = c == null ? void 0 : c.meta) == null ? void 0 : ne.style,
          ...X == null ? void 0 : X.style
        },
        src: ee,
        onLoad: () => j(!0)
      }));
    }, P = ({
      source: H
    }) => {
      const {
        type: j
      } = H.sourceProps, {
        id: ee
      } = H || {}, [X, ie] = React.useState(!1);
      return useEffect(() => {
        ie(!1);
      }, [ee]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: ee,
        type: "background",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: X ? 1 : 0
        },
        className: "backgroundContainer background-transition"
      }, ee && j === "image" && /* @__PURE__ */ React.createElement(I, {
        source: H,
        setStartAnimation: ie
      }), ee && j === "video" && /* @__PURE__ */ React.createElement(_, {
        source: H,
        setStartAnimation: ie
      })));
    }, $ = createRoot(l), F = (H) => $.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(P, {
      source: H
    })));
    return a((H) => {
      F({
        ...H
      });
    }), {
      root: l
    };
  }
}, Banner = {
  name: "LS-Banner",
  sourceType: "Banner",
  props: {
    bannerId: {
      type: String,
      required: !0
    }
  },
  useSource(a, u) {
    return a.find((c) => c.id === u.bannerId);
  },
  create({
    onUpdate: a,
    onNewSource: u
  }, c) {
    const l = document.createElement("div");
    let v, p, _;
    const I = ({
      currentSource: F,
      latestSource: H
    }) => {
      const [j, ee] = useState(!1), {
        headerText: X,
        bodyText: ie
      } = (H == null ? void 0 : H.value) || {};
      return useEffect(() => {
        window.setTimeout(() => {
          ee(!!F);
        }), F || ee(!1);
      }, [F]), /* @__PURE__ */ React.createElement("div", {
        className: "BannerContainer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "flex-start",
          alignItems: "flex-end",
          transition: "200ms ease all",
          ...j ? {
            zIndex: 2,
            opacity: 1,
            transform: "translateX(0)"
          } : {
            zIndex: 1,
            opacity: 0,
            transform: "translateX(-200px)"
          }
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "Banner",
        style: {
          padding: 10,
          background: "orange",
          width: "fit-content",
          height: "fit-content",
          maxWidth: "84%",
          position: "relative"
        }
      }, X && /* @__PURE__ */ React.createElement("div", {
        className: "Banner-header",
        style: {
          marginBottom: 6
        }
      }, X), ie && /* @__PURE__ */ React.createElement("div", {
        className: "Banner-body"
      }, ie)));
    }, P = createRoot(l), $ = () => P.render(/* @__PURE__ */ React.createElement(React.Fragment, null, _ && _.id !== p.id && /* @__PURE__ */ React.createElement(I, {
      key: _ == null ? void 0 : _.id,
      currentSource: null,
      latestSource: _
    }), /* @__PURE__ */ React.createElement(I, {
      key: p == null ? void 0 : p.id,
      currentSource: v,
      latestSource: p
    })));
    return a(() => {
      $();
    }), u((F) => {
      _ = v, v = F, v && (p = v), $();
    }), {
      root: l
    };
  }
};
var functionExpression = /[\s]*([a-z-]+)[\s]*\([\s]*([^\)]+)[\s]*\)[\s]*/i, floatExpression = /^(\-?\d+\.?\d{0,5})/, toFloat = parseFloat;
function ensurePercent(a) {
  return typeof a == "number" ? a : toFloat(a) * 0.01;
}
function formatPercent(a) {
  return formatFloat(a * 100) + "%";
}
function formatFloat(a) {
  return floatExpression.exec(a.toString())[1];
}
function parseCSSFunction(a) {
  var u = functionExpression.exec(a);
  if (!(!u || !u.length))
    return [u[1]].concat(u[2].split(","));
}
function cssFunction(a, u) {
  var c = Array.prototype.join.call(u, ", ");
  return a + "(" + c + ")";
}
var math = Math, round = math.round;
function roundFloat(a, u) {
  return round(a * u) / u;
}
var _a, RGB = "rgb", HSL = "hsl", converters = (_a = {}, _a[RGB + HSL] = RGBtoHSL, _a[HSL + RGB] = HSLtoRGB, _a), maxChannelValues = {
  r: 255,
  g: 255,
  b: 255,
  h: 360,
  s: 1,
  l: 1,
  a: 1
};
function color(a) {
  return parseHexCode(a) || parseColorFunction(a) || rgb(255, 0, 0);
}
function rgb(a, u, c, l) {
  return new ColorHelper(
    RGB,
    a,
    u,
    c,
    l === void 0 ? 1 : ensurePercent(l),
    l !== void 0
    /* hasAlpha*/
  );
}
function convertHelper(a, u, c) {
  var l = u.f, v = u.r, p = u.g, _ = u.b, I = u.a, P = c === void 0 ? u.o : c;
  return l !== a ? converters[l + a](v, p, _, I, P) : c === void 0 ? u : new ColorHelper(l, v, p, _, I, P);
}
var ColorHelper = (
  /** @class */
  function() {
    function a(u, c, l, v, p, _) {
      var I = this;
      I.f = u, I.o = _;
      var P = u === HSL;
      I.r = clampColor(P ? "h" : "r", c), I.g = clampColor(P ? "s" : "g", l), I.b = clampColor(P ? "l" : "b", v), I.a = clampColor("a", p);
    }
    return a.prototype.toString = function() {
      var u = this, c = u.o, l = u.f, v = u.r, p = u.g, _ = u.b, I = u.a, P, $;
      if (l === RGB)
        P = c ? "rgba" : RGB, $ = [round(v), round(p), round(_)];
      else if (l === HSL)
        P = c ? "hsla" : HSL, $ = [round(v), formatPercent(roundFloat(p, 100)), formatPercent(roundFloat(_, 100))];
      else
        throw new Error("Invalid color format");
      return c && $.push(formatFloat(roundFloat(I, 1e5))), cssFunction(P, $);
    }, a.prototype.toHexString = function() {
      var u = convertHelper(RGB, this);
      return "#" + (toHex(u.r) + toHex(u.g) + toHex(u.b)).toUpperCase();
    }, a.prototype.toHSL = function() {
      return convertHelper(HSL, this, !1);
    }, a.prototype.toHSLA = function() {
      return convertHelper(HSL, this, !0);
    }, a.prototype.toRGB = function() {
      return convertHelper(RGB, this, !1);
    }, a.prototype.toRGBA = function() {
      return convertHelper(RGB, this, !0);
    }, a.prototype.red = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).r;
    }, a.prototype.green = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).g;
    }, a.prototype.blue = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).b;
    }, a.prototype.hue = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).r;
    }, a.prototype.saturation = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).g;
    }, a.prototype.lightness = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).b;
    }, a.prototype.alpha = function() {
      return this.a;
    }, a.prototype.opacity = function() {
      return this.a;
    }, a.prototype.invert = function() {
      var u = this, c = convertHelper(RGB, u);
      return convertHelper(u.f, new a(RGB, 255 - c.r, 255 - c.g, 255 - c.b, u.a, u.o));
    }, a.prototype.lighten = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = maxChannelValues.l, _ = v.b + (c ? p - v.b : p) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, v.g, _, l.a, l.o));
    }, a.prototype.darken = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = v.b - (c ? v.b : maxChannelValues.l) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, v.g, p, l.a, l.o));
    }, a.prototype.saturate = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = maxChannelValues.s, _ = v.g + (c ? p - v.g : p) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, _, v.b, l.a, l.o));
    }, a.prototype.desaturate = function(u, c) {
      var l = this, v = convertHelper(HSL, l), p = maxChannelValues.s, _ = v.g - (c ? v.g : p) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, _, v.b, l.a, l.o));
    }, a.prototype.grayscale = function() {
      return this.desaturate(1);
    }, a.prototype.fade = function(u) {
      var c = this, l = clampColor("a", ensurePercent(u));
      return convertHelper(c.f, new a(c.f, c.r, c.g, c.b, l, !0));
    }, a.prototype.fadeOut = function(u, c) {
      var l = this, v = 1, p = clampColor("a", l.a - (c ? l.a : v) * ensurePercent(u));
      return convertHelper(l.f, new a(l.f, l.r, l.g, l.b, p, !0));
    }, a.prototype.fadeIn = function(u, c) {
      var l = this, v = 1, p = clampColor("a", l.a + (c ? l.a : v) * ensurePercent(u));
      return convertHelper(l.f, new a(l.f, l.r, l.g, l.b, p, !0));
    }, a.prototype.mix = function(u, c) {
      var l = this, v = ensureColor(u), p = convertHelper(RGB, l), _ = convertHelper(RGB, v), I = c === void 0 ? 0.5 : c, P = 2 * I - 1, $ = Math.abs(p.a - _.a), F = ((P * $ === -1 ? P : (P + $) / (1 + P * $)) + 1) / 2, H = 1 - F, j = new a(RGB, round(p.r * F + _.r * H), round(p.g * F + _.g * H), round(p.b * F + _.b * H), p.a * I + _.a * (1 - I), l.o || v.o);
      return convertHelper(this.f, j);
    }, a.prototype.tint = function(u) {
      return rgb(255, 255, 255).mix(this, u);
    }, a.prototype.shade = function(u) {
      return rgb(0, 0, 0).mix(this, u);
    }, a.prototype.spin = function(u) {
      var c = this, l = convertHelper(HSL, c);
      return convertHelper(c.f, new a(HSL, modDegrees(l.r + u), l.g, l.b, c.a, c.o));
    }, a;
  }()
);
function toHex(a) {
  var u = round(a);
  return (u < 16 ? "0" : "") + u.toString(16);
}
function modDegrees(a) {
  return ((a < 0 ? 360 : 0) + a % 360) % 360;
}
function RGBtoHSL(a, u, c, l, v) {
  var p = a / 255, _ = u / 255, I = c / 255, P = Math.min(p, _, I), $ = Math.max(p, _, I), F = (P + $) / 2, H = $ - P, j;
  $ === P ? j = 0 : p === $ ? j = (_ - I) / H : _ === $ ? j = 2 + (I - p) / H : I === $ ? j = 4 + (p - _) / H : j = 0, j = Math.min(j * 60, 360), j < 0 && (j += 360);
  var ee;
  return $ === P ? ee = 0 : F <= 0.5 ? ee = H / ($ + P) : ee = H / (2 - $ - P), new ColorHelper(HSL, j, ee, F, l, v);
}
function HSLtoRGB(a, u, c, l, v) {
  var p = a / 360, _ = u, I = c;
  if (_ === 0) {
    var P = I * 255;
    return new ColorHelper(RGB, P, P, P, l, v);
  }
  for (var $ = I < 0.5 ? I * (1 + _) : I + _ - I * _, F = 2 * I - $, H = 0, j = 0, ee = 0, X = 0; X < 3; X++) {
    var ie = p + 0.3333333333333333 * -(X - 1);
    ie < 0 && ie++, ie > 1 && ie--;
    var P = void 0;
    6 * ie < 1 ? P = F + ($ - F) * 6 * ie : 2 * ie < 1 ? P = $ : 3 * ie < 2 ? P = F + ($ - F) * (2 / 3 - ie) * 6 : P = F, P *= 255, X === 0 ? H = P : X === 1 ? j = P : ee = P;
  }
  return new ColorHelper(RGB, H, j, ee, l, v);
}
function clampColor(a, u) {
  var c = 0, l = maxChannelValues[a];
  return u < c ? c : u > l ? l : u;
}
function ensureColor(a) {
  return a instanceof ColorHelper ? a : color(a);
}
function parseHexCode(a) {
  var u = a.match(/#(([a-f0-9]{6})|([a-f0-9]{3}))$/i);
  if (u) {
    var c = u[1], l = parseInt(c.length === 3 ? c[0] + c[0] + c[1] + c[1] + c[2] + c[2] : c, 16), v = l >> 16 & 255, p = l >> 8 & 255, _ = l & 255;
    return new ColorHelper(RGB, v, p, _, 1, !1);
  }
}
function parseColorFunction(a) {
  var u = parseCSSFunction(a);
  if (!(!u || !(u.length === 4 || u.length === 5))) {
    var c = u[0], l = c === "rgba", v = c === "hsla", p = c === RGB, _ = c === HSL, I = v || l, P;
    if (p || l)
      P = RGB;
    else if (_ || v)
      P = HSL;
    else
      throw new Error("unsupported color string");
    var $ = toFloat(u[1]), F = p || l ? toFloat(u[2]) : ensurePercent(u[2]), H = p || l ? toFloat(u[3]) : ensurePercent(u[3]), j = I ? toFloat(u[4]) : 1;
    return new ColorHelper(P, $, F, H, j, I);
  }
}
const of = color, transparent = color("rgba(0,0,0,0)"), white = color("#ffffff"), black = color("#000000"), weights = {
  primary: {
    50: "#EAFAF5",
    100: "#D5F6EB",
    200: "#ABEDD7",
    300: "#82E3C3",
    400: "#58DAAF",
    500: "#26AD80",
    600: "#25A77C",
    700: "#1C7D5D",
    800: "#12543E"
  },
  secondary: {
    50: "#FBEAEA",
    100: "#F7D4D4",
    200: "#EFA9A9",
    300: "#E77E7E",
    400: "#FF6F64",
    500: "#E9554A",
    600: "#CB362B",
    700: "#811818",
    800: "#561010"
  },
  neutral: {
    0: "#ffffff",
    10: "#f5f5f5",
    200: "#d9d9d9",
    300: "#bababa",
    350: "#999999",
    400: "#9e9e9e",
    500: "#808080",
    600: "#666666",
    700: "#4d4d4d",
    800: "#303030",
    900: "#141414",
    1e3: "#000000"
  },
  warning: {
    400: "#FFC28A",
    500: "#FFAE64",
    600: "#F29540"
  }
}, types = Object.keys(weights), weight = (a) => (u) => {
  const c = weights[a];
  if (c[u])
    return c[u];
  const l = Object.keys(weights.primary).map(Number), v = l.find((p) => u <= p);
  return v ? c[v] : c[l.slice(l.length - 1)[0]];
}, primary = weight("primary"), neutral = weight("neutral"), secondary = weight("secondary"), warning = weight("warning"), lightstream = color("#26ad80"), twitch = color("#9156ff"), linkedin = color("#2867b2"), youtube = color("#ff0000"), facebook = color("#1877f2"), twitter = color("#1da1f2"), Color = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  black,
  color,
  facebook,
  lightstream,
  linkedin,
  neutral,
  of,
  primary,
  secondary,
  transparent,
  twitch,
  twitter,
  types,
  warning,
  white,
  youtube
}, Symbol.toStringTag, { value: "Module" })), YouTube = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z"
})), YouTubeDuo = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("rect", {
  x: "8",
  y: "9",
  width: "9",
  height: "7",
  fill: neutral(0)
}), /* @__PURE__ */ React.createElement("path", {
  d: "M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z"
})), Facebook = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M15.4863 13.3125L15.8965 10.6172H13.2891V8.85938C13.2891 8.09766 13.6406 7.39453 14.8125 7.39453H16.0137V5.08008C16.0137 5.08008 14.9297 4.875 13.9043 4.875C11.7656 4.875 10.3594 6.19336 10.3594 8.53711V10.6172H7.95703V13.3125H10.3594V19.875H13.2891V13.3125H15.4863Z"
})), FacebookCircle = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.2656 12.375C19.2656 8.36133 16.0137 5.10938 12 5.10938C7.98633 5.10938 4.73438 8.36133 4.73438 12.375C4.73438 16.0078 7.37109 19.0254 10.8574 19.5527V14.4844H9.01172V12.375H10.8574V10.793C10.8574 8.97656 11.9414 7.95117 13.582 7.95117C14.4023 7.95117 15.2227 8.09766 15.2227 8.09766V9.88477H14.3145C13.4062 9.88477 13.1133 10.4414 13.1133 11.0273V12.375H15.1348L14.8125 14.4844H13.1133V19.5527C16.5996 19.0254 19.2656 16.0078 19.2656 12.375Z"
})), Twitch = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z"
})), TwitchDuo = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19 6.5H9L8.8125 17.5H13.5L19 13V6.5Z",
  fill: neutral(0)
}), /* @__PURE__ */ React.createElement("path", {
  d: "M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z"
})), Twitter = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M20.6681 7.98749C20.6806 8.16248 20.6806 8.33751 20.6806 8.5125C20.6806 13.85 16.6197 20 9.1976 20C6.91098 20 4.78681 19.3375 3 18.1875C3.32489 18.225 3.63723 18.2375 3.97462 18.2375C5.86136 18.2375 7.59821 17.6 8.98518 16.5125C7.21086 16.475 5.72393 15.3125 5.21162 13.7125C5.46155 13.75 5.71143 13.775 5.97386 13.775C6.33621 13.775 6.69859 13.725 7.03594 13.6375C5.18666 13.2625 3.79966 11.6375 3.79966 9.67499V9.62501C4.33693 9.92501 4.96174 10.1125 5.62393 10.1375C4.53685 9.41247 3.82466 8.17498 3.82466 6.77497C3.82466 6.02499 4.02454 5.33749 4.37443 4.73748C6.36117 7.18748 9.34753 8.78745 12.6962 8.96248C12.6337 8.66248 12.5962 8.35001 12.5962 8.03751C12.5962 5.81248 14.3955 4 16.6322 4C17.7942 4 18.8438 4.4875 19.581 5.275C20.4931 5.10001 21.3678 4.76249 22.1425 4.3C21.8426 5.23752 21.2054 6.02502 20.3682 6.52499C21.1804 6.43753 21.9676 6.21248 22.6923 5.90001C22.1426 6.69998 21.4553 7.41245 20.6681 7.98749Z"
})), LinkedIn = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.2 3H4.8C3.81 3 3.009 3.81 3.009 4.8L3 19.2C3 20.19 3.81 21 4.8 21H19.2C20.19 21 21 20.19 21 19.2V4.8C21 3.81 20.19 3 19.2 3ZM8.4 18.3H5.7V10.2H8.4V18.3ZM7.05 8.679C6.15 8.679 5.421 7.95 5.421 7.05C5.421 6.15 6.15 5.421 7.05 5.421C7.95 5.421 8.679 6.15 8.679 7.05C8.679 7.95 7.95 8.679 7.05 8.679ZM18.3 18.3H15.6V13.53C15.6 12.783 14.997 12.18 14.25 12.18C13.503 12.18 12.9 12.783 12.9 13.53V18.3H10.2V10.2H12.9V11.28C13.368 10.524 14.331 10.02 15.15 10.02C16.887 10.02 18.3 11.433 18.3 13.17V18.3Z"
})), Lightstream = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0.144 0 27.712 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M16.0369 12.1232L14 15.6518L11.5642 11.4335L6.27356 10.6176L14 24L20.4627 12.805L16.0369 12.1232Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M9.74033 8.27418L7.37317 4.17409H20.6268L19.0921 6.83194L24.3827 6.01602L27.8558 0H0.144165L5.31453 8.95665L9.74033 8.27418Z"
})), LightstreamWithText = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 3000 524"
}, /* @__PURE__ */ React.createElement("polygon", {
  points: "330.56 263.5 299.73 316.91 262.86 253.06 182.78 240.71 299.73 443.27 397.55 273.82 330.56 263.5"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "235.25 205.24 199.42 143.18 400.03 143.18 376.8 183.41 456.88 171.06 509.45 80 90 80 168.26 215.57 235.25 205.24"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M646.32,345.72h94.91v13.73H630V167.26h16.36Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M846.24,359.45H830V167.26h16.23Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1091.16,336.61q-8.45,12-26.46,18.74t-40.33,6.73q-22.57,0-40.13-10.82t-27.19-30.62q-9.64-19.8-9.77-45.41V250.95q0-40,20.2-63.16t54.25-23.17q29.69,0,47.78,15.11T1091,221.38h-16.24q-3.56-21.18-17.23-32.11t-35.7-10.92q-26.92,0-42.64,19.15t-15.71,54v22.72q0,21.93,7.46,38.77t21.38,26.09q13.92,9.25,32,9.25,21,0,36-6.6,9.76-4.36,14.52-10.16V282h-51.61V268.24h67.85Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1333.71,359.45h-16.37V278.11H1207.53v81.33h-16.23V167.26h16.23v97.12h109.81V167.26h16.37Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1563.2,181h-65.87V359.45H1481.1V181h-65.73V167.26H1563.2Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1990.75,181h-65.87V359.45h-16.23V181h-65.73V167.26h147.83Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M2147.65,279.33h-55.84v80.12h-16.36V167.26h62.43q30.75,0,48,14.9t17.29,41.66a52,52,0,0,1-10.83,32.56q-10.82,14.11-29,19.51l48,81.83v1.72h-17.29Zm-55.84-13.73h49.76q20.45,0,32.86-11.63t12.41-30.14q0-20.36-12.93-31.59T2137.61,181h-45.8Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M2407.62,278.11h-89.88v67.61h103.35v13.73H2301.5V167.26h118.92V181H2317.73v83.39h89.88Z"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "2892.79 183.67 2892.79 183.67 2816.23 326.97 2724.06 154.45 2724.06 189.54 2724.06 359.75 2739.67 359.75 2739.67 218.3 2816.26 359.42 2892.79 218.32 2892.79 359.75 2908.4 359.75 2908.4 189.54 2908.4 154.45 2892.79 183.67"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "2649.77 359.45 2569.47 154.54 2569.47 154.53 2569.46 154.53 2569.46 154.53 2569.46 154.54 2489.16 359.45 2506.19 359.45 2569.46 194.32 2632.74 359.45 2649.77 359.45"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1764.57,287q-6.73-10.56-20.06-18.15a131.55,131.55,0,0,0-21.47-9.18l-7.64,13.49q19.65,6.61,28.32,13.77,11.22,9.3,11.22,25.28,0,16.37-13.6,26.26t-36,9.9c-11.35,0-21.05-1.94-29.35-5.51l-7,12.33a94,94,0,0,0,36.33,6.91q29.7,0,47.85-13.73t18.15-36.43Q1771.3,297.55,1764.57,287Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1659.11,250.93c7.28,5.25,18,10.18,32.13,14.79l7.72-13.38q-21-6.41-31.29-14.49Q1655.95,228.61,1656,214q0-15.83,13-25.66t35-9.83c13.12,0,23.78,3.19,32.26,9.21l7.23-12.51c-1.71-1-3.43-2.1-5.3-3q-15.09-7.38-34.18-7.38-28.19,0-46.31,13.76t-18.11,35.77Q1639.62,237,1659.11,250.93Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1744.34,268.78a129.23,129.23,0,0,0-21.68-9.32l-7.79,13.49c13.28,4.44,22.87,9.06,28.68,13.88q11.2,9.29,11.2,25.23,0,16.33-13.57,26.21t-36,9.88c-11.8,0-21.85-2-30.34-5.91l-7.08,12.26.2.1a93.63,93.63,0,0,0,37.22,7.25q29.64,0,47.75-13.7t18.11-36.36q0-14.36-6.72-24.9T1744.34,268.78Z"
})), IconMap = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Facebook,
  FacebookCircle,
  Lightstream,
  LightstreamWithText,
  LinkedIn,
  Twitch,
  TwitchDuo,
  Twitter,
  YouTube,
  YouTubeDuo
}, Symbol.toStringTag, { value: "Module" })), nudge = (a) => {
  if (a.nudgeUp || a.nudgeDown || a.nudgeRight || a.nudgeLeft)
    return {
      position: "relative",
      top: a.nudgeDown,
      left: a.nudgeRight,
      right: a.nudgeLeft,
      bottom: a.nudgeUp
    };
}, SVGWrapper = ({
  children: a,
  width: u,
  height: c,
  color: l,
  colorWeight: v = 0,
  marginLeft: p,
  marginTop: _,
  marginRight: I,
  marginBottom: P,
  className: $,
  ...F
}) => (l && Color[l](v), /* @__PURE__ */ React.createElement("div", {
  className: $,
  style: {
    ...nudge(F),
    display: "flex",
    justifyContent: "center",
    flexBasis: u || "auto",
    flexShrink: 0,
    width: u,
    height: c || u && "fit-content",
    marginLeft: p,
    marginTop: _,
    marginBottom: P,
    marginRight: I
  }
}, a)), Icon = ({
  name: a,
  ...u
}) => /* @__PURE__ */ React.createElement(SVGWrapper, {
  ...u
}, IconMap[a]), Icon$1 = Icon, dragImageSvg = `
  <svg height="75" width="120" viewBox="0 0 120 75" xmlns="http://www.w3.org/2000/svg" style="">
    <rect width="120" height="75" rx="3" style="
      opacity: 0.4;
      stroke: white;
      stroke-width: 3px;
      stroke-opacity: 0.7;
    "/>
  </svg>`;
let dragImage;
const loadDragImage = () => dragImage || (dragImage = new Image(), dragImage.src = URL.createObjectURL(new Blob([dragImageSvg], {
  type: "image/svg+xml"
})), dragImage);
class ErrorBoundary extends React.Component {
  constructor(u) {
    super(u), this.state = {
      error: null
    };
  }
  componentDidCatch(u, c) {
    log.warn(u, c);
  }
  static getDerivedStateFromError() {
    return {
      error: !0
    };
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
const onDrop = async (a, u) => {
  u.preventDefault(), u.stopPropagation();
  const {
    dropNodeId: c,
    dropType: l,
    project: v
  } = a, p = u.dataTransfer.getData("text/plain");
  if (log.debug("Compositor: Dropping", {
    dropType: l,
    dragNodeId: p,
    dropNodeId: c
  }), c === p)
    return;
  const [_, I, P, $] = await Promise.all([v.compositor.get(p), v.compositor.get(c), v.compositor.getParent(p), v.compositor.getParent(c)]);
  if (l === "layout")
    return P.id === c ? void 0 : CoreContext.Command.moveNode({
      projectId: v.id,
      nodeId: _.id,
      parentId: I.id
    });
  if (P.id !== ($ == null ? void 0 : $.id))
    return CoreContext.Command.swapNodes({
      projectId: v.id,
      nodeAId: _.id,
      nodeBId: I.id
    });
  const F = P.children.map((H) => H.id);
  return CoreContext.Command.reorderNodes({
    projectId: v.id,
    parentId: P.id,
    childIds: swapItems(_.id, I.id, F)
  });
};
let foundDropTarget = !1;
const ElementTree = (a) => {
  var de, he;
  const u = useRef(!1), c = useRef(), l = useRef(), v = useRef(), {
    project: p,
    interactive: _ = !0,
    onElementDoubleClick: I,
    checkIsDragTarget: P,
    checkIsDropTarget: $
  } = useContext(CompositorContext), {
    nodeId: F
  } = a, H = p.compositor.get(F);
  if (!H)
    return null;
  const j = CoreContext.compositor.getElement(H), ee = H.props.layout || "Row", X = _ && P(H), ie = _ && $(H);
  let Q = ie ? {
    onDrop: (pe) => (foundDropTarget = !0, onDrop({
      dropType: "layout",
      dropNodeId: H.id,
      project: p
    }, pe)),
    onDragOver: (pe) => {
      var be;
      pe.preventDefault(), pe.stopPropagation(), (be = v.current) == null || be.toggleAttribute("data-layout-drop-target-active", !0);
    },
    onDragLeave: (pe) => {
      var be;
      pe.preventDefault(), pe.stopPropagation(), (be = v.current) == null || be.toggleAttribute("data-layout-drop-target-active", !1);
    }
  } : {}, ne = X ? {
    draggable: !0,
    // If a target is draggable, it will also be treated as
    //  a drop target (swap element positions)
    ondrop: (pe) => (foundDropTarget = !0, onDrop(
      {
        dropType: "transform",
        dropNodeId: H.id,
        project: p
      },
      // @ts-ignore TODO: Convert all to native drag events
      pe
    )),
    ondragstart: (pe) => {
      var be;
      u.current = !0, wrapperEl.toggleAttribute("data-dragging", !0), log.debug("Compositor: Dragging", H.id), foundDropTarget = !1, pe.dataTransfer.setData("text/plain", H.id), pe.dataTransfer.dropEffect = "move", pe.dataTransfer.setDragImage(dragImage, 10, 10), (be = v.current) == null || be.toggleAttribute("data-drag-target-active", !0), window.__dragging = !0;
    },
    ondragend: (pe) => {
      var be;
      u.current = !1, foundDropTarget || (log.info("Compositor: No drop target - deleting node", H), CoreContext.Command.deleteNode({
        nodeId: H.id
      })), wrapperEl.toggleAttribute("data-dragging", !0), log.debug("Compositor: DragEnd", pe), (be = v.current) == null || be.toggleAttribute("data-drag-target-active", !1), wrapperEl.querySelectorAll("[data-item]").forEach((ke) => {
        ke.toggleAttribute("data-drag-target-active", !1), ke.toggleAttribute("data-layout-drop-target-active", !1), ke.toggleAttribute("data-transform-drop-target-active", !1);
      }), window.__dragging = !1;
    },
    ondragover: (pe) => {
      var be;
      pe.preventDefault(), pe.stopPropagation(), !u.current && ((be = v.current) == null || be.toggleAttribute("data-transform-drop-target-active", !0));
    },
    ondragleave: (pe) => {
      var be;
      pe.preventDefault(), pe.stopPropagation(), (be = v.current) == null || be.toggleAttribute("data-transform-drop-target-active", !1);
    }
  } : {};
  useEffect(() => {
    l.current && j && (l.current.appendChild(j.root), Object.assign(l.current.style, {
      width: "100%",
      height: "100%",
      position: "relative",
      overflow: "hidden"
    }), Object.assign(j.root.style, {
      pointerEvents: X ? "all" : "none",
      width: "100%",
      height: "100%",
      position: "relative",
      ...H.props.style || {}
    }));
  }, [l.current, j]), useEffect(() => {
    const pe = X ? () => I(H) : () => {
    };
    return c.current && (Object.assign(c.current, ne), Object.assign(c.current.style, {
      pointerEvents: X ? "all" : "none"
    }), c.current.addEventListener("dblclick", pe)), () => {
      var be;
      (be = c.current) == null || be.removeEventListener("dblclick", pe);
    };
  }, [c.current]);
  const Z = {
    layout: ee,
    ...H.props.layoutProps ?? {}
  };
  return /* @__PURE__ */ React.createElement("div", {
    ref: v,
    "data-id": H.id + "-x",
    "data-item": !0,
    ...X && {
      "data-drag-target": !0
    },
    ...ie && {
      "data-drop-target": !0
    },
    ...Q,
    style: {
      position: "relative",
      width: ((de = H.props.size) == null ? void 0 : de.x) || "100%",
      height: ((he = H.props.size) == null ? void 0 : he.y) || "100%",
      pointerEvents: "none"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    className: "interactive-overlay",
    ref: c,
    style: {
      height: "100%",
      width: "100%",
      position: "absolute",
      zIndex: 2
    }
  }), /* @__PURE__ */ React.createElement("div", {
    className: "item-element",
    style: {
      display: "flex",
      flex: "0 0 auto",
      justifyContent: "center",
      width: "100%",
      height: "100%"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    ref: l
  }), /* @__PURE__ */ React.createElement(ErrorBoundary, null, /* @__PURE__ */ React.createElement("ls-layout", {
    "data-id": H.id + "-x",
    props: JSON.stringify(Z),
    layout: ee
  }, H.children.map((pe) => /* @__PURE__ */ React.createElement(ElementTree, {
    key: pe.id,
    nodeId: pe.id
  }))))));
}, Root = (a) => {
  const {
    project: u
  } = useContext(CompositorContext), [c, l] = useState(null);
  return useEffect(() => (l(u.compositor.renderTree()), CoreContext.onInternal("NodeChanged", () => {
    l(u.compositor.renderTree());
  })), []), useEffect(() => {
    const v = u.compositor.getRoot(), {
      x: p
    } = v.props.size, _ = () => {
      var ee, X, ie;
      const {
        bannerStyle: I = "default",
        primaryColor: P = "#ABABAB",
        showNameBanners: $
      } = u.props ?? {}, F = ((ee = u.props) == null ? void 0 : ee.logoPosition) ?? ((ie = (X = u.props) == null ? void 0 : X.logo) == null ? void 0 : ie.logoPosition) ?? "top-right";
      if (!I || !P || !F)
        return;
      const H = themes[I](P, $, p / 1920), j = themes[F](p / 1920);
      a.setStyle(`${H} ${j}` || "");
    };
    return _(), CoreContext.onInternal("ProjectChanged", _);
  }, [u]), c ? /* @__PURE__ */ React.createElement("div", {
    onDrop: (v) => {
      foundDropTarget = !0, v.preventDefault();
    },
    onDragOver: (v) => {
      v.preventDefault();
    },
    onDragLeave: (v) => {
      v.preventDefault();
    },
    style: {
      userSelect: "none",
      width: `${c.props.size.x + PADDING * 2}px`,
      height: `${c.props.size.y + PADDING * 2}px`,
      margin: PADDING + "px"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      width: "100%",
      height: "100%",
      overflow: "hidden"
    }
  }, /* @__PURE__ */ React.createElement(ElementTree, {
    nodeId: c.id
  }))) : null;
};
let wrapperEl, customStyleEl;
const PADDING = 0, render = (a) => {
  const {
    containerEl: u,
    projectId: c,
    dragAndDrop: l = !1,
    checkDragTarget: v = scenelessProjectDragCheck,
    checkDropTarget: p = scenelessProjectDropCheck
  } = a, _ = getProject(c);
  CoreContext.clients.LayoutApi().subscribeToLayout(_.layoutApi.layoutId), loadDragImage();
  const I = a.onElementDoubleClick ?? (() => {
  });
  if (!u || !_)
    return;
  if (!u.shadowRoot) {
    u.attachShadow({
      mode: "open"
    }), customStyleEl = document.createElement("style");
    const X = document.createElement("style");
    X.textContent = getStyle(), wrapperEl = document.createElement("div"), wrapperEl.id = "compositor-root", Object.assign(wrapperEl.style, {
      width: "100%",
      height: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transformOrigin: "center"
    }), u.shadowRoot.appendChild(X), u.shadowRoot.appendChild(customStyleEl), u.shadowRoot.appendChild(wrapperEl), new ResizeObserver((Q) => {
      H();
    }).observe(u);
  }
  const P = _.compositor.getRoot(), {
    x: $,
    y: F
  } = P.props.size, H = () => {
    let {
      width: X,
      height: ie
    } = u.getBoundingClientRect();
    const Q = X / ie, ne = $ / F;
    let Z;
    X && ie ? ne > Q ? Z = X / ($ + PADDING * 2) : Z = ie / (F + PADDING * 2) : Z = 1, wrapperEl.style.willChange = "transform", wrapperEl.style.transform = `scale(${Z}) translateZ(0)`, window.__scale = Z, ee();
  }, j = createRoot(wrapperEl), ee = () => {
    j.render(/* @__PURE__ */ React.createElement(CompositorProvider, {
      project: _,
      interactive: l,
      onElementDoubleClick: I,
      checkIsDropTarget: p,
      checkIsDragTarget: v
    }, /* @__PURE__ */ React.createElement(Root, {
      setStyle: (X) => {
        customStyleEl.textContent = X;
      }
    })));
  };
  H();
}, scenelessProjectDragCheck = (a) => a.props.name === "Participant" || a.props.sourceType === "RoomParticipant" || a.props.sourceType === "RTMP", scenelessProjectDropCheck = (a) => a.props.name === "Content", CompositorContext = React.createContext({
  interactive: !1,
  project: null,
  checkIsDragTarget: () => !1,
  checkIsDropTarget: () => !1,
  onElementDoubleClick: () => {
  }
}), CompositorProvider = ({
  children: a,
  ...u
}) => /* @__PURE__ */ React.createElement(CompositorContext.Provider, {
  value: {
    ...u
  }
}, a), getStyle = () => `
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Arial';
}

video {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.NameBanner {
  top: 100%;
  transform: translateY(-100%);
  left: 0;
  height: 30px;
  background: linear-gradient(90deg, rgba(0, 0, 0, 0.5) 50%, rgba(0, 0, 0, 0) 100%);
  padding: 0px 0px 0px 10px;
  color: rgba(255, 255, 255, 0.9);
  font-weight: bold;
  line-height: 30px;
  width: 100%;
  font-size: 28px;
  position: absolute;
}

ls-layout[layout="Presentation"][props*="\\"cover\\"\\:true"] > :first-child .NameBanner {
  top: 0% !important;
  transform: translateY(0%) !important;
}

[layout="Layered"] > [data-item] {
  transform: scale(1.003) !important;
}
[layout="Layered"] > [data-item]:nth-child(2) {
  transform: scale(1.0015) !important;
}
[layout="Layered"] > [data-item]:nth-child(1) {
  transform: scale(1) !important;
}

.logo {
  position: absolute !important;
}

#compositor-root[data-dragging] {}

[data-drag-target] {}
[data-drag-target]:hover > .interactive-overlay {
  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.5);
  cursor: grab;
}
[data-drop-target] {}
[data-drop-target]:hover {}
[data-drag-target][data-drag-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.2);
}
[data-drag-target][data-drag-target-active] > .item-element {
  opacity: 0.8;
}
[data-layout-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset yellow;
}
[data-transform-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset white;
}
`;
var BannerStyle = /* @__PURE__ */ ((a) => (a.DEFAULT = "default", a.MINIMAL = "minimal", a.BUBBLE = "bubble", a))(BannerStyle || {});
const themes = {
  "top-left": (a = 1280 / 1920) => `
      .wrapper {
       top:0;
       left:0;
    }`,
  "top-right": (a = 1280 / 1920) => `
      .wrapper {
       top:0;
       right:0;
    }`,
  "bottom-left": (a = 1280 / 1920) => `
      .wrapper {
       bottom:0;
       left:0;
    }`,
  "bottom-right": (a = 1280 / 1920) => `
      .wrapper {
       bottom:0;
       right:0;
    }`,
  default: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = color(a).lightness() < 0.6 ? "#FFF" : "#000", v = color(a).lightness() < 0.6 ? "#FFF" : "#000", p = color(a).lightness() < 0.6 ? "#000" : "#FFF", _ = (I) => I * c + "px";
    return `
      .ChatOverlay {
        background: ${a} !important;
        margin-bottom: ${_(40)} !important;
        transition: 300ms ease all;
        left: 0;

        /* Default Size 4 */
        font-size: ${_(44)} !important;
        padding: ${_(40)} ${_(100)} !important;
        border-radius: ${_(20)} !important;
      }
      
      .ChatOverlay-badge-icon {
          width:${_(32)};
          height: ${_(32)};
          fill: currentcolor;
          color: ${p};
      }

       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${_(6)} ${_(12)} ${_(6)} ${_(6)};
          border-radius: ${_(10)};
          align-items: center;
          border-bottom-left-radius: 0px !important;
          position: relative;
          border: none;
          cursor: pointer;
       }
      
       .ChatOverlay-badge-username {
          color:${p};
          padding:${_(6)};
          font-size:${_(18)};
          font-weight:700;
          text-transform: capitalize; 
       }
       
       .ChatOverlay-badge-container::before {
          content:"";
          width:15px;
          height:15px;
          background-color:${v};
          position: absolute;
          bottom:-14px;
          left:0;
          clip-path:polygon(0 100%, 12% 87%, 26% 73%, 45% 53%, 59% 40%, 71% 28%, 85% 14%, 100% 0, 0 0);
        }
       

       .ChatOverlay-avatar {
          height: ${_(120)};
          width: ${_(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }

      .Banner, .NameBanner, .ChatOverlay {
        background: ${a} !important;
        margin-bottom: ${_(40)} !important;
        transition: 300ms ease all;
        left: 0;

        /* Default Size 4 */
        font-size: ${_(44)} !important;
        padding: ${_(40)} ${_(100)} !important;
        border-top-right-radius: ${_(20)} !important;
        border-bottom-right-radius: ${_(20)} !important;
      }

      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
      }

      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${_(40)} ${_(100)} !important;
        font-size: ${_(44)} !important;
        border-top-right-radius: ${_(20)} !important;
        border-bottom-right-radius: ${_(20)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${_(12)} ${_(30)} !important;
        font-size: ${_(44)} !important;
        border-top-right-radius: ${_(20)} !important;
        border-bottom-right-radius: ${_(20)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${_(12)} ${_(20)} !important;
        font-size: ${_(28)} !important;
        border-top-right-radius: ${_(16)} !important;
        border-bottom-right-radius: ${_(16)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${_(8)} ${_(8)} !important;
        font-size: ${_(20)} !important;
        border-top-right-radius: ${_(8)} !important;
        border-bottom-right-radius: ${_(8)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0;
        transform: translateX(-100%);
      }
    `;
  },
  minimal: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = "white", v = "#fff", p = "#000", _ = (I) => I * c + "px";
    return `

      .ChatOverlay-badge-icon {
          width:${_(32)};
          height: ${_(32)};
          fill: currentcolor;
          color: ${p};
      }

       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${_(6)} ${_(12)} ${_(6)} ${_(6)};
          align-items: center;
          position: relative;
          border: none;
          cursor: pointer;
       }

       .ChatOverlay-badge-username {
          color:${p};
          padding:${_(6)};
          font-size:${_(18)};
          font-weight:700;
          text-transform: capitalize; 
       }

       .ChatOverlay-avatar {
          height: ${_(120)};
          width: ${_(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }


    .Banner, .NameBanner, .ChatOverlay {
        background: ${color(a).fade(color(a).alpha() * 0.7).toString()} !important;
        padding: ${_(40)} ${_(40)} ${_(40)} ${_(60)} !important;
        position: relative !important;
        margin-bottom: ${_(40)} !important;
        transition: 300ms ease all;
        font-size: ${_(34)} !important;
        left: 0;
      }

      .Banner:before, .NameBanner:before, .ChatOverlay:before {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        transition: 300ms ease all;
        opacity: ${color(a).alpha()};
      }
      .Banner:after, .NameBanner:after, .ChatOverlay:after {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        transition: 300ms ease all;
        width: ${_(20)};
        background: ${color(a)};
        opacity: ${color(a).alpha()};
      }
      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
        position: relative;
        z-index: 2;
      }
      .Banner-header {
        font-size: ${_(90)};
        position: relative;
        z-index: 2;
      }
      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${_(40)} ${_(40)} ${_(40)} ${_(60)} !important;
        font-size: ${_(34)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${_(16)} ${_(40)} ${_(16)} ${_(60)} !important;
        font-size: ${_(34)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${_(12)} ${_(24)} ${_(12)} ${_(44)} !important;
        font-size: ${_(24)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${_(12)} ${_(16)} ${_(12)} ${_(36)} !important;
        font-size: ${_(18)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
  },
  bubble: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = color(a).lightness() < 0.6 ? "#FFF" : "#000", v = color(a).lightness() < 0.6 ? "#FFF" : "#000", p = color(a).lightness() < 0.6 ? "#000" : "#FFF", _ = (I) => I * c + "px";
    return `
      .ChatOverlay-badge-icon {
          width:${_(32)};
          height: ${_(32)};
          fill: currentcolor;
          color: ${p};
      }


       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${_(6)} ${_(12)} ${_(6)} ${_(6)};
          align-items: center;
          z-index: 1;
          border: none;
          cursor: pointer;
          top: 0;
          margin-bottom: 2px;
          margin-left: -${_(30)};
          border-radius: 30px;
       }

       .ChatOverlay-badge-username {
          color:${p};
          padding:${_(6)};
          font-size:${_(18)};
          font-weight:700;
          text-transform: capitalize; 
       }

       .ChatOverlayAvatar-container {
          height: ${_(120)};
          width: ${_(120)};
          top: 0;
       }
       .ChatOverlay-avatar {
          height: ${_(120)};
          width: ${_(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }


      .Banner, .ChatOverlay {
        transform: translateX(-50%);
        left: 50%;
        margin-bottom: ${_(40)} !important;
      }

      .Banner, .NameBanner, .ChatOverlay {
        background: ${color(a)} !important;
        color: ${l} !important;
        border-radius: 500px !important;
        transition: 300ms ease all;

        /* Default Style */
        border: 4px solid ${l} !important;
        padding: ${_(40)} ${_(80)} !important;
        font-size: ${_(40)} !important;
      }
      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        text-align: center !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
      }
      .NameBanner {
        transform-origin: 0% 100%;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      ls-layout[layout="Presentation"][props*="\\"cover\\"\\:true"] > :first-child .NameBanner {
        top: 0% !important;
        transform: translateY(0%) !important;
        margin: ${_(20)} ${_(20)};
      }


      .NameBanner[data-size="4"] {
        padding: ${_(40)} ${_(80)} ${_(40)} ${_(80)} !important;
        font-size: ${_(40)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${_(12)} ${_(30)} ${_(12)} ${_(30)} !important;
        font-size: ${_(40)} !important;
        margin: -${_(20)} ${_(20)};
      }
      .NameBanner[data-size="2"] {
        padding: ${_(12)} ${_(30)} ${_(12)} ${_(30)} !important;
        font-size: ${_(26)} !important;
        margin: -${_(8)} ${_(8)};
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${_(8)} ${_(16)} ${_(8)} ${_(16)} !important;
        font-size: ${_(18)} !important;
        border-width: ${_(2)} !important;
        margin: -${_(16)} ${_(8)};
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
  }
}, iconStyles = {
  twitch: {
    icon: "Twitch"
  },
  youtube: {
    icon: "YouTube"
  },
  facebook: {
    icon: "Facebook"
  }
}, fixLink = (a) => !a.startsWith("http:") && !a.startsWith("https:") ? `https://${a}` : a, ChatOverlay = {
  name: "LS-ChatOverlay",
  sourceType: "ChatOverlay",
  create({
    onUpdate: a,
    onEvent: u
  }, c) {
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId), p = v.compositor.getRoot(), {
      x: _
    } = p.props.size, I = (_ ?? 1280) / 1920, P = (Q) => Q * I + "px";
    let $;
    const F = (Q, ne) => {
      const Z = Q.width / ne.width;
      return Q.height / ne.height >= 0.25 && Z >= 0.75 ? 4 : Z >= 0.75 ? 1 : Z >= 0.5 ? -2 : Z > 0.25 ? -3 : -4;
    };
    CoreContext.onInternal("ProjectChanged", () => {
      const {
        bannerStyle: Q
      } = v.props ?? {};
      Q && ie({
        ...$,
        metadata: {
          ...$.metadata,
          bannerStyle: Q
        }
      });
    });
    const H = React.memo((Q) => {
      var ne, Z, de;
      return (Q == null ? void 0 : Q.type) === "emoticon" && ((ne = Q == null ? void 0 : Q.data) == null ? void 0 : ne.type) === "direct" ? /* @__PURE__ */ React.createElement("img", {
        src: (Z = Q == null ? void 0 : Q.data) == null ? void 0 : Z.url,
        style: {
          height: P(36)
        },
        alt: Q == null ? void 0 : Q.text
      }) : (Q == null ? void 0 : Q.type) === "link" ? /* @__PURE__ */ React.createElement("a", {
        style: {
          color: "#FFF",
          wordBreak: "break-all"
        },
        target: "_blank",
        rel: "noreferrer",
        href: fixLink((de = Q == null ? void 0 : Q.data) == null ? void 0 : de.url)
      }, Q == null ? void 0 : Q.text) : /* @__PURE__ */ React.createElement("span", null, Q == null ? void 0 : Q.text);
    }), j = (Q) => {
      const ne = {
        height: `${Q.height}`,
        width: `${Q.width}`,
        background: Q.background || "transparent",
        display: "inline-block",
        verticalAlign: "middle",
        borderRadius: "50%",
        fontSize: `${Q.fontSize}`
      };
      return /* @__PURE__ */ React.createElement("div", {
        style: {
          ...ne,
          position: "relative",
          marginRight: Q == null ? void 0 : Q.marginRight
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          left: "50%",
          position: "absolute",
          top: "50%",
          transform: "translate(-50%, -50%)"
        }
      }, Q.username.substring(0, 2).toUpperCase()));
    }, ee = (Q) => {
      const {
        message: ne,
        id: Z,
        username: de,
        metadata: he
      } = Q || {}, [pe, be] = useState(0), {
        index: ke,
        platform: _e,
        avatar: q,
        bannerStyle: z
      } = he || {}, C = useMemo(() => iconStyles[_e], [_e]), b = useRef();
      return useLayoutEffect(() => {
        if (!b.current)
          return;
        const E = () => {
          const O = b.current;
          O && be(F({
            width: O.clientWidth,
            height: O.clientHeight
          }, {
            width: v.compositor.getRoot().props.size.x,
            height: v.compositor.getRoot().props.size.y
          }));
        }, k = new ResizeObserver((O) => {
          E();
        });
        return E(), k.observe(b.current), () => {
          b != null && b.current && k.unobserve(b == null ? void 0 : b.current);
        };
      }, [b.current, v]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: `${Z}_${ke}`,
        type: "chatoverlay",
        enter: APIKitAnimationTypes.SLIDE_IN_LEFT,
        exit: APIKitAnimationTypes.SLIDE_OUT_LEFT,
        duration: 200
      }, /* @__PURE__ */ React.createElement("div", {
        className: "ChatOverlayContainer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "flex-start",
          alignItems: "flex-end",
          marginLeft: z !== BannerStyle.BUBBLE ? "5%" : "0px"
        }
      }, z !== BannerStyle.BUBBLE ? (
        /* It's a ternary operator. If the style is not equal to BannerStyle.BUBBLE.toString(), then it will
        render the first div. Otherwise, it will render the second div. */
        /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%",
            display: "flex"
          }
        }, q ? /* @__PURE__ */ React.createElement("span", {
          style: {
            marginRight: "20px"
          }
        }, /* @__PURE__ */ React.createElement("img", {
          src: q,
          className: "ChatOverlay-avatar"
        })) : /* @__PURE__ */ React.createElement(j, {
          height: P(110),
          width: P(120),
          background: primary(500),
          username: de,
          marginRight: 20,
          fontSize: P(30)
        }), /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%"
          }
        }, de && /* @__PURE__ */ React.createElement("button", {
          className: "ChatOverlay-badge-container"
        }, (C == null ? void 0 : C.icon) && /* @__PURE__ */ React.createElement(Icon$1, {
          className: "ChatOverlay-badge-icon",
          name: C == null ? void 0 : C.icon
        }), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-badge-username"
        }, de)), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay",
          style: {
            padding: 10,
            background: "orange",
            width: "fit-content",
            height: "fit-content",
            maxWidth: "84%",
            position: "relative"
          }
        }, ne && /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-body",
          style: {
            gap: 10,
            display: "flex",
            alignItems: "center",
            flexWrap: "wrap",
            verticalAlign: "middle"
          }
        }, ne.map((E, k) => /* @__PURE__ */ React.createElement(H, {
          key: k,
          ...E
        }))))))
      ) : (
        /* It's a ternary operator. If the style is not equal to BannerStyle.BUBBLE.toString(), then it will
        render the first div. Otherwise, it will render the second div. */
        /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%",
            display: "flex"
          }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay",
          style: {
            padding: 10,
            background: "orange",
            width: "fit-content",
            height: "fit-content",
            maxWidth: "84%",
            position: "relative"
          }
        }, /* @__PURE__ */ React.createElement("div", {
          style: {
            display: "flex",
            marginTop: `-${P(160)}`,
            alignItems: "flex-end",
            padding: `${P(14)} ${P(0)} ${P(14)} ${P(0)}`,
            marginLeft: `${pe * 10}px`
          }
        }, q ? /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlayAvatar-container"
        }, /* @__PURE__ */ React.createElement("img", {
          src: q,
          className: "ChatOverlay-avatar"
        })) : /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlayAvatar-container"
        }, /* @__PURE__ */ React.createElement(j, {
          height: P(120),
          width: P(120),
          background: primary(500),
          username: de,
          fontSize: P(30)
        })), de && /* @__PURE__ */ React.createElement("button", {
          className: "ChatOverlay-badge-container"
        }, (C == null ? void 0 : C.icon) && /* @__PURE__ */ React.createElement(Icon$1, {
          className: "ChatOverlay-badge-icon",
          name: C == null ? void 0 : C.icon
        }), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-badge-username"
        }, de))), ne && /* @__PURE__ */ React.createElement("div", {
          ref: b,
          className: "ChatOverlay-body",
          style: {
            gap: 10,
            alignItems: "center",
            flexWrap: "wrap",
            verticalAlign: "middle"
          }
        }, ne.map((E, k) => /* @__PURE__ */ React.createElement(H, {
          key: k,
          ...E
        })))))
      )));
    }, X = createRoot(l), ie = (Q) => X.render(/* @__PURE__ */ React.createElement(ee, {
      ...Q
    }));
    return a((Q) => {
      const {
        bannerStyle: ne = BannerStyle.DEFAULT
      } = v.props ?? {};
      $ = {
        ...Q,
        metadata: {
          ...Q.metadata,
          bannerStyle: ne
        }
      }, ie($);
    }), {
      root: l
    };
  }
}, Element$1 = {
  name: "Element",
  sourceType: "Element",
  create({
    onUpdate: a
  }, {
    tagName: u
  }) {
    const c = document.createElement(u);
    return a(({
      tagName: l,
      attributes: v = {},
      fields: p = {}
    }) => {
      l === "img" ? (c == null ? void 0 : c.src) !== v.src && Object.keys(v).forEach((_) => {
        c.setAttribute(_, v[_]);
      }) : Object.keys(v).forEach((_) => {
        c.setAttribute(_, v[_]);
      }), Object.keys(p).forEach((_) => {
        Object.assign(c[_], p[_]);
      });
    }), {
      root: c
    };
  }
}, GameSource = {
  name: "LS-Game-Source",
  sourceType: "Game",
  props: {},
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), p = getProject(CoreContext.state.activeProjectId);
    Object.assign(v.style, {
      position: "relative"
    });
    let _, I = l;
    const P = (j, ee) => {
      const X = j / ee.width;
      return X >= 0.5 ? 3 : X > 0.25 ? 2 : X > 0.15 ? 1 : 0;
    }, $ = ({
      props: j,
      source: ee
    }) => {
      var pe, be;
      const X = useRef(), {
        volume: ie = 1,
        isHidden: Q = !1
      } = j || {}, [ne, Z] = useState(0), de = j == null ? void 0 : j.isMuted, he = !(j != null && j.isHidden) && ((pe = ee == null ? void 0 : ee.props) == null ? void 0 : pe.videoEnabled);
      return useEffect(() => {
        X.current && (X.current.play().catch((ke) => {
          document.addEventListener("click", () => {
            var _e;
            return (_e = X.current) == null ? void 0 : _e.play();
          }, {
            once: !0
          });
        }), ee != null && ee.value && (ee == null ? void 0 : ee.value) !== X.current.srcObject ? X.current.srcObject = ee == null ? void 0 : ee.value : ee != null && ee.value || (X.current.srcObject = null));
      }, [X.current, ee == null ? void 0 : ee.value]), useEffect(() => {
        !j && X.current && (X.current.srcObject = null, X.current = null);
      }, [j]), useLayoutEffect(() => {
        if (!X.current)
          return;
        const ke = () => {
          const q = X.current;
          q && Z(P(q.clientWidth, {
            width: p.compositor.getRoot().props.size.x,
            height: p.compositor.getRoot().props.size.y
          }));
        }, _e = new ResizeObserver((q) => {
          ke();
        });
        return ke(), _e == null || _e.observe(X.current), () => {
          X.current && (_e == null || _e.unobserve(X.current), X.current.srcObject = null);
        };
      }, [X.current, p]), useEffect(() => {
        X.current && (X.current.volume = ie);
      }, [X.current, ie]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: he ? "0" : "1"
        }
      }, !!ee && /* @__PURE__ */ React.createElement("div", {
        style: {
          borderRadius: "50%",
          background: "#555",
          width: "70px",
          height: "70px",
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1em"
        }
      }, "Game Source")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%",
          ...!!((be = ee == null ? void 0 : ee.props) != null && be.mirrored) && {
            transform: "scaleX(-1)"
          }
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: X,
        autoPlay: !0,
        muted: de,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: he ? "1" : "0",
          objectFit: "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })), !!(ee != null && ee.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        className: "NameBannerContainer",
        style: {
          width: "100%",
          height: "100%",
          position: "absolute"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner",
        "data-size": ne,
        style: {
          padding: "12px 30px",
          width: "fit-content",
          height: "fit-content",
          top: "100%",
          transform: "translateY(-100%)",
          left: 0
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner-body"
      }, ee == null ? void 0 : ee.props.displayName))));
    }, F = createRoot(v), H = () => F.render(/* @__PURE__ */ React.createElement($, {
      source: _,
      props: I
    }));
    return a((j) => {
      I = j, H();
    }), u((j) => {
      _ = j, H();
    }), c((j) => {
      I = j, H();
    }), {
      root: v
    };
  }
}, Logo = {
  name: "LS-Logo",
  sourceType: "Logo",
  create({
    onUpdate: a
  }, {
    sourceProps: u
  }) {
    const c = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {
      x: p
    } = v.props.size, _ = (p ?? 1280) / 1920, I = (H) => H * _ + "px", P = ({
      source: H
    }) => {
      var pe;
      const {
        src: j,
        meta: ee
      } = (H == null ? void 0 : H.sourceProps) || {}, {
        id: X
      } = H || {}, [ie, Q] = React.useState(!1);
      useEffect(() => {
        Q(!1);
      }, [X]);
      const {
        offsetX: ne = 40,
        offsetY: Z = 40,
        height: de = 135,
        width: he = 240
      } = (ee == null ? void 0 : ee.style) || {};
      return /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        type: "logo",
        id: X,
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: ie ? 1 : 0,
          width: "100%",
          height: "100%"
        },
        className: "logo-transition"
      }, j && /* @__PURE__ */ React.createElement("div", {
        className: "logo wrapper",
        style: {
          padding: `${I(Z)} ${I(ne)}`
        }
      }, /* @__PURE__ */ React.createElement("img", {
        style: {
          height: "100%",
          width: "100%",
          maxHeight: de ? I(de) : "none",
          maxWidth: he ? I(he) : "none",
          ...(pe = u == null ? void 0 : u.meta) == null ? void 0 : pe.style,
          ...ee == null ? void 0 : ee.style
        },
        src: j,
        onLoad: () => Q(!0)
      }))));
    }, $ = createRoot(c), F = (H) => $.render(/* @__PURE__ */ React.createElement(P, {
      source: H
    }));
    return a((H) => {
      F({
        ...H
      });
    }), {
      root: c
    };
  }
}, Iframe = ({
  url: a,
  allowFullScreen: u,
  position: c,
  display: l,
  height: v,
  width: p,
  overflow: _,
  styles: I,
  onLoad: P,
  id: $,
  frameBorder: F,
  className: H,
  name: j,
  target: ee,
  iframeRef: X,
  children: ie,
  src: Q
}) => {
  const ne = Object.assign({
    src: Q || a,
    target: ee || null,
    style: {
      position: c || null,
      display: l || "block",
      overflow: _ || null,
      ...I
    },
    name: j || null,
    className: H || null,
    id: $ || null,
    onLoad: P || null,
    height: v || "100%",
    width: p || "100%",
    allow: "autoplay"
  });
  let Z = /* @__PURE__ */ Object.create(null);
  for (let de of Object.keys(ne))
    ne[de] != null && (Z[de] = ne[de]);
  for (let de of Object.keys(Z.style))
    Z.style[de] == null && delete Z.style[de];
  if (u)
    if ("allow" in Z) {
      const de = Z.allow.replace("fullscreen", "");
      Z.allow = `fullscreen ${de.trim()}`.trim();
    } else
      Z.allow = "fullscreen";
  return F >= 0 && (Z.style.hasOwnProperty("border") || (Z.style.border = F)), /* @__PURE__ */ React.createElement(React.Fragment, null, ie ? /* @__PURE__ */ React.createElement("iframe", {
    ref: X,
    ...Z
  }, ie) : /* @__PURE__ */ React.createElement("iframe", {
    ref: X,
    ...Z
  }));
}, Iframe$1 = Iframe, Overlay = {
  name: "LS-Overlay",
  sourceType: "Overlay",
  create({
    onUpdate: a,
    onRemove: u
  }, {
    sourceProps: c
  }) {
    u(() => {
      clearInterval(p);
    });
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).role;
    let p;
    const _ = ({
      source: j,
      setStartAnimation: ee
    }) => {
      const {
        src: X,
        meta: ie,
        height: Q,
        width: ne
      } = (j == null ? void 0 : j.sourceProps) || {}, Z = React.useRef(null);
      useEffect(() => {
        Z.current && (Z.current.style.removeProperty("transformOrigin"), Z.current.style.removeProperty("transform"));
      }, [X]);
      const de = () => {
        if (Z.current) {
          const pe = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {
            x: be,
            y: ke
          } = pe.props.size;
          let _e = Z.current.clientWidth, q = Z.current.clientHeight, z;
          _e && q ? z = Math.min(be / _e, ke / q) : z = 1, Z.current.style.willChange = "transform", Z.current.style.transformOrigin = "0 0", Z.current.style.transform = `scale(${z}) translateZ(0)`, ee(!0);
        }
      };
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Iframe$1, {
        key: j.id,
        url: X,
        frameBorder: 0,
        iframeRef: Z,
        height: Q,
        width: ne,
        onLoad: de,
        styles: {
          ...ie == null ? void 0 : ie.style
        }
      }));
    }, I = ({
      source: j,
      setStartAnimation: ee
    }) => {
      var z;
      const {
        src: X,
        type: ie,
        meta: Q,
        loop: ne
      } = (j == null ? void 0 : j.sourceProps) || {}, {
        id: Z,
        sourceType: de
      } = j || {}, [he, pe] = React.useState(null), be = React.useRef(null);
      console.log("Updated current time", (z = be == null ? void 0 : be.current) == null ? void 0 : z.currentTime);
      const ke = React.useCallback((C) => {
        be.current = C, pe(C ? C.id : null);
      }, []), _e = React.useCallback(() => {
        be != null && be.current && be.current.play().catch(() => {
          var C;
          be.current.muted = !0, (C = be.current) == null || C.play();
        });
      }, [X]), q = React.useCallback(() => {
        p && clearInterval(p), hasPermission(v, Permission.UpdateProject) && trigger$1("VideoEnded", {
          id: Z,
          category: ie
        });
      }, [X]);
      return React.useEffect(() => {
        Q && (be != null && be.current) && he && hasPermission(v, Permission.ManageSelf) && Q != null && Q.time && (be.current.currentTime = Number(Q == null ? void 0 : Q.time));
      }, [Q == null ? void 0 : Q.time, he]), React.useEffect(() => () => {
        p && clearInterval(p);
      }, [Z]), React.useEffect(() => {
        he ? be.current && (be.current.src = X, be.current.play().catch(() => {
          be.current.muted = !0, be.current.play();
        }), hasPermission(v, Permission.UpdateProject) && (p = setInterval(() => {
          if (be.current.duration) {
            const C = be.current.duration - be.current.currentTime;
            trigger$1("VideoTimeUpdate", {
              category: de,
              id: Z,
              time: Math.floor(C)
            });
          }
        }, 1e3))) : p && clearInterval(p);
      }, [he]), /* @__PURE__ */ React.createElement(React.Fragment, {
        key: Z
      }, X && /* @__PURE__ */ React.createElement("video", {
        loop: ne,
        id: Z,
        ref: ke,
        style: {
          ...c.meta.style,
          ...Q.style
        },
        onLoadedData: _e,
        onEnded: q,
        onCanPlay: () => ee(!0)
      }));
    }, P = ({
      source: j,
      setStartAnimation: ee
    }) => {
      const {
        src: X,
        meta: ie
      } = (j == null ? void 0 : j.sourceProps) || {}, {
        id: Q
      } = j || {};
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: Q
      }, X && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...c.meta.style,
          ...ie.style
        },
        src: X,
        onLoad: () => ee(!0)
      }));
    }, $ = ({
      source: j
    }) => {
      const {
        type: ee
      } = (j == null ? void 0 : j.sourceProps) || {}, {
        id: X
      } = j || {}, [ie, Q] = React.useState(!1);
      return useEffect(() => {
        Q(!1);
      }, [X]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: X,
        type: "overlay",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: ie ? 1 : 0
        },
        className: "overlayContainer overlay-transition"
      }, X && ee === "image" && /* @__PURE__ */ React.createElement(P, {
        source: j,
        setStartAnimation: Q
      }), X && ee === "video" && /* @__PURE__ */ React.createElement(I, {
        source: j,
        setStartAnimation: Q
      }), X && ee === "custom" && /* @__PURE__ */ React.createElement(_, {
        source: j,
        setStartAnimation: Q
      })));
    }, F = createRoot(l), H = (j) => F.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement($, {
      source: j
    })));
    return a((j) => {
      H({
        ...j
      });
    }), {
      root: l
    };
  }
}, RTMPSource = {
  name: "LS-RTMP-Source",
  sourceType: "RTMP",
  props: {},
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), p = getProject(CoreContext.state.activeProjectId);
    getProjectRoom(CoreContext.state.activeProjectId), Object.assign(v.style, {
      position: "relative"
    });
    let _, I = l;
    const P = (j, ee) => {
      const X = j / ee.width;
      return X >= 0.5 ? 3 : X > 0.25 ? 2 : X > 0.15 ? 1 : 0;
    }, $ = ({
      props: j,
      source: ee
    }) => {
      var pe, be;
      const X = useRef(), {
        volume: ie = 1,
        isHidden: Q = !1
      } = j || {}, [ne, Z] = useState(0), de = j == null ? void 0 : j.isMuted, he = !(j != null && j.isHidden) && ((pe = ee == null ? void 0 : ee.props) == null ? void 0 : pe.videoEnabled);
      return useEffect(() => {
        X.current && (X.current.play().catch((ke) => {
          document.addEventListener("click", () => {
            var _e;
            return (_e = X.current) == null ? void 0 : _e.play();
          }, {
            once: !0
          });
        }), ee != null && ee.value && (ee == null ? void 0 : ee.value) !== X.current.srcObject ? X.current.srcObject = ee == null ? void 0 : ee.value : ee != null && ee.value || (X.current.srcObject = null));
      }, [X.current, ee == null ? void 0 : ee.value]), useEffect(() => {
        !j && X.current && (X.current.srcObject = null, X.current = null);
      }, [j]), useLayoutEffect(() => {
        if (!X.current)
          return;
        const ke = () => {
          const q = X.current;
          q && Z(P(q.clientWidth, {
            width: p.compositor.getRoot().props.size.x,
            height: p.compositor.getRoot().props.size.y
          }));
        }, _e = new ResizeObserver((q) => {
          ke();
        });
        return ke(), _e == null || _e.observe(X.current), () => {
          X.current && (_e == null || _e.unobserve(X.current), X.current.srcObject = null);
        };
      }, [X.current, p]), useEffect(() => {
        X.current && (X.current.volume = ie);
      }, [X.current, ie]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: he ? "0" : "1"
        }
      }, !!ee && /* @__PURE__ */ React.createElement("div", {
        style: {
          borderRadius: "50%",
          background: "#555",
          width: "70px",
          height: "70px",
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1em"
        }
      }, "RTMP")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%",
          ...!!((be = ee == null ? void 0 : ee.props) != null && be.mirrored) && {
            transform: "scaleX(-1)"
          }
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: X,
        autoPlay: !0,
        muted: de,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: he ? "1" : "0",
          objectFit: "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })), !!(ee != null && ee.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        className: "NameBannerContainer",
        style: {
          width: "100%",
          height: "100%",
          position: "absolute"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner",
        "data-size": ne,
        style: {
          padding: "12px 30px",
          width: "fit-content",
          height: "fit-content",
          top: "100%",
          transform: "translateY(-100%)",
          left: 0
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner-body"
      }, ee == null ? void 0 : ee.props.displayName))));
    }, F = createRoot(v), H = () => F.render(/* @__PURE__ */ React.createElement($, {
      source: _,
      props: I
    }));
    return a((j) => {
      I = j, H();
    }), u((j) => {
      _ = j, H();
    }), c((j) => {
      I = j, H();
    }), {
      root: v
    };
  }
}, RoomParticipant = {
  name: "LS-Room-Participant",
  sourceType: "RoomParticipant",
  props: {
    isMuted: {
      type: Boolean,
      required: !1,
      default: !1
    },
    volume: {
      type: Number,
      required: !1,
      default: 1
    }
  },
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), p = getProject(CoreContext.state.activeProjectId), _ = getProjectRoom(CoreContext.state.activeProjectId);
    Object.assign(v.style, {
      position: "relative"
    });
    let I, P = l;
    const $ = (ee, X) => {
      const ie = ee / X.width;
      return ie >= 0.5 ? 3 : ie > 0.25 ? 2 : ie > 0.15 ? 1 : 0;
    }, F = ({
      props: ee,
      source: X
    }) => {
      var ke, _e, q;
      const ie = useRef(), {
        volume: Q = 1,
        isHidden: ne = !1
      } = ee || {}, [Z, de] = useState(0), pe = (X == null ? void 0 : X.id) === (_ == null ? void 0 : _.participantId) || ((ke = X == null ? void 0 : X.props) == null ? void 0 : ke.participantId) === (_ == null ? void 0 : _.participantId) || (ee == null ? void 0 : ee.isMuted), be = !(ee != null && ee.isHidden) && ((_e = X == null ? void 0 : X.props) == null ? void 0 : _e.videoEnabled);
      return useEffect(() => {
        ie.current && (ie.current.play().catch((z) => {
          document.addEventListener("click", () => {
            var C;
            return (C = ie.current) == null ? void 0 : C.play();
          }, {
            once: !0
          });
        }), X != null && X.value && (X == null ? void 0 : X.value) !== ie.current.srcObject ? ie.current.srcObject = X == null ? void 0 : X.value : X != null && X.value || (ie.current.srcObject = null));
      }, [ie.current, X == null ? void 0 : X.value]), useEffect(() => {
        !ee && ie.current && (ie.current.srcObject = null, ie.current = null);
      }, [ee]), useLayoutEffect(() => {
        if (!ie.current)
          return;
        const z = () => {
          const b = ie.current;
          b && de($(b.clientWidth, {
            width: p.compositor.getRoot().props.size.x,
            height: p.compositor.getRoot().props.size.y
          }));
        }, C = new ResizeObserver((b) => {
          z();
        });
        return z(), C == null || C.observe(ie.current), () => {
          ie.current && (C == null || C.unobserve(ie.current), ie.current.srcObject = null);
        };
      }, [ie.current, p]), useEffect(() => {
        ie.current && (ie.current.volume = Q);
      }, [ie.current, Q]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: be ? "0" : "1"
        }
      }, (X == null ? void 0 : X.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        style: {
          borderRadius: "50%",
          background: "#555",
          width: "70px",
          height: "70px",
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1em"
        }
      }, (X == null ? void 0 : X.props.displayName.slice(0, 1)) || "")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%",
          ...!!((q = X == null ? void 0 : X.props) != null && q.mirrored) && {
            transform: "scaleX(-1)"
          }
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: ie,
        autoPlay: !0,
        muted: pe,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: be ? "1" : "0",
          objectFit: (X == null ? void 0 : X.props.type) === "screen" ? "contain" : "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })), (X == null ? void 0 : X.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        className: "NameBannerContainer",
        style: {
          width: "100%",
          height: "100%",
          position: "absolute"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner",
        "data-size": Z,
        style: {
          padding: "12px 30px",
          width: "fit-content",
          height: "fit-content",
          top: "100%",
          transform: "translateY(-100%)",
          left: 0
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner-body"
      }, X.props.displayName))));
    }, H = createRoot(v), j = () => H.render(/* @__PURE__ */ React.createElement(F, {
      source: I,
      props: P
    }));
    return a((ee) => {
      P = ee, j();
    }), u((ee) => {
      I = ee, j();
    }), c((ee) => {
      P = ee, j();
    }), {
      root: v
    };
  }
}, Transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Background,
  Banner,
  ChatOverlay,
  Element: Element$1,
  GameSource,
  Logo,
  Overlay,
  RTMPSource,
  RoomParticipant
}, Symbol.toStringTag, { value: "Module" }));
class EngineWebsocket {
  constructor(u, c) {
    qt(this, "ws", null);
    qt(this, "sources", /* @__PURE__ */ new Set());
    this.connectSource = u, this.disconnectSource = c, this.connect = this.connect.bind(this), this.handleMessage = this.handleMessage.bind(this);
  }
  connect() {
    const u = this.handleMessage.bind(this);
    this.ws = new WebSocket("ws://127.0.0.1:8000"), this.ws.addEventListener("message", u), this.ws.addEventListener("error", (c) => {
      console.error("Unable to connect to websocket", c);
    }), this.ws.addEventListener("close", () => {
      var c, l;
      (c = this.ws) == null || c.removeEventListener("message", u);
      try {
        (l = this.ws) == null || l.close(), this.ws = null;
      } catch {
      }
      setTimeout(() => {
        this.connect();
      }, 1e3);
    });
  }
  disconnect() {
    var u, c;
    (u = this.ws) != null && u.OPEN && ((c = this.ws) == null || c.close());
  }
  handleMessage(u) {
    try {
      const c = JSON.parse(u.data);
      if (c.name === "state") {
        this.sources.clear(), console.info("[Engine]: state", c.payload);
        for (const l of c.payload.sources)
          l.connected && (this.sources.has(l.id) || (this.sources.add(l.id), this.connectSource(l.id)));
      } else
        c.name === "source.disconnect" ? (console.info("[Engine]: source disconnect", c.payload.id), this.sources.delete(c.payload.id), this.disconnectSource(c.payload.id)) : c.name === "source.connect" && (console.info("[Engine]: source connect", c.payload.id), this.sources.add(c.payload.id), this.connectSource(c.payload.id));
    } catch (c) {
      console.error("unable to handle message: ", c);
    }
  }
}
const BroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase, {
  trigger,
  triggerInternal
} = CoreContext, EventType = lib$2.LiveApiModel.EventType, EventSubType = lib$2.LiveApiModel.EventSubType;
let engineSocket;
const init = async (a = {}) => {
  prepareInternalEvents();
  const u = a.env || "prod", c = a.logLevel || "Warn";
  log.getLogger("livekit").setLevel(c), log.setLevel(c), log.info("Initializing Studio SDK...");
  const {
    layouts: v = [],
    transforms: p = [],
    sources: _ = [],
    defaultTransforms: I = {},
    useLatestRenderer: P = !1,
    guestToken: $,
    rendererVersion: F
  } = a, H = new lib$2.ApiStream({
    sdkVersion: CoreContext.version,
    env: u,
    logLevel: c
  }), j = config$2(), ee = start({
    dbAdapter: compositorAdapter,
    transformSettings: {
      defaultTransforms: {
        ...I,
        ...j.defaults.transforms
      }
    }
  });
  CoreContext.config = j, CoreContext.clients = H, CoreContext.compositor = ee, CoreContext.logLevel = c, CoreContext.Request = await Promise.resolve().then(() => requests), CoreContext.Command = await Promise.resolve().then(() => commands$1), CoreContext.rendererVersion = P ? "latest-v2" : F || CoreContext.version, window.__StudioKit = {
    ...CoreContext
  }, ee && (ee.registerSource([...Object.values(Sources), ..._]), ee.registerTransform([...Object.values(Transforms), ...p]), ee.registerLayout([...Object.values(Layouts), ...v]));
  const X = await H.load($);
  let ie;
  X && await H.LiveApi().project.getProject({
    ...X
  }).then((ne) => hydrateProject(ne.project, X.role)).then(async (ne) => {
    setAppState({
      // As a contributor, `user` refers to the collection
      //  that the project belongs to. This will be referenced
      //  when making requests requiring `collectionId`.
      user: {
        id: X.collectionId,
        props: {},
        name: null,
        metadata: {}
      },
      // TODO: Populate
      sources: [],
      projects: [ne],
      activeProjectId: null
    }), ne.isInitial = !0, ie = await CoreContext.Command.setActiveProject({
      projectId: ne.id
    });
  }), H.LiveApi().on(EventType.EVENT_TYPE_COLLECTION, (ne, Z) => {
    switch (log.info("Received: Collection event", Z, ne), Z) {
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("UserChanged", ne.update.collection);
        return;
      }
    }
  }), H.LiveApi().on(EventType.EVENT_TYPE_DESTINATION, (ne, Z) => {
    switch (log.info("Received: Destination event", Z, ne), Z) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const {
          destination: de
        } = ne.create;
        triggerInternal("DestinationAdded", de);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const {
          destination: de
        } = ne.update;
        triggerInternal("DestinationChanged", de);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("DestinationRemoved", ne.delete);
        return;
      }
    }
  }), H.LiveApi().on(EventType.EVENT_TYPE_SOURCE, (ne, Z) => {
    switch (log.info("Received: Source event", Z, ne), Z) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        triggerInternal("SourceAdded", ne.create.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("SourceChanged", ne.update.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("SourceRemoved", ne.delete.sourceId);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_ADD: {
        triggerInternal("ProjectSourceAdded", {
          projectId: ne.add.projectId,
          source: ne.add.source
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_REMOVE: {
        triggerInternal("ProjectSourceRemoved", {
          projectId: ne.remove.projectId,
          sourceId: ne.remove.sourceId
        });
        return;
      }
    }
  }), H.LiveApi().on(EventType.EVENT_TYPE_PROJECT, (ne, Z) => {
    var de;
    switch (log.info("Received: Project event", Z, ne), Z) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const he = ne.create.project;
        if (getProject(he.projectId))
          return;
        triggerInternal("ProjectAdded", he);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const {
          project: he
        } = ne.update, pe = getProject(he.projectId);
        if (!pe)
          return;
        triggerInternal("ProjectChanged", {
          project: he,
          phase: pe.videoApi.phase
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("ProjectRemoved", {
          projectId: ne.delete.projectId
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_STATE: {
        const he = getProject((de = ne.state) == null ? void 0 : de.projectId);
        if (!he)
          return;
        let pe = ne.state.broadcastId;
        if (ne.state.error && trigger("BroadcastError", {
          projectId: he.id,
          broadcastId: ne.state.broadcastId,
          error: ne.state.error
        }), ne.state.phase) {
          const be = ne.state.phase;
          be === BroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING ? trigger("BroadcastStarted", {
            projectId: he.id,
            broadcastId: ne.state.broadcastId
          }) : be === BroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPED && (pe = null, trigger("BroadcastStopped", {
            projectId: he.id,
            broadcastId: ne.state.broadcastId
          }));
        }
        triggerInternal("ProjectChanged", {
          project: he.videoApi.project,
          phase: ne.state.phase,
          broadcastId: pe
        });
        return;
      }
    }
  }), H.LayoutApi().on(lib$2.LayoutApiModel.EventType.EVENT_TYPE_LAYER, (ne, Z) => {
    var de;
    if (Z === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_CREATE) {
      log.debug("Received: Node Insert", ne.create);
      const {
        connectionId: he,
        layoutId: pe
      } = ne.create.requestMetadata;
      if (CoreContext.connectionId === he)
        return;
      const be = layerToNode(ne.create), ke = getProjectByLayoutId(pe), _e = [be, ...ke.compositor.nodes.map(toDataNode$1)], q = toSceneTree(_e, be.id);
      ke.compositor.local.insert(q), triggerInternal("NodeAdded", {
        projectId: ke.id,
        nodeId: be.id
      });
    } else if (Z === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_UPDATE) {
      log.debug("Received: Node Update", ne.update);
      const {
        connectionId: he,
        layoutId: pe,
        updateVersions: be = {}
      } = ((de = ne.update) == null ? void 0 : de.requestMetadata) || {};
      if (CoreContext.connectionId === he)
        return;
      const ke = layerToNode(ne.update);
      if ((latestUpdateVersion[ke.id] || 0) > be[ke.id])
        return log.info("Ignoring node update - updateID is less than latest.");
      latestUpdateVersion[ke.id] = be[ke.id];
      const q = getProjectByLayoutId(pe);
      q.compositor.local.update(ne.update.id, ke.props, ke.childIds), triggerInternal("NodeChanged", {
        projectId: q.id,
        nodeId: ke.id
      });
    } else if (Z === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_DELETE) {
      log.debug("Received: Node Delete", ne.delete);
      const {
        connectionId: he,
        layoutId: pe
      } = ne.delete.requestMetadata;
      if (CoreContext.connectionId === he)
        return;
      const be = getProjectByLayoutId(pe);
      be.compositor.local.remove(ne.delete.id), triggerInternal("NodeRemoved", {
        projectId: be.id,
        nodeId: ne.delete.id
      });
    } else if (Z === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_BATCH) {
      log.debug("Received: Node Batch Update", ne.batch);
      const {
        connectionId: he,
        layoutId: pe,
        updateVersions: be = {}
      } = ne.batch.requestMetadata;
      if (CoreContext.connectionId === he)
        return;
      const ke = getProjectByLayoutId(pe);
      ne.batch.layers.forEach((_e) => {
        try {
          const [q, z] = Object.entries(_e)[0];
          if (q === "create") {
            const C = layerToNode(z);
            ke.compositor.local.insert(C), triggerInternal("NodeAdded", {
              projectId: ke.id,
              nodeId: C.id
            });
          } else if (q === "update") {
            const C = layerToNode(z);
            if ((latestUpdateVersion[C.id] || 0) > be[C.id])
              return log.info("Ignoring node update - updateID is less than latest.");
            latestUpdateVersion[C.id] = be[C.id], ke.compositor.local.update(C.id, C.props, C.childIds), triggerInternal("NodeChanged", {
              projectId: ke.id,
              nodeId: C.id
            });
          } else
            q === "delete" && (ke.compositor.local.remove(z.id), triggerInternal("NodeRemoved", {
              projectId: ke.id,
              nodeId: z.id
            }));
        } catch (q) {
          log.warn("Error handling batch item", q, {
            item: _e
          });
        }
      }), ke && triggerInternal("NodeChanged", {
        projectId: ke.id,
        nodeId: ke.compositor.getRoot().id
      });
    }
  });
  const Q = (ne = {}, Z) => {
    const {
      displayName: de,
      role: he,
      maxDuration: pe = CoreContext.config.defaults.guestTokenDuration,
      projectId: be = CoreContext.state.activeProjectId
    } = ne, ke = getProject(be), _e = de ? {
      direct: {
        displayName: de
      }
    } : {
      exchange: {
        maxDuration: pe
      }
    };
    return H.LiveApi().authentication.createGuestAccessToken({
      projectId: be,
      token: _e,
      url: Z,
      collectionId: ke.videoApi.project.collectionId,
      maxDuration: pe,
      role: he || lib$2.LiveApiModel.Role.ROLE_GUEST
    });
  };
  return {
    ...omit(CoreContext, ["clients", "config", "connectionId", "Request", "state", "trigger"]),
    createDemoToken: async () => (console.warn("createDemoToken() is currently unavailable."), ""),
    createPreviewLink: async (ne = {}) => {
      const {
        maxDuration: Z,
        projectId: de = CoreContext.state.activeProjectId
      } = ne, he = getProject(de), pe = he.videoApi.project.composition.studioSdk.rendererUrl;
      return (await H.LiveApi().authentication.createGuestAccessToken({
        projectId: de,
        token: {
          direct: {
            displayName: "Preview"
          }
        },
        url: pe,
        collectionId: he.videoApi.project.collectionId,
        maxDuration: Z || CoreContext.config.defaults.previewTokenDuration,
        role: lib$2.LiveApiModel.Role.ROLE_VIEWER
      })).url;
    },
    createGuestLink: async (ne, Z = {}) => (await Q(Z, ne)).url,
    createGuestToken: async (ne = {}) => (await Q(ne)).accessToken,
    initialProject: ie,
    load,
    render
  };
};
CoreContext.on("ActiveProjectChanged", ({
  projectId: a
}) => {
  toBaseProject(getProject(a)).role === Role.ROLE_RENDERER && (log.info("Connecting to engine websocket..."), engineSocket && (log.info("Disconnecting existing engine websocket..."), engineSocket.disconnect(), engineSocket = null), engineSocket || (log.info("Creating new engine websocket..."), engineSocket = setupEngineWebsocket(async function(l) {
    triggerInternal("SourceConnected", l);
  }, async function(l) {
    triggerInternal("SourceDisconnected", l);
  }), engineSocket.connect()));
});
function setupEngineWebsocket(a, u) {
  return new EngineWebsocket(a, u);
}
const load = async (a, u) => {
  let c = getBaseUser();
  if (c)
    return log.info("Attempted to load user again - returning existing user"), c;
  if (!a) {
    log.warn("Access token required for load()");
    return;
  }
  log.info("Loading user..."), await CoreContext.clients.load(a);
  const v = await CoreContext.Request.loadUser(u);
  return setAppState({
    user: v.user,
    sources: v.sources,
    projects: v.projects,
    activeProjectId: null
  }), c = getBaseUser(), trigger("UserLoaded", c), c;
};
export {
  commands$1 as Command,
  index as Compositor,
  context as Context,
  events$1 as Events,
  index$1 as Helpers,
  requests as Request,
  index$2 as Room,
  types$2 as SDK,
  init
};
//# sourceMappingURL=index.js.map
