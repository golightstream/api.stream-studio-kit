var qr = Object.defineProperty;
var Gr = (a, u, c) => u in a ? qr(a, u, { enumerable: !0, configurable: !0, writable: !0, value: c }) : a[u] = c;
var ht = (a, u, c) => (Gr(a, typeof u != "symbol" ? u + "" : u, c), c);
import ReactDOM from "react-dom";
import React, { useRef, useState, useEffect, useLayoutEffect, useContext, useMemo } from "react";
let currentSubId = 0;
const subscribers = /* @__PURE__ */ new Map(), subscribersInternal = /* @__PURE__ */ new Map();
function createSubscribe(a = {}) {
  return function(u) {
    if (typeof u != "function")
      return;
    const c = a.internal ? subscribersInternal : subscribers, l = ++currentSubId;
    return c.set(l, u), () => {
      c.delete(l);
    };
  };
}
function createOn(a = {}) {
  return function(u, c) {
    return (a.internal ? subscribeInternal : subscribe)((v, S) => {
      if (u === v)
        return c(S);
    });
  };
}
function createTrigger(a = {}) {
  const u = a.internal ? subscribersInternal : subscribers;
  return async function(c, ...l) {
    let v = {
      type: c,
      payload: l[0]
    };
    const S = a.internal ? "Internal" : "External";
    log$1.info(`${S} Event:`, v), await Promise.all(Array.from(u.values()).map((g) => g(v.type, v.payload)));
  };
}
const trigger$1 = createTrigger(), subscribe = createSubscribe(), on = createOn(), triggerInternal$1 = createTrigger({
  internal: !0
}), subscribeInternal = createSubscribe({
  internal: !0
}), onInternal = createOn({
  internal: !0
}), events$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  on,
  onInternal,
  subscribe,
  subscribeInternal,
  trigger: trigger$1,
  triggerInternal: triggerInternal$1
}, Symbol.toStringTag, { value: "Module" }));
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$1(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
function getAugmentedNamespace(a) {
  if (a.__esModule)
    return a;
  var u = a.default;
  if (typeof u == "function") {
    var c = function l() {
      return this instanceof l ? Reflect.construct(u, arguments, this.constructor) : u.apply(this, arguments);
    };
    c.prototype = u.prototype;
  } else
    c = {};
  return Object.defineProperty(c, "__esModule", { value: !0 }), Object.keys(a).forEach(function(l) {
    var v = Object.getOwnPropertyDescriptor(a, l);
    Object.defineProperty(c, l, v.get ? v : {
      enumerable: !0,
      get: function() {
        return a[l];
      }
    });
  }), c;
}
var loglevel$1 = { exports: {} };
(function(a) {
  (function(u, c) {
    a.exports ? a.exports = c() : u.log = c();
  })(commonjsGlobal$1, function() {
    var u = function() {
    }, c = "undefined", l = typeof window !== c && typeof window.navigator !== c && /Trident\/|MSIE /.test(window.navigator.userAgent), v = [
      "trace",
      "debug",
      "info",
      "warn",
      "error"
    ], S = {}, g = null;
    function E(q, G) {
      var H = q[G];
      if (typeof H.bind == "function")
        return H.bind(q);
      try {
        return Function.prototype.bind.call(H, q);
      } catch {
        return function() {
          return Function.prototype.apply.apply(H, [q, arguments]);
        };
      }
    }
    function _() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function k(q) {
      return q === "debug" && (q = "log"), typeof console === c ? !1 : q === "trace" && l ? _ : console[q] !== void 0 ? E(console, q) : console.log !== void 0 ? E(console, "log") : u;
    }
    function L() {
      for (var q = this.getLevel(), G = 0; G < v.length; G++) {
        var H = v[G];
        this[H] = G < q ? u : this.methodFactory(H, q, this.name);
      }
      if (this.log = this.debug, typeof console === c && q < this.levels.SILENT)
        return "No console available for logging";
    }
    function M(q) {
      return function() {
        typeof console !== c && (L.call(this), this[q].apply(this, arguments));
      };
    }
    function $(q, G, H) {
      return k(q) || M.apply(this, arguments);
    }
    function J(q, G) {
      var H = this, B, Y, ne, Z = "loglevel";
      typeof q == "string" ? Z += ":" + q : typeof q == "symbol" && (Z = void 0);
      function re(D) {
        var W = (v[D] || "silent").toUpperCase();
        if (!(typeof window === c || !Z)) {
          try {
            window.localStorage[Z] = W;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(Z) + "=" + W + ";";
          } catch {
          }
        }
      }
      function oe() {
        var D;
        if (!(typeof window === c || !Z)) {
          try {
            D = window.localStorage[Z];
          } catch {
          }
          if (typeof D === c)
            try {
              var W = window.document.cookie, ee = encodeURIComponent(Z), ae = W.indexOf(ee + "=");
              ae !== -1 && (D = /^([^;]+)/.exec(
                W.slice(ae + ee.length + 1)
              )[1]);
            } catch {
            }
          return H.levels[D] === void 0 && (D = void 0), D;
        }
      }
      function de() {
        if (!(typeof window === c || !Z)) {
          try {
            window.localStorage.removeItem(Z);
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(Z) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      function A(D) {
        var W = D;
        if (typeof W == "string" && H.levels[W.toUpperCase()] !== void 0 && (W = H.levels[W.toUpperCase()]), typeof W == "number" && W >= 0 && W <= H.levels.SILENT)
          return W;
        throw new TypeError("log.setLevel() called with invalid level: " + D);
      }
      H.name = q, H.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, H.methodFactory = G || $, H.getLevel = function() {
        return ne ?? Y ?? B;
      }, H.setLevel = function(D, W) {
        return ne = A(D), W !== !1 && re(ne), L.call(H);
      }, H.setDefaultLevel = function(D) {
        Y = A(D), oe() || H.setLevel(D, !1);
      }, H.resetLevel = function() {
        ne = null, de(), L.call(H);
      }, H.enableAll = function(D) {
        H.setLevel(H.levels.TRACE, D);
      }, H.disableAll = function(D) {
        H.setLevel(H.levels.SILENT, D);
      }, H.rebuild = function() {
        if (g !== H && (B = A(g.getLevel())), L.call(H), g === H)
          for (var D in S)
            S[D].rebuild();
      }, B = A(
        g ? g.getLevel() : "WARN"
      );
      var N = oe();
      N != null && (ne = A(N)), L.call(H);
    }
    g = new J(), g.getLogger = function(G) {
      if (typeof G != "symbol" && typeof G != "string" || G === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var H = S[G];
      return H || (H = S[G] = new J(
        G,
        g.methodFactory
      )), H;
    };
    var V = typeof window !== c ? window.log : void 0;
    return g.noConflict = function() {
      return typeof window !== c && window.log === g && (window.log = V), g;
    }, g.getLoggers = function() {
      return S;
    }, g.default = g, g;
  });
})(loglevel$1);
var loglevelExports$1 = loglevel$1.exports;
const log$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(loglevelExports$1), connectionId$1 = (Math.random() * 1e20).toString(36), version$5 = "3.0.3", CoreContext = {
  config: null,
  // TODO: Rename to client
  clients: null,
  Request: {},
  Command: {},
  on,
  subscribe,
  /** @private @internal */
  onInternal,
  /** @private @internal */
  subscribeInternal,
  /** @private @internal */
  trigger: trigger$1,
  /** @private @internal */
  triggerInternal: triggerInternal$1,
  /** @private @internal */
  state: {},
  compositor: {},
  connectionId: connectionId$1,
  version: version$5,
  /** @private @internal */
  rendererVersion: version$5,
  log: log$1,
  logLevel: null
}, setAppState = (a) => {
  Object.keys(a).forEach((u) => {
    CoreContext.state[u] = a[u];
  });
}, context = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CoreContext,
  default: CoreContext,
  log: log$1,
  setAppState
}, Symbol.toStringTag, { value: "Module" }));
var freeGlobal = typeof global == "object" && global && global.Object === Object && global, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), Symbol$1 = root.Symbol, objectProto$m = Object.prototype, hasOwnProperty$f = objectProto$m.hasOwnProperty, nativeObjectToString$1 = objectProto$m.toString, symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(a) {
  var u = hasOwnProperty$f.call(a, symToStringTag$1), c = a[symToStringTag$1];
  try {
    a[symToStringTag$1] = void 0;
    var l = !0;
  } catch {
  }
  var v = nativeObjectToString$1.call(a);
  return l && (u ? a[symToStringTag$1] = c : delete a[symToStringTag$1]), v;
}
var objectProto$l = Object.prototype, nativeObjectToString = objectProto$l.toString;
function objectToString$7(a) {
  return nativeObjectToString.call(a);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(a) {
  return a == null ? a === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(a) ? getRawTag(a) : objectToString$7(a);
}
function isObjectLike$7(a) {
  return a != null && typeof a == "object";
}
var symbolTag$6 = "[object Symbol]";
function isSymbol$3(a) {
  return typeof a == "symbol" || isObjectLike$7(a) && baseGetTag(a) == symbolTag$6;
}
function arrayMap$1(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length, v = Array(l); ++c < l; )
    v[c] = u(a[c], c, a);
  return v;
}
var isArray$5 = Array.isArray, INFINITY$4 = 1 / 0, symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString(a) {
  if (typeof a == "string")
    return a;
  if (isArray$5(a))
    return arrayMap$1(a, baseToString) + "";
  if (isSymbol$3(a))
    return symbolToString ? symbolToString.call(a) : "";
  var u = a + "";
  return u == "0" && 1 / a == -INFINITY$4 ? "-0" : u;
}
var reWhitespace = /\s/;
function trimmedEndIndex(a) {
  for (var u = a.length; u-- && reWhitespace.test(a.charAt(u)); )
    ;
  return u;
}
var reTrimStart = /^\s+/;
function baseTrim(a) {
  return a && a.slice(0, trimmedEndIndex(a) + 1).replace(reTrimStart, "");
}
function isObject$9(a) {
  var u = typeof a;
  return a != null && (u == "object" || u == "function");
}
var NAN$3 = NaN, reIsBadHex$3 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$3 = /^0b[01]+$/i, reIsOctal$3 = /^0o[0-7]+$/i, freeParseInt$3 = parseInt;
function toNumber$3(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$3(a))
    return NAN$3;
  if (isObject$9(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$9(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = baseTrim(a);
  var c = reIsBinary$3.test(a);
  return c || reIsOctal$3.test(a) ? freeParseInt$3(a.slice(2), c ? 2 : 8) : reIsBadHex$3.test(a) ? NAN$3 : +a;
}
function identity$1(a) {
  return a;
}
var asyncTag = "[object AsyncFunction]", funcTag$3 = "[object Function]", genTag$2 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$4(a) {
  if (!isObject$9(a))
    return !1;
  var u = baseGetTag(a);
  return u == funcTag$3 || u == genTag$2 || u == asyncTag || u == proxyTag;
}
var coreJsData = root["__core-js_shared__"], maskSrcKey = function() {
  var a = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return a ? "Symbol(src)_1." + a : "";
}();
function isMasked(a) {
  return !!maskSrcKey && maskSrcKey in a;
}
var funcProto$3 = Function.prototype, funcToString$3 = funcProto$3.toString;
function toSource(a) {
  if (a != null) {
    try {
      return funcToString$3.call(a);
    } catch {
    }
    try {
      return a + "";
    } catch {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto$2 = Function.prototype, objectProto$k = Object.prototype, funcToString$2 = funcProto$2.toString, hasOwnProperty$e = objectProto$k.hasOwnProperty, reIsNative = RegExp(
  "^" + funcToString$2.call(hasOwnProperty$e).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(a) {
  if (!isObject$9(a) || isMasked(a))
    return !1;
  var u = isFunction$4(a) ? reIsNative : reIsHostCtor;
  return u.test(toSource(a));
}
function getValue(a, u) {
  return a == null ? void 0 : a[u];
}
function getNative(a, u) {
  var c = getValue(a, u);
  return baseIsNative(c) ? c : void 0;
}
var WeakMap$2 = getNative(root, "WeakMap"), objectCreate$1 = Object.create, baseCreate = /* @__PURE__ */ function() {
  function a() {
  }
  return function(u) {
    if (!isObject$9(u))
      return {};
    if (objectCreate$1)
      return objectCreate$1(u);
    a.prototype = u;
    var c = new a();
    return a.prototype = void 0, c;
  };
}();
function apply(a, u, c) {
  switch (c.length) {
    case 0:
      return a.call(u);
    case 1:
      return a.call(u, c[0]);
    case 2:
      return a.call(u, c[0], c[1]);
    case 3:
      return a.call(u, c[0], c[1], c[2]);
  }
  return a.apply(u, c);
}
function copyArray(a, u) {
  var c = -1, l = a.length;
  for (u || (u = Array(l)); ++c < l; )
    u[c] = a[c];
  return u;
}
var HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
function shortOut(a) {
  var u = 0, c = 0;
  return function() {
    var l = nativeNow(), v = HOT_SPAN - (l - c);
    if (c = l, v > 0) {
      if (++u >= HOT_COUNT)
        return arguments[0];
    } else
      u = 0;
    return a.apply(void 0, arguments);
  };
}
function constant(a) {
  return function() {
    return a;
  };
}
var defineProperty$1 = function() {
  try {
    var a = getNative(Object, "defineProperty");
    return a({}, "", {}), a;
  } catch {
  }
}(), baseSetToString = defineProperty$1 ? function(a, u) {
  return defineProperty$1(a, "toString", {
    configurable: !0,
    enumerable: !1,
    value: constant(u),
    writable: !0
  });
} : identity$1;
const baseSetToString$1 = baseSetToString;
var setToString = shortOut(baseSetToString$1);
function arrayEach(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l && u(a[c], c, a) !== !1; )
    ;
  return a;
}
function baseFindIndex$1(a, u, c, l) {
  for (var v = a.length, S = c + (l ? 1 : -1); l ? S-- : ++S < v; )
    if (u(a[S], S, a))
      return S;
  return -1;
}
function baseIsNaN$1(a) {
  return a !== a;
}
function strictIndexOf(a, u, c) {
  for (var l = c - 1, v = a.length; ++l < v; )
    if (a[l] === u)
      return l;
  return -1;
}
function baseIndexOf$1(a, u, c) {
  return u === u ? strictIndexOf(a, u, c) : baseFindIndex$1(a, baseIsNaN$1, c);
}
var MAX_SAFE_INTEGER$2 = 9007199254740991, reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$1(a, u) {
  var c = typeof a;
  return u = u ?? MAX_SAFE_INTEGER$2, !!u && (c == "number" || c != "symbol" && reIsUint$1.test(a)) && a > -1 && a % 1 == 0 && a < u;
}
function baseAssignValue(a, u, c) {
  u == "__proto__" && defineProperty$1 ? defineProperty$1(a, u, {
    configurable: !0,
    enumerable: !0,
    value: c,
    writable: !0
  }) : a[u] = c;
}
function eq(a, u) {
  return a === u || a !== a && u !== u;
}
var objectProto$j = Object.prototype, hasOwnProperty$d = objectProto$j.hasOwnProperty;
function assignValue(a, u, c) {
  var l = a[u];
  (!(hasOwnProperty$d.call(a, u) && eq(l, c)) || c === void 0 && !(u in a)) && baseAssignValue(a, u, c);
}
function copyObject(a, u, c, l) {
  var v = !c;
  c || (c = {});
  for (var S = -1, g = u.length; ++S < g; ) {
    var E = u[S], _ = l ? l(c[E], a[E], E, c, a) : void 0;
    _ === void 0 && (_ = a[E]), v ? baseAssignValue(c, E, _) : assignValue(c, E, _);
  }
  return c;
}
var nativeMax$2 = Math.max;
function overRest(a, u, c) {
  return u = nativeMax$2(u === void 0 ? a.length - 1 : u, 0), function() {
    for (var l = arguments, v = -1, S = nativeMax$2(l.length - u, 0), g = Array(S); ++v < S; )
      g[v] = l[u + v];
    v = -1;
    for (var E = Array(u + 1); ++v < u; )
      E[v] = l[v];
    return E[u] = c(g), apply(a, this, E);
  };
}
function baseRest(a, u) {
  return setToString(overRest(a, u, identity$1), a + "");
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$1(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= MAX_SAFE_INTEGER$1;
}
function isArrayLike$2(a) {
  return a != null && isLength$1(a.length) && !isFunction$4(a);
}
function isIterateeCall(a, u, c) {
  if (!isObject$9(c))
    return !1;
  var l = typeof u;
  return (l == "number" ? isArrayLike$2(c) && isIndex$1(u, c.length) : l == "string" && u in c) ? eq(c[u], a) : !1;
}
var objectProto$i = Object.prototype;
function isPrototype$1(a) {
  var u = a && a.constructor, c = typeof u == "function" && u.prototype || objectProto$i;
  return a === c;
}
function baseTimes$1(a, u) {
  for (var c = -1, l = Array(a); ++c < a; )
    l[c] = u(c);
  return l;
}
var argsTag$4 = "[object Arguments]";
function baseIsArguments(a) {
  return isObjectLike$7(a) && baseGetTag(a) == argsTag$4;
}
var objectProto$h = Object.prototype, hasOwnProperty$c = objectProto$h.hasOwnProperty, propertyIsEnumerable$2 = objectProto$h.propertyIsEnumerable, isArguments$1 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(a) {
  return isObjectLike$7(a) && hasOwnProperty$c.call(a, "callee") && !propertyIsEnumerable$2.call(a, "callee");
};
function stubFalse() {
  return !1;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module, moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2, Buffer$9 = moduleExports$2 ? root.Buffer : void 0, nativeIsBuffer = Buffer$9 ? Buffer$9.isBuffer : void 0, isBuffer$1 = nativeIsBuffer || stubFalse, argsTag$3 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$4 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$2 = "[object Function]", mapTag$5 = "[object Map]", numberTag$4 = "[object Number]", objectTag$5 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$5 = "[object String]", weakMapTag$2 = "[object WeakMap]", arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]", typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0;
typedArrayTags[argsTag$3] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$4] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$2] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$4] = typedArrayTags[objectTag$5] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$5] = typedArrayTags[weakMapTag$2] = !1;
function baseIsTypedArray(a) {
  return isObjectLike$7(a) && isLength$1(a.length) && !!typedArrayTags[baseGetTag(a)];
}
function baseUnary(a) {
  return function(u) {
    return a(u);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module, moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1, freeProcess = moduleExports$1 && freeGlobal.process, nodeUtil = function() {
  try {
    var a = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    return a || freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch {
  }
}(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, objectProto$g = Object.prototype, hasOwnProperty$b = objectProto$g.hasOwnProperty;
function arrayLikeKeys$1(a, u) {
  var c = isArray$5(a), l = !c && isArguments$1(a), v = !c && !l && isBuffer$1(a), S = !c && !l && !v && isTypedArray(a), g = c || l || v || S, E = g ? baseTimes$1(a.length, String) : [], _ = E.length;
  for (var k in a)
    (u || hasOwnProperty$b.call(a, k)) && !(g && // Safari 9 has enumerable `arguments.length` in strict mode.
    (k == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    v && (k == "offset" || k == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    S && (k == "buffer" || k == "byteLength" || k == "byteOffset") || // Skip index properties.
    isIndex$1(k, _))) && E.push(k);
  return E;
}
function overArg$2(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var nativeKeys$1 = overArg$2(Object.keys, Object), objectProto$f = Object.prototype, hasOwnProperty$a = objectProto$f.hasOwnProperty;
function baseKeys$1(a) {
  if (!isPrototype$1(a))
    return nativeKeys$1(a);
  var u = [];
  for (var c in Object(a))
    hasOwnProperty$a.call(a, c) && c != "constructor" && u.push(c);
  return u;
}
function keys$2(a) {
  return isArrayLike$2(a) ? arrayLikeKeys$1(a) : baseKeys$1(a);
}
function nativeKeysIn(a) {
  var u = [];
  if (a != null)
    for (var c in Object(a))
      u.push(c);
  return u;
}
var objectProto$e = Object.prototype, hasOwnProperty$9 = objectProto$e.hasOwnProperty;
function baseKeysIn(a) {
  if (!isObject$9(a))
    return nativeKeysIn(a);
  var u = isPrototype$1(a), c = [];
  for (var l in a)
    l == "constructor" && (u || !hasOwnProperty$9.call(a, l)) || c.push(l);
  return c;
}
function keysIn(a) {
  return isArrayLike$2(a) ? arrayLikeKeys$1(a, !0) : baseKeysIn(a);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(a, u) {
  if (isArray$5(a))
    return !1;
  var c = typeof a;
  return c == "number" || c == "symbol" || c == "boolean" || a == null || isSymbol$3(a) ? !0 : reIsPlainProp.test(a) || !reIsDeepProp.test(a) || u != null && a in Object(u);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
}
function hashDelete(a) {
  var u = this.has(a) && delete this.__data__[a];
  return this.size -= u ? 1 : 0, u;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__", objectProto$d = Object.prototype, hasOwnProperty$8 = objectProto$d.hasOwnProperty;
function hashGet(a) {
  var u = this.__data__;
  if (nativeCreate) {
    var c = u[a];
    return c === HASH_UNDEFINED$2 ? void 0 : c;
  }
  return hasOwnProperty$8.call(u, a) ? u[a] : void 0;
}
var objectProto$c = Object.prototype, hasOwnProperty$7 = objectProto$c.hasOwnProperty;
function hashHas(a) {
  var u = this.__data__;
  return nativeCreate ? u[a] !== void 0 : hasOwnProperty$7.call(u, a);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(a, u) {
  var c = this.__data__;
  return this.size += this.has(a) ? 0 : 1, c[a] = nativeCreate && u === void 0 ? HASH_UNDEFINED$1 : u, this;
}
function Hash(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [], this.size = 0;
}
function assocIndexOf(a, u) {
  for (var c = a.length; c--; )
    if (eq(a[c][0], u))
      return c;
  return -1;
}
var arrayProto$1 = Array.prototype, splice$1 = arrayProto$1.splice;
function listCacheDelete(a) {
  var u = this.__data__, c = assocIndexOf(u, a);
  if (c < 0)
    return !1;
  var l = u.length - 1;
  return c == l ? u.pop() : splice$1.call(u, c, 1), --this.size, !0;
}
function listCacheGet(a) {
  var u = this.__data__, c = assocIndexOf(u, a);
  return c < 0 ? void 0 : u[c][1];
}
function listCacheHas(a) {
  return assocIndexOf(this.__data__, a) > -1;
}
function listCacheSet(a, u) {
  var c = this.__data__, l = assocIndexOf(c, a);
  return l < 0 ? (++this.size, c.push([a, u])) : c[l][1] = u, this;
}
function ListCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0, this.__data__ = {
    hash: new Hash(),
    map: new (Map$1 || ListCache)(),
    string: new Hash()
  };
}
function isKeyable(a) {
  var u = typeof a;
  return u == "string" || u == "number" || u == "symbol" || u == "boolean" ? a !== "__proto__" : a === null;
}
function getMapData(a, u) {
  var c = a.__data__;
  return isKeyable(u) ? c[typeof u == "string" ? "string" : "hash"] : c.map;
}
function mapCacheDelete(a) {
  var u = getMapData(this, a).delete(a);
  return this.size -= u ? 1 : 0, u;
}
function mapCacheGet(a) {
  return getMapData(this, a).get(a);
}
function mapCacheHas(a) {
  return getMapData(this, a).has(a);
}
function mapCacheSet(a, u) {
  var c = getMapData(this, a), l = c.size;
  return c.set(a, u), this.size += c.size == l ? 0 : 1, this;
}
function MapCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.clear(); ++u < c; ) {
    var l = a[u];
    this.set(l[0], l[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$2 = "Expected a function";
function memoize(a, u) {
  if (typeof a != "function" || u != null && typeof u != "function")
    throw new TypeError(FUNC_ERROR_TEXT$2);
  var c = function() {
    var l = arguments, v = u ? u.apply(this, l) : l[0], S = c.cache;
    if (S.has(v))
      return S.get(v);
    var g = a.apply(this, l);
    return c.cache = S.set(v, g) || S, g;
  };
  return c.cache = new (memoize.Cache || MapCache)(), c;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(a) {
  var u = memoize(a, function(l) {
    return c.size === MAX_MEMOIZE_SIZE && c.clear(), l;
  }), c = u.cache;
  return u;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = memoizeCapped(function(a) {
  var u = [];
  return a.charCodeAt(0) === 46 && u.push(""), a.replace(rePropName, function(c, l, v, S) {
    u.push(v ? S.replace(reEscapeChar, "$1") : l || c);
  }), u;
});
function toString$3(a) {
  return a == null ? "" : baseToString(a);
}
function castPath(a, u) {
  return isArray$5(a) ? a : isKey(a, u) ? [a] : stringToPath(toString$3(a));
}
var INFINITY$3 = 1 / 0;
function toKey(a) {
  if (typeof a == "string" || isSymbol$3(a))
    return a;
  var u = a + "";
  return u == "0" && 1 / a == -INFINITY$3 ? "-0" : u;
}
function baseGet(a, u) {
  u = castPath(u, a);
  for (var c = 0, l = u.length; a != null && c < l; )
    a = a[toKey(u[c++])];
  return c && c == l ? a : void 0;
}
function get(a, u, c) {
  var l = a == null ? void 0 : baseGet(a, u);
  return l === void 0 ? c : l;
}
function arrayPush(a, u) {
  for (var c = -1, l = u.length, v = a.length; ++c < l; )
    a[v + c] = u[c];
  return a;
}
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable(a) {
  return isArray$5(a) || isArguments$1(a) || !!(spreadableSymbol && a && a[spreadableSymbol]);
}
function baseFlatten(a, u, c, l, v) {
  var S = -1, g = a.length;
  for (c || (c = isFlattenable), v || (v = []); ++S < g; ) {
    var E = a[S];
    u > 0 && c(E) ? u > 1 ? baseFlatten(E, u - 1, c, l, v) : arrayPush(v, E) : l || (v[v.length] = E);
  }
  return v;
}
function flatten(a) {
  var u = a == null ? 0 : a.length;
  return u ? baseFlatten(a, 1) : [];
}
function flatRest(a) {
  return setToString(overRest(a, void 0, flatten), a + "");
}
var getPrototype$1 = overArg$2(Object.getPrototypeOf, Object);
const getPrototype$2 = getPrototype$1;
var objectTag$4 = "[object Object]", funcProto$1 = Function.prototype, objectProto$b = Object.prototype, funcToString$1 = funcProto$1.toString, hasOwnProperty$6 = objectProto$b.hasOwnProperty, objectCtorString$1 = funcToString$1.call(Object);
function isPlainObject$3(a) {
  if (!isObjectLike$7(a) || baseGetTag(a) != objectTag$4)
    return !1;
  var u = getPrototype$2(a);
  if (u === null)
    return !0;
  var c = hasOwnProperty$6.call(u, "constructor") && u.constructor;
  return typeof c == "function" && c instanceof c && funcToString$1.call(c) == objectCtorString$1;
}
function baseSlice(a, u, c) {
  var l = -1, v = a.length;
  u < 0 && (u = -u > v ? 0 : v + u), c = c > v ? v : c, c < 0 && (c += v), v = u > c ? 0 : c - u >>> 0, u >>>= 0;
  for (var S = Array(v); ++l < v; )
    S[l] = a[l + u];
  return S;
}
function castSlice(a, u, c) {
  var l = a.length;
  return c = c === void 0 ? l : c, !u && c >= l ? a : baseSlice(a, u, c);
}
var rsAstralRange$2 = "\\ud800-\\udfff", rsComboMarksRange$3 = "\\u0300-\\u036f", reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$3 = "\\u20d0-\\u20ff", rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsVarRange$2 = "\\ufe0e\\ufe0f", rsZWJ$2 = "\\u200d", reHasUnicode = RegExp("[" + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + "]");
function hasUnicode(a) {
  return reHasUnicode.test(a);
}
function asciiToArray(a) {
  return a.split("");
}
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$2 = "\\u0300-\\u036f", reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$2 = "\\u20d0-\\u20ff", rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2, rsVarRange$1 = "\\ufe0e\\ufe0f", rsAstral = "[" + rsAstralRange$1 + "]", rsCombo$2 = "[" + rsComboRange$2 + "]", rsFitz$1 = "\\ud83c[\\udffb-\\udfff]", rsModifier$1 = "(?:" + rsCombo$2 + "|" + rsFitz$1 + ")", rsNonAstral$1 = "[^" + rsAstralRange$1 + "]", rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ$1 = "\\u200d", reOptMod$1 = rsModifier$1 + "?", rsOptVar$1 = "[" + rsVarRange$1 + "]?", rsOptJoin$1 = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join("|") + ")" + rsOptVar$1 + reOptMod$1 + ")*", rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsSymbol = "(?:" + [rsNonAstral$1 + rsCombo$2 + "?", rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join("|") + ")", reUnicode = RegExp(rsFitz$1 + "(?=" + rsFitz$1 + ")|" + rsSymbol + rsSeq$1, "g");
function unicodeToArray(a) {
  return a.match(reUnicode) || [];
}
function stringToArray(a) {
  return hasUnicode(a) ? unicodeToArray(a) : asciiToArray(a);
}
function createCaseFirst(a) {
  return function(u) {
    u = toString$3(u);
    var c = hasUnicode(u) ? stringToArray(u) : void 0, l = c ? c[0] : u.charAt(0), v = c ? castSlice(c, 1).join("") : u.slice(1);
    return l[a]() + v;
  };
}
var upperFirst = createCaseFirst("toUpperCase");
function capitalize(a) {
  return upperFirst(toString$3(a).toLowerCase());
}
function arrayReduce(a, u, c, l) {
  var v = -1, S = a == null ? 0 : a.length;
  for (l && S && (c = a[++v]); ++v < S; )
    c = u(c, a[v], v, a);
  return c;
}
function basePropertyOf(a) {
  return function(u) {
    return a == null ? void 0 : a[u];
  };
}
var deburredLetters = {
  // Latin-1 Supplement block.
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  Ç: "C",
  ç: "c",
  Ð: "D",
  ð: "d",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  Ñ: "N",
  ñ: "n",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  Ý: "Y",
  ý: "y",
  ÿ: "y",
  Æ: "Ae",
  æ: "ae",
  Þ: "Th",
  þ: "th",
  ß: "ss",
  // Latin Extended-A block.
  Ā: "A",
  Ă: "A",
  Ą: "A",
  ā: "a",
  ă: "a",
  ą: "a",
  Ć: "C",
  Ĉ: "C",
  Ċ: "C",
  Č: "C",
  ć: "c",
  ĉ: "c",
  ċ: "c",
  č: "c",
  Ď: "D",
  Đ: "D",
  ď: "d",
  đ: "d",
  Ē: "E",
  Ĕ: "E",
  Ė: "E",
  Ę: "E",
  Ě: "E",
  ē: "e",
  ĕ: "e",
  ė: "e",
  ę: "e",
  ě: "e",
  Ĝ: "G",
  Ğ: "G",
  Ġ: "G",
  Ģ: "G",
  ĝ: "g",
  ğ: "g",
  ġ: "g",
  ģ: "g",
  Ĥ: "H",
  Ħ: "H",
  ĥ: "h",
  ħ: "h",
  Ĩ: "I",
  Ī: "I",
  Ĭ: "I",
  Į: "I",
  İ: "I",
  ĩ: "i",
  ī: "i",
  ĭ: "i",
  į: "i",
  ı: "i",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  ĸ: "k",
  Ĺ: "L",
  Ļ: "L",
  Ľ: "L",
  Ŀ: "L",
  Ł: "L",
  ĺ: "l",
  ļ: "l",
  ľ: "l",
  ŀ: "l",
  ł: "l",
  Ń: "N",
  Ņ: "N",
  Ň: "N",
  Ŋ: "N",
  ń: "n",
  ņ: "n",
  ň: "n",
  ŋ: "n",
  Ō: "O",
  Ŏ: "O",
  Ő: "O",
  ō: "o",
  ŏ: "o",
  ő: "o",
  Ŕ: "R",
  Ŗ: "R",
  Ř: "R",
  ŕ: "r",
  ŗ: "r",
  ř: "r",
  Ś: "S",
  Ŝ: "S",
  Ş: "S",
  Š: "S",
  ś: "s",
  ŝ: "s",
  ş: "s",
  š: "s",
  Ţ: "T",
  Ť: "T",
  Ŧ: "T",
  ţ: "t",
  ť: "t",
  ŧ: "t",
  Ũ: "U",
  Ū: "U",
  Ŭ: "U",
  Ů: "U",
  Ű: "U",
  Ų: "U",
  ũ: "u",
  ū: "u",
  ŭ: "u",
  ů: "u",
  ű: "u",
  ų: "u",
  Ŵ: "W",
  ŵ: "w",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Ź: "Z",
  Ż: "Z",
  Ž: "Z",
  ź: "z",
  ż: "z",
  ž: "z",
  Ĳ: "IJ",
  ĳ: "ij",
  Œ: "Oe",
  œ: "oe",
  ŉ: "'n",
  ſ: "s"
}, deburrLetter = basePropertyOf(deburredLetters);
const deburrLetter$1 = deburrLetter;
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsCombo$1 = "[" + rsComboRange$1 + "]", reComboMark = RegExp(rsCombo$1, "g");
function deburr(a) {
  return a = toString$3(a), a && a.replace(reLatin, deburrLetter$1).replace(reComboMark, "");
}
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
function asciiWords(a) {
  return a.match(reAsciiWord) || [];
}
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
function hasUnicodeWord(a) {
  return reHasUnicodeWord.test(a);
}
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos$1 = "['’]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos$1 + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos$1 + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, reUnicodeWord = RegExp([
  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
  rsUpper + "+" + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join("|"), "g");
function unicodeWords(a) {
  return a.match(reUnicodeWord) || [];
}
function words(a, u, c) {
  return a = toString$3(a), u = c ? void 0 : u, u === void 0 ? hasUnicodeWord(a) ? unicodeWords(a) : asciiWords(a) : a.match(u) || [];
}
var rsApos = "['’]", reApos = RegExp(rsApos, "g");
function createCompounder(a) {
  return function(u) {
    return arrayReduce(words(deburr(u).replace(reApos, "")), a, "");
  };
}
var camelCase$2 = createCompounder(function(a, u, c) {
  return u = u.toLowerCase(), a + (c ? capitalize(u) : u);
});
const camelCase$3 = camelCase$2;
function stackClear() {
  this.__data__ = new ListCache(), this.size = 0;
}
function stackDelete(a) {
  var u = this.__data__, c = u.delete(a);
  return this.size = u.size, c;
}
function stackGet(a) {
  return this.__data__.get(a);
}
function stackHas(a) {
  return this.__data__.has(a);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(a, u) {
  var c = this.__data__;
  if (c instanceof ListCache) {
    var l = c.__data__;
    if (!Map$1 || l.length < LARGE_ARRAY_SIZE - 1)
      return l.push([a, u]), this.size = ++c.size, this;
    c = this.__data__ = new MapCache(l);
  }
  return c.set(a, u), this.size = c.size, this;
}
function Stack(a) {
  var u = this.__data__ = new ListCache(a);
  this.size = u.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(a, u) {
  return a && copyObject(u, keys$2(u), a);
}
function baseAssignIn(a, u) {
  return a && copyObject(u, keysIn(u), a);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, Buffer$8 = moduleExports ? root.Buffer : void 0, allocUnsafe = Buffer$8 ? Buffer$8.allocUnsafe : void 0;
function cloneBuffer(a, u) {
  if (u)
    return a.slice();
  var c = a.length, l = allocUnsafe ? allocUnsafe(c) : new a.constructor(c);
  return a.copy(l), l;
}
function arrayFilter(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length, v = 0, S = []; ++c < l; ) {
    var g = a[c];
    u(g, c, a) && (S[v++] = g);
  }
  return S;
}
function stubArray() {
  return [];
}
var objectProto$a = Object.prototype, propertyIsEnumerable$1 = objectProto$a.propertyIsEnumerable, nativeGetSymbols$1 = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols$1 ? function(a) {
  return a == null ? [] : (a = Object(a), arrayFilter(nativeGetSymbols$1(a), function(u) {
    return propertyIsEnumerable$1.call(a, u);
  }));
} : stubArray;
function copySymbols(a, u) {
  return copyObject(a, getSymbols(a), u);
}
var nativeGetSymbols = Object.getOwnPropertySymbols, getSymbolsIn = nativeGetSymbols ? function(a) {
  for (var u = []; a; )
    arrayPush(u, getSymbols(a)), a = getPrototype$2(a);
  return u;
} : stubArray;
function copySymbolsIn(a, u) {
  return copyObject(a, getSymbolsIn(a), u);
}
function baseGetAllKeys(a, u, c) {
  var l = u(a);
  return isArray$5(a) ? l : arrayPush(l, c(a));
}
function getAllKeys(a) {
  return baseGetAllKeys(a, keys$2, getSymbols);
}
function getAllKeysIn(a) {
  return baseGetAllKeys(a, keysIn, getSymbolsIn);
}
var DataView$1 = getNative(root, "DataView"), Promise$1 = getNative(root, "Promise"), Set$1 = getNative(root, "Set"), mapTag$4 = "[object Map]", objectTag$3 = "[object Object]", promiseTag = "[object Promise]", setTag$4 = "[object Set]", weakMapTag$1 = "[object WeakMap]", dataViewTag$3 = "[object DataView]", dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$2), getTag = baseGetTag;
(DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$3 || Map$1 && getTag(new Map$1()) != mapTag$4 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$4 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag$1) && (getTag = function(a) {
  var u = baseGetTag(a), c = u == objectTag$3 ? a.constructor : void 0, l = c ? toSource(c) : "";
  if (l)
    switch (l) {
      case dataViewCtorString:
        return dataViewTag$3;
      case mapCtorString:
        return mapTag$4;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag$4;
      case weakMapCtorString:
        return weakMapTag$1;
    }
  return u;
});
const getTag$1 = getTag;
var objectProto$9 = Object.prototype, hasOwnProperty$5 = objectProto$9.hasOwnProperty;
function initCloneArray(a) {
  var u = a.length, c = new a.constructor(u);
  return u && typeof a[0] == "string" && hasOwnProperty$5.call(a, "index") && (c.index = a.index, c.input = a.input), c;
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(a) {
  var u = new a.constructor(a.byteLength);
  return new Uint8Array$1(u).set(new Uint8Array$1(a)), u;
}
function cloneDataView(a, u) {
  var c = u ? cloneArrayBuffer(a.buffer) : a.buffer;
  return new a.constructor(c, a.byteOffset, a.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(a) {
  var u = new a.constructor(a.source, reFlags.exec(a));
  return u.lastIndex = a.lastIndex, u;
}
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(a) {
  return symbolValueOf$1 ? Object(symbolValueOf$1.call(a)) : {};
}
function cloneTypedArray(a, u) {
  var c = u ? cloneArrayBuffer(a.buffer) : a.buffer;
  return new a.constructor(c, a.byteOffset, a.length);
}
var boolTag$3 = "[object Boolean]", dateTag$2 = "[object Date]", mapTag$3 = "[object Map]", numberTag$3 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$3 = "[object Set]", stringTag$4 = "[object String]", symbolTag$5 = "[object Symbol]", arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(a, u, c) {
  var l = a.constructor;
  switch (u) {
    case arrayBufferTag$2:
      return cloneArrayBuffer(a);
    case boolTag$3:
    case dateTag$2:
      return new l(+a);
    case dataViewTag$2:
      return cloneDataView(a, c);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(a, c);
    case mapTag$3:
      return new l();
    case numberTag$3:
    case stringTag$4:
      return new l(a);
    case regexpTag$2:
      return cloneRegExp(a);
    case setTag$3:
      return new l();
    case symbolTag$5:
      return cloneSymbol(a);
  }
}
function initCloneObject(a) {
  return typeof a.constructor == "function" && !isPrototype$1(a) ? baseCreate(getPrototype$2(a)) : {};
}
var mapTag$2 = "[object Map]";
function baseIsMap(a) {
  return isObjectLike$7(a) && getTag$1(a) == mapTag$2;
}
var nodeIsMap = nodeUtil && nodeUtil.isMap, isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap, setTag$2 = "[object Set]";
function baseIsSet(a) {
  return isObjectLike$7(a) && getTag$1(a) == setTag$2;
}
var nodeIsSet = nodeUtil && nodeUtil.isSet, isSet$5 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet, CLONE_DEEP_FLAG$3 = 1, CLONE_FLAT_FLAG$1 = 2, CLONE_SYMBOLS_FLAG$2 = 4, argsTag$2 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", genTag$1 = "[object GeneratorFunction]", mapTag$1 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$1 = "[object Set]", stringTag$3 = "[object String]", symbolTag$4 = "[object Symbol]", weakMapTag = "[object WeakMap]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", cloneableTags = {};
cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] = cloneableTags[arrayBufferTag$1] = cloneableTags[dataViewTag$1] = cloneableTags[boolTag$2] = cloneableTags[dateTag$1] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag$1] = cloneableTags[numberTag$2] = cloneableTags[objectTag$2] = cloneableTags[regexpTag$1] = cloneableTags[setTag$1] = cloneableTags[stringTag$3] = cloneableTags[symbolTag$4] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0;
cloneableTags[errorTag$1] = cloneableTags[funcTag$1] = cloneableTags[weakMapTag] = !1;
function baseClone(a, u, c, l, v, S) {
  var g, E = u & CLONE_DEEP_FLAG$3, _ = u & CLONE_FLAT_FLAG$1, k = u & CLONE_SYMBOLS_FLAG$2;
  if (c && (g = v ? c(a, l, v, S) : c(a)), g !== void 0)
    return g;
  if (!isObject$9(a))
    return a;
  var L = isArray$5(a);
  if (L) {
    if (g = initCloneArray(a), !E)
      return copyArray(a, g);
  } else {
    var M = getTag$1(a), $ = M == funcTag$1 || M == genTag$1;
    if (isBuffer$1(a))
      return cloneBuffer(a, E);
    if (M == objectTag$2 || M == argsTag$2 || $ && !v) {
      if (g = _ || $ ? {} : initCloneObject(a), !E)
        return _ ? copySymbolsIn(a, baseAssignIn(g, a)) : copySymbols(a, baseAssign(g, a));
    } else {
      if (!cloneableTags[M])
        return v ? a : {};
      g = initCloneByTag(a, M, E);
    }
  }
  S || (S = new Stack());
  var J = S.get(a);
  if (J)
    return J;
  S.set(a, g), isSet$5(a) ? a.forEach(function(G) {
    g.add(baseClone(G, u, c, G, a, S));
  }) : isMap(a) && a.forEach(function(G, H) {
    g.set(H, baseClone(G, u, c, H, a, S));
  });
  var V = k ? _ ? getAllKeysIn : getAllKeys : _ ? keysIn : keys$2, q = L ? void 0 : V(a);
  return arrayEach(q || a, function(G, H) {
    q && (H = G, G = a[H]), assignValue(g, H, baseClone(G, u, c, H, a, S));
  }), g;
}
var CLONE_DEEP_FLAG$2 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep$1(a) {
  return baseClone(a, CLONE_DEEP_FLAG$2 | CLONE_SYMBOLS_FLAG$1);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(a) {
  return this.__data__.set(a, HASH_UNDEFINED), this;
}
function setCacheHas(a) {
  return this.__data__.has(a);
}
function SetCache(a) {
  var u = -1, c = a == null ? 0 : a.length;
  for (this.__data__ = new MapCache(); ++u < c; )
    this.add(a[u]);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l; )
    if (u(a[c], c, a))
      return !0;
  return !1;
}
function cacheHas(a, u) {
  return a.has(u);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(a, u, c, l, v, S) {
  var g = c & COMPARE_PARTIAL_FLAG$5, E = a.length, _ = u.length;
  if (E != _ && !(g && _ > E))
    return !1;
  var k = S.get(a), L = S.get(u);
  if (k && L)
    return k == u && L == a;
  var M = -1, $ = !0, J = c & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  for (S.set(a, u), S.set(u, a); ++M < E; ) {
    var V = a[M], q = u[M];
    if (l)
      var G = g ? l(q, V, M, u, a, S) : l(V, q, M, a, u, S);
    if (G !== void 0) {
      if (G)
        continue;
      $ = !1;
      break;
    }
    if (J) {
      if (!arraySome(u, function(H, B) {
        if (!cacheHas(J, B) && (V === H || v(V, H, c, l, S)))
          return J.push(B);
      })) {
        $ = !1;
        break;
      }
    } else if (!(V === q || v(V, q, c, l, S))) {
      $ = !1;
      break;
    }
  }
  return S.delete(a), S.delete(u), $;
}
function mapToArray(a) {
  var u = -1, c = Array(a.size);
  return a.forEach(function(l, v) {
    c[++u] = [v, l];
  }), c;
}
function setToArray(a) {
  var u = -1, c = Array(a.size);
  return a.forEach(function(l) {
    c[++u] = l;
  }), c;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2, boolTag$1 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag$1 = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag$2 = "[object String]", symbolTag$3 = "[object Symbol]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(a, u, c, l, v, S, g) {
  switch (c) {
    case dataViewTag:
      if (a.byteLength != u.byteLength || a.byteOffset != u.byteOffset)
        return !1;
      a = a.buffer, u = u.buffer;
    case arrayBufferTag:
      return !(a.byteLength != u.byteLength || !S(new Uint8Array$1(a), new Uint8Array$1(u)));
    case boolTag$1:
    case dateTag:
    case numberTag$1:
      return eq(+a, +u);
    case errorTag:
      return a.name == u.name && a.message == u.message;
    case regexpTag:
    case stringTag$2:
      return a == u + "";
    case mapTag:
      var E = mapToArray;
    case setTag:
      var _ = l & COMPARE_PARTIAL_FLAG$4;
      if (E || (E = setToArray), a.size != u.size && !_)
        return !1;
      var k = g.get(a);
      if (k)
        return k == u;
      l |= COMPARE_UNORDERED_FLAG$2, g.set(a, u);
      var L = equalArrays(E(a), E(u), l, v, S, g);
      return g.delete(a), L;
    case symbolTag$3:
      if (symbolValueOf)
        return symbolValueOf.call(a) == symbolValueOf.call(u);
  }
  return !1;
}
var COMPARE_PARTIAL_FLAG$3 = 1, objectProto$8 = Object.prototype, hasOwnProperty$4 = objectProto$8.hasOwnProperty;
function equalObjects(a, u, c, l, v, S) {
  var g = c & COMPARE_PARTIAL_FLAG$3, E = getAllKeys(a), _ = E.length, k = getAllKeys(u), L = k.length;
  if (_ != L && !g)
    return !1;
  for (var M = _; M--; ) {
    var $ = E[M];
    if (!(g ? $ in u : hasOwnProperty$4.call(u, $)))
      return !1;
  }
  var J = S.get(a), V = S.get(u);
  if (J && V)
    return J == u && V == a;
  var q = !0;
  S.set(a, u), S.set(u, a);
  for (var G = g; ++M < _; ) {
    $ = E[M];
    var H = a[$], B = u[$];
    if (l)
      var Y = g ? l(B, H, $, u, a, S) : l(H, B, $, a, u, S);
    if (!(Y === void 0 ? H === B || v(H, B, c, l, S) : Y)) {
      q = !1;
      break;
    }
    G || (G = $ == "constructor");
  }
  if (q && !G) {
    var ne = a.constructor, Z = u.constructor;
    ne != Z && "constructor" in a && "constructor" in u && !(typeof ne == "function" && ne instanceof ne && typeof Z == "function" && Z instanceof Z) && (q = !1);
  }
  return S.delete(a), S.delete(u), q;
}
var COMPARE_PARTIAL_FLAG$2 = 1, argsTag$1 = "[object Arguments]", arrayTag = "[object Array]", objectTag$1 = "[object Object]", objectProto$7 = Object.prototype, hasOwnProperty$3 = objectProto$7.hasOwnProperty;
function baseIsEqualDeep(a, u, c, l, v, S) {
  var g = isArray$5(a), E = isArray$5(u), _ = g ? arrayTag : getTag$1(a), k = E ? arrayTag : getTag$1(u);
  _ = _ == argsTag$1 ? objectTag$1 : _, k = k == argsTag$1 ? objectTag$1 : k;
  var L = _ == objectTag$1, M = k == objectTag$1, $ = _ == k;
  if ($ && isBuffer$1(a)) {
    if (!isBuffer$1(u))
      return !1;
    g = !0, L = !1;
  }
  if ($ && !L)
    return S || (S = new Stack()), g || isTypedArray(a) ? equalArrays(a, u, c, l, v, S) : equalByTag(a, u, _, c, l, v, S);
  if (!(c & COMPARE_PARTIAL_FLAG$2)) {
    var J = L && hasOwnProperty$3.call(a, "__wrapped__"), V = M && hasOwnProperty$3.call(u, "__wrapped__");
    if (J || V) {
      var q = J ? a.value() : a, G = V ? u.value() : u;
      return S || (S = new Stack()), v(q, G, c, l, S);
    }
  }
  return $ ? (S || (S = new Stack()), equalObjects(a, u, c, l, v, S)) : !1;
}
function baseIsEqual(a, u, c, l, v) {
  return a === u ? !0 : a == null || u == null || !isObjectLike$7(a) && !isObjectLike$7(u) ? a !== a && u !== u : baseIsEqualDeep(a, u, c, l, baseIsEqual, v);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(a, u, c, l) {
  var v = c.length, S = v, g = !l;
  if (a == null)
    return !S;
  for (a = Object(a); v--; ) {
    var E = c[v];
    if (g && E[2] ? E[1] !== a[E[0]] : !(E[0] in a))
      return !1;
  }
  for (; ++v < S; ) {
    E = c[v];
    var _ = E[0], k = a[_], L = E[1];
    if (g && E[2]) {
      if (k === void 0 && !(_ in a))
        return !1;
    } else {
      var M = new Stack();
      if (l)
        var $ = l(k, L, _, a, u, M);
      if (!($ === void 0 ? baseIsEqual(L, k, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, l, M) : $))
        return !1;
    }
  }
  return !0;
}
function isStrictComparable(a) {
  return a === a && !isObject$9(a);
}
function getMatchData(a) {
  for (var u = keys$2(a), c = u.length; c--; ) {
    var l = u[c], v = a[l];
    u[c] = [l, v, isStrictComparable(v)];
  }
  return u;
}
function matchesStrictComparable(a, u) {
  return function(c) {
    return c == null ? !1 : c[a] === u && (u !== void 0 || a in Object(c));
  };
}
function baseMatches(a) {
  var u = getMatchData(a);
  return u.length == 1 && u[0][2] ? matchesStrictComparable(u[0][0], u[0][1]) : function(c) {
    return c === a || baseIsMatch(c, a, u);
  };
}
function baseHasIn(a, u) {
  return a != null && u in Object(a);
}
function hasPath(a, u, c) {
  u = castPath(u, a);
  for (var l = -1, v = u.length, S = !1; ++l < v; ) {
    var g = toKey(u[l]);
    if (!(S = a != null && c(a, g)))
      break;
    a = a[g];
  }
  return S || ++l != v ? S : (v = a == null ? 0 : a.length, !!v && isLength$1(v) && isIndex$1(g, v) && (isArray$5(a) || isArguments$1(a)));
}
function hasIn(a, u) {
  return a != null && hasPath(a, u, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(a, u) {
  return isKey(a) && isStrictComparable(u) ? matchesStrictComparable(toKey(a), u) : function(c) {
    var l = get(c, a);
    return l === void 0 && l === u ? hasIn(c, a) : baseIsEqual(u, l, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(a) {
  return function(u) {
    return u == null ? void 0 : u[a];
  };
}
function basePropertyDeep(a) {
  return function(u) {
    return baseGet(u, a);
  };
}
function property(a) {
  return isKey(a) ? baseProperty(toKey(a)) : basePropertyDeep(a);
}
function baseIteratee(a) {
  return typeof a == "function" ? a : a == null ? identity$1 : typeof a == "object" ? isArray$5(a) ? baseMatchesProperty(a[0], a[1]) : baseMatches(a) : property(a);
}
function createBaseFor(a) {
  return function(u, c, l) {
    for (var v = -1, S = Object(u), g = l(u), E = g.length; E--; ) {
      var _ = g[a ? E : ++v];
      if (c(S[_], _, S) === !1)
        break;
    }
    return u;
  };
}
var baseFor = createBaseFor();
const baseFor$1 = baseFor;
function baseForOwn(a, u) {
  return a && baseFor$1(a, u, keys$2);
}
function createBaseEach(a, u) {
  return function(c, l) {
    if (c == null)
      return c;
    if (!isArrayLike$2(c))
      return a(c, l);
    for (var v = c.length, S = u ? v : -1, g = Object(c); (u ? S-- : ++S < v) && l(g[S], S, g) !== !1; )
      ;
    return c;
  };
}
var baseEach = createBaseEach(baseForOwn), now = function() {
  return root.Date.now();
}, FUNC_ERROR_TEXT$1 = "Expected a function", nativeMax$1 = Math.max, nativeMin = Math.min;
function debounce$1(a, u, c) {
  var l, v, S, g, E, _, k = 0, L = !1, M = !1, $ = !0;
  if (typeof a != "function")
    throw new TypeError(FUNC_ERROR_TEXT$1);
  u = toNumber$3(u) || 0, isObject$9(c) && (L = !!c.leading, M = "maxWait" in c, S = M ? nativeMax$1(toNumber$3(c.maxWait) || 0, u) : S, $ = "trailing" in c ? !!c.trailing : $);
  function J(re) {
    var oe = l, de = v;
    return l = v = void 0, k = re, g = a.apply(de, oe), g;
  }
  function V(re) {
    return k = re, E = setTimeout(H, u), L ? J(re) : g;
  }
  function q(re) {
    var oe = re - _, de = re - k, A = u - oe;
    return M ? nativeMin(A, S - de) : A;
  }
  function G(re) {
    var oe = re - _, de = re - k;
    return _ === void 0 || oe >= u || oe < 0 || M && de >= S;
  }
  function H() {
    var re = now();
    if (G(re))
      return B(re);
    E = setTimeout(H, q(re));
  }
  function B(re) {
    return E = void 0, $ && l ? J(re) : (l = v = void 0, g);
  }
  function Y() {
    E !== void 0 && clearTimeout(E), k = 0, l = _ = v = E = void 0;
  }
  function ne() {
    return E === void 0 ? g : B(now());
  }
  function Z() {
    var re = now(), oe = G(re);
    if (l = arguments, v = this, _ = re, oe) {
      if (E === void 0)
        return V(_);
      if (M)
        return clearTimeout(E), E = setTimeout(H, u), J(_);
    }
    return E === void 0 && (E = setTimeout(H, u)), g;
  }
  return Z.cancel = Y, Z.flush = ne, Z;
}
function last$1(a) {
  var u = a == null ? 0 : a.length;
  return u ? a[u - 1] : void 0;
}
function arrayEvery(a, u) {
  for (var c = -1, l = a == null ? 0 : a.length; ++c < l; )
    if (!u(a[c], c, a))
      return !1;
  return !0;
}
function baseEvery(a, u) {
  var c = !0;
  return baseEach(a, function(l, v, S) {
    return c = !!u(l, v, S), c;
  }), c;
}
function every$1(a, u, c) {
  var l = isArray$5(a) ? arrayEvery : baseEvery;
  return c && isIterateeCall(a, u, c) && (u = void 0), l(a, baseIteratee(u));
}
function baseMap(a, u) {
  var c = -1, l = isArrayLike$2(a) ? Array(a.length) : [];
  return baseEach(a, function(v, S, g) {
    l[++c] = u(v, S, g);
  }), l;
}
function parent(a, u) {
  return u.length < 2 ? a : baseGet(a, baseSlice(u, 0, -1));
}
function isEqual(a, u) {
  return baseIsEqual(a, u);
}
function isMatch(a, u) {
  return a === u || baseIsMatch(a, u, getMatchData(u));
}
var CLONE_DEEP_FLAG$1 = 1;
function iteratee(a) {
  return baseIteratee(typeof a == "function" ? a : baseClone(a, CLONE_DEEP_FLAG$1));
}
var kebabCase = createCompounder(function(a, u, c) {
  return a + (c ? "-" : "") + u.toLowerCase();
});
const kebabCase$1 = kebabCase;
function baseUnset(a, u) {
  return u = castPath(u, a), a = parent(a, u), a == null || delete a[toKey(last$1(u))];
}
function customOmitClone(a) {
  return isPlainObject$3(a) ? void 0 : a;
}
var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, omit = flatRest(function(a, u) {
  var c = {};
  if (a == null)
    return c;
  var l = !1;
  u = arrayMap$1(u, function(S) {
    return S = castPath(S, a), l || (l = S.length > 1), S;
  }), copyObject(a, getAllKeysIn(a), c), l && (c = baseClone(c, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
  for (var v = u.length; v--; )
    baseUnset(c, u[v]);
  return c;
});
function baseSet(a, u, c, l) {
  if (!isObject$9(a))
    return a;
  u = castPath(u, a);
  for (var v = -1, S = u.length, g = S - 1, E = a; E != null && ++v < S; ) {
    var _ = toKey(u[v]), k = c;
    if (_ === "__proto__" || _ === "constructor" || _ === "prototype")
      return a;
    if (v != g) {
      var L = E[_];
      k = l ? l(L, _, E) : void 0, k === void 0 && (k = isObject$9(L) ? L : isIndex$1(u[v + 1]) ? [] : {});
    }
    assignValue(E, _, k), E = E[_];
  }
  return a;
}
function basePickBy(a, u, c) {
  for (var l = -1, v = u.length, S = {}; ++l < v; ) {
    var g = u[l], E = baseGet(a, g);
    c(E, g) && baseSet(S, castPath(g, a), E);
  }
  return S;
}
function baseSortBy(a, u) {
  var c = a.length;
  for (a.sort(u); c--; )
    a[c] = a[c].value;
  return a;
}
function compareAscending(a, u) {
  if (a !== u) {
    var c = a !== void 0, l = a === null, v = a === a, S = isSymbol$3(a), g = u !== void 0, E = u === null, _ = u === u, k = isSymbol$3(u);
    if (!E && !k && !S && a > u || S && g && _ && !E && !k || l && g && _ || !c && _ || !v)
      return 1;
    if (!l && !S && !k && a < u || k && c && v && !l && !S || E && c && v || !g && v || !_)
      return -1;
  }
  return 0;
}
function compareMultiple(a, u, c) {
  for (var l = -1, v = a.criteria, S = u.criteria, g = v.length, E = c.length; ++l < g; ) {
    var _ = compareAscending(v[l], S[l]);
    if (_) {
      if (l >= E)
        return _;
      var k = c[l];
      return _ * (k == "desc" ? -1 : 1);
    }
  }
  return a.index - u.index;
}
function baseOrderBy(a, u, c) {
  u.length ? u = arrayMap$1(u, function(S) {
    return isArray$5(S) ? function(g) {
      return baseGet(g, S.length === 1 ? S[0] : S);
    } : S;
  }) : u = [identity$1];
  var l = -1;
  u = arrayMap$1(u, baseUnary(baseIteratee));
  var v = baseMap(a, function(S, g, E) {
    var _ = arrayMap$1(u, function(k) {
      return k(S);
    });
    return { criteria: _, index: ++l, value: S };
  });
  return baseSortBy(v, function(S, g) {
    return compareMultiple(S, g, c);
  });
}
function basePick(a, u) {
  return basePickBy(a, u, function(c, l) {
    return hasIn(a, l);
  });
}
var pick = flatRest(function(a, u) {
  return a == null ? {} : basePick(a, u);
});
const pick$1 = pick;
function baseIndexOfWith(a, u, c, l) {
  for (var v = c - 1, S = a.length; ++v < S; )
    if (l(a[v], u))
      return v;
  return -1;
}
var arrayProto = Array.prototype, splice = arrayProto.splice;
function basePullAll(a, u, c, l) {
  var v = l ? baseIndexOfWith : baseIndexOf$1, S = -1, g = u.length, E = a;
  for (a === u && (u = copyArray(u)), c && (E = arrayMap$1(a, baseUnary(c))); ++S < g; )
    for (var _ = 0, k = u[S], L = c ? c(k) : k; (_ = v(E, L, _, l)) > -1; )
      E !== a && splice.call(E, _, 1), splice.call(a, _, 1);
  return a;
}
function pullAll(a, u) {
  return a && a.length && u && u.length ? basePullAll(a, u) : a;
}
var pull$1 = baseRest(pullAll), sortBy = baseRest(function(a, u) {
  if (a == null)
    return [];
  var c = u.length;
  return c > 1 && isIterateeCall(a, u[0], u[1]) ? u = [] : c > 2 && isIterateeCall(u[0], u[1], u[2]) && (u = [u[0]]), baseOrderBy(a, baseFlatten(u, 1), []);
});
const sortBy$1 = sortBy, convert = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(a) {
    if (a == null)
      return ok;
    if (typeof a == "function")
      return castFactory(a);
    if (typeof a == "object")
      return Array.isArray(a) ? anyFactory(a) : propsFactory(a);
    if (typeof a == "string")
      return typeFactory(a);
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(a) {
  const u = [];
  let c = -1;
  for (; ++c < a.length; )
    u[c] = convert(a[c]);
  return castFactory(l);
  function l(...v) {
    let S = -1;
    for (; ++S < u.length; )
      if (u[S].apply(this, v))
        return !0;
    return !1;
  }
}
function propsFactory(a) {
  const u = (
    /** @type {Record<string, unknown>} */
    a
  );
  return castFactory(c);
  function c(l) {
    const v = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      l
    );
    let S;
    for (S in a)
      if (v[S] !== u[S])
        return !1;
    return !0;
  }
}
function typeFactory(a) {
  return castFactory(u);
  function u(c) {
    return c && c.type === a;
  }
}
function castFactory(a) {
  return u;
  function u(c, l, v) {
    return !!(looksLikeANode(c) && a.call(
      this,
      c,
      typeof l == "number" ? l : void 0,
      v || void 0
    ));
  }
}
function ok() {
  return !0;
}
function looksLikeANode(a) {
  return a !== null && typeof a == "object" && "type" in a;
}
function color$1(a) {
  return a;
}
const empty$3 = [], CONTINUE = !0, EXIT = !1, SKIP = "skip";
function visitParents(a, u, c, l) {
  let v;
  typeof u == "function" && typeof c != "function" ? (l = c, c = u) : v = u;
  const S = convert(v), g = l ? -1 : 1;
  E(a, void 0, [])();
  function E(_, k, L) {
    const M = (
      /** @type {Record<string, unknown>} */
      _ && typeof _ == "object" ? _ : {}
    );
    if (typeof M.type == "string") {
      const J = (
        // `hast`
        typeof M.tagName == "string" ? M.tagName : (
          // `xast`
          typeof M.name == "string" ? M.name : void 0
        )
      );
      Object.defineProperty($, "name", {
        value: "node (" + (_.type + (J ? "<" + J + ">" : "")) + ")"
      });
    }
    return $;
    function $() {
      let J = empty$3, V, q, G;
      if ((!u || S(_, k, L[L.length - 1] || void 0)) && (J = toResult(c(_, L)), J[0] === EXIT))
        return J;
      if ("children" in _ && _.children) {
        const H = (
          /** @type {UnistParent} */
          _
        );
        if (H.children && J[0] !== SKIP)
          for (q = (l ? H.children.length : -1) + g, G = L.concat(H); q > -1 && q < H.children.length; ) {
            const B = H.children[q];
            if (V = E(B, q, G)(), V[0] === EXIT)
              return V;
            q = typeof V[1] == "number" ? V[1] : q + g;
          }
      }
      return J;
    }
  }
}
function toResult(a) {
  return Array.isArray(a) ? a : typeof a == "number" ? [CONTINUE, a] : a == null ? empty$3 : [a];
}
function visit(a, u, c, l) {
  let v, S, g;
  typeof u == "function" && typeof c != "function" ? (S = void 0, g = u, v = c) : (S = u, g = c, v = l), visitParents(a, S, E, v);
  function E(_, k) {
    const L = k[k.length - 1], M = L ? L.children.indexOf(_) : void 0;
    return g(_, M, L);
  }
}
var fastDeepEqual = function a(u, c) {
  if (u === c)
    return !0;
  if (u && c && typeof u == "object" && typeof c == "object") {
    if (u.constructor !== c.constructor)
      return !1;
    var l, v, S;
    if (Array.isArray(u)) {
      if (l = u.length, l != c.length)
        return !1;
      for (v = l; v-- !== 0; )
        if (!a(u[v], c[v]))
          return !1;
      return !0;
    }
    if (u.constructor === RegExp)
      return u.source === c.source && u.flags === c.flags;
    if (u.valueOf !== Object.prototype.valueOf)
      return u.valueOf() === c.valueOf();
    if (u.toString !== Object.prototype.toString)
      return u.toString() === c.toString();
    if (S = Object.keys(u), l = S.length, l !== Object.keys(c).length)
      return !1;
    for (v = l; v-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(c, S[v]))
        return !1;
    for (v = l; v-- !== 0; ) {
      var g = S[v];
      if (!a(u[g], c[g]))
        return !1;
    }
    return !0;
  }
  return u !== u && c !== c;
};
const deepEqual = /* @__PURE__ */ getDefaultExportFromCjs$1(fastDeepEqual), generateId = () => (Math.random() * 1e20).toString(36), insertAt$1 = (a = 0, u, c, l = !1) => [...c.slice(0, a), ...[u].flat(), ...c.slice(l ? a + 1 : a)], replaceItem$1 = (a, u, c) => {
  a = typeof a == "function" ? a : (v) => v === a;
  const l = c.findIndex(a);
  return l < 0 ? c : insertAt$1(l, u, c, !0);
}, swapIndex = (a, u, c) => {
  if (!c[a] || !c[u])
    return c;
  c = [...c];
  const l = c[a];
  return c[a] = c[u], c[u] = l, c;
}, swapItems = (a, u, c) => {
  const l = c.findIndex((S) => S === a), v = c.findIndex((S) => S === u);
  return l < 0 || v < 0 ? c : swapIndex(l, v, c);
}, toDataNode$1 = (a) => a ? {
  id: a.id,
  props: a.props,
  childIds: (a.children || []).map((u) => u.id)
} : null, toSceneNode = (a) => ({
  id: a.id,
  props: a.props,
  children: []
}), toSceneTree = (a, u) => {
  const c = a.find((v) => v.id === u);
  if (!c)
    return null;
  const l = c.childIds;
  return {
    id: c.id,
    props: c.props,
    children: l.map((v) => toSceneTree(a, v)).filter(Boolean)
  };
}, forEachDown$1 = (a, u) => {
  u(a), (a.children || []).forEach((l) => forEachDown$1(l, (v, S) => {
    u(v, S || a);
  }));
}, mapDown = (a, u) => {
  const c = u(a);
  return {
    ...c,
    children: ((c == null ? void 0 : c.children) || (a == null ? void 0 : a.children) || []).map((l) => mapDown(l, u))
  };
}, mapDownAsync = async (a, u) => {
  const c = (a == null ? void 0 : a.children) ?? [];
  return {
    ...await u(a),
    children: await Promise.all(c.map((l) => mapDownAsync(l, u)))
  };
}, getElementAttributes = (a) => Object.values(a.attributes).reduce((u, c) => ({
  ...u,
  [c.name]: c.value
}), {}), asArray = (a) => isArray$5(a) ? a : [a], sizeToNum = (a, u) => typeof a == "number" ? a : typeof a == "string" ? a.indexOf("%") > -1 ? parseFloat(a) / 100 * u : parseFloat(a) : 0, asSize = (a) => typeof a == "number" ? a + "px" : typeof a == "string" ? a.indexOf("%") > -1 ? parseFloat(a) + "%" : a : "0px", asDuration = (a) => typeof a == "string" ? a : typeof a == "number" ? a + "ms" : "0ms", find$2 = (a, u) => {
  if (!a)
    throw new Error("requires a tree to search");
  if (!u)
    throw new Error("requires a condition");
  const c = iteratee(u);
  let l;
  return visit(a, function(v) {
    if (c(v))
      return l = v, !1;
  }), l;
}, findAll = (a, u) => {
  if (!a)
    throw new Error("requires a tree to search");
  if (!u)
    throw new Error("requires a condition");
  const c = iteratee(u);
  let l = [];
  return visit(a, function(v) {
    c(v) && l.push(v);
  }), l;
}, values$1 = (a) => Array.from(a.values()), Logic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  asArray,
  asDuration,
  asSize,
  camelCase: camelCase$3,
  cloneDeep: cloneDeep$1,
  debounce: debounce$1,
  deepEqual,
  every: every$1,
  find: find$2,
  findAll,
  forEachDown: forEachDown$1,
  generateId,
  getElementAttributes,
  insertAt: insertAt$1,
  isArray: isArray$5,
  isEqual,
  kebabCase: kebabCase$1,
  mapDown,
  mapDownAsync,
  omit,
  pick: pick$1,
  pull: pull$1,
  replaceItem: replaceItem$1,
  sizeToNum,
  sortBy: sortBy$1,
  swapIndex,
  swapItems,
  toDataNode: toDataNode$1,
  toSceneNode,
  toSceneTree,
  values: values$1
}, Symbol.toStringTag, { value: "Module" }));
var lib$2 = {};
function e(a) {
  this.message = a;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r$1 = typeof window < "u" && window.atob && window.atob.bind(window) || function(a) {
  var u = String(a).replace(/=+$/, "");
  if (u.length % 4 == 1)
    throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var c, l, v = 0, S = 0, g = ""; l = u.charAt(S++); ~l && (c = v % 4 ? 64 * c + l : l, v++ % 4) ? g += String.fromCharCode(255 & c >> (-2 * v & 6)) : 0)
    l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(l);
  return g;
};
function t(a) {
  var u = a.replace(/-/g, "+").replace(/_/g, "/");
  switch (u.length % 4) {
    case 0:
      break;
    case 2:
      u += "==";
      break;
    case 3:
      u += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(c) {
      return decodeURIComponent(r$1(c).replace(/(.)/g, function(l, v) {
        var S = v.charCodeAt(0).toString(16).toUpperCase();
        return S.length < 2 && (S = "0" + S), "%" + S;
      }));
    }(u);
  } catch {
    return r$1(u);
  }
}
function n(a) {
  this.message = a;
}
function o(a, u) {
  if (typeof a != "string")
    throw new n("Invalid token specified");
  var c = (u = u || {}).header === !0 ? 0 : 1;
  try {
    return JSON.parse(t(a.split(".")[c]));
  } catch (l) {
    throw new n("Invalid token specified: " + l.message);
  }
}
n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
const jwtDecode_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InvalidTokenError: n,
  default: o
}, Symbol.toStringTag, { value: "Module" })), require$$0$2 = /* @__PURE__ */ getAugmentedNamespace(jwtDecode_esm);
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$2(a) {
  return typeof a == "string" && REGEX.test(a);
}
var byteToHex = [];
for (var i = 0; i < 256; ++i)
  byteToHex.push((i + 256).toString(16).substr(1));
function stringify(a) {
  var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, c = (byteToHex[a[u + 0]] + byteToHex[a[u + 1]] + byteToHex[a[u + 2]] + byteToHex[a[u + 3]] + "-" + byteToHex[a[u + 4]] + byteToHex[a[u + 5]] + "-" + byteToHex[a[u + 6]] + byteToHex[a[u + 7]] + "-" + byteToHex[a[u + 8]] + byteToHex[a[u + 9]] + "-" + byteToHex[a[u + 10]] + byteToHex[a[u + 11]] + byteToHex[a[u + 12]] + byteToHex[a[u + 13]] + byteToHex[a[u + 14]] + byteToHex[a[u + 15]]).toLowerCase();
  if (!validate$2(c))
    throw TypeError("Stringified UUID is invalid");
  return c;
}
var _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;
function v1(a, u, c) {
  var l = u && c || 0, v = u || new Array(16);
  a = a || {};
  var S = a.node || _nodeId, g = a.clockseq !== void 0 ? a.clockseq : _clockseq;
  if (S == null || g == null) {
    var E = a.random || (a.rng || rng)();
    S == null && (S = _nodeId = [E[0] | 1, E[1], E[2], E[3], E[4], E[5]]), g == null && (g = _clockseq = (E[6] << 8 | E[7]) & 16383);
  }
  var _ = a.msecs !== void 0 ? a.msecs : Date.now(), k = a.nsecs !== void 0 ? a.nsecs : _lastNSecs + 1, L = _ - _lastMSecs + (k - _lastNSecs) / 1e4;
  if (L < 0 && a.clockseq === void 0 && (g = g + 1 & 16383), (L < 0 || _ > _lastMSecs) && a.nsecs === void 0 && (k = 0), k >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  _lastMSecs = _, _lastNSecs = k, _clockseq = g, _ += 122192928e5;
  var M = ((_ & 268435455) * 1e4 + k) % 4294967296;
  v[l++] = M >>> 24 & 255, v[l++] = M >>> 16 & 255, v[l++] = M >>> 8 & 255, v[l++] = M & 255;
  var $ = _ / 4294967296 * 1e4 & 268435455;
  v[l++] = $ >>> 8 & 255, v[l++] = $ & 255, v[l++] = $ >>> 24 & 15 | 16, v[l++] = $ >>> 16 & 255, v[l++] = g >>> 8 | 128, v[l++] = g & 255;
  for (var J = 0; J < 6; ++J)
    v[l + J] = S[J];
  return u || stringify(v);
}
function parse$3(a) {
  if (!validate$2(a))
    throw TypeError("Invalid UUID");
  var u, c = new Uint8Array(16);
  return c[0] = (u = parseInt(a.slice(0, 8), 16)) >>> 24, c[1] = u >>> 16 & 255, c[2] = u >>> 8 & 255, c[3] = u & 255, c[4] = (u = parseInt(a.slice(9, 13), 16)) >>> 8, c[5] = u & 255, c[6] = (u = parseInt(a.slice(14, 18), 16)) >>> 8, c[7] = u & 255, c[8] = (u = parseInt(a.slice(19, 23), 16)) >>> 8, c[9] = u & 255, c[10] = (u = parseInt(a.slice(24, 36), 16)) / 1099511627776 & 255, c[11] = u / 4294967296 & 255, c[12] = u >>> 24 & 255, c[13] = u >>> 16 & 255, c[14] = u >>> 8 & 255, c[15] = u & 255, c;
}
function stringToBytes(a) {
  a = unescape(encodeURIComponent(a));
  for (var u = [], c = 0; c < a.length; ++c)
    u.push(a.charCodeAt(c));
  return u;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(a, u, c) {
  function l(v, S, g, E) {
    if (typeof v == "string" && (v = stringToBytes(v)), typeof S == "string" && (S = parse$3(S)), S.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var _ = new Uint8Array(16 + v.length);
    if (_.set(S), _.set(v, S.length), _ = c(_), _[6] = _[6] & 15 | u, _[8] = _[8] & 63 | 128, g) {
      E = E || 0;
      for (var k = 0; k < 16; ++k)
        g[E + k] = _[k];
      return g;
    }
    return stringify(_);
  }
  try {
    l.name = a;
  } catch {
  }
  return l.DNS = DNS, l.URL = URL$1, l;
}
function md5(a) {
  if (typeof a == "string") {
    var u = unescape(encodeURIComponent(a));
    a = new Uint8Array(u.length);
    for (var c = 0; c < u.length; ++c)
      a[c] = u.charCodeAt(c);
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(a), a.length * 8));
}
function md5ToHexEncodedArray(a) {
  for (var u = [], c = a.length * 32, l = "0123456789abcdef", v = 0; v < c; v += 8) {
    var S = a[v >> 5] >>> v % 32 & 255, g = parseInt(l.charAt(S >>> 4 & 15) + l.charAt(S & 15), 16);
    u.push(g);
  }
  return u;
}
function getOutputLength(a) {
  return (a + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(a, u) {
  a[u >> 5] |= 128 << u % 32, a[getOutputLength(u) - 1] = u;
  for (var c = 1732584193, l = -271733879, v = -1732584194, S = 271733878, g = 0; g < a.length; g += 16) {
    var E = c, _ = l, k = v, L = S;
    c = md5ff(c, l, v, S, a[g], 7, -680876936), S = md5ff(S, c, l, v, a[g + 1], 12, -389564586), v = md5ff(v, S, c, l, a[g + 2], 17, 606105819), l = md5ff(l, v, S, c, a[g + 3], 22, -1044525330), c = md5ff(c, l, v, S, a[g + 4], 7, -176418897), S = md5ff(S, c, l, v, a[g + 5], 12, 1200080426), v = md5ff(v, S, c, l, a[g + 6], 17, -1473231341), l = md5ff(l, v, S, c, a[g + 7], 22, -45705983), c = md5ff(c, l, v, S, a[g + 8], 7, 1770035416), S = md5ff(S, c, l, v, a[g + 9], 12, -1958414417), v = md5ff(v, S, c, l, a[g + 10], 17, -42063), l = md5ff(l, v, S, c, a[g + 11], 22, -1990404162), c = md5ff(c, l, v, S, a[g + 12], 7, 1804603682), S = md5ff(S, c, l, v, a[g + 13], 12, -40341101), v = md5ff(v, S, c, l, a[g + 14], 17, -1502002290), l = md5ff(l, v, S, c, a[g + 15], 22, 1236535329), c = md5gg(c, l, v, S, a[g + 1], 5, -165796510), S = md5gg(S, c, l, v, a[g + 6], 9, -1069501632), v = md5gg(v, S, c, l, a[g + 11], 14, 643717713), l = md5gg(l, v, S, c, a[g], 20, -373897302), c = md5gg(c, l, v, S, a[g + 5], 5, -701558691), S = md5gg(S, c, l, v, a[g + 10], 9, 38016083), v = md5gg(v, S, c, l, a[g + 15], 14, -660478335), l = md5gg(l, v, S, c, a[g + 4], 20, -405537848), c = md5gg(c, l, v, S, a[g + 9], 5, 568446438), S = md5gg(S, c, l, v, a[g + 14], 9, -1019803690), v = md5gg(v, S, c, l, a[g + 3], 14, -187363961), l = md5gg(l, v, S, c, a[g + 8], 20, 1163531501), c = md5gg(c, l, v, S, a[g + 13], 5, -1444681467), S = md5gg(S, c, l, v, a[g + 2], 9, -51403784), v = md5gg(v, S, c, l, a[g + 7], 14, 1735328473), l = md5gg(l, v, S, c, a[g + 12], 20, -1926607734), c = md5hh(c, l, v, S, a[g + 5], 4, -378558), S = md5hh(S, c, l, v, a[g + 8], 11, -2022574463), v = md5hh(v, S, c, l, a[g + 11], 16, 1839030562), l = md5hh(l, v, S, c, a[g + 14], 23, -35309556), c = md5hh(c, l, v, S, a[g + 1], 4, -1530992060), S = md5hh(S, c, l, v, a[g + 4], 11, 1272893353), v = md5hh(v, S, c, l, a[g + 7], 16, -155497632), l = md5hh(l, v, S, c, a[g + 10], 23, -1094730640), c = md5hh(c, l, v, S, a[g + 13], 4, 681279174), S = md5hh(S, c, l, v, a[g], 11, -358537222), v = md5hh(v, S, c, l, a[g + 3], 16, -722521979), l = md5hh(l, v, S, c, a[g + 6], 23, 76029189), c = md5hh(c, l, v, S, a[g + 9], 4, -640364487), S = md5hh(S, c, l, v, a[g + 12], 11, -421815835), v = md5hh(v, S, c, l, a[g + 15], 16, 530742520), l = md5hh(l, v, S, c, a[g + 2], 23, -995338651), c = md5ii(c, l, v, S, a[g], 6, -198630844), S = md5ii(S, c, l, v, a[g + 7], 10, 1126891415), v = md5ii(v, S, c, l, a[g + 14], 15, -1416354905), l = md5ii(l, v, S, c, a[g + 5], 21, -57434055), c = md5ii(c, l, v, S, a[g + 12], 6, 1700485571), S = md5ii(S, c, l, v, a[g + 3], 10, -1894986606), v = md5ii(v, S, c, l, a[g + 10], 15, -1051523), l = md5ii(l, v, S, c, a[g + 1], 21, -2054922799), c = md5ii(c, l, v, S, a[g + 8], 6, 1873313359), S = md5ii(S, c, l, v, a[g + 15], 10, -30611744), v = md5ii(v, S, c, l, a[g + 6], 15, -1560198380), l = md5ii(l, v, S, c, a[g + 13], 21, 1309151649), c = md5ii(c, l, v, S, a[g + 4], 6, -145523070), S = md5ii(S, c, l, v, a[g + 11], 10, -1120210379), v = md5ii(v, S, c, l, a[g + 2], 15, 718787259), l = md5ii(l, v, S, c, a[g + 9], 21, -343485551), c = safeAdd(c, E), l = safeAdd(l, _), v = safeAdd(v, k), S = safeAdd(S, L);
  }
  return [c, l, v, S];
}
function bytesToWords(a) {
  if (a.length === 0)
    return [];
  for (var u = a.length * 8, c = new Uint32Array(getOutputLength(u)), l = 0; l < u; l += 8)
    c[l >> 5] |= (a[l / 8] & 255) << l % 32;
  return c;
}
function safeAdd(a, u) {
  var c = (a & 65535) + (u & 65535), l = (a >> 16) + (u >> 16) + (c >> 16);
  return l << 16 | c & 65535;
}
function bitRotateLeft(a, u) {
  return a << u | a >>> 32 - u;
}
function md5cmn(a, u, c, l, v, S) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(u, a), safeAdd(l, S)), v), c);
}
function md5ff(a, u, c, l, v, S, g) {
  return md5cmn(u & c | ~u & l, a, u, v, S, g);
}
function md5gg(a, u, c, l, v, S, g) {
  return md5cmn(u & l | c & ~l, a, u, v, S, g);
}
function md5hh(a, u, c, l, v, S, g) {
  return md5cmn(u ^ c ^ l, a, u, v, S, g);
}
function md5ii(a, u, c, l, v, S, g) {
  return md5cmn(c ^ (u | ~l), a, u, v, S, g);
}
var v3 = v35("v3", 48, md5);
const v3$1 = v3;
function v4(a, u, c) {
  a = a || {};
  var l = a.random || (a.rng || rng)();
  if (l[6] = l[6] & 15 | 64, l[8] = l[8] & 63 | 128, u) {
    c = c || 0;
    for (var v = 0; v < 16; ++v)
      u[c + v] = l[v];
    return u;
  }
  return stringify(l);
}
function f(a, u, c, l) {
  switch (a) {
    case 0:
      return u & c ^ ~u & l;
    case 1:
      return u ^ c ^ l;
    case 2:
      return u & c ^ u & l ^ c & l;
    case 3:
      return u ^ c ^ l;
  }
}
function ROTL(a, u) {
  return a << u | a >>> 32 - u;
}
function sha1(a) {
  var u = [1518500249, 1859775393, 2400959708, 3395469782], c = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof a == "string") {
    var l = unescape(encodeURIComponent(a));
    a = [];
    for (var v = 0; v < l.length; ++v)
      a.push(l.charCodeAt(v));
  } else
    Array.isArray(a) || (a = Array.prototype.slice.call(a));
  a.push(128);
  for (var S = a.length / 4 + 2, g = Math.ceil(S / 16), E = new Array(g), _ = 0; _ < g; ++_) {
    for (var k = new Uint32Array(16), L = 0; L < 16; ++L)
      k[L] = a[_ * 64 + L * 4] << 24 | a[_ * 64 + L * 4 + 1] << 16 | a[_ * 64 + L * 4 + 2] << 8 | a[_ * 64 + L * 4 + 3];
    E[_] = k;
  }
  E[g - 1][14] = (a.length - 1) * 8 / Math.pow(2, 32), E[g - 1][14] = Math.floor(E[g - 1][14]), E[g - 1][15] = (a.length - 1) * 8 & 4294967295;
  for (var M = 0; M < g; ++M) {
    for (var $ = new Uint32Array(80), J = 0; J < 16; ++J)
      $[J] = E[M][J];
    for (var V = 16; V < 80; ++V)
      $[V] = ROTL($[V - 3] ^ $[V - 8] ^ $[V - 14] ^ $[V - 16], 1);
    for (var q = c[0], G = c[1], H = c[2], B = c[3], Y = c[4], ne = 0; ne < 80; ++ne) {
      var Z = Math.floor(ne / 20), re = ROTL(q, 5) + f(Z, G, H, B) + Y + u[Z] + $[ne] >>> 0;
      Y = B, B = H, H = ROTL(G, 30) >>> 0, G = q, q = re;
    }
    c[0] = c[0] + q >>> 0, c[1] = c[1] + G >>> 0, c[2] = c[2] + H >>> 0, c[3] = c[3] + B >>> 0, c[4] = c[4] + Y >>> 0;
  }
  return [c[0] >> 24 & 255, c[0] >> 16 & 255, c[0] >> 8 & 255, c[0] & 255, c[1] >> 24 & 255, c[1] >> 16 & 255, c[1] >> 8 & 255, c[1] & 255, c[2] >> 24 & 255, c[2] >> 16 & 255, c[2] >> 8 & 255, c[2] & 255, c[3] >> 24 & 255, c[3] >> 16 & 255, c[3] >> 8 & 255, c[3] & 255, c[4] >> 24 & 255, c[4] >> 16 & 255, c[4] >> 8 & 255, c[4] & 255];
}
var v5 = v35("v5", 80, sha1);
const v5$1 = v5, nil = "00000000-0000-0000-0000-000000000000";
function version$4(a) {
  if (!validate$2(a))
    throw TypeError("Invalid UUID");
  return parseInt(a.substr(14, 1), 16);
}
const esmBrowser = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: nil,
  parse: parse$3,
  stringify,
  v1,
  v3: v3$1,
  v4,
  v5: v5$1,
  validate: validate$2,
  version: version$4
}, Symbol.toStringTag, { value: "Module" })), require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(esmBrowser);
let EnhancedMap$1 = class extends Map {
  /**
   * If key has a mapping already returns the currently associated value. If
   * there is no mapping, calls the computer which must return a value V.
   * The value is then stored for given key and returned.
   * @param key Key
   * @param computer Computer which is called only if key has no mapping yet.
   * @return Existing value if the key already existed, or the newly computed value.
   */
  computeIfAbsent(u, c) {
    if (this.has(u))
      return this.get(u);
    const l = c(u);
    return this.set(u, l), l;
  }
  /**
   * If the key exists already calls given computer, if the key does not exist
   * this method does nothing.
   *
   * The computer is called with current key and current value associated. The
   * computer can return a (new) value V or undefined. When undefined is returned
   * the key is removed from this map, when a V is returned the key is updated
   * with the new value V.
   * @param key Key
   * @param computer Computer which is called only if the key has a mapping already
   * @return Undefined if the key has no mapping, otherwise the value returned from computer
   */
  computeIfPresent(u, c) {
    const l = this.get(u);
    if (l === void 0)
      return;
    const v = c(u, l);
    return v !== void 0 ? this.set(u, v) : this.delete(u), v;
  }
  /**
   * Computes a value for given key, the computer can return a value V (in which case the map
   * will set the value for given key), if it returns undefined the mapping for key K will be
   * removed.
   * @param key Key to compute
   * @param computer Computer which is called, note that the currentValue argument contains the existing
   *                 value or is undefined when no mapping exists for the key.
   * @return The newly computed value
   */
  compute(u, c) {
    const l = this.get(u), v = c(u, l);
    return v ? this.set(u, v) : this.delete(u), v;
  }
};
var InternalLogLevel$1;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error";
})(InternalLogLevel$1 || (InternalLogLevel$1 = {}));
function getInternalLogger$1(a) {
  return provider$1.getLogger(a);
}
const INTERNAL_LOGGING_SETTINGS$1 = {
  /**
   * Changes the log level for the internal logging (for all new and existing loggers)
   * @param level New log level
   */
  setInternalLogLevel: (a) => provider$1.changeLogLevel(a),
  /**
   * Changes where messages are written to for all new and existing loggers),
   * by default they are written to the console.
   * @param fnOutput Function to write messages to
   */
  setOutput: (a) => provider$1.changeOutput(a),
  /**
   * Resets the log level and output back to defaults (level to error and writing to console)
   * for all new and existing loggers.
   */
  reset: () => provider$1.reset()
};
let InternalLoggerImpl$1 = class {
  constructor(u, c, l) {
    this._name = u, this._level = c, this._fnOutput = l;
  }
  trace(u) {
    this.log(InternalLogLevel$1.Trace, u);
  }
  debug(u) {
    this.log(InternalLogLevel$1.Debug, u);
  }
  error(u, c) {
    this.log(InternalLogLevel$1.Error, u, c);
  }
  info(u) {
    this.log(InternalLogLevel$1.Info, u);
  }
  warn(u, c) {
    this.log(InternalLogLevel$1.Warn, u, c);
  }
  setLevel(u) {
    this._level = u;
  }
  setOutput(u) {
    this._fnOutput = u;
  }
  log(u, c, l) {
    this._level > u || this._fnOutput(`${InternalLogLevel$1[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${c()}${l ? `
` + l.stack : ""}`);
  }
}, InternalProviderImpl$1 = class Bt {
  constructor() {
    this._loggers = new EnhancedMap$1(), this._logLevel = InternalLogLevel$1.Error, this._fnOutput = Bt.logConsole;
  }
  getLogger(u) {
    return this._loggers.computeIfAbsent(u, (c) => new InternalLoggerImpl$1(c, this._logLevel, this._fnOutput));
  }
  changeLogLevel(u) {
    this._logLevel = u, this._loggers.forEach((c) => c.setLevel(u));
  }
  changeOutput(u) {
    this._fnOutput = u, this._loggers.forEach((c) => c.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel$1.Error), this._fnOutput = Bt.logConsole, this._loggers.forEach((u) => u.setOutput(this._fnOutput));
  }
  static logConsole(u) {
    console && console.log && console.log(u);
  }
};
const provider$1 = new InternalProviderImpl$1();
var InternalLogger$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get InternalLogLevel() {
    return InternalLogLevel$1;
  },
  getInternalLogger: getInternalLogger$1,
  INTERNAL_LOGGING_SETTINGS: INTERNAL_LOGGING_SETTINGS$1
}), LogLevel$2;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error", a[a.Fatal = 5] = "Fatal";
})(LogLevel$2 || (LogLevel$2 = {}));
(function(a) {
  function u(c) {
    switch (c.toLowerCase()) {
      case "trace":
        return a.Trace;
      case "debug":
        return a.Debug;
      case "info":
        return a.Info;
      case "warn":
        return a.Warn;
      case "error":
        return a.Error;
      case "fatal":
        return a.Fatal;
      default:
        return;
    }
  }
  a.toLogLevel = u;
})(LogLevel$2 || (LogLevel$2 = {}));
let CoreLoggerImpl$1 = class Ar {
  constructor(u) {
    this._runtime = u;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(u) {
    this._runtime = u;
  }
  trace(u, ...c) {
    this.logMessage(LogLevel$2.Trace, u, c);
  }
  debug(u, ...c) {
    this.logMessage(LogLevel$2.Debug, u, c);
  }
  info(u, ...c) {
    this.logMessage(LogLevel$2.Info, u, c);
  }
  warn(u, ...c) {
    this.logMessage(LogLevel$2.Warn, u, c);
  }
  error(u, ...c) {
    this.logMessage(LogLevel$2.Error, u, c);
  }
  fatal(u, ...c) {
    this.logMessage(LogLevel$2.Fatal, u, c);
  }
  logMessage(u, c, l) {
    if (this._runtime.level > u)
      return;
    const v = Date.now(), S = typeof c == "string" ? c : c(), g = Ar.getErrorAndArgs(l);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({
          message: S,
          exception: g.error,
          args: g.args,
          timeInMillis: v,
          level: u,
          logNames: this._runtime.name
        }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(S, u, g, v));
        break;
    }
  }
  formatArgValue(u) {
    try {
      return this._runtime.argumentFormatter(u);
    } catch {
      return `>>ARG CONVERT FAILED: '${u !== void 0 ? u.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(u, c, l, v) {
    let S;
    const g = l.error, E = l.args;
    g && (S = `${g.name}: ${g.message}`, g.stack && (S += `@
${g.stack}`));
    const _ = this._runtime.dateFormatter(v);
    let k = LogLevel$2[c].toUpperCase();
    k.length < 5 && (k += " ");
    const L = typeof this._runtime.name == "string" ? this._runtime.name : this._runtime.name.join(", "), M = typeof E < "u" && E.length > 0 ? " [" + E.map((J) => this.formatArgValue(J)).join(", ") + "]" : "";
    return {
      message: _ + " " + k + " [" + L + "] " + u + M,
      error: S
    };
  }
  static getErrorAndArgs(u) {
    if (u.length === 0)
      return {};
    let c, l;
    const v = u[0];
    if (v instanceof Error)
      return c = v, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l };
    if (typeof v == "function") {
      const S = v();
      return S instanceof Error ? (c = S, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l }) : u.length === 1 ? Array.isArray(S) ? { args: S.length > 0 ? S : void 0 } : { args: S } : Array.isArray(S) ? { args: [...S, ...u.slice(1)] } : { args: [S, ...u.slice(1)] };
    }
    return { args: u };
  }
};
function padStart$1(a, u, c = " ") {
  return padInternal$1(a, u, "start", c);
}
function padEnd$1(a, u, c = " ") {
  return padInternal$1(a, u, "end", c);
}
function maxLengthStringValueInArray$1(a) {
  return a.map((u) => u.length).reduce((u, c) => c > u ? c : u, 0);
}
function padInternal$1(a, u, c, l = " ") {
  if (u <= a.length)
    return a;
  if (l.length > 1)
    throw new Error(`Fill char must be one char exactly, it is: ${l.length}`);
  const v = u - a.length;
  let S = "";
  for (let g = 0; g < v; g++)
    S += l;
  return c === "start" ? S + a : a + S;
}
function formatArgument$1(a) {
  return a === void 0 ? "undefined" : JSON.stringify(a);
}
function formatDate$1(a) {
  const u = new Date(a), c = u.getFullYear(), l = padStart$1((u.getMonth() + 1).toString(), 2, "0"), v = padStart$1(u.getDate().toString(), 2, "0"), S = padStart$1(u.getHours().toString(), 2, "0"), g = padStart$1(u.getMinutes().toString(), 2, "0"), E = padStart$1(u.getSeconds().toString(), 2, "0"), _ = padStart$1(u.getMilliseconds().toString(), 2, "0");
  return `${c}-${l}-${v} ${S}:${g}:${E},${_}`;
}
let ConsoleLogChannel$1 = class {
  constructor() {
    this.type = "LogChannel";
  }
  write(u) {
    console && console.log && console.log(u.message + (u.error ? `
${u.error}` : ""));
  }
};
var DefaultChannels$1;
(function(a) {
  function u() {
    return new ConsoleLogChannel$1();
  }
  a.createConsoleChannel = u;
})(DefaultChannels$1 || (DefaultChannels$1 = {}));
let LogProviderImpl$1 = class Mt {
  constructor(u, c) {
    this._log = getInternalLogger$1("core.impl.LogProviderImpl"), this._name = u, this._settings = c, this._loggers = new EnhancedMap$1(), this._idToKeyMap = new EnhancedMap$1(), this._globalRuntimeSettings = { level: c.level, channel: c.channel }, this._nextLoggerId = 1, this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(u) {
    return this.getOrCreateLogger(u);
  }
  updateLoggerRuntime(u, c) {
    this._log.debug(() => `Updating logger ${u.id} runtime settings using: '${JSON.stringify(c)}'`);
    const l = this._idToKeyMap.get(u.id);
    return l === void 0 ? (this._log.warn(() => `Cannot update logger with id: ${u.id}, it was not found.`), !1) : (this._loggers.computeIfPresent(l, (v, S) => (S.runtimeSettings = Mt.mergeRuntimeSettingsIntoLogRuntime(S.runtimeSettings, c), S)), !0);
  }
  updateRuntimeSettings(u) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(u)}'`), this._globalRuntimeSettings = {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: u.level !== void 0 ? u.level : this._globalRuntimeSettings.level,
      channel: u.channel !== void 0 ? u.channel : this._globalRuntimeSettings.channel
    }, this._loggers.forEach((c) => c.runtimeSettings = Mt.mergeRuntimeSettingsIntoLogRuntime(c.runtimeSettings, u));
  }
  /**
   * Removes all state and loggers, it reverts back to as it was after initial construction.
   */
  clear() {
    this._loggers.clear(), this._idToKeyMap.clear(), this._globalRuntimeSettings = Object.assign({}, this._settings), this._nextLoggerId = 1;
  }
  getOrCreateLogger(u) {
    const c = Mt.createKey(u), l = this._loggers.computeIfAbsent(c, () => {
      const v = {
        level: this._globalRuntimeSettings.level,
        channel: this._globalRuntimeSettings.channel,
        id: this.nextLoggerId(),
        name: u,
        argumentFormatter: this._settings.argumentFormatter,
        dateFormatter: this._settings.dateFormatter
      };
      return new CoreLoggerImpl$1(v);
    });
    return this._idToKeyMap.computeIfAbsent(l.id, () => c), l;
  }
  nextLoggerId() {
    const u = this._name + "_" + this._nextLoggerId;
    return this._nextLoggerId++, u;
  }
  static mergeRuntimeSettingsIntoLogRuntime(u, c) {
    return Object.assign(Object.assign({}, u), {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: c.level !== void 0 ? c.level : u.level,
      channel: c.channel !== void 0 ? c.channel : u.channel
    });
  }
  static createKey(u) {
    return typeof u == "string" ? u : u.join(",");
  }
};
function createLogProvider$1(a, u) {
  return new LogProviderImpl$1(a, u);
}
var index$4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EnhancedMap: EnhancedMap$1,
  padStart: padStart$1,
  padEnd: padEnd$1,
  maxLengthStringValueInArray: maxLengthStringValueInArray$1
});
class ArrayLogChannel {
  constructor() {
    this._buffer = [], this.type = "LogChannel";
  }
  write(u) {
    this._buffer.push(u);
  }
  get logMessages() {
    return this._buffer;
  }
  get messages() {
    return this._buffer.map((u) => u.message);
  }
}
class ArrayRawLogChannel {
  constructor() {
    this._buffer = [], this.type = "RawLogChannel";
  }
  write(u, c) {
    this._buffer.push(u);
  }
  get messages() {
    return this._buffer.map((u) => u.message);
  }
  get errors() {
    return this._buffer.map((u) => u.exception);
  }
  get size() {
    return this._buffer.length;
  }
  get rawMessages() {
    return this._buffer;
  }
  clear() {
    this._buffer = [];
  }
}
class TestControlMessage {
  constructor() {
    this._messages = [], this.write = this.write.bind(this);
  }
  get messages() {
    return this._messages;
  }
  write(u) {
    this._messages.push(u);
  }
  clear() {
    this._messages = [];
  }
}
var TestClasses = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArrayLogChannel,
  ArrayRawLogChannel,
  TestControlMessage
});
const typescriptLogging_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $internal: InternalLogger$1,
  $test: TestClasses,
  get DefaultChannels() {
    return DefaultChannels$1;
  },
  get LogLevel() {
    return LogLevel$2;
  },
  createLogProvider: createLogProvider$1,
  formatArgument: formatArgument$1,
  formatDate: formatDate$1,
  util: index$4
}, Symbol.toStringTag, { value: "Module" })), require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(typescriptLogging_esm);
var layoutapi = {}, lib$1 = {}, lib = {}, Metadata = {};
Object.defineProperty(Metadata, "__esModule", { value: !0 });
Metadata.Metadata = void 0;
Metadata.Metadata = function(u) {
  const c = /* @__PURE__ */ new Map(), l = {
    set(v, S) {
      if (v = normalizeKey(v), Array.isArray(S))
        if (S.length === 0)
          c.delete(v);
        else {
          for (const g of S)
            validate$1(v, g);
          c.set(v, v.endsWith("-bin") ? S : [S.join(", ")]);
        }
      else
        validate$1(v, S), c.set(v, [S]);
      return l;
    },
    append(v, S) {
      v = normalizeKey(v), validate$1(v, S);
      let g = c.get(v);
      return g == null && (g = [], c.set(v, g)), g.push(S), v.endsWith("-bin") || c.set(v, [g.join(", ")]), l;
    },
    delete(v) {
      v = normalizeKey(v), c.delete(v);
    },
    get(v) {
      var S;
      return v = normalizeKey(v), (S = c.get(v)) === null || S === void 0 ? void 0 : S[0];
    },
    getAll(v) {
      var S;
      return v = normalizeKey(v), (S = c.get(v)) !== null && S !== void 0 ? S : [];
    },
    has(v) {
      return v = normalizeKey(v), c.has(v);
    },
    [Symbol.iterator]() {
      return c[Symbol.iterator]();
    }
  };
  if (u != null) {
    const v = isIterable$1(u) ? u : Object.entries(u);
    for (const [S, g] of v)
      l.set(S, g);
  }
  return l;
};
function normalizeKey(a) {
  return a.toLowerCase();
}
function validate$1(a, u) {
  if (!/^[0-9a-z_.-]+$/.test(a))
    throw new Error(`Metadata key '${a}' contains illegal characters`);
  if (a.endsWith("-bin")) {
    if (!(u instanceof Uint8Array))
      throw new Error(`Metadata key '${a}' ends with '-bin', thus it must have binary value`);
  } else {
    if (typeof u != "string")
      throw new Error(`Metadata key '${a}' doesn't end with '-bin', thus it must have string value`);
    if (!/^[ -~]*$/.test(u))
      throw new Error(`Metadata value '${u}' of key '${a}' contains illegal characters`);
  }
}
function isIterable$1(a) {
  return Symbol.iterator in a;
}
var Status = {};
(function(a) {
  Object.defineProperty(a, "__esModule", { value: !0 }), a.Status = void 0, function(u) {
    u[u.OK = 0] = "OK", u[u.CANCELLED = 1] = "CANCELLED", u[u.UNKNOWN = 2] = "UNKNOWN", u[u.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", u[u.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", u[u.NOT_FOUND = 5] = "NOT_FOUND", u[u.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", u[u.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", u[u.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", u[u.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", u[u.ABORTED = 10] = "ABORTED", u[u.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", u[u.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", u[u.INTERNAL = 13] = "INTERNAL", u[u.UNAVAILABLE = 14] = "UNAVAILABLE", u[u.DATA_LOSS = 15] = "DATA_LOSS", u[u.UNAUTHENTICATED = 16] = "UNAUTHENTICATED";
  }(a.Status || (a.Status = {}));
})(Status);
var MethodDescriptor = {};
Object.defineProperty(MethodDescriptor, "__esModule", { value: !0 });
var CallOptions = {};
Object.defineProperty(CallOptions, "__esModule", { value: !0 });
var ClientMiddleware = {};
Object.defineProperty(ClientMiddleware, "__esModule", { value: !0 });
var composeClientMiddleware$1 = {};
Object.defineProperty(composeClientMiddleware$1, "__esModule", { value: !0 });
composeClientMiddleware$1.composeClientMiddleware = void 0;
function composeClientMiddleware(a, u) {
  return (c, l) => u({
    ...c,
    next: (v, S) => a({ ...c, request: v }, S)
  }, l);
}
composeClientMiddleware$1.composeClientMiddleware = composeClientMiddleware;
var ClientError$1 = {}, cjs = {}, helpers = {};
helpers.__esModule = void 0;
helpers.__esModule = !0;
var objectSetPrototypeOfIsDefined = typeof Object.setPrototypeOf == "function", objectGetPrototypeOfIsDefined = typeof Object.getPrototypeOf == "function", objectDefinePropertyIsDefined = typeof Object.defineProperty == "function", objectCreateIsDefined = typeof Object.create == "function", objectHasOwnPropertyIsDefined = typeof Object.prototype.hasOwnProperty == "function", setPrototypeOf = function(u, c) {
  objectSetPrototypeOfIsDefined ? Object.setPrototypeOf(u, c) : u.__proto__ = c;
};
helpers.setPrototypeOf = setPrototypeOf;
var getPrototypeOf = function(u) {
  return objectGetPrototypeOfIsDefined ? Object.getPrototypeOf(u) : u.__proto__ || u.prototype;
};
helpers.getPrototypeOf = getPrototypeOf;
var ie8ObjectDefinePropertyBug = !1, defineProperty = function a(u, c, l) {
  if (objectDefinePropertyIsDefined && !ie8ObjectDefinePropertyBug)
    try {
      Object.defineProperty(u, c, l);
    } catch {
      ie8ObjectDefinePropertyBug = !0, a(u, c, l);
    }
  else
    u[c] = l.value;
};
helpers.defineProperty = defineProperty;
var hasOwnProperty$2 = function(u, c) {
  return objectHasOwnPropertyIsDefined ? u.hasOwnProperty(u, c) : u[c] === void 0;
};
helpers.hasOwnProperty = hasOwnProperty$2;
var objectCreate = function(u, c) {
  if (objectCreateIsDefined)
    return Object.create(u, c);
  var l = function() {
  };
  l.prototype = u;
  var v = new l();
  if (typeof c > "u")
    return v;
  if (typeof c == "null")
    throw new Error("PropertyDescriptors must not be null.");
  if (typeof c == "object")
    for (var S in c)
      hasOwnProperty$2(c, S) && (v[S] = c[S].value);
  return v;
};
helpers.objectCreate = objectCreate;
(function(a) {
  a.__esModule = void 0, a.__esModule = !0;
  var u = helpers, c = u.setPrototypeOf, l = u.getPrototypeOf, v = u.defineProperty, S = u.objectCreate, g = new Error().toString() === "[object Error]", E = "";
  function _(k) {
    var L = this.constructor, M = L.name || function() {
      var G = L.toString().match(/^function\s*([^\s(]+)/);
      return G === null ? E || "Error" : G[1];
    }(), $ = M === "Error", J = $ ? E : M, V = Error.apply(this, arguments);
    if (c(V, l(this)), !(V instanceof L) || !(V instanceof _)) {
      var V = this;
      Error.apply(this, arguments), v(V, "message", {
        configurable: !0,
        enumerable: !1,
        value: k,
        writable: !0
      });
    }
    if (v(V, "name", {
      configurable: !0,
      enumerable: !1,
      value: J,
      writable: !0
    }), Error.captureStackTrace && Error.captureStackTrace(
      V,
      $ ? _ : L
    ), V.stack === void 0) {
      var q = new Error(k);
      q.name = V.name, V.stack = q.stack;
    }
    return g && v(V, "toString", {
      configurable: !0,
      enumerable: !1,
      value: function() {
        return (this.name || "Error") + (typeof this.message > "u" ? "" : ": " + this.message);
      },
      writable: !0
    }), V;
  }
  E = _.name || "ExtendableError", _.prototype = S(Error.prototype, {
    constructor: {
      value: Error,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), a.ExtendableError = _, a.default = a.ExtendableError;
})(cjs);
Object.defineProperty(ClientError$1, "__esModule", { value: !0 });
ClientError$1.ClientError = void 0;
const ts_error_1$1 = cjs, Status_1$1 = Status;
class ClientError extends ts_error_1$1.ExtendableError {
  constructor(u, c, l) {
    super(`${u} ${Status_1$1.Status[c]}: ${l}`), this.path = u, this.code = c, this.details = l, this.name = "ClientError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ClientError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](u) {
    return this !== ClientError ? this.prototype.isPrototypeOf(u) : typeof u == "object" && u !== null && (u.constructor === ClientError || u["@@nice-grpc:ClientError"] === !0 || u.name === "ClientError" && u["@@nice-grpc"] === !0);
  }
}
ClientError$1.ClientError = ClientError;
var CallContext = {};
Object.defineProperty(CallContext, "__esModule", { value: !0 });
var ServerMiddleware = {};
Object.defineProperty(ServerMiddleware, "__esModule", { value: !0 });
var composeServerMiddleware$1 = {};
Object.defineProperty(composeServerMiddleware$1, "__esModule", { value: !0 });
composeServerMiddleware$1.composeServerMiddleware = void 0;
function composeServerMiddleware(a, u) {
  return (c, l) => a({
    ...c,
    next: (v, S) => u({ ...c, request: v }, S)
  }, l);
}
composeServerMiddleware$1.composeServerMiddleware = composeServerMiddleware;
var ServerError$1 = {};
Object.defineProperty(ServerError$1, "__esModule", { value: !0 });
ServerError$1.ServerError = void 0;
const ts_error_1 = cjs, Status_1 = Status;
class ServerError extends ts_error_1.ExtendableError {
  constructor(u, c) {
    super(`${Status_1.Status[u]}: ${c}`), this.code = u, this.details = c, this.name = "ServerError", Object.defineProperty(this, "@@nice-grpc", {
      value: !0
    }), Object.defineProperty(this, "@@nice-grpc:ServerError", {
      value: !0
    });
  }
  static [Symbol.hasInstance](u) {
    return this !== ServerError ? this.prototype.isPrototypeOf(u) : typeof u == "object" && u !== null && (u.constructor === ServerError || u["@@nice-grpc:ServerError"] === !0 || u.name === "ServerError" && u["@@nice-grpc"] === !0);
  }
}
ServerError$1.ServerError = ServerError;
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(l, v, S, g) {
    g === void 0 && (g = S);
    var E = Object.getOwnPropertyDescriptor(v, S);
    (!E || ("get" in E ? !v.__esModule : E.writable || E.configurable)) && (E = { enumerable: !0, get: function() {
      return v[S];
    } }), Object.defineProperty(l, g, E);
  } : function(l, v, S, g) {
    g === void 0 && (g = S), l[g] = v[S];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(l, v) {
    for (var S in l)
      S !== "default" && !Object.prototype.hasOwnProperty.call(v, S) && u(v, l, S);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), c(Metadata, a), c(Status, a), c(MethodDescriptor, a), c(CallOptions, a), c(ClientMiddleware, a), c(composeClientMiddleware$1, a), c(ClientError$1, a), c(CallContext, a), c(ServerMiddleware, a), c(composeServerMiddleware$1, a), c(ServerError$1, a);
})(lib);
var serviceDefinitions = {}, grpcWeb = {};
Object.defineProperty(grpcWeb, "__esModule", { value: !0 });
grpcWeb.isGrpcWebServiceDefinition = grpcWeb.fromGrpcWebServiceDefinition = void 0;
function fromGrpcWebServiceDefinition(a) {
  const u = {};
  for (const [c, l] of Object.entries(a)) {
    if (c === "serviceName")
      continue;
    const v = l;
    u[uncapitalize(c)] = {
      path: `/${a.serviceName}/${c}`,
      requestStream: v.requestStream,
      responseStream: v.responseStream,
      requestDeserialize: v.requestType.deserializeBinary,
      requestSerialize: (S) => S.serializeBinary(),
      responseDeserialize: v.responseType.deserializeBinary,
      responseSerialize: (S) => S.serializeBinary(),
      options: {}
    };
  }
  return u;
}
grpcWeb.fromGrpcWebServiceDefinition = fromGrpcWebServiceDefinition;
function isGrpcWebServiceDefinition(a) {
  return "prototype" in a;
}
grpcWeb.isGrpcWebServiceDefinition = isGrpcWebServiceDefinition;
function uncapitalize(a) {
  return a.length === 0 ? a : a[0].toLowerCase() + a.slice(1);
}
var tsProto = {};
Object.defineProperty(tsProto, "__esModule", { value: !0 });
tsProto.isTsProtoServiceDefinition = tsProto.fromTsProtoServiceDefinition = void 0;
function fromTsProtoServiceDefinition(a) {
  const u = {};
  for (const [c, l] of Object.entries(a.methods)) {
    const v = l.requestType.encode, S = l.requestType.fromPartial, g = l.responseType.encode, E = l.responseType.fromPartial;
    u[c] = {
      path: `/${a.fullName}/${l.name}`,
      requestStream: l.requestStream,
      responseStream: l.responseStream,
      requestDeserialize: l.requestType.decode,
      requestSerialize: S != null ? (_) => v(S(_)).finish() : (_) => v(_).finish(),
      responseDeserialize: l.responseType.decode,
      responseSerialize: E != null ? (_) => g(E(_)).finish() : (_) => g(_).finish(),
      options: l.options
    };
  }
  return u;
}
tsProto.fromTsProtoServiceDefinition = fromTsProtoServiceDefinition;
function isTsProtoServiceDefinition(a) {
  return "name" in a && "fullName" in a && "methods" in a;
}
tsProto.isTsProtoServiceDefinition = isTsProtoServiceDefinition;
Object.defineProperty(serviceDefinitions, "__esModule", { value: !0 });
serviceDefinitions.toGrpcWebMethodDefinition = serviceDefinitions.normalizeServiceDefinition = void 0;
const grpc_web_1$5 = grpcWeb, ts_proto_1 = tsProto;
function normalizeServiceDefinition(a) {
  return (0, grpc_web_1$5.isGrpcWebServiceDefinition)(a) ? (0, grpc_web_1$5.fromGrpcWebServiceDefinition)(a) : (0, ts_proto_1.isTsProtoServiceDefinition)(a) ? (0, ts_proto_1.fromTsProtoServiceDefinition)(a) : a;
}
serviceDefinitions.normalizeServiceDefinition = normalizeServiceDefinition;
function toGrpcWebMethodDefinition(a) {
  const [, u, c] = a.path.split("/");
  return {
    service: {
      serviceName: u
    },
    methodName: c,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    requestType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(l) {
        return a.requestDeserialize(l);
      }
    },
    responseType: class {
      constructor() {
        throw new Error("Unexpected instantiation");
      }
      static deserializeBinary(l) {
        return a.responseDeserialize(l);
      }
    }
  };
}
serviceDefinitions.toGrpcWebMethodDefinition = toGrpcWebMethodDefinition;
var channel = {};
Object.defineProperty(channel, "__esModule", { value: !0 });
channel.createChannel = void 0;
function createChannel(a, u) {
  return { address: a, transport: u };
}
channel.createChannel = createChannel;
var ClientFactory = {}, createBidiStreamingMethod$1 = {}, grpcWebClient_umd = { exports: {} };
(function(a, u) {
  (function(c, l) {
    a.exports = l();
  })(commonjsGlobal$1, function() {
    return c = { 418: function(v, S) {
      (function(g, E) {
        for (var _ in E)
          g[_] = E[_];
      })(S, function(g) {
        var E = {};
        function _(k) {
          if (E[k])
            return E[k].exports;
          var L = E[k] = { i: k, l: !1, exports: {} };
          return g[k].call(L.exports, L, L.exports, _), L.l = !0, L.exports;
        }
        return _.m = g, _.c = E, _.i = function(k) {
          return k;
        }, _.d = function(k, L, M) {
          _.o(k, L) || Object.defineProperty(k, L, { configurable: !1, enumerable: !0, get: M });
        }, _.n = function(k) {
          var L = k && k.__esModule ? function() {
            return k.default;
          } : function() {
            return k;
          };
          return _.d(L, "a", L), L;
        }, _.o = function(k, L) {
          return Object.prototype.hasOwnProperty.call(k, L);
        }, _.p = "", _(_.s = 1);
      }([function(g, E, _) {
        Object.defineProperty(E, "__esModule", { value: !0 });
        var k = _(3), L = function() {
          function M($, J) {
            $ === void 0 && ($ = {}), J === void 0 && (J = { splitValues: !1 });
            var V, q = this;
            this.headersMap = {}, $ && (typeof Headers < "u" && $ instanceof Headers ? k.getHeaderKeys($).forEach(function(G) {
              k.getHeaderValues($, G).forEach(function(H) {
                J.splitValues ? q.append(G, k.splitHeaderValue(H)) : q.append(G, H);
              });
            }) : typeof (V = $) == "object" && typeof V.headersMap == "object" && typeof V.forEach == "function" ? $.forEach(function(G, H) {
              q.append(G, H);
            }) : typeof Map < "u" && $ instanceof Map ? $.forEach(function(G, H) {
              q.append(H, G);
            }) : typeof $ == "string" ? this.appendFromString($) : typeof $ == "object" && Object.getOwnPropertyNames($).forEach(function(G) {
              var H = $[G];
              Array.isArray(H) ? H.forEach(function(B) {
                q.append(G, B);
              }) : q.append(G, H);
            }));
          }
          return M.prototype.appendFromString = function($) {
            for (var J = $.split(`\r
`), V = 0; V < J.length; V++) {
              var q = J[V], G = q.indexOf(":");
              if (G > 0) {
                var H = q.substring(0, G).trim(), B = q.substring(G + 1).trim();
                this.append(H, B);
              }
            }
          }, M.prototype.delete = function($, J) {
            var V = k.normalizeName($);
            if (J === void 0)
              delete this.headersMap[V];
            else {
              var q = this.headersMap[V];
              if (q) {
                var G = q.indexOf(J);
                G >= 0 && q.splice(G, 1), q.length === 0 && delete this.headersMap[V];
              }
            }
          }, M.prototype.append = function($, J) {
            var V = this, q = k.normalizeName($);
            Array.isArray(this.headersMap[q]) || (this.headersMap[q] = []), Array.isArray(J) ? J.forEach(function(G) {
              V.headersMap[q].push(k.normalizeValue(G));
            }) : this.headersMap[q].push(k.normalizeValue(J));
          }, M.prototype.set = function($, J) {
            var V = k.normalizeName($);
            if (Array.isArray(J)) {
              var q = [];
              J.forEach(function(G) {
                q.push(k.normalizeValue(G));
              }), this.headersMap[V] = q;
            } else
              this.headersMap[V] = [k.normalizeValue(J)];
          }, M.prototype.has = function($, J) {
            var V = this.headersMap[k.normalizeName($)];
            if (!Array.isArray(V))
              return !1;
            if (J !== void 0) {
              var q = k.normalizeValue(J);
              return V.indexOf(q) >= 0;
            }
            return !0;
          }, M.prototype.get = function($) {
            var J = this.headersMap[k.normalizeName($)];
            return J !== void 0 ? J.concat() : [];
          }, M.prototype.forEach = function($) {
            var J = this;
            Object.getOwnPropertyNames(this.headersMap).forEach(function(V) {
              $(V, J.headersMap[V]);
            }, this);
          }, M.prototype.toHeaders = function() {
            if (typeof Headers < "u") {
              var $ = new Headers();
              return this.forEach(function(J, V) {
                V.forEach(function(q) {
                  $.append(J, q);
                });
              }), $;
            }
            throw new Error("Headers class is not defined");
          }, M;
        }();
        E.BrowserHeaders = L;
      }, function(g, E, _) {
        Object.defineProperty(E, "__esModule", { value: !0 });
        var k = _(0);
        E.BrowserHeaders = k.BrowserHeaders;
      }, function(g, E, _) {
        Object.defineProperty(E, "__esModule", { value: !0 }), E.iterateHeaders = function(k, L) {
          for (var M = k[Symbol.iterator](), $ = M.next(); !$.done; )
            L($.value[0]), $ = M.next();
        }, E.iterateHeadersKeys = function(k, L) {
          for (var M = k.keys(), $ = M.next(); !$.done; )
            L($.value), $ = M.next();
        };
      }, function(g, E, _) {
        Object.defineProperty(E, "__esModule", { value: !0 });
        var k = _(2);
        E.normalizeName = function(L) {
          if (typeof L != "string" && (L = String(L)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(L))
            throw new TypeError("Invalid character in header field name");
          return L.toLowerCase();
        }, E.normalizeValue = function(L) {
          return typeof L != "string" && (L = String(L)), L;
        }, E.getHeaderValues = function(L, M) {
          var $ = L;
          if ($ instanceof Headers && $.getAll)
            return $.getAll(M);
          var J = $.get(M);
          return J && typeof J == "string" ? [J] : J;
        }, E.getHeaderKeys = function(L) {
          var M = L, $ = {}, J = [];
          return M.keys ? k.iterateHeadersKeys(M, function(V) {
            $[V] || ($[V] = !0, J.push(V));
          }) : M.forEach ? M.forEach(function(V, q) {
            $[q] || ($[q] = !0, J.push(q));
          }) : k.iterateHeaders(M, function(V) {
            var q = V[0];
            $[q] || ($[q] = !0, J.push(q));
          }), J;
        }, E.splitHeaderValue = function(L) {
          var M = [];
          return L.split(", ").forEach(function($) {
            $.split(",").forEach(function(J) {
              M.push(J);
            });
          }), M;
        };
      }]));
    }, 617: function(v, S, g) {
      Object.defineProperty(S, "__esModule", { value: !0 }), S.ChunkParser = S.ChunkType = S.encodeASCII = S.decodeASCII = void 0;
      var E, _ = g(65);
      function k(G) {
        return (H = G) === 9 || H === 10 || H === 13 || G >= 32 && G <= 126;
        var H;
      }
      function L(G) {
        for (var H = 0; H !== G.length; ++H)
          if (!k(G[H]))
            throw new Error("Metadata is not valid (printable) ASCII");
        return String.fromCharCode.apply(String, Array.prototype.slice.call(G));
      }
      function M(G) {
        return (128 & G.getUint8(0)) == 128;
      }
      function $(G) {
        return G.getUint32(1, !1);
      }
      function J(G, H, B) {
        return G.byteLength - H >= B;
      }
      function V(G, H, B) {
        if (G.slice)
          return G.slice(H, B);
        var Y = G.length;
        B !== void 0 && (Y = B);
        for (var ne = new Uint8Array(Y - H), Z = 0, re = H; re < Y; re++)
          ne[Z++] = G[re];
        return ne;
      }
      S.decodeASCII = L, S.encodeASCII = function(G) {
        for (var H = new Uint8Array(G.length), B = 0; B !== G.length; ++B) {
          var Y = G.charCodeAt(B);
          if (!k(Y))
            throw new Error("Metadata contains invalid ASCII");
          H[B] = Y;
        }
        return H;
      }, function(G) {
        G[G.MESSAGE = 1] = "MESSAGE", G[G.TRAILERS = 2] = "TRAILERS";
      }(E = S.ChunkType || (S.ChunkType = {}));
      var q = function() {
        function G() {
          this.buffer = null, this.position = 0;
        }
        return G.prototype.parse = function(H, B) {
          if (H.length === 0 && B)
            return [];
          var Y, ne = [];
          if (this.buffer == null)
            this.buffer = H, this.position = 0;
          else if (this.position === this.buffer.byteLength)
            this.buffer = H, this.position = 0;
          else {
            var Z = this.buffer.byteLength - this.position, re = new Uint8Array(Z + H.byteLength), oe = V(this.buffer, this.position);
            re.set(oe, 0);
            var de = new Uint8Array(H);
            re.set(de, Z), this.buffer = re, this.position = 0;
          }
          for (; ; ) {
            if (!J(this.buffer, this.position, 5))
              return ne;
            var A = V(this.buffer, this.position, this.position + 5), N = new DataView(A.buffer, A.byteOffset, A.byteLength), D = $(N);
            if (!J(this.buffer, this.position, 5 + D))
              return ne;
            var W = V(this.buffer, this.position + 5, this.position + 5 + D);
            if (this.position += 5 + D, M(N))
              return ne.push({ chunkType: E.TRAILERS, trailers: (Y = W, new _.Metadata(L(Y))) }), ne;
            ne.push({ chunkType: E.MESSAGE, data: W });
          }
        }, G;
      }();
      S.ChunkParser = q;
    }, 8: function(v, S) {
      var g;
      Object.defineProperty(S, "__esModule", { value: !0 }), S.httpStatusToCode = S.Code = void 0, function(E) {
        E[E.OK = 0] = "OK", E[E.Canceled = 1] = "Canceled", E[E.Unknown = 2] = "Unknown", E[E.InvalidArgument = 3] = "InvalidArgument", E[E.DeadlineExceeded = 4] = "DeadlineExceeded", E[E.NotFound = 5] = "NotFound", E[E.AlreadyExists = 6] = "AlreadyExists", E[E.PermissionDenied = 7] = "PermissionDenied", E[E.ResourceExhausted = 8] = "ResourceExhausted", E[E.FailedPrecondition = 9] = "FailedPrecondition", E[E.Aborted = 10] = "Aborted", E[E.OutOfRange = 11] = "OutOfRange", E[E.Unimplemented = 12] = "Unimplemented", E[E.Internal = 13] = "Internal", E[E.Unavailable = 14] = "Unavailable", E[E.DataLoss = 15] = "DataLoss", E[E.Unauthenticated = 16] = "Unauthenticated";
      }(g = S.Code || (S.Code = {})), S.httpStatusToCode = function(E) {
        switch (E) {
          case 0:
            return g.Internal;
          case 200:
            return g.OK;
          case 400:
            return g.InvalidArgument;
          case 401:
            return g.Unauthenticated;
          case 403:
            return g.PermissionDenied;
          case 404:
            return g.NotFound;
          case 409:
            return g.Aborted;
          case 412:
            return g.FailedPrecondition;
          case 429:
            return g.ResourceExhausted;
          case 499:
            return g.Canceled;
          case 500:
            return g.Unknown;
          case 501:
            return g.Unimplemented;
          case 503:
            return g.Unavailable;
          case 504:
            return g.DeadlineExceeded;
          default:
            return g.Unknown;
        }
      };
    }, 934: function(v, S, g) {
      Object.defineProperty(S, "__esModule", { value: !0 }), S.client = void 0;
      var E = g(65), _ = g(617), k = g(8), L = g(346), M = g(57), $ = g(882);
      S.client = function(q, G) {
        return new J(q, G);
      };
      var J = function() {
        function q(G, H) {
          this.started = !1, this.sentFirstMessage = !1, this.completed = !1, this.closed = !1, this.finishedSending = !1, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new _.ChunkParser(), this.methodDefinition = G, this.props = H, this.createTransport();
        }
        return q.prototype.createTransport = function() {
          var G = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, H = { methodDefinition: this.methodDefinition, debug: this.props.debug || !1, url: G, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
          this.props.transport ? this.transport = this.props.transport(H) : this.transport = M.makeDefaultTransport(H);
        }, q.prototype.onTransportHeaders = function(G, H) {
          if (this.props.debug && L.debug("onHeaders", G, H), this.closed)
            this.props.debug && L.debug("grpc.onHeaders received after request was closed - ignoring");
          else if (H !== 0) {
            this.responseHeaders = G, this.props.debug && L.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
            var B = V(G);
            this.props.debug && L.debug("onHeaders.gRPCStatus", B);
            var Y = B && B >= 0 ? B : k.httpStatusToCode(H);
            this.props.debug && L.debug("onHeaders.code", Y);
            var ne = G.get("grpc-message") || [];
            if (this.props.debug && L.debug("onHeaders.gRPCMessage", ne), this.rawOnHeaders(G), Y !== k.Code.OK) {
              var Z = this.decodeGRPCStatus(ne[0]);
              this.rawOnError(Y, Z, G);
            }
          }
        }, q.prototype.onTransportChunk = function(G) {
          var H = this;
          if (this.closed)
            this.props.debug && L.debug("grpc.onChunk received after request was closed - ignoring");
          else {
            var B = [];
            try {
              B = this.parser.parse(G);
            } catch (Y) {
              return this.props.debug && L.debug("onChunk.parsing error", Y, Y.message), void this.rawOnError(k.Code.Internal, "parsing error: " + Y.message);
            }
            B.forEach(function(Y) {
              if (Y.chunkType === _.ChunkType.MESSAGE) {
                var ne = H.methodDefinition.responseType.deserializeBinary(Y.data);
                H.rawOnMessage(ne);
              } else
                Y.chunkType === _.ChunkType.TRAILERS && (H.responseHeaders ? (H.responseTrailers = new E.Metadata(Y.trailers), H.props.debug && L.debug("onChunk.trailers", H.responseTrailers)) : (H.responseHeaders = new E.Metadata(Y.trailers), H.rawOnHeaders(H.responseHeaders)));
            });
          }
        }, q.prototype.onTransportEnd = function() {
          if (this.props.debug && L.debug("grpc.onEnd"), this.closed)
            this.props.debug && L.debug("grpc.onEnd received after request was closed - ignoring");
          else if (this.responseTrailers !== void 0) {
            var G = V(this.responseTrailers);
            if (G !== null) {
              var H = this.responseTrailers.get("grpc-message"), B = this.decodeGRPCStatus(H[0]);
              this.rawOnEnd(G, B, this.responseTrailers);
            } else
              this.rawOnError(k.Code.Internal, "Response closed without grpc-status (Trailers provided)");
          } else {
            if (this.responseHeaders === void 0)
              return void this.rawOnError(k.Code.Unknown, "Response closed without headers");
            var Y = V(this.responseHeaders), ne = this.responseHeaders.get("grpc-message");
            if (this.props.debug && L.debug("grpc.headers only response ", Y, ne), Y === null)
              return void this.rawOnEnd(k.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
            var Z = this.decodeGRPCStatus(ne[0]);
            this.rawOnEnd(Y, Z, this.responseHeaders);
          }
        }, q.prototype.decodeGRPCStatus = function(G) {
          if (!G)
            return "";
          try {
            return decodeURIComponent(G);
          } catch {
            return G;
          }
        }, q.prototype.rawOnEnd = function(G, H, B) {
          var Y = this;
          this.props.debug && L.debug("rawOnEnd", G, H, B), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(ne) {
            if (!Y.closed)
              try {
                ne(G, H, B);
              } catch (Z) {
                setTimeout(function() {
                  throw Z;
                }, 0);
              }
          }));
        }, q.prototype.rawOnHeaders = function(G) {
          this.props.debug && L.debug("rawOnHeaders", G), this.completed || this.onHeadersCallbacks.forEach(function(H) {
            try {
              H(G);
            } catch (B) {
              setTimeout(function() {
                throw B;
              }, 0);
            }
          });
        }, q.prototype.rawOnError = function(G, H, B) {
          var Y = this;
          B === void 0 && (B = new E.Metadata()), this.props.debug && L.debug("rawOnError", G, H), this.completed || (this.completed = !0, this.onEndCallbacks.forEach(function(ne) {
            if (!Y.closed)
              try {
                ne(G, H, B);
              } catch (Z) {
                setTimeout(function() {
                  throw Z;
                }, 0);
              }
          }));
        }, q.prototype.rawOnMessage = function(G) {
          var H = this;
          this.props.debug && L.debug("rawOnMessage", G.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(B) {
            if (!H.closed)
              try {
                B(G);
              } catch (Y) {
                setTimeout(function() {
                  throw Y;
                }, 0);
              }
          });
        }, q.prototype.onHeaders = function(G) {
          this.onHeadersCallbacks.push(G);
        }, q.prototype.onMessage = function(G) {
          this.onMessageCallbacks.push(G);
        }, q.prototype.onEnd = function(G) {
          this.onEndCallbacks.push(G);
        }, q.prototype.start = function(G) {
          if (this.started)
            throw new Error("Client already started - cannot .start()");
          this.started = !0;
          var H = new E.Metadata(G || {});
          H.set("content-type", "application/grpc-web+proto"), H.set("x-grpc-web", "1"), this.transport.start(H);
        }, q.prototype.send = function(G) {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .send()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .send()");
          if (!this.methodDefinition.requestStream && this.sentFirstMessage)
            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
          this.sentFirstMessage = !0;
          var H = $.frameRequest(G);
          this.transport.sendMessage(H);
        }, q.prototype.finishSend = function() {
          if (!this.started)
            throw new Error("Client not started - .finishSend() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .send()");
          if (this.finishedSending)
            throw new Error("Client already finished sending - cannot .finishSend()");
          this.finishedSending = !0, this.transport.finishSend();
        }, q.prototype.close = function() {
          if (!this.started)
            throw new Error("Client not started - .start() must be called before .close()");
          if (this.closed)
            throw new Error("Client already closed - cannot .close()");
          this.closed = !0, this.props.debug && L.debug("request.abort aborting request"), this.transport.cancel();
        }, q;
      }();
      function V(q) {
        var G = q.get("grpc-status") || [];
        if (G.length > 0)
          try {
            var H = G[0];
            return parseInt(H, 10);
          } catch {
            return null;
          }
        return null;
      }
    }, 346: function(v, S) {
      Object.defineProperty(S, "__esModule", { value: !0 }), S.debug = void 0, S.debug = function() {
        for (var g = [], E = 0; E < arguments.length; E++)
          g[E] = arguments[E];
        console.debug ? console.debug.apply(null, g) : console.log.apply(null, g);
      };
    }, 607: function(v, S, g) {
      Object.defineProperty(S, "__esModule", { value: !0 }), S.grpc = void 0;
      var E, _ = g(418), k = g(57), L = g(229), M = g(540), $ = g(210), J = g(859), V = g(8), q = g(938), G = g(35), H = g(934);
      (E = S.grpc || (S.grpc = {})).setDefaultTransport = k.setDefaultTransportFactory, E.CrossBrowserHttpTransport = J.CrossBrowserHttpTransport, E.FetchReadableStreamTransport = L.FetchReadableStreamTransport, E.XhrTransport = $.XhrTransport, E.WebsocketTransport = M.WebsocketTransport, E.Code = V.Code, E.Metadata = _.BrowserHeaders, E.client = function(B, Y) {
        return H.client(B, Y);
      }, E.invoke = q.invoke, E.unary = G.unary;
    }, 938: function(v, S, g) {
      Object.defineProperty(S, "__esModule", { value: !0 }), S.invoke = void 0;
      var E = g(934);
      S.invoke = function(_, k) {
        if (_.requestStream)
          throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
        var L = E.client(_, { host: k.host, transport: k.transport, debug: k.debug });
        return k.onHeaders && L.onHeaders(k.onHeaders), k.onMessage && L.onMessage(k.onMessage), k.onEnd && L.onEnd(k.onEnd), L.start(k.metadata), L.send(k.request), L.finishSend(), { close: function() {
          L.close();
        } };
      };
    }, 65: function(v, S, g) {
      Object.defineProperty(S, "__esModule", { value: !0 }), S.Metadata = void 0;
      var E = g(418);
      Object.defineProperty(S, "Metadata", { enumerable: !0, get: function() {
        return E.BrowserHeaders;
      } });
    }, 57: function(v, S, g) {
      Object.defineProperty(S, "__esModule", { value: !0 }), S.makeDefaultTransport = S.setDefaultTransportFactory = void 0;
      var E = g(859), _ = function(k) {
        return E.CrossBrowserHttpTransport({ withCredentials: !1 })(k);
      };
      S.setDefaultTransportFactory = function(k) {
        _ = k;
      }, S.makeDefaultTransport = function(k) {
        return _(k);
      };
    }, 229: function(v, S, g) {
      var E = this && this.__assign || function() {
        return (E = Object.assign || function(M) {
          for (var $, J = 1, V = arguments.length; J < V; J++)
            for (var q in $ = arguments[J])
              Object.prototype.hasOwnProperty.call($, q) && (M[q] = $[q]);
          return M;
        }).apply(this, arguments);
      };
      Object.defineProperty(S, "__esModule", { value: !0 }), S.detectFetchSupport = S.FetchReadableStreamTransport = void 0;
      var _ = g(65), k = g(346);
      S.FetchReadableStreamTransport = function(M) {
        return function($) {
          return function(J, V) {
            return J.debug && k.debug("fetchRequest", J), new L(J, V);
          }($, M);
        };
      };
      var L = function() {
        function M($, J) {
          this.cancelled = !1, this.controller = self.AbortController && new AbortController(), this.options = $, this.init = J;
        }
        return M.prototype.pump = function($, J) {
          var V = this;
          if (this.reader = $, this.cancelled)
            return this.options.debug && k.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(q) {
              V.options.debug && k.debug("Fetch.pump.reader.cancel exception", q);
            });
          this.reader.read().then(function(q) {
            if (q.done)
              return V.options.onEnd(), J;
            V.options.onChunk(q.value), V.pump(V.reader, J);
          }).catch(function(q) {
            V.cancelled ? V.options.debug && k.debug("Fetch.catch - request cancelled") : (V.cancelled = !0, V.options.debug && k.debug("Fetch.catch", q.message), V.options.onEnd(q));
          });
        }, M.prototype.send = function($) {
          var J = this;
          fetch(this.options.url, E(E({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: $, signal: this.controller && this.controller.signal })).then(function(V) {
            if (J.options.debug && k.debug("Fetch.response", V), J.options.onHeaders(new _.Metadata(V.headers), V.status), !V.body)
              return V;
            J.pump(V.body.getReader(), V);
          }).catch(function(V) {
            J.cancelled ? J.options.debug && k.debug("Fetch.catch - request cancelled") : (J.cancelled = !0, J.options.debug && k.debug("Fetch.catch", V.message), J.options.onEnd(V));
          });
        }, M.prototype.sendMessage = function($) {
          this.send($);
        }, M.prototype.finishSend = function() {
        }, M.prototype.start = function($) {
          this.metadata = $;
        }, M.prototype.cancel = function() {
          var $ = this;
          this.cancelled ? this.options.debug && k.debug("Fetch.cancel already cancelled") : (this.cancelled = !0, this.controller ? (this.options.debug && k.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && k.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && k.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(J) {
            $.options.debug && k.debug("Fetch.cancel.reader.cancel exception", J);
          })) : this.options.debug && k.debug("Fetch.cancel before reader"));
        }, M;
      }();
      S.detectFetchSupport = function() {
        return typeof Response < "u" && Response.prototype.hasOwnProperty("body") && typeof Headers == "function";
      };
    }, 859: function(v, S, g) {
      Object.defineProperty(S, "__esModule", { value: !0 }), S.CrossBrowserHttpTransport = void 0;
      var E = g(229), _ = g(210);
      S.CrossBrowserHttpTransport = function(k) {
        if (E.detectFetchSupport()) {
          var L = { credentials: k.withCredentials ? "include" : "same-origin" };
          return E.FetchReadableStreamTransport(L);
        }
        return _.XhrTransport({ withCredentials: k.withCredentials });
      };
    }, 210: function(v, S, g) {
      var E, _ = this && this.__extends || (E = function(G, H) {
        return (E = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(B, Y) {
          B.__proto__ = Y;
        } || function(B, Y) {
          for (var ne in Y)
            Object.prototype.hasOwnProperty.call(Y, ne) && (B[ne] = Y[ne]);
        })(G, H);
      }, function(G, H) {
        function B() {
          this.constructor = G;
        }
        E(G, H), G.prototype = H === null ? Object.create(H) : (B.prototype = H.prototype, new B());
      });
      Object.defineProperty(S, "__esModule", { value: !0 }), S.stringToArrayBuffer = S.MozChunkedArrayBufferXHR = S.XHR = S.XhrTransport = void 0;
      var k = g(65), L = g(346), M = g(849);
      S.XhrTransport = function(G) {
        return function(H) {
          if (M.detectMozXHRSupport())
            return new J(H, G);
          if (M.detectXHROverrideMimeTypeSupport())
            return new $(H, G);
          throw new Error("This environment's XHR implementation cannot support binary transfer.");
        };
      };
      var $ = function() {
        function G(H, B) {
          this.options = H, this.init = B;
        }
        return G.prototype.onProgressEvent = function() {
          this.options.debug && L.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
          var H = this.xhr.response.substr(this.index);
          this.index = this.xhr.response.length;
          var B = q(H);
          this.options.onChunk(B);
        }, G.prototype.onLoadEvent = function() {
          this.options.debug && L.debug("XHR.onLoadEvent"), this.options.onEnd();
        }, G.prototype.onStateChange = function() {
          this.options.debug && L.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new k.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
        }, G.prototype.sendMessage = function(H) {
          this.xhr.send(H);
        }, G.prototype.finishSend = function() {
        }, G.prototype.start = function(H) {
          var B = this;
          this.metadata = H;
          var Y = new XMLHttpRequest();
          this.xhr = Y, Y.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(ne, Z) {
            Y.setRequestHeader(ne, Z.join(", "));
          }), Y.withCredentials = !!this.init.withCredentials, Y.addEventListener("readystatechange", this.onStateChange.bind(this)), Y.addEventListener("progress", this.onProgressEvent.bind(this)), Y.addEventListener("loadend", this.onLoadEvent.bind(this)), Y.addEventListener("error", function(ne) {
            B.options.debug && L.debug("XHR.error", ne), B.options.onEnd(ne.error);
          });
        }, G.prototype.configureXhr = function() {
          this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
        }, G.prototype.cancel = function() {
          this.options.debug && L.debug("XHR.abort"), this.xhr.abort();
        }, G;
      }();
      S.XHR = $;
      var J = function(G) {
        function H() {
          return G !== null && G.apply(this, arguments) || this;
        }
        return _(H, G), H.prototype.configureXhr = function() {
          this.options.debug && L.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
        }, H.prototype.onProgressEvent = function() {
          var B = this.xhr.response;
          this.options.debug && L.debug("MozXHR.onProgressEvent: ", new Uint8Array(B)), this.options.onChunk(new Uint8Array(B));
        }, H;
      }($);
      function V(G, H) {
        var B = G.charCodeAt(H);
        if (B >= 55296 && B <= 56319) {
          var Y = G.charCodeAt(H + 1);
          Y >= 56320 && Y <= 57343 && (B = 65536 + (B - 55296 << 10) + (Y - 56320));
        }
        return B;
      }
      function q(G) {
        for (var H = new Uint8Array(G.length), B = 0, Y = 0; Y < G.length; Y++) {
          var ne = String.prototype.codePointAt ? G.codePointAt(Y) : V(G, Y);
          H[B++] = 255 & ne;
        }
        return H;
      }
      S.MozChunkedArrayBufferXHR = J, S.stringToArrayBuffer = q;
    }, 849: function(v, S) {
      var g;
      function E() {
        if (g !== void 0)
          return g;
        if (XMLHttpRequest) {
          g = new XMLHttpRequest();
          try {
            g.open("GET", "https://localhost");
          } catch {
          }
        }
        return g;
      }
      function _(k) {
        var L = E();
        if (!L)
          return !1;
        try {
          return L.responseType = k, L.responseType === k;
        } catch {
        }
        return !1;
      }
      Object.defineProperty(S, "__esModule", { value: !0 }), S.detectXHROverrideMimeTypeSupport = S.detectMozXHRSupport = S.xhrSupportsResponseType = void 0, S.xhrSupportsResponseType = _, S.detectMozXHRSupport = function() {
        return typeof XMLHttpRequest < "u" && _("moz-chunked-arraybuffer");
      }, S.detectXHROverrideMimeTypeSupport = function() {
        return typeof XMLHttpRequest < "u" && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
      };
    }, 540: function(v, S, g) {
      Object.defineProperty(S, "__esModule", { value: !0 }), S.WebsocketTransport = void 0;
      var E, _ = g(346), k = g(617);
      (function(M) {
        M[M.FINISH_SEND = 1] = "FINISH_SEND";
      })(E || (E = {}));
      var L = new Uint8Array([1]);
      S.WebsocketTransport = function() {
        return function(M) {
          return function($) {
            $.debug && _.debug("websocketRequest", $);
            var J, V = function(H) {
              if (H.substr(0, 8) === "https://")
                return "wss://" + H.substr(8);
              if (H.substr(0, 7) === "http://")
                return "ws://" + H.substr(7);
              throw new Error("Websocket transport constructed with non-https:// or http:// host.");
            }($.url), q = [];
            function G(H) {
              if (H === E.FINISH_SEND)
                J.send(L);
              else {
                var B = H, Y = new Int8Array(B.byteLength + 1);
                Y.set(new Uint8Array([0])), Y.set(B, 1), J.send(Y);
              }
            }
            return { sendMessage: function(H) {
              J && J.readyState !== J.CONNECTING ? G(H) : q.push(H);
            }, finishSend: function() {
              J && J.readyState !== J.CONNECTING ? G(E.FINISH_SEND) : q.push(E.FINISH_SEND);
            }, start: function(H) {
              (J = new WebSocket(V, ["grpc-websockets"])).binaryType = "arraybuffer", J.onopen = function() {
                var B;
                $.debug && _.debug("websocketRequest.onopen"), J.send((B = "", H.forEach(function(Y, ne) {
                  B += Y + ": " + ne.join(", ") + `\r
`;
                }), k.encodeASCII(B))), q.forEach(function(Y) {
                  G(Y);
                });
              }, J.onclose = function(B) {
                $.debug && _.debug("websocketRequest.onclose", B), $.onEnd();
              }, J.onerror = function(B) {
                $.debug && _.debug("websocketRequest.onerror", B);
              }, J.onmessage = function(B) {
                $.onChunk(new Uint8Array(B.data));
              };
            }, cancel: function() {
              $.debug && _.debug("websocket.abort"), J.close();
            } };
          }(M);
        };
      };
    }, 35: function(v, S, g) {
      Object.defineProperty(S, "__esModule", { value: !0 }), S.unary = void 0;
      var E = g(65), _ = g(934);
      S.unary = function(k, L) {
        if (k.responseStream)
          throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
        if (k.requestStream)
          throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
        var M = null, $ = null, J = _.client(k, { host: L.host, transport: L.transport, debug: L.debug });
        return J.onHeaders(function(V) {
          M = V;
        }), J.onMessage(function(V) {
          $ = V;
        }), J.onEnd(function(V, q, G) {
          L.onEnd({ status: V, statusMessage: q, headers: M || new E.Metadata(), message: $, trailers: G });
        }), J.start(L.metadata), J.send(L.request), J.finishSend(), { close: function() {
          J.close();
        } };
      };
    }, 882: function(v, S) {
      Object.defineProperty(S, "__esModule", { value: !0 }), S.frameRequest = void 0, S.frameRequest = function(g) {
        var E = g.serializeBinary(), _ = new ArrayBuffer(E.byteLength + 5);
        return new DataView(_, 1, 4).setUint32(0, E.length, !1), new Uint8Array(_, 5).set(E), new Uint8Array(_);
      };
    } }, l = {}, function v(S) {
      if (l[S])
        return l[S].exports;
      var g = l[S] = { exports: {} };
      return c[S].call(g.exports, g, g.exports, v), g.exports;
    }(607);
    var c, l;
  });
})(grpcWebClient_umd);
var grpcWebClient_umdExports = grpcWebClient_umd.exports;
class AbortError extends Error {
  constructor() {
    super("The operation has been aborted"), this.message = "The operation has been aborted", this.name = "AbortError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
  }
}
function isAbortError(a) {
  return typeof a == "object" && a !== null && a.name === "AbortError";
}
function throwIfAborted(a) {
  if (a.aborted)
    throw new AbortError();
}
function rethrowAbortError(a) {
  if (isAbortError(a))
    throw a;
}
function catchAbortError(a) {
  if (!isAbortError(a))
    throw a;
}
function execute(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    let v, S = !1;
    function g() {
      S || (S = !0, v != null && v());
    }
    const E = u((_) => {
      c(_), g();
    }, (_) => {
      l(_), g();
    });
    if (!S) {
      const _ = () => {
        const k = E();
        k == null ? l(new AbortError()) : k.then(() => {
          l(new AbortError());
        }, (L) => {
          l(L);
        }), g();
      };
      a.addEventListener("abort", _), v = () => {
        a.removeEventListener("abort", _);
      };
    }
  });
}
function abortable(a, u) {
  if (a.aborted) {
    const c = () => {
    };
    u.then(c, c);
  }
  return execute(a, (c, l) => (u.then(c, l), () => {
  }));
}
function delay$1(a, u) {
  return execute(a, (c) => {
    const l = typeof u == "number" ? u : u.getTime() - Date.now(), v = setTimeout(c, l);
    return () => {
      clearTimeout(v);
    };
  });
}
function forever(a) {
  return execute(a, () => () => {
  });
}
function waitForEvent(a, u, c, l) {
  return execute(a, (v) => {
    let S, g = !1;
    return S = listen(u, c, (..._) => {
      v(_.length > 1 ? _ : _[0]), g = !0, S != null && S();
    }, l), g && S(), () => {
      g = !0, S != null && S();
    };
  });
}
function listen(a, u, c, l) {
  if (isEventTarget(a))
    return a.addEventListener(u, c, l), () => a.removeEventListener(u, c, l);
  if (isJQueryStyleEventEmitter(a))
    return a.on(u, c), () => a.off(u, c);
  if (isNodeStyleEventEmitter(a))
    return a.addListener(u, c), () => a.removeListener(u, c);
  throw new Error("Invalid event target");
}
function isNodeStyleEventEmitter(a) {
  return isFunction$3(a.addListener) && isFunction$3(a.removeListener);
}
function isJQueryStyleEventEmitter(a) {
  return isFunction$3(a.on) && isFunction$3(a.off);
}
function isEventTarget(a) {
  return isFunction$3(a.addEventListener) && isFunction$3(a.removeEventListener);
}
const isFunction$3 = (a) => typeof a == "function";
var browser$3 = { exports: {} };
const _global = typeof self < "u" ? self : typeof window < "u" ? window : (
  /* otherwise */
  void 0
);
if (!_global)
  throw new Error(
    "Unable to find global scope. Are you sure this is running in the browser?"
  );
if (!_global.AbortController)
  throw new Error(
    'Could not find "AbortController" in the global scope. You need to polyfill it first'
  );
browser$3.exports = _global.AbortController;
browser$3.exports.default = _global.AbortController;
var browserExports = browser$3.exports;
const AbortController$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
function all(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    const v = new AbortController$1(), S = u(v.signal);
    if (S.length === 0) {
      c([]);
      return;
    }
    const g = () => {
      v.abort();
    };
    a.addEventListener("abort", g);
    let E;
    const _ = new Array(S.length);
    let k = 0;
    function L() {
      k += 1, k === S.length && (a.removeEventListener("abort", g), E != null ? l(E.reason) : c(_));
    }
    for (const [M, $] of S.entries())
      $.then((J) => {
        _[M] = J, L();
      }, (J) => {
        v.abort(), (E == null || !isAbortError(J) && isAbortError(E.reason)) && (E = { reason: J }), L();
      });
  });
}
function race$2(a, u) {
  return new Promise((c, l) => {
    if (a.aborted) {
      l(new AbortError());
      return;
    }
    const v = new AbortController$1(), S = u(v.signal), g = () => {
      v.abort();
    };
    a.addEventListener("abort", g);
    let E = 0;
    function _(L) {
      v.abort(), E += 1, E === S.length && (a.removeEventListener("abort", g), L.status === "fulfilled" ? c(L.value) : l(L.reason));
    }
    let k;
    for (const L of S)
      L.then((M) => {
        k == null && (k = { status: "fulfilled", value: M }), _(k);
      }, (M) => {
        (k == null || !isAbortError(M) && (k.status === "fulfilled" || isAbortError(k.reason))) && (k = { status: "rejected", reason: M }), _(k);
      });
  });
}
async function retry$1(a, u, c = {}) {
  const { baseMs: l = 1e3, maxDelayMs: v = 15e3, onError: S, maxAttempts: g = 1 / 0 } = c;
  let E = 0;
  const _ = () => {
    E = -1;
  };
  for (; ; )
    try {
      return await u(a, E, _);
    } catch (k) {
      if (rethrowAbortError(k), E >= g)
        throw k;
      let L;
      if (E === -1)
        L = 0;
      else {
        const M = Math.min(v, Math.pow(2, E) * l);
        L = Math.round(M * (1 + Math.random()) / 2);
      }
      S && S(k, E, L), L !== 0 && await delay$1(a, L), E += 1;
    }
}
function spawn(a, u) {
  if (a.aborted)
    return Promise.reject(new AbortError());
  const c = [], l = new AbortController$1(), v = l.signal, S = () => {
    l.abort();
  };
  a.addEventListener("abort", S);
  const g = () => {
    a.removeEventListener("abort", S);
  }, E = /* @__PURE__ */ new Set(), _ = () => {
    for (const M of E)
      M.abort();
  };
  v.addEventListener("abort", _);
  const k = () => {
    v.removeEventListener("abort", _);
  };
  let L = new Promise((M, $) => {
    let J, V;
    q((G) => u(G, {
      defer(H) {
        c.push(H);
      },
      fork: q
    })).join().then((G) => {
      l.abort(), J = { value: G };
    }, (G) => {
      l.abort(), (!isAbortError(G) || V == null) && (V = { error: G });
    });
    function q(G) {
      if (v.aborted)
        return {
          abort() {
          },
          async join() {
            throw new AbortError();
          }
        };
      const H = new AbortController$1(), B = H.signal, Y = G(B), ne = {
        abort() {
          H.abort();
        },
        join: () => Y
      };
      return E.add(ne), Y.catch(catchAbortError).catch((Z) => {
        V = { error: Z }, l.abort();
      }).finally(() => {
        E.delete(ne), E.size === 0 && (V != null ? $(V.error) : M(J.value));
      }), ne;
    }
  });
  return L = L.finally(() => {
    g(), k();
    let M = Promise.resolve();
    for (let $ = c.length - 1; $ >= 0; $--)
      M = M.finally(c[$]);
    return M;
  }), L;
}
function run(a) {
  const u = new AbortController$1(), c = a(u.signal).catch(catchAbortError);
  return () => (u.abort(), c);
}
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortError,
  abortable,
  all,
  catchAbortError,
  delay: delay$1,
  execute,
  forever,
  isAbortError,
  race: race$2,
  rethrowAbortError,
  retry: retry$1,
  run,
  spawn,
  throwIfAborted,
  waitForEvent
}, Symbol.toStringTag, { value: "Module" })), require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(es);
var AsyncSink$1 = {};
Object.defineProperty(AsyncSink$1, "__esModule", { value: !0 });
AsyncSink$1.AsyncSink = void 0;
const ARRAY_VALUE = "value", ARRAY_ERROR = "error";
class AsyncSink {
  constructor() {
    this._ended = !1, this._values = [], this._resolvers = [];
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  write(u) {
    this._push({ type: ARRAY_VALUE, value: u });
  }
  error(u) {
    this._push({ type: ARRAY_ERROR, error: u });
  }
  _push(u) {
    if (this._ended)
      throw new Error("AsyncSink already ended");
    if (this._resolvers.length > 0) {
      const { resolve: c, reject: l } = this._resolvers.shift();
      u.type === ARRAY_ERROR ? l(u.error) : c({ done: !1, value: u.value });
    } else
      this._values.push(u);
  }
  next() {
    if (this._values.length > 0) {
      const { type: u, value: c, error: l } = this._values.shift();
      return u === ARRAY_ERROR ? Promise.reject(l) : Promise.resolve({ done: !1, value: c });
    }
    return this._ended ? Promise.resolve({ done: !0 }) : new Promise((u, c) => {
      this._resolvers.push({ resolve: u, reject: c });
    });
  }
  end() {
    for (; this._resolvers.length > 0; )
      this._resolvers.shift().resolve({ done: !0 });
    this._ended = !0;
  }
}
AsyncSink$1.AsyncSink = AsyncSink;
var isAsyncIterable$1 = {};
Object.defineProperty(isAsyncIterable$1, "__esModule", { value: !0 });
isAsyncIterable$1.isAsyncIterable = void 0;
function isAsyncIterable(a) {
  return a != null && Symbol.asyncIterator in a;
}
isAsyncIterable$1.isAsyncIterable = isAsyncIterable;
var convertMetadata = {}, base64$2 = { exports: {} };
(function(a, u) {
  (function(c, l) {
    a.exports = l();
  })(typeof self < "u" ? self : typeof window < "u" ? window : commonjsGlobal$1, function() {
    var c = "3.7.2", l = c, v = typeof atob == "function", S = typeof btoa == "function", g = typeof Buffer == "function", E = typeof TextDecoder == "function" ? new TextDecoder() : void 0, _ = typeof TextEncoder == "function" ? new TextEncoder() : void 0, k = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", L = Array.prototype.slice.call(k), M = function(be) {
      var Ae = {};
      return be.forEach(function(qe, xe) {
        return Ae[qe] = xe;
      }), Ae;
    }(L), $ = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/, J = String.fromCharCode.bind(String), V = typeof Uint8Array.from == "function" ? Uint8Array.from.bind(Uint8Array) : function(be, Ae) {
      return Ae === void 0 && (Ae = function(qe) {
        return qe;
      }), new Uint8Array(Array.prototype.slice.call(be, 0).map(Ae));
    }, q = function(be) {
      return be.replace(/=/g, "").replace(/[+\/]/g, function(Ae) {
        return Ae == "+" ? "-" : "_";
      });
    }, G = function(be) {
      return be.replace(/[^A-Za-z0-9\+\/]/g, "");
    }, H = function(be) {
      for (var Ae, qe, xe, Pe, C = "", x = be.length % 3, Q = 0; Q < be.length; ) {
        if ((qe = be.charCodeAt(Q++)) > 255 || (xe = be.charCodeAt(Q++)) > 255 || (Pe = be.charCodeAt(Q++)) > 255)
          throw new TypeError("invalid character found");
        Ae = qe << 16 | xe << 8 | Pe, C += L[Ae >> 18 & 63] + L[Ae >> 12 & 63] + L[Ae >> 6 & 63] + L[Ae & 63];
      }
      return x ? C.slice(0, x - 3) + "===".substring(x) : C;
    }, B = S ? function(be) {
      return btoa(be);
    } : g ? function(be) {
      return Buffer.from(be, "binary").toString("base64");
    } : H, Y = g ? function(be) {
      return Buffer.from(be).toString("base64");
    } : function(be) {
      for (var Ae = 4096, qe = [], xe = 0, Pe = be.length; xe < Pe; xe += Ae)
        qe.push(J.apply(null, be.subarray(xe, xe + Ae)));
      return B(qe.join(""));
    }, ne = function(be, Ae) {
      return Ae === void 0 && (Ae = !1), Ae ? q(Y(be)) : Y(be);
    }, Z = function(be) {
      if (be.length < 2) {
        var Ae = be.charCodeAt(0);
        return Ae < 128 ? be : Ae < 2048 ? J(192 | Ae >>> 6) + J(128 | Ae & 63) : J(224 | Ae >>> 12 & 15) + J(128 | Ae >>> 6 & 63) + J(128 | Ae & 63);
      } else {
        var Ae = 65536 + (be.charCodeAt(0) - 55296) * 1024 + (be.charCodeAt(1) - 56320);
        return J(240 | Ae >>> 18 & 7) + J(128 | Ae >>> 12 & 63) + J(128 | Ae >>> 6 & 63) + J(128 | Ae & 63);
      }
    }, re = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g, oe = function(be) {
      return be.replace(re, Z);
    }, de = g ? function(be) {
      return Buffer.from(be, "utf8").toString("base64");
    } : _ ? function(be) {
      return Y(_.encode(be));
    } : function(be) {
      return B(oe(be));
    }, A = function(be, Ae) {
      return Ae === void 0 && (Ae = !1), Ae ? q(de(be)) : de(be);
    }, N = function(be) {
      return A(be, !0);
    }, D = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g, W = function(be) {
      switch (be.length) {
        case 4:
          var Ae = (7 & be.charCodeAt(0)) << 18 | (63 & be.charCodeAt(1)) << 12 | (63 & be.charCodeAt(2)) << 6 | 63 & be.charCodeAt(3), qe = Ae - 65536;
          return J((qe >>> 10) + 55296) + J((qe & 1023) + 56320);
        case 3:
          return J((15 & be.charCodeAt(0)) << 12 | (63 & be.charCodeAt(1)) << 6 | 63 & be.charCodeAt(2));
        default:
          return J((31 & be.charCodeAt(0)) << 6 | 63 & be.charCodeAt(1));
      }
    }, ee = function(be) {
      return be.replace(D, W);
    }, ae = function(be) {
      if (be = be.replace(/\s+/g, ""), !$.test(be))
        throw new TypeError("malformed base64.");
      be += "==".slice(2 - (be.length & 3));
      for (var Ae, qe = "", xe, Pe, C = 0; C < be.length; )
        Ae = M[be.charAt(C++)] << 18 | M[be.charAt(C++)] << 12 | (xe = M[be.charAt(C++)]) << 6 | (Pe = M[be.charAt(C++)]), qe += xe === 64 ? J(Ae >> 16 & 255) : Pe === 64 ? J(Ae >> 16 & 255, Ae >> 8 & 255) : J(Ae >> 16 & 255, Ae >> 8 & 255, Ae & 255);
      return qe;
    }, ye = v ? function(be) {
      return atob(G(be));
    } : g ? function(be) {
      return Buffer.from(be, "base64").toString("binary");
    } : ae, he = g ? function(be) {
      return V(Buffer.from(be, "base64"));
    } : function(be) {
      return V(ye(be), function(Ae) {
        return Ae.charCodeAt(0);
      });
    }, le = function(be) {
      return he(Be(be));
    }, we = g ? function(be) {
      return Buffer.from(be, "base64").toString("utf8");
    } : E ? function(be) {
      return E.decode(he(be));
    } : function(be) {
      return ee(ye(be));
    }, Be = function(be) {
      return G(be.replace(/[-_]/g, function(Ae) {
        return Ae == "-" ? "+" : "/";
      }));
    }, Ne = function(be) {
      return we(Be(be));
    }, Le = function(be) {
      if (typeof be != "string")
        return !1;
      var Ae = be.replace(/\s+/g, "").replace(/={0,2}$/, "");
      return !/[^\s0-9a-zA-Z\+/]/.test(Ae) || !/[^\s0-9a-zA-Z\-_]/.test(Ae);
    }, $e = function(be) {
      return {
        value: be,
        enumerable: !1,
        writable: !0,
        configurable: !0
      };
    }, Ue = function() {
      var be = function(Ae, qe) {
        return Object.defineProperty(String.prototype, Ae, $e(qe));
      };
      be("fromBase64", function() {
        return Ne(this);
      }), be("toBase64", function(Ae) {
        return A(this, Ae);
      }), be("toBase64URI", function() {
        return A(this, !0);
      }), be("toBase64URL", function() {
        return A(this, !0);
      }), be("toUint8Array", function() {
        return le(this);
      });
    }, Ge = function() {
      var be = function(Ae, qe) {
        return Object.defineProperty(Uint8Array.prototype, Ae, $e(qe));
      };
      be("toBase64", function(Ae) {
        return ne(this, Ae);
      }), be("toBase64URI", function() {
        return ne(this, !0);
      }), be("toBase64URL", function() {
        return ne(this, !0);
      });
    }, He = function() {
      Ue(), Ge();
    }, Ve = {
      version: c,
      VERSION: l,
      atob: ye,
      atobPolyfill: ae,
      btoa: B,
      btoaPolyfill: H,
      fromBase64: Ne,
      toBase64: A,
      encode: A,
      encodeURI: N,
      encodeURL: N,
      utob: oe,
      btou: ee,
      decode: Ne,
      isValid: Le,
      fromUint8Array: ne,
      toUint8Array: le,
      extendString: Ue,
      extendUint8Array: Ge,
      extendBuiltins: He
    };
    return Ve.Base64 = {}, Object.keys(Ve).forEach(function(be) {
      return Ve.Base64[be] = Ve[be];
    }), Ve;
  });
})(base64$2);
var base64Exports = base64$2.exports;
Object.defineProperty(convertMetadata, "__esModule", { value: !0 });
convertMetadata.convertMetadataFromGrpcWeb = convertMetadata.convertMetadataToGrpcWeb = void 0;
const grpc_web_1$4 = grpcWebClient_umdExports, nice_grpc_common_1$5 = lib, js_base64_1 = base64Exports;
function convertMetadataToGrpcWeb(a) {
  const u = new grpc_web_1$4.grpc.Metadata();
  for (const [c, l] of a)
    for (const v of l)
      u.append(c, typeof v == "string" ? v : js_base64_1.Base64.fromUint8Array(v));
  return u;
}
convertMetadata.convertMetadataToGrpcWeb = convertMetadataToGrpcWeb;
function convertMetadataFromGrpcWeb(a) {
  const u = (0, nice_grpc_common_1$5.Metadata)();
  for (const [c, l] of Object.entries(a.headersMap))
    u.set(c, c.endsWith("-bin") ? l.map((v) => js_base64_1.Base64.toUint8Array(v)) : l);
  return u;
}
convertMetadata.convertMetadataFromGrpcWeb = convertMetadataFromGrpcWeb;
var __importDefault$h = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createBidiStreamingMethod$1, "__esModule", { value: !0 });
createBidiStreamingMethod$1.createBidiStreamingMethod = void 0;
const nice_grpc_common_1$4 = lib, grpc_web_1$3 = grpcWebClient_umdExports, abort_controller_x_1$4 = require$$1$1, node_abort_controller_1$3 = __importDefault$h(browserExports), AsyncSink_1$1 = AsyncSink$1, service_definitions_1$4 = serviceDefinitions, isAsyncIterable_1$3 = isAsyncIterable$1, convertMetadata_1$3 = convertMetadata;
function createBidiStreamingMethod(a, u, c, l) {
  const v = (0, service_definitions_1$4.toGrpcWebMethodDefinition)(a), S = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* g(_, k) {
    if (!(0, isAsyncIterable_1$3.isAsyncIterable)(_))
      throw new Error("A middleware passed invalid request to next(): expected a single message for bidirectional streaming method");
    const { metadata: L = (0, nice_grpc_common_1$4.Metadata)(), signal: M = new node_abort_controller_1$3.default().signal, onHeader: $, onTrailer: J } = k, V = new node_abort_controller_1$3.default(), q = new AsyncSink_1$1.AsyncSink(), G = grpc_web_1$3.grpc.client(v, {
      host: u.address,
      transport: u.transport
    });
    G.onHeaders((Y) => {
      $ == null || $((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(Y));
    }), G.onMessage((Y) => {
      q.write(Y);
    }), G.onEnd((Y, ne, Z) => {
      J == null || J((0, convertMetadata_1$3.convertMetadataFromGrpcWeb)(Z)), Y === grpc_web_1$3.grpc.Code.OK ? q.end() : q.error(new nice_grpc_common_1$4.ClientError(a.path, +Y, ne));
    }), G.start((0, convertMetadata_1$3.convertMetadataToGrpcWeb)(L));
    let H;
    pipeRequest$1(V.signal, _, G, a).then(() => {
      G.finishSend();
    }, (Y) => {
      (0, abort_controller_x_1$4.isAbortError)(Y) || (H = Y, G.close(), q.end());
    });
    const B = () => {
      q.error(new abort_controller_x_1$4.AbortError()), V.abort(), G.close();
    };
    M.addEventListener("abort", B);
    try {
      yield* q;
    } finally {
      if (V.abort(), M.removeEventListener("abort", B), (0, abort_controller_x_1$4.throwIfAborted)(M), H)
        throw H;
    }
  }
  const E = c == null ? g : (_, k) => c({
    method: S,
    requestStream: !0,
    request: _,
    responseStream: !0,
    next: g
  }, k);
  return (_, k) => {
    const M = E(_, {
      ...l,
      ...k
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const $ = await M.next();
            return $.done && $.value != null ? await M.throw(new Error("A middleware returned a message, but expected to return void for bidirectional streaming method")) : $;
          },
          return() {
            return M.return();
          },
          throw($) {
            return M.throw($);
          }
        };
      }
    };
  };
}
createBidiStreamingMethod$1.createBidiStreamingMethod = createBidiStreamingMethod;
async function pipeRequest$1(a, u, c, l) {
  for await (const v of u)
    (0, abort_controller_x_1$4.throwIfAborted)(a), c.send({
      serializeBinary: () => l.requestSerialize(v)
    });
}
var createClientStreamingMethod$1 = {}, __importDefault$g = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createClientStreamingMethod$1, "__esModule", { value: !0 });
createClientStreamingMethod$1.createClientStreamingMethod = void 0;
const nice_grpc_common_1$3 = lib, grpc_web_1$2 = grpcWebClient_umdExports, abort_controller_x_1$3 = require$$1$1, node_abort_controller_1$2 = __importDefault$g(browserExports), service_definitions_1$3 = serviceDefinitions, isAsyncIterable_1$2 = isAsyncIterable$1, convertMetadata_1$2 = convertMetadata;
function createClientStreamingMethod(a, u, c, l) {
  const v = (0, service_definitions_1$3.toGrpcWebMethodDefinition)(a), S = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* g(_, k) {
    if (!(0, isAsyncIterable_1$2.isAsyncIterable)(_))
      throw new Error("A middleware passed invalid request to next(): expected a single message for client streaming method");
    const { metadata: L = (0, nice_grpc_common_1$3.Metadata)(), signal: M = new node_abort_controller_1$2.default().signal, onHeader: $, onTrailer: J } = k;
    return await (0, abort_controller_x_1$3.execute)(M, (V, q) => {
      const G = new node_abort_controller_1$2.default();
      let H;
      const B = grpc_web_1$2.grpc.client(v, {
        host: u.address,
        transport: u.transport
      });
      return B.onHeaders((Y) => {
        $ == null || $((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(Y));
      }), B.onMessage((Y) => {
        H = Y;
      }), B.onEnd((Y, ne, Z) => {
        J == null || J((0, convertMetadata_1$2.convertMetadataFromGrpcWeb)(Z)), G.abort(), Y === grpc_web_1$2.grpc.Code.OK ? V(H) : q(new nice_grpc_common_1$3.ClientError(a.path, +Y, ne));
      }), B.start((0, convertMetadata_1$2.convertMetadataToGrpcWeb)(L)), pipeRequest(G.signal, _, B, a).then(() => {
        B.finishSend();
      }, (Y) => {
        (0, abort_controller_x_1$3.isAbortError)(Y) || (q(Y), B.close());
      }), () => {
        G.abort(), B.close();
      };
    });
  }
  const E = c == null ? g : (_, k) => c({
    method: S,
    requestStream: !0,
    request: _,
    responseStream: !1,
    next: g
  }, k);
  return async (_, k) => {
    const M = E(_, {
      ...l,
      ...k
    })[Symbol.asyncIterator]();
    let $ = await M.next();
    for (; ; ) {
      if (!$.done) {
        $ = await M.throw(new Error("A middleware yielded a message, but expected to only return a message for client streaming method"));
        continue;
      }
      if ($.value == null) {
        $ = await M.throw(new Error("A middleware returned void, but expected to return a message for client streaming method"));
        continue;
      }
      return $.value;
    }
  };
}
createClientStreamingMethod$1.createClientStreamingMethod = createClientStreamingMethod;
async function pipeRequest(a, u, c, l) {
  for await (const v of u)
    (0, abort_controller_x_1$3.throwIfAborted)(a), c.send({
      serializeBinary: () => l.requestSerialize(v)
    });
}
var createServerStreamingMethod$1 = {}, __importDefault$f = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createServerStreamingMethod$1, "__esModule", { value: !0 });
createServerStreamingMethod$1.createServerStreamingMethod = void 0;
const grpc_web_1$1 = grpcWebClient_umdExports, abort_controller_x_1$2 = require$$1$1, AsyncSink_1 = AsyncSink$1, nice_grpc_common_1$2 = lib, node_abort_controller_1$1 = __importDefault$f(browserExports), service_definitions_1$2 = serviceDefinitions, convertMetadata_1$1 = convertMetadata, isAsyncIterable_1$1 = isAsyncIterable$1;
function createServerStreamingMethod(a, u, c, l) {
  const v = (0, service_definitions_1$2.toGrpcWebMethodDefinition)(a), S = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* g(_, k) {
    if ((0, isAsyncIterable_1$1.isAsyncIterable)(_))
      throw new Error("A middleware passed invalid request to next(): expected a single message for server streaming method");
    const { metadata: L = (0, nice_grpc_common_1$2.Metadata)(), signal: M = new node_abort_controller_1$1.default().signal, onHeader: $, onTrailer: J } = k, V = new AsyncSink_1.AsyncSink(), q = grpc_web_1$1.grpc.client(v, {
      host: u.address,
      transport: u.transport
    });
    q.onHeaders((H) => {
      $ == null || $((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(H));
    }), q.onMessage((H) => {
      V.write(H);
    }), q.onEnd((H, B, Y) => {
      J == null || J((0, convertMetadata_1$1.convertMetadataFromGrpcWeb)(Y)), H === grpc_web_1$1.grpc.Code.OK ? V.end() : V.error(new nice_grpc_common_1$2.ClientError(a.path, +H, B));
    }), q.start((0, convertMetadata_1$1.convertMetadataToGrpcWeb)(L)), q.send({
      serializeBinary: () => a.requestSerialize(_)
    }), q.finishSend();
    const G = () => {
      V.error(new abort_controller_x_1$2.AbortError()), q.close();
    };
    M.addEventListener("abort", G);
    try {
      yield* V;
    } finally {
      M.removeEventListener("abort", G), (0, abort_controller_x_1$2.throwIfAborted)(M);
    }
  }
  const E = c == null ? g : (_, k) => c({
    method: S,
    requestStream: !1,
    request: _,
    responseStream: !0,
    next: g
  }, k);
  return (_, k) => {
    const M = E(_, {
      ...l,
      ...k
    })[Symbol.asyncIterator]();
    return {
      [Symbol.asyncIterator]() {
        return {
          async next() {
            const $ = await M.next();
            return $.done && $.value != null ? await M.throw(new Error("A middleware returned a message, but expected to return void for server streaming method")) : $;
          },
          return() {
            return M.return();
          },
          throw($) {
            return M.throw($);
          }
        };
      }
    };
  };
}
createServerStreamingMethod$1.createServerStreamingMethod = createServerStreamingMethod;
var createUnaryMethod$1 = {}, __importDefault$e = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(createUnaryMethod$1, "__esModule", { value: !0 });
createUnaryMethod$1.createUnaryMethod = void 0;
const nice_grpc_common_1$1 = lib, grpc_web_1 = grpcWebClient_umdExports, abort_controller_x_1$1 = require$$1$1, node_abort_controller_1 = __importDefault$e(browserExports), service_definitions_1$1 = serviceDefinitions, isAsyncIterable_1 = isAsyncIterable$1, convertMetadata_1 = convertMetadata;
function createUnaryMethod(a, u, c, l) {
  const v = (0, service_definitions_1$1.toGrpcWebMethodDefinition)(a), S = {
    path: a.path,
    requestStream: a.requestStream,
    responseStream: a.responseStream,
    options: a.options
  };
  async function* g(_, k) {
    if ((0, isAsyncIterable_1.isAsyncIterable)(_))
      throw new Error("A middleware passed invalid request to next(): expected a single message for unary method");
    const { metadata: L = (0, nice_grpc_common_1$1.Metadata)(), signal: M = new node_abort_controller_1.default().signal, onHeader: $, onTrailer: J } = k;
    return await (0, abort_controller_x_1$1.execute)(M, (V, q) => {
      let G;
      const H = grpc_web_1.grpc.client(v, {
        host: u.address,
        transport: u.transport
      });
      return H.onHeaders((B) => {
        $ == null || $((0, convertMetadata_1.convertMetadataFromGrpcWeb)(B));
      }), H.onMessage((B) => {
        G = B;
      }), H.onEnd((B, Y, ne) => {
        J == null || J((0, convertMetadata_1.convertMetadataFromGrpcWeb)(ne)), B === grpc_web_1.grpc.Code.OK ? V(G) : q(new nice_grpc_common_1$1.ClientError(a.path, +B, Y));
      }), H.start((0, convertMetadata_1.convertMetadataToGrpcWeb)(L)), H.send({
        serializeBinary: () => a.requestSerialize(_)
      }), H.finishSend(), () => {
        H.close();
      };
    });
  }
  const E = c == null ? g : (_, k) => c({
    method: S,
    requestStream: !1,
    request: _,
    responseStream: !1,
    next: g
  }, k);
  return async (_, k) => {
    const M = E(_, {
      ...l,
      ...k
    })[Symbol.asyncIterator]();
    let $ = await M.next();
    for (; ; ) {
      if (!$.done) {
        $ = await M.throw(new Error("A middleware yielded a message, but expected to only return a message for unary method"));
        continue;
      }
      if ($.value == null) {
        $ = await M.throw(new Error("A middleware returned void, but expected to return a message for unary method"));
        continue;
      }
      return $.value;
    }
  };
}
createUnaryMethod$1.createUnaryMethod = createUnaryMethod;
Object.defineProperty(ClientFactory, "__esModule", { value: !0 });
ClientFactory.createClient = ClientFactory.createClientFactory = void 0;
const nice_grpc_common_1 = lib, service_definitions_1 = serviceDefinitions, createBidiStreamingMethod_1 = createBidiStreamingMethod$1, createClientStreamingMethod_1 = createClientStreamingMethod$1, createServerStreamingMethod_1 = createServerStreamingMethod$1, createUnaryMethod_1 = createUnaryMethod$1;
function createClientFactory() {
  return createClientFactoryWithMiddleware();
}
ClientFactory.createClientFactory = createClientFactory;
function createClient(a, u, c) {
  return createClientFactory().create(a, u, c);
}
ClientFactory.createClient = createClient;
function createClientFactoryWithMiddleware(a) {
  return {
    use(u) {
      return createClientFactoryWithMiddleware(a == null ? u : (0, nice_grpc_common_1.composeClientMiddleware)(a, u));
    },
    create(u, c, l = {}) {
      const v = {}, S = Object.entries((0, service_definitions_1.normalizeServiceDefinition)(u));
      for (const [g, E] of S) {
        const _ = {
          ...l["*"],
          ...l[g]
        };
        E.requestStream ? E.responseStream ? v[g] = (0, createBidiStreamingMethod_1.createBidiStreamingMethod)(E, c, a, _) : v[g] = (0, createClientStreamingMethod_1.createClientStreamingMethod)(E, c, a, _) : E.responseStream ? v[g] = (0, createServerStreamingMethod_1.createServerStreamingMethod)(E, c, a, _) : v[g] = (0, createUnaryMethod_1.createUnaryMethod)(E, c, a, _);
      }
      return v;
    }
  };
}
var Client = {};
Object.defineProperty(Client, "__esModule", { value: !0 });
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(v, S, g, E) {
    E === void 0 && (E = g);
    var _ = Object.getOwnPropertyDescriptor(S, g);
    (!_ || ("get" in _ ? !S.__esModule : _.writable || _.configurable)) && (_ = { enumerable: !0, get: function() {
      return S[g];
    } }), Object.defineProperty(v, E, _);
  } : function(v, S, g, E) {
    E === void 0 && (E = g), v[E] = S[g];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(v, S) {
    for (var g in v)
      g !== "default" && !Object.prototype.hasOwnProperty.call(S, g) && u(S, v, g);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.Status = a.Metadata = a.composeClientMiddleware = a.ClientError = void 0;
  var l = lib;
  Object.defineProperty(a, "ClientError", { enumerable: !0, get: function() {
    return l.ClientError;
  } }), Object.defineProperty(a, "composeClientMiddleware", { enumerable: !0, get: function() {
    return l.composeClientMiddleware;
  } }), Object.defineProperty(a, "Metadata", { enumerable: !0, get: function() {
    return l.Metadata;
  } }), Object.defineProperty(a, "Status", { enumerable: !0, get: function() {
    return l.Status;
  } }), c(serviceDefinitions, a), c(channel, a), c(ClientFactory, a), c(Client, a);
})(lib$1);
var dist$2 = {}, api$3 = {}, umd = { exports: {} };
(function(a, u) {
  var c = function(l) {
    Object.defineProperty(l, "__esModule", {
      value: !0
    }), l.default = void 0;
    /**
     * @license
     * Copyright 2009 The Closure Library Authors
     * Copyright 2020 Daniel Wirtz / The long.js Authors.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * SPDX-License-Identifier: Apache-2.0
     */
    var v = null;
    try {
      v = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
    } catch {
    }
    function S(he, le, we) {
      this.low = he | 0, this.high = le | 0, this.unsigned = !!we;
    }
    S.prototype.__isLong__, Object.defineProperty(S.prototype, "__isLong__", {
      value: !0
    });
    function g(he) {
      return (he && he.__isLong__) === !0;
    }
    function E(he) {
      var le = Math.clz32(he & -he);
      return he ? 31 - le : le;
    }
    S.isLong = g;
    var _ = {}, k = {};
    function L(he, le) {
      var we, Be, Ne;
      return le ? (he >>>= 0, (Ne = 0 <= he && he < 256) && (Be = k[he], Be) ? Be : (we = $(he, 0, !0), Ne && (k[he] = we), we)) : (he |= 0, (Ne = -128 <= he && he < 128) && (Be = _[he], Be) ? Be : (we = $(he, he < 0 ? -1 : 0, !1), Ne && (_[he] = we), we));
    }
    S.fromInt = L;
    function M(he, le) {
      if (isNaN(he))
        return le ? oe : re;
      if (le) {
        if (he < 0)
          return oe;
        if (he >= Y)
          return W;
      } else {
        if (he <= -ne)
          return ee;
        if (he + 1 >= ne)
          return D;
      }
      return he < 0 ? M(-he, le).neg() : $(he % B | 0, he / B | 0, le);
    }
    S.fromNumber = M;
    function $(he, le, we) {
      return new S(he, le, we);
    }
    S.fromBits = $;
    var J = Math.pow;
    function V(he, le, we) {
      if (he.length === 0)
        throw Error("empty string");
      if (typeof le == "number" ? (we = le, le = !1) : le = !!le, he === "NaN" || he === "Infinity" || he === "+Infinity" || he === "-Infinity")
        return le ? oe : re;
      if (we = we || 10, we < 2 || 36 < we)
        throw RangeError("radix");
      var Be;
      if ((Be = he.indexOf("-")) > 0)
        throw Error("interior hyphen");
      if (Be === 0)
        return V(he.substring(1), le, we).neg();
      for (var Ne = M(J(we, 8)), Le = re, $e = 0; $e < he.length; $e += 8) {
        var Ue = Math.min(8, he.length - $e), Ge = parseInt(he.substring($e, $e + Ue), we);
        if (Ue < 8) {
          var He = M(J(we, Ue));
          Le = Le.mul(He).add(M(Ge));
        } else
          Le = Le.mul(Ne), Le = Le.add(M(Ge));
      }
      return Le.unsigned = le, Le;
    }
    S.fromString = V;
    function q(he, le) {
      return typeof he == "number" ? M(he, le) : typeof he == "string" ? V(he, le) : $(he.low, he.high, typeof le == "boolean" ? le : he.unsigned);
    }
    S.fromValue = q;
    var G = 65536, H = 1 << 24, B = G * G, Y = B * B, ne = Y / 2, Z = L(H), re = L(0);
    S.ZERO = re;
    var oe = L(0, !0);
    S.UZERO = oe;
    var de = L(1);
    S.ONE = de;
    var A = L(1, !0);
    S.UONE = A;
    var N = L(-1);
    S.NEG_ONE = N;
    var D = $(-1, 2147483647, !1);
    S.MAX_VALUE = D;
    var W = $(-1, -1, !0);
    S.MAX_UNSIGNED_VALUE = W;
    var ee = $(0, -2147483648, !1);
    S.MIN_VALUE = ee;
    var ae = S.prototype;
    ae.toInt = function() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }, ae.toNumber = function() {
      return this.unsigned ? (this.high >>> 0) * B + (this.low >>> 0) : this.high * B + (this.low >>> 0);
    }, ae.toString = function(le) {
      if (le = le || 10, le < 2 || 36 < le)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative())
        if (this.eq(ee)) {
          var we = M(le), Be = this.div(we), Ne = Be.mul(we).sub(this);
          return Be.toString(le) + Ne.toInt().toString(le);
        } else
          return "-" + this.neg().toString(le);
      for (var Le = M(J(le, 6), this.unsigned), $e = this, Ue = ""; ; ) {
        var Ge = $e.div(Le), He = $e.sub(Ge.mul(Le)).toInt() >>> 0, Ve = He.toString(le);
        if ($e = Ge, $e.isZero())
          return Ve + Ue;
        for (; Ve.length < 6; )
          Ve = "0" + Ve;
        Ue = "" + Ve + Ue;
      }
    }, ae.getHighBits = function() {
      return this.high;
    }, ae.getHighBitsUnsigned = function() {
      return this.high >>> 0;
    }, ae.getLowBits = function() {
      return this.low;
    }, ae.getLowBitsUnsigned = function() {
      return this.low >>> 0;
    }, ae.getNumBitsAbs = function() {
      if (this.isNegative())
        return this.eq(ee) ? 64 : this.neg().getNumBitsAbs();
      for (var le = this.high != 0 ? this.high : this.low, we = 31; we > 0 && !(le & 1 << we); we--)
        ;
      return this.high != 0 ? we + 33 : we + 1;
    }, ae.isZero = function() {
      return this.high === 0 && this.low === 0;
    }, ae.eqz = ae.isZero, ae.isNegative = function() {
      return !this.unsigned && this.high < 0;
    }, ae.isPositive = function() {
      return this.unsigned || this.high >= 0;
    }, ae.isOdd = function() {
      return (this.low & 1) === 1;
    }, ae.isEven = function() {
      return (this.low & 1) === 0;
    }, ae.equals = function(le) {
      return g(le) || (le = q(le)), this.unsigned !== le.unsigned && this.high >>> 31 === 1 && le.high >>> 31 === 1 ? !1 : this.high === le.high && this.low === le.low;
    }, ae.eq = ae.equals, ae.notEquals = function(le) {
      return !this.eq(
        /* validates */
        le
      );
    }, ae.neq = ae.notEquals, ae.ne = ae.notEquals, ae.lessThan = function(le) {
      return this.comp(
        /* validates */
        le
      ) < 0;
    }, ae.lt = ae.lessThan, ae.lessThanOrEqual = function(le) {
      return this.comp(
        /* validates */
        le
      ) <= 0;
    }, ae.lte = ae.lessThanOrEqual, ae.le = ae.lessThanOrEqual, ae.greaterThan = function(le) {
      return this.comp(
        /* validates */
        le
      ) > 0;
    }, ae.gt = ae.greaterThan, ae.greaterThanOrEqual = function(le) {
      return this.comp(
        /* validates */
        le
      ) >= 0;
    }, ae.gte = ae.greaterThanOrEqual, ae.ge = ae.greaterThanOrEqual, ae.compare = function(le) {
      if (g(le) || (le = q(le)), this.eq(le))
        return 0;
      var we = this.isNegative(), Be = le.isNegative();
      return we && !Be ? -1 : !we && Be ? 1 : this.unsigned ? le.high >>> 0 > this.high >>> 0 || le.high === this.high && le.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(le).isNegative() ? -1 : 1;
    }, ae.comp = ae.compare, ae.negate = function() {
      return !this.unsigned && this.eq(ee) ? ee : this.not().add(de);
    }, ae.neg = ae.negate, ae.add = function(le) {
      g(le) || (le = q(le));
      var we = this.high >>> 16, Be = this.high & 65535, Ne = this.low >>> 16, Le = this.low & 65535, $e = le.high >>> 16, Ue = le.high & 65535, Ge = le.low >>> 16, He = le.low & 65535, Ve = 0, be = 0, Ae = 0, qe = 0;
      return qe += Le + He, Ae += qe >>> 16, qe &= 65535, Ae += Ne + Ge, be += Ae >>> 16, Ae &= 65535, be += Be + Ue, Ve += be >>> 16, be &= 65535, Ve += we + $e, Ve &= 65535, $(Ae << 16 | qe, Ve << 16 | be, this.unsigned);
    }, ae.subtract = function(le) {
      return g(le) || (le = q(le)), this.add(le.neg());
    }, ae.sub = ae.subtract, ae.multiply = function(le) {
      if (this.isZero())
        return this;
      if (g(le) || (le = q(le)), v) {
        var we = v.mul(this.low, this.high, le.low, le.high);
        return $(we, v.get_high(), this.unsigned);
      }
      if (le.isZero())
        return this.unsigned ? oe : re;
      if (this.eq(ee))
        return le.isOdd() ? ee : re;
      if (le.eq(ee))
        return this.isOdd() ? ee : re;
      if (this.isNegative())
        return le.isNegative() ? this.neg().mul(le.neg()) : this.neg().mul(le).neg();
      if (le.isNegative())
        return this.mul(le.neg()).neg();
      if (this.lt(Z) && le.lt(Z))
        return M(this.toNumber() * le.toNumber(), this.unsigned);
      var Be = this.high >>> 16, Ne = this.high & 65535, Le = this.low >>> 16, $e = this.low & 65535, Ue = le.high >>> 16, Ge = le.high & 65535, He = le.low >>> 16, Ve = le.low & 65535, be = 0, Ae = 0, qe = 0, xe = 0;
      return xe += $e * Ve, qe += xe >>> 16, xe &= 65535, qe += Le * Ve, Ae += qe >>> 16, qe &= 65535, qe += $e * He, Ae += qe >>> 16, qe &= 65535, Ae += Ne * Ve, be += Ae >>> 16, Ae &= 65535, Ae += Le * He, be += Ae >>> 16, Ae &= 65535, Ae += $e * Ge, be += Ae >>> 16, Ae &= 65535, be += Be * Ve + Ne * He + Le * Ge + $e * Ue, be &= 65535, $(qe << 16 | xe, be << 16 | Ae, this.unsigned);
    }, ae.mul = ae.multiply, ae.divide = function(le) {
      if (g(le) || (le = q(le)), le.isZero())
        throw Error("division by zero");
      if (v) {
        if (!this.unsigned && this.high === -2147483648 && le.low === -1 && le.high === -1)
          return this;
        var we = (this.unsigned ? v.div_u : v.div_s)(this.low, this.high, le.low, le.high);
        return $(we, v.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? oe : re;
      var Be, Ne, Le;
      if (this.unsigned) {
        if (le.unsigned || (le = le.toUnsigned()), le.gt(this))
          return oe;
        if (le.gt(this.shru(1)))
          return A;
        Le = oe;
      } else {
        if (this.eq(ee)) {
          if (le.eq(de) || le.eq(N))
            return ee;
          if (le.eq(ee))
            return de;
          var $e = this.shr(1);
          return Be = $e.div(le).shl(1), Be.eq(re) ? le.isNegative() ? de : N : (Ne = this.sub(le.mul(Be)), Le = Be.add(Ne.div(le)), Le);
        } else if (le.eq(ee))
          return this.unsigned ? oe : re;
        if (this.isNegative())
          return le.isNegative() ? this.neg().div(le.neg()) : this.neg().div(le).neg();
        if (le.isNegative())
          return this.div(le.neg()).neg();
        Le = re;
      }
      for (Ne = this; Ne.gte(le); ) {
        Be = Math.max(1, Math.floor(Ne.toNumber() / le.toNumber()));
        for (var Ue = Math.ceil(Math.log(Be) / Math.LN2), Ge = Ue <= 48 ? 1 : J(2, Ue - 48), He = M(Be), Ve = He.mul(le); Ve.isNegative() || Ve.gt(Ne); )
          Be -= Ge, He = M(Be, this.unsigned), Ve = He.mul(le);
        He.isZero() && (He = de), Le = Le.add(He), Ne = Ne.sub(Ve);
      }
      return Le;
    }, ae.div = ae.divide, ae.modulo = function(le) {
      if (g(le) || (le = q(le)), v) {
        var we = (this.unsigned ? v.rem_u : v.rem_s)(this.low, this.high, le.low, le.high);
        return $(we, v.get_high(), this.unsigned);
      }
      return this.sub(this.div(le).mul(le));
    }, ae.mod = ae.modulo, ae.rem = ae.modulo, ae.not = function() {
      return $(~this.low, ~this.high, this.unsigned);
    }, ae.countLeadingZeros = function() {
      return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
    }, ae.clz = ae.countLeadingZeros, ae.countTrailingZeros = function() {
      return this.low ? E(this.low) : E(this.high) + 32;
    }, ae.ctz = ae.countTrailingZeros, ae.and = function(le) {
      return g(le) || (le = q(le)), $(this.low & le.low, this.high & le.high, this.unsigned);
    }, ae.or = function(le) {
      return g(le) || (le = q(le)), $(this.low | le.low, this.high | le.high, this.unsigned);
    }, ae.xor = function(le) {
      return g(le) || (le = q(le)), $(this.low ^ le.low, this.high ^ le.high, this.unsigned);
    }, ae.shiftLeft = function(le) {
      return g(le) && (le = le.toInt()), (le &= 63) === 0 ? this : le < 32 ? $(this.low << le, this.high << le | this.low >>> 32 - le, this.unsigned) : $(0, this.low << le - 32, this.unsigned);
    }, ae.shl = ae.shiftLeft, ae.shiftRight = function(le) {
      return g(le) && (le = le.toInt()), (le &= 63) === 0 ? this : le < 32 ? $(this.low >>> le | this.high << 32 - le, this.high >> le, this.unsigned) : $(this.high >> le - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }, ae.shr = ae.shiftRight, ae.shiftRightUnsigned = function(le) {
      return g(le) && (le = le.toInt()), (le &= 63) === 0 ? this : le < 32 ? $(this.low >>> le | this.high << 32 - le, this.high >>> le, this.unsigned) : le === 32 ? $(this.high, 0, this.unsigned) : $(this.high >>> le - 32, 0, this.unsigned);
    }, ae.shru = ae.shiftRightUnsigned, ae.shr_u = ae.shiftRightUnsigned, ae.rotateLeft = function(le) {
      var we;
      return g(le) && (le = le.toInt()), (le &= 63) === 0 ? this : le === 32 ? $(this.high, this.low, this.unsigned) : le < 32 ? (we = 32 - le, $(this.low << le | this.high >>> we, this.high << le | this.low >>> we, this.unsigned)) : (le -= 32, we = 32 - le, $(this.high << le | this.low >>> we, this.low << le | this.high >>> we, this.unsigned));
    }, ae.rotl = ae.rotateLeft, ae.rotateRight = function(le) {
      var we;
      return g(le) && (le = le.toInt()), (le &= 63) === 0 ? this : le === 32 ? $(this.high, this.low, this.unsigned) : le < 32 ? (we = 32 - le, $(this.high << we | this.low >>> le, this.low << we | this.high >>> le, this.unsigned)) : (le -= 32, we = 32 - le, $(this.low << we | this.high >>> le, this.high << we | this.low >>> le, this.unsigned));
    }, ae.rotr = ae.rotateRight, ae.toSigned = function() {
      return this.unsigned ? $(this.low, this.high, !1) : this;
    }, ae.toUnsigned = function() {
      return this.unsigned ? this : $(this.low, this.high, !0);
    }, ae.toBytes = function(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    }, ae.toBytesLE = function() {
      var le = this.high, we = this.low;
      return [we & 255, we >>> 8 & 255, we >>> 16 & 255, we >>> 24, le & 255, le >>> 8 & 255, le >>> 16 & 255, le >>> 24];
    }, ae.toBytesBE = function() {
      var le = this.high, we = this.low;
      return [le >>> 24, le >>> 16 & 255, le >>> 8 & 255, le & 255, we >>> 24, we >>> 16 & 255, we >>> 8 & 255, we & 255];
    }, S.fromBytes = function(le, we, Be) {
      return Be ? S.fromBytesLE(le, we) : S.fromBytesBE(le, we);
    }, S.fromBytesLE = function(le, we) {
      return new S(le[0] | le[1] << 8 | le[2] << 16 | le[3] << 24, le[4] | le[5] << 8 | le[6] << 16 | le[7] << 24, we);
    }, S.fromBytesBE = function(le, we) {
      return new S(le[4] << 24 | le[5] << 16 | le[6] << 8 | le[7], le[0] << 24 | le[1] << 16 | le[2] << 8 | le[3], we);
    };
    var ye = S;
    return l.default = ye, "default" in l ? l.default : l;
  }({});
  a.exports = c;
})(umd);
var umdExports = umd.exports, indexMinimal = {}, minimal$1 = {}, aspromise = asPromise;
function asPromise(a, u) {
  for (var c = new Array(arguments.length - 1), l = 0, v = 2, S = !0; v < arguments.length; )
    c[l++] = arguments[v++];
  return new Promise(function(E, _) {
    c[l] = function(L) {
      if (S)
        if (S = !1, L)
          _(L);
        else {
          for (var M = new Array(arguments.length - 1), $ = 0; $ < M.length; )
            M[$++] = arguments[$];
          E.apply(null, M);
        }
    };
    try {
      a.apply(u || null, c);
    } catch (k) {
      S && (S = !1, _(k));
    }
  });
}
var base64$1 = {};
(function(a) {
  var u = a;
  u.length = function(E) {
    var _ = E.length;
    if (!_)
      return 0;
    for (var k = 0; --_ % 4 > 1 && E.charAt(_) === "="; )
      ++k;
    return Math.ceil(E.length * 3) / 4 - k;
  };
  for (var c = new Array(64), l = new Array(123), v = 0; v < 64; )
    l[c[v] = v < 26 ? v + 65 : v < 52 ? v + 71 : v < 62 ? v - 4 : v - 59 | 43] = v++;
  u.encode = function(E, _, k) {
    for (var L = null, M = [], $ = 0, J = 0, V; _ < k; ) {
      var q = E[_++];
      switch (J) {
        case 0:
          M[$++] = c[q >> 2], V = (q & 3) << 4, J = 1;
          break;
        case 1:
          M[$++] = c[V | q >> 4], V = (q & 15) << 2, J = 2;
          break;
        case 2:
          M[$++] = c[V | q >> 6], M[$++] = c[q & 63], J = 0;
          break;
      }
      $ > 8191 && ((L || (L = [])).push(String.fromCharCode.apply(String, M)), $ = 0);
    }
    return J && (M[$++] = c[V], M[$++] = 61, J === 1 && (M[$++] = 61)), L ? ($ && L.push(String.fromCharCode.apply(String, M.slice(0, $))), L.join("")) : String.fromCharCode.apply(String, M.slice(0, $));
  };
  var S = "invalid encoding";
  u.decode = function(E, _, k) {
    for (var L = k, M = 0, $, J = 0; J < E.length; ) {
      var V = E.charCodeAt(J++);
      if (V === 61 && M > 1)
        break;
      if ((V = l[V]) === void 0)
        throw Error(S);
      switch (M) {
        case 0:
          $ = V, M = 1;
          break;
        case 1:
          _[k++] = $ << 2 | (V & 48) >> 4, $ = V, M = 2;
          break;
        case 2:
          _[k++] = ($ & 15) << 4 | (V & 60) >> 2, $ = V, M = 3;
          break;
        case 3:
          _[k++] = ($ & 3) << 6 | V, M = 0;
          break;
      }
    }
    if (M === 1)
      throw Error(S);
    return k - L;
  }, u.test = function(E) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(E);
  };
})(base64$1);
var eventemitter = EventEmitter$1;
function EventEmitter$1() {
  this._listeners = {};
}
EventEmitter$1.prototype.on = function(u, c, l) {
  return (this._listeners[u] || (this._listeners[u] = [])).push({
    fn: c,
    ctx: l || this
  }), this;
};
EventEmitter$1.prototype.off = function(u, c) {
  if (u === void 0)
    this._listeners = {};
  else if (c === void 0)
    this._listeners[u] = [];
  else
    for (var l = this._listeners[u], v = 0; v < l.length; )
      l[v].fn === c ? l.splice(v, 1) : ++v;
  return this;
};
EventEmitter$1.prototype.emit = function(u) {
  var c = this._listeners[u];
  if (c) {
    for (var l = [], v = 1; v < arguments.length; )
      l.push(arguments[v++]);
    for (v = 0; v < c.length; )
      c[v].fn.apply(c[v++].ctx, l);
  }
  return this;
};
var float = factory(factory);
function factory(a) {
  return typeof Float32Array < "u" ? function() {
    var u = new Float32Array([-0]), c = new Uint8Array(u.buffer), l = c[3] === 128;
    function v(_, k, L) {
      u[0] = _, k[L] = c[0], k[L + 1] = c[1], k[L + 2] = c[2], k[L + 3] = c[3];
    }
    function S(_, k, L) {
      u[0] = _, k[L] = c[3], k[L + 1] = c[2], k[L + 2] = c[1], k[L + 3] = c[0];
    }
    a.writeFloatLE = l ? v : S, a.writeFloatBE = l ? S : v;
    function g(_, k) {
      return c[0] = _[k], c[1] = _[k + 1], c[2] = _[k + 2], c[3] = _[k + 3], u[0];
    }
    function E(_, k) {
      return c[3] = _[k], c[2] = _[k + 1], c[1] = _[k + 2], c[0] = _[k + 3], u[0];
    }
    a.readFloatLE = l ? g : E, a.readFloatBE = l ? E : g;
  }() : function() {
    function u(l, v, S, g) {
      var E = v < 0 ? 1 : 0;
      if (E && (v = -v), v === 0)
        l(1 / v > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), S, g);
      else if (isNaN(v))
        l(2143289344, S, g);
      else if (v > 34028234663852886e22)
        l((E << 31 | 2139095040) >>> 0, S, g);
      else if (v < 11754943508222875e-54)
        l((E << 31 | Math.round(v / 1401298464324817e-60)) >>> 0, S, g);
      else {
        var _ = Math.floor(Math.log(v) / Math.LN2), k = Math.round(v * Math.pow(2, -_) * 8388608) & 8388607;
        l((E << 31 | _ + 127 << 23 | k) >>> 0, S, g);
      }
    }
    a.writeFloatLE = u.bind(null, writeUintLE), a.writeFloatBE = u.bind(null, writeUintBE);
    function c(l, v, S) {
      var g = l(v, S), E = (g >> 31) * 2 + 1, _ = g >>> 23 & 255, k = g & 8388607;
      return _ === 255 ? k ? NaN : E * (1 / 0) : _ === 0 ? E * 1401298464324817e-60 * k : E * Math.pow(2, _ - 150) * (k + 8388608);
    }
    a.readFloatLE = c.bind(null, readUintLE), a.readFloatBE = c.bind(null, readUintBE);
  }(), typeof Float64Array < "u" ? function() {
    var u = new Float64Array([-0]), c = new Uint8Array(u.buffer), l = c[7] === 128;
    function v(_, k, L) {
      u[0] = _, k[L] = c[0], k[L + 1] = c[1], k[L + 2] = c[2], k[L + 3] = c[3], k[L + 4] = c[4], k[L + 5] = c[5], k[L + 6] = c[6], k[L + 7] = c[7];
    }
    function S(_, k, L) {
      u[0] = _, k[L] = c[7], k[L + 1] = c[6], k[L + 2] = c[5], k[L + 3] = c[4], k[L + 4] = c[3], k[L + 5] = c[2], k[L + 6] = c[1], k[L + 7] = c[0];
    }
    a.writeDoubleLE = l ? v : S, a.writeDoubleBE = l ? S : v;
    function g(_, k) {
      return c[0] = _[k], c[1] = _[k + 1], c[2] = _[k + 2], c[3] = _[k + 3], c[4] = _[k + 4], c[5] = _[k + 5], c[6] = _[k + 6], c[7] = _[k + 7], u[0];
    }
    function E(_, k) {
      return c[7] = _[k], c[6] = _[k + 1], c[5] = _[k + 2], c[4] = _[k + 3], c[3] = _[k + 4], c[2] = _[k + 5], c[1] = _[k + 6], c[0] = _[k + 7], u[0];
    }
    a.readDoubleLE = l ? g : E, a.readDoubleBE = l ? E : g;
  }() : function() {
    function u(l, v, S, g, E, _) {
      var k = g < 0 ? 1 : 0;
      if (k && (g = -g), g === 0)
        l(0, E, _ + v), l(1 / g > 0 ? (
          /* positive */
          0
        ) : (
          /* negative 0 */
          2147483648
        ), E, _ + S);
      else if (isNaN(g))
        l(0, E, _ + v), l(2146959360, E, _ + S);
      else if (g > 17976931348623157e292)
        l(0, E, _ + v), l((k << 31 | 2146435072) >>> 0, E, _ + S);
      else {
        var L;
        if (g < 22250738585072014e-324)
          L = g / 5e-324, l(L >>> 0, E, _ + v), l((k << 31 | L / 4294967296) >>> 0, E, _ + S);
        else {
          var M = Math.floor(Math.log(g) / Math.LN2);
          M === 1024 && (M = 1023), L = g * Math.pow(2, -M), l(L * 4503599627370496 >>> 0, E, _ + v), l((k << 31 | M + 1023 << 20 | L * 1048576 & 1048575) >>> 0, E, _ + S);
        }
      }
    }
    a.writeDoubleLE = u.bind(null, writeUintLE, 0, 4), a.writeDoubleBE = u.bind(null, writeUintBE, 4, 0);
    function c(l, v, S, g, E) {
      var _ = l(g, E + v), k = l(g, E + S), L = (k >> 31) * 2 + 1, M = k >>> 20 & 2047, $ = 4294967296 * (k & 1048575) + _;
      return M === 2047 ? $ ? NaN : L * (1 / 0) : M === 0 ? L * 5e-324 * $ : L * Math.pow(2, M - 1075) * ($ + 4503599627370496);
    }
    a.readDoubleLE = c.bind(null, readUintLE, 0, 4), a.readDoubleBE = c.bind(null, readUintBE, 4, 0);
  }(), a;
}
function writeUintLE(a, u, c) {
  u[c] = a & 255, u[c + 1] = a >>> 8 & 255, u[c + 2] = a >>> 16 & 255, u[c + 3] = a >>> 24;
}
function writeUintBE(a, u, c) {
  u[c] = a >>> 24, u[c + 1] = a >>> 16 & 255, u[c + 2] = a >>> 8 & 255, u[c + 3] = a & 255;
}
function readUintLE(a, u) {
  return (a[u] | a[u + 1] << 8 | a[u + 2] << 16 | a[u + 3] << 24) >>> 0;
}
function readUintBE(a, u) {
  return (a[u] << 24 | a[u + 1] << 16 | a[u + 2] << 8 | a[u + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (a) {
  }
  return null;
}
var utf8$2 = {};
(function(a) {
  var u = a;
  u.length = function(l) {
    for (var v = 0, S = 0, g = 0; g < l.length; ++g)
      S = l.charCodeAt(g), S < 128 ? v += 1 : S < 2048 ? v += 2 : (S & 64512) === 55296 && (l.charCodeAt(g + 1) & 64512) === 56320 ? (++g, v += 4) : v += 3;
    return v;
  }, u.read = function(l, v, S) {
    var g = S - v;
    if (g < 1)
      return "";
    for (var E = null, _ = [], k = 0, L; v < S; )
      L = l[v++], L < 128 ? _[k++] = L : L > 191 && L < 224 ? _[k++] = (L & 31) << 6 | l[v++] & 63 : L > 239 && L < 365 ? (L = ((L & 7) << 18 | (l[v++] & 63) << 12 | (l[v++] & 63) << 6 | l[v++] & 63) - 65536, _[k++] = 55296 + (L >> 10), _[k++] = 56320 + (L & 1023)) : _[k++] = (L & 15) << 12 | (l[v++] & 63) << 6 | l[v++] & 63, k > 8191 && ((E || (E = [])).push(String.fromCharCode.apply(String, _)), k = 0);
    return E ? (k && E.push(String.fromCharCode.apply(String, _.slice(0, k))), E.join("")) : String.fromCharCode.apply(String, _.slice(0, k));
  }, u.write = function(l, v, S) {
    for (var g = S, E, _, k = 0; k < l.length; ++k)
      E = l.charCodeAt(k), E < 128 ? v[S++] = E : E < 2048 ? (v[S++] = E >> 6 | 192, v[S++] = E & 63 | 128) : (E & 64512) === 55296 && ((_ = l.charCodeAt(k + 1)) & 64512) === 56320 ? (E = 65536 + ((E & 1023) << 10) + (_ & 1023), ++k, v[S++] = E >> 18 | 240, v[S++] = E >> 12 & 63 | 128, v[S++] = E >> 6 & 63 | 128, v[S++] = E & 63 | 128) : (v[S++] = E >> 12 | 224, v[S++] = E >> 6 & 63 | 128, v[S++] = E & 63 | 128);
    return S - g;
  };
})(utf8$2);
var pool_1 = pool;
function pool(a, u, c) {
  var l = c || 8192, v = l >>> 1, S = null, g = l;
  return function(_) {
    if (_ < 1 || _ > v)
      return a(_);
    g + _ > l && (S = a(l), g = 0);
    var k = u.call(S, g, g += _);
    return g & 7 && (g = (g | 7) + 1), k;
  };
}
var longbits, hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1, longbits = u;
  var a = requireMinimal();
  function u(S, g) {
    this.lo = S >>> 0, this.hi = g >>> 0;
  }
  var c = u.zero = new u(0, 0);
  c.toNumber = function() {
    return 0;
  }, c.zzEncode = c.zzDecode = function() {
    return this;
  }, c.length = function() {
    return 1;
  };
  var l = u.zeroHash = "\0\0\0\0\0\0\0\0";
  u.fromNumber = function(g) {
    if (g === 0)
      return c;
    var E = g < 0;
    E && (g = -g);
    var _ = g >>> 0, k = (g - _) / 4294967296 >>> 0;
    return E && (k = ~k >>> 0, _ = ~_ >>> 0, ++_ > 4294967295 && (_ = 0, ++k > 4294967295 && (k = 0))), new u(_, k);
  }, u.from = function(g) {
    if (typeof g == "number")
      return u.fromNumber(g);
    if (a.isString(g))
      if (a.Long)
        g = a.Long.fromString(g);
      else
        return u.fromNumber(parseInt(g, 10));
    return g.low || g.high ? new u(g.low >>> 0, g.high >>> 0) : c;
  }, u.prototype.toNumber = function(g) {
    if (!g && this.hi >>> 31) {
      var E = ~this.lo + 1 >>> 0, _ = ~this.hi >>> 0;
      return E || (_ = _ + 1 >>> 0), -(E + _ * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  }, u.prototype.toLong = function(g) {
    return a.Long ? new a.Long(this.lo | 0, this.hi | 0, !!g) : { low: this.lo | 0, high: this.hi | 0, unsigned: !!g };
  };
  var v = String.prototype.charCodeAt;
  return u.fromHash = function(g) {
    return g === l ? c : new u(
      (v.call(g, 0) | v.call(g, 1) << 8 | v.call(g, 2) << 16 | v.call(g, 3) << 24) >>> 0,
      (v.call(g, 4) | v.call(g, 5) << 8 | v.call(g, 6) << 16 | v.call(g, 7) << 24) >>> 0
    );
  }, u.prototype.toHash = function() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  }, u.prototype.zzEncode = function() {
    var g = this.hi >> 31;
    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ g) >>> 0, this.lo = (this.lo << 1 ^ g) >>> 0, this;
  }, u.prototype.zzDecode = function() {
    var g = -(this.lo & 1);
    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ g) >>> 0, this.hi = (this.hi >>> 1 ^ g) >>> 0, this;
  }, u.prototype.length = function() {
    var g = this.lo, E = (this.lo >>> 28 | this.hi << 4) >>> 0, _ = this.hi >>> 24;
    return _ === 0 ? E === 0 ? g < 16384 ? g < 128 ? 1 : 2 : g < 2097152 ? 3 : 4 : E < 16384 ? E < 128 ? 5 : 6 : E < 2097152 ? 7 : 8 : _ < 128 ? 9 : 10;
  }, longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  return hasRequiredMinimal || (hasRequiredMinimal = 1, function(a) {
    var u = a;
    u.asPromise = aspromise, u.base64 = base64$1, u.EventEmitter = eventemitter, u.float = float, u.inquire = inquire_1, u.utf8 = utf8$2, u.pool = pool_1, u.LongBits = requireLongbits(), u.isNode = !!(typeof commonjsGlobal$1 < "u" && commonjsGlobal$1 && commonjsGlobal$1.process && commonjsGlobal$1.process.versions && commonjsGlobal$1.process.versions.node), u.global = u.isNode && commonjsGlobal$1 || typeof window < "u" && window || typeof self < "u" && self || commonjsGlobal$1, u.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    ), u.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    ), u.isInteger = Number.isInteger || /* istanbul ignore next */
    function(S) {
      return typeof S == "number" && isFinite(S) && Math.floor(S) === S;
    }, u.isString = function(S) {
      return typeof S == "string" || S instanceof String;
    }, u.isObject = function(S) {
      return S && typeof S == "object";
    }, u.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    u.isSet = function(S, g) {
      var E = S[g];
      return E != null && S.hasOwnProperty(g) ? typeof E != "object" || (Array.isArray(E) ? E.length : Object.keys(E).length) > 0 : !1;
    }, u.Buffer = function() {
      try {
        var v = u.inquire("buffer").Buffer;
        return v.prototype.utf8Write ? v : (
          /* istanbul ignore next */
          null
        );
      } catch {
        return null;
      }
    }(), u._Buffer_from = null, u._Buffer_allocUnsafe = null, u.newBuffer = function(S) {
      return typeof S == "number" ? u.Buffer ? u._Buffer_allocUnsafe(S) : new u.Array(S) : u.Buffer ? u._Buffer_from(S) : typeof Uint8Array > "u" ? S : new Uint8Array(S);
    }, u.Array = typeof Uint8Array < "u" ? Uint8Array : Array, u.Long = /* istanbul ignore next */
    u.global.dcodeIO && /* istanbul ignore next */
    u.global.dcodeIO.Long || /* istanbul ignore next */
    u.global.Long || u.inquire("long"), u.key2Re = /^true|false|0|1$/, u.key32Re = /^-?(?:0|[1-9][0-9]*)$/, u.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, u.longToHash = function(S) {
      return S ? u.LongBits.from(S).toHash() : u.LongBits.zeroHash;
    }, u.longFromHash = function(S, g) {
      var E = u.LongBits.fromHash(S);
      return u.Long ? u.Long.fromBits(E.lo, E.hi, g) : E.toNumber(!!g);
    };
    function c(v, S, g) {
      for (var E = Object.keys(S), _ = 0; _ < E.length; ++_)
        (v[E[_]] === void 0 || !g) && (v[E[_]] = S[E[_]]);
      return v;
    }
    u.merge = c, u.lcFirst = function(S) {
      return S.charAt(0).toLowerCase() + S.substring(1);
    };
    function l(v) {
      function S(g, E) {
        if (!(this instanceof S))
          return new S(g, E);
        Object.defineProperty(this, "message", { get: function() {
          return g;
        } }), Error.captureStackTrace ? Error.captureStackTrace(this, S) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), E && c(this, E);
      }
      return (S.prototype = Object.create(Error.prototype)).constructor = S, Object.defineProperty(S.prototype, "name", { get: function() {
        return v;
      } }), S.prototype.toString = function() {
        return this.name + ": " + this.message;
      }, S;
    }
    u.newError = l, u.ProtocolError = l("ProtocolError"), u.oneOfGetter = function(S) {
      for (var g = {}, E = 0; E < S.length; ++E)
        g[S[E]] = 1;
      return function() {
        for (var _ = Object.keys(this), k = _.length - 1; k > -1; --k)
          if (g[_[k]] === 1 && this[_[k]] !== void 0 && this[_[k]] !== null)
            return _[k];
      };
    }, u.oneOfSetter = function(S) {
      return function(g) {
        for (var E = 0; E < S.length; ++E)
          S[E] !== g && delete this[S[E]];
      };
    }, u.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: !0
    }, u._configure = function() {
      var v = u.Buffer;
      if (!v) {
        u._Buffer_from = u._Buffer_allocUnsafe = null;
        return;
      }
      u._Buffer_from = v.from !== Uint8Array.from && v.from || /* istanbul ignore next */
      function(g, E) {
        return new v(g, E);
      }, u._Buffer_allocUnsafe = v.allocUnsafe || /* istanbul ignore next */
      function(g) {
        return new v(g);
      };
    };
  }(minimal$1)), minimal$1;
}
var writer$2 = Writer$1, util$8 = requireMinimal(), BufferWriter$1, LongBits$1 = util$8.LongBits, base64 = util$8.base64, utf8$1 = util$8.utf8;
function Op(a, u, c) {
  this.fn = a, this.len = u, this.next = void 0, this.val = c;
}
function noop$2() {
}
function State(a) {
  this.head = a.head, this.tail = a.tail, this.len = a.len, this.next = a.states;
}
function Writer$1() {
  this.len = 0, this.head = new Op(noop$2, 0, 0), this.tail = this.head, this.states = null;
}
var create$3 = function a() {
  return util$8.Buffer ? function() {
    return (Writer$1.create = function() {
      return new BufferWriter$1();
    })();
  } : function() {
    return new Writer$1();
  };
};
Writer$1.create = create$3();
Writer$1.alloc = function a(u) {
  return new util$8.Array(u);
};
util$8.Array !== Array && (Writer$1.alloc = util$8.pool(Writer$1.alloc, util$8.Array.prototype.subarray));
Writer$1.prototype._push = function a(u, c, l) {
  return this.tail = this.tail.next = new Op(u, c, l), this.len += c, this;
};
function writeByte(a, u, c) {
  u[c] = a & 255;
}
function writeVarint32(a, u, c) {
  for (; a > 127; )
    u[c++] = a & 127 | 128, a >>>= 7;
  u[c] = a;
}
function VarintOp(a, u) {
  this.len = a, this.next = void 0, this.val = u;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function a(u) {
  return this.len += (this.tail = this.tail.next = new VarintOp(
    (u = u >>> 0) < 128 ? 1 : u < 16384 ? 2 : u < 2097152 ? 3 : u < 268435456 ? 4 : 5,
    u
  )).len, this;
};
Writer$1.prototype.int32 = function a(u) {
  return u < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(u)) : this.uint32(u);
};
Writer$1.prototype.sint32 = function a(u) {
  return this.uint32((u << 1 ^ u >> 31) >>> 0);
};
function writeVarint64(a, u, c) {
  for (; a.hi; )
    u[c++] = a.lo & 127 | 128, a.lo = (a.lo >>> 7 | a.hi << 25) >>> 0, a.hi >>>= 7;
  for (; a.lo > 127; )
    u[c++] = a.lo & 127 | 128, a.lo = a.lo >>> 7;
  u[c++] = a.lo;
}
Writer$1.prototype.uint64 = function a(u) {
  var c = LongBits$1.from(u);
  return this._push(writeVarint64, c.length(), c);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function a(u) {
  var c = LongBits$1.from(u).zzEncode();
  return this._push(writeVarint64, c.length(), c);
};
Writer$1.prototype.bool = function a(u) {
  return this._push(writeByte, 1, u ? 1 : 0);
};
function writeFixed32(a, u, c) {
  u[c] = a & 255, u[c + 1] = a >>> 8 & 255, u[c + 2] = a >>> 16 & 255, u[c + 3] = a >>> 24;
}
Writer$1.prototype.fixed32 = function a(u) {
  return this._push(writeFixed32, 4, u >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function a(u) {
  var c = LongBits$1.from(u);
  return this._push(writeFixed32, 4, c.lo)._push(writeFixed32, 4, c.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function a(u) {
  return this._push(util$8.float.writeFloatLE, 4, u);
};
Writer$1.prototype.double = function a(u) {
  return this._push(util$8.float.writeDoubleLE, 8, u);
};
var writeBytes = util$8.Array.prototype.set ? function a(u, c, l) {
  c.set(u, l);
} : function a(u, c, l) {
  for (var v = 0; v < u.length; ++v)
    c[l + v] = u[v];
};
Writer$1.prototype.bytes = function a(u) {
  var c = u.length >>> 0;
  if (!c)
    return this._push(writeByte, 1, 0);
  if (util$8.isString(u)) {
    var l = Writer$1.alloc(c = base64.length(u));
    base64.decode(u, l, 0), u = l;
  }
  return this.uint32(c)._push(writeBytes, c, u);
};
Writer$1.prototype.string = function a(u) {
  var c = utf8$1.length(u);
  return c ? this.uint32(c)._push(utf8$1.write, c, u) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function a() {
  return this.states = new State(this), this.head = this.tail = new Op(noop$2, 0, 0), this.len = 0, this;
};
Writer$1.prototype.reset = function a() {
  return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new Op(noop$2, 0, 0), this.len = 0), this;
};
Writer$1.prototype.ldelim = function a() {
  var u = this.head, c = this.tail, l = this.len;
  return this.reset().uint32(l), l && (this.tail.next = u.next, this.tail = c, this.len += l), this;
};
Writer$1.prototype.finish = function a() {
  for (var u = this.head.next, c = this.constructor.alloc(this.len), l = 0; u; )
    u.fn(u.val, c, l), l += u.len, u = u.next;
  return c;
};
Writer$1._configure = function(a) {
  BufferWriter$1 = a, Writer$1.create = create$3(), BufferWriter$1._configure();
};
var writer_buffer = BufferWriter, Writer = writer$2;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$7 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$7._Buffer_allocUnsafe, BufferWriter.writeBytesBuffer = util$7.Buffer && util$7.Buffer.prototype instanceof Uint8Array && util$7.Buffer.prototype.set.name === "set" ? function(u, c, l) {
    c.set(u, l);
  } : function(u, c, l) {
    if (u.copy)
      u.copy(c, l, 0, u.length);
    else
      for (var v = 0; v < u.length; )
        c[l++] = u[v++];
  };
};
BufferWriter.prototype.bytes = function a(u) {
  util$7.isString(u) && (u = util$7._Buffer_from(u, "base64"));
  var c = u.length >>> 0;
  return this.uint32(c), c && this._push(BufferWriter.writeBytesBuffer, c, u), this;
};
function writeStringBuffer(a, u, c) {
  a.length < 40 ? util$7.utf8.write(a, u, c) : u.utf8Write ? u.utf8Write(a, c) : u.write(a, c);
}
BufferWriter.prototype.string = function a(u) {
  var c = util$7.Buffer.byteLength(u);
  return this.uint32(c), c && this._push(writeStringBuffer, c, u), this;
};
BufferWriter._configure();
var reader = Reader$1, util$6 = requireMinimal(), BufferReader$1, LongBits = util$6.LongBits, utf8 = util$6.utf8;
function indexOutOfRange(a, u) {
  return RangeError("index out of range: " + a.pos + " + " + (u || 1) + " > " + a.len);
}
function Reader$1(a) {
  this.buf = a, this.pos = 0, this.len = a.length;
}
var create_array = typeof Uint8Array < "u" ? function a(u) {
  if (u instanceof Uint8Array || Array.isArray(u))
    return new Reader$1(u);
  throw Error("illegal buffer");
} : function a(u) {
  if (Array.isArray(u))
    return new Reader$1(u);
  throw Error("illegal buffer");
}, create$2 = function a() {
  return util$6.Buffer ? function(c) {
    return (Reader$1.create = function(v) {
      return util$6.Buffer.isBuffer(v) ? new BufferReader$1(v) : create_array(v);
    })(c);
  } : create_array;
};
Reader$1.create = create$2();
Reader$1.prototype._slice = util$6.Array.prototype.subarray || /* istanbul ignore next */
util$6.Array.prototype.slice;
Reader$1.prototype.uint32 = /* @__PURE__ */ function a() {
  var u = 4294967295;
  return function() {
    if (u = (this.buf[this.pos] & 127) >>> 0, this.buf[this.pos++] < 128 || (u = (u | (this.buf[this.pos] & 127) << 7) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 127) << 14) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 127) << 21) >>> 0, this.buf[this.pos++] < 128) || (u = (u | (this.buf[this.pos] & 15) << 28) >>> 0, this.buf[this.pos++] < 128))
      return u;
    if ((this.pos += 5) > this.len)
      throw this.pos = this.len, indexOutOfRange(this, 10);
    return u;
  };
}();
Reader$1.prototype.int32 = function a() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function a() {
  var u = this.uint32();
  return u >>> 1 ^ -(u & 1) | 0;
};
function readLongVarint() {
  var a = new LongBits(0, 0), u = 0;
  if (this.len - this.pos > 4) {
    for (; u < 4; ++u)
      if (a.lo = (a.lo | (this.buf[this.pos] & 127) << u * 7) >>> 0, this.buf[this.pos++] < 128)
        return a;
    if (a.lo = (a.lo | (this.buf[this.pos] & 127) << 28) >>> 0, a.hi = (a.hi | (this.buf[this.pos] & 127) >> 4) >>> 0, this.buf[this.pos++] < 128)
      return a;
    u = 0;
  } else {
    for (; u < 3; ++u) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (a.lo = (a.lo | (this.buf[this.pos] & 127) << u * 7) >>> 0, this.buf[this.pos++] < 128)
        return a;
    }
    return a.lo = (a.lo | (this.buf[this.pos++] & 127) << u * 7) >>> 0, a;
  }
  if (this.len - this.pos > 4) {
    for (; u < 5; ++u)
      if (a.hi = (a.hi | (this.buf[this.pos] & 127) << u * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return a;
  } else
    for (; u < 5; ++u) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      if (a.hi = (a.hi | (this.buf[this.pos] & 127) << u * 7 + 3) >>> 0, this.buf[this.pos++] < 128)
        return a;
    }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function a() {
  return this.uint32() !== 0;
};
function readFixed32_end(a, u) {
  return (a[u - 4] | a[u - 3] << 8 | a[u - 2] << 16 | a[u - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function a() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var u = util$6.float.readFloatLE(this.buf, this.pos);
  return this.pos += 4, u;
};
Reader$1.prototype.double = function a() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var u = util$6.float.readDoubleLE(this.buf, this.pos);
  return this.pos += 8, u;
};
Reader$1.prototype.bytes = function a() {
  var u = this.uint32(), c = this.pos, l = this.pos + u;
  if (l > this.len)
    throw indexOutOfRange(this, u);
  return this.pos += u, Array.isArray(this.buf) ? this.buf.slice(c, l) : c === l ? new this.buf.constructor(0) : this._slice.call(this.buf, c, l);
};
Reader$1.prototype.string = function a() {
  var u = this.bytes();
  return utf8.read(u, 0, u.length);
};
Reader$1.prototype.skip = function a(u) {
  if (typeof u == "number") {
    if (this.pos + u > this.len)
      throw indexOutOfRange(this, u);
    this.pos += u;
  } else
    do
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    while (this.buf[this.pos++] & 128);
  return this;
};
Reader$1.prototype.skipType = function(a) {
  switch (a) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      for (; (a = this.uint32() & 7) !== 4; )
        this.skipType(a);
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + a + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(a) {
  BufferReader$1 = a, Reader$1.create = create$2(), BufferReader$1._configure();
  var u = util$6.Long ? "toLong" : (
    /* istanbul ignore next */
    "toNumber"
  );
  util$6.merge(Reader$1.prototype, {
    int64: function() {
      return readLongVarint.call(this)[u](!1);
    },
    uint64: function() {
      return readLongVarint.call(this)[u](!0);
    },
    sint64: function() {
      return readLongVarint.call(this).zzDecode()[u](!1);
    },
    fixed64: function() {
      return readFixed64.call(this)[u](!0);
    },
    sfixed64: function() {
      return readFixed64.call(this)[u](!1);
    }
  });
};
var reader_buffer = BufferReader, Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$5 = requireMinimal();
function BufferReader(a) {
  Reader.call(this, a);
}
BufferReader._configure = function() {
  util$5.Buffer && (BufferReader.prototype._slice = util$5.Buffer.prototype.slice);
};
BufferReader.prototype.string = function a() {
  var u = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + u, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + u, this.len));
};
BufferReader._configure();
var rpc = {}, service = Service, util$4 = requireMinimal();
(Service.prototype = Object.create(util$4.EventEmitter.prototype)).constructor = Service;
function Service(a, u, c) {
  if (typeof a != "function")
    throw TypeError("rpcImpl must be a function");
  util$4.EventEmitter.call(this), this.rpcImpl = a, this.requestDelimited = !!u, this.responseDelimited = !!c;
}
Service.prototype.rpcCall = function a(u, c, l, v, S) {
  if (!v)
    throw TypeError("request must be specified");
  var g = this;
  if (!S)
    return util$4.asPromise(a, g, u, c, l, v);
  if (!g.rpcImpl) {
    setTimeout(function() {
      S(Error("already ended"));
    }, 0);
    return;
  }
  try {
    return g.rpcImpl(
      u,
      c[g.requestDelimited ? "encodeDelimited" : "encode"](v).finish(),
      function(_, k) {
        if (_)
          return g.emit("error", _, u), S(_);
        if (k === null) {
          g.end(
            /* endedByRPC */
            !0
          );
          return;
        }
        if (!(k instanceof l))
          try {
            k = l[g.responseDelimited ? "decodeDelimited" : "decode"](k);
          } catch (L) {
            return g.emit("error", L, u), S(L);
          }
        return g.emit("data", k, u), S(null, k);
      }
    );
  } catch (E) {
    g.emit("error", E, u), setTimeout(function() {
      S(E);
    }, 0);
    return;
  }
};
Service.prototype.end = function a(u) {
  return this.rpcImpl && (u || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
};
(function(a) {
  var u = a;
  u.Service = service;
})(rpc);
var roots = {};
(function(a) {
  var u = a;
  u.build = "minimal", u.Writer = writer$2, u.BufferWriter = writer_buffer, u.Reader = reader, u.BufferReader = reader_buffer, u.util = requireMinimal(), u.rpc = rpc, u.roots = roots, u.configure = c;
  function c() {
    u.util._configure(), u.Writer._configure(u.BufferWriter), u.Reader._configure(u.BufferReader);
  }
  c();
})(indexMinimal);
var minimal = indexMinimal, struct$2 = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(B, Y, ne, Z) {
    Z === void 0 && (Z = ne), Object.defineProperty(B, Z, { enumerable: !0, get: function() {
      return Y[ne];
    } });
  } : function(B, Y, ne, Z) {
    Z === void 0 && (Z = ne), B[Z] = Y[ne];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(B, Y) {
    Object.defineProperty(B, "default", { enumerable: !0, value: Y });
  } : function(B, Y) {
    B.default = Y;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(B) {
    if (B && B.__esModule)
      return B;
    var Y = {};
    if (B != null)
      for (var ne in B)
        ne !== "default" && Object.hasOwnProperty.call(B, ne) && u(Y, B, ne);
    return c(Y, B), Y;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const S = v(umdExports), g = l(minimal);
  a.protobufPackage = "google.protobuf";
  var E;
  (function(B) {
    B.NULL_VALUE = "NULL_VALUE";
  })(E = a.NullValue || (a.NullValue = {}));
  function _(B) {
    switch (B) {
      case 0:
      case "NULL_VALUE":
        return E.NULL_VALUE;
      default:
        throw new q.Error("Unrecognized enum value " + B + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = _;
  function k(B) {
    switch (B) {
      case E.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  a.nullValueToJSON = k;
  function L(B) {
    switch (B) {
      case E.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  a.nullValueToNumber = L;
  function M() {
    return { fields: {} };
  }
  a.Struct = {
    encode(B, Y = g.Writer.create()) {
      return Object.entries(B.fields).forEach(([ne, Z]) => {
        Z !== void 0 && a.Struct_FieldsEntry.encode({ key: ne, value: Z }, Y.uint32(10).fork()).ldelim();
      }), Y;
    },
    decode(B, Y) {
      const ne = B instanceof g.Reader ? B : new g.Reader(B);
      let Z = Y === void 0 ? ne.len : ne.pos + Y;
      const re = M();
      for (; ne.pos < Z; ) {
        const oe = ne.uint32();
        switch (oe >>> 3) {
          case 1:
            const de = a.Struct_FieldsEntry.decode(ne, ne.uint32());
            de.value !== void 0 && (re.fields[de.key] = de.value);
            break;
          default:
            ne.skipType(oe & 7);
            break;
        }
      }
      return re;
    },
    fromJSON(B) {
      return {
        fields: G(B.fields) ? Object.entries(B.fields).reduce((Y, [ne, Z]) => (Y[ne] = Z, Y), {}) : {}
      };
    },
    toJSON(B) {
      const Y = {};
      return Y.fields = {}, B.fields && Object.entries(B.fields).forEach(([ne, Z]) => {
        Y.fields[ne] = Z;
      }), Y;
    },
    fromPartial(B) {
      var Y;
      const ne = M();
      return ne.fields = Object.entries((Y = B.fields) !== null && Y !== void 0 ? Y : {}).reduce((Z, [re, oe]) => (oe !== void 0 && (Z[re] = oe), Z), {}), ne;
    },
    wrap(B) {
      const Y = M();
      return B !== void 0 && Object.keys(B).forEach((ne) => {
        Y.fields[ne] = B[ne];
      }), Y;
    },
    unwrap(B) {
      const Y = {};
      return Object.keys(B.fields).forEach((ne) => {
        Y[ne] = B.fields[ne];
      }), Y;
    }
  };
  function $() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(B, Y = g.Writer.create()) {
      return B.key !== "" && Y.uint32(10).string(B.key), B.value !== void 0 && a.Value.encode(a.Value.wrap(B.value), Y.uint32(18).fork()).ldelim(), Y;
    },
    decode(B, Y) {
      const ne = B instanceof g.Reader ? B : new g.Reader(B);
      let Z = Y === void 0 ? ne.len : ne.pos + Y;
      const re = $();
      for (; ne.pos < Z; ) {
        const oe = ne.uint32();
        switch (oe >>> 3) {
          case 1:
            re.key = ne.string();
            break;
          case 2:
            re.value = a.Value.unwrap(a.Value.decode(ne, ne.uint32()));
            break;
          default:
            ne.skipType(oe & 7);
            break;
        }
      }
      return re;
    },
    fromJSON(B) {
      return {
        key: H(B.key) ? String(B.key) : "",
        value: H(B == null ? void 0 : B.value) ? B.value : void 0
      };
    },
    toJSON(B) {
      const Y = {};
      return B.key !== void 0 && (Y.key = B.key), B.value !== void 0 && (Y.value = B.value), Y;
    },
    fromPartial(B) {
      var Y, ne;
      const Z = $();
      return Z.key = (Y = B.key) !== null && Y !== void 0 ? Y : "", Z.value = (ne = B.value) !== null && ne !== void 0 ? ne : void 0, Z;
    }
  };
  function J() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(B, Y = g.Writer.create()) {
      return B.nullValue !== void 0 && Y.uint32(8).int32(L(B.nullValue)), B.numberValue !== void 0 && Y.uint32(17).double(B.numberValue), B.stringValue !== void 0 && Y.uint32(26).string(B.stringValue), B.boolValue !== void 0 && Y.uint32(32).bool(B.boolValue), B.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(B.structValue), Y.uint32(42).fork()).ldelim(), B.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(B.listValue), Y.uint32(50).fork()).ldelim(), Y;
    },
    decode(B, Y) {
      const ne = B instanceof g.Reader ? B : new g.Reader(B);
      let Z = Y === void 0 ? ne.len : ne.pos + Y;
      const re = J();
      for (; ne.pos < Z; ) {
        const oe = ne.uint32();
        switch (oe >>> 3) {
          case 1:
            re.nullValue = _(ne.int32());
            break;
          case 2:
            re.numberValue = ne.double();
            break;
          case 3:
            re.stringValue = ne.string();
            break;
          case 4:
            re.boolValue = ne.bool();
            break;
          case 5:
            re.structValue = a.Struct.unwrap(a.Struct.decode(ne, ne.uint32()));
            break;
          case 6:
            re.listValue = a.ListValue.unwrap(a.ListValue.decode(ne, ne.uint32()));
            break;
          default:
            ne.skipType(oe & 7);
            break;
        }
      }
      return re;
    },
    fromJSON(B) {
      return {
        nullValue: H(B.nullValue) ? _(B.nullValue) : void 0,
        numberValue: H(B.numberValue) ? Number(B.numberValue) : void 0,
        stringValue: H(B.stringValue) ? String(B.stringValue) : void 0,
        boolValue: H(B.boolValue) ? !!B.boolValue : void 0,
        structValue: G(B.structValue) ? B.structValue : void 0,
        listValue: Array.isArray(B.listValue) ? [...B.listValue] : void 0
      };
    },
    toJSON(B) {
      const Y = {};
      return B.nullValue !== void 0 && (Y.nullValue = B.nullValue !== void 0 ? k(B.nullValue) : void 0), B.numberValue !== void 0 && (Y.numberValue = B.numberValue), B.stringValue !== void 0 && (Y.stringValue = B.stringValue), B.boolValue !== void 0 && (Y.boolValue = B.boolValue), B.structValue !== void 0 && (Y.structValue = B.structValue), B.listValue !== void 0 && (Y.listValue = B.listValue), Y;
    },
    fromPartial(B) {
      var Y, ne, Z, re, oe, de;
      const A = J();
      return A.nullValue = (Y = B.nullValue) !== null && Y !== void 0 ? Y : void 0, A.numberValue = (ne = B.numberValue) !== null && ne !== void 0 ? ne : void 0, A.stringValue = (Z = B.stringValue) !== null && Z !== void 0 ? Z : void 0, A.boolValue = (re = B.boolValue) !== null && re !== void 0 ? re : void 0, A.structValue = (oe = B.structValue) !== null && oe !== void 0 ? oe : void 0, A.listValue = (de = B.listValue) !== null && de !== void 0 ? de : void 0, A;
    },
    wrap(B) {
      const Y = J();
      if (B === null)
        Y.nullValue = E.NULL_VALUE;
      else if (typeof B == "boolean")
        Y.boolValue = B;
      else if (typeof B == "number")
        Y.numberValue = B;
      else if (typeof B == "string")
        Y.stringValue = B;
      else if (Array.isArray(B))
        Y.listValue = B;
      else if (typeof B == "object")
        Y.structValue = B;
      else if (typeof B < "u")
        throw new Error("Unsupported any value type: " + typeof B);
      return Y;
    },
    unwrap(B) {
      if ((B == null ? void 0 : B.stringValue) !== void 0)
        return B.stringValue;
      if ((B == null ? void 0 : B.numberValue) !== void 0)
        return B.numberValue;
      if ((B == null ? void 0 : B.boolValue) !== void 0)
        return B.boolValue;
      if ((B == null ? void 0 : B.structValue) !== void 0)
        return B.structValue;
      if ((B == null ? void 0 : B.listValue) !== void 0)
        return B.listValue;
      if ((B == null ? void 0 : B.nullValue) !== void 0)
        return null;
    }
  };
  function V() {
    return { values: [] };
  }
  a.ListValue = {
    encode(B, Y = g.Writer.create()) {
      for (const ne of B.values)
        a.Value.encode(a.Value.wrap(ne), Y.uint32(10).fork()).ldelim();
      return Y;
    },
    decode(B, Y) {
      const ne = B instanceof g.Reader ? B : new g.Reader(B);
      let Z = Y === void 0 ? ne.len : ne.pos + Y;
      const re = V();
      for (; ne.pos < Z; ) {
        const oe = ne.uint32();
        switch (oe >>> 3) {
          case 1:
            re.values.push(a.Value.unwrap(a.Value.decode(ne, ne.uint32())));
            break;
          default:
            ne.skipType(oe & 7);
            break;
        }
      }
      return re;
    },
    fromJSON(B) {
      return {
        values: Array.isArray(B == null ? void 0 : B.values) ? [...B.values] : []
      };
    },
    toJSON(B) {
      const Y = {};
      return B.values ? Y.values = B.values.map((ne) => ne) : Y.values = [], Y;
    },
    fromPartial(B) {
      var Y;
      const ne = V();
      return ne.values = ((Y = B.values) === null || Y === void 0 ? void 0 : Y.map((Z) => Z)) || [], ne;
    },
    wrap(B) {
      const Y = V();
      return Y.values = B ?? [], Y;
    },
    unwrap(B) {
      return B.values;
    }
  };
  var q = (() => {
    if (typeof q < "u")
      return q;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  g.util.Long !== S.default && (g.util.Long = S.default, g.configure());
  function G(B) {
    return typeof B == "object" && B !== null;
  }
  function H(B) {
    return B != null;
  }
})(struct$2);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(I, F, z, Te) {
    Te === void 0 && (Te = z), Object.defineProperty(I, Te, { enumerable: !0, get: function() {
      return F[z];
    } });
  } : function(I, F, z, Te) {
    Te === void 0 && (Te = z), I[Te] = F[z];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(I, F) {
    Object.defineProperty(I, "default", { enumerable: !0, value: F });
  } : function(I, F) {
    I.default = F;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(I) {
    if (I && I.__esModule)
      return I;
    var F = {};
    if (I != null)
      for (var z in I)
        z !== "default" && Object.hasOwnProperty.call(I, z) && u(F, I, z);
    return c(F, I), F;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(I) {
    return I && I.__esModule ? I : { default: I };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LayoutServiceDefinition = a.LayoutServiceClientImpl = a.LayerServiceDefinition = a.LayerServiceClientImpl = a.Event = a.LayerEvent = a.LayoutEvent = a.BatchLayerRequest_BatchItem = a.BatchLayerRequest = a.BatchDeleteLayerRequest = a.DeleteLayerPayload = a.UpdateLayerRequest = a.GetLayerRequest = a.CreateLayerRequest = a.ListLayersResponse = a.ListLayersRequest = a.PartialLayerWithID = a.PartialLayer = a.LayerAnimation = a.DeleteLayoutResponse = a.DeleteLayoutRequest = a.DeleteLayoutPayload = a.UpdateLayoutRequest = a.GetLayoutRequest = a.CreateLayoutRequest = a.ListLayoutsResponse = a.ListLayoutsRequest = a.PartialLayout = a.BatchLayerResponse_BatchLayerItem = a.BatchLayerResponse = a.DeleteLayerResponse = a.DeleteLayerRequest = a.Layer = a.Layout = a.Transition_TransitionStinger = a.Transition_TransitionStingerCut = a.Transition_TransitionSwipe = a.Transition_TransitionCrossfade = a.Transition_TransitionFadeToColor = a.Transition_TransitionCut = a.Transition_TransitionMediaType = a.Transition = a.transition_TransitionSwipeTypeToNumber = a.transition_TransitionSwipeTypeToJSON = a.transition_TransitionSwipeTypeFromJSON = a.Transition_TransitionSwipeType = a.transition_TransitionDirectionToNumber = a.transition_TransitionDirectionToJSON = a.transition_TransitionDirectionFromJSON = a.Transition_TransitionDirection = a.eventTypeToNumber = a.eventTypeToJSON = a.eventTypeFromJSON = a.EventType = a.eventSubTypeToNumber = a.eventSubTypeToJSON = a.eventSubTypeFromJSON = a.EventSubType = a.requestAnimationModeToNumber = a.requestAnimationModeToJSON = a.requestAnimationModeFromJSON = a.RequestAnimationMode = a.layoutTypeToNumber = a.layoutTypeToJSON = a.layoutTypeFromJSON = a.LayoutType = a.protobufPackage = void 0;
  const S = v(umdExports), g = l(minimal), E = struct$2;
  a.protobufPackage = "apis.layout.v2";
  var _;
  (function(I) {
    I.LAYOUT_TYPE_UNSPECIFIED = "LAYOUT_TYPE_UNSPECIFIED", I.LAYOUT_TYPE_SCENELESS = "LAYOUT_TYPE_SCENELESS", I.LAYOUT_TYPE_SCENE = "LAYOUT_TYPE_SCENE";
  })(_ = a.LayoutType || (a.LayoutType = {}));
  function k(I) {
    switch (I) {
      case 0:
      case "LAYOUT_TYPE_UNSPECIFIED":
        return _.LAYOUT_TYPE_UNSPECIFIED;
      case 1:
      case "LAYOUT_TYPE_SCENELESS":
        return _.LAYOUT_TYPE_SCENELESS;
      case 2:
      case "LAYOUT_TYPE_SCENE":
        return _.LAYOUT_TYPE_SCENE;
      default:
        throw new ot.Error("Unrecognized enum value " + I + " for enum LayoutType");
    }
  }
  a.layoutTypeFromJSON = k;
  function L(I) {
    switch (I) {
      case _.LAYOUT_TYPE_UNSPECIFIED:
        return "LAYOUT_TYPE_UNSPECIFIED";
      case _.LAYOUT_TYPE_SCENELESS:
        return "LAYOUT_TYPE_SCENELESS";
      case _.LAYOUT_TYPE_SCENE:
        return "LAYOUT_TYPE_SCENE";
      default:
        return "UNKNOWN";
    }
  }
  a.layoutTypeToJSON = L;
  function M(I) {
    switch (I) {
      case _.LAYOUT_TYPE_UNSPECIFIED:
        return 0;
      case _.LAYOUT_TYPE_SCENELESS:
        return 1;
      case _.LAYOUT_TYPE_SCENE:
        return 2;
      default:
        return 0;
    }
  }
  a.layoutTypeToNumber = M;
  var $;
  (function(I) {
    I.REQUEST_ANIMATION_MODE_UNSPECIFIED = "REQUEST_ANIMATION_MODE_UNSPECIFIED", I.REQUEST_ANIMATION_MODE_PARALLEL = "REQUEST_ANIMATION_MODE_PARALLEL", I.REQUEST_ANIMATION_MODE_SERIES = "REQUEST_ANIMATION_MODE_SERIES";
  })($ = a.RequestAnimationMode || (a.RequestAnimationMode = {}));
  function J(I) {
    switch (I) {
      case 0:
      case "REQUEST_ANIMATION_MODE_UNSPECIFIED":
        return $.REQUEST_ANIMATION_MODE_UNSPECIFIED;
      case 1:
      case "REQUEST_ANIMATION_MODE_PARALLEL":
        return $.REQUEST_ANIMATION_MODE_PARALLEL;
      case 2:
      case "REQUEST_ANIMATION_MODE_SERIES":
        return $.REQUEST_ANIMATION_MODE_SERIES;
      default:
        throw new ot.Error("Unrecognized enum value " + I + " for enum RequestAnimationMode");
    }
  }
  a.requestAnimationModeFromJSON = J;
  function V(I) {
    switch (I) {
      case $.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return "REQUEST_ANIMATION_MODE_UNSPECIFIED";
      case $.REQUEST_ANIMATION_MODE_PARALLEL:
        return "REQUEST_ANIMATION_MODE_PARALLEL";
      case $.REQUEST_ANIMATION_MODE_SERIES:
        return "REQUEST_ANIMATION_MODE_SERIES";
      default:
        return "UNKNOWN";
    }
  }
  a.requestAnimationModeToJSON = V;
  function q(I) {
    switch (I) {
      case $.REQUEST_ANIMATION_MODE_UNSPECIFIED:
        return 0;
      case $.REQUEST_ANIMATION_MODE_PARALLEL:
        return 1;
      case $.REQUEST_ANIMATION_MODE_SERIES:
        return 2;
      default:
        return 0;
    }
  }
  a.requestAnimationModeToNumber = q;
  var G;
  (function(I) {
    I.EVENT_SUB_TYPE_UNSPECIFIED = "EVENT_SUB_TYPE_UNSPECIFIED", I.EVENT_SUB_TYPE_CREATE = "EVENT_SUB_TYPE_CREATE", I.EVENT_SUB_TYPE_UPDATE = "EVENT_SUB_TYPE_UPDATE", I.EVENT_SUB_TYPE_DELETE = "EVENT_SUB_TYPE_DELETE", I.EVENT_SUB_TYPE_BATCH = "EVENT_SUB_TYPE_BATCH";
  })(G = a.EventSubType || (a.EventSubType = {}));
  function H(I) {
    switch (I) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return G.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return G.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return G.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return G.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_BATCH":
        return G.EVENT_SUB_TYPE_BATCH;
      default:
        throw new ot.Error("Unrecognized enum value " + I + " for enum EventSubType");
    }
  }
  a.eventSubTypeFromJSON = H;
  function B(I) {
    switch (I) {
      case G.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case G.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case G.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case G.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case G.EVENT_SUB_TYPE_BATCH:
        return "EVENT_SUB_TYPE_BATCH";
      default:
        return "UNKNOWN";
    }
  }
  a.eventSubTypeToJSON = B;
  function Y(I) {
    switch (I) {
      case G.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case G.EVENT_SUB_TYPE_CREATE:
        return 1;
      case G.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case G.EVENT_SUB_TYPE_DELETE:
        return 3;
      case G.EVENT_SUB_TYPE_BATCH:
        return 4;
      default:
        return 0;
    }
  }
  a.eventSubTypeToNumber = Y;
  var ne;
  (function(I) {
    I.EVENT_TYPE_UNSPECIFIED = "EVENT_TYPE_UNSPECIFIED", I.EVENT_TYPE_LAYOUT = "EVENT_TYPE_LAYOUT", I.EVENT_TYPE_LAYER = "EVENT_TYPE_LAYER";
  })(ne = a.EventType || (a.EventType = {}));
  function Z(I) {
    switch (I) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return ne.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_LAYOUT":
        return ne.EVENT_TYPE_LAYOUT;
      case 2:
      case "EVENT_TYPE_LAYER":
        return ne.EVENT_TYPE_LAYER;
      default:
        throw new ot.Error("Unrecognized enum value " + I + " for enum EventType");
    }
  }
  a.eventTypeFromJSON = Z;
  function re(I) {
    switch (I) {
      case ne.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case ne.EVENT_TYPE_LAYOUT:
        return "EVENT_TYPE_LAYOUT";
      case ne.EVENT_TYPE_LAYER:
        return "EVENT_TYPE_LAYER";
      default:
        return "UNKNOWN";
    }
  }
  a.eventTypeToJSON = re;
  function oe(I) {
    switch (I) {
      case ne.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case ne.EVENT_TYPE_LAYOUT:
        return 1;
      case ne.EVENT_TYPE_LAYER:
        return 2;
      default:
        return 0;
    }
  }
  a.eventTypeToNumber = oe;
  var de;
  (function(I) {
    I.TRANSITION_DIRECTION_UNSPECIFIED = "TRANSITION_DIRECTION_UNSPECIFIED", I.TRANSITION_DIRECTION_LEFT = "TRANSITION_DIRECTION_LEFT", I.TRANSITION_DIRECTION_RIGHT = "TRANSITION_DIRECTION_RIGHT", I.TRANSITION_DIRECTION_UP = "TRANSITION_DIRECTION_UP", I.TRANSITION_DIRECTION_DOWN = "TRANSITION_DIRECTION_DOWN";
  })(de = a.Transition_TransitionDirection || (a.Transition_TransitionDirection = {}));
  function A(I) {
    switch (I) {
      case 0:
      case "TRANSITION_DIRECTION_UNSPECIFIED":
        return de.TRANSITION_DIRECTION_UNSPECIFIED;
      case 1:
      case "TRANSITION_DIRECTION_LEFT":
        return de.TRANSITION_DIRECTION_LEFT;
      case 2:
      case "TRANSITION_DIRECTION_RIGHT":
        return de.TRANSITION_DIRECTION_RIGHT;
      case 3:
      case "TRANSITION_DIRECTION_UP":
        return de.TRANSITION_DIRECTION_UP;
      case 4:
      case "TRANSITION_DIRECTION_DOWN":
        return de.TRANSITION_DIRECTION_DOWN;
      default:
        throw new ot.Error("Unrecognized enum value " + I + " for enum Transition_TransitionDirection");
    }
  }
  a.transition_TransitionDirectionFromJSON = A;
  function N(I) {
    switch (I) {
      case de.TRANSITION_DIRECTION_UNSPECIFIED:
        return "TRANSITION_DIRECTION_UNSPECIFIED";
      case de.TRANSITION_DIRECTION_LEFT:
        return "TRANSITION_DIRECTION_LEFT";
      case de.TRANSITION_DIRECTION_RIGHT:
        return "TRANSITION_DIRECTION_RIGHT";
      case de.TRANSITION_DIRECTION_UP:
        return "TRANSITION_DIRECTION_UP";
      case de.TRANSITION_DIRECTION_DOWN:
        return "TRANSITION_DIRECTION_DOWN";
      default:
        return "UNKNOWN";
    }
  }
  a.transition_TransitionDirectionToJSON = N;
  function D(I) {
    switch (I) {
      case de.TRANSITION_DIRECTION_UNSPECIFIED:
        return 0;
      case de.TRANSITION_DIRECTION_LEFT:
        return 1;
      case de.TRANSITION_DIRECTION_RIGHT:
        return 2;
      case de.TRANSITION_DIRECTION_UP:
        return 3;
      case de.TRANSITION_DIRECTION_DOWN:
        return 4;
      default:
        return 0;
    }
  }
  a.transition_TransitionDirectionToNumber = D;
  var W;
  (function(I) {
    I.TRANSITION_SWIPE_TYPE_UNSPECIFIED = "TRANSITION_SWIPE_TYPE_UNSPECIFIED", I.TRANSITION_SWIPE_TYPE_COMBINED = "TRANSITION_SWIPE_TYPE_COMBINED", I.TRANSITION_SWIPE_TYPE_SOURCE = "TRANSITION_SWIPE_TYPE_SOURCE", I.TRANSITION_SWIPE_TYPE_DESTINATION = "TRANSITION_SWIPE_TYPE_DESTINATION";
  })(W = a.Transition_TransitionSwipeType || (a.Transition_TransitionSwipeType = {}));
  function ee(I) {
    switch (I) {
      case 0:
      case "TRANSITION_SWIPE_TYPE_UNSPECIFIED":
        return W.TRANSITION_SWIPE_TYPE_UNSPECIFIED;
      case 1:
      case "TRANSITION_SWIPE_TYPE_COMBINED":
        return W.TRANSITION_SWIPE_TYPE_COMBINED;
      case 2:
      case "TRANSITION_SWIPE_TYPE_SOURCE":
        return W.TRANSITION_SWIPE_TYPE_SOURCE;
      case 3:
      case "TRANSITION_SWIPE_TYPE_DESTINATION":
        return W.TRANSITION_SWIPE_TYPE_DESTINATION;
      default:
        throw new ot.Error("Unrecognized enum value " + I + " for enum Transition_TransitionSwipeType");
    }
  }
  a.transition_TransitionSwipeTypeFromJSON = ee;
  function ae(I) {
    switch (I) {
      case W.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return "TRANSITION_SWIPE_TYPE_UNSPECIFIED";
      case W.TRANSITION_SWIPE_TYPE_COMBINED:
        return "TRANSITION_SWIPE_TYPE_COMBINED";
      case W.TRANSITION_SWIPE_TYPE_SOURCE:
        return "TRANSITION_SWIPE_TYPE_SOURCE";
      case W.TRANSITION_SWIPE_TYPE_DESTINATION:
        return "TRANSITION_SWIPE_TYPE_DESTINATION";
      default:
        return "UNKNOWN";
    }
  }
  a.transition_TransitionSwipeTypeToJSON = ae;
  function ye(I) {
    switch (I) {
      case W.TRANSITION_SWIPE_TYPE_UNSPECIFIED:
        return 0;
      case W.TRANSITION_SWIPE_TYPE_COMBINED:
        return 1;
      case W.TRANSITION_SWIPE_TYPE_SOURCE:
        return 2;
      case W.TRANSITION_SWIPE_TYPE_DESTINATION:
        return 3;
      default:
        return 0;
    }
  }
  a.transition_TransitionSwipeTypeToNumber = ye;
  function he() {
    return {
      fromLayoutIds: [],
      cut: void 0,
      crossfade: void 0,
      fadeToColor: void 0,
      swipe: void 0,
      stinger: void 0
    };
  }
  a.Transition = {
    encode(I, F = g.Writer.create()) {
      for (const z of I.fromLayoutIds)
        F.uint32(10).string(z);
      return I.cut !== void 0 && a.Transition_TransitionCut.encode(I.cut, F.uint32(82).fork()).ldelim(), I.crossfade !== void 0 && a.Transition_TransitionCrossfade.encode(I.crossfade, F.uint32(90).fork()).ldelim(), I.fadeToColor !== void 0 && a.Transition_TransitionFadeToColor.encode(I.fadeToColor, F.uint32(98).fork()).ldelim(), I.swipe !== void 0 && a.Transition_TransitionSwipe.encode(I.swipe, F.uint32(106).fork()).ldelim(), I.stinger !== void 0 && a.Transition_TransitionStinger.encode(I.stinger, F.uint32(114).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = he();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.fromLayoutIds.push(z.string());
            break;
          case 10:
            fe.cut = a.Transition_TransitionCut.decode(z, z.uint32());
            break;
          case 11:
            fe.crossfade = a.Transition_TransitionCrossfade.decode(z, z.uint32());
            break;
          case 12:
            fe.fadeToColor = a.Transition_TransitionFadeToColor.decode(z, z.uint32());
            break;
          case 13:
            fe.swipe = a.Transition_TransitionSwipe.decode(z, z.uint32());
            break;
          case 14:
            fe.stinger = a.Transition_TransitionStinger.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        fromLayoutIds: Array.isArray(I == null ? void 0 : I.fromLayoutIds) ? I.fromLayoutIds.map((F) => String(F)) : [],
        cut: Ce(I.cut) ? a.Transition_TransitionCut.fromJSON(I.cut) : void 0,
        crossfade: Ce(I.crossfade) ? a.Transition_TransitionCrossfade.fromJSON(I.crossfade) : void 0,
        fadeToColor: Ce(I.fadeToColor) ? a.Transition_TransitionFadeToColor.fromJSON(I.fadeToColor) : void 0,
        swipe: Ce(I.swipe) ? a.Transition_TransitionSwipe.fromJSON(I.swipe) : void 0,
        stinger: Ce(I.stinger) ? a.Transition_TransitionStinger.fromJSON(I.stinger) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.fromLayoutIds ? F.fromLayoutIds = I.fromLayoutIds.map((z) => z) : F.fromLayoutIds = [], I.cut !== void 0 && (F.cut = I.cut ? a.Transition_TransitionCut.toJSON(I.cut) : void 0), I.crossfade !== void 0 && (F.crossfade = I.crossfade ? a.Transition_TransitionCrossfade.toJSON(I.crossfade) : void 0), I.fadeToColor !== void 0 && (F.fadeToColor = I.fadeToColor ? a.Transition_TransitionFadeToColor.toJSON(I.fadeToColor) : void 0), I.swipe !== void 0 && (F.swipe = I.swipe ? a.Transition_TransitionSwipe.toJSON(I.swipe) : void 0), I.stinger !== void 0 && (F.stinger = I.stinger ? a.Transition_TransitionStinger.toJSON(I.stinger) : void 0), F;
    },
    fromPartial(I) {
      var F;
      const z = he();
      return z.fromLayoutIds = ((F = I.fromLayoutIds) === null || F === void 0 ? void 0 : F.map((Te) => Te)) || [], z.cut = I.cut !== void 0 && I.cut !== null ? a.Transition_TransitionCut.fromPartial(I.cut) : void 0, z.crossfade = I.crossfade !== void 0 && I.crossfade !== null ? a.Transition_TransitionCrossfade.fromPartial(I.crossfade) : void 0, z.fadeToColor = I.fadeToColor !== void 0 && I.fadeToColor !== null ? a.Transition_TransitionFadeToColor.fromPartial(I.fadeToColor) : void 0, z.swipe = I.swipe !== void 0 && I.swipe !== null ? a.Transition_TransitionSwipe.fromPartial(I.swipe) : void 0, z.stinger = I.stinger !== void 0 && I.stinger !== null ? a.Transition_TransitionStinger.fromPartial(I.stinger) : void 0, z;
    }
  };
  function le() {
    return { url: "", volume: 0 };
  }
  a.Transition_TransitionMediaType = {
    encode(I, F = g.Writer.create()) {
      return I.url !== "" && F.uint32(10).string(I.url), I.volume !== 0 && F.uint32(17).double(I.volume), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = le();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.url = z.string();
            break;
          case 2:
            fe.volume = z.double();
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        url: Ce(I.url) ? String(I.url) : "",
        volume: Ce(I.volume) ? Number(I.volume) : 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.url !== void 0 && (F.url = I.url), I.volume !== void 0 && (F.volume = I.volume), F;
    },
    fromPartial(I) {
      var F, z;
      const Te = le();
      return Te.url = (F = I.url) !== null && F !== void 0 ? F : "", Te.volume = (z = I.volume) !== null && z !== void 0 ? z : 0, Te;
    }
  };
  function we() {
    return {};
  }
  a.Transition_TransitionCut = {
    encode(I, F = g.Writer.create()) {
      return F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = we();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {};
    },
    toJSON(I) {
      return {};
    },
    fromPartial(I) {
      return we();
    }
  };
  function Be() {
    return { durationMs: 0, backgroundColor: "" };
  }
  a.Transition_TransitionFadeToColor = {
    encode(I, F = g.Writer.create()) {
      return I.durationMs !== 0 && F.uint32(8).int32(I.durationMs), I.backgroundColor !== "" && F.uint32(18).string(I.backgroundColor), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Be();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.durationMs = z.int32();
            break;
          case 2:
            fe.backgroundColor = z.string();
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        durationMs: Ce(I.durationMs) ? Number(I.durationMs) : 0,
        backgroundColor: Ce(I.backgroundColor) ? String(I.backgroundColor) : ""
      };
    },
    toJSON(I) {
      const F = {};
      return I.durationMs !== void 0 && (F.durationMs = Math.round(I.durationMs)), I.backgroundColor !== void 0 && (F.backgroundColor = I.backgroundColor), F;
    },
    fromPartial(I) {
      var F, z;
      const Te = Be();
      return Te.durationMs = (F = I.durationMs) !== null && F !== void 0 ? F : 0, Te.backgroundColor = (z = I.backgroundColor) !== null && z !== void 0 ? z : "", Te;
    }
  };
  function Ne() {
    return { durationMs: 0 };
  }
  a.Transition_TransitionCrossfade = {
    encode(I, F = g.Writer.create()) {
      return I.durationMs !== 0 && F.uint32(8).int32(I.durationMs), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Ne();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.durationMs = z.int32();
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        durationMs: Ce(I.durationMs) ? Number(I.durationMs) : 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.durationMs !== void 0 && (F.durationMs = Math.round(I.durationMs)), F;
    },
    fromPartial(I) {
      var F;
      const z = Ne();
      return z.durationMs = (F = I.durationMs) !== null && F !== void 0 ? F : 0, z;
    }
  };
  function Le() {
    return {
      durationMs: 0,
      direction: de.TRANSITION_DIRECTION_UNSPECIFIED,
      combinedAnimation: W.TRANSITION_SWIPE_TYPE_UNSPECIFIED
    };
  }
  a.Transition_TransitionSwipe = {
    encode(I, F = g.Writer.create()) {
      return I.durationMs !== 0 && F.uint32(8).int32(I.durationMs), I.direction !== de.TRANSITION_DIRECTION_UNSPECIFIED && F.uint32(16).int32(D(I.direction)), I.combinedAnimation !== W.TRANSITION_SWIPE_TYPE_UNSPECIFIED && F.uint32(24).int32(ye(I.combinedAnimation)), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Le();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.durationMs = z.int32();
            break;
          case 2:
            fe.direction = A(z.int32());
            break;
          case 3:
            fe.combinedAnimation = ee(z.int32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        durationMs: Ce(I.durationMs) ? Number(I.durationMs) : 0,
        direction: Ce(I.direction) ? A(I.direction) : de.TRANSITION_DIRECTION_UNSPECIFIED,
        combinedAnimation: Ce(I.combinedAnimation) ? ee(I.combinedAnimation) : W.TRANSITION_SWIPE_TYPE_UNSPECIFIED
      };
    },
    toJSON(I) {
      const F = {};
      return I.durationMs !== void 0 && (F.durationMs = Math.round(I.durationMs)), I.direction !== void 0 && (F.direction = N(I.direction)), I.combinedAnimation !== void 0 && (F.combinedAnimation = ae(I.combinedAnimation)), F;
    },
    fromPartial(I) {
      var F, z, Te;
      const fe = Le();
      return fe.durationMs = (F = I.durationMs) !== null && F !== void 0 ? F : 0, fe.direction = (z = I.direction) !== null && z !== void 0 ? z : de.TRANSITION_DIRECTION_UNSPECIFIED, fe.combinedAnimation = (Te = I.combinedAnimation) !== null && Te !== void 0 ? Te : W.TRANSITION_SWIPE_TYPE_UNSPECIFIED, fe;
    }
  };
  function $e() {
    return { cutPointMs: 0, media: void 0 };
  }
  a.Transition_TransitionStingerCut = {
    encode(I, F = g.Writer.create()) {
      return I.cutPointMs !== 0 && F.uint32(8).int32(I.cutPointMs), I.media !== void 0 && a.Transition_TransitionMediaType.encode(I.media, F.uint32(18).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = $e();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.cutPointMs = z.int32();
            break;
          case 2:
            fe.media = a.Transition_TransitionMediaType.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        cutPointMs: Ce(I.cutPointMs) ? Number(I.cutPointMs) : 0,
        media: Ce(I.media) ? a.Transition_TransitionMediaType.fromJSON(I.media) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.cutPointMs !== void 0 && (F.cutPointMs = Math.round(I.cutPointMs)), I.media !== void 0 && (F.media = I.media ? a.Transition_TransitionMediaType.toJSON(I.media) : void 0), F;
    },
    fromPartial(I) {
      var F;
      const z = $e();
      return z.cutPointMs = (F = I.cutPointMs) !== null && F !== void 0 ? F : 0, z.media = I.media !== void 0 && I.media !== null ? a.Transition_TransitionMediaType.fromPartial(I.media) : void 0, z;
    }
  };
  function Ue() {
    return { cut: void 0 };
  }
  a.Transition_TransitionStinger = {
    encode(I, F = g.Writer.create()) {
      return I.cut !== void 0 && a.Transition_TransitionStingerCut.encode(I.cut, F.uint32(10).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Ue();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.cut = a.Transition_TransitionStingerCut.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        cut: Ce(I.cut) ? a.Transition_TransitionStingerCut.fromJSON(I.cut) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.cut !== void 0 && (F.cut = I.cut ? a.Transition_TransitionStingerCut.toJSON(I.cut) : void 0), F;
    },
    fromPartial(I) {
      const F = Ue();
      return F.cut = I.cut !== void 0 && I.cut !== null ? a.Transition_TransitionStingerCut.fromPartial(I.cut) : void 0, F;
    }
  };
  function Ge() {
    return {
      id: "",
      width: 0,
      height: 0,
      metadata: void 0,
      projectId: void 0,
      collectionId: void 0,
      type: void 0,
      transitions: [],
      requestMetadata: void 0
    };
  }
  a.Layout = {
    encode(I, F = g.Writer.create()) {
      I.id !== "" && F.uint32(10).string(I.id), I.width !== 0 && F.uint32(16).int32(I.width), I.height !== 0 && F.uint32(24).int32(I.height), I.metadata !== void 0 && E.Value.encode(E.Value.wrap(I.metadata), F.uint32(50).fork()).ldelim(), I.projectId !== void 0 && F.uint32(58).string(I.projectId), I.collectionId !== void 0 && F.uint32(66).string(I.collectionId), I.type !== void 0 && F.uint32(72).int32(M(I.type));
      for (const z of I.transitions)
        a.Transition.encode(z, F.uint32(82).fork()).ldelim();
      return I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(810).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Ge();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.id = z.string();
            break;
          case 2:
            fe.width = z.int32();
            break;
          case 3:
            fe.height = z.int32();
            break;
          case 6:
            fe.metadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 7:
            fe.projectId = z.string();
            break;
          case 8:
            fe.collectionId = z.string();
            break;
          case 9:
            fe.type = k(z.int32());
            break;
          case 10:
            fe.transitions.push(a.Transition.decode(z, z.uint32()));
            break;
          case 101:
            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        id: Ce(I.id) ? String(I.id) : "",
        width: Ce(I.width) ? Number(I.width) : 0,
        height: Ce(I.height) ? Number(I.height) : 0,
        metadata: Ce(I == null ? void 0 : I.metadata) ? I.metadata : void 0,
        projectId: Ce(I.projectId) ? String(I.projectId) : void 0,
        collectionId: Ce(I.collectionId) ? String(I.collectionId) : void 0,
        type: Ce(I.type) ? k(I.type) : void 0,
        transitions: Array.isArray(I == null ? void 0 : I.transitions) ? I.transitions.map((F) => a.Transition.fromJSON(F)) : [],
        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.id !== void 0 && (F.id = I.id), I.width !== void 0 && (F.width = Math.round(I.width)), I.height !== void 0 && (F.height = Math.round(I.height)), I.metadata !== void 0 && (F.metadata = I.metadata), I.projectId !== void 0 && (F.projectId = I.projectId), I.collectionId !== void 0 && (F.collectionId = I.collectionId), I.type !== void 0 && (F.type = I.type !== void 0 ? L(I.type) : void 0), I.transitions ? F.transitions = I.transitions.map((z) => z ? a.Transition.toJSON(z) : void 0) : F.transitions = [], I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;
    },
    fromPartial(I) {
      var F, z, Te, fe, ke, it, mt, vt, st;
      const ut = Ge();
      return ut.id = (F = I.id) !== null && F !== void 0 ? F : "", ut.width = (z = I.width) !== null && z !== void 0 ? z : 0, ut.height = (Te = I.height) !== null && Te !== void 0 ? Te : 0, ut.metadata = (fe = I.metadata) !== null && fe !== void 0 ? fe : void 0, ut.projectId = (ke = I.projectId) !== null && ke !== void 0 ? ke : void 0, ut.collectionId = (it = I.collectionId) !== null && it !== void 0 ? it : void 0, ut.type = (mt = I.type) !== null && mt !== void 0 ? mt : void 0, ut.transitions = ((vt = I.transitions) === null || vt === void 0 ? void 0 : vt.map((yt) => a.Transition.fromPartial(yt))) || [], ut.requestMetadata = (st = I.requestMetadata) !== null && st !== void 0 ? st : void 0, ut;
    }
  };
  function He() {
    return {
      type: "",
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: 0,
      opacity: 0,
      scale: 0,
      hidden: !1,
      children: void 0,
      metadata: void 0,
      id: "",
      layoutId: "",
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.Layer = {
    encode(I, F = g.Writer.create()) {
      I.type !== "" && F.uint32(10).string(I.type), I.data !== void 0 && E.Struct.encode(E.Struct.wrap(I.data), F.uint32(18).fork()).ldelim(), I.x !== void 0 && E.Value.encode(E.Value.wrap(I.x), F.uint32(26).fork()).ldelim(), I.y !== void 0 && E.Value.encode(E.Value.wrap(I.y), F.uint32(34).fork()).ldelim(), I.width !== void 0 && E.Value.encode(E.Value.wrap(I.width), F.uint32(42).fork()).ldelim(), I.height !== void 0 && E.Value.encode(E.Value.wrap(I.height), F.uint32(50).fork()).ldelim(), I.rotation !== 0 && F.uint32(57).double(I.rotation), I.opacity !== 0 && F.uint32(65).double(I.opacity), I.scale !== 0 && F.uint32(73).double(I.scale), I.hidden === !0 && F.uint32(80).bool(I.hidden), I.children !== void 0 && E.ListValue.encode(E.ListValue.wrap(I.children), F.uint32(98).fork()).ldelim(), I.metadata !== void 0 && E.Value.encode(E.Value.wrap(I.metadata), F.uint32(114).fork()).ldelim(), I.id !== "" && F.uint32(802).string(I.id), I.layoutId !== "" && F.uint32(818).string(I.layoutId), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(810).fork()).ldelim();
      for (const z of I.requestAnimation)
        a.LayerAnimation.encode(z, F.uint32(826).fork()).ldelim();
      return F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = He();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.type = z.string();
            break;
          case 2:
            fe.data = E.Struct.unwrap(E.Struct.decode(z, z.uint32()));
            break;
          case 3:
            fe.x = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 4:
            fe.y = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 5:
            fe.width = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 6:
            fe.height = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 7:
            fe.rotation = z.double();
            break;
          case 8:
            fe.opacity = z.double();
            break;
          case 9:
            fe.scale = z.double();
            break;
          case 10:
            fe.hidden = z.bool();
            break;
          case 12:
            fe.children = E.ListValue.unwrap(E.ListValue.decode(z, z.uint32()));
            break;
          case 14:
            fe.metadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 100:
            fe.id = z.string();
            break;
          case 102:
            fe.layoutId = z.string();
            break;
          case 101:
            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 103:
            fe.requestAnimation.push(a.LayerAnimation.decode(z, z.uint32()));
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        type: Ce(I.type) ? String(I.type) : "",
        data: ft(I.data) ? I.data : void 0,
        x: Ce(I == null ? void 0 : I.x) ? I.x : void 0,
        y: Ce(I == null ? void 0 : I.y) ? I.y : void 0,
        width: Ce(I == null ? void 0 : I.width) ? I.width : void 0,
        height: Ce(I == null ? void 0 : I.height) ? I.height : void 0,
        rotation: Ce(I.rotation) ? Number(I.rotation) : 0,
        opacity: Ce(I.opacity) ? Number(I.opacity) : 0,
        scale: Ce(I.scale) ? Number(I.scale) : 0,
        hidden: Ce(I.hidden) ? !!I.hidden : !1,
        children: Array.isArray(I.children) ? [...I.children] : void 0,
        metadata: Ce(I == null ? void 0 : I.metadata) ? I.metadata : void 0,
        id: Ce(I.id) ? String(I.id) : "",
        layoutId: Ce(I.layoutId) ? String(I.layoutId) : "",
        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0,
        requestAnimation: Array.isArray(I == null ? void 0 : I.requestAnimation) ? I.requestAnimation.map((F) => a.LayerAnimation.fromJSON(F)) : []
      };
    },
    toJSON(I) {
      const F = {};
      return I.type !== void 0 && (F.type = I.type), I.data !== void 0 && (F.data = I.data), I.x !== void 0 && (F.x = I.x), I.y !== void 0 && (F.y = I.y), I.width !== void 0 && (F.width = I.width), I.height !== void 0 && (F.height = I.height), I.rotation !== void 0 && (F.rotation = I.rotation), I.opacity !== void 0 && (F.opacity = I.opacity), I.scale !== void 0 && (F.scale = I.scale), I.hidden !== void 0 && (F.hidden = I.hidden), I.children !== void 0 && (F.children = I.children), I.metadata !== void 0 && (F.metadata = I.metadata), I.id !== void 0 && (F.id = I.id), I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), I.requestAnimation ? F.requestAnimation = I.requestAnimation.map((z) => z ? a.LayerAnimation.toJSON(z) : void 0) : F.requestAnimation = [], F;
    },
    fromPartial(I) {
      var F, z, Te, fe, ke, it, mt, vt, st, ut, yt, gt, bt, St, Et, ct;
      const Xe = He();
      return Xe.type = (F = I.type) !== null && F !== void 0 ? F : "", Xe.data = (z = I.data) !== null && z !== void 0 ? z : void 0, Xe.x = (Te = I.x) !== null && Te !== void 0 ? Te : void 0, Xe.y = (fe = I.y) !== null && fe !== void 0 ? fe : void 0, Xe.width = (ke = I.width) !== null && ke !== void 0 ? ke : void 0, Xe.height = (it = I.height) !== null && it !== void 0 ? it : void 0, Xe.rotation = (mt = I.rotation) !== null && mt !== void 0 ? mt : 0, Xe.opacity = (vt = I.opacity) !== null && vt !== void 0 ? vt : 0, Xe.scale = (st = I.scale) !== null && st !== void 0 ? st : 0, Xe.hidden = (ut = I.hidden) !== null && ut !== void 0 ? ut : !1, Xe.children = (yt = I.children) !== null && yt !== void 0 ? yt : void 0, Xe.metadata = (gt = I.metadata) !== null && gt !== void 0 ? gt : void 0, Xe.id = (bt = I.id) !== null && bt !== void 0 ? bt : "", Xe.layoutId = (St = I.layoutId) !== null && St !== void 0 ? St : "", Xe.requestMetadata = (Et = I.requestMetadata) !== null && Et !== void 0 ? Et : void 0, Xe.requestAnimation = ((ct = I.requestAnimation) === null || ct === void 0 ? void 0 : ct.map((Ct) => a.LayerAnimation.fromPartial(Ct))) || [], Xe;
    }
  };
  function Ve() {
    return { layoutId: "", layerId: "", payload: void 0 };
  }
  a.DeleteLayerRequest = {
    encode(I, F = g.Writer.create()) {
      return I.layoutId !== "" && F.uint32(10).string(I.layoutId), I.layerId !== "" && F.uint32(18).string(I.layerId), I.payload !== void 0 && a.DeleteLayerPayload.encode(I.payload, F.uint32(26).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Ve();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.layoutId = z.string();
            break;
          case 2:
            fe.layerId = z.string();
            break;
          case 3:
            fe.payload = a.DeleteLayerPayload.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layoutId: Ce(I.layoutId) ? String(I.layoutId) : "",
        layerId: Ce(I.layerId) ? String(I.layerId) : "",
        payload: Ce(I.payload) ? a.DeleteLayerPayload.fromJSON(I.payload) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.layerId !== void 0 && (F.layerId = I.layerId), I.payload !== void 0 && (F.payload = I.payload ? a.DeleteLayerPayload.toJSON(I.payload) : void 0), F;
    },
    fromPartial(I) {
      var F, z;
      const Te = Ve();
      return Te.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : "", Te.layerId = (z = I.layerId) !== null && z !== void 0 ? z : "", Te.payload = I.payload !== void 0 && I.payload !== null ? a.DeleteLayerPayload.fromPartial(I.payload) : void 0, Te;
    }
  };
  function be() {
    return { id: "", layoutId: "", requestMetadata: void 0 };
  }
  a.DeleteLayerResponse = {
    encode(I, F = g.Writer.create()) {
      return I.id !== "" && F.uint32(10).string(I.id), I.layoutId !== "" && F.uint32(18).string(I.layoutId), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = be();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.id = z.string();
            break;
          case 2:
            fe.layoutId = z.string();
            break;
          case 100:
            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        id: Ce(I.id) ? String(I.id) : "",
        layoutId: Ce(I.layoutId) ? String(I.layoutId) : "",
        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.id !== void 0 && (F.id = I.id), I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;
    },
    fromPartial(I) {
      var F, z, Te;
      const fe = be();
      return fe.id = (F = I.id) !== null && F !== void 0 ? F : "", fe.layoutId = (z = I.layoutId) !== null && z !== void 0 ? z : "", fe.requestMetadata = (Te = I.requestMetadata) !== null && Te !== void 0 ? Te : void 0, fe;
    }
  };
  function Ae() {
    return {
      layers: [],
      layoutId: "",
      requestMetadata: void 0,
      requestAnimationMode: $.REQUEST_ANIMATION_MODE_UNSPECIFIED
    };
  }
  a.BatchLayerResponse = {
    encode(I, F = g.Writer.create()) {
      for (const z of I.layers)
        a.BatchLayerResponse_BatchLayerItem.encode(z, F.uint32(18).fork()).ldelim();
      return I.layoutId !== "" && F.uint32(26).string(I.layoutId), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), I.requestAnimationMode !== $.REQUEST_ANIMATION_MODE_UNSPECIFIED && F.uint32(808).int32(q(I.requestAnimationMode)), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Ae();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 2:
            fe.layers.push(a.BatchLayerResponse_BatchLayerItem.decode(z, z.uint32()));
            break;
          case 3:
            fe.layoutId = z.string();
            break;
          case 100:
            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 101:
            fe.requestAnimationMode = J(z.int32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layers: Array.isArray(I == null ? void 0 : I.layers) ? I.layers.map((F) => a.BatchLayerResponse_BatchLayerItem.fromJSON(F)) : [],
        layoutId: Ce(I.layoutId) ? String(I.layoutId) : "",
        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0,
        requestAnimationMode: Ce(I.requestAnimationMode) ? J(I.requestAnimationMode) : $.REQUEST_ANIMATION_MODE_UNSPECIFIED
      };
    },
    toJSON(I) {
      const F = {};
      return I.layers ? F.layers = I.layers.map((z) => z ? a.BatchLayerResponse_BatchLayerItem.toJSON(z) : void 0) : F.layers = [], I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), I.requestAnimationMode !== void 0 && (F.requestAnimationMode = V(I.requestAnimationMode)), F;
    },
    fromPartial(I) {
      var F, z, Te, fe;
      const ke = Ae();
      return ke.layers = ((F = I.layers) === null || F === void 0 ? void 0 : F.map((it) => a.BatchLayerResponse_BatchLayerItem.fromPartial(it))) || [], ke.layoutId = (z = I.layoutId) !== null && z !== void 0 ? z : "", ke.requestMetadata = (Te = I.requestMetadata) !== null && Te !== void 0 ? Te : void 0, ke.requestAnimationMode = (fe = I.requestAnimationMode) !== null && fe !== void 0 ? fe : $.REQUEST_ANIMATION_MODE_UNSPECIFIED, ke;
    }
  };
  function qe() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.BatchLayerResponse_BatchLayerItem = {
    encode(I, F = g.Writer.create()) {
      return I.create !== void 0 && a.Layer.encode(I.create, F.uint32(10).fork()).ldelim(), I.update !== void 0 && a.Layer.encode(I.update, F.uint32(18).fork()).ldelim(), I.delete !== void 0 && a.DeleteLayerResponse.encode(I.delete, F.uint32(26).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = qe();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.create = a.Layer.decode(z, z.uint32());
            break;
          case 2:
            fe.update = a.Layer.decode(z, z.uint32());
            break;
          case 3:
            fe.delete = a.DeleteLayerResponse.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        create: Ce(I.create) ? a.Layer.fromJSON(I.create) : void 0,
        update: Ce(I.update) ? a.Layer.fromJSON(I.update) : void 0,
        delete: Ce(I.delete) ? a.DeleteLayerResponse.fromJSON(I.delete) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.create !== void 0 && (F.create = I.create ? a.Layer.toJSON(I.create) : void 0), I.update !== void 0 && (F.update = I.update ? a.Layer.toJSON(I.update) : void 0), I.delete !== void 0 && (F.delete = I.delete ? a.DeleteLayerResponse.toJSON(I.delete) : void 0), F;
    },
    fromPartial(I) {
      const F = qe();
      return F.create = I.create !== void 0 && I.create !== null ? a.Layer.fromPartial(I.create) : void 0, F.update = I.update !== void 0 && I.update !== null ? a.Layer.fromPartial(I.update) : void 0, F.delete = I.delete !== void 0 && I.delete !== null ? a.DeleteLayerResponse.fromPartial(I.delete) : void 0, F;
    }
  };
  function xe() {
    return {
      width: void 0,
      height: void 0,
      metadata: void 0,
      projectId: void 0,
      collectionId: void 0,
      type: void 0,
      transitions: [],
      requestMetadata: void 0
    };
  }
  a.PartialLayout = {
    encode(I, F = g.Writer.create()) {
      I.width !== void 0 && F.uint32(16).int32(I.width), I.height !== void 0 && F.uint32(24).int32(I.height), I.metadata !== void 0 && E.Value.encode(E.Value.wrap(I.metadata), F.uint32(50).fork()).ldelim(), I.projectId !== void 0 && F.uint32(58).string(I.projectId), I.collectionId !== void 0 && F.uint32(66).string(I.collectionId), I.type !== void 0 && F.uint32(72).int32(M(I.type));
      for (const z of I.transitions)
        a.Transition.encode(z, F.uint32(82).fork()).ldelim();
      return I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(810).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = xe();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 2:
            fe.width = z.int32();
            break;
          case 3:
            fe.height = z.int32();
            break;
          case 6:
            fe.metadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 7:
            fe.projectId = z.string();
            break;
          case 8:
            fe.collectionId = z.string();
            break;
          case 9:
            fe.type = k(z.int32());
            break;
          case 10:
            fe.transitions.push(a.Transition.decode(z, z.uint32()));
            break;
          case 101:
            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        width: Ce(I.width) ? Number(I.width) : void 0,
        height: Ce(I.height) ? Number(I.height) : void 0,
        metadata: Ce(I == null ? void 0 : I.metadata) ? I.metadata : void 0,
        projectId: Ce(I.projectId) ? String(I.projectId) : void 0,
        collectionId: Ce(I.collectionId) ? String(I.collectionId) : void 0,
        type: Ce(I.type) ? k(I.type) : void 0,
        transitions: Array.isArray(I == null ? void 0 : I.transitions) ? I.transitions.map((F) => a.Transition.fromJSON(F)) : [],
        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.width !== void 0 && (F.width = Math.round(I.width)), I.height !== void 0 && (F.height = Math.round(I.height)), I.metadata !== void 0 && (F.metadata = I.metadata), I.projectId !== void 0 && (F.projectId = I.projectId), I.collectionId !== void 0 && (F.collectionId = I.collectionId), I.type !== void 0 && (F.type = I.type !== void 0 ? L(I.type) : void 0), I.transitions ? F.transitions = I.transitions.map((z) => z ? a.Transition.toJSON(z) : void 0) : F.transitions = [], I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;
    },
    fromPartial(I) {
      var F, z, Te, fe, ke, it, mt, vt;
      const st = xe();
      return st.width = (F = I.width) !== null && F !== void 0 ? F : void 0, st.height = (z = I.height) !== null && z !== void 0 ? z : void 0, st.metadata = (Te = I.metadata) !== null && Te !== void 0 ? Te : void 0, st.projectId = (fe = I.projectId) !== null && fe !== void 0 ? fe : void 0, st.collectionId = (ke = I.collectionId) !== null && ke !== void 0 ? ke : void 0, st.type = (it = I.type) !== null && it !== void 0 ? it : void 0, st.transitions = ((mt = I.transitions) === null || mt === void 0 ? void 0 : mt.map((ut) => a.Transition.fromPartial(ut))) || [], st.requestMetadata = (vt = I.requestMetadata) !== null && vt !== void 0 ? vt : void 0, st;
    }
  };
  function Pe() {
    return { projectId: void 0, collectionId: void 0, type: void 0 };
  }
  a.ListLayoutsRequest = {
    encode(I, F = g.Writer.create()) {
      return I.projectId !== void 0 && F.uint32(10).string(I.projectId), I.collectionId !== void 0 && F.uint32(18).string(I.collectionId), I.type !== void 0 && F.uint32(24).int32(M(I.type)), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Pe();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.projectId = z.string();
            break;
          case 2:
            fe.collectionId = z.string();
            break;
          case 3:
            fe.type = k(z.int32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        projectId: Ce(I.projectId) ? String(I.projectId) : void 0,
        collectionId: Ce(I.collectionId) ? String(I.collectionId) : void 0,
        type: Ce(I.type) ? k(I.type) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.projectId !== void 0 && (F.projectId = I.projectId), I.collectionId !== void 0 && (F.collectionId = I.collectionId), I.type !== void 0 && (F.type = I.type !== void 0 ? L(I.type) : void 0), F;
    },
    fromPartial(I) {
      var F, z, Te;
      const fe = Pe();
      return fe.projectId = (F = I.projectId) !== null && F !== void 0 ? F : void 0, fe.collectionId = (z = I.collectionId) !== null && z !== void 0 ? z : void 0, fe.type = (Te = I.type) !== null && Te !== void 0 ? Te : void 0, fe;
    }
  };
  function C() {
    return { layouts: [] };
  }
  a.ListLayoutsResponse = {
    encode(I, F = g.Writer.create()) {
      for (const z of I.layouts)
        a.Layout.encode(z, F.uint32(10).fork()).ldelim();
      return F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = C();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.layouts.push(a.Layout.decode(z, z.uint32()));
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layouts: Array.isArray(I == null ? void 0 : I.layouts) ? I.layouts.map((F) => a.Layout.fromJSON(F)) : []
      };
    },
    toJSON(I) {
      const F = {};
      return I.layouts ? F.layouts = I.layouts.map((z) => z ? a.Layout.toJSON(z) : void 0) : F.layouts = [], F;
    },
    fromPartial(I) {
      var F;
      const z = C();
      return z.layouts = ((F = I.layouts) === null || F === void 0 ? void 0 : F.map((Te) => a.Layout.fromPartial(Te))) || [], z;
    }
  };
  function x() {
    return { layout: void 0 };
  }
  a.CreateLayoutRequest = {
    encode(I, F = g.Writer.create()) {
      return I.layout !== void 0 && a.PartialLayout.encode(I.layout, F.uint32(18).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = x();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 2:
            fe.layout = a.PartialLayout.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layout: Ce(I.layout) ? a.PartialLayout.fromJSON(I.layout) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.layout !== void 0 && (F.layout = I.layout ? a.PartialLayout.toJSON(I.layout) : void 0), F;
    },
    fromPartial(I) {
      const F = x();
      return F.layout = I.layout !== void 0 && I.layout !== null ? a.PartialLayout.fromPartial(I.layout) : void 0, F;
    }
  };
  function Q() {
    return { layoutId: "" };
  }
  a.GetLayoutRequest = {
    encode(I, F = g.Writer.create()) {
      return I.layoutId !== "" && F.uint32(10).string(I.layoutId), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Q();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.layoutId = z.string();
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layoutId: Ce(I.layoutId) ? String(I.layoutId) : ""
      };
    },
    toJSON(I) {
      const F = {};
      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), F;
    },
    fromPartial(I) {
      var F;
      const z = Q();
      return z.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : "", z;
    }
  };
  function Se() {
    return { layoutId: "", layout: void 0 };
  }
  a.UpdateLayoutRequest = {
    encode(I, F = g.Writer.create()) {
      return I.layoutId !== "" && F.uint32(10).string(I.layoutId), I.layout !== void 0 && a.PartialLayout.encode(I.layout, F.uint32(26).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Se();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.layoutId = z.string();
            break;
          case 3:
            fe.layout = a.PartialLayout.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layoutId: Ce(I.layoutId) ? String(I.layoutId) : "",
        layout: Ce(I.layout) ? a.PartialLayout.fromJSON(I.layout) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.layout !== void 0 && (F.layout = I.layout ? a.PartialLayout.toJSON(I.layout) : void 0), F;
    },
    fromPartial(I) {
      var F;
      const z = Se();
      return z.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : "", z.layout = I.layout !== void 0 && I.layout !== null ? a.PartialLayout.fromPartial(I.layout) : void 0, z;
    }
  };
  function me() {
    return { requestMetadata: void 0 };
  }
  a.DeleteLayoutPayload = {
    encode(I, F = g.Writer.create()) {
      return I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = me();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 100:
            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;
    },
    fromPartial(I) {
      var F;
      const z = me();
      return z.requestMetadata = (F = I.requestMetadata) !== null && F !== void 0 ? F : void 0, z;
    }
  };
  function Ie() {
    return { layoutId: "", payload: void 0 };
  }
  a.DeleteLayoutRequest = {
    encode(I, F = g.Writer.create()) {
      return I.layoutId !== "" && F.uint32(10).string(I.layoutId), I.payload !== void 0 && a.DeleteLayoutPayload.encode(I.payload, F.uint32(18).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Ie();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.layoutId = z.string();
            break;
          case 2:
            fe.payload = a.DeleteLayoutPayload.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layoutId: Ce(I.layoutId) ? String(I.layoutId) : "",
        payload: Ce(I.payload) ? a.DeleteLayoutPayload.fromJSON(I.payload) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.payload !== void 0 && (F.payload = I.payload ? a.DeleteLayoutPayload.toJSON(I.payload) : void 0), F;
    },
    fromPartial(I) {
      var F;
      const z = Ie();
      return z.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : "", z.payload = I.payload !== void 0 && I.payload !== null ? a.DeleteLayoutPayload.fromPartial(I.payload) : void 0, z;
    }
  };
  function at() {
    return { id: "", requestMetadata: void 0 };
  }
  a.DeleteLayoutResponse = {
    encode(I, F = g.Writer.create()) {
      return I.id !== "" && F.uint32(18).string(I.id), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = at();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 2:
            fe.id = z.string();
            break;
          case 100:
            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        id: Ce(I.id) ? String(I.id) : "",
        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.id !== void 0 && (F.id = I.id), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;
    },
    fromPartial(I) {
      var F, z;
      const Te = at();
      return Te.id = (F = I.id) !== null && F !== void 0 ? F : "", Te.requestMetadata = (z = I.requestMetadata) !== null && z !== void 0 ? z : void 0, Te;
    }
  };
  function Ye() {
    return {
      properties: [],
      durationMs: 0,
      delayMs: void 0,
      easingMode: void 0
    };
  }
  a.LayerAnimation = {
    encode(I, F = g.Writer.create()) {
      for (const z of I.properties)
        F.uint32(10).string(z);
      return I.durationMs !== 0 && F.uint32(16).int32(I.durationMs), I.delayMs !== void 0 && F.uint32(32).int32(I.delayMs), I.easingMode !== void 0 && F.uint32(42).string(I.easingMode), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Ye();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.properties.push(z.string());
            break;
          case 2:
            fe.durationMs = z.int32();
            break;
          case 4:
            fe.delayMs = z.int32();
            break;
          case 5:
            fe.easingMode = z.string();
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        properties: Array.isArray(I == null ? void 0 : I.properties) ? I.properties.map((F) => String(F)) : [],
        durationMs: Ce(I.durationMs) ? Number(I.durationMs) : 0,
        delayMs: Ce(I.delayMs) ? Number(I.delayMs) : void 0,
        easingMode: Ce(I.easingMode) ? String(I.easingMode) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.properties ? F.properties = I.properties.map((z) => z) : F.properties = [], I.durationMs !== void 0 && (F.durationMs = Math.round(I.durationMs)), I.delayMs !== void 0 && (F.delayMs = Math.round(I.delayMs)), I.easingMode !== void 0 && (F.easingMode = I.easingMode), F;
    },
    fromPartial(I) {
      var F, z, Te, fe;
      const ke = Ye();
      return ke.properties = ((F = I.properties) === null || F === void 0 ? void 0 : F.map((it) => it)) || [], ke.durationMs = (z = I.durationMs) !== null && z !== void 0 ? z : 0, ke.delayMs = (Te = I.delayMs) !== null && Te !== void 0 ? Te : void 0, ke.easingMode = (fe = I.easingMode) !== null && fe !== void 0 ? fe : void 0, ke;
    }
  };
  function je() {
    return {
      type: void 0,
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: void 0,
      opacity: void 0,
      scale: void 0,
      hidden: void 0,
      children: void 0,
      parentId: void 0,
      metadata: void 0,
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.PartialLayer = {
    encode(I, F = g.Writer.create()) {
      I.type !== void 0 && F.uint32(10).string(I.type), I.data !== void 0 && E.Struct.encode(E.Struct.wrap(I.data), F.uint32(18).fork()).ldelim(), I.x !== void 0 && E.Value.encode(E.Value.wrap(I.x), F.uint32(26).fork()).ldelim(), I.y !== void 0 && E.Value.encode(E.Value.wrap(I.y), F.uint32(34).fork()).ldelim(), I.width !== void 0 && E.Value.encode(E.Value.wrap(I.width), F.uint32(42).fork()).ldelim(), I.height !== void 0 && E.Value.encode(E.Value.wrap(I.height), F.uint32(50).fork()).ldelim(), I.rotation !== void 0 && F.uint32(57).double(I.rotation), I.opacity !== void 0 && F.uint32(65).double(I.opacity), I.scale !== void 0 && F.uint32(73).double(I.scale), I.hidden !== void 0 && F.uint32(80).bool(I.hidden), I.children !== void 0 && E.ListValue.encode(E.ListValue.wrap(I.children), F.uint32(98).fork()).ldelim(), I.parentId !== void 0 && F.uint32(106).string(I.parentId), I.metadata !== void 0 && E.Value.encode(E.Value.wrap(I.metadata), F.uint32(114).fork()).ldelim(), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim();
      for (const z of I.requestAnimation)
        a.LayerAnimation.encode(z, F.uint32(826).fork()).ldelim();
      return F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = je();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.type = z.string();
            break;
          case 2:
            fe.data = E.Struct.unwrap(E.Struct.decode(z, z.uint32()));
            break;
          case 3:
            fe.x = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 4:
            fe.y = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 5:
            fe.width = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 6:
            fe.height = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 7:
            fe.rotation = z.double();
            break;
          case 8:
            fe.opacity = z.double();
            break;
          case 9:
            fe.scale = z.double();
            break;
          case 10:
            fe.hidden = z.bool();
            break;
          case 12:
            fe.children = E.ListValue.unwrap(E.ListValue.decode(z, z.uint32()));
            break;
          case 13:
            fe.parentId = z.string();
            break;
          case 14:
            fe.metadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 100:
            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 103:
            fe.requestAnimation.push(a.LayerAnimation.decode(z, z.uint32()));
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        type: Ce(I.type) ? String(I.type) : void 0,
        data: ft(I.data) ? I.data : void 0,
        x: Ce(I == null ? void 0 : I.x) ? I.x : void 0,
        y: Ce(I == null ? void 0 : I.y) ? I.y : void 0,
        width: Ce(I == null ? void 0 : I.width) ? I.width : void 0,
        height: Ce(I == null ? void 0 : I.height) ? I.height : void 0,
        rotation: Ce(I.rotation) ? Number(I.rotation) : void 0,
        opacity: Ce(I.opacity) ? Number(I.opacity) : void 0,
        scale: Ce(I.scale) ? Number(I.scale) : void 0,
        hidden: Ce(I.hidden) ? !!I.hidden : void 0,
        children: Array.isArray(I.children) ? [...I.children] : void 0,
        parentId: Ce(I.parentId) ? String(I.parentId) : void 0,
        metadata: Ce(I == null ? void 0 : I.metadata) ? I.metadata : void 0,
        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0,
        requestAnimation: Array.isArray(I == null ? void 0 : I.requestAnimation) ? I.requestAnimation.map((F) => a.LayerAnimation.fromJSON(F)) : []
      };
    },
    toJSON(I) {
      const F = {};
      return I.type !== void 0 && (F.type = I.type), I.data !== void 0 && (F.data = I.data), I.x !== void 0 && (F.x = I.x), I.y !== void 0 && (F.y = I.y), I.width !== void 0 && (F.width = I.width), I.height !== void 0 && (F.height = I.height), I.rotation !== void 0 && (F.rotation = I.rotation), I.opacity !== void 0 && (F.opacity = I.opacity), I.scale !== void 0 && (F.scale = I.scale), I.hidden !== void 0 && (F.hidden = I.hidden), I.children !== void 0 && (F.children = I.children), I.parentId !== void 0 && (F.parentId = I.parentId), I.metadata !== void 0 && (F.metadata = I.metadata), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), I.requestAnimation ? F.requestAnimation = I.requestAnimation.map((z) => z ? a.LayerAnimation.toJSON(z) : void 0) : F.requestAnimation = [], F;
    },
    fromPartial(I) {
      var F, z, Te, fe, ke, it, mt, vt, st, ut, yt, gt, bt, St, Et;
      const ct = je();
      return ct.type = (F = I.type) !== null && F !== void 0 ? F : void 0, ct.data = (z = I.data) !== null && z !== void 0 ? z : void 0, ct.x = (Te = I.x) !== null && Te !== void 0 ? Te : void 0, ct.y = (fe = I.y) !== null && fe !== void 0 ? fe : void 0, ct.width = (ke = I.width) !== null && ke !== void 0 ? ke : void 0, ct.height = (it = I.height) !== null && it !== void 0 ? it : void 0, ct.rotation = (mt = I.rotation) !== null && mt !== void 0 ? mt : void 0, ct.opacity = (vt = I.opacity) !== null && vt !== void 0 ? vt : void 0, ct.scale = (st = I.scale) !== null && st !== void 0 ? st : void 0, ct.hidden = (ut = I.hidden) !== null && ut !== void 0 ? ut : void 0, ct.children = (yt = I.children) !== null && yt !== void 0 ? yt : void 0, ct.parentId = (gt = I.parentId) !== null && gt !== void 0 ? gt : void 0, ct.metadata = (bt = I.metadata) !== null && bt !== void 0 ? bt : void 0, ct.requestMetadata = (St = I.requestMetadata) !== null && St !== void 0 ? St : void 0, ct.requestAnimation = ((Et = I.requestAnimation) === null || Et === void 0 ? void 0 : Et.map((Xe) => a.LayerAnimation.fromPartial(Xe))) || [], ct;
    }
  };
  function tt() {
    return {
      id: "",
      type: void 0,
      data: void 0,
      x: void 0,
      y: void 0,
      width: void 0,
      height: void 0,
      rotation: void 0,
      opacity: void 0,
      scale: void 0,
      hidden: void 0,
      children: void 0,
      parentId: void 0,
      metadata: void 0,
      requestMetadata: void 0,
      requestAnimation: []
    };
  }
  a.PartialLayerWithID = {
    encode(I, F = g.Writer.create()) {
      I.id !== "" && F.uint32(8002).string(I.id), I.type !== void 0 && F.uint32(10).string(I.type), I.data !== void 0 && E.Struct.encode(E.Struct.wrap(I.data), F.uint32(18).fork()).ldelim(), I.x !== void 0 && E.Value.encode(E.Value.wrap(I.x), F.uint32(26).fork()).ldelim(), I.y !== void 0 && E.Value.encode(E.Value.wrap(I.y), F.uint32(34).fork()).ldelim(), I.width !== void 0 && E.Value.encode(E.Value.wrap(I.width), F.uint32(42).fork()).ldelim(), I.height !== void 0 && E.Value.encode(E.Value.wrap(I.height), F.uint32(50).fork()).ldelim(), I.rotation !== void 0 && F.uint32(57).double(I.rotation), I.opacity !== void 0 && F.uint32(65).double(I.opacity), I.scale !== void 0 && F.uint32(73).double(I.scale), I.hidden !== void 0 && F.uint32(80).bool(I.hidden), I.children !== void 0 && E.ListValue.encode(E.ListValue.wrap(I.children), F.uint32(98).fork()).ldelim(), I.parentId !== void 0 && F.uint32(106).string(I.parentId), I.metadata !== void 0 && E.Value.encode(E.Value.wrap(I.metadata), F.uint32(114).fork()).ldelim(), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim();
      for (const z of I.requestAnimation)
        a.LayerAnimation.encode(z, F.uint32(826).fork()).ldelim();
      return F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = tt();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1e3:
            fe.id = z.string();
            break;
          case 1:
            fe.type = z.string();
            break;
          case 2:
            fe.data = E.Struct.unwrap(E.Struct.decode(z, z.uint32()));
            break;
          case 3:
            fe.x = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 4:
            fe.y = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 5:
            fe.width = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 6:
            fe.height = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 7:
            fe.rotation = z.double();
            break;
          case 8:
            fe.opacity = z.double();
            break;
          case 9:
            fe.scale = z.double();
            break;
          case 10:
            fe.hidden = z.bool();
            break;
          case 12:
            fe.children = E.ListValue.unwrap(E.ListValue.decode(z, z.uint32()));
            break;
          case 13:
            fe.parentId = z.string();
            break;
          case 14:
            fe.metadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 100:
            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 103:
            fe.requestAnimation.push(a.LayerAnimation.decode(z, z.uint32()));
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        id: Ce(I.id) ? String(I.id) : "",
        type: Ce(I.type) ? String(I.type) : void 0,
        data: ft(I.data) ? I.data : void 0,
        x: Ce(I == null ? void 0 : I.x) ? I.x : void 0,
        y: Ce(I == null ? void 0 : I.y) ? I.y : void 0,
        width: Ce(I == null ? void 0 : I.width) ? I.width : void 0,
        height: Ce(I == null ? void 0 : I.height) ? I.height : void 0,
        rotation: Ce(I.rotation) ? Number(I.rotation) : void 0,
        opacity: Ce(I.opacity) ? Number(I.opacity) : void 0,
        scale: Ce(I.scale) ? Number(I.scale) : void 0,
        hidden: Ce(I.hidden) ? !!I.hidden : void 0,
        children: Array.isArray(I.children) ? [...I.children] : void 0,
        parentId: Ce(I.parentId) ? String(I.parentId) : void 0,
        metadata: Ce(I == null ? void 0 : I.metadata) ? I.metadata : void 0,
        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0,
        requestAnimation: Array.isArray(I == null ? void 0 : I.requestAnimation) ? I.requestAnimation.map((F) => a.LayerAnimation.fromJSON(F)) : []
      };
    },
    toJSON(I) {
      const F = {};
      return I.id !== void 0 && (F.id = I.id), I.type !== void 0 && (F.type = I.type), I.data !== void 0 && (F.data = I.data), I.x !== void 0 && (F.x = I.x), I.y !== void 0 && (F.y = I.y), I.width !== void 0 && (F.width = I.width), I.height !== void 0 && (F.height = I.height), I.rotation !== void 0 && (F.rotation = I.rotation), I.opacity !== void 0 && (F.opacity = I.opacity), I.scale !== void 0 && (F.scale = I.scale), I.hidden !== void 0 && (F.hidden = I.hidden), I.children !== void 0 && (F.children = I.children), I.parentId !== void 0 && (F.parentId = I.parentId), I.metadata !== void 0 && (F.metadata = I.metadata), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), I.requestAnimation ? F.requestAnimation = I.requestAnimation.map((z) => z ? a.LayerAnimation.toJSON(z) : void 0) : F.requestAnimation = [], F;
    },
    fromPartial(I) {
      var F, z, Te, fe, ke, it, mt, vt, st, ut, yt, gt, bt, St, Et, ct;
      const Xe = tt();
      return Xe.id = (F = I.id) !== null && F !== void 0 ? F : "", Xe.type = (z = I.type) !== null && z !== void 0 ? z : void 0, Xe.data = (Te = I.data) !== null && Te !== void 0 ? Te : void 0, Xe.x = (fe = I.x) !== null && fe !== void 0 ? fe : void 0, Xe.y = (ke = I.y) !== null && ke !== void 0 ? ke : void 0, Xe.width = (it = I.width) !== null && it !== void 0 ? it : void 0, Xe.height = (mt = I.height) !== null && mt !== void 0 ? mt : void 0, Xe.rotation = (vt = I.rotation) !== null && vt !== void 0 ? vt : void 0, Xe.opacity = (st = I.opacity) !== null && st !== void 0 ? st : void 0, Xe.scale = (ut = I.scale) !== null && ut !== void 0 ? ut : void 0, Xe.hidden = (yt = I.hidden) !== null && yt !== void 0 ? yt : void 0, Xe.children = (gt = I.children) !== null && gt !== void 0 ? gt : void 0, Xe.parentId = (bt = I.parentId) !== null && bt !== void 0 ? bt : void 0, Xe.metadata = (St = I.metadata) !== null && St !== void 0 ? St : void 0, Xe.requestMetadata = (Et = I.requestMetadata) !== null && Et !== void 0 ? Et : void 0, Xe.requestAnimation = ((ct = I.requestAnimation) === null || ct === void 0 ? void 0 : ct.map((Ct) => a.LayerAnimation.fromPartial(Ct))) || [], Xe;
    }
  };
  function Oe() {
    return { layoutId: "" };
  }
  a.ListLayersRequest = {
    encode(I, F = g.Writer.create()) {
      return I.layoutId !== "" && F.uint32(10).string(I.layoutId), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Oe();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.layoutId = z.string();
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layoutId: Ce(I.layoutId) ? String(I.layoutId) : ""
      };
    },
    toJSON(I) {
      const F = {};
      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), F;
    },
    fromPartial(I) {
      var F;
      const z = Oe();
      return z.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : "", z;
    }
  };
  function P() {
    return { layers: [] };
  }
  a.ListLayersResponse = {
    encode(I, F = g.Writer.create()) {
      for (const z of I.layers)
        a.Layer.encode(z, F.uint32(10).fork()).ldelim();
      return F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = P();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.layers.push(a.Layer.decode(z, z.uint32()));
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layers: Array.isArray(I == null ? void 0 : I.layers) ? I.layers.map((F) => a.Layer.fromJSON(F)) : []
      };
    },
    toJSON(I) {
      const F = {};
      return I.layers ? F.layers = I.layers.map((z) => z ? a.Layer.toJSON(z) : void 0) : F.layers = [], F;
    },
    fromPartial(I) {
      var F;
      const z = P();
      return z.layers = ((F = I.layers) === null || F === void 0 ? void 0 : F.map((Te) => a.Layer.fromPartial(Te))) || [], z;
    }
  };
  function X() {
    return { layoutId: "", layer: void 0 };
  }
  a.CreateLayerRequest = {
    encode(I, F = g.Writer.create()) {
      return I.layoutId !== "" && F.uint32(10).string(I.layoutId), I.layer !== void 0 && a.PartialLayer.encode(I.layer, F.uint32(18).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = X();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.layoutId = z.string();
            break;
          case 2:
            fe.layer = a.PartialLayer.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layoutId: Ce(I.layoutId) ? String(I.layoutId) : "",
        layer: Ce(I.layer) ? a.PartialLayer.fromJSON(I.layer) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.layer !== void 0 && (F.layer = I.layer ? a.PartialLayer.toJSON(I.layer) : void 0), F;
    },
    fromPartial(I) {
      var F;
      const z = X();
      return z.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : "", z.layer = I.layer !== void 0 && I.layer !== null ? a.PartialLayer.fromPartial(I.layer) : void 0, z;
    }
  };
  function ie() {
    return { layoutId: "", layerId: "" };
  }
  a.GetLayerRequest = {
    encode(I, F = g.Writer.create()) {
      return I.layoutId !== "" && F.uint32(10).string(I.layoutId), I.layerId !== "" && F.uint32(18).string(I.layerId), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = ie();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.layoutId = z.string();
            break;
          case 2:
            fe.layerId = z.string();
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layoutId: Ce(I.layoutId) ? String(I.layoutId) : "",
        layerId: Ce(I.layerId) ? String(I.layerId) : ""
      };
    },
    toJSON(I) {
      const F = {};
      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.layerId !== void 0 && (F.layerId = I.layerId), F;
    },
    fromPartial(I) {
      var F, z;
      const Te = ie();
      return Te.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : "", Te.layerId = (z = I.layerId) !== null && z !== void 0 ? z : "", Te;
    }
  };
  function Ee() {
    return { layoutId: "", layerId: "", layer: void 0 };
  }
  a.UpdateLayerRequest = {
    encode(I, F = g.Writer.create()) {
      return I.layoutId !== "" && F.uint32(10).string(I.layoutId), I.layerId !== "" && F.uint32(18).string(I.layerId), I.layer !== void 0 && a.PartialLayer.encode(I.layer, F.uint32(26).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = Ee();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.layoutId = z.string();
            break;
          case 2:
            fe.layerId = z.string();
            break;
          case 3:
            fe.layer = a.PartialLayer.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layoutId: Ce(I.layoutId) ? String(I.layoutId) : "",
        layerId: Ce(I.layerId) ? String(I.layerId) : "",
        layer: Ce(I.layer) ? a.PartialLayer.fromJSON(I.layer) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.layerId !== void 0 && (F.layerId = I.layerId), I.layer !== void 0 && (F.layer = I.layer ? a.PartialLayer.toJSON(I.layer) : void 0), F;
    },
    fromPartial(I) {
      var F, z;
      const Te = Ee();
      return Te.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : "", Te.layerId = (z = I.layerId) !== null && z !== void 0 ? z : "", Te.layer = I.layer !== void 0 && I.layer !== null ? a.PartialLayer.fromPartial(I.layer) : void 0, Te;
    }
  };
  function ue() {
    return { requestMetadata: void 0 };
  }
  a.DeleteLayerPayload = {
    encode(I, F = g.Writer.create()) {
      return I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = ue();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 100:
            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;
    },
    fromPartial(I) {
      var F;
      const z = ue();
      return z.requestMetadata = (F = I.requestMetadata) !== null && F !== void 0 ? F : void 0, z;
    }
  };
  function O() {
    return { id: "", requestMetadata: void 0 };
  }
  a.BatchDeleteLayerRequest = {
    encode(I, F = g.Writer.create()) {
      return I.id !== "" && F.uint32(10).string(I.id), I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = O();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.id = z.string();
            break;
          case 100:
            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        id: Ce(I.id) ? String(I.id) : "",
        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.id !== void 0 && (F.id = I.id), I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), F;
    },
    fromPartial(I) {
      var F, z;
      const Te = O();
      return Te.id = (F = I.id) !== null && F !== void 0 ? F : "", Te.requestMetadata = (z = I.requestMetadata) !== null && z !== void 0 ? z : void 0, Te;
    }
  };
  function j() {
    return {
      layoutId: "",
      layers: [],
      requestMetadata: void 0,
      requestAnimationMode: void 0
    };
  }
  a.BatchLayerRequest = {
    encode(I, F = g.Writer.create()) {
      I.layoutId !== "" && F.uint32(10).string(I.layoutId);
      for (const z of I.layers)
        a.BatchLayerRequest_BatchItem.encode(z, F.uint32(18).fork()).ldelim();
      return I.requestMetadata !== void 0 && E.Value.encode(E.Value.wrap(I.requestMetadata), F.uint32(802).fork()).ldelim(), I.requestAnimationMode !== void 0 && F.uint32(808).int32(q(I.requestAnimationMode)), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = j();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.layoutId = z.string();
            break;
          case 2:
            fe.layers.push(a.BatchLayerRequest_BatchItem.decode(z, z.uint32()));
            break;
          case 100:
            fe.requestMetadata = E.Value.unwrap(E.Value.decode(z, z.uint32()));
            break;
          case 101:
            fe.requestAnimationMode = J(z.int32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layoutId: Ce(I.layoutId) ? String(I.layoutId) : "",
        layers: Array.isArray(I == null ? void 0 : I.layers) ? I.layers.map((F) => a.BatchLayerRequest_BatchItem.fromJSON(F)) : [],
        requestMetadata: Ce(I == null ? void 0 : I.requestMetadata) ? I.requestMetadata : void 0,
        requestAnimationMode: Ce(I.requestAnimationMode) ? J(I.requestAnimationMode) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.layoutId !== void 0 && (F.layoutId = I.layoutId), I.layers ? F.layers = I.layers.map((z) => z ? a.BatchLayerRequest_BatchItem.toJSON(z) : void 0) : F.layers = [], I.requestMetadata !== void 0 && (F.requestMetadata = I.requestMetadata), I.requestAnimationMode !== void 0 && (F.requestAnimationMode = I.requestAnimationMode !== void 0 ? V(I.requestAnimationMode) : void 0), F;
    },
    fromPartial(I) {
      var F, z, Te, fe;
      const ke = j();
      return ke.layoutId = (F = I.layoutId) !== null && F !== void 0 ? F : "", ke.layers = ((z = I.layers) === null || z === void 0 ? void 0 : z.map((it) => a.BatchLayerRequest_BatchItem.fromPartial(it))) || [], ke.requestMetadata = (Te = I.requestMetadata) !== null && Te !== void 0 ? Te : void 0, ke.requestAnimationMode = (fe = I.requestAnimationMode) !== null && fe !== void 0 ? fe : void 0, ke;
    }
  };
  function se() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.BatchLayerRequest_BatchItem = {
    encode(I, F = g.Writer.create()) {
      return I.create !== void 0 && a.PartialLayer.encode(I.create, F.uint32(10).fork()).ldelim(), I.update !== void 0 && a.PartialLayerWithID.encode(I.update, F.uint32(18).fork()).ldelim(), I.delete !== void 0 && a.BatchDeleteLayerRequest.encode(I.delete, F.uint32(26).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = se();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.create = a.PartialLayer.decode(z, z.uint32());
            break;
          case 2:
            fe.update = a.PartialLayerWithID.decode(z, z.uint32());
            break;
          case 3:
            fe.delete = a.BatchDeleteLayerRequest.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        create: Ce(I.create) ? a.PartialLayer.fromJSON(I.create) : void 0,
        update: Ce(I.update) ? a.PartialLayerWithID.fromJSON(I.update) : void 0,
        delete: Ce(I.delete) ? a.BatchDeleteLayerRequest.fromJSON(I.delete) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.create !== void 0 && (F.create = I.create ? a.PartialLayer.toJSON(I.create) : void 0), I.update !== void 0 && (F.update = I.update ? a.PartialLayerWithID.toJSON(I.update) : void 0), I.delete !== void 0 && (F.delete = I.delete ? a.BatchDeleteLayerRequest.toJSON(I.delete) : void 0), F;
    },
    fromPartial(I) {
      const F = se();
      return F.create = I.create !== void 0 && I.create !== null ? a.PartialLayer.fromPartial(I.create) : void 0, F.update = I.update !== void 0 && I.update !== null ? a.PartialLayerWithID.fromPartial(I.update) : void 0, F.delete = I.delete !== void 0 && I.delete !== null ? a.BatchDeleteLayerRequest.fromPartial(I.delete) : void 0, F;
    }
  };
  function _e() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.LayoutEvent = {
    encode(I, F = g.Writer.create()) {
      return I.create !== void 0 && a.Layout.encode(I.create, F.uint32(10).fork()).ldelim(), I.update !== void 0 && a.Layout.encode(I.update, F.uint32(18).fork()).ldelim(), I.delete !== void 0 && a.DeleteLayoutResponse.encode(I.delete, F.uint32(26).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = _e();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.create = a.Layout.decode(z, z.uint32());
            break;
          case 2:
            fe.update = a.Layout.decode(z, z.uint32());
            break;
          case 3:
            fe.delete = a.DeleteLayoutResponse.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        create: Ce(I.create) ? a.Layout.fromJSON(I.create) : void 0,
        update: Ce(I.update) ? a.Layout.fromJSON(I.update) : void 0,
        delete: Ce(I.delete) ? a.DeleteLayoutResponse.fromJSON(I.delete) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.create !== void 0 && (F.create = I.create ? a.Layout.toJSON(I.create) : void 0), I.update !== void 0 && (F.update = I.update ? a.Layout.toJSON(I.update) : void 0), I.delete !== void 0 && (F.delete = I.delete ? a.DeleteLayoutResponse.toJSON(I.delete) : void 0), F;
    },
    fromPartial(I) {
      const F = _e();
      return F.create = I.create !== void 0 && I.create !== null ? a.Layout.fromPartial(I.create) : void 0, F.update = I.update !== void 0 && I.update !== null ? a.Layout.fromPartial(I.update) : void 0, F.delete = I.delete !== void 0 && I.delete !== null ? a.DeleteLayoutResponse.fromPartial(I.delete) : void 0, F;
    }
  };
  function ve() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      batch: void 0
    };
  }
  a.LayerEvent = {
    encode(I, F = g.Writer.create()) {
      return I.create !== void 0 && a.Layer.encode(I.create, F.uint32(10).fork()).ldelim(), I.update !== void 0 && a.Layer.encode(I.update, F.uint32(18).fork()).ldelim(), I.delete !== void 0 && a.DeleteLayerResponse.encode(I.delete, F.uint32(26).fork()).ldelim(), I.batch !== void 0 && a.BatchLayerResponse.encode(I.batch, F.uint32(34).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = ve();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.create = a.Layer.decode(z, z.uint32());
            break;
          case 2:
            fe.update = a.Layer.decode(z, z.uint32());
            break;
          case 3:
            fe.delete = a.DeleteLayerResponse.decode(z, z.uint32());
            break;
          case 4:
            fe.batch = a.BatchLayerResponse.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        create: Ce(I.create) ? a.Layer.fromJSON(I.create) : void 0,
        update: Ce(I.update) ? a.Layer.fromJSON(I.update) : void 0,
        delete: Ce(I.delete) ? a.DeleteLayerResponse.fromJSON(I.delete) : void 0,
        batch: Ce(I.batch) ? a.BatchLayerResponse.fromJSON(I.batch) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.create !== void 0 && (F.create = I.create ? a.Layer.toJSON(I.create) : void 0), I.update !== void 0 && (F.update = I.update ? a.Layer.toJSON(I.update) : void 0), I.delete !== void 0 && (F.delete = I.delete ? a.DeleteLayerResponse.toJSON(I.delete) : void 0), I.batch !== void 0 && (F.batch = I.batch ? a.BatchLayerResponse.toJSON(I.batch) : void 0), F;
    },
    fromPartial(I) {
      const F = ve();
      return F.create = I.create !== void 0 && I.create !== null ? a.Layer.fromPartial(I.create) : void 0, F.update = I.update !== void 0 && I.update !== null ? a.Layer.fromPartial(I.update) : void 0, F.delete = I.delete !== void 0 && I.delete !== null ? a.DeleteLayerResponse.fromPartial(I.delete) : void 0, F.batch = I.batch !== void 0 && I.batch !== null ? a.BatchLayerResponse.fromPartial(I.batch) : void 0, F;
    }
  };
  function De() {
    return { layout: void 0, layer: void 0 };
  }
  a.Event = {
    encode(I, F = g.Writer.create()) {
      return I.layout !== void 0 && a.LayoutEvent.encode(I.layout, F.uint32(10).fork()).ldelim(), I.layer !== void 0 && a.LayerEvent.encode(I.layer, F.uint32(18).fork()).ldelim(), F;
    },
    decode(I, F) {
      const z = I instanceof g.Reader ? I : new g.Reader(I);
      let Te = F === void 0 ? z.len : z.pos + F;
      const fe = De();
      for (; z.pos < Te; ) {
        const ke = z.uint32();
        switch (ke >>> 3) {
          case 1:
            fe.layout = a.LayoutEvent.decode(z, z.uint32());
            break;
          case 2:
            fe.layer = a.LayerEvent.decode(z, z.uint32());
            break;
          default:
            z.skipType(ke & 7);
            break;
        }
      }
      return fe;
    },
    fromJSON(I) {
      return {
        layout: Ce(I.layout) ? a.LayoutEvent.fromJSON(I.layout) : void 0,
        layer: Ce(I.layer) ? a.LayerEvent.fromJSON(I.layer) : void 0
      };
    },
    toJSON(I) {
      const F = {};
      return I.layout !== void 0 && (F.layout = I.layout ? a.LayoutEvent.toJSON(I.layout) : void 0), I.layer !== void 0 && (F.layer = I.layer ? a.LayerEvent.toJSON(I.layer) : void 0), F;
    },
    fromPartial(I) {
      const F = De();
      return F.layout = I.layout !== void 0 && I.layout !== null ? a.LayoutEvent.fromPartial(I.layout) : void 0, F.layer = I.layer !== void 0 && I.layer !== null ? a.LayerEvent.fromPartial(I.layer) : void 0, F;
    }
  };
  class Ze {
    constructor(F) {
      this.rpc = F, this.ListLayers = this.ListLayers.bind(this), this.CreateLayer = this.CreateLayer.bind(this), this.GetLayer = this.GetLayer.bind(this), this.UpdateLayer = this.UpdateLayer.bind(this), this.DeleteLayer = this.DeleteLayer.bind(this), this.Batch = this.Batch.bind(this);
    }
    ListLayers(F) {
      const z = a.ListLayersRequest.encode(F).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "ListLayers", z).then((fe) => a.ListLayersResponse.decode(new g.Reader(fe)));
    }
    CreateLayer(F) {
      const z = a.CreateLayerRequest.encode(F).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "CreateLayer", z).then((fe) => a.Layer.decode(new g.Reader(fe)));
    }
    GetLayer(F) {
      const z = a.GetLayerRequest.encode(F).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "GetLayer", z).then((fe) => a.Layer.decode(new g.Reader(fe)));
    }
    UpdateLayer(F) {
      const z = a.UpdateLayerRequest.encode(F).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "UpdateLayer", z).then((fe) => a.Layer.decode(new g.Reader(fe)));
    }
    DeleteLayer(F) {
      const z = a.DeleteLayerRequest.encode(F).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "DeleteLayer", z).then((fe) => a.DeleteLayerResponse.decode(new g.Reader(fe)));
    }
    Batch(F) {
      const z = a.BatchLayerRequest.encode(F).finish();
      return this.rpc.request("apis.layout.v2.LayerService", "Batch", z).then((fe) => a.BatchLayerResponse.decode(new g.Reader(fe)));
    }
  }
  a.LayerServiceClientImpl = Ze, a.LayerServiceDefinition = {
    name: "LayerService",
    fullName: "apis.layout.v2.LayerService",
    methods: {
      /** List all layers */
      listLayers: {
        name: "ListLayers",
        requestType: a.ListLayersRequest,
        requestStream: !1,
        responseType: a.ListLayersResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create a layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      createLayer: {
        name: "CreateLayer",
        requestType: a.CreateLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /**
       * Get a single layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      getLayer: {
        name: "GetLayer",
        requestType: a.GetLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /**
       * Update a layer
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      updateLayer: {
        name: "UpdateLayer",
        requestType: a.UpdateLayerRequest,
        requestStream: !1,
        responseType: a.Layer,
        responseStream: !1,
        options: {}
      },
      /** Delete a layer */
      deleteLayer: {
        name: "DeleteLayer",
        requestType: a.DeleteLayerRequest,
        requestStream: !1,
        responseType: a.DeleteLayerResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Batch update
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      batch: {
        name: "Batch",
        requestType: a.BatchLayerRequest,
        requestStream: !1,
        responseType: a.BatchLayerResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Qe {
    constructor(F) {
      this.rpc = F, this.ListLayouts = this.ListLayouts.bind(this), this.CreateLayout = this.CreateLayout.bind(this), this.GetLayout = this.GetLayout.bind(this), this.UpdateLayout = this.UpdateLayout.bind(this), this.DeleteLayout = this.DeleteLayout.bind(this);
    }
    ListLayouts(F) {
      const z = a.ListLayoutsRequest.encode(F).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "ListLayouts", z).then((fe) => a.ListLayoutsResponse.decode(new g.Reader(fe)));
    }
    CreateLayout(F) {
      const z = a.CreateLayoutRequest.encode(F).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "CreateLayout", z).then((fe) => a.Layout.decode(new g.Reader(fe)));
    }
    GetLayout(F) {
      const z = a.GetLayoutRequest.encode(F).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "GetLayout", z).then((fe) => a.Layout.decode(new g.Reader(fe)));
    }
    UpdateLayout(F) {
      const z = a.UpdateLayoutRequest.encode(F).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "UpdateLayout", z).then((fe) => a.Layout.decode(new g.Reader(fe)));
    }
    DeleteLayout(F) {
      const z = a.DeleteLayoutRequest.encode(F).finish();
      return this.rpc.request("apis.layout.v2.LayoutService", "DeleteLayout", z).then((fe) => a.DeleteLayoutResponse.decode(new g.Reader(fe)));
    }
  }
  a.LayoutServiceClientImpl = Qe, a.LayoutServiceDefinition = {
    name: "LayoutService",
    fullName: "apis.layout.v2.LayoutService",
    methods: {
      /** Get all layouts owned by the user. */
      listLayouts: {
        name: "ListLayouts",
        requestType: a.ListLayoutsRequest,
        requestStream: !1,
        responseType: a.ListLayoutsResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create a new layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      createLayout: {
        name: "CreateLayout",
        requestType: a.CreateLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /**
       * Get a layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      getLayout: {
        name: "GetLayout",
        requestType: a.GetLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /**
       * Update a layout
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       * buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
       */
      updateLayout: {
        name: "UpdateLayout",
        requestType: a.UpdateLayoutRequest,
        requestStream: !1,
        responseType: a.Layout,
        responseStream: !1,
        options: {}
      },
      /** Delete a layout */
      deleteLayout: {
        name: "DeleteLayout",
        requestType: a.DeleteLayoutRequest,
        requestStream: !1,
        responseType: a.DeleteLayoutResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var ot = (() => {
    if (typeof ot < "u")
      return ot;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  g.util.Long !== S.default && (g.util.Long = S.default, g.configure());
  function ft(I) {
    return typeof I == "object" && I !== null;
  }
  function Ce(I) {
    return I != null;
  }
})(api$3);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(v, S, g, E) {
    E === void 0 && (E = g), Object.defineProperty(v, E, { enumerable: !0, get: function() {
      return S[g];
    } });
  } : function(v, S, g, E) {
    E === void 0 && (E = g), v[E] = S[g];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(v, S) {
    for (var g in v)
      g !== "default" && !S.hasOwnProperty(g) && u(S, v, g);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.layoutApiEventMap = void 0;
  const l = api$3;
  c(api$3, a), a.layoutApiEventMap = {
    [l.EventType.EVENT_TYPE_LAYOUT]: "layout",
    [l.EventType.EVENT_TYPE_LAYER]: "layer",
    [l.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified"
  };
})(dist$2);
var api$2 = {}, browser$2 = !1;
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var logger = {};
class EnhancedMap extends Map {
  /**
   * If key has a mapping already returns the currently associated value. If
   * there is no mapping, calls the computer which must return a value V.
   * The value is then stored for given key and returned.
   * @param key Key
   * @param computer Computer which is called only if key has no mapping yet.
   * @return Existing value if the key already existed, or the newly computed value.
   */
  computeIfAbsent(u, c) {
    if (this.has(u))
      return this.get(u);
    const l = c(u);
    return this.set(u, l), l;
  }
  /**
   * If the key exists already calls given computer, if the key does not exist
   * this method does nothing.
   *
   * The computer is called with current key and current value associated. The
   * computer can return a (new) value V or undefined. When undefined is returned
   * the key is removed from this map, when a V is returned the key is updated
   * with the new value V.
   * @param key Key
   * @param computer Computer which is called only if the key has a mapping already
   * @return Undefined if the key has no mapping, otherwise the value returned from computer
   */
  computeIfPresent(u, c) {
    const l = this.get(u);
    if (l === void 0)
      return;
    const v = c(u, l);
    return v !== void 0 ? this.set(u, v) : this.delete(u), v;
  }
  /**
   * Computes a value for given key, the computer can return a value V (in which case the map
   * will set the value for given key), if it returns undefined the mapping for key K will be
   * removed.
   * @param key Key to compute
   * @param computer Computer which is called, note that the currentValue argument contains the existing
   *                 value or is undefined when no mapping exists for the key.
   * @return The newly computed value
   */
  compute(u, c) {
    const l = this.get(u), v = c(u, l);
    return v ? this.set(u, v) : this.delete(u), v;
  }
}
var InternalLogLevel;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error";
})(InternalLogLevel || (InternalLogLevel = {}));
function getInternalLogger(a) {
  return provider.getLogger(a);
}
const INTERNAL_LOGGING_SETTINGS = {
  /**
   * Changes the log level for the internal logging (for all new and existing loggers)
   * @param level New log level
   */
  setInternalLogLevel: (a) => provider.changeLogLevel(a),
  /**
   * Changes where messages are written to for all new and existing loggers),
   * by default they are written to the console.
   * @param fnOutput Function to write messages to
   */
  setOutput: (a) => provider.changeOutput(a),
  /**
   * Resets the log level and output back to defaults (level to error and writing to console)
   * for all new and existing loggers.
   */
  reset: () => provider.reset()
};
class InternalLoggerImpl {
  constructor(u, c, l) {
    this._name = u, this._level = c, this._fnOutput = l;
  }
  trace(u) {
    this.log(InternalLogLevel.Trace, u);
  }
  debug(u) {
    this.log(InternalLogLevel.Debug, u);
  }
  error(u, c) {
    this.log(InternalLogLevel.Error, u, c);
  }
  info(u) {
    this.log(InternalLogLevel.Info, u);
  }
  warn(u, c) {
    this.log(InternalLogLevel.Warn, u, c);
  }
  setLevel(u) {
    this._level = u;
  }
  setOutput(u) {
    this._fnOutput = u;
  }
  log(u, c, l) {
    this._level > u || this._fnOutput(`${InternalLogLevel[this._level].toString()} <INTERNAL LOGGER> ${this._name} ${c()}${l ? `
` + l.stack : ""}`);
  }
}
class InternalProviderImpl {
  constructor() {
    this._loggers = new EnhancedMap(), this._logLevel = InternalLogLevel.Error, this._fnOutput = InternalProviderImpl.logConsole;
  }
  getLogger(u) {
    return this._loggers.computeIfAbsent(u, (c) => new InternalLoggerImpl(c, this._logLevel, this._fnOutput));
  }
  changeLogLevel(u) {
    this._logLevel = u, this._loggers.forEach((c) => c.setLevel(u));
  }
  changeOutput(u) {
    this._fnOutput = u, this._loggers.forEach((c) => c.setOutput(this._fnOutput));
  }
  reset() {
    this.changeLogLevel(InternalLogLevel.Error), this._fnOutput = InternalProviderImpl.logConsole, this._loggers.forEach((u) => u.setOutput(this._fnOutput));
  }
  static logConsole(u) {
    console && console.log && console.log(u);
  }
}
const provider = new InternalProviderImpl();
var InternalLogger = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get InternalLogLevel() {
    return InternalLogLevel;
  },
  getInternalLogger,
  INTERNAL_LOGGING_SETTINGS
}), LogLevel$1;
(function(a) {
  a[a.Trace = 0] = "Trace", a[a.Debug = 1] = "Debug", a[a.Info = 2] = "Info", a[a.Warn = 3] = "Warn", a[a.Error = 4] = "Error", a[a.Fatal = 5] = "Fatal";
})(LogLevel$1 || (LogLevel$1 = {}));
(function(a) {
  function u(c) {
    switch (c.toLowerCase()) {
      case "trace":
        return a.Trace;
      case "debug":
        return a.Debug;
      case "info":
        return a.Info;
      case "warn":
        return a.Warn;
      case "error":
        return a.Error;
      case "fatal":
        return a.Fatal;
      default:
        return;
    }
  }
  a.toLogLevel = u;
})(LogLevel$1 || (LogLevel$1 = {}));
class CoreLoggerImpl {
  constructor(u) {
    this._runtime = u;
  }
  get id() {
    return this._runtime.id;
  }
  get logLevel() {
    return this._runtime.level;
  }
  get runtimeSettings() {
    return Object.assign({}, this._runtime);
  }
  set runtimeSettings(u) {
    this._runtime = u;
  }
  trace(u, ...c) {
    this.logMessage(LogLevel$1.Trace, u, c);
  }
  debug(u, ...c) {
    this.logMessage(LogLevel$1.Debug, u, c);
  }
  info(u, ...c) {
    this.logMessage(LogLevel$1.Info, u, c);
  }
  warn(u, ...c) {
    this.logMessage(LogLevel$1.Warn, u, c);
  }
  error(u, ...c) {
    this.logMessage(LogLevel$1.Error, u, c);
  }
  fatal(u, ...c) {
    this.logMessage(LogLevel$1.Fatal, u, c);
  }
  logMessage(u, c, l) {
    if (this._runtime.level > u)
      return;
    const v = Date.now(), S = typeof c == "string" ? c : c(), g = CoreLoggerImpl.getErrorAndArgs(l);
    switch (this._runtime.channel.type) {
      case "RawLogChannel":
        this._runtime.channel.write({
          message: S,
          exception: g.error,
          args: g.args,
          timeInMillis: v,
          level: u,
          logNames: this._runtime.name
        }, this._runtime.argumentFormatter);
        return;
      case "LogChannel":
        this._runtime.channel.write(this.createLogMessage(S, u, g, v));
        break;
    }
  }
  formatArgValue(u) {
    try {
      return this._runtime.argumentFormatter(u);
    } catch {
      return `>>ARG CONVERT FAILED: '${u !== void 0 ? u.toString() : "undefined"}'<<`;
    }
  }
  createLogMessage(u, c, l, v) {
    let S;
    const g = l.error, E = l.args;
    g && (S = `${g.name}: ${g.message}`, g.stack && (S += `@
${g.stack}`));
    const _ = this._runtime.dateFormatter(v);
    let k = LogLevel$1[c].toUpperCase();
    k.length < 5 && (k += " ");
    const L = typeof this._runtime.name == "string" ? this._runtime.name : this._runtime.name.join(", "), M = typeof E < "u" && E.length > 0 ? " [" + E.map((J) => this.formatArgValue(J)).join(", ") + "]" : "";
    return {
      message: _ + " " + k + " [" + L + "] " + u + M,
      error: S
    };
  }
  static getErrorAndArgs(u) {
    if (u.length === 0)
      return {};
    let c, l;
    const v = u[0];
    if (v instanceof Error)
      return c = v, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l };
    if (typeof v == "function") {
      const S = v();
      return S instanceof Error ? (c = S, l = u.length > 1 ? u.slice(1) : void 0, { error: c, args: l }) : u.length === 1 ? Array.isArray(S) ? { args: S.length > 0 ? S : void 0 } : { args: S } : Array.isArray(S) ? { args: [...S, ...u.slice(1)] } : { args: [S, ...u.slice(1)] };
    }
    return { args: u };
  }
}
function padStart(a, u, c = " ") {
  return padInternal(a, u, "start", c);
}
function padEnd(a, u, c = " ") {
  return padInternal(a, u, "end", c);
}
function maxLengthStringValueInArray(a) {
  return a.map((u) => u.length).reduce((u, c) => c > u ? c : u, 0);
}
function padInternal(a, u, c, l = " ") {
  if (u <= a.length)
    return a;
  if (l.length > 1)
    throw new Error(`Fill char must be one char exactly, it is: ${l.length}`);
  const v = u - a.length;
  let S = "";
  for (let g = 0; g < v; g++)
    S += l;
  return c === "start" ? S + a : a + S;
}
function formatArgument(a) {
  return a === void 0 ? "undefined" : JSON.stringify(a);
}
function formatDate(a) {
  const u = new Date(a), c = u.getFullYear(), l = padStart((u.getMonth() + 1).toString(), 2, "0"), v = padStart(u.getDate().toString(), 2, "0"), S = padStart(u.getHours().toString(), 2, "0"), g = padStart(u.getMinutes().toString(), 2, "0"), E = padStart(u.getSeconds().toString(), 2, "0"), _ = padStart(u.getMilliseconds().toString(), 2, "0");
  return `${c}-${l}-${v} ${S}:${g}:${E},${_}`;
}
class ConsoleLogChannel {
  constructor() {
    this.type = "LogChannel";
  }
  write(u) {
    console && console.log && console.log(u.message + (u.error ? `
${u.error}` : ""));
  }
}
var DefaultChannels;
(function(a) {
  function u() {
    return new ConsoleLogChannel();
  }
  a.createConsoleChannel = u;
})(DefaultChannels || (DefaultChannels = {}));
class LogProviderImpl {
  constructor(u, c) {
    this._log = getInternalLogger("core.impl.LogProviderImpl"), this._name = u, this._settings = c, this._loggers = new EnhancedMap(), this._idToKeyMap = new EnhancedMap(), this._globalRuntimeSettings = { level: c.level, channel: c.channel }, this._nextLoggerId = 1, this._log.trace(() => `Created LogProviderImpl with settings: ${JSON.stringify(this._settings)}`);
  }
  get runtimeSettings() {
    return Object.assign(Object.assign({}, this._settings), { level: this._globalRuntimeSettings.level, channel: this._globalRuntimeSettings.channel });
  }
  getLogger(u) {
    return this.getOrCreateLogger(u);
  }
  updateLoggerRuntime(u, c) {
    this._log.debug(() => `Updating logger ${u.id} runtime settings using: '${JSON.stringify(c)}'`);
    const l = this._idToKeyMap.get(u.id);
    return l === void 0 ? (this._log.warn(() => `Cannot update logger with id: ${u.id}, it was not found.`), !1) : (this._loggers.computeIfPresent(l, (v, S) => (S.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(S.runtimeSettings, c), S)), !0);
  }
  updateRuntimeSettings(u) {
    this._log.debug(() => `Updating global runtime settings and updating existing loggers runtime settings using: '${JSON.stringify(u)}'`), this._globalRuntimeSettings = {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: u.level !== void 0 ? u.level : this._globalRuntimeSettings.level,
      channel: u.channel !== void 0 ? u.channel : this._globalRuntimeSettings.channel
    }, this._loggers.forEach((c) => c.runtimeSettings = LogProviderImpl.mergeRuntimeSettingsIntoLogRuntime(c.runtimeSettings, u));
  }
  /**
   * Removes all state and loggers, it reverts back to as it was after initial construction.
   */
  clear() {
    this._loggers.clear(), this._idToKeyMap.clear(), this._globalRuntimeSettings = Object.assign({}, this._settings), this._nextLoggerId = 1;
  }
  getOrCreateLogger(u) {
    const c = LogProviderImpl.createKey(u), l = this._loggers.computeIfAbsent(c, () => {
      const v = {
        level: this._globalRuntimeSettings.level,
        channel: this._globalRuntimeSettings.channel,
        id: this.nextLoggerId(),
        name: u,
        argumentFormatter: this._settings.argumentFormatter,
        dateFormatter: this._settings.dateFormatter
      };
      return new CoreLoggerImpl(v);
    });
    return this._idToKeyMap.computeIfAbsent(l.id, () => c), l;
  }
  nextLoggerId() {
    const u = this._name + "_" + this._nextLoggerId;
    return this._nextLoggerId++, u;
  }
  static mergeRuntimeSettingsIntoLogRuntime(u, c) {
    return Object.assign(Object.assign({}, u), {
      /* It's unclear, but not checking explicitly on undefined here makes the test fail, it makes no sense as level is a number | undefined essentially. */
      level: c.level !== void 0 ? c.level : u.level,
      channel: c.channel !== void 0 ? c.channel : u.channel
    });
  }
  static createKey(u) {
    return typeof u == "string" ? u : u.join(",");
  }
}
function createLogProvider(a, u) {
  return new LogProviderImpl(a, u);
}
var index$3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  EnhancedMap,
  padStart,
  padEnd,
  maxLengthStringValueInArray
});
class CategoryImpl {
  constructor(u, c, l, v) {
    this._children = [], this._logger = u, this._name = c, this._parent = l, this._fnGetOrCreateChildCategory = v;
  }
  get name() {
    return this._name;
  }
  get parent() {
    return this._parent;
  }
  get path() {
    const u = [];
    let c = this;
    for (; c !== void 0; )
      u.push(c.name), c = c.parent;
    return u.reverse();
  }
  get children() {
    return [...this._children];
  }
  addChild(u) {
    if (u.parent !== this)
      throw new Error(`Cannot add child '${u.name}', expected parent '${this._name} but got ${u.parent ? u.parent.name : "undefined"}'`);
    this._children.push(u);
  }
  getChildCategory(u) {
    const c = this._children.find((l) => l.name === u);
    return c !== void 0 ? c : this._fnGetOrCreateChildCategory(u, this);
  }
  get id() {
    return this._logger.id;
  }
  get logLevel() {
    return this._logger.logLevel;
  }
  get runtimeSettings() {
    return this._logger.runtimeSettings;
  }
  get logger() {
    return this._logger;
  }
  trace(u, ...c) {
    this._logger.trace(u, ...c);
  }
  debug(u, ...c) {
    this._logger.debug(u, ...c);
  }
  info(u, ...c) {
    this._logger.info(u, ...c);
  }
  warn(u, ...c) {
    this._logger.warn(u, ...c);
  }
  error(u, ...c) {
    this._logger.error(u, ...c);
  }
  fatal(u, ...c) {
    this._logger.fatal(u, ...c);
  }
}
const CATEGORY_PATH_SEPARATOR = "#";
class CategoryProviderImpl {
  constructor(u, c) {
    this._name = u, this._initialConfig = c, this._categoryStorage = new CategoryStorage(u, c);
  }
  get name() {
    return this._name;
  }
  get config() {
    return this._initialConfig;
  }
  get runtimeConfig() {
    return this._categoryStorage.getCurrentRuntimeConfig();
  }
  getCategory(u, c) {
    return this._categoryStorage.getOrCreateCategory(u, c);
  }
  updateRuntimeSettingsCategory(u, c) {
    this._categoryStorage.updateRuntimeSettingsCategory(u, c);
  }
  updateRuntimeSettings(u) {
    this._categoryStorage.updateRuntimeSettings(u);
  }
  /** Returns all currently registered categories */
  getRegisteredCategories() {
    return this._categoryStorage.getRegisteredCategories();
  }
  /** Get a category by path, note that paths must be separated by #, e.g. root#child1#child1_1 */
  getCategoryByPath(u) {
    return this._categoryStorage.getCategoryByPath(u);
  }
}
class CategoryStorage {
  constructor(u, c) {
    this._categoriesById = /* @__PURE__ */ new Map(), this._categoriesByPath = /* @__PURE__ */ new Map(), this._categoryProviderName = u, this._allowSameCategoryName = c.allowSameCategoryName, this._logProvider = createLogProvider(u, Object.assign({}, c)), this.getOrCreateCategory = this.getOrCreateCategory.bind(this);
  }
  getOrCreateCategory(u, c) {
    if (u.indexOf(CATEGORY_PATH_SEPARATOR) !== -1)
      throw new Error(`Cannot create category '${u}', name cannot contain a '${CATEGORY_PATH_SEPARATOR}'.`);
    const l = c !== void 0 ? this.getParentCategory(c) : void 0;
    return l === void 0 ? this.getOrCreateRootCategory(u) : this.getOrCreateChildCategory(u, l);
  }
  updateRuntimeSettingsCategory(u, c) {
    if (!u.id.startsWith(this._categoryProviderName))
      throw new Error(`Category '${u.name}' with LogId '${u.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    const l = this._categoriesById.get(u.id);
    l !== void 0 && (this._logProvider.updateLoggerRuntime(l.logger, { level: c.level }), !(c.disableRecursion !== void 0 && c.disableRecursion) && l.children.forEach((v) => this.updateRuntimeSettingsCategory(v, c)));
  }
  updateRuntimeSettings(u) {
    this._logProvider.updateRuntimeSettings(u);
  }
  getCurrentRuntimeConfig() {
    return Object.assign(Object.assign({}, this._logProvider.runtimeSettings), { allowSameCategoryName: this._allowSameCategoryName });
  }
  /** Returns all currently registered categories */
  getRegisteredCategories() {
    return [...this._categoriesById.values()];
  }
  /** Get a category by path, note that paths must be separated by #, e.g. root#child1#child1_1 */
  getCategoryByPath(u) {
    return this._categoriesByPath.get(u);
  }
  getParentCategory(u) {
    let c;
    if (CategoryStorage.isLogId(u)) {
      if (c = this._categoriesById.get(u), c === void 0)
        throw new Error(`Parent category was not found by LogId '${u}'. Are you sure you passed in the correct argument?`);
    } else if (c = this._categoriesById.get(u.id), c === void 0)
      throw new Error(`Parent category '${u.name}' was not found by it's LogId '${u.id}'. Are you sure you passed in the correct parent category?`);
    return c;
  }
  getOrCreateRootCategory(u) {
    const c = this._categoriesByPath.get(u);
    if (c) {
      if (!this._allowSameCategoryName)
        throw new Error(`Category '${u} already exists, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      return c;
    }
    const l = this._logProvider.getLogger(u), v = new CategoryImpl(l, u, void 0, this.getOrCreateCategory);
    return this._categoriesById.set(v.id, v), this._categoriesByPath.set(u, v), v;
  }
  getOrCreateChildCategory(u, c) {
    if (!c.id.startsWith(this._categoryProviderName))
      throw new Error(`Parent category '${c.name}' with LogId '${c.id}' is from a different CategoryProvider, cannot mix categories between providers.`);
    const l = [...c.path, u].join(CATEGORY_PATH_SEPARATOR), v = this._categoriesByPath.get(l);
    if (v) {
      if (!this._allowSameCategoryName)
        throw new Error(`Child category '${u} already exists for parent category ${c.name}, config flag allowSameCategoryName=false - therefore matching version 1 behavior (hence this Error)`);
      return v;
    }
    const S = this._logProvider.getLogger(l);
    this._logProvider.updateLoggerRuntime(S, {
      level: c.logger.runtimeSettings.level,
      channel: c.logger.runtimeSettings.channel
    });
    const g = new CategoryImpl(S, u, c, this.getOrCreateCategory);
    return this._categoriesById.set(g.id, g), this._categoriesByPath.set(g.path.join(CATEGORY_PATH_SEPARATOR), g), c.addChild(g), g;
  }
  static isLogId(u) {
    return typeof u == "string";
  }
}
class CategoryControlProviderImpl {
  constructor(u, c) {
    this._provider = u, this._messageChannel = c, this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(u);
  }
  get name() {
    return this._provider.name;
  }
  /**
   * Shows current settings.
   */
  showSettings() {
    let u = `Available categories (CategoryProvider '${this._provider.name}'):
`;
    const c = this.createCategoryInfoHierarchy(), l = c.size.toString().length, v = index$3.maxLengthStringValueInArray([...c.values()].map((g) => g.category.name + " ".repeat(g.depth))), S = [...c.values()].map((g, E) => CategoryControlProviderImpl.createSettingLineCategory(g, E, l, v));
    u += S.join(`
`) + (S.length > 0 ? `
` : ""), this._messageChannel(u);
  }
  help() {
    const u = `You can use the following commands (CategoryProvider ${this._provider.name}):
  showSettings()
    Shows the current configuration settings.
  update(level: CategoryControlProviderLogLevel, categoryId?: number | string, noRecurse?: boolean)
    Change the log level for a category (by default recursively).
      @param level      The log level to set - must be one of 'trace', 'debug', 'info', 'warn', 'error' or 'fatal'
      @param categoryId The category id or path of a category (e.g. root#child1) to update. Use showSettings() for id and/or name.
                        When omitted, it applies the level to all categories recursively.
  reset()
    Resets the log levels of the config groups back to when this control provider was created.
  save()
    Saves the current log levels for all categories of this provider. Use restore() to load last saved state.
  restore()
    Restore stored saved state, if any. Log levels will be set according to the saved state.
  help()
    Shows this help.
`;
    this._messageChannel(u);
  }
  reset() {
    const u = new Map(this._provider.getRegisteredCategories().map((c) => [c.id, c]));
    this._originalLogLevels.forEach((c, l) => {
      const v = u.get(l);
      v !== void 0 && this._provider.updateRuntimeSettingsCategory(v, { level: c, disableRecursion: !0 }), u.delete(l);
    }), u.forEach((c) => {
      c.parent !== void 0 && this._provider.updateRuntimeSettingsCategory(c, { level: c.parent.logLevel, disableRecursion: !0 });
    }), this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider), this._messageChannel("Successfully reset log levels back to original state (from when this CategoryControlProvider was created).");
  }
  save() {
    if (!localStorage) {
      this._messageChannel("Cannot save state, localStorage is not available.");
      return;
    }
    const u = this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).map((l) => CategoryControlProviderImpl.createCategorySaveData(l)), c = {
      name: this._provider.name,
      rootCategories: u
    };
    localStorage.setItem(this.createKey(), JSON.stringify(c)), this._messageChannel(`Successfully saved state for CategoryControlProvider '${this._provider.name}'.`);
  }
  restore(u) {
    const c = u !== void 0 ? u : !0;
    if (!localStorage) {
      c && this._messageChannel(`Will not attempt to restore state for CategoryControlProvider '${this._provider.name}', localStorage is not available.`);
      return;
    }
    const l = this.createKey(), v = localStorage.getItem(l);
    if (v === null) {
      c && this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', no data available.`);
      return;
    }
    try {
      const S = JSON.parse(v);
      if (this._provider.name !== S.name) {
        c && this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not for provider - found name '${S.name}'.`);
        return;
      }
      this.restoreBySaveData(S, c), this._messageChannel(`Successfully restored state for CategoryControlProvider '${this._provider.name}'`), this._originalLogLevels = CategoryControlProviderImpl.loadCurrentGroupLogLevels(this._provider);
    } catch {
      localStorage.removeItem(l), this._messageChannel(`Cannot restore state for CategoryControlProvider '${this._provider.name}', data is not valid. Invalid data removed from localStorage.`);
    }
  }
  update(u, c, l) {
    typeof c > "u" ? this.updateAll(u) : typeof c == "number" ? this.updateByIndex(u, c, l !== void 0 ? l : !1) : this.updateByPath(u, c, l !== void 0 ? l : !1);
  }
  updateAll(u) {
    const c = LogLevel$1.toLogLevel(u);
    this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).forEach((l) => this._provider.updateRuntimeSettingsCategory(l, { level: c })), this._messageChannel(`Updated all categories to use log level '${u.toLowerCase()}'`);
  }
  updateByPath(u, c, l) {
    const v = this._provider.getCategoryByPath(c);
    if (v === void 0) {
      this._messageChannel(`Failed to find a provider by path '${c}', please make sure to separate the parts by a ${CATEGORY_PATH_SEPARATOR}.`);
      return;
    }
    this._provider.updateRuntimeSettingsCategory(v, { level: LogLevel$1.toLogLevel(u), disableRecursion: l }), this._messageChannel(`Successfully updated category '${v.name}' with path '${c}' to log level '${u.toLowerCase()}'${l ? "" : " and recursively applied to children (if any)"}.`);
  }
  updateByIndex(u, c, l) {
    if (c < 0) {
      this._messageChannel(`Cannot update category by index '${c}', it is negative.`);
      return;
    }
    const v = this.createCategoryInfoHierarchy();
    if (c >= v.size) {
      this._messageChannel(`Cannot update category by index '${c}', it is outside of the range of available categories, use showSettings() to see the indices.`);
      return;
    }
    const S = [...v.values()][c].category;
    this._provider.updateRuntimeSettingsCategory(S, { level: LogLevel$1.toLogLevel(u), disableRecursion: l }), this._messageChannel(`Successfully updated category '${S.name}' by index '${c}' to log level '${u.toLowerCase()}'${l ? "" : " and recursively applied to children (if any)"}.`);
  }
  restoreBySaveData(u, c) {
    const l = (v, S) => {
      const g = S.length > 0 ? S + CATEGORY_PATH_SEPARATOR + v.name : v.name, E = this._provider.getCategoryByPath(g);
      if (E !== void 0) {
        const _ = LogLevel$1.toLogLevel(v.level);
        _ !== void 0 ? this._provider.updateRuntimeSettingsCategory(E, { level: _, disableRecursion: !0 }) : c && this._messageChannel(`CategoryControlProvider '${this._provider.name}' - cannot restore log level for category path '${g}', log level is invalid.`);
        for (const k of v.children)
          l(k, g);
      } else
        c && this._messageChannel(`CategoryControlProvider '${this._provider.name}' - failed to find a Category by path '${g}', will not restore category (and children)`);
    };
    for (const v of u.rootCategories)
      l(v, "");
  }
  createKey() {
    return `CategoryProvider-${this._provider.name}`;
  }
  createCategoryInfoHierarchy() {
    const u = /* @__PURE__ */ new Map();
    return this._provider.getRegisteredCategories().filter((l) => l.parent === void 0).forEach((l) => CategoryControlProviderImpl.addCategoryInfoHierarchy(l, 0, u)), u;
  }
  static createCategorySaveData(u) {
    return {
      name: u.name,
      level: LogLevel$1[u.logLevel],
      children: u.children.map((c) => this.createCategorySaveData(c))
    };
  }
  static loadCurrentGroupLogLevels(u) {
    return new Map(u.getRegisteredCategories().map((c) => [c.id, c.logLevel]));
  }
  static createSettingLineCategory(u, c, l, v) {
    const g = " ".repeat(u.depth) + u.category.name;
    return `  [${index$3.padStart(c.toString(), l)}, ${index$3.padEnd(g, v)} (level=${index$3.padEnd(u.logLevel, 5)})]`;
  }
  static addCategoryInfoHierarchy(u, c, l) {
    l.set(u.id, {
      category: u,
      logLevel: LogLevel$1[u.logLevel],
      depth: c
    }), u.children.forEach((v) => this.addCategoryInfoHierarchy(v, c + 1, l));
  }
}
function categoryConfigDebug(a) {
  return `CategoryConfig=level: ${LogLevel$1[a.level].toString()}, allowSameCategoryName=${a.allowSameCategoryName}`;
}
class CategoryProviderService {
  constructor() {
    this._log = InternalLogger.getInternalLogger("category.impl.CategoryProviderService"), this._providers = new index$3.EnhancedMap();
  }
  createLogProvider(u, c) {
    const l = this._providers.compute(u, (v, S) => {
      if (S)
        throw new Error(`CategoryProvider with name '${u}' already exists, cannot create another.`);
      const g = mergeWithDefaults(c);
      return this._log.debug(() => `Creating new CategoryProvider with name '${u}', using config settings '${categoryConfigDebug(g)}'.`), new CategoryProviderImpl(u, g);
    });
    if (l)
      return l;
    throw new Error("No CategoryProvider? This is a bug.");
  }
  getCategoryControl(u) {
    const c = u || ((l) => {
      if (console && console.log)
        console.log(l);
      else
        throw new Error("Cannot use console (it is not present), please specify a custom function to write to.");
    });
    return {
      help: () => c(CategoryProviderService.help()),
      showSettings: () => c(this.showSettings()),
      getProvider: (l) => this.getCategoryControlProviderByIdOrName(l, c)
    };
  }
  clear() {
    this._providers.clear();
  }
  /* Functions for CategoryControl follow */
  showSettings() {
    let u = `Available CategoryProviders:
`;
    const c = this._providers.size.toString().length, l = index$3.maxLengthStringValueInArray([...this._providers.keys()]), v = [...this._providers.entries()].map((S, g) => {
      const E = S[0];
      return `  [${index$3.padStart(g.toString(), c)}, ${index$3.padEnd(E, l)}]`;
    });
    return u += v.join(`
`) + (v.length > 0 ? `
` : ""), u;
  }
  getCategoryControlProviderByIdOrName(u, c) {
    if (typeof u == "string") {
      const v = this._providers.get(u);
      if (v === void 0)
        throw new Error(`Provider with name '${u}' does not exist.`);
      return new CategoryControlProviderImpl(v, c);
    }
    const l = [...this._providers.values()];
    if (u < 0 || u >= l.length)
      throw new Error(`Provider with index '${u}' does not exist (outside of range).`);
    return new CategoryControlProviderImpl(l[u], c);
  }
  static help() {
    return `You can use the following commands:
  showSettings()
    Shows the current configuration settings.
  getProvider: (id: number | string): CategoryControlProvider
    Get access to a CategoryControlProvider to change log levels.
      @param id The id (use showSettings to see) or name of the provider
  help()
    Shows this help.
`;
  }
}
const CATEGORY_PROVIDER_SERVICE = new CategoryProviderService(), CATEGORY_LOG_CONTROL = (a) => CATEGORY_PROVIDER_SERVICE.getCategoryControl(a);
function mergeWithDefaults(a) {
  const u = {
    channel: DefaultChannels.createConsoleChannel(),
    allowSameCategoryName: !0,
    level: LogLevel$1.Error,
    dateFormatter: formatDate,
    argumentFormatter: formatArgument
  };
  return a ? {
    channel: a.channel ? a.channel : u.channel,
    allowSameCategoryName: a.allowSameCategoryName !== void 0 ? a.allowSameCategoryName : u.allowSameCategoryName,
    level: a.level ? a.level : u.level,
    dateFormatter: a.dateFormatter ? a.dateFormatter : u.dateFormatter,
    argumentFormatter: a.argumentFormatter ? a.argumentFormatter : u.argumentFormatter
  } : u;
}
var CategoryProvider;
(function(a) {
  function u(l, v) {
    return CATEGORY_PROVIDER_SERVICE.createLogProvider(l, v);
  }
  a.createProvider = u;
  function c() {
    CATEGORY_PROVIDER_SERVICE.clear();
  }
  a.clear = c;
})(CategoryProvider || (CategoryProvider = {}));
const typescriptLoggingCategory_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CATEGORY_LOG_CONTROL,
  get CategoryProvider() {
    return CategoryProvider;
  }
}, Symbol.toStringTag, { value: "Module" })), require$$1 = /* @__PURE__ */ getAugmentedNamespace(typescriptLoggingCategory_esm);
Object.defineProperty(logger, "__esModule", { value: !0 });
logger.logger = void 0;
const typescript_logging_1 = require$$2$1, typescript_logging_category_style_1 = require$$1;
logger.logger = typescript_logging_category_style_1.CategoryProvider.createProvider("ApiStream", { allowSameCategoryName: !0, level: typescript_logging_1.LogLevel.Warn });
var version$3 = "1.0.25", __createBinding$3 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar$3 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$3(u, a, c);
  return __setModuleDefault$3(u, a), u;
}, __importDefault$d = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(api$2, "__esModule", { value: !0 });
api$2.ApiClient = void 0;
const NiceGrpc$1 = __importStar$3(lib$1), abort_controller_x_1 = require$$1$1, detect_node_1 = __importDefault$d(browser$2), NodeTransport = __importStar$3(require$$0$1), logger_1 = logger, clientVersion$1 = version$3;
class ApiClient {
  constructor(u, c, l, v, S, g) {
    this.sessionId = u, this.sdkVersion = l, this.version = clientVersion$1, this.apiLogCallback = S, this.eventLogCallback = g, this.log = logger_1.logger.getCategory(v), this.channel = NiceGrpc$1.createChannel(c, detect_node_1.default ? NodeTransport.NodeHttpTransport() : void 0), this.clientFactory = NiceGrpc$1.createClientFactory().use(this.logMiddleware.bind(this));
  }
  async *logMiddleware(u, c) {
    const { path: l } = u.method;
    try {
      const v = yield* u.next(u.request, c);
      if (this.log.debug(`-> ${l}: ok`), this.log.trace(`${JSON.stringify(u.request)} -> ${l}: ${JSON.stringify(v)}`), this.apiLogCallback) {
        let S = l.split("/"), g = S[1].split("."), E = g[g.length - 1], _ = g[g.length - 2], k = g[g.length - 3], L = S[2];
        this.apiLogCallback(k, E, L, u.request, v);
      }
      return v;
    } catch (v) {
      throw this.log.trace(`${JSON.stringify(u.request)} -> ${l}`), v instanceof NiceGrpc$1.ClientError ? this.log.warn(`-> ${l}: error: ${NiceGrpc$1.Status[v.code]}: ${v.details}`) : (0, abort_controller_x_1.isAbortError)(v) ? this.log.warn(`-> ${l}: cancel`) : this.log.warn(`-> ${l}: error: ${v == null ? void 0 : v.stack}`), v;
    }
  }
  setAccessToken(u) {
    (this.accessToken == null || this.accessToken != u) && (this.log.debug("access token refreshed"), this.accessToken = u, this.setup());
  }
  makeGrpcMetadata() {
    let u = NiceGrpc$1.Metadata({
      Authorization: `Bearer ${this.accessToken}`,
      Version: this.version,
      SessionId: this.sessionId
    });
    return this.sdkVersion != null && u.set("SdkVersion", this.sdkVersion), u;
  }
  setup() {
    let u = {
      metadata: this.makeGrpcMetadata()
    };
    this._setup(u);
  }
  _setup(u) {
  }
}
api$2.ApiClient = ApiClient;
var decorator = {};
Object.defineProperty(decorator, "__esModule", { value: !0 });
decorator.RequiresSdkAuthentication = void 0;
function RequiresSdkAuthentication() {
  return function(a, u) {
    const c = Symbol(u);
    Object.defineProperty(a, u, {
      get: function() {
        if (!this[c])
          throw new Error("Please authenticate ApiStream by calling apiStream.load( accessToken )");
        return this[c];
      },
      set: function(l) {
        this[c] = l;
      }
    });
  };
}
decorator.RequiresSdkAuthentication = RequiresSdkAuthentication;
var __createBinding$2 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __decorate = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(a, u, c, l) {
  var v = arguments.length, S = v < 3 ? u : l === null ? l = Object.getOwnPropertyDescriptor(u, c) : l, g;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    S = Reflect.decorate(a, u, c, l);
  else
    for (var E = a.length - 1; E >= 0; E--)
      (g = a[E]) && (S = (v < 3 ? g(S) : v > 3 ? g(u, c, S) : g(u, c)) || S);
  return v > 3 && S && Object.defineProperty(u, c, S), S;
}, __importStar$2 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$2(u, a, c);
  return __setModuleDefault$2(u, a), u;
}, __metadata = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function(a, u) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(a, u);
};
Object.defineProperty(layoutapi, "__esModule", { value: !0 });
layoutapi.LayoutApi = void 0;
__importStar$2(lib$1);
const LayoutApiModel = __importStar$2(dist$2), api_1$1 = api$2, decorator_1 = decorator, LOG_CATEGORY$1 = "LayoutApi";
class LayoutApi extends api_1$1.ApiClient {
  constructor(u, c, l, v, S) {
    super(u, l, v, LOG_CATEGORY$1, S), this.handlers = {}, this.eventApi = c, this.eventApi.on("event", { name: `${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: !0 }, (g) => {
      var E;
      const [, _] = g.name.split(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:`), [k, L] = _.split(":"), M = g.payload;
      for (const $ of (E = this.handlers[k]) !== null && E !== void 0 ? E : [])
        $(Object.values(M).find((J) => !!J), L);
    });
  }
  _setup(u) {
    this.layer = this.clientFactory.create(LayoutApiModel.LayerServiceDefinition, this.channel, {
      "*": u
    }), this.layout = this.clientFactory.create(LayoutApiModel.LayoutServiceDefinition, this.channel, {
      "*": u
    });
  }
  /**
   * Subscribe to all events for a given layout.
   *
   * @param layoutId - the id of the layout to which you want to subscribe to layout events
   */
  async subscribeToLayout(u) {
    await Promise.all([
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId: u } }),
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId: u } })
    ]);
  }
  /**
   * Unsubscribe from all events for a given layout.
   *
   * @param layoutId - the id of the layout to which you want to unsubscribe to layout events
   */
  async unsubscribeFromLayout(u) {
    await Promise.all([
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { layoutId: u } }),
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { layoutId: u } })
    ]);
  }
  /**
   * Subscribe to all events for layouts in a project.
   *
   * @param collectionId - the id of the collection the layouts are in.
   * @param projectId - the id of the project the layouts are in.
   */
  async subscribeToLayoutsInProject(u, c) {
    await Promise.all([
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId: u, projectId: c } }),
      this.eventApi.subscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId: u, projectId: c } })
    ]);
  }
  /**
   * Unsubscribe from all events for layouts in a project.
   *
   * @param collectionId - the id of the collection the layouts are in.
   * @param projectId - the id of the project the layouts are in.
   */
  async unsubscribeFromLayoutsInProject(u, c) {
    await Promise.all([
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYER}:*`, { target: { collectionId: u, projectId: c } }),
      this.eventApi.unsubscribe(`${LayoutApi.LAYOUTAPI_EVENT_PREFIX}:${LayoutApiModel.EventType.EVENT_TYPE_LAYOUT}:*`, { target: { collectionId: u, projectId: c } })
    ]);
  }
  /**
   * Register an event handler
   *
   * @param type Type of event
   * @param handler
   */
  on(u, c) {
    var l;
    this.handlers[u] = (l = this.handlers[u]) !== null && l !== void 0 ? l : [], this.handlers[u].push(c);
  }
  /**
   * Unregister an event handler
   *
   * @param type Type of event
   * @param handler
   */
  off(u, c) {
    this.handlers[u] = this.handlers[u].filter((l) => l !== c);
  }
}
LayoutApi.LAYOUTAPI_EVENT_PREFIX = "apistream:layout";
__decorate([
  (0, decorator_1.RequiresSdkAuthentication)(),
  __metadata("design:type", Object)
], LayoutApi.prototype, "layout", void 0);
__decorate([
  (0, decorator_1.RequiresSdkAuthentication)(),
  __metadata("design:type", Object)
], LayoutApi.prototype, "layer", void 0);
layoutapi.LayoutApi = LayoutApi;
var liveapi = {}, api$1 = {}, httpbody = {}, any = {}, __importDefault$c = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(any, "__esModule", { value: !0 });
any.Any = any.protobufPackage = void 0;
const minimal_1$5 = __importDefault$c(minimal);
any.protobufPackage = "google.protobuf";
function createBaseAny() {
  return { typeUrl: "", value: new Uint8Array() };
}
any.Any = {
  encode(a, u = minimal_1$5.default.Writer.create()) {
    return a.typeUrl !== "" && u.uint32(10).string(a.typeUrl), a.value.length !== 0 && u.uint32(18).bytes(a.value), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$5.default.Reader ? a : new minimal_1$5.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseAny();
    for (; c.pos < l; ) {
      const S = c.uint32();
      switch (S >>> 3) {
        case 1:
          v.typeUrl = c.string();
          break;
        case 2:
          v.value = c.bytes();
          break;
        default:
          c.skipType(S & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      typeUrl: isSet$4(a.typeUrl) ? String(a.typeUrl) : "",
      value: isSet$4(a.value) ? bytesFromBase64$1(a.value) : new Uint8Array()
    };
  },
  toJSON(a) {
    const u = {};
    return a.typeUrl !== void 0 && (u.typeUrl = a.typeUrl), a.value !== void 0 && (u.value = base64FromBytes$1(a.value !== void 0 ? a.value : new Uint8Array())), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseAny();
    return l.typeUrl = (u = a.typeUrl) !== null && u !== void 0 ? u : "", l.value = (c = a.value) !== null && c !== void 0 ? c : new Uint8Array(), l;
  }
};
var globalThis$5 = (() => {
  if (typeof globalThis$5 < "u")
    return globalThis$5;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function bytesFromBase64$1(a) {
  if (globalThis$5.Buffer)
    return Uint8Array.from(globalThis$5.Buffer.from(a, "base64"));
  {
    const u = globalThis$5.atob(a), c = new Uint8Array(u.length);
    for (let l = 0; l < u.length; ++l)
      c[l] = u.charCodeAt(l);
    return c;
  }
}
function base64FromBytes$1(a) {
  if (globalThis$5.Buffer)
    return globalThis$5.Buffer.from(a).toString("base64");
  {
    const u = [];
    return a.forEach((c) => {
      u.push(String.fromCharCode(c));
    }), globalThis$5.btoa(u.join(""));
  }
}
function isSet$4(a) {
  return a != null;
}
var __importDefault$b = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(httpbody, "__esModule", { value: !0 });
httpbody.HttpBody = httpbody.protobufPackage = void 0;
const minimal_1$4 = __importDefault$b(minimal), any_1 = any;
httpbody.protobufPackage = "google.api";
function createBaseHttpBody() {
  return { contentType: "", data: new Uint8Array(), extensions: [] };
}
httpbody.HttpBody = {
  encode(a, u = minimal_1$4.default.Writer.create()) {
    a.contentType !== "" && u.uint32(10).string(a.contentType), a.data.length !== 0 && u.uint32(18).bytes(a.data);
    for (const c of a.extensions)
      any_1.Any.encode(c, u.uint32(26).fork()).ldelim();
    return u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$4.default.Reader ? a : new minimal_1$4.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseHttpBody();
    for (; c.pos < l; ) {
      const S = c.uint32();
      switch (S >>> 3) {
        case 1:
          v.contentType = c.string();
          break;
        case 2:
          v.data = c.bytes();
          break;
        case 3:
          v.extensions.push(any_1.Any.decode(c, c.uint32()));
          break;
        default:
          c.skipType(S & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      contentType: isSet$3(a.contentType) ? String(a.contentType) : "",
      data: isSet$3(a.data) ? bytesFromBase64(a.data) : new Uint8Array(),
      extensions: Array.isArray(a == null ? void 0 : a.extensions) ? a.extensions.map((u) => any_1.Any.fromJSON(u)) : []
    };
  },
  toJSON(a) {
    const u = {};
    return a.contentType !== void 0 && (u.contentType = a.contentType), a.data !== void 0 && (u.data = base64FromBytes(a.data !== void 0 ? a.data : new Uint8Array())), a.extensions ? u.extensions = a.extensions.map((c) => c ? any_1.Any.toJSON(c) : void 0) : u.extensions = [], u;
  },
  fromPartial(a) {
    var u, c, l;
    const v = createBaseHttpBody();
    return v.contentType = (u = a.contentType) !== null && u !== void 0 ? u : "", v.data = (c = a.data) !== null && c !== void 0 ? c : new Uint8Array(), v.extensions = ((l = a.extensions) === null || l === void 0 ? void 0 : l.map((S) => any_1.Any.fromPartial(S))) || [], v;
  }
};
var globalThis$4 = (() => {
  if (typeof globalThis$4 < "u")
    return globalThis$4;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function bytesFromBase64(a) {
  if (globalThis$4.Buffer)
    return Uint8Array.from(globalThis$4.Buffer.from(a, "base64"));
  {
    const u = globalThis$4.atob(a), c = new Uint8Array(u.length);
    for (let l = 0; l < u.length; ++l)
      c[l] = u.charCodeAt(l);
    return c;
  }
}
function base64FromBytes(a) {
  if (globalThis$4.Buffer)
    return globalThis$4.Buffer.from(a).toString("base64");
  {
    const u = [];
    return a.forEach((c) => {
      u.push(String.fromCharCode(c));
    }), globalThis$4.btoa(u.join(""));
  }
}
function isSet$3(a) {
  return a != null;
}
var field_mask = {}, __importDefault$a = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(field_mask, "__esModule", { value: !0 });
field_mask.FieldMask = field_mask.protobufPackage = void 0;
const minimal_1$3 = __importDefault$a(minimal);
field_mask.protobufPackage = "google.protobuf";
function createBaseFieldMask() {
  return { paths: [] };
}
field_mask.FieldMask = {
  encode(a, u = minimal_1$3.default.Writer.create()) {
    for (const c of a.paths)
      u.uint32(10).string(c);
    return u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$3.default.Reader ? a : new minimal_1$3.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseFieldMask();
    for (; c.pos < l; ) {
      const S = c.uint32();
      switch (S >>> 3) {
        case 1:
          v.paths.push(c.string());
          break;
        default:
          c.skipType(S & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      paths: typeof a == "string" ? a.split(",").filter(Boolean) : Array.isArray(a == null ? void 0 : a.paths) ? a.paths.map(String) : []
    };
  },
  toJSON(a) {
    return a.paths.join(",");
  },
  fromPartial(a) {
    var u;
    const c = createBaseFieldMask();
    return c.paths = ((u = a.paths) === null || u === void 0 ? void 0 : u.map((l) => l)) || [], c;
  },
  wrap(a) {
    const u = createBaseFieldMask();
    return u.paths = a, u;
  },
  unwrap(a) {
    return a.paths;
  }
};
var struct$1 = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(V) {
    return V && V.__esModule ? V : { default: V };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const c = u(minimal);
  a.protobufPackage = "google.protobuf";
  var l;
  (function(V) {
    V.NULL_VALUE = "NULL_VALUE";
  })(l = a.NullValue || (a.NullValue = {}));
  function v(V) {
    switch (V) {
      case 0:
      case "NULL_VALUE":
        return l.NULL_VALUE;
      default:
        throw new M.Error("Unrecognized enum value " + V + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = v;
  function S(V) {
    switch (V) {
      case l.NULL_VALUE:
        return "NULL_VALUE";
      default:
        throw new M.Error("Unrecognized enum value " + V + " for enum NullValue");
    }
  }
  a.nullValueToJSON = S;
  function g(V) {
    switch (V) {
      case l.NULL_VALUE:
        return 0;
      default:
        throw new M.Error("Unrecognized enum value " + V + " for enum NullValue");
    }
  }
  a.nullValueToNumber = g;
  function E() {
    return { fields: {} };
  }
  a.Struct = {
    encode(V, q = c.default.Writer.create()) {
      return Object.entries(V.fields).forEach(([G, H]) => {
        H !== void 0 && a.Struct_FieldsEntry.encode({ key: G, value: H }, q.uint32(10).fork()).ldelim();
      }), q;
    },
    decode(V, q) {
      const G = V instanceof c.default.Reader ? V : new c.default.Reader(V);
      let H = q === void 0 ? G.len : G.pos + q;
      const B = E();
      for (; G.pos < H; ) {
        const Y = G.uint32();
        switch (Y >>> 3) {
          case 1:
            const ne = a.Struct_FieldsEntry.decode(G, G.uint32());
            ne.value !== void 0 && (B.fields[ne.key] = ne.value);
            break;
          default:
            G.skipType(Y & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(V) {
      return {
        fields: $(V.fields) ? Object.entries(V.fields).reduce((q, [G, H]) => (q[G] = H, q), {}) : {}
      };
    },
    toJSON(V) {
      const q = {};
      return q.fields = {}, V.fields && Object.entries(V.fields).forEach(([G, H]) => {
        q.fields[G] = H;
      }), q;
    },
    fromPartial(V) {
      var q;
      const G = E();
      return G.fields = Object.entries((q = V.fields) !== null && q !== void 0 ? q : {}).reduce((H, [B, Y]) => (Y !== void 0 && (H[B] = Y), H), {}), G;
    },
    wrap(V) {
      const q = E();
      return V !== void 0 && Object.keys(V).forEach((G) => {
        q.fields[G] = V[G];
      }), q;
    },
    unwrap(V) {
      const q = {};
      return Object.keys(V.fields).forEach((G) => {
        q[G] = V.fields[G];
      }), q;
    }
  };
  function _() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(V, q = c.default.Writer.create()) {
      return V.key !== "" && q.uint32(10).string(V.key), V.value !== void 0 && a.Value.encode(a.Value.wrap(V.value), q.uint32(18).fork()).ldelim(), q;
    },
    decode(V, q) {
      const G = V instanceof c.default.Reader ? V : new c.default.Reader(V);
      let H = q === void 0 ? G.len : G.pos + q;
      const B = _();
      for (; G.pos < H; ) {
        const Y = G.uint32();
        switch (Y >>> 3) {
          case 1:
            B.key = G.string();
            break;
          case 2:
            B.value = a.Value.unwrap(a.Value.decode(G, G.uint32()));
            break;
          default:
            G.skipType(Y & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(V) {
      return { key: J(V.key) ? String(V.key) : "", value: J(V == null ? void 0 : V.value) ? V.value : void 0 };
    },
    toJSON(V) {
      const q = {};
      return V.key !== void 0 && (q.key = V.key), V.value !== void 0 && (q.value = V.value), q;
    },
    fromPartial(V) {
      var q, G;
      const H = _();
      return H.key = (q = V.key) !== null && q !== void 0 ? q : "", H.value = (G = V.value) !== null && G !== void 0 ? G : void 0, H;
    }
  };
  function k() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(V, q = c.default.Writer.create()) {
      return V.nullValue !== void 0 && q.uint32(8).int32(g(V.nullValue)), V.numberValue !== void 0 && q.uint32(17).double(V.numberValue), V.stringValue !== void 0 && q.uint32(26).string(V.stringValue), V.boolValue !== void 0 && q.uint32(32).bool(V.boolValue), V.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(V.structValue), q.uint32(42).fork()).ldelim(), V.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(V.listValue), q.uint32(50).fork()).ldelim(), q;
    },
    decode(V, q) {
      const G = V instanceof c.default.Reader ? V : new c.default.Reader(V);
      let H = q === void 0 ? G.len : G.pos + q;
      const B = k();
      for (; G.pos < H; ) {
        const Y = G.uint32();
        switch (Y >>> 3) {
          case 1:
            B.nullValue = v(G.int32());
            break;
          case 2:
            B.numberValue = G.double();
            break;
          case 3:
            B.stringValue = G.string();
            break;
          case 4:
            B.boolValue = G.bool();
            break;
          case 5:
            B.structValue = a.Struct.unwrap(a.Struct.decode(G, G.uint32()));
            break;
          case 6:
            B.listValue = a.ListValue.unwrap(a.ListValue.decode(G, G.uint32()));
            break;
          default:
            G.skipType(Y & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(V) {
      return {
        nullValue: J(V.nullValue) ? v(V.nullValue) : void 0,
        numberValue: J(V.numberValue) ? Number(V.numberValue) : void 0,
        stringValue: J(V.stringValue) ? String(V.stringValue) : void 0,
        boolValue: J(V.boolValue) ? !!V.boolValue : void 0,
        structValue: $(V.structValue) ? V.structValue : void 0,
        listValue: Array.isArray(V.listValue) ? [...V.listValue] : void 0
      };
    },
    toJSON(V) {
      const q = {};
      return V.nullValue !== void 0 && (q.nullValue = V.nullValue !== void 0 ? S(V.nullValue) : void 0), V.numberValue !== void 0 && (q.numberValue = V.numberValue), V.stringValue !== void 0 && (q.stringValue = V.stringValue), V.boolValue !== void 0 && (q.boolValue = V.boolValue), V.structValue !== void 0 && (q.structValue = V.structValue), V.listValue !== void 0 && (q.listValue = V.listValue), q;
    },
    fromPartial(V) {
      var q, G, H, B, Y, ne;
      const Z = k();
      return Z.nullValue = (q = V.nullValue) !== null && q !== void 0 ? q : void 0, Z.numberValue = (G = V.numberValue) !== null && G !== void 0 ? G : void 0, Z.stringValue = (H = V.stringValue) !== null && H !== void 0 ? H : void 0, Z.boolValue = (B = V.boolValue) !== null && B !== void 0 ? B : void 0, Z.structValue = (Y = V.structValue) !== null && Y !== void 0 ? Y : void 0, Z.listValue = (ne = V.listValue) !== null && ne !== void 0 ? ne : void 0, Z;
    },
    wrap(V) {
      const q = k();
      if (V === null)
        q.nullValue = l.NULL_VALUE;
      else if (typeof V == "boolean")
        q.boolValue = V;
      else if (typeof V == "number")
        q.numberValue = V;
      else if (typeof V == "string")
        q.stringValue = V;
      else if (Array.isArray(V))
        q.listValue = V;
      else if (typeof V == "object")
        q.structValue = V;
      else if (typeof V < "u")
        throw new Error("Unsupported any value type: " + typeof V);
      return q;
    },
    unwrap(V) {
      if ((V == null ? void 0 : V.stringValue) !== void 0)
        return V.stringValue;
      if ((V == null ? void 0 : V.numberValue) !== void 0)
        return V.numberValue;
      if ((V == null ? void 0 : V.boolValue) !== void 0)
        return V.boolValue;
      if ((V == null ? void 0 : V.structValue) !== void 0)
        return V.structValue;
      if ((V == null ? void 0 : V.listValue) !== void 0)
        return V.listValue;
      if ((V == null ? void 0 : V.nullValue) !== void 0)
        return null;
    }
  };
  function L() {
    return { values: [] };
  }
  a.ListValue = {
    encode(V, q = c.default.Writer.create()) {
      for (const G of V.values)
        a.Value.encode(a.Value.wrap(G), q.uint32(10).fork()).ldelim();
      return q;
    },
    decode(V, q) {
      const G = V instanceof c.default.Reader ? V : new c.default.Reader(V);
      let H = q === void 0 ? G.len : G.pos + q;
      const B = L();
      for (; G.pos < H; ) {
        const Y = G.uint32();
        switch (Y >>> 3) {
          case 1:
            B.values.push(a.Value.unwrap(a.Value.decode(G, G.uint32())));
            break;
          default:
            G.skipType(Y & 7);
            break;
        }
      }
      return B;
    },
    fromJSON(V) {
      return { values: Array.isArray(V == null ? void 0 : V.values) ? [...V.values] : [] };
    },
    toJSON(V) {
      const q = {};
      return V.values ? q.values = V.values.map((G) => G) : q.values = [], q;
    },
    fromPartial(V) {
      var q;
      const G = L();
      return G.values = ((q = V.values) === null || q === void 0 ? void 0 : q.map((H) => H)) || [], G;
    },
    wrap(V) {
      const q = L();
      return q.values = V ?? [], q;
    },
    unwrap(V) {
      return V.values;
    }
  };
  var M = (() => {
    if (typeof M < "u")
      return M;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function $(V) {
    return typeof V == "object" && V !== null;
  }
  function J(V) {
    return V != null;
  }
})(struct$1);
var timestamp$2 = {}, __importDefault$9 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(timestamp$2, "__esModule", { value: !0 });
timestamp$2.Timestamp = timestamp$2.protobufPackage = void 0;
const long_1$2 = __importDefault$9(umdExports), minimal_1$2 = __importDefault$9(minimal);
timestamp$2.protobufPackage = "google.protobuf";
function createBaseTimestamp$1() {
  return { seconds: 0, nanos: 0 };
}
timestamp$2.Timestamp = {
  encode(a, u = minimal_1$2.default.Writer.create()) {
    return a.seconds !== 0 && u.uint32(8).int64(a.seconds), a.nanos !== 0 && u.uint32(16).int32(a.nanos), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$2.default.Reader ? a : new minimal_1$2.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseTimestamp$1();
    for (; c.pos < l; ) {
      const S = c.uint32();
      switch (S >>> 3) {
        case 1:
          v.seconds = longToNumber$2(c.int64());
          break;
        case 2:
          v.nanos = c.int32();
          break;
        default:
          c.skipType(S & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      seconds: isSet$2(a.seconds) ? Number(a.seconds) : 0,
      nanos: isSet$2(a.nanos) ? Number(a.nanos) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.seconds !== void 0 && (u.seconds = Math.round(a.seconds)), a.nanos !== void 0 && (u.nanos = Math.round(a.nanos)), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseTimestamp$1();
    return l.seconds = (u = a.seconds) !== null && u !== void 0 ? u : 0, l.nanos = (c = a.nanos) !== null && c !== void 0 ? c : 0, l;
  }
};
var globalThis$3 = (() => {
  if (typeof globalThis$3 < "u")
    return globalThis$3;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber$2(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$3.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1$2.default.util.Long !== long_1$2.default && (minimal_1$2.default.util.Long = long_1$2.default, minimal_1$2.default.configure());
function isSet$2(a) {
  return a != null;
}
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(p) {
    return p && p.__esModule ? p : { default: p };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.Role = a.regionToNumber = a.regionToJSON = a.regionFromJSON = a.Region = a.sourceTriggerActionToNumber = a.sourceTriggerActionToJSON = a.sourceTriggerActionFromJSON = a.SourceTriggerAction = a.s3ACLToNumber = a.s3ACLToJSON = a.s3ACLFromJSON = a.S3ACL = a.projectBroadcastPhaseToNumber = a.projectBroadcastPhaseToJSON = a.projectBroadcastPhaseFromJSON = a.ProjectBroadcastPhase = a.videoCodecRateControlModeToNumber = a.videoCodecRateControlModeToJSON = a.videoCodecRateControlModeFromJSON = a.VideoCodecRateControlMode = a.audioCodecToNumber = a.audioCodecToJSON = a.audioCodecFromJSON = a.AudioCodec = a.videoCodecProfileToNumber = a.videoCodecProfileToJSON = a.videoCodecProfileFromJSON = a.VideoCodecProfile = a.videoCodecToNumber = a.videoCodecToJSON = a.videoCodecFromJSON = a.VideoCodec = a.renderingQualityToNumber = a.renderingQualityToJSON = a.renderingQualityFromJSON = a.RenderingQuality = a.audioChannelLayoutToNumber = a.audioChannelLayoutToJSON = a.audioChannelLayoutFromJSON = a.AudioChannelLayout = a.videoColorSpaceToNumber = a.videoColorSpaceToJSON = a.videoColorSpaceFromJSON = a.VideoColorSpace = a.imageFormatToNumber = a.imageFormatToJSON = a.imageFormatFromJSON = a.ImageFormat = a.protobufPackage = void 0, a.ExternalComposition = a.SceneComposition = a.StudioSdkComposition = a.PreviewAddress = a.PreviewWebRtcAddress = a.PreviewHlsPullAddress = a.ProjectTrigger = a.WebRtcTrigger = a.SourceTrigger = a.DestinationAddress = a.S3StorageAddress = a.ObjectStoragePackaging = a.HlsPackaging = a.HlsLifecycle = a.HlsLifecycleVod = a.HlsLifecycleLive = a.DestinationAgoraPushAddress = a.DestinationSrtPushAddress = a.DestinationRtmpPushAddress = a.SourceAddress = a.SrtPullAddress = a.RtmpPullAddress = a.SrtPushAddress = a.SourceRtmpPushAddress = a.Encoding = a.AudioEncoding = a.VideoEncoding = a.VideoCodecRateControl = a.Rendering = a.AudioRendering = a.VideoRendering = a.eventTypeToNumber = a.eventTypeToJSON = a.eventTypeFromJSON = a.EventType = a.eventSubTypeToNumber = a.eventSubTypeToJSON = a.eventSubTypeFromJSON = a.EventSubType = a.connectStateToNumber = a.connectStateToJSON = a.connectStateFromJSON = a.ConnectState = a.projectBroadcastErrorToNumber = a.projectBroadcastErrorToJSON = a.projectBroadcastErrorFromJSON = a.ProjectBroadcastError = a.roleToNumber = a.roleToJSON = a.roleFromJSON = void 0, a.CreateSourceResponse = a.CreateSourceRequest = a.UpdateDestinationResponse = a.UpdateDestinationRequest = a.DeleteDestinationResponse = a.DeleteDestinationRequest = a.GetDestinationResponse = a.GetDestinationRequest = a.CreateDestinationResponse = a.CreateDestinationRequest = a.StopProjectWebRtcResponse = a.StopProjectWebRtcRequest = a.StartProjectWebRtcResponse = a.StartProjectWebRtcRequest = a.GetProjectBroadcastStatusResponse = a.GetProjectBroadcastStatusRequest = a.GetProjectBroadcastSnapshotResponse = a.GetProjectBroadcastSnapshotRequest = a.GetProjectResponse = a.GetProjectRequest = a.StopProjectBroadcastResponse = a.StopProjectBroadcastRequest = a.StartProjectBroadcastResponse = a.StartProjectBroadcastRequest = a.DeleteProjectResponse = a.DeleteProjectRequest = a.UpdateProjectResponse = a.UpdateProjectRequest = a.CreateProjectResponse = a.CreateProjectRequest = a.GetCollectionsResponse = a.GetCollectionsRequest = a.DeleteCollectionResponse = a.DeleteCollectionRequest = a.UpdateCollectionResponse = a.UpdateCollectionRequest = a.GetCollectionResponse = a.GetCollectionRequest = a.CreateCollectionResponse = a.CreateCollectionRequest = a.Collection = a.Project = a.Destination = a.Source = a.ProjectBroadcastStatus = a.LatLong = a.WebRtcAccess = a.WebRtc = a.HostedWebRtc = a.Composition = void 0, a.SourceAddEvent = a.SourceUpdateEvent = a.SourceDeleteEvent = a.SourceCreateEvent = a.CollectionUpdateEvent = a.CollectionDeleteEvent = a.CollectionCreateEvent = a.ProjectBroadcastStateEvent = a.ProjectUpdateEvent = a.ProjectDeleteEvent = a.ProjectCreateEvent = a.DestinationStateEvent = a.DestinationUpdateEvent = a.DestinationDeleteEvent = a.DestinationCreateEvent = a.GetTestTokenResponse = a.GetTestTokenRequest = a.GetJsonWebKeySetResponse = a.GetJsonWebKeySetRequest = a.JsonWebKey = a.GuestCodeRedirectResponse = a.GuestCodeRedirectRequest = a.GuestCode = a.RefreshAccessTokenResponse = a.RefreshAccessTokenRequest = a.CreateWebRtcAccessTokenResponse = a.CreateWebRtcAccessTokenRequest = a.CreateGuestAccessTokenResponse = a.CreateGuestAccessTokenRequest = a.GuestAccessToken = a.GuestAccessTokenExchange = a.GuestAccessTokenDirect = a.CreateAccessTokenResponse = a.CreateAccessTokenRequest = a.GetSourcePlaylistResponse = a.GetSourcePlaylistRequest = a.RemoveSourceFromProjectResponse = a.RemoveSourceFromProjectRequest = a.UpdateSourceResponse = a.UpdateSourceRequest = a.GetSourcesResponse = a.GetSourcesRequest = a.GetSourceResponse = a.GetSourceRequest = a.UpdateSourceInProjectResponse = a.UpdateSourceInProjectRequest = a.AddSourceToProjectResponse = a.AddSourceToProjectRequest = a.DeleteSourceResponse = a.DeleteSourceRequest = void 0, a.PublicAuthenticationServiceDefinition = a.PublicAuthenticationServiceClientImpl = a.AuthenticationServiceDefinition = a.AuthenticationServiceClientImpl = a.BackendAuthenticationServiceDefinition = a.BackendAuthenticationServiceClientImpl = a.SourceServiceDefinition = a.SourceServiceClientImpl = a.DestinationServiceDefinition = a.DestinationServiceClientImpl = a.ProjectServiceDefinition = a.ProjectServiceClientImpl = a.CollectionServiceDefinition = a.CollectionServiceClientImpl = a.LiveEvent = a.SourceEvent = a.ProjectEvent = a.DestinationEvent = a.CollectionEvent = a.SourceStateEvent = a.SourceRemoveEvent = void 0;
  const c = u(minimal), l = httpbody, v = field_mask, S = struct$1, g = timestamp$2;
  a.protobufPackage = "live.v21";
  var E;
  (function(p) {
    p.IMAGE_FORMAT_UNSPECIFIED = "IMAGE_FORMAT_UNSPECIFIED", p.IMAGE_FORMAT_JPEG = "IMAGE_FORMAT_JPEG";
  })(E = a.ImageFormat || (a.ImageFormat = {}));
  function _(p) {
    switch (p) {
      case 0:
      case "IMAGE_FORMAT_UNSPECIFIED":
        return E.IMAGE_FORMAT_UNSPECIFIED;
      case 1:
      case "IMAGE_FORMAT_JPEG":
        return E.IMAGE_FORMAT_JPEG;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum ImageFormat");
    }
  }
  a.imageFormatFromJSON = _;
  function k(p) {
    switch (p) {
      case E.IMAGE_FORMAT_UNSPECIFIED:
        return "IMAGE_FORMAT_UNSPECIFIED";
      case E.IMAGE_FORMAT_JPEG:
        return "IMAGE_FORMAT_JPEG";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum ImageFormat");
    }
  }
  a.imageFormatToJSON = k;
  function L(p) {
    switch (p) {
      case E.IMAGE_FORMAT_UNSPECIFIED:
        return 0;
      case E.IMAGE_FORMAT_JPEG:
        return 1;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum ImageFormat");
    }
  }
  a.imageFormatToNumber = L;
  var M;
  (function(p) {
    p.VIDEO_COLOR_SPACE_UNSPECIFIED = "VIDEO_COLOR_SPACE_UNSPECIFIED", p.VIDEO_COLOR_SPACE_YUV420 = "VIDEO_COLOR_SPACE_YUV420";
  })(M = a.VideoColorSpace || (a.VideoColorSpace = {}));
  function $(p) {
    switch (p) {
      case 0:
      case "VIDEO_COLOR_SPACE_UNSPECIFIED":
        return M.VIDEO_COLOR_SPACE_UNSPECIFIED;
      case 1:
      case "VIDEO_COLOR_SPACE_YUV420":
        return M.VIDEO_COLOR_SPACE_YUV420;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceFromJSON = $;
  function J(p) {
    switch (p) {
      case M.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return "VIDEO_COLOR_SPACE_UNSPECIFIED";
      case M.VIDEO_COLOR_SPACE_YUV420:
        return "VIDEO_COLOR_SPACE_YUV420";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceToJSON = J;
  function V(p) {
    switch (p) {
      case M.VIDEO_COLOR_SPACE_UNSPECIFIED:
        return 0;
      case M.VIDEO_COLOR_SPACE_YUV420:
        return 1;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum VideoColorSpace");
    }
  }
  a.videoColorSpaceToNumber = V;
  var q;
  (function(p) {
    p.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED = "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED", p.AUDIO_CHANNEL_LAYOUT_STEREO = "AUDIO_CHANNEL_LAYOUT_STEREO";
  })(q = a.AudioChannelLayout || (a.AudioChannelLayout = {}));
  function G(p) {
    switch (p) {
      case 0:
      case "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED":
        return q.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED;
      case 1:
      case "AUDIO_CHANNEL_LAYOUT_STEREO":
        return q.AUDIO_CHANNEL_LAYOUT_STEREO;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutFromJSON = G;
  function H(p) {
    switch (p) {
      case q.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return "AUDIO_CHANNEL_LAYOUT_UNSPECIFIED";
      case q.AUDIO_CHANNEL_LAYOUT_STEREO:
        return "AUDIO_CHANNEL_LAYOUT_STEREO";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutToJSON = H;
  function B(p) {
    switch (p) {
      case q.AUDIO_CHANNEL_LAYOUT_UNSPECIFIED:
        return 0;
      case q.AUDIO_CHANNEL_LAYOUT_STEREO:
        return 1;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum AudioChannelLayout");
    }
  }
  a.audioChannelLayoutToNumber = B;
  var Y;
  (function(p) {
    p.RENDERING_QUALITY_UNSPECIFIED = "RENDERING_QUALITY_UNSPECIFIED", p.RENDERING_QUALITY_STANDARD = "RENDERING_QUALITY_STANDARD", p.RENDERING_QUALITY_HIGH = "RENDERING_QUALITY_HIGH";
  })(Y = a.RenderingQuality || (a.RenderingQuality = {}));
  function ne(p) {
    switch (p) {
      case 0:
      case "RENDERING_QUALITY_UNSPECIFIED":
        return Y.RENDERING_QUALITY_UNSPECIFIED;
      case 1:
      case "RENDERING_QUALITY_STANDARD":
        return Y.RENDERING_QUALITY_STANDARD;
      case 2:
      case "RENDERING_QUALITY_HIGH":
        return Y.RENDERING_QUALITY_HIGH;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum RenderingQuality");
    }
  }
  a.renderingQualityFromJSON = ne;
  function Z(p) {
    switch (p) {
      case Y.RENDERING_QUALITY_UNSPECIFIED:
        return "RENDERING_QUALITY_UNSPECIFIED";
      case Y.RENDERING_QUALITY_STANDARD:
        return "RENDERING_QUALITY_STANDARD";
      case Y.RENDERING_QUALITY_HIGH:
        return "RENDERING_QUALITY_HIGH";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum RenderingQuality");
    }
  }
  a.renderingQualityToJSON = Z;
  function re(p) {
    switch (p) {
      case Y.RENDERING_QUALITY_UNSPECIFIED:
        return 0;
      case Y.RENDERING_QUALITY_STANDARD:
        return 1;
      case Y.RENDERING_QUALITY_HIGH:
        return 2;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum RenderingQuality");
    }
  }
  a.renderingQualityToNumber = re;
  var oe;
  (function(p) {
    p.VIDEO_CODEC_UNSPECIFIED = "VIDEO_CODEC_UNSPECIFIED", p.VIDEO_CODEC_H264 = "VIDEO_CODEC_H264";
  })(oe = a.VideoCodec || (a.VideoCodec = {}));
  function de(p) {
    switch (p) {
      case 0:
      case "VIDEO_CODEC_UNSPECIFIED":
        return oe.VIDEO_CODEC_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_H264":
        return oe.VIDEO_CODEC_H264;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum VideoCodec");
    }
  }
  a.videoCodecFromJSON = de;
  function A(p) {
    switch (p) {
      case oe.VIDEO_CODEC_UNSPECIFIED:
        return "VIDEO_CODEC_UNSPECIFIED";
      case oe.VIDEO_CODEC_H264:
        return "VIDEO_CODEC_H264";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum VideoCodec");
    }
  }
  a.videoCodecToJSON = A;
  function N(p) {
    switch (p) {
      case oe.VIDEO_CODEC_UNSPECIFIED:
        return 0;
      case oe.VIDEO_CODEC_H264:
        return 1;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum VideoCodec");
    }
  }
  a.videoCodecToNumber = N;
  var D;
  (function(p) {
    p.VIDEO_CODEC_PROFILE_UNSPECIFIED = "VIDEO_CODEC_PROFILE_UNSPECIFIED", p.VIDEO_CODEC_PROFILE_BASELINE = "VIDEO_CODEC_PROFILE_BASELINE", p.VIDEO_CODEC_PROFILE_MAIN = "VIDEO_CODEC_PROFILE_MAIN", p.VIDEO_CODEC_PROFILE_HIGH = "VIDEO_CODEC_PROFILE_HIGH";
  })(D = a.VideoCodecProfile || (a.VideoCodecProfile = {}));
  function W(p) {
    switch (p) {
      case 0:
      case "VIDEO_CODEC_PROFILE_UNSPECIFIED":
        return D.VIDEO_CODEC_PROFILE_UNSPECIFIED;
      case 2:
      case "VIDEO_CODEC_PROFILE_BASELINE":
        return D.VIDEO_CODEC_PROFILE_BASELINE;
      case 3:
      case "VIDEO_CODEC_PROFILE_MAIN":
        return D.VIDEO_CODEC_PROFILE_MAIN;
      case 4:
      case "VIDEO_CODEC_PROFILE_HIGH":
        return D.VIDEO_CODEC_PROFILE_HIGH;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileFromJSON = W;
  function ee(p) {
    switch (p) {
      case D.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return "VIDEO_CODEC_PROFILE_UNSPECIFIED";
      case D.VIDEO_CODEC_PROFILE_BASELINE:
        return "VIDEO_CODEC_PROFILE_BASELINE";
      case D.VIDEO_CODEC_PROFILE_MAIN:
        return "VIDEO_CODEC_PROFILE_MAIN";
      case D.VIDEO_CODEC_PROFILE_HIGH:
        return "VIDEO_CODEC_PROFILE_HIGH";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileToJSON = ee;
  function ae(p) {
    switch (p) {
      case D.VIDEO_CODEC_PROFILE_UNSPECIFIED:
        return 0;
      case D.VIDEO_CODEC_PROFILE_BASELINE:
        return 2;
      case D.VIDEO_CODEC_PROFILE_MAIN:
        return 3;
      case D.VIDEO_CODEC_PROFILE_HIGH:
        return 4;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum VideoCodecProfile");
    }
  }
  a.videoCodecProfileToNumber = ae;
  var ye;
  (function(p) {
    p.AUDIO_CODEC_UNSPECIFIED = "AUDIO_CODEC_UNSPECIFIED", p.AUDIO_CODEC_AAC = "AUDIO_CODEC_AAC";
  })(ye = a.AudioCodec || (a.AudioCodec = {}));
  function he(p) {
    switch (p) {
      case 0:
      case "AUDIO_CODEC_UNSPECIFIED":
        return ye.AUDIO_CODEC_UNSPECIFIED;
      case 1:
      case "AUDIO_CODEC_AAC":
        return ye.AUDIO_CODEC_AAC;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum AudioCodec");
    }
  }
  a.audioCodecFromJSON = he;
  function le(p) {
    switch (p) {
      case ye.AUDIO_CODEC_UNSPECIFIED:
        return "AUDIO_CODEC_UNSPECIFIED";
      case ye.AUDIO_CODEC_AAC:
        return "AUDIO_CODEC_AAC";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum AudioCodec");
    }
  }
  a.audioCodecToJSON = le;
  function we(p) {
    switch (p) {
      case ye.AUDIO_CODEC_UNSPECIFIED:
        return 0;
      case ye.AUDIO_CODEC_AAC:
        return 1;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum AudioCodec");
    }
  }
  a.audioCodecToNumber = we;
  var Be;
  (function(p) {
    p.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED = "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED", p.VIDEO_CODEC_RATE_CONTROL_MODE_CBR = "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
  })(Be = a.VideoCodecRateControlMode || (a.VideoCodecRateControlMode = {}));
  function Ne(p) {
    switch (p) {
      case 0:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED":
        return Be.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED;
      case 1:
      case "VIDEO_CODEC_RATE_CONTROL_MODE_CBR":
        return Be.VIDEO_CODEC_RATE_CONTROL_MODE_CBR;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeFromJSON = Ne;
  function Le(p) {
    switch (p) {
      case Be.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED";
      case Be.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return "VIDEO_CODEC_RATE_CONTROL_MODE_CBR";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeToJSON = Le;
  function $e(p) {
    switch (p) {
      case Be.VIDEO_CODEC_RATE_CONTROL_MODE_UNSPECIFIED:
        return 0;
      case Be.VIDEO_CODEC_RATE_CONTROL_MODE_CBR:
        return 1;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum VideoCodecRateControlMode");
    }
  }
  a.videoCodecRateControlModeToNumber = $e;
  var Ue;
  (function(p) {
    p.PROJECT_BROADCAST_PHASE_UNSPECIFIED = "PROJECT_BROADCAST_PHASE_UNSPECIFIED", p.PROJECT_BROADCAST_PHASE_NOT_RUNNING = "PROJECT_BROADCAST_PHASE_NOT_RUNNING", p.PROJECT_BROADCAST_PHASE_WAITING = "PROJECT_BROADCAST_PHASE_WAITING", p.PROJECT_BROADCAST_PHASE_STARTING = "PROJECT_BROADCAST_PHASE_STARTING", p.PROJECT_BROADCAST_PHASE_RUNNING = "PROJECT_BROADCAST_PHASE_RUNNING", p.PROJECT_BROADCAST_PHASE_STOPPING = "PROJECT_BROADCAST_PHASE_STOPPING", p.PROJECT_BROADCAST_PHASE_STOPPED = "PROJECT_BROADCAST_PHASE_STOPPED", p.PROJECT_BROADCAST_PHASE_ARCHIVED = "PROJECT_BROADCAST_PHASE_ARCHIVED";
  })(Ue = a.ProjectBroadcastPhase || (a.ProjectBroadcastPhase = {}));
  function Ge(p) {
    switch (p) {
      case 0:
      case "PROJECT_BROADCAST_PHASE_UNSPECIFIED":
        return Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_PHASE_NOT_RUNNING":
        return Ue.PROJECT_BROADCAST_PHASE_NOT_RUNNING;
      case 2:
      case "PROJECT_BROADCAST_PHASE_WAITING":
        return Ue.PROJECT_BROADCAST_PHASE_WAITING;
      case 3:
      case "PROJECT_BROADCAST_PHASE_STARTING":
        return Ue.PROJECT_BROADCAST_PHASE_STARTING;
      case 4:
      case "PROJECT_BROADCAST_PHASE_RUNNING":
        return Ue.PROJECT_BROADCAST_PHASE_RUNNING;
      case 5:
      case "PROJECT_BROADCAST_PHASE_STOPPING":
        return Ue.PROJECT_BROADCAST_PHASE_STOPPING;
      case 6:
      case "PROJECT_BROADCAST_PHASE_STOPPED":
        return Ue.PROJECT_BROADCAST_PHASE_STOPPED;
      case 7:
      case "PROJECT_BROADCAST_PHASE_ARCHIVED":
        return Ue.PROJECT_BROADCAST_PHASE_ARCHIVED;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseFromJSON = Ge;
  function He(p) {
    switch (p) {
      case Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return "PROJECT_BROADCAST_PHASE_UNSPECIFIED";
      case Ue.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return "PROJECT_BROADCAST_PHASE_NOT_RUNNING";
      case Ue.PROJECT_BROADCAST_PHASE_WAITING:
        return "PROJECT_BROADCAST_PHASE_WAITING";
      case Ue.PROJECT_BROADCAST_PHASE_STARTING:
        return "PROJECT_BROADCAST_PHASE_STARTING";
      case Ue.PROJECT_BROADCAST_PHASE_RUNNING:
        return "PROJECT_BROADCAST_PHASE_RUNNING";
      case Ue.PROJECT_BROADCAST_PHASE_STOPPING:
        return "PROJECT_BROADCAST_PHASE_STOPPING";
      case Ue.PROJECT_BROADCAST_PHASE_STOPPED:
        return "PROJECT_BROADCAST_PHASE_STOPPED";
      case Ue.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return "PROJECT_BROADCAST_PHASE_ARCHIVED";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseToJSON = He;
  function Ve(p) {
    switch (p) {
      case Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED:
        return 0;
      case Ue.PROJECT_BROADCAST_PHASE_NOT_RUNNING:
        return 1;
      case Ue.PROJECT_BROADCAST_PHASE_WAITING:
        return 2;
      case Ue.PROJECT_BROADCAST_PHASE_STARTING:
        return 3;
      case Ue.PROJECT_BROADCAST_PHASE_RUNNING:
        return 4;
      case Ue.PROJECT_BROADCAST_PHASE_STOPPING:
        return 5;
      case Ue.PROJECT_BROADCAST_PHASE_STOPPED:
        return 6;
      case Ue.PROJECT_BROADCAST_PHASE_ARCHIVED:
        return 7;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum ProjectBroadcastPhase");
    }
  }
  a.projectBroadcastPhaseToNumber = Ve;
  var be;
  (function(p) {
    p.S3ACL_UNSPECIFIED = "S3ACL_UNSPECIFIED", p.S3ACL_PRIVATE = "S3ACL_PRIVATE", p.S3ACL_PUBLIC_READ = "S3ACL_PUBLIC_READ", p.S3ACL_PUBLIC_READ_WRITE = "S3ACL_PUBLIC_READ_WRITE", p.S3ACL_AUTHENTICATED_READ = "S3ACL_AUTHENTICATED_READ", p.S3ACL_BUCKET_OWNER_READ = "S3ACL_BUCKET_OWNER_READ", p.S3ACL_BUCKET_OWNER_FULL_CONTROL = "S3ACL_BUCKET_OWNER_FULL_CONTROL";
  })(be = a.S3ACL || (a.S3ACL = {}));
  function Ae(p) {
    switch (p) {
      case 0:
      case "S3ACL_UNSPECIFIED":
        return be.S3ACL_UNSPECIFIED;
      case 1:
      case "S3ACL_PRIVATE":
        return be.S3ACL_PRIVATE;
      case 2:
      case "S3ACL_PUBLIC_READ":
        return be.S3ACL_PUBLIC_READ;
      case 3:
      case "S3ACL_PUBLIC_READ_WRITE":
        return be.S3ACL_PUBLIC_READ_WRITE;
      case 4:
      case "S3ACL_AUTHENTICATED_READ":
        return be.S3ACL_AUTHENTICATED_READ;
      case 5:
      case "S3ACL_BUCKET_OWNER_READ":
        return be.S3ACL_BUCKET_OWNER_READ;
      case 6:
      case "S3ACL_BUCKET_OWNER_FULL_CONTROL":
        return be.S3ACL_BUCKET_OWNER_FULL_CONTROL;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum S3ACL");
    }
  }
  a.s3ACLFromJSON = Ae;
  function qe(p) {
    switch (p) {
      case be.S3ACL_UNSPECIFIED:
        return "S3ACL_UNSPECIFIED";
      case be.S3ACL_PRIVATE:
        return "S3ACL_PRIVATE";
      case be.S3ACL_PUBLIC_READ:
        return "S3ACL_PUBLIC_READ";
      case be.S3ACL_PUBLIC_READ_WRITE:
        return "S3ACL_PUBLIC_READ_WRITE";
      case be.S3ACL_AUTHENTICATED_READ:
        return "S3ACL_AUTHENTICATED_READ";
      case be.S3ACL_BUCKET_OWNER_READ:
        return "S3ACL_BUCKET_OWNER_READ";
      case be.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return "S3ACL_BUCKET_OWNER_FULL_CONTROL";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum S3ACL");
    }
  }
  a.s3ACLToJSON = qe;
  function xe(p) {
    switch (p) {
      case be.S3ACL_UNSPECIFIED:
        return 0;
      case be.S3ACL_PRIVATE:
        return 1;
      case be.S3ACL_PUBLIC_READ:
        return 2;
      case be.S3ACL_PUBLIC_READ_WRITE:
        return 3;
      case be.S3ACL_AUTHENTICATED_READ:
        return 4;
      case be.S3ACL_BUCKET_OWNER_READ:
        return 5;
      case be.S3ACL_BUCKET_OWNER_FULL_CONTROL:
        return 6;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum S3ACL");
    }
  }
  a.s3ACLToNumber = xe;
  var Pe;
  (function(p) {
    p.SOURCE_TRIGGER_ACTION_UNSPECIFIED = "SOURCE_TRIGGER_ACTION_UNSPECIFIED", p.SOURCE_TRIGGER_ACTION_IGNORE = "SOURCE_TRIGGER_ACTION_IGNORE", p.SOURCE_TRIGGER_ACTION_OR = "SOURCE_TRIGGER_ACTION_OR";
  })(Pe = a.SourceTriggerAction || (a.SourceTriggerAction = {}));
  function C(p) {
    switch (p) {
      case 0:
      case "SOURCE_TRIGGER_ACTION_UNSPECIFIED":
        return Pe.SOURCE_TRIGGER_ACTION_UNSPECIFIED;
      case 1:
      case "SOURCE_TRIGGER_ACTION_IGNORE":
        return Pe.SOURCE_TRIGGER_ACTION_IGNORE;
      case 3:
      case "SOURCE_TRIGGER_ACTION_OR":
        return Pe.SOURCE_TRIGGER_ACTION_OR;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionFromJSON = C;
  function x(p) {
    switch (p) {
      case Pe.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return "SOURCE_TRIGGER_ACTION_UNSPECIFIED";
      case Pe.SOURCE_TRIGGER_ACTION_IGNORE:
        return "SOURCE_TRIGGER_ACTION_IGNORE";
      case Pe.SOURCE_TRIGGER_ACTION_OR:
        return "SOURCE_TRIGGER_ACTION_OR";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionToJSON = x;
  function Q(p) {
    switch (p) {
      case Pe.SOURCE_TRIGGER_ACTION_UNSPECIFIED:
        return 0;
      case Pe.SOURCE_TRIGGER_ACTION_IGNORE:
        return 1;
      case Pe.SOURCE_TRIGGER_ACTION_OR:
        return 3;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum SourceTriggerAction");
    }
  }
  a.sourceTriggerActionToNumber = Q;
  var Se;
  (function(p) {
    p.REGION_UNSPECIFIED = "REGION_UNSPECIFIED", p.REGION_US_EAST_1 = "REGION_US_EAST_1", p.REGION_US_EAST_2 = "REGION_US_EAST_2", p.REGION_US_WEST_1 = "REGION_US_WEST_1", p.REGION_US_WEST_2 = "REGION_US_WEST_2", p.REGION_US_CENTRAL_1 = "REGION_US_CENTRAL_1", p.REGION_AP_SOUTHEAST_1 = "REGION_AP_SOUTHEAST_1", p.REGION_AP_SOUTHEAST_2 = "REGION_AP_SOUTHEAST_2", p.REGION_AP_SOUTH_1 = "REGION_AP_SOUTH_1", p.REGION_CA_EAST_1 = "REGION_CA_EAST_1", p.REGION_EU_CENTRAL_1 = "REGION_EU_CENTRAL_1", p.REGION_EU_WEST_1 = "REGION_EU_WEST_1";
  })(Se = a.Region || (a.Region = {}));
  function me(p) {
    switch (p) {
      case 0:
      case "REGION_UNSPECIFIED":
        return Se.REGION_UNSPECIFIED;
      case 1:
      case "REGION_US_EAST_1":
        return Se.REGION_US_EAST_1;
      case 2:
      case "REGION_US_EAST_2":
        return Se.REGION_US_EAST_2;
      case 3:
      case "REGION_US_WEST_1":
        return Se.REGION_US_WEST_1;
      case 4:
      case "REGION_US_WEST_2":
        return Se.REGION_US_WEST_2;
      case 5:
      case "REGION_US_CENTRAL_1":
        return Se.REGION_US_CENTRAL_1;
      case 10:
      case "REGION_AP_SOUTHEAST_1":
        return Se.REGION_AP_SOUTHEAST_1;
      case 11:
      case "REGION_AP_SOUTHEAST_2":
        return Se.REGION_AP_SOUTHEAST_2;
      case 15:
      case "REGION_AP_SOUTH_1":
        return Se.REGION_AP_SOUTH_1;
      case 20:
      case "REGION_CA_EAST_1":
        return Se.REGION_CA_EAST_1;
      case 30:
      case "REGION_EU_CENTRAL_1":
        return Se.REGION_EU_CENTRAL_1;
      case 31:
      case "REGION_EU_WEST_1":
        return Se.REGION_EU_WEST_1;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum Region");
    }
  }
  a.regionFromJSON = me;
  function Ie(p) {
    switch (p) {
      case Se.REGION_UNSPECIFIED:
        return "REGION_UNSPECIFIED";
      case Se.REGION_US_EAST_1:
        return "REGION_US_EAST_1";
      case Se.REGION_US_EAST_2:
        return "REGION_US_EAST_2";
      case Se.REGION_US_WEST_1:
        return "REGION_US_WEST_1";
      case Se.REGION_US_WEST_2:
        return "REGION_US_WEST_2";
      case Se.REGION_US_CENTRAL_1:
        return "REGION_US_CENTRAL_1";
      case Se.REGION_AP_SOUTHEAST_1:
        return "REGION_AP_SOUTHEAST_1";
      case Se.REGION_AP_SOUTHEAST_2:
        return "REGION_AP_SOUTHEAST_2";
      case Se.REGION_AP_SOUTH_1:
        return "REGION_AP_SOUTH_1";
      case Se.REGION_CA_EAST_1:
        return "REGION_CA_EAST_1";
      case Se.REGION_EU_CENTRAL_1:
        return "REGION_EU_CENTRAL_1";
      case Se.REGION_EU_WEST_1:
        return "REGION_EU_WEST_1";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum Region");
    }
  }
  a.regionToJSON = Ie;
  function at(p) {
    switch (p) {
      case Se.REGION_UNSPECIFIED:
        return 0;
      case Se.REGION_US_EAST_1:
        return 1;
      case Se.REGION_US_EAST_2:
        return 2;
      case Se.REGION_US_WEST_1:
        return 3;
      case Se.REGION_US_WEST_2:
        return 4;
      case Se.REGION_US_CENTRAL_1:
        return 5;
      case Se.REGION_AP_SOUTHEAST_1:
        return 10;
      case Se.REGION_AP_SOUTHEAST_2:
        return 11;
      case Se.REGION_AP_SOUTH_1:
        return 15;
      case Se.REGION_CA_EAST_1:
        return 20;
      case Se.REGION_EU_CENTRAL_1:
        return 30;
      case Se.REGION_EU_WEST_1:
        return 31;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum Region");
    }
  }
  a.regionToNumber = at;
  var Ye;
  (function(p) {
    p.ROLE_UNSPECIFIED = "ROLE_UNSPECIFIED", p.ROLE_HOST = "ROLE_HOST", p.ROLE_COHOST = "ROLE_COHOST", p.ROLE_CONTRIBUTOR = "ROLE_CONTRIBUTOR", p.ROLE_GUEST = "ROLE_GUEST", p.ROLE_VIEWER = "ROLE_VIEWER", p.ROLE_RENDERER = "ROLE_RENDERER", p.ROLE_PLATFORM = "ROLE_PLATFORM", p.ROLE_IMPERSONATE = "ROLE_IMPERSONATE";
  })(Ye = a.Role || (a.Role = {}));
  function je(p) {
    switch (p) {
      case 0:
      case "ROLE_UNSPECIFIED":
        return Ye.ROLE_UNSPECIFIED;
      case 1:
      case "ROLE_HOST":
        return Ye.ROLE_HOST;
      case 2:
      case "ROLE_COHOST":
        return Ye.ROLE_COHOST;
      case 3:
      case "ROLE_CONTRIBUTOR":
        return Ye.ROLE_CONTRIBUTOR;
      case 4:
      case "ROLE_GUEST":
        return Ye.ROLE_GUEST;
      case 5:
      case "ROLE_VIEWER":
        return Ye.ROLE_VIEWER;
      case 6:
      case "ROLE_RENDERER":
        return Ye.ROLE_RENDERER;
      case 7:
      case "ROLE_PLATFORM":
        return Ye.ROLE_PLATFORM;
      case 8:
      case "ROLE_IMPERSONATE":
        return Ye.ROLE_IMPERSONATE;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum Role");
    }
  }
  a.roleFromJSON = je;
  function tt(p) {
    switch (p) {
      case Ye.ROLE_UNSPECIFIED:
        return "ROLE_UNSPECIFIED";
      case Ye.ROLE_HOST:
        return "ROLE_HOST";
      case Ye.ROLE_COHOST:
        return "ROLE_COHOST";
      case Ye.ROLE_CONTRIBUTOR:
        return "ROLE_CONTRIBUTOR";
      case Ye.ROLE_GUEST:
        return "ROLE_GUEST";
      case Ye.ROLE_VIEWER:
        return "ROLE_VIEWER";
      case Ye.ROLE_RENDERER:
        return "ROLE_RENDERER";
      case Ye.ROLE_PLATFORM:
        return "ROLE_PLATFORM";
      case Ye.ROLE_IMPERSONATE:
        return "ROLE_IMPERSONATE";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum Role");
    }
  }
  a.roleToJSON = tt;
  function Oe(p) {
    switch (p) {
      case Ye.ROLE_UNSPECIFIED:
        return 0;
      case Ye.ROLE_HOST:
        return 1;
      case Ye.ROLE_COHOST:
        return 2;
      case Ye.ROLE_CONTRIBUTOR:
        return 3;
      case Ye.ROLE_GUEST:
        return 4;
      case Ye.ROLE_VIEWER:
        return 5;
      case Ye.ROLE_RENDERER:
        return 6;
      case Ye.ROLE_PLATFORM:
        return 7;
      case Ye.ROLE_IMPERSONATE:
        return 8;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum Role");
    }
  }
  a.roleToNumber = Oe;
  var P;
  (function(p) {
    p.PROJECT_BROADCAST_ERROR_UNSPECIFIED = "PROJECT_BROADCAST_ERROR_UNSPECIFIED", p.PROJECT_BROADCAST_ERROR_INTERNAL = "PROJECT_BROADCAST_ERROR_INTERNAL", p.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED = "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
  })(P = a.ProjectBroadcastError || (a.ProjectBroadcastError = {}));
  function X(p) {
    switch (p) {
      case 0:
      case "PROJECT_BROADCAST_ERROR_UNSPECIFIED":
        return P.PROJECT_BROADCAST_ERROR_UNSPECIFIED;
      case 1:
      case "PROJECT_BROADCAST_ERROR_INTERNAL":
        return P.PROJECT_BROADCAST_ERROR_INTERNAL;
      case 2:
      case "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED":
        return P.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorFromJSON = X;
  function ie(p) {
    switch (p) {
      case P.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return "PROJECT_BROADCAST_ERROR_UNSPECIFIED";
      case P.PROJECT_BROADCAST_ERROR_INTERNAL:
        return "PROJECT_BROADCAST_ERROR_INTERNAL";
      case P.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return "PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorToJSON = ie;
  function Ee(p) {
    switch (p) {
      case P.PROJECT_BROADCAST_ERROR_UNSPECIFIED:
        return 0;
      case P.PROJECT_BROADCAST_ERROR_INTERNAL:
        return 1;
      case P.PROJECT_BROADCAST_ERROR_DURATION_EXCEEDED:
        return 2;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum ProjectBroadcastError");
    }
  }
  a.projectBroadcastErrorToNumber = Ee;
  var ue;
  (function(p) {
    p.CONNECT_STATE_UNSPECIFIED = "CONNECT_STATE_UNSPECIFIED", p.CONNECT_STATE_CONNECTED = "CONNECT_STATE_CONNECTED", p.CONNECT_STATE_DISCONNECTED = "CONNECT_STATE_DISCONNECTED";
  })(ue = a.ConnectState || (a.ConnectState = {}));
  function O(p) {
    switch (p) {
      case 0:
      case "CONNECT_STATE_UNSPECIFIED":
        return ue.CONNECT_STATE_UNSPECIFIED;
      case 1:
      case "CONNECT_STATE_CONNECTED":
        return ue.CONNECT_STATE_CONNECTED;
      case 2:
      case "CONNECT_STATE_DISCONNECTED":
        return ue.CONNECT_STATE_DISCONNECTED;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum ConnectState");
    }
  }
  a.connectStateFromJSON = O;
  function j(p) {
    switch (p) {
      case ue.CONNECT_STATE_UNSPECIFIED:
        return "CONNECT_STATE_UNSPECIFIED";
      case ue.CONNECT_STATE_CONNECTED:
        return "CONNECT_STATE_CONNECTED";
      case ue.CONNECT_STATE_DISCONNECTED:
        return "CONNECT_STATE_DISCONNECTED";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum ConnectState");
    }
  }
  a.connectStateToJSON = j;
  function se(p) {
    switch (p) {
      case ue.CONNECT_STATE_UNSPECIFIED:
        return 0;
      case ue.CONNECT_STATE_CONNECTED:
        return 1;
      case ue.CONNECT_STATE_DISCONNECTED:
        return 2;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum ConnectState");
    }
  }
  a.connectStateToNumber = se;
  var _e;
  (function(p) {
    p.EVENT_SUB_TYPE_UNSPECIFIED = "EVENT_SUB_TYPE_UNSPECIFIED", p.EVENT_SUB_TYPE_CREATE = "EVENT_SUB_TYPE_CREATE", p.EVENT_SUB_TYPE_UPDATE = "EVENT_SUB_TYPE_UPDATE", p.EVENT_SUB_TYPE_DELETE = "EVENT_SUB_TYPE_DELETE", p.EVENT_SUB_TYPE_ADD = "EVENT_SUB_TYPE_ADD", p.EVENT_SUB_TYPE_REMOVE = "EVENT_SUB_TYPE_REMOVE", p.EVENT_SUB_TYPE_STATE = "EVENT_SUB_TYPE_STATE";
  })(_e = a.EventSubType || (a.EventSubType = {}));
  function ve(p) {
    switch (p) {
      case 0:
      case "EVENT_SUB_TYPE_UNSPECIFIED":
        return _e.EVENT_SUB_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_SUB_TYPE_CREATE":
        return _e.EVENT_SUB_TYPE_CREATE;
      case 2:
      case "EVENT_SUB_TYPE_UPDATE":
        return _e.EVENT_SUB_TYPE_UPDATE;
      case 3:
      case "EVENT_SUB_TYPE_DELETE":
        return _e.EVENT_SUB_TYPE_DELETE;
      case 4:
      case "EVENT_SUB_TYPE_ADD":
        return _e.EVENT_SUB_TYPE_ADD;
      case 5:
      case "EVENT_SUB_TYPE_REMOVE":
        return _e.EVENT_SUB_TYPE_REMOVE;
      case 6:
      case "EVENT_SUB_TYPE_STATE":
        return _e.EVENT_SUB_TYPE_STATE;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum EventSubType");
    }
  }
  a.eventSubTypeFromJSON = ve;
  function De(p) {
    switch (p) {
      case _e.EVENT_SUB_TYPE_UNSPECIFIED:
        return "EVENT_SUB_TYPE_UNSPECIFIED";
      case _e.EVENT_SUB_TYPE_CREATE:
        return "EVENT_SUB_TYPE_CREATE";
      case _e.EVENT_SUB_TYPE_UPDATE:
        return "EVENT_SUB_TYPE_UPDATE";
      case _e.EVENT_SUB_TYPE_DELETE:
        return "EVENT_SUB_TYPE_DELETE";
      case _e.EVENT_SUB_TYPE_ADD:
        return "EVENT_SUB_TYPE_ADD";
      case _e.EVENT_SUB_TYPE_REMOVE:
        return "EVENT_SUB_TYPE_REMOVE";
      case _e.EVENT_SUB_TYPE_STATE:
        return "EVENT_SUB_TYPE_STATE";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum EventSubType");
    }
  }
  a.eventSubTypeToJSON = De;
  function Ze(p) {
    switch (p) {
      case _e.EVENT_SUB_TYPE_UNSPECIFIED:
        return 0;
      case _e.EVENT_SUB_TYPE_CREATE:
        return 1;
      case _e.EVENT_SUB_TYPE_UPDATE:
        return 2;
      case _e.EVENT_SUB_TYPE_DELETE:
        return 3;
      case _e.EVENT_SUB_TYPE_ADD:
        return 4;
      case _e.EVENT_SUB_TYPE_REMOVE:
        return 5;
      case _e.EVENT_SUB_TYPE_STATE:
        return 6;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum EventSubType");
    }
  }
  a.eventSubTypeToNumber = Ze;
  var Qe;
  (function(p) {
    p.EVENT_TYPE_UNSPECIFIED = "EVENT_TYPE_UNSPECIFIED", p.EVENT_TYPE_COLLECTION = "EVENT_TYPE_COLLECTION", p.EVENT_TYPE_PROJECT = "EVENT_TYPE_PROJECT", p.EVENT_TYPE_SOURCE = "EVENT_TYPE_SOURCE", p.EVENT_TYPE_DESTINATION = "EVENT_TYPE_DESTINATION";
  })(Qe = a.EventType || (a.EventType = {}));
  function ot(p) {
    switch (p) {
      case 0:
      case "EVENT_TYPE_UNSPECIFIED":
        return Qe.EVENT_TYPE_UNSPECIFIED;
      case 1:
      case "EVENT_TYPE_COLLECTION":
        return Qe.EVENT_TYPE_COLLECTION;
      case 2:
      case "EVENT_TYPE_PROJECT":
        return Qe.EVENT_TYPE_PROJECT;
      case 4:
      case "EVENT_TYPE_SOURCE":
        return Qe.EVENT_TYPE_SOURCE;
      case 5:
      case "EVENT_TYPE_DESTINATION":
        return Qe.EVENT_TYPE_DESTINATION;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum EventType");
    }
  }
  a.eventTypeFromJSON = ot;
  function ft(p) {
    switch (p) {
      case Qe.EVENT_TYPE_UNSPECIFIED:
        return "EVENT_TYPE_UNSPECIFIED";
      case Qe.EVENT_TYPE_COLLECTION:
        return "EVENT_TYPE_COLLECTION";
      case Qe.EVENT_TYPE_PROJECT:
        return "EVENT_TYPE_PROJECT";
      case Qe.EVENT_TYPE_SOURCE:
        return "EVENT_TYPE_SOURCE";
      case Qe.EVENT_TYPE_DESTINATION:
        return "EVENT_TYPE_DESTINATION";
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum EventType");
    }
  }
  a.eventTypeToJSON = ft;
  function Ce(p) {
    switch (p) {
      case Qe.EVENT_TYPE_UNSPECIFIED:
        return 0;
      case Qe.EVENT_TYPE_COLLECTION:
        return 1;
      case Qe.EVENT_TYPE_PROJECT:
        return 2;
      case Qe.EVENT_TYPE_SOURCE:
        return 4;
      case Qe.EVENT_TYPE_DESTINATION:
        return 5;
      default:
        throw new Ke.Error("Unrecognized enum value " + p + " for enum EventType");
    }
  }
  a.eventTypeToNumber = Ce;
  function I() {
    return { height: void 0, width: void 0, framerate: void 0, colorSpace: void 0 };
  }
  a.VideoRendering = {
    encode(p, b = c.default.Writer.create()) {
      return p.height !== void 0 && b.uint32(8).uint32(p.height), p.width !== void 0 && b.uint32(16).uint32(p.width), p.framerate !== void 0 && b.uint32(29).float(p.framerate), p.colorSpace !== void 0 && b.uint32(32).int32(V(p.colorSpace)), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = I();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.height = T.uint32();
            break;
          case 2:
            U.width = T.uint32();
            break;
          case 3:
            U.framerate = T.float();
            break;
          case 4:
            U.colorSpace = $(T.int32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        height: ce(p.height) ? Number(p.height) : void 0,
        width: ce(p.width) ? Number(p.width) : void 0,
        framerate: ce(p.framerate) ? Number(p.framerate) : void 0,
        colorSpace: ce(p.colorSpace) ? $(p.colorSpace) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.height !== void 0 && (b.height = Math.round(p.height)), p.width !== void 0 && (b.width = Math.round(p.width)), p.framerate !== void 0 && (b.framerate = p.framerate), p.colorSpace !== void 0 && (b.colorSpace = p.colorSpace !== void 0 ? J(p.colorSpace) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K, U;
      const te = I();
      return te.height = (b = p.height) !== null && b !== void 0 ? b : void 0, te.width = (T = p.width) !== null && T !== void 0 ? T : void 0, te.framerate = (K = p.framerate) !== null && K !== void 0 ? K : void 0, te.colorSpace = (U = p.colorSpace) !== null && U !== void 0 ? U : void 0, te;
    }
  };
  function F() {
    return { channelLayout: void 0 };
  }
  a.AudioRendering = {
    encode(p, b = c.default.Writer.create()) {
      return p.channelLayout !== void 0 && b.uint32(8).int32(B(p.channelLayout)), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = F();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.channelLayout = G(T.int32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        channelLayout: ce(p.channelLayout) ? G(p.channelLayout) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.channelLayout !== void 0 && (b.channelLayout = p.channelLayout !== void 0 ? H(p.channelLayout) : void 0), b;
    },
    fromPartial(p) {
      var b;
      const T = F();
      return T.channelLayout = (b = p.channelLayout) !== null && b !== void 0 ? b : void 0, T;
    }
  };
  function z() {
    return { video: void 0, audio: void 0, quality: void 0, targetLatency: void 0, complexity: void 0 };
  }
  a.Rendering = {
    encode(p, b = c.default.Writer.create()) {
      return p.video !== void 0 && a.VideoRendering.encode(p.video, b.uint32(10).fork()).ldelim(), p.audio !== void 0 && a.AudioRendering.encode(p.audio, b.uint32(18).fork()).ldelim(), p.quality !== void 0 && b.uint32(24).int32(re(p.quality)), p.targetLatency !== void 0 && b.uint32(32).uint32(p.targetLatency), p.complexity !== void 0 && b.uint32(40).int32(p.complexity), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = z();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.video = a.VideoRendering.decode(T, T.uint32());
            break;
          case 2:
            U.audio = a.AudioRendering.decode(T, T.uint32());
            break;
          case 3:
            U.quality = ne(T.int32());
            break;
          case 4:
            U.targetLatency = T.uint32();
            break;
          case 5:
            U.complexity = T.int32();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        video: ce(p.video) ? a.VideoRendering.fromJSON(p.video) : void 0,
        audio: ce(p.audio) ? a.AudioRendering.fromJSON(p.audio) : void 0,
        quality: ce(p.quality) ? ne(p.quality) : void 0,
        targetLatency: ce(p.targetLatency) ? Number(p.targetLatency) : void 0,
        complexity: ce(p.complexity) ? Number(p.complexity) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.video !== void 0 && (b.video = p.video ? a.VideoRendering.toJSON(p.video) : void 0), p.audio !== void 0 && (b.audio = p.audio ? a.AudioRendering.toJSON(p.audio) : void 0), p.quality !== void 0 && (b.quality = p.quality !== void 0 ? Z(p.quality) : void 0), p.targetLatency !== void 0 && (b.targetLatency = Math.round(p.targetLatency)), p.complexity !== void 0 && (b.complexity = Math.round(p.complexity)), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = z();
      return U.video = p.video !== void 0 && p.video !== null ? a.VideoRendering.fromPartial(p.video) : void 0, U.audio = p.audio !== void 0 && p.audio !== null ? a.AudioRendering.fromPartial(p.audio) : void 0, U.quality = (b = p.quality) !== null && b !== void 0 ? b : void 0, U.targetLatency = (T = p.targetLatency) !== null && T !== void 0 ? T : void 0, U.complexity = (K = p.complexity) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function Te() {
    return { mode: void 0, targetBitrate: void 0, maxKeyFrameInterval: void 0 };
  }
  a.VideoCodecRateControl = {
    encode(p, b = c.default.Writer.create()) {
      return p.mode !== void 0 && b.uint32(8).int32($e(p.mode)), p.targetBitrate !== void 0 && b.uint32(16).uint32(p.targetBitrate), p.maxKeyFrameInterval !== void 0 && b.uint32(24).uint32(p.maxKeyFrameInterval), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Te();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.mode = Ne(T.int32());
            break;
          case 2:
            U.targetBitrate = T.uint32();
            break;
          case 3:
            U.maxKeyFrameInterval = T.uint32();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        mode: ce(p.mode) ? Ne(p.mode) : void 0,
        targetBitrate: ce(p.targetBitrate) ? Number(p.targetBitrate) : void 0,
        maxKeyFrameInterval: ce(p.maxKeyFrameInterval) ? Number(p.maxKeyFrameInterval) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.mode !== void 0 && (b.mode = p.mode !== void 0 ? Le(p.mode) : void 0), p.targetBitrate !== void 0 && (b.targetBitrate = Math.round(p.targetBitrate)), p.maxKeyFrameInterval !== void 0 && (b.maxKeyFrameInterval = Math.round(p.maxKeyFrameInterval)), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = Te();
      return U.mode = (b = p.mode) !== null && b !== void 0 ? b : void 0, U.targetBitrate = (T = p.targetBitrate) !== null && T !== void 0 ? T : void 0, U.maxKeyFrameInterval = (K = p.maxKeyFrameInterval) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function fe() {
    return { codec: void 0, rateControl: void 0, profile: void 0 };
  }
  a.VideoEncoding = {
    encode(p, b = c.default.Writer.create()) {
      return p.codec !== void 0 && b.uint32(8).int32(N(p.codec)), p.rateControl !== void 0 && a.VideoCodecRateControl.encode(p.rateControl, b.uint32(18).fork()).ldelim(), p.profile !== void 0 && b.uint32(32).int32(ae(p.profile)), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = fe();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.codec = de(T.int32());
            break;
          case 2:
            U.rateControl = a.VideoCodecRateControl.decode(T, T.uint32());
            break;
          case 4:
            U.profile = W(T.int32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        codec: ce(p.codec) ? de(p.codec) : void 0,
        rateControl: ce(p.rateControl) ? a.VideoCodecRateControl.fromJSON(p.rateControl) : void 0,
        profile: ce(p.profile) ? W(p.profile) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.codec !== void 0 && (b.codec = p.codec !== void 0 ? A(p.codec) : void 0), p.rateControl !== void 0 && (b.rateControl = p.rateControl ? a.VideoCodecRateControl.toJSON(p.rateControl) : void 0), p.profile !== void 0 && (b.profile = p.profile !== void 0 ? ee(p.profile) : void 0), b;
    },
    fromPartial(p) {
      var b, T;
      const K = fe();
      return K.codec = (b = p.codec) !== null && b !== void 0 ? b : void 0, K.rateControl = p.rateControl !== void 0 && p.rateControl !== null ? a.VideoCodecRateControl.fromPartial(p.rateControl) : void 0, K.profile = (T = p.profile) !== null && T !== void 0 ? T : void 0, K;
    }
  };
  function ke() {
    return { codec: void 0 };
  }
  a.AudioEncoding = {
    encode(p, b = c.default.Writer.create()) {
      return p.codec !== void 0 && b.uint32(8).int32(we(p.codec)), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = ke();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.codec = he(T.int32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { codec: ce(p.codec) ? he(p.codec) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.codec !== void 0 && (b.codec = p.codec !== void 0 ? le(p.codec) : void 0), b;
    },
    fromPartial(p) {
      var b;
      const T = ke();
      return T.codec = (b = p.codec) !== null && b !== void 0 ? b : void 0, T;
    }
  };
  function it() {
    return { video: void 0, audio: void 0 };
  }
  a.Encoding = {
    encode(p, b = c.default.Writer.create()) {
      return p.video !== void 0 && a.VideoEncoding.encode(p.video, b.uint32(10).fork()).ldelim(), p.audio !== void 0 && a.AudioEncoding.encode(p.audio, b.uint32(18).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = it();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.video = a.VideoEncoding.decode(T, T.uint32());
            break;
          case 2:
            U.audio = a.AudioEncoding.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        video: ce(p.video) ? a.VideoEncoding.fromJSON(p.video) : void 0,
        audio: ce(p.audio) ? a.AudioEncoding.fromJSON(p.audio) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.video !== void 0 && (b.video = p.video ? a.VideoEncoding.toJSON(p.video) : void 0), p.audio !== void 0 && (b.audio = p.audio ? a.AudioEncoding.toJSON(p.audio) : void 0), b;
    },
    fromPartial(p) {
      const b = it();
      return b.video = p.video !== void 0 && p.video !== null ? a.VideoEncoding.fromPartial(p.video) : void 0, b.audio = p.audio !== void 0 && p.audio !== null ? a.AudioEncoding.fromPartial(p.audio) : void 0, b;
    }
  };
  function mt() {
    return {
      enabled: void 0,
      key: void 0,
      url: void 0,
      baseUrl: void 0,
      previewUrl: void 0,
      ingestId: void 0,
      secure: void 0,
      ingestType: void 0
    };
  }
  a.SourceRtmpPushAddress = {
    encode(p, b = c.default.Writer.create()) {
      return p.enabled !== void 0 && b.uint32(8).bool(p.enabled), p.key !== void 0 && b.uint32(18).string(p.key), p.url !== void 0 && b.uint32(26).string(p.url), p.baseUrl !== void 0 && b.uint32(34).string(p.baseUrl), p.previewUrl !== void 0 && b.uint32(42).string(p.previewUrl), p.ingestId !== void 0 && b.uint32(50).string(p.ingestId), p.secure !== void 0 && b.uint32(56).bool(p.secure), p.ingestType !== void 0 && b.uint32(66).string(p.ingestType), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = mt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.enabled = T.bool();
            break;
          case 2:
            U.key = T.string();
            break;
          case 3:
            U.url = T.string();
            break;
          case 4:
            U.baseUrl = T.string();
            break;
          case 5:
            U.previewUrl = T.string();
            break;
          case 6:
            U.ingestId = T.string();
            break;
          case 7:
            U.secure = T.bool();
            break;
          case 8:
            U.ingestType = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        enabled: ce(p.enabled) ? !!p.enabled : void 0,
        key: ce(p.key) ? String(p.key) : void 0,
        url: ce(p.url) ? String(p.url) : void 0,
        baseUrl: ce(p.baseUrl) ? String(p.baseUrl) : void 0,
        previewUrl: ce(p.previewUrl) ? String(p.previewUrl) : void 0,
        ingestId: ce(p.ingestId) ? String(p.ingestId) : void 0,
        secure: ce(p.secure) ? !!p.secure : void 0,
        ingestType: ce(p.ingestType) ? String(p.ingestType) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.enabled !== void 0 && (b.enabled = p.enabled), p.key !== void 0 && (b.key = p.key), p.url !== void 0 && (b.url = p.url), p.baseUrl !== void 0 && (b.baseUrl = p.baseUrl), p.previewUrl !== void 0 && (b.previewUrl = p.previewUrl), p.ingestId !== void 0 && (b.ingestId = p.ingestId), p.secure !== void 0 && (b.secure = p.secure), p.ingestType !== void 0 && (b.ingestType = p.ingestType), b;
    },
    fromPartial(p) {
      var b, T, K, U, te, We, et, dt;
      const lt = mt();
      return lt.enabled = (b = p.enabled) !== null && b !== void 0 ? b : void 0, lt.key = (T = p.key) !== null && T !== void 0 ? T : void 0, lt.url = (K = p.url) !== null && K !== void 0 ? K : void 0, lt.baseUrl = (U = p.baseUrl) !== null && U !== void 0 ? U : void 0, lt.previewUrl = (te = p.previewUrl) !== null && te !== void 0 ? te : void 0, lt.ingestId = (We = p.ingestId) !== null && We !== void 0 ? We : void 0, lt.secure = (et = p.secure) !== null && et !== void 0 ? et : void 0, lt.ingestType = (dt = p.ingestType) !== null && dt !== void 0 ? dt : void 0, lt;
    }
  };
  function vt() {
    return {
      enabled: void 0,
      streamId: void 0,
      url: void 0,
      baseUrl: void 0,
      previewUrl: void 0,
      ingestId: void 0,
      ingestType: void 0
    };
  }
  a.SrtPushAddress = {
    encode(p, b = c.default.Writer.create()) {
      return p.enabled !== void 0 && b.uint32(8).bool(p.enabled), p.streamId !== void 0 && b.uint32(18).string(p.streamId), p.url !== void 0 && b.uint32(26).string(p.url), p.baseUrl !== void 0 && b.uint32(34).string(p.baseUrl), p.previewUrl !== void 0 && b.uint32(42).string(p.previewUrl), p.ingestId !== void 0 && b.uint32(50).string(p.ingestId), p.ingestType !== void 0 && b.uint32(58).string(p.ingestType), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = vt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.enabled = T.bool();
            break;
          case 2:
            U.streamId = T.string();
            break;
          case 3:
            U.url = T.string();
            break;
          case 4:
            U.baseUrl = T.string();
            break;
          case 5:
            U.previewUrl = T.string();
            break;
          case 6:
            U.ingestId = T.string();
            break;
          case 7:
            U.ingestType = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        enabled: ce(p.enabled) ? !!p.enabled : void 0,
        streamId: ce(p.streamId) ? String(p.streamId) : void 0,
        url: ce(p.url) ? String(p.url) : void 0,
        baseUrl: ce(p.baseUrl) ? String(p.baseUrl) : void 0,
        previewUrl: ce(p.previewUrl) ? String(p.previewUrl) : void 0,
        ingestId: ce(p.ingestId) ? String(p.ingestId) : void 0,
        ingestType: ce(p.ingestType) ? String(p.ingestType) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.enabled !== void 0 && (b.enabled = p.enabled), p.streamId !== void 0 && (b.streamId = p.streamId), p.url !== void 0 && (b.url = p.url), p.baseUrl !== void 0 && (b.baseUrl = p.baseUrl), p.previewUrl !== void 0 && (b.previewUrl = p.previewUrl), p.ingestId !== void 0 && (b.ingestId = p.ingestId), p.ingestType !== void 0 && (b.ingestType = p.ingestType), b;
    },
    fromPartial(p) {
      var b, T, K, U, te, We, et;
      const dt = vt();
      return dt.enabled = (b = p.enabled) !== null && b !== void 0 ? b : void 0, dt.streamId = (T = p.streamId) !== null && T !== void 0 ? T : void 0, dt.url = (K = p.url) !== null && K !== void 0 ? K : void 0, dt.baseUrl = (U = p.baseUrl) !== null && U !== void 0 ? U : void 0, dt.previewUrl = (te = p.previewUrl) !== null && te !== void 0 ? te : void 0, dt.ingestId = (We = p.ingestId) !== null && We !== void 0 ? We : void 0, dt.ingestType = (et = p.ingestType) !== null && et !== void 0 ? et : void 0, dt;
    }
  };
  function st() {
    return { url: "" };
  }
  a.RtmpPullAddress = {
    encode(p, b = c.default.Writer.create()) {
      return p.url !== "" && b.uint32(10).string(p.url), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = st();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.url = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { url: ce(p.url) ? String(p.url) : "" };
    },
    toJSON(p) {
      const b = {};
      return p.url !== void 0 && (b.url = p.url), b;
    },
    fromPartial(p) {
      var b;
      const T = st();
      return T.url = (b = p.url) !== null && b !== void 0 ? b : "", T;
    }
  };
  function ut() {
    return { url: "" };
  }
  a.SrtPullAddress = {
    encode(p, b = c.default.Writer.create()) {
      return p.url !== "" && b.uint32(10).string(p.url), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = ut();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.url = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { url: ce(p.url) ? String(p.url) : "" };
    },
    toJSON(p) {
      const b = {};
      return p.url !== void 0 && (b.url = p.url), b;
    },
    fromPartial(p) {
      var b;
      const T = ut();
      return T.url = (b = p.url) !== null && b !== void 0 ? b : "", T;
    }
  };
  function yt() {
    return { rtmpPush: void 0, srtPush: void 0, rtmpPull: void 0, srtPull: void 0 };
  }
  a.SourceAddress = {
    encode(p, b = c.default.Writer.create()) {
      return p.rtmpPush !== void 0 && a.SourceRtmpPushAddress.encode(p.rtmpPush, b.uint32(10).fork()).ldelim(), p.srtPush !== void 0 && a.SrtPushAddress.encode(p.srtPush, b.uint32(18).fork()).ldelim(), p.rtmpPull !== void 0 && a.RtmpPullAddress.encode(p.rtmpPull, b.uint32(26).fork()).ldelim(), p.srtPull !== void 0 && a.SrtPullAddress.encode(p.srtPull, b.uint32(34).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = yt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.rtmpPush = a.SourceRtmpPushAddress.decode(T, T.uint32());
            break;
          case 2:
            U.srtPush = a.SrtPushAddress.decode(T, T.uint32());
            break;
          case 3:
            U.rtmpPull = a.RtmpPullAddress.decode(T, T.uint32());
            break;
          case 4:
            U.srtPull = a.SrtPullAddress.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        rtmpPush: ce(p.rtmpPush) ? a.SourceRtmpPushAddress.fromJSON(p.rtmpPush) : void 0,
        srtPush: ce(p.srtPush) ? a.SrtPushAddress.fromJSON(p.srtPush) : void 0,
        rtmpPull: ce(p.rtmpPull) ? a.RtmpPullAddress.fromJSON(p.rtmpPull) : void 0,
        srtPull: ce(p.srtPull) ? a.SrtPullAddress.fromJSON(p.srtPull) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.rtmpPush !== void 0 && (b.rtmpPush = p.rtmpPush ? a.SourceRtmpPushAddress.toJSON(p.rtmpPush) : void 0), p.srtPush !== void 0 && (b.srtPush = p.srtPush ? a.SrtPushAddress.toJSON(p.srtPush) : void 0), p.rtmpPull !== void 0 && (b.rtmpPull = p.rtmpPull ? a.RtmpPullAddress.toJSON(p.rtmpPull) : void 0), p.srtPull !== void 0 && (b.srtPull = p.srtPull ? a.SrtPullAddress.toJSON(p.srtPull) : void 0), b;
    },
    fromPartial(p) {
      const b = yt();
      return b.rtmpPush = p.rtmpPush !== void 0 && p.rtmpPush !== null ? a.SourceRtmpPushAddress.fromPartial(p.rtmpPush) : void 0, b.srtPush = p.srtPush !== void 0 && p.srtPush !== null ? a.SrtPushAddress.fromPartial(p.srtPush) : void 0, b.rtmpPull = p.rtmpPull !== void 0 && p.rtmpPull !== null ? a.RtmpPullAddress.fromPartial(p.rtmpPull) : void 0, b.srtPull = p.srtPull !== void 0 && p.srtPull !== null ? a.SrtPullAddress.fromPartial(p.srtPull) : void 0, b;
    }
  };
  function gt() {
    return { key: void 0, url: "" };
  }
  a.DestinationRtmpPushAddress = {
    encode(p, b = c.default.Writer.create()) {
      return p.key !== void 0 && b.uint32(10).string(p.key), p.url !== "" && b.uint32(18).string(p.url), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = gt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.key = T.string();
            break;
          case 2:
            U.url = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        key: ce(p.key) ? String(p.key) : void 0,
        url: ce(p.url) ? String(p.url) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.key !== void 0 && (b.key = p.key), p.url !== void 0 && (b.url = p.url), b;
    },
    fromPartial(p) {
      var b, T;
      const K = gt();
      return K.key = (b = p.key) !== null && b !== void 0 ? b : void 0, K.url = (T = p.url) !== null && T !== void 0 ? T : "", K;
    }
  };
  function bt() {
    return { url: "" };
  }
  a.DestinationSrtPushAddress = {
    encode(p, b = c.default.Writer.create()) {
      return p.url !== "" && b.uint32(18).string(p.url), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = bt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 2:
            U.url = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { url: ce(p.url) ? String(p.url) : "" };
    },
    toJSON(p) {
      const b = {};
      return p.url !== void 0 && (b.url = p.url), b;
    },
    fromPartial(p) {
      var b;
      const T = bt();
      return T.url = (b = p.url) !== null && b !== void 0 ? b : "", T;
    }
  };
  function St() {
    return { appId: "", channelId: "", userId: "" };
  }
  a.DestinationAgoraPushAddress = {
    encode(p, b = c.default.Writer.create()) {
      return p.appId !== "" && b.uint32(10).string(p.appId), p.channelId !== "" && b.uint32(18).string(p.channelId), p.userId !== "" && b.uint32(26).string(p.userId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = St();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.appId = T.string();
            break;
          case 2:
            U.channelId = T.string();
            break;
          case 3:
            U.userId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        appId: ce(p.appId) ? String(p.appId) : "",
        channelId: ce(p.channelId) ? String(p.channelId) : "",
        userId: ce(p.userId) ? String(p.userId) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.appId !== void 0 && (b.appId = p.appId), p.channelId !== void 0 && (b.channelId = p.channelId), p.userId !== void 0 && (b.userId = p.userId), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = St();
      return U.appId = (b = p.appId) !== null && b !== void 0 ? b : "", U.channelId = (T = p.channelId) !== null && T !== void 0 ? T : "", U.userId = (K = p.userId) !== null && K !== void 0 ? K : "", U;
    }
  };
  function Et() {
    return { playlistCount: void 0, fileCount: void 0 };
  }
  a.HlsLifecycleLive = {
    encode(p, b = c.default.Writer.create()) {
      return p.playlistCount !== void 0 && b.uint32(8).int32(p.playlistCount), p.fileCount !== void 0 && b.uint32(16).int32(p.fileCount), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Et();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.playlistCount = T.int32();
            break;
          case 2:
            U.fileCount = T.int32();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        playlistCount: ce(p.playlistCount) ? Number(p.playlistCount) : void 0,
        fileCount: ce(p.fileCount) ? Number(p.fileCount) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.playlistCount !== void 0 && (b.playlistCount = Math.round(p.playlistCount)), p.fileCount !== void 0 && (b.fileCount = Math.round(p.fileCount)), b;
    },
    fromPartial(p) {
      var b, T;
      const K = Et();
      return K.playlistCount = (b = p.playlistCount) !== null && b !== void 0 ? b : void 0, K.fileCount = (T = p.fileCount) !== null && T !== void 0 ? T : void 0, K;
    }
  };
  function ct() {
    return { maxDuration: void 0 };
  }
  a.HlsLifecycleVod = {
    encode(p, b = c.default.Writer.create()) {
      return p.maxDuration !== void 0 && b.uint32(8).int32(p.maxDuration), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = ct();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.maxDuration = T.int32();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), b;
    },
    fromPartial(p) {
      var b;
      const T = ct();
      return T.maxDuration = (b = p.maxDuration) !== null && b !== void 0 ? b : void 0, T;
    }
  };
  function Xe() {
    return { vod: void 0, live: void 0 };
  }
  a.HlsLifecycle = {
    encode(p, b = c.default.Writer.create()) {
      return p.vod !== void 0 && a.HlsLifecycleVod.encode(p.vod, b.uint32(10).fork()).ldelim(), p.live !== void 0 && a.HlsLifecycleLive.encode(p.live, b.uint32(18).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Xe();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.vod = a.HlsLifecycleVod.decode(T, T.uint32());
            break;
          case 2:
            U.live = a.HlsLifecycleLive.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        vod: ce(p.vod) ? a.HlsLifecycleVod.fromJSON(p.vod) : void 0,
        live: ce(p.live) ? a.HlsLifecycleLive.fromJSON(p.live) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.vod !== void 0 && (b.vod = p.vod ? a.HlsLifecycleVod.toJSON(p.vod) : void 0), p.live !== void 0 && (b.live = p.live ? a.HlsLifecycleLive.toJSON(p.live) : void 0), b;
    },
    fromPartial(p) {
      const b = Xe();
      return b.vod = p.vod !== void 0 && p.vod !== null ? a.HlsLifecycleVod.fromPartial(p.vod) : void 0, b.live = p.live !== void 0 && p.live !== null ? a.HlsLifecycleLive.fromPartial(p.live) : void 0, b;
    }
  };
  function Ct() {
    return { lifecycle: void 0, segmentDuration: void 0 };
  }
  a.HlsPackaging = {
    encode(p, b = c.default.Writer.create()) {
      return p.lifecycle !== void 0 && a.HlsLifecycle.encode(p.lifecycle, b.uint32(10).fork()).ldelim(), p.segmentDuration !== void 0 && b.uint32(16).int32(p.segmentDuration), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Ct();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.lifecycle = a.HlsLifecycle.decode(T, T.uint32());
            break;
          case 2:
            U.segmentDuration = T.int32();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        lifecycle: ce(p.lifecycle) ? a.HlsLifecycle.fromJSON(p.lifecycle) : void 0,
        segmentDuration: ce(p.segmentDuration) ? Number(p.segmentDuration) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.lifecycle !== void 0 && (b.lifecycle = p.lifecycle ? a.HlsLifecycle.toJSON(p.lifecycle) : void 0), p.segmentDuration !== void 0 && (b.segmentDuration = Math.round(p.segmentDuration)), b;
    },
    fromPartial(p) {
      var b;
      const T = Ct();
      return T.lifecycle = p.lifecycle !== void 0 && p.lifecycle !== null ? a.HlsLifecycle.fromPartial(p.lifecycle) : void 0, T.segmentDuration = (b = p.segmentDuration) !== null && b !== void 0 ? b : void 0, T;
    }
  };
  function Ot() {
    return { hls: void 0 };
  }
  a.ObjectStoragePackaging = {
    encode(p, b = c.default.Writer.create()) {
      return p.hls !== void 0 && a.HlsPackaging.encode(p.hls, b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Ot();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.hls = a.HlsPackaging.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { hls: ce(p.hls) ? a.HlsPackaging.fromJSON(p.hls) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.hls !== void 0 && (b.hls = p.hls ? a.HlsPackaging.toJSON(p.hls) : void 0), b;
    },
    fromPartial(p) {
      const b = Ot();
      return b.hls = p.hls !== void 0 && p.hls !== null ? a.HlsPackaging.fromPartial(p.hls) : void 0, b;
    }
  };
  function Nt() {
    return {
      region: "",
      bucket: "",
      prefix: void 0,
      accessKey: "",
      secretKey: "",
      token: void 0,
      tokenDuration: void 0,
      acl: void 0,
      endpoint: void 0,
      packaging: void 0
    };
  }
  a.S3StorageAddress = {
    encode(p, b = c.default.Writer.create()) {
      return p.region !== "" && b.uint32(10).string(p.region), p.bucket !== "" && b.uint32(18).string(p.bucket), p.prefix !== void 0 && b.uint32(26).string(p.prefix), p.accessKey !== "" && b.uint32(34).string(p.accessKey), p.secretKey !== "" && b.uint32(42).string(p.secretKey), p.token !== void 0 && b.uint32(50).string(p.token), p.tokenDuration !== void 0 && b.uint32(56).int32(p.tokenDuration), p.acl !== void 0 && b.uint32(64).int32(xe(p.acl)), p.endpoint !== void 0 && b.uint32(74).string(p.endpoint), p.packaging !== void 0 && a.ObjectStoragePackaging.encode(p.packaging, b.uint32(82).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Nt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.region = T.string();
            break;
          case 2:
            U.bucket = T.string();
            break;
          case 3:
            U.prefix = T.string();
            break;
          case 4:
            U.accessKey = T.string();
            break;
          case 5:
            U.secretKey = T.string();
            break;
          case 6:
            U.token = T.string();
            break;
          case 7:
            U.tokenDuration = T.int32();
            break;
          case 8:
            U.acl = Ae(T.int32());
            break;
          case 9:
            U.endpoint = T.string();
            break;
          case 10:
            U.packaging = a.ObjectStoragePackaging.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        region: ce(p.region) ? String(p.region) : "",
        bucket: ce(p.bucket) ? String(p.bucket) : "",
        prefix: ce(p.prefix) ? String(p.prefix) : void 0,
        accessKey: ce(p.accessKey) ? String(p.accessKey) : "",
        secretKey: ce(p.secretKey) ? String(p.secretKey) : "",
        token: ce(p.token) ? String(p.token) : void 0,
        tokenDuration: ce(p.tokenDuration) ? Number(p.tokenDuration) : void 0,
        acl: ce(p.acl) ? Ae(p.acl) : void 0,
        endpoint: ce(p.endpoint) ? String(p.endpoint) : void 0,
        packaging: ce(p.packaging) ? a.ObjectStoragePackaging.fromJSON(p.packaging) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.region !== void 0 && (b.region = p.region), p.bucket !== void 0 && (b.bucket = p.bucket), p.prefix !== void 0 && (b.prefix = p.prefix), p.accessKey !== void 0 && (b.accessKey = p.accessKey), p.secretKey !== void 0 && (b.secretKey = p.secretKey), p.token !== void 0 && (b.token = p.token), p.tokenDuration !== void 0 && (b.tokenDuration = Math.round(p.tokenDuration)), p.acl !== void 0 && (b.acl = p.acl !== void 0 ? qe(p.acl) : void 0), p.endpoint !== void 0 && (b.endpoint = p.endpoint), p.packaging !== void 0 && (b.packaging = p.packaging ? a.ObjectStoragePackaging.toJSON(p.packaging) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K, U, te, We, et, dt, lt;
      const pt = Nt();
      return pt.region = (b = p.region) !== null && b !== void 0 ? b : "", pt.bucket = (T = p.bucket) !== null && T !== void 0 ? T : "", pt.prefix = (K = p.prefix) !== null && K !== void 0 ? K : void 0, pt.accessKey = (U = p.accessKey) !== null && U !== void 0 ? U : "", pt.secretKey = (te = p.secretKey) !== null && te !== void 0 ? te : "", pt.token = (We = p.token) !== null && We !== void 0 ? We : void 0, pt.tokenDuration = (et = p.tokenDuration) !== null && et !== void 0 ? et : void 0, pt.acl = (dt = p.acl) !== null && dt !== void 0 ? dt : void 0, pt.endpoint = (lt = p.endpoint) !== null && lt !== void 0 ? lt : void 0, pt.packaging = p.packaging !== void 0 && p.packaging !== null ? a.ObjectStoragePackaging.fromPartial(p.packaging) : void 0, pt;
    }
  };
  function Pt() {
    return { rtmpPush: void 0, agora: void 0, s3Storage: void 0, srtPush: void 0 };
  }
  a.DestinationAddress = {
    encode(p, b = c.default.Writer.create()) {
      return p.rtmpPush !== void 0 && a.DestinationRtmpPushAddress.encode(p.rtmpPush, b.uint32(10).fork()).ldelim(), p.agora !== void 0 && a.DestinationAgoraPushAddress.encode(p.agora, b.uint32(18).fork()).ldelim(), p.s3Storage !== void 0 && a.S3StorageAddress.encode(p.s3Storage, b.uint32(26).fork()).ldelim(), p.srtPush !== void 0 && a.DestinationSrtPushAddress.encode(p.srtPush, b.uint32(34).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Pt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.rtmpPush = a.DestinationRtmpPushAddress.decode(T, T.uint32());
            break;
          case 2:
            U.agora = a.DestinationAgoraPushAddress.decode(T, T.uint32());
            break;
          case 3:
            U.s3Storage = a.S3StorageAddress.decode(T, T.uint32());
            break;
          case 4:
            U.srtPush = a.DestinationSrtPushAddress.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        rtmpPush: ce(p.rtmpPush) ? a.DestinationRtmpPushAddress.fromJSON(p.rtmpPush) : void 0,
        agora: ce(p.agora) ? a.DestinationAgoraPushAddress.fromJSON(p.agora) : void 0,
        s3Storage: ce(p.s3Storage) ? a.S3StorageAddress.fromJSON(p.s3Storage) : void 0,
        srtPush: ce(p.srtPush) ? a.DestinationSrtPushAddress.fromJSON(p.srtPush) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.rtmpPush !== void 0 && (b.rtmpPush = p.rtmpPush ? a.DestinationRtmpPushAddress.toJSON(p.rtmpPush) : void 0), p.agora !== void 0 && (b.agora = p.agora ? a.DestinationAgoraPushAddress.toJSON(p.agora) : void 0), p.s3Storage !== void 0 && (b.s3Storage = p.s3Storage ? a.S3StorageAddress.toJSON(p.s3Storage) : void 0), p.srtPush !== void 0 && (b.srtPush = p.srtPush ? a.DestinationSrtPushAddress.toJSON(p.srtPush) : void 0), b;
    },
    fromPartial(p) {
      const b = Pt();
      return b.rtmpPush = p.rtmpPush !== void 0 && p.rtmpPush !== null ? a.DestinationRtmpPushAddress.fromPartial(p.rtmpPush) : void 0, b.agora = p.agora !== void 0 && p.agora !== null ? a.DestinationAgoraPushAddress.fromPartial(p.agora) : void 0, b.s3Storage = p.s3Storage !== void 0 && p.s3Storage !== null ? a.S3StorageAddress.fromPartial(p.s3Storage) : void 0, b.srtPush = p.srtPush !== void 0 && p.srtPush !== null ? a.DestinationSrtPushAddress.fromPartial(p.srtPush) : void 0, b;
    }
  };
  function wt() {
    return { sourceId: "", start: void 0, stop: void 0 };
  }
  a.SourceTrigger = {
    encode(p, b = c.default.Writer.create()) {
      return p.sourceId !== "" && b.uint32(10).string(p.sourceId), p.start !== void 0 && b.uint32(16).int32(Q(p.start)), p.stop !== void 0 && b.uint32(24).int32(Q(p.stop)), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = wt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.sourceId = T.string();
            break;
          case 2:
            U.start = C(T.int32());
            break;
          case 3:
            U.stop = C(T.int32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        sourceId: ce(p.sourceId) ? String(p.sourceId) : "",
        start: ce(p.start) ? C(p.start) : void 0,
        stop: ce(p.stop) ? C(p.stop) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.start !== void 0 && (b.start = p.start !== void 0 ? x(p.start) : void 0), p.stop !== void 0 && (b.stop = p.stop !== void 0 ? x(p.stop) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = wt();
      return U.sourceId = (b = p.sourceId) !== null && b !== void 0 ? b : "", U.start = (T = p.start) !== null && T !== void 0 ? T : void 0, U.stop = (K = p.stop) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function At() {
    return { stop: void 0 };
  }
  a.WebRtcTrigger = {
    encode(p, b = c.default.Writer.create()) {
      return p.stop !== void 0 && b.uint32(24).int32(Q(p.stop)), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = At();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 3:
            U.stop = C(T.int32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { stop: ce(p.stop) ? C(p.stop) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.stop !== void 0 && (b.stop = p.stop !== void 0 ? x(p.stop) : void 0), b;
    },
    fromPartial(p) {
      var b;
      const T = At();
      return T.stop = (b = p.stop) !== null && b !== void 0 ? b : void 0, T;
    }
  };
  function Dt() {
    return { source: void 0 };
  }
  a.ProjectTrigger = {
    encode(p, b = c.default.Writer.create()) {
      return p.source !== void 0 && a.SourceTrigger.encode(p.source, b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Dt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.source = a.SourceTrigger.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { source: ce(p.source) ? a.SourceTrigger.fromJSON(p.source) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.source !== void 0 && (b.source = p.source ? a.SourceTrigger.toJSON(p.source) : void 0), b;
    },
    fromPartial(p) {
      const b = Dt();
      return b.source = p.source !== void 0 && p.source !== null ? a.SourceTrigger.fromPartial(p.source) : void 0, b;
    }
  };
  function pe() {
    return { enabled: void 0, url: void 0 };
  }
  a.PreviewHlsPullAddress = {
    encode(p, b = c.default.Writer.create()) {
      return p.enabled !== void 0 && b.uint32(8).bool(p.enabled), p.url !== void 0 && b.uint32(18).string(p.url), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = pe();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.enabled = T.bool();
            break;
          case 2:
            U.url = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        enabled: ce(p.enabled) ? !!p.enabled : void 0,
        url: ce(p.url) ? String(p.url) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.enabled !== void 0 && (b.enabled = p.enabled), p.url !== void 0 && (b.url = p.url), b;
    },
    fromPartial(p) {
      var b, T;
      const K = pe();
      return K.enabled = (b = p.enabled) !== null && b !== void 0 ? b : void 0, K.url = (T = p.url) !== null && T !== void 0 ? T : void 0, K;
    }
  };
  function ge() {
    return { enabled: void 0, displayName: void 0, participantId: void 0 };
  }
  a.PreviewWebRtcAddress = {
    encode(p, b = c.default.Writer.create()) {
      return p.enabled !== void 0 && b.uint32(8).bool(p.enabled), p.displayName !== void 0 && b.uint32(18).string(p.displayName), p.participantId !== void 0 && b.uint32(26).string(p.participantId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = ge();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.enabled = T.bool();
            break;
          case 2:
            U.displayName = T.string();
            break;
          case 3:
            U.participantId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        enabled: ce(p.enabled) ? !!p.enabled : void 0,
        displayName: ce(p.displayName) ? String(p.displayName) : void 0,
        participantId: ce(p.participantId) ? String(p.participantId) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.enabled !== void 0 && (b.enabled = p.enabled), p.displayName !== void 0 && (b.displayName = p.displayName), p.participantId !== void 0 && (b.participantId = p.participantId), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = ge();
      return U.enabled = (b = p.enabled) !== null && b !== void 0 ? b : void 0, U.displayName = (T = p.displayName) !== null && T !== void 0 ? T : void 0, U.participantId = (K = p.participantId) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function Re() {
    return { webrtc: void 0 };
  }
  a.PreviewAddress = {
    encode(p, b = c.default.Writer.create()) {
      return p.webrtc !== void 0 && a.PreviewWebRtcAddress.encode(p.webrtc, b.uint32(18).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Re();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 2:
            U.webrtc = a.PreviewWebRtcAddress.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { webrtc: ce(p.webrtc) ? a.PreviewWebRtcAddress.fromJSON(p.webrtc) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.webrtc !== void 0 && (b.webrtc = p.webrtc ? a.PreviewWebRtcAddress.toJSON(p.webrtc) : void 0), b;
    },
    fromPartial(p) {
      const b = Re();
      return b.webrtc = p.webrtc !== void 0 && p.webrtc !== null ? a.PreviewWebRtcAddress.fromPartial(p.webrtc) : void 0, b;
    }
  };
  function Je() {
    return { rendererUrl: void 0, version: void 0 };
  }
  a.StudioSdkComposition = {
    encode(p, b = c.default.Writer.create()) {
      return p.rendererUrl !== void 0 && b.uint32(10).string(p.rendererUrl), p.version !== void 0 && b.uint32(18).string(p.version), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Je();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.rendererUrl = T.string();
            break;
          case 2:
            U.version = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        rendererUrl: ce(p.rendererUrl) ? String(p.rendererUrl) : void 0,
        version: ce(p.version) ? String(p.version) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.rendererUrl !== void 0 && (b.rendererUrl = p.rendererUrl), p.version !== void 0 && (b.version = p.version), b;
    },
    fromPartial(p) {
      var b, T;
      const K = Je();
      return K.rendererUrl = (b = p.rendererUrl) !== null && b !== void 0 ? b : void 0, K.version = (T = p.version) !== null && T !== void 0 ? T : void 0, K;
    }
  };
  function Fe() {
    return { rendererUrl: void 0, selectedLayoutId: void 0, debug: void 0 };
  }
  a.SceneComposition = {
    encode(p, b = c.default.Writer.create()) {
      return p.rendererUrl !== void 0 && b.uint32(10).string(p.rendererUrl), p.selectedLayoutId !== void 0 && b.uint32(18).string(p.selectedLayoutId), p.debug !== void 0 && b.uint32(24).bool(p.debug), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Fe();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.rendererUrl = T.string();
            break;
          case 2:
            U.selectedLayoutId = T.string();
            break;
          case 3:
            U.debug = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        rendererUrl: ce(p.rendererUrl) ? String(p.rendererUrl) : void 0,
        selectedLayoutId: ce(p.selectedLayoutId) ? String(p.selectedLayoutId) : void 0,
        debug: ce(p.debug) ? !!p.debug : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.rendererUrl !== void 0 && (b.rendererUrl = p.rendererUrl), p.selectedLayoutId !== void 0 && (b.selectedLayoutId = p.selectedLayoutId), p.debug !== void 0 && (b.debug = p.debug), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = Fe();
      return U.rendererUrl = (b = p.rendererUrl) !== null && b !== void 0 ? b : void 0, U.selectedLayoutId = (T = p.selectedLayoutId) !== null && T !== void 0 ? T : void 0, U.debug = (K = p.debug) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function ze() {
    return { url: "" };
  }
  a.ExternalComposition = {
    encode(p, b = c.default.Writer.create()) {
      return p.url !== "" && b.uint32(10).string(p.url), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = ze();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.url = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { url: ce(p.url) ? String(p.url) : "" };
    },
    toJSON(p) {
      const b = {};
      return p.url !== void 0 && (b.url = p.url), b;
    },
    fromPartial(p) {
      var b;
      const T = ze();
      return T.url = (b = p.url) !== null && b !== void 0 ? b : "", T;
    }
  };
  function Me() {
    return { external: void 0, studioSdk: void 0, scene: void 0 };
  }
  a.Composition = {
    encode(p, b = c.default.Writer.create()) {
      return p.external !== void 0 && a.ExternalComposition.encode(p.external, b.uint32(10).fork()).ldelim(), p.studioSdk !== void 0 && a.StudioSdkComposition.encode(p.studioSdk, b.uint32(18).fork()).ldelim(), p.scene !== void 0 && a.SceneComposition.encode(p.scene, b.uint32(34).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Me();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.external = a.ExternalComposition.decode(T, T.uint32());
            break;
          case 2:
            U.studioSdk = a.StudioSdkComposition.decode(T, T.uint32());
            break;
          case 4:
            U.scene = a.SceneComposition.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        external: ce(p.external) ? a.ExternalComposition.fromJSON(p.external) : void 0,
        studioSdk: ce(p.studioSdk) ? a.StudioSdkComposition.fromJSON(p.studioSdk) : void 0,
        scene: ce(p.scene) ? a.SceneComposition.fromJSON(p.scene) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.external !== void 0 && (b.external = p.external ? a.ExternalComposition.toJSON(p.external) : void 0), p.studioSdk !== void 0 && (b.studioSdk = p.studioSdk ? a.StudioSdkComposition.toJSON(p.studioSdk) : void 0), p.scene !== void 0 && (b.scene = p.scene ? a.SceneComposition.toJSON(p.scene) : void 0), b;
    },
    fromPartial(p) {
      const b = Me();
      return b.external = p.external !== void 0 && p.external !== null ? a.ExternalComposition.fromPartial(p.external) : void 0, b.studioSdk = p.studioSdk !== void 0 && p.studioSdk !== null ? a.StudioSdkComposition.fromPartial(p.studioSdk) : void 0, b.scene = p.scene !== void 0 && p.scene !== null ? a.SceneComposition.fromPartial(p.scene) : void 0, b;
    }
  };
  function nt() {
    return { enabled: void 0 };
  }
  a.HostedWebRtc = {
    encode(p, b = c.default.Writer.create()) {
      return p.enabled !== void 0 && b.uint32(8).bool(p.enabled), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = nt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.enabled = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { enabled: ce(p.enabled) ? !!p.enabled : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.enabled !== void 0 && (b.enabled = p.enabled), b;
    },
    fromPartial(p) {
      var b;
      const T = nt();
      return T.enabled = (b = p.enabled) !== null && b !== void 0 ? b : void 0, T;
    }
  };
  function rt() {
    return { hosted: void 0 };
  }
  a.WebRtc = {
    encode(p, b = c.default.Writer.create()) {
      return p.hosted !== void 0 && a.HostedWebRtc.encode(p.hosted, b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = rt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.hosted = a.HostedWebRtc.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { hosted: ce(p.hosted) ? a.HostedWebRtc.fromJSON(p.hosted) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.hosted !== void 0 && (b.hosted = p.hosted ? a.HostedWebRtc.toJSON(p.hosted) : void 0), b;
    },
    fromPartial(p) {
      const b = rt();
      return b.hosted = p.hosted !== void 0 && p.hosted !== null ? a.HostedWebRtc.fromPartial(p.hosted) : void 0, b;
    }
  };
  function Tt() {
    return { accessToken: "", participantId: void 0 };
  }
  a.WebRtcAccess = {
    encode(p, b = c.default.Writer.create()) {
      return p.accessToken !== "" && b.uint32(10).string(p.accessToken), p.participantId !== void 0 && b.uint32(26).string(p.participantId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Tt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.accessToken = T.string();
            break;
          case 3:
            U.participantId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        accessToken: ce(p.accessToken) ? String(p.accessToken) : "",
        participantId: ce(p.participantId) ? String(p.participantId) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.accessToken !== void 0 && (b.accessToken = p.accessToken), p.participantId !== void 0 && (b.participantId = p.participantId), b;
    },
    fromPartial(p) {
      var b, T;
      const K = Tt();
      return K.accessToken = (b = p.accessToken) !== null && b !== void 0 ? b : "", K.participantId = (T = p.participantId) !== null && T !== void 0 ? T : void 0, K;
    }
  };
  function kt() {
    return { latitude: 0, longitude: 0 };
  }
  a.LatLong = {
    encode(p, b = c.default.Writer.create()) {
      return p.latitude !== 0 && b.uint32(9).double(p.latitude), p.longitude !== 0 && b.uint32(17).double(p.longitude), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = kt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.latitude = T.double();
            break;
          case 2:
            U.longitude = T.double();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        latitude: ce(p.latitude) ? Number(p.latitude) : 0,
        longitude: ce(p.longitude) ? Number(p.longitude) : 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.latitude !== void 0 && (b.latitude = p.latitude), p.longitude !== void 0 && (b.longitude = p.longitude), b;
    },
    fromPartial(p) {
      var b, T;
      const K = kt();
      return K.latitude = (b = p.latitude) !== null && b !== void 0 ? b : 0, K.longitude = (T = p.longitude) !== null && T !== void 0 ? T : 0, K;
    }
  };
  function It() {
    return {
      collectionId: "",
      projectId: "",
      broadcastId: void 0,
      duration: void 0,
      start: void 0,
      stop: void 0,
      phase: Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED,
      region: void 0,
      datacenter: void 0
    };
  }
  a.ProjectBroadcastStatus = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.broadcastId !== void 0 && b.uint32(26).string(p.broadcastId), p.duration !== void 0 && b.uint32(32).uint32(p.duration), p.start !== void 0 && g.Timestamp.encode(Ut(p.start), b.uint32(42).fork()).ldelim(), p.stop !== void 0 && g.Timestamp.encode(Ut(p.stop), b.uint32(50).fork()).ldelim(), p.phase !== Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED && b.uint32(56).int32(Ve(p.phase)), p.region !== void 0 && b.uint32(64).int32(at(p.region)), p.datacenter !== void 0 && b.uint32(74).string(p.datacenter), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = It();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.broadcastId = T.string();
            break;
          case 4:
            U.duration = T.uint32();
            break;
          case 5:
            U.start = $t(g.Timestamp.decode(T, T.uint32()));
            break;
          case 6:
            U.stop = $t(g.Timestamp.decode(T, T.uint32()));
            break;
          case 7:
            U.phase = Ge(T.int32());
            break;
          case 8:
            U.region = me(T.int32());
            break;
          case 9:
            U.datacenter = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        broadcastId: ce(p.broadcastId) ? String(p.broadcastId) : void 0,
        duration: ce(p.duration) ? Number(p.duration) : void 0,
        start: ce(p.start) ? String(p.start) : void 0,
        stop: ce(p.stop) ? String(p.stop) : void 0,
        phase: ce(p.phase) ? Ge(p.phase) : Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED,
        region: ce(p.region) ? me(p.region) : void 0,
        datacenter: ce(p.datacenter) ? String(p.datacenter) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.broadcastId !== void 0 && (b.broadcastId = p.broadcastId), p.duration !== void 0 && (b.duration = Math.round(p.duration)), p.start !== void 0 && (b.start = p.start), p.stop !== void 0 && (b.stop = p.stop), p.phase !== void 0 && (b.phase = He(p.phase)), p.region !== void 0 && (b.region = p.region !== void 0 ? Ie(p.region) : void 0), p.datacenter !== void 0 && (b.datacenter = p.datacenter), b;
    },
    fromPartial(p) {
      var b, T, K, U, te, We, et, dt, lt;
      const pt = It();
      return pt.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", pt.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", pt.broadcastId = (K = p.broadcastId) !== null && K !== void 0 ? K : void 0, pt.duration = (U = p.duration) !== null && U !== void 0 ? U : void 0, pt.start = (te = p.start) !== null && te !== void 0 ? te : void 0, pt.stop = (We = p.stop) !== null && We !== void 0 ? We : void 0, pt.phase = (et = p.phase) !== null && et !== void 0 ? et : Ue.PROJECT_BROADCAST_PHASE_UNSPECIFIED, pt.region = (dt = p.region) !== null && dt !== void 0 ? dt : void 0, pt.datacenter = (lt = p.datacenter) !== null && lt !== void 0 ? lt : void 0, pt;
    }
  };
  function _t() {
    return { collectionId: "", sourceId: "", metadata: void 0, preview: void 0, address: void 0 };
  }
  a.Source = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.sourceId !== "" && b.uint32(18).string(p.sourceId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(26).fork()).ldelim(), p.preview !== void 0 && a.PreviewAddress.encode(p.preview, b.uint32(34).fork()).ldelim(), p.address !== void 0 && a.SourceAddress.encode(p.address, b.uint32(50).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = _t();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.sourceId = T.string();
            break;
          case 3:
            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));
            break;
          case 4:
            U.preview = a.PreviewAddress.decode(T, T.uint32());
            break;
          case 6:
            U.address = a.SourceAddress.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : "",
        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,
        preview: ce(p.preview) ? a.PreviewAddress.fromJSON(p.preview) : void 0,
        address: ce(p.address) ? a.SourceAddress.fromJSON(p.address) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.metadata !== void 0 && (b.metadata = p.metadata), p.preview !== void 0 && (b.preview = p.preview ? a.PreviewAddress.toJSON(p.preview) : void 0), p.address !== void 0 && (b.address = p.address ? a.SourceAddress.toJSON(p.address) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = _t();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : "", U.metadata = (K = p.metadata) !== null && K !== void 0 ? K : void 0, U.preview = p.preview !== void 0 && p.preview !== null ? a.PreviewAddress.fromPartial(p.preview) : void 0, U.address = p.address !== void 0 && p.address !== null ? a.SourceAddress.fromPartial(p.address) : void 0, U;
    }
  };
  function Rt() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      metadata: void 0,
      enabled: void 0,
      address: void 0,
      timeout: void 0
    };
  }
  a.Destination = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.destinationId !== "" && b.uint32(26).string(p.destinationId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(34).fork()).ldelim(), p.enabled !== void 0 && b.uint32(40).bool(p.enabled), p.address !== void 0 && a.DestinationAddress.encode(p.address, b.uint32(50).fork()).ldelim(), p.timeout !== void 0 && b.uint32(56).uint32(p.timeout), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Rt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.destinationId = T.string();
            break;
          case 4:
            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));
            break;
          case 5:
            U.enabled = T.bool();
            break;
          case 6:
            U.address = a.DestinationAddress.decode(T, T.uint32());
            break;
          case 7:
            U.timeout = T.uint32();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        destinationId: ce(p.destinationId) ? String(p.destinationId) : "",
        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,
        enabled: ce(p.enabled) ? !!p.enabled : void 0,
        address: ce(p.address) ? a.DestinationAddress.fromJSON(p.address) : void 0,
        timeout: ce(p.timeout) ? Number(p.timeout) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), p.metadata !== void 0 && (b.metadata = p.metadata), p.enabled !== void 0 && (b.enabled = p.enabled), p.address !== void 0 && (b.address = p.address ? a.DestinationAddress.toJSON(p.address) : void 0), p.timeout !== void 0 && (b.timeout = Math.round(p.timeout)), b;
    },
    fromPartial(p) {
      var b, T, K, U, te, We;
      const et = Rt();
      return et.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", et.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", et.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : "", et.metadata = (U = p.metadata) !== null && U !== void 0 ? U : void 0, et.enabled = (te = p.enabled) !== null && te !== void 0 ? te : void 0, et.address = p.address !== void 0 && p.address !== null ? a.DestinationAddress.fromPartial(p.address) : void 0, et.timeout = (We = p.timeout) !== null && We !== void 0 ? We : void 0, et;
    }
  };
  function Jt() {
    return {
      collectionId: "",
      projectId: "",
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      sources: [],
      destinations: [],
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      triggers: [],
      location: void 0,
      guestCodes: []
    };
  }
  a.Project = {
    encode(p, b = c.default.Writer.create()) {
      p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(26).fork()).ldelim(), p.rendering !== void 0 && a.Rendering.encode(p.rendering, b.uint32(34).fork()).ldelim(), p.encoding !== void 0 && a.Encoding.encode(p.encoding, b.uint32(42).fork()).ldelim();
      for (const T of p.sources)
        a.Source.encode(T, b.uint32(50).fork()).ldelim();
      for (const T of p.destinations)
        a.Destination.encode(T, b.uint32(58).fork()).ldelim();
      p.composition !== void 0 && a.Composition.encode(p.composition, b.uint32(66).fork()).ldelim(), p.maxDuration !== void 0 && b.uint32(72).uint32(p.maxDuration), p.webrtc !== void 0 && a.WebRtc.encode(p.webrtc, b.uint32(82).fork()).ldelim();
      for (const T of p.triggers)
        a.ProjectTrigger.encode(T, b.uint32(90).fork()).ldelim();
      p.location !== void 0 && a.LatLong.encode(p.location, b.uint32(98).fork()).ldelim();
      for (const T of p.guestCodes)
        a.GuestCode.encode(T, b.uint32(106).fork()).ldelim();
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Jt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));
            break;
          case 4:
            U.rendering = a.Rendering.decode(T, T.uint32());
            break;
          case 5:
            U.encoding = a.Encoding.decode(T, T.uint32());
            break;
          case 6:
            U.sources.push(a.Source.decode(T, T.uint32()));
            break;
          case 7:
            U.destinations.push(a.Destination.decode(T, T.uint32()));
            break;
          case 8:
            U.composition = a.Composition.decode(T, T.uint32());
            break;
          case 9:
            U.maxDuration = T.uint32();
            break;
          case 10:
            U.webrtc = a.WebRtc.decode(T, T.uint32());
            break;
          case 11:
            U.triggers.push(a.ProjectTrigger.decode(T, T.uint32()));
            break;
          case 12:
            U.location = a.LatLong.decode(T, T.uint32());
            break;
          case 13:
            U.guestCodes.push(a.GuestCode.decode(T, T.uint32()));
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,
        rendering: ce(p.rendering) ? a.Rendering.fromJSON(p.rendering) : void 0,
        encoding: ce(p.encoding) ? a.Encoding.fromJSON(p.encoding) : void 0,
        sources: Array.isArray(p == null ? void 0 : p.sources) ? p.sources.map((b) => a.Source.fromJSON(b)) : [],
        destinations: Array.isArray(p == null ? void 0 : p.destinations) ? p.destinations.map((b) => a.Destination.fromJSON(b)) : [],
        composition: ce(p.composition) ? a.Composition.fromJSON(p.composition) : void 0,
        maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0,
        webrtc: ce(p.webrtc) ? a.WebRtc.fromJSON(p.webrtc) : void 0,
        triggers: Array.isArray(p == null ? void 0 : p.triggers) ? p.triggers.map((b) => a.ProjectTrigger.fromJSON(b)) : [],
        location: ce(p.location) ? a.LatLong.fromJSON(p.location) : void 0,
        guestCodes: Array.isArray(p == null ? void 0 : p.guestCodes) ? p.guestCodes.map((b) => a.GuestCode.fromJSON(b)) : []
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.metadata !== void 0 && (b.metadata = p.metadata), p.rendering !== void 0 && (b.rendering = p.rendering ? a.Rendering.toJSON(p.rendering) : void 0), p.encoding !== void 0 && (b.encoding = p.encoding ? a.Encoding.toJSON(p.encoding) : void 0), p.sources ? b.sources = p.sources.map((T) => T ? a.Source.toJSON(T) : void 0) : b.sources = [], p.destinations ? b.destinations = p.destinations.map((T) => T ? a.Destination.toJSON(T) : void 0) : b.destinations = [], p.composition !== void 0 && (b.composition = p.composition ? a.Composition.toJSON(p.composition) : void 0), p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), p.webrtc !== void 0 && (b.webrtc = p.webrtc ? a.WebRtc.toJSON(p.webrtc) : void 0), p.triggers ? b.triggers = p.triggers.map((T) => T ? a.ProjectTrigger.toJSON(T) : void 0) : b.triggers = [], p.location !== void 0 && (b.location = p.location ? a.LatLong.toJSON(p.location) : void 0), p.guestCodes ? b.guestCodes = p.guestCodes.map((T) => T ? a.GuestCode.toJSON(T) : void 0) : b.guestCodes = [], b;
    },
    fromPartial(p) {
      var b, T, K, U, te, We, et, dt;
      const lt = Jt();
      return lt.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", lt.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", lt.metadata = (K = p.metadata) !== null && K !== void 0 ? K : void 0, lt.rendering = p.rendering !== void 0 && p.rendering !== null ? a.Rendering.fromPartial(p.rendering) : void 0, lt.encoding = p.encoding !== void 0 && p.encoding !== null ? a.Encoding.fromPartial(p.encoding) : void 0, lt.sources = ((U = p.sources) === null || U === void 0 ? void 0 : U.map((pt) => a.Source.fromPartial(pt))) || [], lt.destinations = ((te = p.destinations) === null || te === void 0 ? void 0 : te.map((pt) => a.Destination.fromPartial(pt))) || [], lt.composition = p.composition !== void 0 && p.composition !== null ? a.Composition.fromPartial(p.composition) : void 0, lt.maxDuration = (We = p.maxDuration) !== null && We !== void 0 ? We : void 0, lt.webrtc = p.webrtc !== void 0 && p.webrtc !== null ? a.WebRtc.fromPartial(p.webrtc) : void 0, lt.triggers = ((et = p.triggers) === null || et === void 0 ? void 0 : et.map((pt) => a.ProjectTrigger.fromPartial(pt))) || [], lt.location = p.location !== void 0 && p.location !== null ? a.LatLong.fromPartial(p.location) : void 0, lt.guestCodes = ((dt = p.guestCodes) === null || dt === void 0 ? void 0 : dt.map((pt) => a.GuestCode.fromPartial(pt))) || [], lt;
    }
  };
  function Ft() {
    return { collectionId: "", metadata: void 0, projects: [], sources: [] };
  }
  a.Collection = {
    encode(p, b = c.default.Writer.create()) {
      p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(18).fork()).ldelim();
      for (const T of p.projects)
        a.Project.encode(T, b.uint32(26).fork()).ldelim();
      for (const T of p.sources)
        a.Source.encode(T, b.uint32(34).fork()).ldelim();
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Ft();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));
            break;
          case 3:
            U.projects.push(a.Project.decode(T, T.uint32()));
            break;
          case 4:
            U.sources.push(a.Source.decode(T, T.uint32()));
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,
        projects: Array.isArray(p == null ? void 0 : p.projects) ? p.projects.map((b) => a.Project.fromJSON(b)) : [],
        sources: Array.isArray(p == null ? void 0 : p.sources) ? p.sources.map((b) => a.Source.fromJSON(b)) : []
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.metadata !== void 0 && (b.metadata = p.metadata), p.projects ? b.projects = p.projects.map((T) => T ? a.Project.toJSON(T) : void 0) : b.projects = [], p.sources ? b.sources = p.sources.map((T) => T ? a.Source.toJSON(T) : void 0) : b.sources = [], b;
    },
    fromPartial(p) {
      var b, T, K, U;
      const te = Ft();
      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", te.metadata = (T = p.metadata) !== null && T !== void 0 ? T : void 0, te.projects = ((K = p.projects) === null || K === void 0 ? void 0 : K.map((We) => a.Project.fromPartial(We))) || [], te.sources = ((U = p.sources) === null || U === void 0 ? void 0 : U.map((We) => a.Source.fromPartial(We))) || [], te;
    }
  };
  function Vt() {
    return { metadata: void 0 };
  }
  a.CreateCollectionRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Vt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.metadata !== void 0 && (b.metadata = p.metadata), b;
    },
    fromPartial(p) {
      var b;
      const T = Vt();
      return T.metadata = (b = p.metadata) !== null && b !== void 0 ? b : void 0, T;
    }
  };
  function qt() {
    return { collection: void 0 };
  }
  a.CreateCollectionResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.collection !== void 0 && a.Collection.encode(p.collection, b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = qt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collection = a.Collection.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { collection: ce(p.collection) ? a.Collection.fromJSON(p.collection) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.collection !== void 0 && (b.collection = p.collection ? a.Collection.toJSON(p.collection) : void 0), b;
    },
    fromPartial(p) {
      const b = qt();
      return b.collection = p.collection !== void 0 && p.collection !== null ? a.Collection.fromPartial(p.collection) : void 0, b;
    }
  };
  function Gt() {
    return { collectionId: "", populateProjects: void 0, populateSources: void 0 };
  }
  a.GetCollectionRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.populateProjects !== void 0 && b.uint32(16).bool(p.populateProjects), p.populateSources !== void 0 && b.uint32(24).bool(p.populateSources), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Gt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.populateProjects = T.bool();
            break;
          case 3:
            U.populateSources = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        populateProjects: ce(p.populateProjects) ? !!p.populateProjects : void 0,
        populateSources: ce(p.populateSources) ? !!p.populateSources : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.populateProjects !== void 0 && (b.populateProjects = p.populateProjects), p.populateSources !== void 0 && (b.populateSources = p.populateSources), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = Gt();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.populateProjects = (T = p.populateProjects) !== null && T !== void 0 ? T : void 0, U.populateSources = (K = p.populateSources) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function Wt() {
    return { collection: void 0 };
  }
  a.GetCollectionResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.collection !== void 0 && a.Collection.encode(p.collection, b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Wt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collection = a.Collection.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { collection: ce(p.collection) ? a.Collection.fromJSON(p.collection) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.collection !== void 0 && (b.collection = p.collection ? a.Collection.toJSON(p.collection) : void 0), b;
    },
    fromPartial(p) {
      const b = Wt();
      return b.collection = p.collection !== void 0 && p.collection !== null ? a.Collection.fromPartial(p.collection) : void 0, b;
    }
  };
  function Ht() {
    return { collectionId: "", updateMask: void 0, metadata: void 0 };
  }
  a.UpdateCollectionRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(p.updateMask), b.uint32(18).fork()).ldelim(), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(26).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Ht();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(T, T.uint32()));
            break;
          case 3:
            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        updateMask: ce(p.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(p.updateMask)) : void 0,
        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.updateMask !== void 0 && (b.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(p.updateMask))), p.metadata !== void 0 && (b.metadata = p.metadata), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = Ht();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.updateMask = (T = p.updateMask) !== null && T !== void 0 ? T : void 0, U.metadata = (K = p.metadata) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function xt() {
    return { collection: void 0 };
  }
  a.UpdateCollectionResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.collection !== void 0 && a.Collection.encode(p.collection, b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = xt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collection = a.Collection.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { collection: ce(p.collection) ? a.Collection.fromJSON(p.collection) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.collection !== void 0 && (b.collection = p.collection ? a.Collection.toJSON(p.collection) : void 0), b;
    },
    fromPartial(p) {
      const b = xt();
      return b.collection = p.collection !== void 0 && p.collection !== null ? a.Collection.fromPartial(p.collection) : void 0, b;
    }
  };
  function zt() {
    return { collectionId: "", force: void 0 };
  }
  a.DeleteCollectionRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.force !== void 0 && b.uint32(16).bool(p.force), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = zt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.force = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        force: ce(p.force) ? !!p.force : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.force !== void 0 && (b.force = p.force), b;
    },
    fromPartial(p) {
      var b, T;
      const K = zt();
      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", K.force = (T = p.force) !== null && T !== void 0 ? T : void 0, K;
    }
  };
  function Yt() {
    return { sourcesDeleted: 0, projectsDeleted: 0, projectIdsStopped: [] };
  }
  a.DeleteCollectionResponse = {
    encode(p, b = c.default.Writer.create()) {
      p.sourcesDeleted !== 0 && b.uint32(8).uint32(p.sourcesDeleted), p.projectsDeleted !== 0 && b.uint32(16).uint32(p.projectsDeleted);
      for (const T of p.projectIdsStopped)
        b.uint32(26).string(T);
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Yt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.sourcesDeleted = T.uint32();
            break;
          case 2:
            U.projectsDeleted = T.uint32();
            break;
          case 3:
            U.projectIdsStopped.push(T.string());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        sourcesDeleted: ce(p.sourcesDeleted) ? Number(p.sourcesDeleted) : 0,
        projectsDeleted: ce(p.projectsDeleted) ? Number(p.projectsDeleted) : 0,
        projectIdsStopped: Array.isArray(p == null ? void 0 : p.projectIdsStopped) ? p.projectIdsStopped.map((b) => String(b)) : []
      };
    },
    toJSON(p) {
      const b = {};
      return p.sourcesDeleted !== void 0 && (b.sourcesDeleted = Math.round(p.sourcesDeleted)), p.projectsDeleted !== void 0 && (b.projectsDeleted = Math.round(p.projectsDeleted)), p.projectIdsStopped ? b.projectIdsStopped = p.projectIdsStopped.map((T) => T) : b.projectIdsStopped = [], b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = Yt();
      return U.sourcesDeleted = (b = p.sourcesDeleted) !== null && b !== void 0 ? b : 0, U.projectsDeleted = (T = p.projectsDeleted) !== null && T !== void 0 ? T : 0, U.projectIdsStopped = ((K = p.projectIdsStopped) === null || K === void 0 ? void 0 : K.map((te) => te)) || [], U;
    }
  };
  function Kt() {
    return {};
  }
  a.GetCollectionsRequest = {
    encode(p, b = c.default.Writer.create()) {
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Kt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {};
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return Kt();
    }
  };
  function Qt() {
    return { collections: [] };
  }
  a.GetCollectionsResponse = {
    encode(p, b = c.default.Writer.create()) {
      for (const T of p.collections)
        a.Collection.encode(T, b.uint32(10).fork()).ldelim();
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Qt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collections.push(a.Collection.decode(T, T.uint32()));
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collections: Array.isArray(p == null ? void 0 : p.collections) ? p.collections.map((b) => a.Collection.fromJSON(b)) : []
      };
    },
    toJSON(p) {
      const b = {};
      return p.collections ? b.collections = p.collections.map((T) => T ? a.Collection.toJSON(T) : void 0) : b.collections = [], b;
    },
    fromPartial(p) {
      var b;
      const T = Qt();
      return T.collections = ((b = p.collections) === null || b === void 0 ? void 0 : b.map((K) => a.Collection.fromPartial(K))) || [], T;
    }
  };
  function Zt() {
    return {
      collectionId: "",
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      location: void 0
    };
  }
  a.CreateProjectRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(18).fork()).ldelim(), p.rendering !== void 0 && a.Rendering.encode(p.rendering, b.uint32(26).fork()).ldelim(), p.encoding !== void 0 && a.Encoding.encode(p.encoding, b.uint32(34).fork()).ldelim(), p.composition !== void 0 && a.Composition.encode(p.composition, b.uint32(42).fork()).ldelim(), p.maxDuration !== void 0 && b.uint32(48).uint32(p.maxDuration), p.webrtc !== void 0 && a.WebRtc.encode(p.webrtc, b.uint32(58).fork()).ldelim(), p.location !== void 0 && a.LatLong.encode(p.location, b.uint32(74).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Zt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));
            break;
          case 3:
            U.rendering = a.Rendering.decode(T, T.uint32());
            break;
          case 4:
            U.encoding = a.Encoding.decode(T, T.uint32());
            break;
          case 5:
            U.composition = a.Composition.decode(T, T.uint32());
            break;
          case 6:
            U.maxDuration = T.uint32();
            break;
          case 7:
            U.webrtc = a.WebRtc.decode(T, T.uint32());
            break;
          case 9:
            U.location = a.LatLong.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,
        rendering: ce(p.rendering) ? a.Rendering.fromJSON(p.rendering) : void 0,
        encoding: ce(p.encoding) ? a.Encoding.fromJSON(p.encoding) : void 0,
        composition: ce(p.composition) ? a.Composition.fromJSON(p.composition) : void 0,
        maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0,
        webrtc: ce(p.webrtc) ? a.WebRtc.fromJSON(p.webrtc) : void 0,
        location: ce(p.location) ? a.LatLong.fromJSON(p.location) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.metadata !== void 0 && (b.metadata = p.metadata), p.rendering !== void 0 && (b.rendering = p.rendering ? a.Rendering.toJSON(p.rendering) : void 0), p.encoding !== void 0 && (b.encoding = p.encoding ? a.Encoding.toJSON(p.encoding) : void 0), p.composition !== void 0 && (b.composition = p.composition ? a.Composition.toJSON(p.composition) : void 0), p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), p.webrtc !== void 0 && (b.webrtc = p.webrtc ? a.WebRtc.toJSON(p.webrtc) : void 0), p.location !== void 0 && (b.location = p.location ? a.LatLong.toJSON(p.location) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = Zt();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.metadata = (T = p.metadata) !== null && T !== void 0 ? T : void 0, U.rendering = p.rendering !== void 0 && p.rendering !== null ? a.Rendering.fromPartial(p.rendering) : void 0, U.encoding = p.encoding !== void 0 && p.encoding !== null ? a.Encoding.fromPartial(p.encoding) : void 0, U.composition = p.composition !== void 0 && p.composition !== null ? a.Composition.fromPartial(p.composition) : void 0, U.maxDuration = (K = p.maxDuration) !== null && K !== void 0 ? K : void 0, U.webrtc = p.webrtc !== void 0 && p.webrtc !== null ? a.WebRtc.fromPartial(p.webrtc) : void 0, U.location = p.location !== void 0 && p.location !== null ? a.LatLong.fromPartial(p.location) : void 0, U;
    }
  };
  function Xt() {
    return { project: void 0 };
  }
  a.CreateProjectResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Xt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.project = a.Project.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), b;
    },
    fromPartial(p) {
      const b = Xt();
      return b.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, b;
    }
  };
  function jt() {
    return {
      collectionId: "",
      projectId: "",
      updateMask: void 0,
      metadata: void 0,
      rendering: void 0,
      encoding: void 0,
      composition: void 0,
      maxDuration: void 0,
      webrtc: void 0,
      location: void 0
    };
  }
  a.UpdateProjectRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(p.updateMask), b.uint32(26).fork()).ldelim(), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(34).fork()).ldelim(), p.rendering !== void 0 && a.Rendering.encode(p.rendering, b.uint32(42).fork()).ldelim(), p.encoding !== void 0 && a.Encoding.encode(p.encoding, b.uint32(50).fork()).ldelim(), p.composition !== void 0 && a.Composition.encode(p.composition, b.uint32(58).fork()).ldelim(), p.maxDuration !== void 0 && b.uint32(64).uint32(p.maxDuration), p.webrtc !== void 0 && a.WebRtc.encode(p.webrtc, b.uint32(74).fork()).ldelim(), p.location !== void 0 && a.LatLong.encode(p.location, b.uint32(82).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = jt();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(T, T.uint32()));
            break;
          case 4:
            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));
            break;
          case 5:
            U.rendering = a.Rendering.decode(T, T.uint32());
            break;
          case 6:
            U.encoding = a.Encoding.decode(T, T.uint32());
            break;
          case 7:
            U.composition = a.Composition.decode(T, T.uint32());
            break;
          case 8:
            U.maxDuration = T.uint32();
            break;
          case 9:
            U.webrtc = a.WebRtc.decode(T, T.uint32());
            break;
          case 10:
            U.location = a.LatLong.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        updateMask: ce(p.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(p.updateMask)) : void 0,
        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,
        rendering: ce(p.rendering) ? a.Rendering.fromJSON(p.rendering) : void 0,
        encoding: ce(p.encoding) ? a.Encoding.fromJSON(p.encoding) : void 0,
        composition: ce(p.composition) ? a.Composition.fromJSON(p.composition) : void 0,
        maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0,
        webrtc: ce(p.webrtc) ? a.WebRtc.fromJSON(p.webrtc) : void 0,
        location: ce(p.location) ? a.LatLong.fromJSON(p.location) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.updateMask !== void 0 && (b.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(p.updateMask))), p.metadata !== void 0 && (b.metadata = p.metadata), p.rendering !== void 0 && (b.rendering = p.rendering ? a.Rendering.toJSON(p.rendering) : void 0), p.encoding !== void 0 && (b.encoding = p.encoding ? a.Encoding.toJSON(p.encoding) : void 0), p.composition !== void 0 && (b.composition = p.composition ? a.Composition.toJSON(p.composition) : void 0), p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), p.webrtc !== void 0 && (b.webrtc = p.webrtc ? a.WebRtc.toJSON(p.webrtc) : void 0), p.location !== void 0 && (b.location = p.location ? a.LatLong.toJSON(p.location) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K, U, te;
      const We = jt();
      return We.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", We.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", We.updateMask = (K = p.updateMask) !== null && K !== void 0 ? K : void 0, We.metadata = (U = p.metadata) !== null && U !== void 0 ? U : void 0, We.rendering = p.rendering !== void 0 && p.rendering !== null ? a.Rendering.fromPartial(p.rendering) : void 0, We.encoding = p.encoding !== void 0 && p.encoding !== null ? a.Encoding.fromPartial(p.encoding) : void 0, We.composition = p.composition !== void 0 && p.composition !== null ? a.Composition.fromPartial(p.composition) : void 0, We.maxDuration = (te = p.maxDuration) !== null && te !== void 0 ? te : void 0, We.webrtc = p.webrtc !== void 0 && p.webrtc !== null ? a.WebRtc.fromPartial(p.webrtc) : void 0, We.location = p.location !== void 0 && p.location !== null ? a.LatLong.fromPartial(p.location) : void 0, We;
    }
  };
  function en() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.UpdateProjectResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(10).fork()).ldelim(), p.broadcastUpdated === !0 && b.uint32(16).bool(p.broadcastUpdated), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = en();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.project = a.Project.decode(T, T.uint32());
            break;
          case 2:
            U.broadcastUpdated = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0,
        broadcastUpdated: ce(p.broadcastUpdated) ? !!p.broadcastUpdated : !1
      };
    },
    toJSON(p) {
      const b = {};
      return p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), p.broadcastUpdated !== void 0 && (b.broadcastUpdated = p.broadcastUpdated), b;
    },
    fromPartial(p) {
      var b;
      const T = en();
      return T.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, T.broadcastUpdated = (b = p.broadcastUpdated) !== null && b !== void 0 ? b : !1, T;
    }
  };
  function tn() {
    return { collectionId: "", projectId: "", force: void 0 };
  }
  a.DeleteProjectRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.force !== void 0 && b.uint32(24).bool(p.force), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = tn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.force = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        force: ce(p.force) ? !!p.force : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.force !== void 0 && (b.force = p.force), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = tn();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", U.force = (K = p.force) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function nn() {
    return { broadcastStopped: !1, layoutsDeleted: 0 };
  }
  a.DeleteProjectResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.broadcastStopped === !0 && b.uint32(8).bool(p.broadcastStopped), p.layoutsDeleted !== 0 && b.uint32(16).uint32(p.layoutsDeleted), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = nn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.broadcastStopped = T.bool();
            break;
          case 2:
            U.layoutsDeleted = T.uint32();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        broadcastStopped: ce(p.broadcastStopped) ? !!p.broadcastStopped : !1,
        layoutsDeleted: ce(p.layoutsDeleted) ? Number(p.layoutsDeleted) : 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.broadcastStopped !== void 0 && (b.broadcastStopped = p.broadcastStopped), p.layoutsDeleted !== void 0 && (b.layoutsDeleted = Math.round(p.layoutsDeleted)), b;
    },
    fromPartial(p) {
      var b, T;
      const K = nn();
      return K.broadcastStopped = (b = p.broadcastStopped) !== null && b !== void 0 ? b : !1, K.layoutsDeleted = (T = p.layoutsDeleted) !== null && T !== void 0 ? T : 0, K;
    }
  };
  function rn() {
    return { collectionId: "", projectId: "", webrtcStart: void 0 };
  }
  a.StartProjectBroadcastRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.webrtcStart !== void 0 && b.uint32(24).bool(p.webrtcStart), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = rn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.webrtcStart = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        webrtcStart: ce(p.webrtcStart) ? !!p.webrtcStart : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.webrtcStart !== void 0 && (b.webrtcStart = p.webrtcStart), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = rn();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", U.webrtcStart = (K = p.webrtcStart) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function an() {
    return { broadcastId: "" };
  }
  a.StartProjectBroadcastResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.broadcastId !== "" && b.uint32(10).string(p.broadcastId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = an();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.broadcastId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { broadcastId: ce(p.broadcastId) ? String(p.broadcastId) : "" };
    },
    toJSON(p) {
      const b = {};
      return p.broadcastId !== void 0 && (b.broadcastId = p.broadcastId), b;
    },
    fromPartial(p) {
      var b;
      const T = an();
      return T.broadcastId = (b = p.broadcastId) !== null && b !== void 0 ? b : "", T;
    }
  };
  function sn() {
    return { collectionId: "", projectId: "", webrtcStop: void 0 };
  }
  a.StopProjectBroadcastRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.webrtcStop !== void 0 && b.uint32(24).bool(p.webrtcStop), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = sn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.webrtcStop = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        webrtcStop: ce(p.webrtcStop) ? !!p.webrtcStop : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.webrtcStop !== void 0 && (b.webrtcStop = p.webrtcStop), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = sn();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", U.webrtcStop = (K = p.webrtcStop) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function dn() {
    return {};
  }
  a.StopProjectBroadcastResponse = {
    encode(p, b = c.default.Writer.create()) {
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = dn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {};
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return dn();
    }
  };
  function un() {
    return { collectionId: "", projectId: "", status: void 0 };
  }
  a.GetProjectRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.status !== void 0 && b.uint32(24).bool(p.status), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = un();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.status = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        status: ce(p.status) ? !!p.status : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.status !== void 0 && (b.status = p.status), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = un();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", U.status = (K = p.status) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function cn() {
    return { project: void 0, status: void 0 };
  }
  a.GetProjectResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(10).fork()).ldelim(), p.status !== void 0 && a.ProjectBroadcastStatus.encode(p.status, b.uint32(18).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = cn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.project = a.Project.decode(T, T.uint32());
            break;
          case 2:
            U.status = a.ProjectBroadcastStatus.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0,
        status: ce(p.status) ? a.ProjectBroadcastStatus.fromJSON(p.status) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), p.status !== void 0 && (b.status = p.status ? a.ProjectBroadcastStatus.toJSON(p.status) : void 0), b;
    },
    fromPartial(p) {
      const b = cn();
      return b.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, b.status = p.status !== void 0 && p.status !== null ? a.ProjectBroadcastStatus.fromPartial(p.status) : void 0, b;
    }
  };
  function ln() {
    return { collectionId: "", projectId: "", format: void 0 };
  }
  a.GetProjectBroadcastSnapshotRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.format !== void 0 && b.uint32(24).int32(L(p.format)), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = ln();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.format = _(T.int32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        format: ce(p.format) ? _(p.format) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.format !== void 0 && (b.format = p.format !== void 0 ? k(p.format) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = ln();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", U.format = (K = p.format) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function fn() {
    return { format: E.IMAGE_FORMAT_UNSPECIFIED, image: new Uint8Array() };
  }
  a.GetProjectBroadcastSnapshotResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.format !== E.IMAGE_FORMAT_UNSPECIFIED && b.uint32(8).int32(L(p.format)), p.image.length !== 0 && b.uint32(18).bytes(p.image), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = fn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.format = _(T.int32());
            break;
          case 2:
            U.image = T.bytes();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        format: ce(p.format) ? _(p.format) : E.IMAGE_FORMAT_UNSPECIFIED,
        image: ce(p.image) ? Fr(p.image) : new Uint8Array()
      };
    },
    toJSON(p) {
      const b = {};
      return p.format !== void 0 && (b.format = k(p.format)), p.image !== void 0 && (b.image = Vr(p.image !== void 0 ? p.image : new Uint8Array())), b;
    },
    fromPartial(p) {
      var b, T;
      const K = fn();
      return K.format = (b = p.format) !== null && b !== void 0 ? b : E.IMAGE_FORMAT_UNSPECIFIED, K.image = (T = p.image) !== null && T !== void 0 ? T : new Uint8Array(), K;
    }
  };
  function pn() {
    return { collectionId: "", projectId: "" };
  }
  a.GetProjectBroadcastStatusRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = pn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), b;
    },
    fromPartial(p) {
      var b, T;
      const K = pn();
      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", K.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", K;
    }
  };
  function hn() {
    return { status: void 0 };
  }
  a.GetProjectBroadcastStatusResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.status !== void 0 && a.ProjectBroadcastStatus.encode(p.status, b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = hn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.status = a.ProjectBroadcastStatus.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { status: ce(p.status) ? a.ProjectBroadcastStatus.fromJSON(p.status) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.status !== void 0 && (b.status = p.status ? a.ProjectBroadcastStatus.toJSON(p.status) : void 0), b;
    },
    fromPartial(p) {
      const b = hn();
      return b.status = p.status !== void 0 && p.status !== null ? a.ProjectBroadcastStatus.fromPartial(p.status) : void 0, b;
    }
  };
  function mn() {
    return { collectionId: "", projectId: "" };
  }
  a.StartProjectWebRtcRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = mn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), b;
    },
    fromPartial(p) {
      var b, T;
      const K = mn();
      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", K.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", K;
    }
  };
  function vn() {
    return {};
  }
  a.StartProjectWebRtcResponse = {
    encode(p, b = c.default.Writer.create()) {
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = vn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {};
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return vn();
    }
  };
  function Sn() {
    return { collectionId: "", projectId: "" };
  }
  a.StopProjectWebRtcRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Sn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), b;
    },
    fromPartial(p) {
      var b, T;
      const K = Sn();
      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", K.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", K;
    }
  };
  function yn() {
    return {};
  }
  a.StopProjectWebRtcResponse = {
    encode(p, b = c.default.Writer.create()) {
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = yn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {};
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return yn();
    }
  };
  function gn() {
    return {
      collectionId: "",
      projectId: "",
      metadata: void 0,
      address: void 0,
      enabled: void 0,
      timeout: void 0
    };
  }
  a.CreateDestinationRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(26).fork()).ldelim(), p.address !== void 0 && a.DestinationAddress.encode(p.address, b.uint32(42).fork()).ldelim(), p.enabled !== void 0 && b.uint32(48).bool(p.enabled), p.timeout !== void 0 && b.uint32(56).uint32(p.timeout), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = gn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));
            break;
          case 5:
            U.address = a.DestinationAddress.decode(T, T.uint32());
            break;
          case 6:
            U.enabled = T.bool();
            break;
          case 7:
            U.timeout = T.uint32();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,
        address: ce(p.address) ? a.DestinationAddress.fromJSON(p.address) : void 0,
        enabled: ce(p.enabled) ? !!p.enabled : void 0,
        timeout: ce(p.timeout) ? Number(p.timeout) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.metadata !== void 0 && (b.metadata = p.metadata), p.address !== void 0 && (b.address = p.address ? a.DestinationAddress.toJSON(p.address) : void 0), p.enabled !== void 0 && (b.enabled = p.enabled), p.timeout !== void 0 && (b.timeout = Math.round(p.timeout)), b;
    },
    fromPartial(p) {
      var b, T, K, U, te;
      const We = gn();
      return We.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", We.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", We.metadata = (K = p.metadata) !== null && K !== void 0 ? K : void 0, We.address = p.address !== void 0 && p.address !== null ? a.DestinationAddress.fromPartial(p.address) : void 0, We.enabled = (U = p.enabled) !== null && U !== void 0 ? U : void 0, We.timeout = (te = p.timeout) !== null && te !== void 0 ? te : void 0, We;
    }
  };
  function bn() {
    return { destination: void 0 };
  }
  a.CreateDestinationResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.destination !== void 0 && a.Destination.encode(p.destination, b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = bn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.destination = a.Destination.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { destination: ce(p.destination) ? a.Destination.fromJSON(p.destination) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.destination !== void 0 && (b.destination = p.destination ? a.Destination.toJSON(p.destination) : void 0), b;
    },
    fromPartial(p) {
      const b = bn();
      return b.destination = p.destination !== void 0 && p.destination !== null ? a.Destination.fromPartial(p.destination) : void 0, b;
    }
  };
  function En() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  a.GetDestinationRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.destinationId !== "" && b.uint32(26).string(p.destinationId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = En();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.destinationId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        destinationId: ce(p.destinationId) ? String(p.destinationId) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = En();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", U.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : "", U;
    }
  };
  function Tn() {
    return { destination: void 0 };
  }
  a.GetDestinationResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.destination !== void 0 && a.Destination.encode(p.destination, b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Tn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.destination = a.Destination.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { destination: ce(p.destination) ? a.Destination.fromJSON(p.destination) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.destination !== void 0 && (b.destination = p.destination ? a.Destination.toJSON(p.destination) : void 0), b;
    },
    fromPartial(p) {
      const b = Tn();
      return b.destination = p.destination !== void 0 && p.destination !== null ? a.Destination.fromPartial(p.destination) : void 0, b;
    }
  };
  function _n() {
    return { collectionId: "", projectId: "", destinationId: "", force: void 0 };
  }
  a.DeleteDestinationRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.destinationId !== "" && b.uint32(26).string(p.destinationId), p.force !== void 0 && b.uint32(32).bool(p.force), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = _n();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.destinationId = T.string();
            break;
          case 4:
            U.force = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        destinationId: ce(p.destinationId) ? String(p.destinationId) : "",
        force: ce(p.force) ? !!p.force : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), p.force !== void 0 && (b.force = p.force), b;
    },
    fromPartial(p) {
      var b, T, K, U;
      const te = _n();
      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", te.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", te.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : "", te.force = (U = p.force) !== null && U !== void 0 ? U : void 0, te;
    }
  };
  function In() {
    return { broadcastUpdated: !1 };
  }
  a.DeleteDestinationResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.broadcastUpdated === !0 && b.uint32(8).bool(p.broadcastUpdated), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = In();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.broadcastUpdated = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { broadcastUpdated: ce(p.broadcastUpdated) ? !!p.broadcastUpdated : !1 };
    },
    toJSON(p) {
      const b = {};
      return p.broadcastUpdated !== void 0 && (b.broadcastUpdated = p.broadcastUpdated), b;
    },
    fromPartial(p) {
      var b;
      const T = In();
      return T.broadcastUpdated = (b = p.broadcastUpdated) !== null && b !== void 0 ? b : !1, T;
    }
  };
  function kn() {
    return {
      collectionId: "",
      projectId: "",
      destinationId: "",
      updateMask: void 0,
      metadata: void 0,
      address: void 0,
      enabled: void 0,
      timeout: void 0
    };
  }
  a.UpdateDestinationRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.destinationId !== "" && b.uint32(26).string(p.destinationId), p.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(p.updateMask), b.uint32(34).fork()).ldelim(), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(42).fork()).ldelim(), p.address !== void 0 && a.DestinationAddress.encode(p.address, b.uint32(50).fork()).ldelim(), p.enabled !== void 0 && b.uint32(56).bool(p.enabled), p.timeout !== void 0 && b.uint32(64).uint32(p.timeout), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = kn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.destinationId = T.string();
            break;
          case 4:
            U.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(T, T.uint32()));
            break;
          case 5:
            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));
            break;
          case 6:
            U.address = a.DestinationAddress.decode(T, T.uint32());
            break;
          case 7:
            U.enabled = T.bool();
            break;
          case 8:
            U.timeout = T.uint32();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        destinationId: ce(p.destinationId) ? String(p.destinationId) : "",
        updateMask: ce(p.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(p.updateMask)) : void 0,
        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,
        address: ce(p.address) ? a.DestinationAddress.fromJSON(p.address) : void 0,
        enabled: ce(p.enabled) ? !!p.enabled : void 0,
        timeout: ce(p.timeout) ? Number(p.timeout) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), p.updateMask !== void 0 && (b.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(p.updateMask))), p.metadata !== void 0 && (b.metadata = p.metadata), p.address !== void 0 && (b.address = p.address ? a.DestinationAddress.toJSON(p.address) : void 0), p.enabled !== void 0 && (b.enabled = p.enabled), p.timeout !== void 0 && (b.timeout = Math.round(p.timeout)), b;
    },
    fromPartial(p) {
      var b, T, K, U, te, We, et;
      const dt = kn();
      return dt.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", dt.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", dt.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : "", dt.updateMask = (U = p.updateMask) !== null && U !== void 0 ? U : void 0, dt.metadata = (te = p.metadata) !== null && te !== void 0 ? te : void 0, dt.address = p.address !== void 0 && p.address !== null ? a.DestinationAddress.fromPartial(p.address) : void 0, dt.enabled = (We = p.enabled) !== null && We !== void 0 ? We : void 0, dt.timeout = (et = p.timeout) !== null && et !== void 0 ? et : void 0, dt;
    }
  };
  function Cn() {
    return { destination: void 0, broadcastUpdated: !1 };
  }
  a.UpdateDestinationResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.destination !== void 0 && a.Destination.encode(p.destination, b.uint32(10).fork()).ldelim(), p.broadcastUpdated === !0 && b.uint32(16).bool(p.broadcastUpdated), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Cn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.destination = a.Destination.decode(T, T.uint32());
            break;
          case 2:
            U.broadcastUpdated = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        destination: ce(p.destination) ? a.Destination.fromJSON(p.destination) : void 0,
        broadcastUpdated: ce(p.broadcastUpdated) ? !!p.broadcastUpdated : !1
      };
    },
    toJSON(p) {
      const b = {};
      return p.destination !== void 0 && (b.destination = p.destination ? a.Destination.toJSON(p.destination) : void 0), p.broadcastUpdated !== void 0 && (b.broadcastUpdated = p.broadcastUpdated), b;
    },
    fromPartial(p) {
      var b;
      const T = Cn();
      return T.destination = p.destination !== void 0 && p.destination !== null ? a.Destination.fromPartial(p.destination) : void 0, T.broadcastUpdated = (b = p.broadcastUpdated) !== null && b !== void 0 ? b : !1, T;
    }
  };
  function Rn() {
    return { collectionId: "", metadata: void 0, address: void 0, preview: void 0 };
  }
  a.CreateSourceRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(18).fork()).ldelim(), p.address !== void 0 && a.SourceAddress.encode(p.address, b.uint32(26).fork()).ldelim(), p.preview !== void 0 && a.PreviewAddress.encode(p.preview, b.uint32(34).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Rn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));
            break;
          case 3:
            U.address = a.SourceAddress.decode(T, T.uint32());
            break;
          case 4:
            U.preview = a.PreviewAddress.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,
        address: ce(p.address) ? a.SourceAddress.fromJSON(p.address) : void 0,
        preview: ce(p.preview) ? a.PreviewAddress.fromJSON(p.preview) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.metadata !== void 0 && (b.metadata = p.metadata), p.address !== void 0 && (b.address = p.address ? a.SourceAddress.toJSON(p.address) : void 0), p.preview !== void 0 && (b.preview = p.preview ? a.PreviewAddress.toJSON(p.preview) : void 0), b;
    },
    fromPartial(p) {
      var b, T;
      const K = Rn();
      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", K.metadata = (T = p.metadata) !== null && T !== void 0 ? T : void 0, K.address = p.address !== void 0 && p.address !== null ? a.SourceAddress.fromPartial(p.address) : void 0, K.preview = p.preview !== void 0 && p.preview !== null ? a.PreviewAddress.fromPartial(p.preview) : void 0, K;
    }
  };
  function Pn() {
    return { source: void 0 };
  }
  a.CreateSourceResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.source !== void 0 && a.Source.encode(p.source, b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Pn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.source = a.Source.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { source: ce(p.source) ? a.Source.fromJSON(p.source) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.source !== void 0 && (b.source = p.source ? a.Source.toJSON(p.source) : void 0), b;
    },
    fromPartial(p) {
      const b = Pn();
      return b.source = p.source !== void 0 && p.source !== null ? a.Source.fromPartial(p.source) : void 0, b;
    }
  };
  function On() {
    return { collectionId: "", sourceId: "", force: void 0 };
  }
  a.DeleteSourceRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.sourceId !== "" && b.uint32(18).string(p.sourceId), p.force !== void 0 && b.uint32(24).bool(p.force), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = On();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.sourceId = T.string();
            break;
          case 3:
            U.force = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : "",
        force: ce(p.force) ? !!p.force : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.force !== void 0 && (b.force = p.force), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = On();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : "", U.force = (K = p.force) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function Nn() {
    return { projectIdsUpdated: [] };
  }
  a.DeleteSourceResponse = {
    encode(p, b = c.default.Writer.create()) {
      for (const T of p.projectIdsUpdated)
        b.uint32(26).string(T);
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Nn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 3:
            U.projectIdsUpdated.push(T.string());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        projectIdsUpdated: Array.isArray(p == null ? void 0 : p.projectIdsUpdated) ? p.projectIdsUpdated.map((b) => String(b)) : []
      };
    },
    toJSON(p) {
      const b = {};
      return p.projectIdsUpdated ? b.projectIdsUpdated = p.projectIdsUpdated.map((T) => T) : b.projectIdsUpdated = [], b;
    },
    fromPartial(p) {
      var b;
      const T = Nn();
      return T.projectIdsUpdated = ((b = p.projectIdsUpdated) === null || b === void 0 ? void 0 : b.map((K) => K)) || [], T;
    }
  };
  function wn() {
    return { collectionId: "", projectId: "", sourceId: "", trigger: void 0 };
  }
  a.AddSourceToProjectRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.sourceId !== "" && b.uint32(26).string(p.sourceId), p.trigger !== void 0 && a.SourceTrigger.encode(p.trigger, b.uint32(34).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = wn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.sourceId = T.string();
            break;
          case 4:
            U.trigger = a.SourceTrigger.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : "",
        trigger: ce(p.trigger) ? a.SourceTrigger.fromJSON(p.trigger) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.trigger !== void 0 && (b.trigger = p.trigger ? a.SourceTrigger.toJSON(p.trigger) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = wn();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", U.sourceId = (K = p.sourceId) !== null && K !== void 0 ? K : "", U.trigger = p.trigger !== void 0 && p.trigger !== null ? a.SourceTrigger.fromPartial(p.trigger) : void 0, U;
    }
  };
  function An() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.AddSourceToProjectResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(10).fork()).ldelim(), p.broadcastUpdated === !0 && b.uint32(16).bool(p.broadcastUpdated), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = An();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.project = a.Project.decode(T, T.uint32());
            break;
          case 2:
            U.broadcastUpdated = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0,
        broadcastUpdated: ce(p.broadcastUpdated) ? !!p.broadcastUpdated : !1
      };
    },
    toJSON(p) {
      const b = {};
      return p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), p.broadcastUpdated !== void 0 && (b.broadcastUpdated = p.broadcastUpdated), b;
    },
    fromPartial(p) {
      var b;
      const T = An();
      return T.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, T.broadcastUpdated = (b = p.broadcastUpdated) !== null && b !== void 0 ? b : !1, T;
    }
  };
  function Dn() {
    return { collectionId: "", projectId: "", sourceId: "", updateMask: void 0, trigger: void 0 };
  }
  a.UpdateSourceInProjectRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.sourceId !== "" && b.uint32(26).string(p.sourceId), p.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(p.updateMask), b.uint32(34).fork()).ldelim(), p.trigger !== void 0 && a.SourceTrigger.encode(p.trigger, b.uint32(42).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Dn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.sourceId = T.string();
            break;
          case 4:
            U.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(T, T.uint32()));
            break;
          case 5:
            U.trigger = a.SourceTrigger.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : "",
        updateMask: ce(p.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(p.updateMask)) : void 0,
        trigger: ce(p.trigger) ? a.SourceTrigger.fromJSON(p.trigger) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.updateMask !== void 0 && (b.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(p.updateMask))), p.trigger !== void 0 && (b.trigger = p.trigger ? a.SourceTrigger.toJSON(p.trigger) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K, U;
      const te = Dn();
      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", te.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", te.sourceId = (K = p.sourceId) !== null && K !== void 0 ? K : "", te.updateMask = (U = p.updateMask) !== null && U !== void 0 ? U : void 0, te.trigger = p.trigger !== void 0 && p.trigger !== null ? a.SourceTrigger.fromPartial(p.trigger) : void 0, te;
    }
  };
  function Ln() {
    return { project: void 0 };
  }
  a.UpdateSourceInProjectResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Ln();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.project = a.Project.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), b;
    },
    fromPartial(p) {
      const b = Ln();
      return b.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, b;
    }
  };
  function Mn() {
    return { collectionId: "", sourceId: "" };
  }
  a.GetSourceRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.sourceId !== "" && b.uint32(26).string(p.sourceId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Mn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 3:
            U.sourceId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), b;
    },
    fromPartial(p) {
      var b, T;
      const K = Mn();
      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", K.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : "", K;
    }
  };
  function Un() {
    return { source: void 0 };
  }
  a.GetSourceResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.source !== void 0 && a.Source.encode(p.source, b.uint32(10).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Un();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.source = a.Source.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { source: ce(p.source) ? a.Source.fromJSON(p.source) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.source !== void 0 && (b.source = p.source ? a.Source.toJSON(p.source) : void 0), b;
    },
    fromPartial(p) {
      const b = Un();
      return b.source = p.source !== void 0 && p.source !== null ? a.Source.fromPartial(p.source) : void 0, b;
    }
  };
  function $n() {
    return { collectionId: "" };
  }
  a.GetSourcesRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = $n();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { collectionId: ce(p.collectionId) ? String(p.collectionId) : "" };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), b;
    },
    fromPartial(p) {
      var b;
      const T = $n();
      return T.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", T;
    }
  };
  function Bn() {
    return { sources: [] };
  }
  a.GetSourcesResponse = {
    encode(p, b = c.default.Writer.create()) {
      for (const T of p.sources)
        a.Source.encode(T, b.uint32(10).fork()).ldelim();
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Bn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.sources.push(a.Source.decode(T, T.uint32()));
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { sources: Array.isArray(p == null ? void 0 : p.sources) ? p.sources.map((b) => a.Source.fromJSON(b)) : [] };
    },
    toJSON(p) {
      const b = {};
      return p.sources ? b.sources = p.sources.map((T) => T ? a.Source.toJSON(T) : void 0) : b.sources = [], b;
    },
    fromPartial(p) {
      var b;
      const T = Bn();
      return T.sources = ((b = p.sources) === null || b === void 0 ? void 0 : b.map((K) => a.Source.fromPartial(K))) || [], T;
    }
  };
  function Jn() {
    return {
      collectionId: "",
      sourceId: "",
      updateMask: void 0,
      metadata: void 0,
      address: void 0,
      preview: void 0
    };
  }
  a.UpdateSourceRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.sourceId !== "" && b.uint32(26).string(p.sourceId), p.updateMask !== void 0 && v.FieldMask.encode(v.FieldMask.wrap(p.updateMask), b.uint32(34).fork()).ldelim(), p.metadata !== void 0 && S.Value.encode(S.Value.wrap(p.metadata), b.uint32(42).fork()).ldelim(), p.address !== void 0 && a.SourceAddress.encode(p.address, b.uint32(50).fork()).ldelim(), p.preview !== void 0 && a.PreviewAddress.encode(p.preview, b.uint32(58).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Jn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 3:
            U.sourceId = T.string();
            break;
          case 4:
            U.updateMask = v.FieldMask.unwrap(v.FieldMask.decode(T, T.uint32()));
            break;
          case 5:
            U.metadata = S.Value.unwrap(S.Value.decode(T, T.uint32()));
            break;
          case 6:
            U.address = a.SourceAddress.decode(T, T.uint32());
            break;
          case 7:
            U.preview = a.PreviewAddress.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : "",
        updateMask: ce(p.updateMask) ? v.FieldMask.unwrap(v.FieldMask.fromJSON(p.updateMask)) : void 0,
        metadata: ce(p == null ? void 0 : p.metadata) ? p.metadata : void 0,
        address: ce(p.address) ? a.SourceAddress.fromJSON(p.address) : void 0,
        preview: ce(p.preview) ? a.PreviewAddress.fromJSON(p.preview) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.updateMask !== void 0 && (b.updateMask = v.FieldMask.toJSON(v.FieldMask.wrap(p.updateMask))), p.metadata !== void 0 && (b.metadata = p.metadata), p.address !== void 0 && (b.address = p.address ? a.SourceAddress.toJSON(p.address) : void 0), p.preview !== void 0 && (b.preview = p.preview ? a.PreviewAddress.toJSON(p.preview) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K, U;
      const te = Jn();
      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", te.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : "", te.updateMask = (K = p.updateMask) !== null && K !== void 0 ? K : void 0, te.metadata = (U = p.metadata) !== null && U !== void 0 ? U : void 0, te.address = p.address !== void 0 && p.address !== null ? a.SourceAddress.fromPartial(p.address) : void 0, te.preview = p.preview !== void 0 && p.preview !== null ? a.PreviewAddress.fromPartial(p.preview) : void 0, te;
    }
  };
  function Fn() {
    return { source: void 0, broadcastUpdated: !1 };
  }
  a.UpdateSourceResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.source !== void 0 && a.Source.encode(p.source, b.uint32(10).fork()).ldelim(), p.broadcastUpdated === !0 && b.uint32(16).bool(p.broadcastUpdated), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Fn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.source = a.Source.decode(T, T.uint32());
            break;
          case 2:
            U.broadcastUpdated = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        source: ce(p.source) ? a.Source.fromJSON(p.source) : void 0,
        broadcastUpdated: ce(p.broadcastUpdated) ? !!p.broadcastUpdated : !1
      };
    },
    toJSON(p) {
      const b = {};
      return p.source !== void 0 && (b.source = p.source ? a.Source.toJSON(p.source) : void 0), p.broadcastUpdated !== void 0 && (b.broadcastUpdated = p.broadcastUpdated), b;
    },
    fromPartial(p) {
      var b;
      const T = Fn();
      return T.source = p.source !== void 0 && p.source !== null ? a.Source.fromPartial(p.source) : void 0, T.broadcastUpdated = (b = p.broadcastUpdated) !== null && b !== void 0 ? b : !1, T;
    }
  };
  function Vn() {
    return { collectionId: "", projectId: "", sourceId: "", force: void 0 };
  }
  a.RemoveSourceFromProjectRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.sourceId !== "" && b.uint32(26).string(p.sourceId), p.force !== void 0 && b.uint32(32).bool(p.force), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Vn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.sourceId = T.string();
            break;
          case 4:
            U.force = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : "",
        force: ce(p.force) ? !!p.force : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.force !== void 0 && (b.force = p.force), b;
    },
    fromPartial(p) {
      var b, T, K, U;
      const te = Vn();
      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", te.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", te.sourceId = (K = p.sourceId) !== null && K !== void 0 ? K : "", te.force = (U = p.force) !== null && U !== void 0 ? U : void 0, te;
    }
  };
  function qn() {
    return { project: void 0, broadcastUpdated: !1 };
  }
  a.RemoveSourceFromProjectResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(10).fork()).ldelim(), p.broadcastUpdated === !0 && b.uint32(16).bool(p.broadcastUpdated), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = qn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.project = a.Project.decode(T, T.uint32());
            break;
          case 2:
            U.broadcastUpdated = T.bool();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0,
        broadcastUpdated: ce(p.broadcastUpdated) ? !!p.broadcastUpdated : !1
      };
    },
    toJSON(p) {
      const b = {};
      return p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), p.broadcastUpdated !== void 0 && (b.broadcastUpdated = p.broadcastUpdated), b;
    },
    fromPartial(p) {
      var b;
      const T = qn();
      return T.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, T.broadcastUpdated = (b = p.broadcastUpdated) !== null && b !== void 0 ? b : !1, T;
    }
  };
  function Gn() {
    return { collectionId: "", sourceId: "", accessToken: void 0 };
  }
  a.GetSourcePlaylistRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.sourceId !== "" && b.uint32(26).string(p.sourceId), p.accessToken !== void 0 && b.uint32(34).string(p.accessToken), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Gn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 3:
            U.sourceId = T.string();
            break;
          case 4:
            U.accessToken = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : "",
        accessToken: ce(p.accessToken) ? String(p.accessToken) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.accessToken !== void 0 && (b.accessToken = p.accessToken), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = Gn();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : "", U.accessToken = (K = p.accessToken) !== null && K !== void 0 ? K : void 0, U;
    }
  };
  function Wn() {
    return { manifest: "" };
  }
  a.GetSourcePlaylistResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.manifest !== "" && b.uint32(10).string(p.manifest), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Wn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.manifest = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { manifest: ce(p.manifest) ? String(p.manifest) : "" };
    },
    toJSON(p) {
      const b = {};
      return p.manifest !== void 0 && (b.manifest = p.manifest), b;
    },
    fromPartial(p) {
      var b;
      const T = Wn();
      return T.manifest = (b = p.manifest) !== null && b !== void 0 ? b : "", T;
    }
  };
  function Hn() {
    return { serviceUserId: "", displayName: void 0, role: void 0, maxDuration: void 0 };
  }
  a.CreateAccessTokenRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.serviceUserId !== "" && b.uint32(10).string(p.serviceUserId), p.displayName !== void 0 && b.uint32(34).string(p.displayName), p.role !== void 0 && b.uint32(16).int32(Oe(p.role)), p.maxDuration !== void 0 && b.uint32(24).uint32(p.maxDuration), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Hn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.serviceUserId = T.string();
            break;
          case 4:
            U.displayName = T.string();
            break;
          case 2:
            U.role = je(T.int32());
            break;
          case 3:
            U.maxDuration = T.uint32();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        serviceUserId: ce(p.serviceUserId) ? String(p.serviceUserId) : "",
        displayName: ce(p.displayName) ? String(p.displayName) : void 0,
        role: ce(p.role) ? je(p.role) : void 0,
        maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.serviceUserId !== void 0 && (b.serviceUserId = p.serviceUserId), p.displayName !== void 0 && (b.displayName = p.displayName), p.role !== void 0 && (b.role = p.role !== void 0 ? tt(p.role) : void 0), p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), b;
    },
    fromPartial(p) {
      var b, T, K, U;
      const te = Hn();
      return te.serviceUserId = (b = p.serviceUserId) !== null && b !== void 0 ? b : "", te.displayName = (T = p.displayName) !== null && T !== void 0 ? T : void 0, te.role = (K = p.role) !== null && K !== void 0 ? K : void 0, te.maxDuration = (U = p.maxDuration) !== null && U !== void 0 ? U : void 0, te;
    }
  };
  function xn() {
    return { accessToken: "" };
  }
  a.CreateAccessTokenResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.accessToken !== "" && b.uint32(10).string(p.accessToken), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = xn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.accessToken = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { accessToken: ce(p.accessToken) ? String(p.accessToken) : "" };
    },
    toJSON(p) {
      const b = {};
      return p.accessToken !== void 0 && (b.accessToken = p.accessToken), b;
    },
    fromPartial(p) {
      var b;
      const T = xn();
      return T.accessToken = (b = p.accessToken) !== null && b !== void 0 ? b : "", T;
    }
  };
  function zn() {
    return { displayName: "", serviceUserId: void 0 };
  }
  a.GuestAccessTokenDirect = {
    encode(p, b = c.default.Writer.create()) {
      return p.displayName !== "" && b.uint32(10).string(p.displayName), p.serviceUserId !== void 0 && b.uint32(18).string(p.serviceUserId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = zn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.displayName = T.string();
            break;
          case 2:
            U.serviceUserId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        displayName: ce(p.displayName) ? String(p.displayName) : "",
        serviceUserId: ce(p.serviceUserId) ? String(p.serviceUserId) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.displayName !== void 0 && (b.displayName = p.displayName), p.serviceUserId !== void 0 && (b.serviceUserId = p.serviceUserId), b;
    },
    fromPartial(p) {
      var b, T;
      const K = zn();
      return K.displayName = (b = p.displayName) !== null && b !== void 0 ? b : "", K.serviceUserId = (T = p.serviceUserId) !== null && T !== void 0 ? T : void 0, K;
    }
  };
  function Yn() {
    return { maxDuration: void 0 };
  }
  a.GuestAccessTokenExchange = {
    encode(p, b = c.default.Writer.create()) {
      return p.maxDuration !== void 0 && b.uint32(8).uint32(p.maxDuration), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Yn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.maxDuration = T.uint32();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), b;
    },
    fromPartial(p) {
      var b;
      const T = Yn();
      return T.maxDuration = (b = p.maxDuration) !== null && b !== void 0 ? b : void 0, T;
    }
  };
  function Kn() {
    return { direct: void 0, exchange: void 0 };
  }
  a.GuestAccessToken = {
    encode(p, b = c.default.Writer.create()) {
      return p.direct !== void 0 && a.GuestAccessTokenDirect.encode(p.direct, b.uint32(10).fork()).ldelim(), p.exchange !== void 0 && a.GuestAccessTokenExchange.encode(p.exchange, b.uint32(18).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Kn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.direct = a.GuestAccessTokenDirect.decode(T, T.uint32());
            break;
          case 2:
            U.exchange = a.GuestAccessTokenExchange.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        direct: ce(p.direct) ? a.GuestAccessTokenDirect.fromJSON(p.direct) : void 0,
        exchange: ce(p.exchange) ? a.GuestAccessTokenExchange.fromJSON(p.exchange) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.direct !== void 0 && (b.direct = p.direct ? a.GuestAccessTokenDirect.toJSON(p.direct) : void 0), p.exchange !== void 0 && (b.exchange = p.exchange ? a.GuestAccessTokenExchange.toJSON(p.exchange) : void 0), b;
    },
    fromPartial(p) {
      const b = Kn();
      return b.direct = p.direct !== void 0 && p.direct !== null ? a.GuestAccessTokenDirect.fromPartial(p.direct) : void 0, b.exchange = p.exchange !== void 0 && p.exchange !== null ? a.GuestAccessTokenExchange.fromPartial(p.exchange) : void 0, b;
    }
  };
  function Qn() {
    return {
      collectionId: "",
      projectId: "",
      maxDuration: void 0,
      role: Ye.ROLE_UNSPECIFIED,
      token: void 0,
      url: void 0
    };
  }
  a.CreateGuestAccessTokenRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.maxDuration !== void 0 && b.uint32(24).uint32(p.maxDuration), p.role !== Ye.ROLE_UNSPECIFIED && b.uint32(32).int32(Oe(p.role)), p.token !== void 0 && a.GuestAccessToken.encode(p.token, b.uint32(42).fork()).ldelim(), p.url !== void 0 && b.uint32(50).string(p.url), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Qn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.maxDuration = T.uint32();
            break;
          case 4:
            U.role = je(T.int32());
            break;
          case 5:
            U.token = a.GuestAccessToken.decode(T, T.uint32());
            break;
          case 6:
            U.url = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        maxDuration: ce(p.maxDuration) ? Number(p.maxDuration) : void 0,
        role: ce(p.role) ? je(p.role) : Ye.ROLE_UNSPECIFIED,
        token: ce(p.token) ? a.GuestAccessToken.fromJSON(p.token) : void 0,
        url: ce(p.url) ? String(p.url) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.maxDuration !== void 0 && (b.maxDuration = Math.round(p.maxDuration)), p.role !== void 0 && (b.role = tt(p.role)), p.token !== void 0 && (b.token = p.token ? a.GuestAccessToken.toJSON(p.token) : void 0), p.url !== void 0 && (b.url = p.url), b;
    },
    fromPartial(p) {
      var b, T, K, U, te;
      const We = Qn();
      return We.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", We.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", We.maxDuration = (K = p.maxDuration) !== null && K !== void 0 ? K : void 0, We.role = (U = p.role) !== null && U !== void 0 ? U : Ye.ROLE_UNSPECIFIED, We.token = p.token !== void 0 && p.token !== null ? a.GuestAccessToken.fromPartial(p.token) : void 0, We.url = (te = p.url) !== null && te !== void 0 ? te : void 0, We;
    }
  };
  function Zn() {
    return { accessToken: "", url: void 0 };
  }
  a.CreateGuestAccessTokenResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.accessToken !== "" && b.uint32(10).string(p.accessToken), p.url !== void 0 && b.uint32(18).string(p.url), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Zn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.accessToken = T.string();
            break;
          case 2:
            U.url = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        accessToken: ce(p.accessToken) ? String(p.accessToken) : "",
        url: ce(p.url) ? String(p.url) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.accessToken !== void 0 && (b.accessToken = p.accessToken), p.url !== void 0 && (b.url = p.url), b;
    },
    fromPartial(p) {
      var b, T;
      const K = Zn();
      return K.accessToken = (b = p.accessToken) !== null && b !== void 0 ? b : "", K.url = (T = p.url) !== null && T !== void 0 ? T : void 0, K;
    }
  };
  function Xn() {
    return { collectionId: "", projectId: "", displayName: "" };
  }
  a.CreateWebRtcAccessTokenRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.displayName !== "" && b.uint32(26).string(p.displayName), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Xn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.displayName = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        displayName: ce(p.displayName) ? String(p.displayName) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.displayName !== void 0 && (b.displayName = p.displayName), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = Xn();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", U.displayName = (K = p.displayName) !== null && K !== void 0 ? K : "", U;
    }
  };
  function jn() {
    return { webrtcAccess: void 0 };
  }
  a.CreateWebRtcAccessTokenResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.webrtcAccess !== void 0 && a.WebRtcAccess.encode(p.webrtcAccess, b.uint32(18).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = jn();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 2:
            U.webrtcAccess = a.WebRtcAccess.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { webrtcAccess: ce(p.webrtcAccess) ? a.WebRtcAccess.fromJSON(p.webrtcAccess) : void 0 };
    },
    toJSON(p) {
      const b = {};
      return p.webrtcAccess !== void 0 && (b.webrtcAccess = p.webrtcAccess ? a.WebRtcAccess.toJSON(p.webrtcAccess) : void 0), b;
    },
    fromPartial(p) {
      const b = jn();
      return b.webrtcAccess = p.webrtcAccess !== void 0 && p.webrtcAccess !== null ? a.WebRtcAccess.fromPartial(p.webrtcAccess) : void 0, b;
    }
  };
  function er() {
    return {};
  }
  a.RefreshAccessTokenRequest = {
    encode(p, b = c.default.Writer.create()) {
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = er();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {};
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return er();
    }
  };
  function tr() {
    return {};
  }
  a.RefreshAccessTokenResponse = {
    encode(p, b = c.default.Writer.create()) {
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = tr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {};
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return tr();
    }
  };
  function nr() {
    return { collectionId: "", projectId: "", code: "", url: "", autoDelete: void 0 };
  }
  a.GuestCode = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.code !== "" && b.uint32(26).string(p.code), p.url !== "" && b.uint32(34).string(p.url), p.autoDelete !== void 0 && g.Timestamp.encode(Ut(p.autoDelete), b.uint32(42).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = nr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.code = T.string();
            break;
          case 4:
            U.url = T.string();
            break;
          case 5:
            U.autoDelete = $t(g.Timestamp.decode(T, T.uint32()));
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        code: ce(p.code) ? String(p.code) : "",
        url: ce(p.url) ? String(p.url) : "",
        autoDelete: ce(p.autoDelete) ? String(p.autoDelete) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.code !== void 0 && (b.code = p.code), p.url !== void 0 && (b.url = p.url), p.autoDelete !== void 0 && (b.autoDelete = p.autoDelete), b;
    },
    fromPartial(p) {
      var b, T, K, U, te;
      const We = nr();
      return We.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", We.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", We.code = (K = p.code) !== null && K !== void 0 ? K : "", We.url = (U = p.url) !== null && U !== void 0 ? U : "", We.autoDelete = (te = p.autoDelete) !== null && te !== void 0 ? te : void 0, We;
    }
  };
  function rr() {
    return { serviceId: "", code: "" };
  }
  a.GuestCodeRedirectRequest = {
    encode(p, b = c.default.Writer.create()) {
      return p.serviceId !== "" && b.uint32(10).string(p.serviceId), p.code !== "" && b.uint32(18).string(p.code), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = rr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.serviceId = T.string();
            break;
          case 2:
            U.code = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        serviceId: ce(p.serviceId) ? String(p.serviceId) : "",
        code: ce(p.code) ? String(p.code) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.serviceId !== void 0 && (b.serviceId = p.serviceId), p.code !== void 0 && (b.code = p.code), b;
    },
    fromPartial(p) {
      var b, T;
      const K = rr();
      return K.serviceId = (b = p.serviceId) !== null && b !== void 0 ? b : "", K.code = (T = p.code) !== null && T !== void 0 ? T : "", K;
    }
  };
  function ir() {
    return {};
  }
  a.GuestCodeRedirectResponse = {
    encode(p, b = c.default.Writer.create()) {
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = ir();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {};
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return ir();
    }
  };
  function ar() {
    return { alg: "", kty: "", use: "", kid: "", e: "", n: "" };
  }
  a.JsonWebKey = {
    encode(p, b = c.default.Writer.create()) {
      return p.alg !== "" && b.uint32(10).string(p.alg), p.kty !== "" && b.uint32(18).string(p.kty), p.use !== "" && b.uint32(26).string(p.use), p.kid !== "" && b.uint32(34).string(p.kid), p.e !== "" && b.uint32(42).string(p.e), p.n !== "" && b.uint32(50).string(p.n), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = ar();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.alg = T.string();
            break;
          case 2:
            U.kty = T.string();
            break;
          case 3:
            U.use = T.string();
            break;
          case 4:
            U.kid = T.string();
            break;
          case 5:
            U.e = T.string();
            break;
          case 6:
            U.n = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        alg: ce(p.alg) ? String(p.alg) : "",
        kty: ce(p.kty) ? String(p.kty) : "",
        use: ce(p.use) ? String(p.use) : "",
        kid: ce(p.kid) ? String(p.kid) : "",
        e: ce(p.e) ? String(p.e) : "",
        n: ce(p.n) ? String(p.n) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.alg !== void 0 && (b.alg = p.alg), p.kty !== void 0 && (b.kty = p.kty), p.use !== void 0 && (b.use = p.use), p.kid !== void 0 && (b.kid = p.kid), p.e !== void 0 && (b.e = p.e), p.n !== void 0 && (b.n = p.n), b;
    },
    fromPartial(p) {
      var b, T, K, U, te, We;
      const et = ar();
      return et.alg = (b = p.alg) !== null && b !== void 0 ? b : "", et.kty = (T = p.kty) !== null && T !== void 0 ? T : "", et.use = (K = p.use) !== null && K !== void 0 ? K : "", et.kid = (U = p.kid) !== null && U !== void 0 ? U : "", et.e = (te = p.e) !== null && te !== void 0 ? te : "", et.n = (We = p.n) !== null && We !== void 0 ? We : "", et;
    }
  };
  function or() {
    return {};
  }
  a.GetJsonWebKeySetRequest = {
    encode(p, b = c.default.Writer.create()) {
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = or();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {};
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return or();
    }
  };
  function sr() {
    return { keys: [] };
  }
  a.GetJsonWebKeySetResponse = {
    encode(p, b = c.default.Writer.create()) {
      for (const T of p.keys)
        a.JsonWebKey.encode(T, b.uint32(10).fork()).ldelim();
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = sr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.keys.push(a.JsonWebKey.decode(T, T.uint32()));
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { keys: Array.isArray(p == null ? void 0 : p.keys) ? p.keys.map((b) => a.JsonWebKey.fromJSON(b)) : [] };
    },
    toJSON(p) {
      const b = {};
      return p.keys ? b.keys = p.keys.map((T) => T ? a.JsonWebKey.toJSON(T) : void 0) : b.keys = [], b;
    },
    fromPartial(p) {
      var b;
      const T = sr();
      return T.keys = ((b = p.keys) === null || b === void 0 ? void 0 : b.map((K) => a.JsonWebKey.fromPartial(K))) || [], T;
    }
  };
  function dr() {
    return {};
  }
  a.GetTestTokenRequest = {
    encode(p, b = c.default.Writer.create()) {
      return b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = dr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {};
    },
    toJSON(p) {
      return {};
    },
    fromPartial(p) {
      return dr();
    }
  };
  function ur() {
    return { accessToken: "" };
  }
  a.GetTestTokenResponse = {
    encode(p, b = c.default.Writer.create()) {
      return p.accessToken !== "" && b.uint32(10).string(p.accessToken), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = ur();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.accessToken = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { accessToken: ce(p.accessToken) ? String(p.accessToken) : "" };
    },
    toJSON(p) {
      const b = {};
      return p.accessToken !== void 0 && (b.accessToken = p.accessToken), b;
    },
    fromPartial(p) {
      var b;
      const T = ur();
      return T.accessToken = (b = p.accessToken) !== null && b !== void 0 ? b : "", T;
    }
  };
  function cr() {
    return { collectionId: "", projectId: "", destinationId: "", destination: void 0 };
  }
  a.DestinationCreateEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.destinationId !== "" && b.uint32(26).string(p.destinationId), p.destination !== void 0 && a.Destination.encode(p.destination, b.uint32(34).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = cr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.destinationId = T.string();
            break;
          case 4:
            U.destination = a.Destination.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        destinationId: ce(p.destinationId) ? String(p.destinationId) : "",
        destination: ce(p.destination) ? a.Destination.fromJSON(p.destination) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), p.destination !== void 0 && (b.destination = p.destination ? a.Destination.toJSON(p.destination) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = cr();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", U.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : "", U.destination = p.destination !== void 0 && p.destination !== null ? a.Destination.fromPartial(p.destination) : void 0, U;
    }
  };
  function lr() {
    return { collectionId: "", projectId: "", destinationId: "" };
  }
  a.DestinationDeleteEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.destinationId !== "" && b.uint32(26).string(p.destinationId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = lr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.destinationId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        destinationId: ce(p.destinationId) ? String(p.destinationId) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = lr();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", U.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : "", U;
    }
  };
  function fr() {
    return { collectionId: "", projectId: "", destinationId: "", updateMask: [], destination: void 0 };
  }
  a.DestinationUpdateEvent = {
    encode(p, b = c.default.Writer.create()) {
      p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.destinationId !== "" && b.uint32(26).string(p.destinationId);
      for (const T of p.updateMask)
        b.uint32(34).string(T);
      return p.destination !== void 0 && a.Destination.encode(p.destination, b.uint32(42).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = fr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.destinationId = T.string();
            break;
          case 4:
            U.updateMask.push(T.string());
            break;
          case 5:
            U.destination = a.Destination.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        destinationId: ce(p.destinationId) ? String(p.destinationId) : "",
        updateMask: Array.isArray(p == null ? void 0 : p.updateMask) ? p.updateMask.map((b) => String(b)) : [],
        destination: ce(p.destination) ? a.Destination.fromJSON(p.destination) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), p.updateMask ? b.updateMask = p.updateMask.map((T) => T) : b.updateMask = [], p.destination !== void 0 && (b.destination = p.destination ? a.Destination.toJSON(p.destination) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K, U;
      const te = fr();
      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", te.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", te.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : "", te.updateMask = ((U = p.updateMask) === null || U === void 0 ? void 0 : U.map((We) => We)) || [], te.destination = p.destination !== void 0 && p.destination !== null ? a.Destination.fromPartial(p.destination) : void 0, te;
    }
  };
  function pr() {
    return { collectionId: "", projectId: "", destinationId: "", connect: void 0 };
  }
  a.DestinationStateEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.destinationId !== "" && b.uint32(26).string(p.destinationId), p.connect !== void 0 && b.uint32(32).int32(se(p.connect)), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = pr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.destinationId = T.string();
            break;
          case 4:
            U.connect = O(T.int32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        destinationId: ce(p.destinationId) ? String(p.destinationId) : "",
        connect: ce(p.connect) ? O(p.connect) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.destinationId !== void 0 && (b.destinationId = p.destinationId), p.connect !== void 0 && (b.connect = p.connect !== void 0 ? j(p.connect) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K, U;
      const te = pr();
      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", te.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", te.destinationId = (K = p.destinationId) !== null && K !== void 0 ? K : "", te.connect = (U = p.connect) !== null && U !== void 0 ? U : void 0, te;
    }
  };
  function hr() {
    return { collectionId: "", projectId: "", project: void 0 };
  }
  a.ProjectCreateEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.project !== void 0 && a.Project.encode(p.project, b.uint32(26).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = hr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.project = a.Project.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), b;
    },
    fromPartial(p) {
      var b, T;
      const K = hr();
      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", K.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", K.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, K;
    }
  };
  function mr() {
    return { collectionId: "", projectId: "" };
  }
  a.ProjectDeleteEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = mr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), b;
    },
    fromPartial(p) {
      var b, T;
      const K = mr();
      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", K.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", K;
    }
  };
  function vr() {
    return { collectionId: "", projectId: "", updateMask: [], project: void 0 };
  }
  a.ProjectUpdateEvent = {
    encode(p, b = c.default.Writer.create()) {
      p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId);
      for (const T of p.updateMask)
        b.uint32(26).string(T);
      return p.project !== void 0 && a.Project.encode(p.project, b.uint32(34).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = vr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.updateMask.push(T.string());
            break;
          case 4:
            U.project = a.Project.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        updateMask: Array.isArray(p == null ? void 0 : p.updateMask) ? p.updateMask.map((b) => String(b)) : [],
        project: ce(p.project) ? a.Project.fromJSON(p.project) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.updateMask ? b.updateMask = p.updateMask.map((T) => T) : b.updateMask = [], p.project !== void 0 && (b.project = p.project ? a.Project.toJSON(p.project) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = vr();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", U.updateMask = ((K = p.updateMask) === null || K === void 0 ? void 0 : K.map((te) => te)) || [], U.project = p.project !== void 0 && p.project !== null ? a.Project.fromPartial(p.project) : void 0, U;
    }
  };
  function Sr() {
    return { collectionId: "", projectId: "", broadcastId: "", phase: void 0, error: void 0 };
  }
  a.ProjectBroadcastStateEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.broadcastId !== "" && b.uint32(26).string(p.broadcastId), p.phase !== void 0 && b.uint32(32).int32(Ve(p.phase)), p.error !== void 0 && b.uint32(40).int32(Ee(p.error)), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Sr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.broadcastId = T.string();
            break;
          case 4:
            U.phase = Ge(T.int32());
            break;
          case 5:
            U.error = X(T.int32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        broadcastId: ce(p.broadcastId) ? String(p.broadcastId) : "",
        phase: ce(p.phase) ? Ge(p.phase) : void 0,
        error: ce(p.error) ? X(p.error) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.broadcastId !== void 0 && (b.broadcastId = p.broadcastId), p.phase !== void 0 && (b.phase = p.phase !== void 0 ? He(p.phase) : void 0), p.error !== void 0 && (b.error = p.error !== void 0 ? ie(p.error) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K, U, te;
      const We = Sr();
      return We.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", We.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", We.broadcastId = (K = p.broadcastId) !== null && K !== void 0 ? K : "", We.phase = (U = p.phase) !== null && U !== void 0 ? U : void 0, We.error = (te = p.error) !== null && te !== void 0 ? te : void 0, We;
    }
  };
  function yr() {
    return { collectionId: "", collection: void 0 };
  }
  a.CollectionCreateEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.collection !== void 0 && a.Collection.encode(p.collection, b.uint32(18).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = yr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.collection = a.Collection.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        collection: ce(p.collection) ? a.Collection.fromJSON(p.collection) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.collection !== void 0 && (b.collection = p.collection ? a.Collection.toJSON(p.collection) : void 0), b;
    },
    fromPartial(p) {
      var b;
      const T = yr();
      return T.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", T.collection = p.collection !== void 0 && p.collection !== null ? a.Collection.fromPartial(p.collection) : void 0, T;
    }
  };
  function gr() {
    return { collectionId: "" };
  }
  a.CollectionDeleteEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = gr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return { collectionId: ce(p.collectionId) ? String(p.collectionId) : "" };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), b;
    },
    fromPartial(p) {
      var b;
      const T = gr();
      return T.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", T;
    }
  };
  function br() {
    return { collectionId: "", updateMask: [], collection: void 0 };
  }
  a.CollectionUpdateEvent = {
    encode(p, b = c.default.Writer.create()) {
      p.collectionId !== "" && b.uint32(10).string(p.collectionId);
      for (const T of p.updateMask)
        b.uint32(18).string(T);
      return p.collection !== void 0 && a.Collection.encode(p.collection, b.uint32(26).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = br();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.updateMask.push(T.string());
            break;
          case 3:
            U.collection = a.Collection.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        updateMask: Array.isArray(p == null ? void 0 : p.updateMask) ? p.updateMask.map((b) => String(b)) : [],
        collection: ce(p.collection) ? a.Collection.fromJSON(p.collection) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.updateMask ? b.updateMask = p.updateMask.map((T) => T) : b.updateMask = [], p.collection !== void 0 && (b.collection = p.collection ? a.Collection.toJSON(p.collection) : void 0), b;
    },
    fromPartial(p) {
      var b, T;
      const K = br();
      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", K.updateMask = ((T = p.updateMask) === null || T === void 0 ? void 0 : T.map((U) => U)) || [], K.collection = p.collection !== void 0 && p.collection !== null ? a.Collection.fromPartial(p.collection) : void 0, K;
    }
  };
  function Er() {
    return { collectionId: "", sourceId: "", source: void 0 };
  }
  a.SourceCreateEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.sourceId !== "" && b.uint32(18).string(p.sourceId), p.source !== void 0 && a.Source.encode(p.source, b.uint32(26).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Er();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.sourceId = T.string();
            break;
          case 3:
            U.source = a.Source.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : "",
        source: ce(p.source) ? a.Source.fromJSON(p.source) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.source !== void 0 && (b.source = p.source ? a.Source.toJSON(p.source) : void 0), b;
    },
    fromPartial(p) {
      var b, T;
      const K = Er();
      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", K.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : "", K.source = p.source !== void 0 && p.source !== null ? a.Source.fromPartial(p.source) : void 0, K;
    }
  };
  function Tr() {
    return { collectionId: "", sourceId: "" };
  }
  a.SourceDeleteEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.sourceId !== "" && b.uint32(18).string(p.sourceId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Tr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.sourceId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), b;
    },
    fromPartial(p) {
      var b, T;
      const K = Tr();
      return K.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", K.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : "", K;
    }
  };
  function _r() {
    return { collectionId: "", sourceId: "", updateMask: [], source: void 0 };
  }
  a.SourceUpdateEvent = {
    encode(p, b = c.default.Writer.create()) {
      p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.sourceId !== "" && b.uint32(18).string(p.sourceId);
      for (const T of p.updateMask)
        b.uint32(26).string(T);
      return p.source !== void 0 && a.Source.encode(p.source, b.uint32(34).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = _r();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.sourceId = T.string();
            break;
          case 3:
            U.updateMask.push(T.string());
            break;
          case 4:
            U.source = a.Source.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : "",
        updateMask: Array.isArray(p == null ? void 0 : p.updateMask) ? p.updateMask.map((b) => String(b)) : [],
        source: ce(p.source) ? a.Source.fromJSON(p.source) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.updateMask ? b.updateMask = p.updateMask.map((T) => T) : b.updateMask = [], p.source !== void 0 && (b.source = p.source ? a.Source.toJSON(p.source) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = _r();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : "", U.updateMask = ((K = p.updateMask) === null || K === void 0 ? void 0 : K.map((te) => te)) || [], U.source = p.source !== void 0 && p.source !== null ? a.Source.fromPartial(p.source) : void 0, U;
    }
  };
  function Ir() {
    return { collectionId: "", sourceId: "", projectId: "", source: void 0 };
  }
  a.SourceAddEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.sourceId !== "" && b.uint32(18).string(p.sourceId), p.projectId !== "" && b.uint32(26).string(p.projectId), p.source !== void 0 && a.Source.encode(p.source, b.uint32(34).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Ir();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.sourceId = T.string();
            break;
          case 3:
            U.projectId = T.string();
            break;
          case 4:
            U.source = a.Source.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        source: ce(p.source) ? a.Source.fromJSON(p.source) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.projectId !== void 0 && (b.projectId = p.projectId), p.source !== void 0 && (b.source = p.source ? a.Source.toJSON(p.source) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = Ir();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : "", U.projectId = (K = p.projectId) !== null && K !== void 0 ? K : "", U.source = p.source !== void 0 && p.source !== null ? a.Source.fromPartial(p.source) : void 0, U;
    }
  };
  function kr() {
    return { collectionId: "", sourceId: "", projectId: "" };
  }
  a.SourceRemoveEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.sourceId !== "" && b.uint32(18).string(p.sourceId), p.projectId !== "" && b.uint32(26).string(p.projectId), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = kr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.sourceId = T.string();
            break;
          case 3:
            U.projectId = T.string();
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : ""
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.projectId !== void 0 && (b.projectId = p.projectId), b;
    },
    fromPartial(p) {
      var b, T, K;
      const U = kr();
      return U.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", U.sourceId = (T = p.sourceId) !== null && T !== void 0 ? T : "", U.projectId = (K = p.projectId) !== null && K !== void 0 ? K : "", U;
    }
  };
  function Cr() {
    return { collectionId: "", projectId: "", sourceId: "", connect: void 0 };
  }
  a.SourceStateEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collectionId !== "" && b.uint32(10).string(p.collectionId), p.projectId !== "" && b.uint32(18).string(p.projectId), p.sourceId !== "" && b.uint32(26).string(p.sourceId), p.connect !== void 0 && b.uint32(32).int32(se(p.connect)), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Cr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collectionId = T.string();
            break;
          case 2:
            U.projectId = T.string();
            break;
          case 3:
            U.sourceId = T.string();
            break;
          case 4:
            U.connect = O(T.int32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collectionId: ce(p.collectionId) ? String(p.collectionId) : "",
        projectId: ce(p.projectId) ? String(p.projectId) : "",
        sourceId: ce(p.sourceId) ? String(p.sourceId) : "",
        connect: ce(p.connect) ? O(p.connect) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collectionId !== void 0 && (b.collectionId = p.collectionId), p.projectId !== void 0 && (b.projectId = p.projectId), p.sourceId !== void 0 && (b.sourceId = p.sourceId), p.connect !== void 0 && (b.connect = p.connect !== void 0 ? j(p.connect) : void 0), b;
    },
    fromPartial(p) {
      var b, T, K, U;
      const te = Cr();
      return te.collectionId = (b = p.collectionId) !== null && b !== void 0 ? b : "", te.projectId = (T = p.projectId) !== null && T !== void 0 ? T : "", te.sourceId = (K = p.sourceId) !== null && K !== void 0 ? K : "", te.connect = (U = p.connect) !== null && U !== void 0 ? U : void 0, te;
    }
  };
  function Rr() {
    return { create: void 0, update: void 0, delete: void 0 };
  }
  a.CollectionEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.create !== void 0 && a.CollectionCreateEvent.encode(p.create, b.uint32(10).fork()).ldelim(), p.update !== void 0 && a.CollectionUpdateEvent.encode(p.update, b.uint32(18).fork()).ldelim(), p.delete !== void 0 && a.CollectionDeleteEvent.encode(p.delete, b.uint32(26).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Rr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.create = a.CollectionCreateEvent.decode(T, T.uint32());
            break;
          case 2:
            U.update = a.CollectionUpdateEvent.decode(T, T.uint32());
            break;
          case 3:
            U.delete = a.CollectionDeleteEvent.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        create: ce(p.create) ? a.CollectionCreateEvent.fromJSON(p.create) : void 0,
        update: ce(p.update) ? a.CollectionUpdateEvent.fromJSON(p.update) : void 0,
        delete: ce(p.delete) ? a.CollectionDeleteEvent.fromJSON(p.delete) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.create !== void 0 && (b.create = p.create ? a.CollectionCreateEvent.toJSON(p.create) : void 0), p.update !== void 0 && (b.update = p.update ? a.CollectionUpdateEvent.toJSON(p.update) : void 0), p.delete !== void 0 && (b.delete = p.delete ? a.CollectionDeleteEvent.toJSON(p.delete) : void 0), b;
    },
    fromPartial(p) {
      const b = Rr();
      return b.create = p.create !== void 0 && p.create !== null ? a.CollectionCreateEvent.fromPartial(p.create) : void 0, b.update = p.update !== void 0 && p.update !== null ? a.CollectionUpdateEvent.fromPartial(p.update) : void 0, b.delete = p.delete !== void 0 && p.delete !== null ? a.CollectionDeleteEvent.fromPartial(p.delete) : void 0, b;
    }
  };
  function Pr() {
    return { create: void 0, update: void 0, delete: void 0, state: void 0 };
  }
  a.DestinationEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.create !== void 0 && a.DestinationCreateEvent.encode(p.create, b.uint32(10).fork()).ldelim(), p.update !== void 0 && a.DestinationUpdateEvent.encode(p.update, b.uint32(18).fork()).ldelim(), p.delete !== void 0 && a.DestinationDeleteEvent.encode(p.delete, b.uint32(26).fork()).ldelim(), p.state !== void 0 && a.DestinationStateEvent.encode(p.state, b.uint32(34).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Pr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.create = a.DestinationCreateEvent.decode(T, T.uint32());
            break;
          case 2:
            U.update = a.DestinationUpdateEvent.decode(T, T.uint32());
            break;
          case 3:
            U.delete = a.DestinationDeleteEvent.decode(T, T.uint32());
            break;
          case 4:
            U.state = a.DestinationStateEvent.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        create: ce(p.create) ? a.DestinationCreateEvent.fromJSON(p.create) : void 0,
        update: ce(p.update) ? a.DestinationUpdateEvent.fromJSON(p.update) : void 0,
        delete: ce(p.delete) ? a.DestinationDeleteEvent.fromJSON(p.delete) : void 0,
        state: ce(p.state) ? a.DestinationStateEvent.fromJSON(p.state) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.create !== void 0 && (b.create = p.create ? a.DestinationCreateEvent.toJSON(p.create) : void 0), p.update !== void 0 && (b.update = p.update ? a.DestinationUpdateEvent.toJSON(p.update) : void 0), p.delete !== void 0 && (b.delete = p.delete ? a.DestinationDeleteEvent.toJSON(p.delete) : void 0), p.state !== void 0 && (b.state = p.state ? a.DestinationStateEvent.toJSON(p.state) : void 0), b;
    },
    fromPartial(p) {
      const b = Pr();
      return b.create = p.create !== void 0 && p.create !== null ? a.DestinationCreateEvent.fromPartial(p.create) : void 0, b.update = p.update !== void 0 && p.update !== null ? a.DestinationUpdateEvent.fromPartial(p.update) : void 0, b.delete = p.delete !== void 0 && p.delete !== null ? a.DestinationDeleteEvent.fromPartial(p.delete) : void 0, b.state = p.state !== void 0 && p.state !== null ? a.DestinationStateEvent.fromPartial(p.state) : void 0, b;
    }
  };
  function Or() {
    return { create: void 0, update: void 0, delete: void 0, state: void 0 };
  }
  a.ProjectEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.create !== void 0 && a.ProjectCreateEvent.encode(p.create, b.uint32(10).fork()).ldelim(), p.update !== void 0 && a.ProjectUpdateEvent.encode(p.update, b.uint32(18).fork()).ldelim(), p.delete !== void 0 && a.ProjectDeleteEvent.encode(p.delete, b.uint32(26).fork()).ldelim(), p.state !== void 0 && a.ProjectBroadcastStateEvent.encode(p.state, b.uint32(34).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Or();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.create = a.ProjectCreateEvent.decode(T, T.uint32());
            break;
          case 2:
            U.update = a.ProjectUpdateEvent.decode(T, T.uint32());
            break;
          case 3:
            U.delete = a.ProjectDeleteEvent.decode(T, T.uint32());
            break;
          case 4:
            U.state = a.ProjectBroadcastStateEvent.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        create: ce(p.create) ? a.ProjectCreateEvent.fromJSON(p.create) : void 0,
        update: ce(p.update) ? a.ProjectUpdateEvent.fromJSON(p.update) : void 0,
        delete: ce(p.delete) ? a.ProjectDeleteEvent.fromJSON(p.delete) : void 0,
        state: ce(p.state) ? a.ProjectBroadcastStateEvent.fromJSON(p.state) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.create !== void 0 && (b.create = p.create ? a.ProjectCreateEvent.toJSON(p.create) : void 0), p.update !== void 0 && (b.update = p.update ? a.ProjectUpdateEvent.toJSON(p.update) : void 0), p.delete !== void 0 && (b.delete = p.delete ? a.ProjectDeleteEvent.toJSON(p.delete) : void 0), p.state !== void 0 && (b.state = p.state ? a.ProjectBroadcastStateEvent.toJSON(p.state) : void 0), b;
    },
    fromPartial(p) {
      const b = Or();
      return b.create = p.create !== void 0 && p.create !== null ? a.ProjectCreateEvent.fromPartial(p.create) : void 0, b.update = p.update !== void 0 && p.update !== null ? a.ProjectUpdateEvent.fromPartial(p.update) : void 0, b.delete = p.delete !== void 0 && p.delete !== null ? a.ProjectDeleteEvent.fromPartial(p.delete) : void 0, b.state = p.state !== void 0 && p.state !== null ? a.ProjectBroadcastStateEvent.fromPartial(p.state) : void 0, b;
    }
  };
  function Nr() {
    return {
      create: void 0,
      update: void 0,
      delete: void 0,
      add: void 0,
      remove: void 0,
      state: void 0
    };
  }
  a.SourceEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.create !== void 0 && a.SourceCreateEvent.encode(p.create, b.uint32(10).fork()).ldelim(), p.update !== void 0 && a.SourceUpdateEvent.encode(p.update, b.uint32(18).fork()).ldelim(), p.delete !== void 0 && a.SourceDeleteEvent.encode(p.delete, b.uint32(26).fork()).ldelim(), p.add !== void 0 && a.SourceAddEvent.encode(p.add, b.uint32(34).fork()).ldelim(), p.remove !== void 0 && a.SourceRemoveEvent.encode(p.remove, b.uint32(42).fork()).ldelim(), p.state !== void 0 && a.SourceStateEvent.encode(p.state, b.uint32(50).fork()).ldelim(), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = Nr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.create = a.SourceCreateEvent.decode(T, T.uint32());
            break;
          case 2:
            U.update = a.SourceUpdateEvent.decode(T, T.uint32());
            break;
          case 3:
            U.delete = a.SourceDeleteEvent.decode(T, T.uint32());
            break;
          case 4:
            U.add = a.SourceAddEvent.decode(T, T.uint32());
            break;
          case 5:
            U.remove = a.SourceRemoveEvent.decode(T, T.uint32());
            break;
          case 6:
            U.state = a.SourceStateEvent.decode(T, T.uint32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        create: ce(p.create) ? a.SourceCreateEvent.fromJSON(p.create) : void 0,
        update: ce(p.update) ? a.SourceUpdateEvent.fromJSON(p.update) : void 0,
        delete: ce(p.delete) ? a.SourceDeleteEvent.fromJSON(p.delete) : void 0,
        add: ce(p.add) ? a.SourceAddEvent.fromJSON(p.add) : void 0,
        remove: ce(p.remove) ? a.SourceRemoveEvent.fromJSON(p.remove) : void 0,
        state: ce(p.state) ? a.SourceStateEvent.fromJSON(p.state) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.create !== void 0 && (b.create = p.create ? a.SourceCreateEvent.toJSON(p.create) : void 0), p.update !== void 0 && (b.update = p.update ? a.SourceUpdateEvent.toJSON(p.update) : void 0), p.delete !== void 0 && (b.delete = p.delete ? a.SourceDeleteEvent.toJSON(p.delete) : void 0), p.add !== void 0 && (b.add = p.add ? a.SourceAddEvent.toJSON(p.add) : void 0), p.remove !== void 0 && (b.remove = p.remove ? a.SourceRemoveEvent.toJSON(p.remove) : void 0), p.state !== void 0 && (b.state = p.state ? a.SourceStateEvent.toJSON(p.state) : void 0), b;
    },
    fromPartial(p) {
      const b = Nr();
      return b.create = p.create !== void 0 && p.create !== null ? a.SourceCreateEvent.fromPartial(p.create) : void 0, b.update = p.update !== void 0 && p.update !== null ? a.SourceUpdateEvent.fromPartial(p.update) : void 0, b.delete = p.delete !== void 0 && p.delete !== null ? a.SourceDeleteEvent.fromPartial(p.delete) : void 0, b.add = p.add !== void 0 && p.add !== null ? a.SourceAddEvent.fromPartial(p.add) : void 0, b.remove = p.remove !== void 0 && p.remove !== null ? a.SourceRemoveEvent.fromPartial(p.remove) : void 0, b.state = p.state !== void 0 && p.state !== null ? a.SourceStateEvent.fromPartial(p.state) : void 0, b;
    }
  };
  function wr() {
    return {
      collection: void 0,
      destination: void 0,
      project: void 0,
      source: void 0,
      unspecified: void 0
    };
  }
  a.LiveEvent = {
    encode(p, b = c.default.Writer.create()) {
      return p.collection !== void 0 && a.CollectionEvent.encode(p.collection, b.uint32(10).fork()).ldelim(), p.destination !== void 0 && a.DestinationEvent.encode(p.destination, b.uint32(18).fork()).ldelim(), p.project !== void 0 && a.ProjectEvent.encode(p.project, b.uint32(26).fork()).ldelim(), p.source !== void 0 && a.SourceEvent.encode(p.source, b.uint32(34).fork()).ldelim(), p.unspecified !== void 0 && b.uint32(40).int32((0, S.nullValueToNumber)(p.unspecified)), b;
    },
    decode(p, b) {
      const T = p instanceof c.default.Reader ? p : new c.default.Reader(p);
      let K = b === void 0 ? T.len : T.pos + b;
      const U = wr();
      for (; T.pos < K; ) {
        const te = T.uint32();
        switch (te >>> 3) {
          case 1:
            U.collection = a.CollectionEvent.decode(T, T.uint32());
            break;
          case 2:
            U.destination = a.DestinationEvent.decode(T, T.uint32());
            break;
          case 3:
            U.project = a.ProjectEvent.decode(T, T.uint32());
            break;
          case 4:
            U.source = a.SourceEvent.decode(T, T.uint32());
            break;
          case 5:
            U.unspecified = (0, S.nullValueFromJSON)(T.int32());
            break;
          default:
            T.skipType(te & 7);
            break;
        }
      }
      return U;
    },
    fromJSON(p) {
      return {
        collection: ce(p.collection) ? a.CollectionEvent.fromJSON(p.collection) : void 0,
        destination: ce(p.destination) ? a.DestinationEvent.fromJSON(p.destination) : void 0,
        project: ce(p.project) ? a.ProjectEvent.fromJSON(p.project) : void 0,
        source: ce(p.source) ? a.SourceEvent.fromJSON(p.source) : void 0,
        unspecified: ce(p.unspecified) ? (0, S.nullValueFromJSON)(p.unspecified) : void 0
      };
    },
    toJSON(p) {
      const b = {};
      return p.collection !== void 0 && (b.collection = p.collection ? a.CollectionEvent.toJSON(p.collection) : void 0), p.destination !== void 0 && (b.destination = p.destination ? a.DestinationEvent.toJSON(p.destination) : void 0), p.project !== void 0 && (b.project = p.project ? a.ProjectEvent.toJSON(p.project) : void 0), p.source !== void 0 && (b.source = p.source ? a.SourceEvent.toJSON(p.source) : void 0), p.unspecified !== void 0 && (b.unspecified = p.unspecified !== void 0 ? (0, S.nullValueToJSON)(p.unspecified) : void 0), b;
    },
    fromPartial(p) {
      var b;
      const T = wr();
      return T.collection = p.collection !== void 0 && p.collection !== null ? a.CollectionEvent.fromPartial(p.collection) : void 0, T.destination = p.destination !== void 0 && p.destination !== null ? a.DestinationEvent.fromPartial(p.destination) : void 0, T.project = p.project !== void 0 && p.project !== null ? a.ProjectEvent.fromPartial(p.project) : void 0, T.source = p.source !== void 0 && p.source !== null ? a.SourceEvent.fromPartial(p.source) : void 0, T.unspecified = (b = p.unspecified) !== null && b !== void 0 ? b : void 0, T;
    }
  };
  class Dr {
    constructor(b, T) {
      this.service = (T == null ? void 0 : T.service) || "live.v21.CollectionService", this.rpc = b, this.CreateCollection = this.CreateCollection.bind(this), this.GetCollection = this.GetCollection.bind(this), this.GetCollections = this.GetCollections.bind(this), this.UpdateCollection = this.UpdateCollection.bind(this), this.DeleteCollection = this.DeleteCollection.bind(this);
    }
    CreateCollection(b) {
      const T = a.CreateCollectionRequest.encode(b).finish();
      return this.rpc.request(this.service, "CreateCollection", T).then((U) => a.CreateCollectionResponse.decode(new c.default.Reader(U)));
    }
    GetCollection(b) {
      const T = a.GetCollectionRequest.encode(b).finish();
      return this.rpc.request(this.service, "GetCollection", T).then((U) => a.GetCollectionResponse.decode(new c.default.Reader(U)));
    }
    GetCollections(b) {
      const T = a.GetCollectionsRequest.encode(b).finish();
      return this.rpc.request(this.service, "GetCollections", T).then((U) => a.GetCollectionsResponse.decode(new c.default.Reader(U)));
    }
    UpdateCollection(b) {
      const T = a.UpdateCollectionRequest.encode(b).finish();
      return this.rpc.request(this.service, "UpdateCollection", T).then((U) => a.UpdateCollectionResponse.decode(new c.default.Reader(U)));
    }
    DeleteCollection(b) {
      const T = a.DeleteCollectionRequest.encode(b).finish();
      return this.rpc.request(this.service, "DeleteCollection", T).then((U) => a.DeleteCollectionResponse.decode(new c.default.Reader(U)));
    }
  }
  a.CollectionServiceClientImpl = Dr, a.CollectionServiceDefinition = {
    name: "CollectionService",
    fullName: "live.v21.CollectionService",
    methods: {
      /**
       * Create Collection
       *
       * Create a new collection of related projects and collection live sources
       */
      createCollection: {
        name: "CreateCollection",
        requestType: a.CreateCollectionRequest,
        requestStream: !1,
        responseType: a.CreateCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Collection
       *
       * Get an existing collection of related projects and collection live
       * sources
       */
      getCollection: {
        name: "GetCollection",
        requestType: a.GetCollectionRequest,
        requestStream: !1,
        responseType: a.GetCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Collections
       *
       * Get all collections owned by the user
       */
      getCollections: {
        name: "GetCollections",
        requestType: a.GetCollectionsRequest,
        requestStream: !1,
        responseType: a.GetCollectionsResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Collection
       *
       * Update select collection document data
       */
      updateCollection: {
        name: "UpdateCollection",
        requestType: a.UpdateCollectionRequest,
        requestStream: !1,
        responseType: a.UpdateCollectionResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Collection
       *
       * Delete a collection of related projects and collection live sources
       */
      deleteCollection: {
        name: "DeleteCollection",
        requestType: a.DeleteCollectionRequest,
        requestStream: !1,
        responseType: a.DeleteCollectionResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Lr {
    constructor(b, T) {
      this.service = (T == null ? void 0 : T.service) || "live.v21.ProjectService", this.rpc = b, this.CreateProject = this.CreateProject.bind(this), this.GetProject = this.GetProject.bind(this), this.DeleteProject = this.DeleteProject.bind(this), this.UpdateProject = this.UpdateProject.bind(this), this.StartProjectBroadcast = this.StartProjectBroadcast.bind(this), this.StopProjectBroadcast = this.StopProjectBroadcast.bind(this), this.StartProjectWebRtc = this.StartProjectWebRtc.bind(this), this.StopProjectWebRtc = this.StopProjectWebRtc.bind(this), this.GetProjectBroadcastSnapshot = this.GetProjectBroadcastSnapshot.bind(this), this.GetProjectBroadcastStatus = this.GetProjectBroadcastStatus.bind(this);
    }
    CreateProject(b) {
      const T = a.CreateProjectRequest.encode(b).finish();
      return this.rpc.request(this.service, "CreateProject", T).then((U) => a.CreateProjectResponse.decode(new c.default.Reader(U)));
    }
    GetProject(b) {
      const T = a.GetProjectRequest.encode(b).finish();
      return this.rpc.request(this.service, "GetProject", T).then((U) => a.GetProjectResponse.decode(new c.default.Reader(U)));
    }
    DeleteProject(b) {
      const T = a.DeleteProjectRequest.encode(b).finish();
      return this.rpc.request(this.service, "DeleteProject", T).then((U) => a.DeleteProjectResponse.decode(new c.default.Reader(U)));
    }
    UpdateProject(b) {
      const T = a.UpdateProjectRequest.encode(b).finish();
      return this.rpc.request(this.service, "UpdateProject", T).then((U) => a.UpdateProjectResponse.decode(new c.default.Reader(U)));
    }
    StartProjectBroadcast(b) {
      const T = a.StartProjectBroadcastRequest.encode(b).finish();
      return this.rpc.request(this.service, "StartProjectBroadcast", T).then((U) => a.StartProjectBroadcastResponse.decode(new c.default.Reader(U)));
    }
    StopProjectBroadcast(b) {
      const T = a.StopProjectBroadcastRequest.encode(b).finish();
      return this.rpc.request(this.service, "StopProjectBroadcast", T).then((U) => a.StopProjectBroadcastResponse.decode(new c.default.Reader(U)));
    }
    StartProjectWebRtc(b) {
      const T = a.StartProjectWebRtcRequest.encode(b).finish();
      return this.rpc.request(this.service, "StartProjectWebRtc", T).then((U) => a.StartProjectWebRtcResponse.decode(new c.default.Reader(U)));
    }
    StopProjectWebRtc(b) {
      const T = a.StopProjectWebRtcRequest.encode(b).finish();
      return this.rpc.request(this.service, "StopProjectWebRtc", T).then((U) => a.StopProjectWebRtcResponse.decode(new c.default.Reader(U)));
    }
    GetProjectBroadcastSnapshot(b) {
      const T = a.GetProjectBroadcastSnapshotRequest.encode(b).finish();
      return this.rpc.request(this.service, "GetProjectBroadcastSnapshot", T).then((U) => a.GetProjectBroadcastSnapshotResponse.decode(new c.default.Reader(U)));
    }
    GetProjectBroadcastStatus(b) {
      const T = a.GetProjectBroadcastStatusRequest.encode(b).finish();
      return this.rpc.request(this.service, "GetProjectBroadcastStatus", T).then((U) => a.GetProjectBroadcastStatusResponse.decode(new c.default.Reader(U)));
    }
  }
  a.ProjectServiceClientImpl = Lr, a.ProjectServiceDefinition = {
    name: "ProjectService",
    fullName: "live.v21.ProjectService",
    methods: {
      /**
       * Create Project
       *
       * Create a new project
       */
      createProject: {
        name: "CreateProject",
        requestType: a.CreateProjectRequest,
        requestStream: !1,
        responseType: a.CreateProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Project
       *
       * Get an existing project
       */
      getProject: {
        name: "GetProject",
        requestType: a.GetProjectRequest,
        requestStream: !1,
        responseType: a.GetProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Project
       *
       * Delete a project
       */
      deleteProject: {
        name: "DeleteProject",
        requestType: a.DeleteProjectRequest,
        requestStream: !1,
        responseType: a.DeleteProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Project
       *
       * Updates a project
       */
      updateProject: {
        name: "UpdateProject",
        requestType: a.UpdateProjectRequest,
        requestStream: !1,
        responseType: a.UpdateProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Start Broadcast
       *
       * Start broadcasting a project
       */
      startProjectBroadcast: {
        name: "StartProjectBroadcast",
        requestType: a.StartProjectBroadcastRequest,
        requestStream: !1,
        responseType: a.StartProjectBroadcastResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Stop Broadcast
       *
       * Stop broadcasting a project
       */
      stopProjectBroadcast: {
        name: "StopProjectBroadcast",
        requestType: a.StopProjectBroadcastRequest,
        requestStream: !1,
        responseType: a.StopProjectBroadcastResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Start WebRTC
       *
       * Start WebRTC services
       */
      startProjectWebRtc: {
        name: "StartProjectWebRtc",
        requestType: a.StartProjectWebRtcRequest,
        requestStream: !1,
        responseType: a.StartProjectWebRtcResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Stop WebRTC
       *
       * Stop WebRTC services
       */
      stopProjectWebRtc: {
        name: "StopProjectWebRtc",
        requestType: a.StopProjectWebRtcRequest,
        requestStream: !1,
        responseType: a.StopProjectWebRtcResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Snapshot
       *
       * Get a snapshot of the current output frame of the broadcast
       */
      getProjectBroadcastSnapshot: {
        name: "GetProjectBroadcastSnapshot",
        requestType: a.GetProjectBroadcastSnapshotRequest,
        requestStream: !1,
        responseType: a.GetProjectBroadcastSnapshotResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Broadcast Status
       *
       * Get the broadcast status of the project
       */
      getProjectBroadcastStatus: {
        name: "GetProjectBroadcastStatus",
        requestType: a.GetProjectBroadcastStatusRequest,
        requestStream: !1,
        responseType: a.GetProjectBroadcastStatusResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Mr {
    constructor(b, T) {
      this.service = (T == null ? void 0 : T.service) || "live.v21.DestinationService", this.rpc = b, this.CreateDestination = this.CreateDestination.bind(this), this.GetDestination = this.GetDestination.bind(this), this.UpdateDestination = this.UpdateDestination.bind(this), this.DeleteDestination = this.DeleteDestination.bind(this);
    }
    CreateDestination(b) {
      const T = a.CreateDestinationRequest.encode(b).finish();
      return this.rpc.request(this.service, "CreateDestination", T).then((U) => a.CreateDestinationResponse.decode(new c.default.Reader(U)));
    }
    GetDestination(b) {
      const T = a.GetDestinationRequest.encode(b).finish();
      return this.rpc.request(this.service, "GetDestination", T).then((U) => a.GetDestinationResponse.decode(new c.default.Reader(U)));
    }
    UpdateDestination(b) {
      const T = a.UpdateDestinationRequest.encode(b).finish();
      return this.rpc.request(this.service, "UpdateDestination", T).then((U) => a.UpdateDestinationResponse.decode(new c.default.Reader(U)));
    }
    DeleteDestination(b) {
      const T = a.DeleteDestinationRequest.encode(b).finish();
      return this.rpc.request(this.service, "DeleteDestination", T).then((U) => a.DeleteDestinationResponse.decode(new c.default.Reader(U)));
    }
  }
  a.DestinationServiceClientImpl = Mr, a.DestinationServiceDefinition = {
    name: "DestinationService",
    fullName: "live.v21.DestinationService",
    methods: {
      /**
       * Create Destination
       *
       * Create a new Destination
       */
      createDestination: {
        name: "CreateDestination",
        requestType: a.CreateDestinationRequest,
        requestStream: !1,
        responseType: a.CreateDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Destination
       *
       * Get an existing Destination.
       */
      getDestination: {
        name: "GetDestination",
        requestType: a.GetDestinationRequest,
        requestStream: !1,
        responseType: a.GetDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Destination
       *
       * Update a destination
       */
      updateDestination: {
        name: "UpdateDestination",
        requestType: a.UpdateDestinationRequest,
        requestStream: !1,
        responseType: a.UpdateDestinationResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Destination
       *
       * Delete a destination
       */
      deleteDestination: {
        name: "DeleteDestination",
        requestType: a.DeleteDestinationRequest,
        requestStream: !1,
        responseType: a.DeleteDestinationResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Ur {
    constructor(b, T) {
      this.service = (T == null ? void 0 : T.service) || "live.v21.SourceService", this.rpc = b, this.CreateSource = this.CreateSource.bind(this), this.DeleteSource = this.DeleteSource.bind(this), this.UpdateSource = this.UpdateSource.bind(this), this.UpdateSourceInProject = this.UpdateSourceInProject.bind(this), this.GetSource = this.GetSource.bind(this), this.GetSources = this.GetSources.bind(this), this.AddSourceToProject = this.AddSourceToProject.bind(this), this.RemoveSourceFromProject = this.RemoveSourceFromProject.bind(this), this.GetSourcePlaylist = this.GetSourcePlaylist.bind(this);
    }
    CreateSource(b) {
      const T = a.CreateSourceRequest.encode(b).finish();
      return this.rpc.request(this.service, "CreateSource", T).then((U) => a.CreateSourceResponse.decode(new c.default.Reader(U)));
    }
    DeleteSource(b) {
      const T = a.DeleteSourceRequest.encode(b).finish();
      return this.rpc.request(this.service, "DeleteSource", T).then((U) => a.DeleteSourceResponse.decode(new c.default.Reader(U)));
    }
    UpdateSource(b) {
      const T = a.UpdateSourceRequest.encode(b).finish();
      return this.rpc.request(this.service, "UpdateSource", T).then((U) => a.UpdateSourceResponse.decode(new c.default.Reader(U)));
    }
    UpdateSourceInProject(b) {
      const T = a.UpdateSourceInProjectRequest.encode(b).finish();
      return this.rpc.request(this.service, "UpdateSourceInProject", T).then((U) => a.UpdateSourceInProjectResponse.decode(new c.default.Reader(U)));
    }
    GetSource(b) {
      const T = a.GetSourceRequest.encode(b).finish();
      return this.rpc.request(this.service, "GetSource", T).then((U) => a.GetSourceResponse.decode(new c.default.Reader(U)));
    }
    GetSources(b) {
      const T = a.GetSourcesRequest.encode(b).finish();
      return this.rpc.request(this.service, "GetSources", T).then((U) => a.GetSourcesResponse.decode(new c.default.Reader(U)));
    }
    AddSourceToProject(b) {
      const T = a.AddSourceToProjectRequest.encode(b).finish();
      return this.rpc.request(this.service, "AddSourceToProject", T).then((U) => a.AddSourceToProjectResponse.decode(new c.default.Reader(U)));
    }
    RemoveSourceFromProject(b) {
      const T = a.RemoveSourceFromProjectRequest.encode(b).finish();
      return this.rpc.request(this.service, "RemoveSourceFromProject", T).then((U) => a.RemoveSourceFromProjectResponse.decode(new c.default.Reader(U)));
    }
    GetSourcePlaylist(b) {
      const T = a.GetSourcePlaylistRequest.encode(b).finish();
      return this.rpc.request(this.service, "GetSourcePlaylist", T).then((U) => l.HttpBody.decode(new c.default.Reader(U)));
    }
  }
  a.SourceServiceClientImpl = Ur, a.SourceServiceDefinition = {
    name: "SourceService",
    fullName: "live.v21.SourceService",
    methods: {
      /**
       * Create Collection Live Source
       *
       * Create a new live source in a collection
       * ### Permissions
       * * scope: `SCOPE_VAPI_CREATE`
       */
      createSource: {
        name: "CreateSource",
        requestType: a.CreateSourceRequest,
        requestStream: !1,
        responseType: a.CreateSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Live Source
       *
       * Deletes a live source from a collection
       */
      deleteSource: {
        name: "DeleteSource",
        requestType: a.DeleteSourceRequest,
        requestStream: !1,
        responseType: a.DeleteSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Source
       *
       * Update attributes of the Source.
       */
      updateSource: {
        name: "UpdateSource",
        requestType: a.UpdateSourceRequest,
        requestStream: !1,
        responseType: a.UpdateSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Update Source
       *
       * Update attributes of the Source.
       */
      updateSourceInProject: {
        name: "UpdateSourceInProject",
        requestType: a.UpdateSourceInProjectRequest,
        requestStream: !1,
        responseType: a.UpdateSourceInProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Source
       *
       * Get an existing source in a project
       */
      getSource: {
        name: "GetSource",
        requestType: a.GetSourceRequest,
        requestStream: !1,
        responseType: a.GetSourceResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get Source
       *
       * Get existing sources in a collection
       */
      getSources: {
        name: "GetSources",
        requestType: a.GetSourcesRequest,
        requestStream: !1,
        responseType: a.GetSourcesResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Add Source to Project
       *
       * Add a source to a project
       */
      addSourceToProject: {
        name: "AddSourceToProject",
        requestType: a.AddSourceToProjectRequest,
        requestStream: !1,
        responseType: a.AddSourceToProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Delete Source From Project
       *
       * Removes a source from a project.
       */
      removeSourceFromProject: {
        name: "RemoveSourceFromProject",
        requestType: a.RemoveSourceFromProjectRequest,
        requestStream: !1,
        responseType: a.RemoveSourceFromProjectResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Get the HLS playlist for a source.
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      getSourcePlaylist: {
        name: "GetSourcePlaylist",
        requestType: a.GetSourcePlaylistRequest,
        requestStream: !1,
        responseType: l.HttpBody,
        responseStream: !1,
        options: {}
      }
    }
  };
  class $r {
    constructor(b, T) {
      this.service = (T == null ? void 0 : T.service) || "live.v21.BackendAuthenticationService", this.rpc = b, this.CreateAccessToken = this.CreateAccessToken.bind(this);
    }
    CreateAccessToken(b) {
      const T = a.CreateAccessTokenRequest.encode(b).finish();
      return this.rpc.request(this.service, "CreateAccessToken", T).then((U) => a.CreateAccessTokenResponse.decode(new c.default.Reader(U)));
    }
  }
  a.BackendAuthenticationServiceClientImpl = $r, a.BackendAuthenticationServiceDefinition = {
    name: "BackendAuthenticationService",
    fullName: "live.v21.BackendAuthenticationService",
    methods: {
      /**
       * Create Access Token
       *
       * Create an access token for a session host
       */
      createAccessToken: {
        name: "CreateAccessToken",
        requestType: a.CreateAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateAccessTokenResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Br {
    constructor(b, T) {
      this.service = (T == null ? void 0 : T.service) || "live.v21.AuthenticationService", this.rpc = b, this.CreateGuestAccessToken = this.CreateGuestAccessToken.bind(this), this.RefreshAccessToken = this.RefreshAccessToken.bind(this), this.CreateWebRtcAccessToken = this.CreateWebRtcAccessToken.bind(this);
    }
    CreateGuestAccessToken(b) {
      const T = a.CreateGuestAccessTokenRequest.encode(b).finish();
      return this.rpc.request(this.service, "CreateGuestAccessToken", T).then((U) => a.CreateGuestAccessTokenResponse.decode(new c.default.Reader(U)));
    }
    RefreshAccessToken(b) {
      const T = a.RefreshAccessTokenRequest.encode(b).finish();
      return this.rpc.request(this.service, "RefreshAccessToken", T).then((U) => a.RefreshAccessTokenResponse.decode(new c.default.Reader(U)));
    }
    CreateWebRtcAccessToken(b) {
      const T = a.CreateWebRtcAccessTokenRequest.encode(b).finish();
      return this.rpc.request(this.service, "CreateWebRtcAccessToken", T).then((U) => a.CreateWebRtcAccessTokenResponse.decode(new c.default.Reader(U)));
    }
  }
  a.AuthenticationServiceClientImpl = Br, a.AuthenticationServiceDefinition = {
    name: "AuthenticationService",
    fullName: "live.v21.AuthenticationService",
    methods: {
      /**
       * Create Guest Access Token
       *
       * Create an access token for a guest
       */
      createGuestAccessToken: {
        name: "CreateGuestAccessToken",
        requestType: a.CreateGuestAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateGuestAccessTokenResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Refresh Access Token
       *
       * Forcibly refresh an access token prior to expiration
       */
      refreshAccessToken: {
        name: "RefreshAccessToken",
        requestType: a.RefreshAccessTokenRequest,
        requestStream: !1,
        responseType: a.RefreshAccessTokenResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Create WebRTC Access Token
       *
       * Create a WebRTC Access Token
       */
      createWebRtcAccessToken: {
        name: "CreateWebRtcAccessToken",
        requestType: a.CreateWebRtcAccessTokenRequest,
        requestStream: !1,
        responseType: a.CreateWebRtcAccessTokenResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  class Jr {
    constructor(b, T) {
      this.service = (T == null ? void 0 : T.service) || "live.v21.PublicAuthenticationService", this.rpc = b, this.GetJsonWebKeySet = this.GetJsonWebKeySet.bind(this), this.GuestCodeRedirect = this.GuestCodeRedirect.bind(this);
    }
    GetJsonWebKeySet(b) {
      const T = a.GetJsonWebKeySetRequest.encode(b).finish();
      return this.rpc.request(this.service, "GetJsonWebKeySet", T).then((U) => a.GetJsonWebKeySetResponse.decode(new c.default.Reader(U)));
    }
    GuestCodeRedirect(b) {
      const T = a.GuestCodeRedirectRequest.encode(b).finish();
      return this.rpc.request(this.service, "GuestCodeRedirect", T).then((U) => a.GuestCodeRedirectResponse.decode(new c.default.Reader(U)));
    }
  }
  a.PublicAuthenticationServiceClientImpl = Jr, a.PublicAuthenticationServiceDefinition = {
    name: "PublicAuthenticationService",
    fullName: "live.v21.PublicAuthenticationService",
    methods: {
      /**
       * Get Public Keys
       *
       * Get public keys used to sign access tokens
       */
      getJsonWebKeySet: {
        name: "GetJsonWebKeySet",
        requestType: a.GetJsonWebKeySetRequest,
        requestStream: !1,
        responseType: a.GetJsonWebKeySetResponse,
        responseStream: !1,
        options: {}
      },
      /**
       * Exchange Guest Access Token
       *
       * Exchange a guest access token with updated user identifiers
       */
      guestCodeRedirect: {
        name: "GuestCodeRedirect",
        requestType: a.GuestCodeRedirectRequest,
        requestStream: !1,
        responseType: a.GuestCodeRedirectResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var Ke = (() => {
    if (typeof Ke < "u")
      return Ke;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function Fr(p) {
    if (Ke.Buffer)
      return Uint8Array.from(Ke.Buffer.from(p, "base64"));
    {
      const b = Ke.atob(p), T = new Uint8Array(b.length);
      for (let K = 0; K < b.length; ++K)
        T[K] = b.charCodeAt(K);
      return T;
    }
  }
  function Vr(p) {
    if (Ke.Buffer)
      return Ke.Buffer.from(p).toString("base64");
    {
      const b = [];
      return p.forEach((T) => {
        b.push(String.fromCharCode(T));
      }), Ke.btoa(b.join(""));
    }
  }
  function Ut(p) {
    const b = new Date(p), T = b.getTime() / 1e3, K = b.getTime() % 1e3 * 1e6;
    return { seconds: T, nanos: K };
  }
  function $t(p) {
    let b = p.seconds * 1e3;
    return b += p.nanos / 1e6, new Date(b).toISOString();
  }
  function ce(p) {
    return p != null;
  }
})(api$1);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function($, J, V, q) {
    q === void 0 && (q = V);
    var G = Object.getOwnPropertyDescriptor(J, V);
    (!G || ("get" in G ? !J.__esModule : G.writable || G.configurable)) && (G = { enumerable: !0, get: function() {
      return J[V];
    } }), Object.defineProperty($, q, G);
  } : function($, J, V, q) {
    q === void 0 && (q = V), $[q] = J[V];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function($, J) {
    Object.defineProperty($, "default", { enumerable: !0, value: J });
  } : function($, J) {
    $.default = J;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function($, J, V, q) {
    var G = arguments.length, H = G < 3 ? J : q === null ? q = Object.getOwnPropertyDescriptor(J, V) : q, B;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
      H = Reflect.decorate($, J, V, q);
    else
      for (var Y = $.length - 1; Y >= 0; Y--)
        (B = $[Y]) && (H = (G < 3 ? B(H) : G > 3 ? B(J, V, H) : B(J, V)) || H);
    return G > 3 && H && Object.defineProperty(J, V, H), H;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function($) {
    if ($ && $.__esModule)
      return $;
    var J = {};
    if ($ != null)
      for (var V in $)
        V !== "default" && Object.prototype.hasOwnProperty.call($, V) && u(J, $, V);
    return c(J, $), J;
  }, S = commonjsGlobal$1 && commonjsGlobal$1.__metadata || function($, J) {
    if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
      return Reflect.metadata($, J);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LiveApi = void 0;
  const g = v(lib$1), E = api$2, _ = v(api$1), k = decorator, L = "LiveApi";
  class M extends E.ApiClient {
    constructor(J, V, q, G, H, B, Y) {
      super(J, q, B, L, Y), this.handlers = {}, this.eventApi = V, this.accessTokenRefreshCallback = G, this.publicAuthentication = this.clientFactory.create(_.PublicAuthenticationServiceDefinition, this.channel), H != null && (this.backendAuthentication = this.clientFactory.create(_.BackendAuthenticationServiceDefinition, this.channel, {
        "*": { metadata: g.Metadata({ "X-Api-Key": H }) }
      })), this.eventApi.on("event", { name: `${M.LIVEAPI_EVENT_PREFIX}:*`, ignoreSessionEvents: !0, allowedSessionEvents: [`${M.LIVEAPI_EVENT_PREFIX}:EVENT_TYPE_PROJECT:EVENT_SUB_TYPE_STATE`] }, this.eventCallback.bind(this));
    }
    /**
    * Register an event handler
    *
    * @param type Type of event
    * @param handler
    */
    on(J, V) {
      var q;
      this.handlers[J] = (q = this.handlers[J]) !== null && q !== void 0 ? q : [], this.handlers[J].push(V);
    }
    /**
     * Unregister an event handler
     *
     * @param type Type of event
     * @param handler
     */
    off(J, V) {
      this.handlers[J] = this.handlers[J].filter((q) => q !== V);
    }
    emitToHandlers(J, V, q) {
      var G;
      for (const H of (G = this.handlers[J]) !== null && G !== void 0 ? G : [])
        H(Object.values(q).find((B) => !!B), V);
    }
    async subscribeToCollection(J) {
      await this.eventApi.subscribe(`${M.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: J } });
    }
    async unsubscribeFromCollection(J) {
      await this.eventApi.unsubscribe(`${M.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: J } });
    }
    async subscribeToProject(J, V) {
      await this.eventApi.subscribe(`${M.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: J, projectId: V } });
    }
    async unsubscribeFromProject(J, V) {
      await this.eventApi.unsubscribe(`${M.LIVEAPI_EVENT_PREFIX}:*`, { target: { collectionId: J, projectId: V } });
    }
    eventCallback(J) {
      let q = J.name.split(`${M.LIVEAPI_EVENT_PREFIX}:`)[1].split(":"), G = _.eventTypeFromJSON(q[0]), H = _.eventSubTypeFromJSON(q[1]);
      this.log.info("processing event: " + G + "/" + H), M.liveApiEventMap[G] && this.emitToHandlers(G, H, J.payload);
    }
    _setup(J) {
      let V = this;
      J.onHeader = function(q) {
        let G = q.get("Authorization");
        if (G != null) {
          const H = G.split(" ");
          if (H.length == 2 && H[0] == "Bearer") {
            let B = H[1];
            V.log.info("received refresh token"), V.accessTokenRefreshCallback(B);
          }
        }
      }, this.collection = this.clientFactory.create(_.CollectionServiceDefinition, this.channel, {
        "*": J
      }), this.project = this.clientFactory.create(_.ProjectServiceDefinition, this.channel, {
        "*": J
      }), this.source = this.clientFactory.create(_.SourceServiceDefinition, this.channel, {
        "*": J
      }), this.destination = this.clientFactory.create(_.DestinationServiceDefinition, this.channel, {
        "*": J
      }), this.authentication = this.clientFactory.create(_.AuthenticationServiceDefinition, this.channel, {
        "*": J
      });
    }
  }
  M.LIVEAPI_EVENT_PREFIX = "apistream:live", l([
    (0, k.RequiresSdkAuthentication)(),
    S("design:type", Object)
  ], M.prototype, "collection", void 0), l([
    (0, k.RequiresSdkAuthentication)(),
    S("design:type", Object)
  ], M.prototype, "project", void 0), l([
    (0, k.RequiresSdkAuthentication)(),
    S("design:type", Object)
  ], M.prototype, "source", void 0), l([
    (0, k.RequiresSdkAuthentication)(),
    S("design:type", Object)
  ], M.prototype, "destination", void 0), l([
    (0, k.RequiresSdkAuthentication)(),
    S("design:type", Object)
  ], M.prototype, "authentication", void 0), a.LiveApi = M, function($) {
    $.liveApiEventMap = {
      [_.EventType.EVENT_TYPE_COLLECTION]: "collection",
      [_.EventType.EVENT_TYPE_PROJECT]: "project",
      [_.EventType.EVENT_TYPE_SOURCE]: "source",
      [_.EventType.EVENT_TYPE_DESTINATION]: "destination",
      [_.EventType.EVENT_TYPE_UNSPECIFIED]: "unspecified"
    };
  }(M = a.LiveApi || (a.LiveApi = {}));
})(liveapi);
var eventapi = {}, dist$1 = {}, api = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(a, u) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, l) {
    c.__proto__ = l;
  } || function(c, l) {
    for (var v in l)
      l.hasOwnProperty(v) && (c[v] = l[v]);
  }, extendStatics(a, u);
};
function __extends(a, u) {
  extendStatics(a, u);
  function c() {
    this.constructor = a;
  }
  a.prototype = u === null ? Object.create(u) : (c.prototype = u.prototype, new c());
}
function isFunction$2(a) {
  return typeof a == "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = !1, config$2 = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(a) {
    if (a) {
      var u = /* @__PURE__ */ new Error();
      "" + u.stack;
    }
    _enable_super_gross_mode_that_will_cause_bad_things = a;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError(a) {
  setTimeout(function() {
    throw a;
  }, 0);
}
var empty$2 = {
  closed: !0,
  next: function(a) {
  },
  error: function(a) {
    if (config$2.useDeprecatedSynchronousErrorHandling)
      throw a;
    hostReportError(a);
  },
  complete: function() {
  }
}, isArray$4 = /* @__PURE__ */ function() {
  return Array.isArray || function(a) {
    return a && typeof a.length == "number";
  };
}();
function isObject$8(a) {
  return a !== null && typeof a == "object";
}
var UnsubscriptionErrorImpl = /* @__PURE__ */ function() {
  function a(u) {
    return Error.call(this), this.message = u ? u.length + ` errors occurred during unsubscription:
` + u.map(function(c, l) {
      return l + 1 + ") " + c.toString();
    }).join(`
  `) : "", this.name = "UnsubscriptionError", this.errors = u, this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), UnsubscriptionError = UnsubscriptionErrorImpl, Subscription = /* @__PURE__ */ function() {
  function a(u) {
    this.closed = !1, this._parentOrParents = null, this._subscriptions = null, u && (this._ctorUnsubscribe = !0, this._unsubscribe = u);
  }
  return a.prototype.unsubscribe = function() {
    var u;
    if (!this.closed) {
      var c = this, l = c._parentOrParents, v = c._ctorUnsubscribe, S = c._unsubscribe, g = c._subscriptions;
      if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, l instanceof a)
        l.remove(this);
      else if (l !== null)
        for (var E = 0; E < l.length; ++E) {
          var _ = l[E];
          _.remove(this);
        }
      if (isFunction$2(S)) {
        v && (this._unsubscribe = void 0);
        try {
          S.call(this);
        } catch (M) {
          u = M instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(M.errors) : [M];
        }
      }
      if (isArray$4(g))
        for (var E = -1, k = g.length; ++E < k; ) {
          var L = g[E];
          if (isObject$8(L))
            try {
              L.unsubscribe();
            } catch ($) {
              u = u || [], $ instanceof UnsubscriptionError ? u = u.concat(flattenUnsubscriptionErrors($.errors)) : u.push($);
            }
        }
      if (u)
        throw new UnsubscriptionError(u);
    }
  }, a.prototype.add = function(u) {
    var c = u;
    if (!u)
      return a.EMPTY;
    switch (typeof u) {
      case "function":
        c = new a(u);
      case "object":
        if (c === this || c.closed || typeof c.unsubscribe != "function")
          return c;
        if (this.closed)
          return c.unsubscribe(), c;
        if (!(c instanceof a)) {
          var l = c;
          c = new a(), c._subscriptions = [l];
        }
        break;
      default:
        throw new Error("unrecognized teardown " + u + " added to Subscription.");
    }
    var v = c._parentOrParents;
    if (v === null)
      c._parentOrParents = this;
    else if (v instanceof a) {
      if (v === this)
        return c;
      c._parentOrParents = [v, this];
    } else if (v.indexOf(this) === -1)
      v.push(this);
    else
      return c;
    var S = this._subscriptions;
    return S === null ? this._subscriptions = [c] : S.push(c), c;
  }, a.prototype.remove = function(u) {
    var c = this._subscriptions;
    if (c) {
      var l = c.indexOf(u);
      l !== -1 && c.splice(l, 1);
    }
  }, a.EMPTY = function(u) {
    return u.closed = !0, u;
  }(new a()), a;
}();
function flattenUnsubscriptionErrors(a) {
  return a.reduce(function(u, c) {
    return u.concat(c instanceof UnsubscriptionError ? c.errors : c);
  }, []);
}
var rxSubscriber = /* @__PURE__ */ function() {
  return typeof Symbol == "function" ? /* @__PURE__ */ Symbol("rxSubscriber") : "@@rxSubscriber_" + /* @__PURE__ */ Math.random();
}(), Subscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this) || this;
    switch (S.syncErrorValue = null, S.syncErrorThrown = !1, S.syncErrorThrowable = !1, S.isStopped = !1, arguments.length) {
      case 0:
        S.destination = empty$2;
        break;
      case 1:
        if (!c) {
          S.destination = empty$2;
          break;
        }
        if (typeof c == "object") {
          c instanceof u ? (S.syncErrorThrowable = c.syncErrorThrowable, S.destination = c, c.add(S)) : (S.syncErrorThrowable = !0, S.destination = new SafeSubscriber(S, c));
          break;
        }
      default:
        S.syncErrorThrowable = !0, S.destination = new SafeSubscriber(S, c, l, v);
        break;
    }
    return S;
  }
  return u.prototype[rxSubscriber] = function() {
    return this;
  }, u.create = function(c, l, v) {
    var S = new u(c, l, v);
    return S.syncErrorThrowable = !1, S;
  }, u.prototype.next = function(c) {
    this.isStopped || this._next(c);
  }, u.prototype.error = function(c) {
    this.isStopped || (this.isStopped = !0, this._error(c));
  }, u.prototype.complete = function() {
    this.isStopped || (this.isStopped = !0, this._complete());
  }, u.prototype.unsubscribe = function() {
    this.closed || (this.isStopped = !0, a.prototype.unsubscribe.call(this));
  }, u.prototype._next = function(c) {
    this.destination.next(c);
  }, u.prototype._error = function(c) {
    this.destination.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.destination.complete(), this.unsubscribe();
  }, u.prototype._unsubscribeAndRecycle = function() {
    var c = this._parentOrParents;
    return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = c, this;
  }, u;
}(Subscription), SafeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, S) {
    var g = a.call(this) || this;
    g._parentSubscriber = c;
    var E, _ = g;
    return isFunction$2(l) ? E = l : l && (E = l.next, v = l.error, S = l.complete, l !== empty$2 && (_ = Object.create(l), isFunction$2(_.unsubscribe) && g.add(_.unsubscribe.bind(_)), _.unsubscribe = g.unsubscribe.bind(g))), g._context = _, g._next = E, g._error = v, g._complete = S, g;
  }
  return u.prototype.next = function(c) {
    if (!this.isStopped && this._next) {
      var l = this._parentSubscriber;
      !config$2.useDeprecatedSynchronousErrorHandling || !l.syncErrorThrowable ? this.__tryOrUnsub(this._next, c) : this.__tryOrSetError(l, this._next, c) && this.unsubscribe();
    }
  }, u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this._parentSubscriber, v = config$2.useDeprecatedSynchronousErrorHandling;
      if (this._error)
        !v || !l.syncErrorThrowable ? (this.__tryOrUnsub(this._error, c), this.unsubscribe()) : (this.__tryOrSetError(l, this._error, c), this.unsubscribe());
      else if (l.syncErrorThrowable)
        v ? (l.syncErrorValue = c, l.syncErrorThrown = !0) : hostReportError(c), this.unsubscribe();
      else {
        if (this.unsubscribe(), v)
          throw c;
        hostReportError(c);
      }
    }
  }, u.prototype.complete = function() {
    var c = this;
    if (!this.isStopped) {
      var l = this._parentSubscriber;
      if (this._complete) {
        var v = function() {
          return c._complete.call(c._context);
        };
        !config$2.useDeprecatedSynchronousErrorHandling || !l.syncErrorThrowable ? (this.__tryOrUnsub(v), this.unsubscribe()) : (this.__tryOrSetError(l, v), this.unsubscribe());
      } else
        this.unsubscribe();
    }
  }, u.prototype.__tryOrUnsub = function(c, l) {
    try {
      c.call(this._context, l);
    } catch (v) {
      if (this.unsubscribe(), config$2.useDeprecatedSynchronousErrorHandling)
        throw v;
      hostReportError(v);
    }
  }, u.prototype.__tryOrSetError = function(c, l, v) {
    if (!config$2.useDeprecatedSynchronousErrorHandling)
      throw new Error("bad call");
    try {
      l.call(this._context, v);
    } catch (S) {
      return config$2.useDeprecatedSynchronousErrorHandling ? (c.syncErrorValue = S, c.syncErrorThrown = !0, !0) : (hostReportError(S), !0);
    }
    return !1;
  }, u.prototype._unsubscribe = function() {
    var c = this._parentSubscriber;
    this._context = null, this._parentSubscriber = null, c.unsubscribe();
  }, u;
}(Subscriber);
function canReportError(a) {
  for (; a; ) {
    var u = a, c = u.closed, l = u.destination, v = u.isStopped;
    if (c || v)
      return !1;
    l && l instanceof Subscriber ? a = l : a = null;
  }
  return !0;
}
function toSubscriber(a, u, c) {
  if (a) {
    if (a instanceof Subscriber)
      return a;
    if (a[rxSubscriber])
      return a[rxSubscriber]();
  }
  return !a && !u && !c ? new Subscriber(empty$2) : new Subscriber(a, u, c);
}
var observable = /* @__PURE__ */ function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}();
function identity(a) {
  return a;
}
function pipe() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return pipeFromArray(a);
}
function pipeFromArray(a) {
  return a.length === 0 ? identity : a.length === 1 ? a[0] : function(c) {
    return a.reduce(function(l, v) {
      return v(l);
    }, c);
  };
}
var Observable = /* @__PURE__ */ function() {
  function a(u) {
    this._isScalar = !1, u && (this._subscribe = u);
  }
  return a.prototype.lift = function(u) {
    var c = new a();
    return c.source = this, c.operator = u, c;
  }, a.prototype.subscribe = function(u, c, l) {
    var v = this.operator, S = toSubscriber(u, c, l);
    if (v ? S.add(v.call(S, this.source)) : S.add(this.source || config$2.useDeprecatedSynchronousErrorHandling && !S.syncErrorThrowable ? this._subscribe(S) : this._trySubscribe(S)), config$2.useDeprecatedSynchronousErrorHandling && S.syncErrorThrowable && (S.syncErrorThrowable = !1, S.syncErrorThrown))
      throw S.syncErrorValue;
    return S;
  }, a.prototype._trySubscribe = function(u) {
    try {
      return this._subscribe(u);
    } catch (c) {
      config$2.useDeprecatedSynchronousErrorHandling && (u.syncErrorThrown = !0, u.syncErrorValue = c), canReportError(u) ? u.error(c) : console.warn(c);
    }
  }, a.prototype.forEach = function(u, c) {
    var l = this;
    return c = getPromiseCtor(c), new c(function(v, S) {
      var g;
      g = l.subscribe(function(E) {
        try {
          u(E);
        } catch (_) {
          S(_), g && g.unsubscribe();
        }
      }, S, v);
    });
  }, a.prototype._subscribe = function(u) {
    var c = this.source;
    return c && c.subscribe(u);
  }, a.prototype[observable] = function() {
    return this;
  }, a.prototype.pipe = function() {
    for (var u = [], c = 0; c < arguments.length; c++)
      u[c] = arguments[c];
    return u.length === 0 ? this : pipeFromArray(u)(this);
  }, a.prototype.toPromise = function(u) {
    var c = this;
    return u = getPromiseCtor(u), new u(function(l, v) {
      var S;
      c.subscribe(function(g) {
        return S = g;
      }, function(g) {
        return v(g);
      }, function() {
        return l(S);
      });
    });
  }, a.create = function(u) {
    return new a(u);
  }, a;
}();
function getPromiseCtor(a) {
  if (a || (a = Promise), !a)
    throw new Error("no Promise impl found");
  return a;
}
var subscribeToArray = function(a) {
  return function(u) {
    for (var c = 0, l = a.length; c < l && !u.closed; c++)
      u.next(a[c]);
    u.complete();
  };
}, subscribeToPromise = function(a) {
  return function(u) {
    return a.then(function(c) {
      u.closed || (u.next(c), u.complete());
    }, function(c) {
      return u.error(c);
    }).then(null, hostReportError), u;
  };
};
function getSymbolIterator() {
  return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
}
var iterator = /* @__PURE__ */ getSymbolIterator(), subscribeToIterable = function(a) {
  return function(u) {
    var c = a[iterator]();
    do {
      var l = void 0;
      try {
        l = c.next();
      } catch (v) {
        return u.error(v), u;
      }
      if (l.done) {
        u.complete();
        break;
      }
      if (u.next(l.value), u.closed)
        break;
    } while (!0);
    return typeof c.return == "function" && u.add(function() {
      c.return && c.return();
    }), u;
  };
}, subscribeToObservable = function(a) {
  return function(u) {
    var c = a[observable]();
    if (typeof c.subscribe != "function")
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    return c.subscribe(u);
  };
}, isArrayLike$1 = function(a) {
  return a && typeof a.length == "number" && typeof a != "function";
};
function isPromise(a) {
  return !!a && typeof a.subscribe != "function" && typeof a.then == "function";
}
var subscribeTo = function(a) {
  if (a && typeof a[observable] == "function")
    return subscribeToObservable(a);
  if (isArrayLike$1(a))
    return subscribeToArray(a);
  if (isPromise(a))
    return subscribeToPromise(a);
  if (a && typeof a[iterator] == "function")
    return subscribeToIterable(a);
  var u = isObject$8(a) ? "an invalid object" : "'" + a + "'", c = "You provided " + u + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
  throw new TypeError(c);
}, SimpleInnerSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l.parent = c, l;
  }
  return u.prototype._next = function(c) {
    this.parent.notifyNext(c);
  }, u.prototype._error = function(c) {
    this.parent.notifyError(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.notifyComplete(), this.unsubscribe();
  }, u;
}(Subscriber), SimpleOuterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyError = function(c) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function() {
    this.destination.complete();
  }, u;
}(Subscriber);
function innerSubscribe(a, u) {
  if (!u.closed) {
    if (a instanceof Observable)
      return a.subscribe(u);
    var c;
    try {
      c = subscribeTo(a)(u);
    } catch (l) {
      u.error(l);
    }
    return c;
  }
}
function audit(a) {
  return function(c) {
    return c.lift(new AuditOperator(a));
  };
}
var AuditOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.durationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new AuditSubscriber(u, this.durationSelector));
  }, a;
}(), AuditSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.durationSelector = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    if (this.value = c, this.hasValue = !0, !this.throttled) {
      var l = void 0;
      try {
        var v = this.durationSelector;
        l = v(c);
      } catch (g) {
        return this.destination.error(g);
      }
      var S = innerSubscribe(l, new SimpleInnerSubscriber(this));
      !S || S.closed ? this.clearThrottle() : this.add(this.throttled = S);
    }
  }, u.prototype.clearThrottle = function() {
    var c = this, l = c.value, v = c.hasValue, S = c.throttled;
    S && (this.remove(S), this.throttled = void 0, S.unsubscribe()), v && (this.value = void 0, this.hasValue = !1, this.destination.next(l));
  }, u.prototype.notifyNext = function() {
    this.clearThrottle();
  }, u.prototype.notifyComplete = function() {
    this.clearThrottle();
  }, u;
}(SimpleOuterSubscriber), Action = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    return a.call(this) || this;
  }
  return u.prototype.schedule = function(c, l) {
    return this;
  }, u;
}(Subscription), AsyncAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v.pending = !1, v;
  }
  return u.prototype.schedule = function(c, l) {
    if (l === void 0 && (l = 0), this.closed)
      return this;
    this.state = c;
    var v = this.id, S = this.scheduler;
    return v != null && (this.id = this.recycleAsyncId(S, v, l)), this.pending = !0, this.delay = l, this.id = this.id || this.requestAsyncId(S, this.id, l), this;
  }, u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), setInterval(c.flush.bind(c, this), v);
  }, u.prototype.recycleAsyncId = function(c, l, v) {
    if (v === void 0 && (v = 0), v !== null && this.delay === v && this.pending === !1)
      return l;
    clearInterval(l);
  }, u.prototype.execute = function(c, l) {
    if (this.closed)
      return new Error("executing a cancelled action");
    this.pending = !1;
    var v = this._execute(c, l);
    if (v)
      return v;
    this.pending === !1 && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
  }, u.prototype._execute = function(c, l) {
    var v = !1, S = void 0;
    try {
      this.work(c);
    } catch (g) {
      v = !0, S = !!g && g || new Error(g);
    }
    if (v)
      return this.unsubscribe(), S;
  }, u.prototype._unsubscribe = function() {
    var c = this.id, l = this.scheduler, v = l.actions, S = v.indexOf(this);
    this.work = null, this.state = null, this.pending = !1, this.scheduler = null, S !== -1 && v.splice(S, 1), c != null && (this.id = this.recycleAsyncId(l, c, null)), this.delay = null;
  }, u;
}(Action), Scheduler = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = a.now), this.SchedulerAction = u, this.now = c;
  }
  return a.prototype.schedule = function(u, c, l) {
    return c === void 0 && (c = 0), new this.SchedulerAction(this, u).schedule(l, c);
  }, a.now = function() {
    return Date.now();
  }, a;
}(), AsyncScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    l === void 0 && (l = Scheduler.now);
    var v = a.call(this, c, function() {
      return u.delegate && u.delegate !== v ? u.delegate.now() : l();
    }) || this;
    return v.actions = [], v.active = !1, v.scheduled = void 0, v;
  }
  return u.prototype.schedule = function(c, l, v) {
    return l === void 0 && (l = 0), u.delegate && u.delegate !== this ? u.delegate.schedule(c, l, v) : a.prototype.schedule.call(this, c, l, v);
  }, u.prototype.flush = function(c) {
    var l = this.actions;
    if (this.active) {
      l.push(c);
      return;
    }
    var v;
    this.active = !0;
    do
      if (v = c.execute(c.state, c.delay))
        break;
    while (c = l.shift());
    if (this.active = !1, v) {
      for (; c = l.shift(); )
        c.unsubscribe();
      throw v;
    }
  }, u;
}(Scheduler), asyncScheduler = /* @__PURE__ */ new AsyncScheduler(AsyncAction), async = asyncScheduler;
function isNumeric(a) {
  return !isArray$4(a) && a - parseFloat(a) + 1 >= 0;
}
function isScheduler(a) {
  return a && typeof a.schedule == "function";
}
function timer(a, u, c) {
  a === void 0 && (a = 0);
  var l = -1;
  return isNumeric(u) ? l = Number(u) < 1 && 1 || Number(u) : isScheduler(u) && (c = u), isScheduler(c) || (c = async), new Observable(function(v) {
    var S = isNumeric(a) ? a : +a - c.now();
    return c.schedule(dispatch$1, S, {
      index: 0,
      period: l,
      subscriber: v
    });
  });
}
function dispatch$1(a) {
  var u = a.index, c = a.period, l = a.subscriber;
  if (l.next(u), !l.closed) {
    if (c === -1)
      return l.complete();
    a.index = u + 1, this.schedule(a, c);
  }
}
function auditTime(a, u) {
  return u === void 0 && (u = async), audit(function() {
    return timer(a, u);
  });
}
function buffer(a) {
  return function(c) {
    return c.lift(new BufferOperator(a));
  };
}
var BufferOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingNotifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferSubscriber(u, this.closingNotifier));
  }, a;
}(), BufferSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.buffer = [], v.add(innerSubscribe(l, new SimpleInnerSubscriber(v))), v;
  }
  return u.prototype._next = function(c) {
    this.buffer.push(c);
  }, u.prototype.notifyNext = function() {
    var c = this.buffer;
    this.buffer = [], this.destination.next(c);
  }, u;
}(SimpleOuterSubscriber);
function bufferCount(a, u) {
  return u === void 0 && (u = null), function(l) {
    return l.lift(new BufferCountOperator(a, u));
  };
}
var BufferCountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.bufferSize = u, this.startBufferEvery = c, !c || u === c ? this.subscriberClass = BufferCountSubscriber : this.subscriberClass = BufferSkipCountSubscriber;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new this.subscriberClass(u, this.bufferSize, this.startBufferEvery));
  }, a;
}(), BufferCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.bufferSize = l, v.buffer = [], v;
  }
  return u.prototype._next = function(c) {
    var l = this.buffer;
    l.push(c), l.length == this.bufferSize && (this.destination.next(l), this.buffer = []);
  }, u.prototype._complete = function() {
    var c = this.buffer;
    c.length > 0 && this.destination.next(c), a.prototype._complete.call(this);
  }, u;
}(Subscriber), BufferSkipCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.bufferSize = l, S.startBufferEvery = v, S.buffers = [], S.count = 0, S;
  }
  return u.prototype._next = function(c) {
    var l = this, v = l.bufferSize, S = l.startBufferEvery, g = l.buffers, E = l.count;
    this.count++, E % S === 0 && g.push([]);
    for (var _ = g.length; _--; ) {
      var k = g[_];
      k.push(c), k.length === v && (g.splice(_, 1), this.destination.next(k));
    }
  }, u.prototype._complete = function() {
    for (var c = this, l = c.buffers, v = c.destination; l.length > 0; ) {
      var S = l.shift();
      S.length > 0 && v.next(S);
    }
    a.prototype._complete.call(this);
  }, u;
}(Subscriber);
function bufferTime(a) {
  var u = arguments.length, c = async;
  isScheduler(arguments[arguments.length - 1]) && (c = arguments[arguments.length - 1], u--);
  var l = null;
  u >= 2 && (l = arguments[1]);
  var v = Number.POSITIVE_INFINITY;
  return u >= 3 && (v = arguments[2]), function(g) {
    return g.lift(new BufferTimeOperator(a, l, v, c));
  };
}
var BufferTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.bufferTimeSpan = u, this.bufferCreationInterval = c, this.maxBufferSize = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferTimeSubscriber(u, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
  }, a;
}(), Context = /* @__PURE__ */ function() {
  function a() {
    this.buffer = [];
  }
  return a;
}(), BufferTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, S, g) {
    var E = a.call(this, c) || this;
    E.bufferTimeSpan = l, E.bufferCreationInterval = v, E.maxBufferSize = S, E.scheduler = g, E.contexts = [];
    var _ = E.openContext();
    if (E.timespanOnly = v == null || v < 0, E.timespanOnly) {
      var k = { subscriber: E, context: _, bufferTimeSpan: l };
      E.add(_.closeAction = g.schedule(dispatchBufferTimeSpanOnly, l, k));
    } else {
      var L = { subscriber: E, context: _ }, M = { bufferTimeSpan: l, bufferCreationInterval: v, subscriber: E, scheduler: g };
      E.add(_.closeAction = g.schedule(dispatchBufferClose, l, L)), E.add(g.schedule(dispatchBufferCreation, v, M));
    }
    return E;
  }
  return u.prototype._next = function(c) {
    for (var l = this.contexts, v = l.length, S, g = 0; g < v; g++) {
      var E = l[g], _ = E.buffer;
      _.push(c), _.length == this.maxBufferSize && (S = E);
    }
    S && this.onBufferFull(S);
  }, u.prototype._error = function(c) {
    this.contexts.length = 0, a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    for (var c = this, l = c.contexts, v = c.destination; l.length > 0; ) {
      var S = l.shift();
      v.next(S.buffer);
    }
    a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    this.contexts = null;
  }, u.prototype.onBufferFull = function(c) {
    this.closeContext(c);
    var l = c.closeAction;
    if (l.unsubscribe(), this.remove(l), !this.closed && this.timespanOnly) {
      c = this.openContext();
      var v = this.bufferTimeSpan, S = { subscriber: this, context: c, bufferTimeSpan: v };
      this.add(c.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, v, S));
    }
  }, u.prototype.openContext = function() {
    var c = new Context();
    return this.contexts.push(c), c;
  }, u.prototype.closeContext = function(c) {
    this.destination.next(c.buffer);
    var l = this.contexts, v = l ? l.indexOf(c) : -1;
    v >= 0 && l.splice(l.indexOf(c), 1);
  }, u;
}(Subscriber);
function dispatchBufferTimeSpanOnly(a) {
  var u = a.subscriber, c = a.context;
  c && u.closeContext(c), u.closed || (a.context = u.openContext(), a.context.closeAction = this.schedule(a, a.bufferTimeSpan));
}
function dispatchBufferCreation(a) {
  var u = a.bufferCreationInterval, c = a.bufferTimeSpan, l = a.subscriber, v = a.scheduler, S = l.openContext(), g = this;
  l.closed || (l.add(S.closeAction = v.schedule(dispatchBufferClose, c, { subscriber: l, context: S })), g.schedule(a, u));
}
function dispatchBufferClose(a) {
  var u = a.subscriber, c = a.context;
  u.closeContext(c);
}
var InnerSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this) || this;
    return S.parent = c, S.outerValue = l, S.outerIndex = v, S.index = 0, S;
  }
  return u.prototype._next = function(c) {
    this.parent.notifyNext(this.outerValue, c, this.outerIndex, this.index++, this);
  }, u.prototype._error = function(c) {
    this.parent.notifyError(c, this), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.notifyComplete(this), this.unsubscribe();
  }, u;
}(Subscriber);
function subscribeToResult(a, u, c, l, v) {
  if (v === void 0 && (v = new InnerSubscriber(a, c, l)), !v.closed)
    return u instanceof Observable ? u.subscribe(v) : subscribeTo(u)(v);
}
var OuterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.notifyNext = function(c, l, v, S, g) {
    this.destination.next(l);
  }, u.prototype.notifyError = function(c, l) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function(c) {
    this.destination.complete();
  }, u;
}(Subscriber);
function bufferToggle(a, u) {
  return function(l) {
    return l.lift(new BufferToggleOperator(a, u));
  };
}
var BufferToggleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.openings = u, this.closingSelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferToggleSubscriber(u, this.openings, this.closingSelector));
  }, a;
}(), BufferToggleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.closingSelector = v, S.contexts = [], S.add(subscribeToResult(S, l)), S;
  }
  return u.prototype._next = function(c) {
    for (var l = this.contexts, v = l.length, S = 0; S < v; S++)
      l[S].buffer.push(c);
  }, u.prototype._error = function(c) {
    for (var l = this.contexts; l.length > 0; ) {
      var v = l.shift();
      v.subscription.unsubscribe(), v.buffer = null, v.subscription = null;
    }
    this.contexts = null, a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    for (var c = this.contexts; c.length > 0; ) {
      var l = c.shift();
      this.destination.next(l.buffer), l.subscription.unsubscribe(), l.buffer = null, l.subscription = null;
    }
    this.contexts = null, a.prototype._complete.call(this);
  }, u.prototype.notifyNext = function(c, l) {
    c ? this.closeBuffer(c) : this.openBuffer(l);
  }, u.prototype.notifyComplete = function(c) {
    this.closeBuffer(c.context);
  }, u.prototype.openBuffer = function(c) {
    try {
      var l = this.closingSelector, v = l.call(this, c);
      v && this.trySubscribe(v);
    } catch (S) {
      this._error(S);
    }
  }, u.prototype.closeBuffer = function(c) {
    var l = this.contexts;
    if (l && c) {
      var v = c.buffer, S = c.subscription;
      this.destination.next(v), l.splice(l.indexOf(c), 1), this.remove(S), S.unsubscribe();
    }
  }, u.prototype.trySubscribe = function(c) {
    var l = this.contexts, v = [], S = new Subscription(), g = { buffer: v, subscription: S };
    l.push(g);
    var E = subscribeToResult(this, c, g);
    !E || E.closed ? this.closeBuffer(g) : (E.context = g, this.add(E), S.add(E));
  }, u;
}(OuterSubscriber);
function bufferWhen(a) {
  return function(u) {
    return u.lift(new BufferWhenOperator(a));
  };
}
var BufferWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new BufferWhenSubscriber(u, this.closingSelector));
  }, a;
}(), BufferWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.closingSelector = l, v.subscribing = !1, v.openBuffer(), v;
  }
  return u.prototype._next = function(c) {
    this.buffer.push(c);
  }, u.prototype._complete = function() {
    var c = this.buffer;
    c && this.destination.next(c), a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    this.buffer = void 0, this.subscribing = !1;
  }, u.prototype.notifyNext = function() {
    this.openBuffer();
  }, u.prototype.notifyComplete = function() {
    this.subscribing ? this.complete() : this.openBuffer();
  }, u.prototype.openBuffer = function() {
    var c = this.closingSubscription;
    c && (this.remove(c), c.unsubscribe());
    var l = this.buffer;
    this.buffer && this.destination.next(l), this.buffer = [];
    var v;
    try {
      var S = this.closingSelector;
      v = S();
    } catch (g) {
      return this.error(g);
    }
    c = new Subscription(), this.closingSubscription = c, this.add(c), this.subscribing = !0, c.add(innerSubscribe(v, new SimpleInnerSubscriber(this))), this.subscribing = !1;
  }, u;
}(SimpleOuterSubscriber);
function catchError(a) {
  return function(c) {
    var l = new CatchOperator(a), v = c.lift(l);
    return l.caught = v;
  };
}
var CatchOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.selector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CatchSubscriber(u, this.selector, this.caught));
  }, a;
}(), CatchSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.selector = l, S.caught = v, S;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = void 0;
      try {
        l = this.selector(c, this.caught);
      } catch (g) {
        a.prototype.error.call(this, g);
        return;
      }
      this._unsubscribeAndRecycle();
      var v = new SimpleInnerSubscriber(this);
      this.add(v);
      var S = innerSubscribe(l, v);
      S !== v && this.add(S);
    }
  }, u;
}(SimpleOuterSubscriber);
function scheduleArray(a, u) {
  return new Observable(function(c) {
    var l = new Subscription(), v = 0;
    return l.add(u.schedule(function() {
      if (v === a.length) {
        c.complete();
        return;
      }
      c.next(a[v++]), c.closed || l.add(this.schedule());
    })), l;
  });
}
function fromArray(a, u) {
  return u ? scheduleArray(a, u) : new Observable(subscribeToArray(a));
}
var NONE = {}, CombineLatestOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.resultSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CombineLatestSubscriber(u, this.resultSelector));
  }, a;
}(), CombineLatestSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.resultSelector = l, v.active = 0, v.values = [], v.observables = [], v;
  }
  return u.prototype._next = function(c) {
    this.values.push(NONE), this.observables.push(c);
  }, u.prototype._complete = function() {
    var c = this.observables, l = c.length;
    if (l === 0)
      this.destination.complete();
    else {
      this.active = l, this.toRespond = l;
      for (var v = 0; v < l; v++) {
        var S = c[v];
        this.add(subscribeToResult(this, S, void 0, v));
      }
    }
  }, u.prototype.notifyComplete = function(c) {
    (this.active -= 1) === 0 && this.destination.complete();
  }, u.prototype.notifyNext = function(c, l, v) {
    var S = this.values, g = S[v], E = this.toRespond ? g === NONE ? --this.toRespond : this.toRespond : 0;
    S[v] = l, E === 0 && (this.resultSelector ? this._tryResultSelector(S) : this.destination.next(S.slice()));
  }, u.prototype._tryResultSelector = function(c) {
    var l;
    try {
      l = this.resultSelector.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function combineAll(a) {
  return function(u) {
    return u.lift(new CombineLatestOperator(a));
  };
}
function scheduleObservable(a, u) {
  return new Observable(function(c) {
    var l = new Subscription();
    return l.add(u.schedule(function() {
      var v = a[observable]();
      l.add(v.subscribe({
        next: function(S) {
          l.add(u.schedule(function() {
            return c.next(S);
          }));
        },
        error: function(S) {
          l.add(u.schedule(function() {
            return c.error(S);
          }));
        },
        complete: function() {
          l.add(u.schedule(function() {
            return c.complete();
          }));
        }
      }));
    })), l;
  });
}
function schedulePromise(a, u) {
  return new Observable(function(c) {
    var l = new Subscription();
    return l.add(u.schedule(function() {
      return a.then(function(v) {
        l.add(u.schedule(function() {
          c.next(v), l.add(u.schedule(function() {
            return c.complete();
          }));
        }));
      }, function(v) {
        l.add(u.schedule(function() {
          return c.error(v);
        }));
      });
    })), l;
  });
}
function scheduleIterable(a, u) {
  if (!a)
    throw new Error("Iterable cannot be null");
  return new Observable(function(c) {
    var l = new Subscription(), v;
    return l.add(function() {
      v && typeof v.return == "function" && v.return();
    }), l.add(u.schedule(function() {
      v = a[iterator](), l.add(u.schedule(function() {
        if (!c.closed) {
          var S, g;
          try {
            var E = v.next();
            S = E.value, g = E.done;
          } catch (_) {
            c.error(_);
            return;
          }
          g ? c.complete() : (c.next(S), this.schedule());
        }
      }));
    })), l;
  });
}
function isInteropObservable(a) {
  return a && typeof a[observable] == "function";
}
function isIterable(a) {
  return a && typeof a[iterator] == "function";
}
function scheduled(a, u) {
  if (a != null) {
    if (isInteropObservable(a))
      return scheduleObservable(a, u);
    if (isPromise(a))
      return schedulePromise(a, u);
    if (isArrayLike$1(a))
      return scheduleArray(a, u);
    if (isIterable(a) || typeof a == "string")
      return scheduleIterable(a, u);
  }
  throw new TypeError((a !== null && typeof a || a) + " is not observable");
}
function from(a, u) {
  return u ? scheduled(a, u) : a instanceof Observable ? a : new Observable(subscribeTo(a));
}
function combineLatest() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = null;
  return typeof a[a.length - 1] == "function" && (c = a.pop()), a.length === 1 && isArray$4(a[0]) && (a = a[0].slice()), function(l) {
    return l.lift.call(from([l].concat(a)), new CombineLatestOperator(c));
  };
}
function of$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return isScheduler(c) ? (a.pop(), scheduleArray(a, c)) : fromArray(a);
}
function map(a, u) {
  return function(l) {
    if (typeof a != "function")
      throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
    return l.lift(new MapOperator(a, u));
  };
}
var MapOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.project = u, this.thisArg = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MapSubscriber(u, this.project, this.thisArg));
  }, a;
}(), MapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.project = l, S.count = 0, S.thisArg = v || S, S;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.project.call(this.thisArg, c, this.count++);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(Subscriber);
function mergeMap(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), typeof u == "function" ? function(l) {
    return l.pipe(mergeMap(function(v, S) {
      return from(a(v, S)).pipe(map(function(g, E) {
        return u(v, g, S, E);
      }));
    }, c));
  } : (typeof u == "number" && (c = u), function(l) {
    return l.lift(new MergeMapOperator(a, c));
  });
}
var MergeMapOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = Number.POSITIVE_INFINITY), this.project = u, this.concurrent = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MergeMapSubscriber(u, this.project, this.concurrent));
  }, a;
}(), MergeMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    v === void 0 && (v = Number.POSITIVE_INFINITY);
    var S = a.call(this, c) || this;
    return S.project = l, S.concurrent = v, S.hasCompleted = !1, S.buffer = [], S.active = 0, S.index = 0, S;
  }
  return u.prototype._next = function(c) {
    this.active < this.concurrent ? this._tryNext(c) : this.buffer.push(c);
  }, u.prototype._tryNext = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (S) {
      this.destination.error(S);
      return;
    }
    this.active++, this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var S = innerSubscribe(c, l);
    S !== l && v.add(S);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c.length > 0 ? this._next(c.shift()) : this.active === 0 && this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber), flatMap = mergeMap;
function mergeAll(a) {
  return a === void 0 && (a = Number.POSITIVE_INFINITY), mergeMap(identity, a);
}
function concatAll() {
  return mergeAll(1);
}
function concat$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return concatAll()(of$1.apply(void 0, a));
}
function concat() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return c.lift.call(concat$1.apply(void 0, [c].concat(a)));
  };
}
function concatMap(a, u) {
  return mergeMap(a, u, 1);
}
function concatMapTo(a, u) {
  return concatMap(function() {
    return a;
  }, u);
}
function count(a) {
  return function(u) {
    return u.lift(new CountOperator(a, u));
  };
}
var CountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new CountSubscriber(u, this.predicate, this.source));
  }, a;
}(), CountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.predicate = l, S.source = v, S.count = 0, S.index = 0, S;
  }
  return u.prototype._next = function(c) {
    this.predicate ? this._tryPredicate(c) : this.count++;
  }, u.prototype._tryPredicate = function(c) {
    var l;
    try {
      l = this.predicate(c, this.index++, this.source);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l && this.count++;
  }, u.prototype._complete = function() {
    this.destination.next(this.count), this.destination.complete();
  }, u;
}(Subscriber);
function debounce(a) {
  return function(u) {
    return u.lift(new DebounceOperator(a));
  };
}
var DebounceOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.durationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DebounceSubscriber(u, this.durationSelector));
  }, a;
}(), DebounceSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.durationSelector = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    try {
      var l = this.durationSelector.call(this, c);
      l && this._tryNext(c, l);
    } catch (v) {
      this.destination.error(v);
    }
  }, u.prototype._complete = function() {
    this.emitValue(), this.destination.complete();
  }, u.prototype._tryNext = function(c, l) {
    var v = this.durationSubscription;
    this.value = c, this.hasValue = !0, v && (v.unsubscribe(), this.remove(v)), v = innerSubscribe(l, new SimpleInnerSubscriber(this)), v && !v.closed && this.add(this.durationSubscription = v);
  }, u.prototype.notifyNext = function() {
    this.emitValue();
  }, u.prototype.notifyComplete = function() {
    this.emitValue();
  }, u.prototype.emitValue = function() {
    if (this.hasValue) {
      var c = this.value, l = this.durationSubscription;
      l && (this.durationSubscription = void 0, l.unsubscribe(), this.remove(l)), this.value = void 0, this.hasValue = !1, a.prototype._next.call(this, c);
    }
  }, u;
}(SimpleOuterSubscriber);
function debounceTime(a, u) {
  return u === void 0 && (u = async), function(c) {
    return c.lift(new DebounceTimeOperator(a, u));
  };
}
var DebounceTimeOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.dueTime = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DebounceTimeSubscriber(u, this.dueTime, this.scheduler));
  }, a;
}(), DebounceTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.dueTime = l, S.scheduler = v, S.debouncedSubscription = null, S.lastValue = null, S.hasValue = !1, S;
  }
  return u.prototype._next = function(c) {
    this.clearDebounce(), this.lastValue = c, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$1, this.dueTime, this));
  }, u.prototype._complete = function() {
    this.debouncedNext(), this.destination.complete();
  }, u.prototype.debouncedNext = function() {
    if (this.clearDebounce(), this.hasValue) {
      var c = this.lastValue;
      this.lastValue = null, this.hasValue = !1, this.destination.next(c);
    }
  }, u.prototype.clearDebounce = function() {
    var c = this.debouncedSubscription;
    c !== null && (this.remove(c), c.unsubscribe(), this.debouncedSubscription = null);
  }, u;
}(Subscriber);
function dispatchNext$1(a) {
  a.debouncedNext();
}
function defaultIfEmpty(a) {
  return a === void 0 && (a = null), function(u) {
    return u.lift(new DefaultIfEmptyOperator(a));
  };
}
var DefaultIfEmptyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.defaultValue = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DefaultIfEmptySubscriber(u, this.defaultValue));
  }, a;
}(), DefaultIfEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.defaultValue = l, v.isEmpty = !0, v;
  }
  return u.prototype._next = function(c) {
    this.isEmpty = !1, this.destination.next(c);
  }, u.prototype._complete = function() {
    this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete();
  }, u;
}(Subscriber);
function isDate$1(a) {
  return a instanceof Date && !isNaN(+a);
}
var EMPTY = /* @__PURE__ */ new Observable(function(a) {
  return a.complete();
});
function empty$1(a) {
  return a ? emptyScheduled(a) : EMPTY;
}
function emptyScheduled(a) {
  return new Observable(function(u) {
    return a.schedule(function() {
      return u.complete();
    });
  });
}
function throwError(a, u) {
  return u ? new Observable(function(c) {
    return u.schedule(dispatch, 0, { error: a, subscriber: c });
  }) : new Observable(function(c) {
    return c.error(a);
  });
}
function dispatch(a) {
  var u = a.error, c = a.subscriber;
  c.error(u);
}
var Notification = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.kind = u, this.value = c, this.error = l, this.hasValue = u === "N";
  }
  return a.prototype.observe = function(u) {
    switch (this.kind) {
      case "N":
        return u.next && u.next(this.value);
      case "E":
        return u.error && u.error(this.error);
      case "C":
        return u.complete && u.complete();
    }
  }, a.prototype.do = function(u, c, l) {
    var v = this.kind;
    switch (v) {
      case "N":
        return u && u(this.value);
      case "E":
        return c && c(this.error);
      case "C":
        return l && l();
    }
  }, a.prototype.accept = function(u, c, l) {
    return u && typeof u.next == "function" ? this.observe(u) : this.do(u, c, l);
  }, a.prototype.toObservable = function() {
    var u = this.kind;
    switch (u) {
      case "N":
        return of$1(this.value);
      case "E":
        return throwError(this.error);
      case "C":
        return empty$1();
    }
    throw new Error("unexpected notification kind value");
  }, a.createNext = function(u) {
    return typeof u < "u" ? new a("N", u) : a.undefinedValueNotification;
  }, a.createError = function(u) {
    return new a("E", void 0, u);
  }, a.createComplete = function() {
    return a.completeNotification;
  }, a.completeNotification = new a("C"), a.undefinedValueNotification = new a("N", void 0), a;
}();
function delay(a, u) {
  u === void 0 && (u = async);
  var c = isDate$1(a), l = c ? +a - u.now() : Math.abs(a);
  return function(v) {
    return v.lift(new DelayOperator(l, u));
  };
}
var DelayOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.delay = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DelaySubscriber(u, this.delay, this.scheduler));
  }, a;
}(), DelaySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.delay = l, S.scheduler = v, S.queue = [], S.active = !1, S.errored = !1, S;
  }
  return u.dispatch = function(c) {
    for (var l = c.source, v = l.queue, S = c.scheduler, g = c.destination; v.length > 0 && v[0].time - S.now() <= 0; )
      v.shift().notification.observe(g);
    if (v.length > 0) {
      var E = Math.max(0, v[0].time - S.now());
      this.schedule(c, E);
    } else
      this.unsubscribe(), l.active = !1;
  }, u.prototype._schedule = function(c) {
    this.active = !0;
    var l = this.destination;
    l.add(c.schedule(u.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler: c
    }));
  }, u.prototype.scheduleNotification = function(c) {
    if (this.errored !== !0) {
      var l = this.scheduler, v = new DelayMessage(l.now() + this.delay, c);
      this.queue.push(v), this.active === !1 && this._schedule(l);
    }
  }, u.prototype._next = function(c) {
    this.scheduleNotification(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    this.errored = !0, this.queue = [], this.destination.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.scheduleNotification(Notification.createComplete()), this.unsubscribe();
  }, u;
}(Subscriber), DelayMessage = /* @__PURE__ */ function() {
  function a(u, c) {
    this.time = u, this.notification = c;
  }
  return a;
}();
function delayWhen(a, u) {
  return u ? function(c) {
    return new SubscriptionDelayObservable(c, u).lift(new DelayWhenOperator(a));
  } : function(c) {
    return c.lift(new DelayWhenOperator(a));
  };
}
var DelayWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.delayDurationSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DelayWhenSubscriber(u, this.delayDurationSelector));
  }, a;
}(), DelayWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.delayDurationSelector = l, v.completed = !1, v.delayNotifierSubscriptions = [], v.index = 0, v;
  }
  return u.prototype.notifyNext = function(c, l, v, S, g) {
    this.destination.next(c), this.removeSubscription(g), this.tryComplete();
  }, u.prototype.notifyError = function(c, l) {
    this._error(c);
  }, u.prototype.notifyComplete = function(c) {
    var l = this.removeSubscription(c);
    l && this.destination.next(l), this.tryComplete();
  }, u.prototype._next = function(c) {
    var l = this.index++;
    try {
      var v = this.delayDurationSelector(c, l);
      v && this.tryDelay(v, c);
    } catch (S) {
      this.destination.error(S);
    }
  }, u.prototype._complete = function() {
    this.completed = !0, this.tryComplete(), this.unsubscribe();
  }, u.prototype.removeSubscription = function(c) {
    c.unsubscribe();
    var l = this.delayNotifierSubscriptions.indexOf(c);
    return l !== -1 && this.delayNotifierSubscriptions.splice(l, 1), c.outerValue;
  }, u.prototype.tryDelay = function(c, l) {
    var v = subscribeToResult(this, c, l);
    if (v && !v.closed) {
      var S = this.destination;
      S.add(v), this.delayNotifierSubscriptions.push(v);
    }
  }, u.prototype.tryComplete = function() {
    this.completed && this.delayNotifierSubscriptions.length === 0 && this.destination.complete();
  }, u;
}(OuterSubscriber), SubscriptionDelayObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.source = c, v.subscriptionDelay = l, v;
  }
  return u.prototype._subscribe = function(c) {
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(c, this.source));
  }, u;
}(Observable), SubscriptionDelaySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.parent = c, v.source = l, v.sourceSubscribed = !1, v;
  }
  return u.prototype._next = function(c) {
    this.subscribeToSource();
  }, u.prototype._error = function(c) {
    this.unsubscribe(), this.parent.error(c);
  }, u.prototype._complete = function() {
    this.unsubscribe(), this.subscribeToSource();
  }, u.prototype.subscribeToSource = function() {
    this.sourceSubscribed || (this.sourceSubscribed = !0, this.unsubscribe(), this.source.subscribe(this.parent));
  }, u;
}(Subscriber);
function dematerialize() {
  return function(u) {
    return u.lift(new DeMaterializeOperator());
  };
}
var DeMaterializeOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DeMaterializeSubscriber(u));
  }, a;
}(), DeMaterializeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype._next = function(c) {
    c.observe(this.destination);
  }, u;
}(Subscriber);
function distinct(a, u) {
  return function(c) {
    return c.lift(new DistinctOperator(a, u));
  };
}
var DistinctOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.keySelector = u, this.flushes = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DistinctSubscriber(u, this.keySelector, this.flushes));
  }, a;
}(), DistinctSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.keySelector = l, S.values = /* @__PURE__ */ new Set(), v && S.add(innerSubscribe(v, new SimpleInnerSubscriber(S))), S;
  }
  return u.prototype.notifyNext = function() {
    this.values.clear();
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype._next = function(c) {
    this.keySelector ? this._useKeySelector(c) : this._finalizeNext(c, c);
  }, u.prototype._useKeySelector = function(c) {
    var l, v = this.destination;
    try {
      l = this.keySelector(c);
    } catch (S) {
      v.error(S);
      return;
    }
    this._finalizeNext(l, c);
  }, u.prototype._finalizeNext = function(c, l) {
    var v = this.values;
    v.has(c) || (v.add(c), this.destination.next(l));
  }, u;
}(SimpleOuterSubscriber);
function distinctUntilChanged(a, u) {
  return function(c) {
    return c.lift(new DistinctUntilChangedOperator(a, u));
  };
}
var DistinctUntilChangedOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.compare = u, this.keySelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new DistinctUntilChangedSubscriber(u, this.compare, this.keySelector));
  }, a;
}(), DistinctUntilChangedSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.keySelector = v, S.hasKey = !1, typeof l == "function" && (S.compare = l), S;
  }
  return u.prototype.compare = function(c, l) {
    return c === l;
  }, u.prototype._next = function(c) {
    var l;
    try {
      var v = this.keySelector;
      l = v ? v(c) : c;
    } catch (E) {
      return this.destination.error(E);
    }
    var S = !1;
    if (this.hasKey)
      try {
        var g = this.compare;
        S = g(this.key, l);
      } catch (E) {
        return this.destination.error(E);
      }
    else
      this.hasKey = !0;
    S || (this.key = l, this.destination.next(c));
  }, u;
}(Subscriber);
function distinctUntilKeyChanged(a, u) {
  return distinctUntilChanged(function(c, l) {
    return u ? u(c[a], l[a]) : c[a] === l[a];
  });
}
var ArgumentOutOfRangeErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
function filter(a, u) {
  return function(l) {
    return l.lift(new FilterOperator(a, u));
  };
}
var FilterOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.thisArg = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FilterSubscriber(u, this.predicate, this.thisArg));
  }, a;
}(), FilterSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.predicate = l, S.thisArg = v, S.count = 0, S;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.predicate.call(this.thisArg, c, this.count++);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l && this.destination.next(c);
  }, u;
}(Subscriber), EmptyErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), EmptyError = EmptyErrorImpl;
function throwIfEmpty(a) {
  return a === void 0 && (a = defaultErrorFactory), function(u) {
    return u.lift(new ThrowIfEmptyOperator(a));
  };
}
var ThrowIfEmptyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.errorFactory = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrowIfEmptySubscriber(u, this.errorFactory));
  }, a;
}(), ThrowIfEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.errorFactory = l, v.hasValue = !1, v;
  }
  return u.prototype._next = function(c) {
    this.hasValue = !0, this.destination.next(c);
  }, u.prototype._complete = function() {
    if (this.hasValue)
      return this.destination.complete();
    var c = void 0;
    try {
      c = this.errorFactory();
    } catch (l) {
      c = l;
    }
    this.destination.error(c);
  }, u;
}(Subscriber);
function defaultErrorFactory() {
  return new EmptyError();
}
function take(a) {
  return function(u) {
    return a === 0 ? empty$1() : u.lift(new TakeOperator(a));
  };
}
var TakeOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this.total = u, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeSubscriber(u, this.total));
  }, a;
}(), TakeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.total, v = ++this.count;
    v <= l && (this.destination.next(c), v === l && (this.destination.complete(), this.unsubscribe()));
  }, u;
}(Subscriber);
function elementAt(a, u) {
  if (a < 0)
    throw new ArgumentOutOfRangeError();
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(filter(function(v, S) {
      return S === a;
    }), take(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new ArgumentOutOfRangeError();
    }));
  };
}
function endWith() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return concat$1(c, of$1.apply(void 0, a));
  };
}
function every(a, u) {
  return function(c) {
    return c.lift(new EveryOperator(a, u, c));
  };
}
var EveryOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.predicate = u, this.thisArg = c, this.source = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new EverySubscriber(u, this.predicate, this.thisArg, this.source));
  }, a;
}(), EverySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, S) {
    var g = a.call(this, c) || this;
    return g.predicate = l, g.thisArg = v, g.source = S, g.index = 0, g.thisArg = v || g, g;
  }
  return u.prototype.notifyComplete = function(c) {
    this.destination.next(c), this.destination.complete();
  }, u.prototype._next = function(c) {
    var l = !1;
    try {
      l = this.predicate.call(this.thisArg, c, this.index++, this.source);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    l || this.notifyComplete(!1);
  }, u.prototype._complete = function() {
    this.notifyComplete(!0);
  }, u;
}(Subscriber);
function exhaust() {
  return function(a) {
    return a.lift(new SwitchFirstOperator());
  };
}
var SwitchFirstOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SwitchFirstSubscriber(u));
  }, a;
}(), SwitchFirstSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasCompleted = !1, l.hasSubscription = !1, l;
  }
  return u.prototype._next = function(c) {
    this.hasSubscription || (this.hasSubscription = !0, this.add(innerSubscribe(c, new SimpleInnerSubscriber(this))));
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete();
  }, u.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function exhaustMap(a, u) {
  return u ? function(c) {
    return c.pipe(exhaustMap(function(l, v) {
      return from(a(l, v)).pipe(map(function(S, g) {
        return u(l, S, v, g);
      }));
    }));
  } : function(c) {
    return c.lift(new ExhaustMapOperator(a));
  };
}
var ExhaustMapOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.project = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ExhaustMapSubscriber(u, this.project));
  }, a;
}(), ExhaustMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.project = l, v.hasSubscription = !1, v.hasCompleted = !1, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    this.hasSubscription || this.tryNext(c);
  }, u.prototype.tryNext = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (S) {
      this.destination.error(S);
      return;
    }
    this.hasSubscription = !0, this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var S = innerSubscribe(c, l);
    S !== l && v.add(S);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasSubscription || this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u.prototype.notifyError = function(c) {
    this.destination.error(c);
  }, u.prototype.notifyComplete = function() {
    this.hasSubscription = !1, this.hasCompleted && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function expand(a, u, c) {
  return u === void 0 && (u = Number.POSITIVE_INFINITY), u = (u || 0) < 1 ? Number.POSITIVE_INFINITY : u, function(l) {
    return l.lift(new ExpandOperator(a, u, c));
  };
}
var ExpandOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.project = u, this.concurrent = c, this.scheduler = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ExpandSubscriber(u, this.project, this.concurrent, this.scheduler));
  }, a;
}(), ExpandSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, S) {
    var g = a.call(this, c) || this;
    return g.project = l, g.concurrent = v, g.scheduler = S, g.index = 0, g.active = 0, g.hasCompleted = !1, v < Number.POSITIVE_INFINITY && (g.buffer = []), g;
  }
  return u.dispatch = function(c) {
    var l = c.subscriber, v = c.result, S = c.value, g = c.index;
    l.subscribeToProjection(v, S, g);
  }, u.prototype._next = function(c) {
    var l = this.destination;
    if (l.closed) {
      this._complete();
      return;
    }
    var v = this.index++;
    if (this.active < this.concurrent) {
      l.next(c);
      try {
        var S = this.project, g = S(c, v);
        if (!this.scheduler)
          this.subscribeToProjection(g, c, v);
        else {
          var E = { subscriber: this, result: g, value: c, index: v }, _ = this.destination;
          _.add(this.scheduler.schedule(u.dispatch, 0, E));
        }
      } catch (k) {
        l.error(k);
      }
    } else
      this.buffer.push(c);
  }, u.prototype.subscribeToProjection = function(c, l, v) {
    this.active++;
    var S = this.destination;
    S.add(innerSubscribe(c, new SimpleInnerSubscriber(this)));
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.hasCompleted && this.active === 0 && this.destination.complete(), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    this._next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c && c.length > 0 && this._next(c.shift()), this.hasCompleted && this.active === 0 && this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function finalize(a) {
  return function(u) {
    return u.lift(new FinallyOperator(a));
  };
}
var FinallyOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.callback = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FinallySubscriber(u, this.callback));
  }, a;
}(), FinallySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.add(new Subscription(l)), v;
  }
  return u;
}(Subscriber);
function find$1(a, u) {
  if (typeof a != "function")
    throw new TypeError("predicate is not a function");
  return function(c) {
    return c.lift(new FindValueOperator(a, c, !1, u));
  };
}
var FindValueOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.predicate = u, this.source = c, this.yieldIndex = l, this.thisArg = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new FindValueSubscriber(u, this.predicate, this.source, this.yieldIndex, this.thisArg));
  }, a;
}(), FindValueSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, S, g) {
    var E = a.call(this, c) || this;
    return E.predicate = l, E.source = v, E.yieldIndex = S, E.thisArg = g, E.index = 0, E;
  }
  return u.prototype.notifyComplete = function(c) {
    var l = this.destination;
    l.next(c), l.complete(), this.unsubscribe();
  }, u.prototype._next = function(c) {
    var l = this, v = l.predicate, S = l.thisArg, g = this.index++;
    try {
      var E = v.call(S || this, c, g, this.source);
      E && this.notifyComplete(this.yieldIndex ? g : c);
    } catch (_) {
      this.destination.error(_);
    }
  }, u.prototype._complete = function() {
    this.notifyComplete(this.yieldIndex ? -1 : void 0);
  }, u;
}(Subscriber);
function findIndex(a, u) {
  return function(c) {
    return c.lift(new FindValueOperator(a, c, !0, u));
  };
}
function first(a, u) {
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(a ? filter(function(v, S) {
      return a(v, S, l);
    }) : identity, take(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
var ObjectUnsubscribedErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl, SubjectSubscription = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.subject = c, v.subscriber = l, v.closed = !1, v;
  }
  return u.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.closed = !0;
      var c = this.subject, l = c.observers;
      if (this.subject = null, !(!l || l.length === 0 || c.isStopped || c.closed)) {
        var v = l.indexOf(this.subscriber);
        v !== -1 && l.splice(v, 1);
      }
    }
  }, u;
}(Subscription), SubjectSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.destination = c, l;
  }
  return u;
}(Subscriber), Subject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a.call(this) || this;
    return c.observers = [], c.closed = !1, c.isStopped = !1, c.hasError = !1, c.thrownError = null, c;
  }
  return u.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  }, u.prototype.lift = function(c) {
    var l = new AnonymousSubject(this, this);
    return l.operator = c, l;
  }, u.prototype.next = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (!this.isStopped)
      for (var l = this.observers, v = l.length, S = l.slice(), g = 0; g < v; g++)
        S[g].next(c);
  }, u.prototype.error = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.hasError = !0, this.thrownError = c, this.isStopped = !0;
    for (var l = this.observers, v = l.length, S = l.slice(), g = 0; g < v; g++)
      S[g].error(c);
    this.observers.length = 0;
  }, u.prototype.complete = function() {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    this.isStopped = !0;
    for (var c = this.observers, l = c.length, v = c.slice(), S = 0; S < l; S++)
      v[S].complete();
    this.observers.length = 0;
  }, u.prototype.unsubscribe = function() {
    this.isStopped = !0, this.closed = !0, this.observers = null;
  }, u.prototype._trySubscribe = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return a.prototype._trySubscribe.call(this, c);
  }, u.prototype._subscribe = function(c) {
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this.hasError ? (c.error(this.thrownError), Subscription.EMPTY) : this.isStopped ? (c.complete(), Subscription.EMPTY) : (this.observers.push(c), new SubjectSubscription(this, c));
  }, u.prototype.asObservable = function() {
    var c = new Observable();
    return c.source = this, c;
  }, u.create = function(c, l) {
    return new AnonymousSubject(c, l);
  }, u;
}(Observable), AnonymousSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.destination = c, v.source = l, v;
  }
  return u.prototype.next = function(c) {
    var l = this.destination;
    l && l.next && l.next(c);
  }, u.prototype.error = function(c) {
    var l = this.destination;
    l && l.error && this.destination.error(c);
  }, u.prototype.complete = function() {
    var c = this.destination;
    c && c.complete && this.destination.complete();
  }, u.prototype._subscribe = function(c) {
    var l = this.source;
    return l ? this.source.subscribe(c) : Subscription.EMPTY;
  }, u;
}(Subject);
function groupBy(a, u, c, l) {
  return function(v) {
    return v.lift(new GroupByOperator(a, u, c, l));
  };
}
var GroupByOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.keySelector = u, this.elementSelector = c, this.durationSelector = l, this.subjectSelector = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new GroupBySubscriber(u, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
  }, a;
}(), GroupBySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, S, g) {
    var E = a.call(this, c) || this;
    return E.keySelector = l, E.elementSelector = v, E.durationSelector = S, E.subjectSelector = g, E.groups = null, E.attemptedToUnsubscribe = !1, E.count = 0, E;
  }
  return u.prototype._next = function(c) {
    var l;
    try {
      l = this.keySelector(c);
    } catch (v) {
      this.error(v);
      return;
    }
    this._group(c, l);
  }, u.prototype._group = function(c, l) {
    var v = this.groups;
    v || (v = this.groups = /* @__PURE__ */ new Map());
    var S = v.get(l), g;
    if (this.elementSelector)
      try {
        g = this.elementSelector(c);
      } catch (k) {
        this.error(k);
      }
    else
      g = c;
    if (!S) {
      S = this.subjectSelector ? this.subjectSelector() : new Subject(), v.set(l, S);
      var E = new GroupedObservable(l, S, this);
      if (this.destination.next(E), this.durationSelector) {
        var _ = void 0;
        try {
          _ = this.durationSelector(new GroupedObservable(l, S));
        } catch (k) {
          this.error(k);
          return;
        }
        this.add(_.subscribe(new GroupDurationSubscriber(l, S, this)));
      }
    }
    S.closed || S.next(g);
  }, u.prototype._error = function(c) {
    var l = this.groups;
    l && (l.forEach(function(v, S) {
      v.error(c);
    }), l.clear()), this.destination.error(c);
  }, u.prototype._complete = function() {
    var c = this.groups;
    c && (c.forEach(function(l, v) {
      l.complete();
    }), c.clear()), this.destination.complete();
  }, u.prototype.removeGroup = function(c) {
    this.groups.delete(c);
  }, u.prototype.unsubscribe = function() {
    this.closed || (this.attemptedToUnsubscribe = !0, this.count === 0 && a.prototype.unsubscribe.call(this));
  }, u;
}(Subscriber), GroupDurationSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, l) || this;
    return S.key = c, S.group = l, S.parent = v, S;
  }
  return u.prototype._next = function(c) {
    this.complete();
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.parent, v = c.key;
    this.key = this.parent = null, l && l.removeGroup(v);
  }, u;
}(Subscriber), GroupedObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this) || this;
    return S.key = c, S.groupSubject = l, S.refCountSubscription = v, S;
  }
  return u.prototype._subscribe = function(c) {
    var l = new Subscription(), v = this, S = v.refCountSubscription, g = v.groupSubject;
    return S && !S.closed && l.add(new InnerRefCountSubscription(S)), l.add(g.subscribe(c)), l;
  }, u;
}(Observable), InnerRefCountSubscription = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l.parent = c, c.count++, l;
  }
  return u.prototype.unsubscribe = function() {
    var c = this.parent;
    !c.closed && !this.closed && (a.prototype.unsubscribe.call(this), c.count -= 1, c.count === 0 && c.attemptedToUnsubscribe && c.unsubscribe());
  }, u;
}(Subscription);
function ignoreElements() {
  return function(u) {
    return u.lift(new IgnoreElementsOperator());
  };
}
var IgnoreElementsOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new IgnoreElementsSubscriber(u));
  }, a;
}(), IgnoreElementsSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype._next = function(c) {
  }, u;
}(Subscriber);
function isEmpty() {
  return function(a) {
    return a.lift(new IsEmptyOperator());
  };
}
var IsEmptyOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new IsEmptySubscriber(u));
  }, a;
}(), IsEmptySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype.notifyComplete = function(c) {
    var l = this.destination;
    l.next(c), l.complete();
  }, u.prototype._next = function(c) {
    this.notifyComplete(!1);
  }, u.prototype._complete = function() {
    this.notifyComplete(!0);
  }, u;
}(Subscriber);
function takeLast(a) {
  return function(c) {
    return a === 0 ? empty$1() : c.lift(new TakeLastOperator(a));
  };
}
var TakeLastOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this.total = u, this.total < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeLastSubscriber(u, this.total));
  }, a;
}(), TakeLastSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.ring = new Array(), v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.ring, v = this.total, S = this.count++;
    if (l.length < v)
      l.push(c);
    else {
      var g = S % v;
      l[g] = c;
    }
  }, u.prototype._complete = function() {
    var c = this.destination, l = this.count;
    if (l > 0)
      for (var v = this.count >= this.total ? this.total : this.count, S = this.ring, g = 0; g < v; g++) {
        var E = l++ % v;
        c.next(S[E]);
      }
    c.complete();
  }, u;
}(Subscriber);
function last(a, u) {
  var c = arguments.length >= 2;
  return function(l) {
    return l.pipe(a ? filter(function(v, S) {
      return a(v, S, l);
    }) : identity, takeLast(1), c ? defaultIfEmpty(u) : throwIfEmpty(function() {
      return new EmptyError();
    }));
  };
}
function mapTo(a) {
  return function(u) {
    return u.lift(new MapToOperator(a));
  };
}
var MapToOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.value = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MapToSubscriber(u, this.value));
  }, a;
}(), MapToSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.value = l, v;
  }
  return u.prototype._next = function(c) {
    this.destination.next(this.value);
  }, u;
}(Subscriber);
function materialize() {
  return function(u) {
    return u.lift(new MaterializeOperator());
  };
}
var MaterializeOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MaterializeSubscriber(u));
  }, a;
}(), MaterializeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    return a.call(this, c) || this;
  }
  return u.prototype._next = function(c) {
    this.destination.next(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    var l = this.destination;
    l.next(Notification.createError(c)), l.complete();
  }, u.prototype._complete = function() {
    var c = this.destination;
    c.next(Notification.createComplete()), c.complete();
  }, u;
}(Subscriber);
function scan(a, u) {
  var c = !1;
  return arguments.length >= 2 && (c = !0), function(v) {
    return v.lift(new ScanOperator(a, u, c));
  };
}
var ScanOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    l === void 0 && (l = !1), this.accumulator = u, this.seed = c, this.hasSeed = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ScanSubscriber(u, this.accumulator, this.seed, this.hasSeed));
  }, a;
}(), ScanSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, S) {
    var g = a.call(this, c) || this;
    return g.accumulator = l, g._seed = v, g.hasSeed = S, g.index = 0, g;
  }
  return Object.defineProperty(u.prototype, "seed", {
    get: function() {
      return this._seed;
    },
    set: function(c) {
      this.hasSeed = !0, this._seed = c;
    },
    enumerable: !0,
    configurable: !0
  }), u.prototype._next = function(c) {
    if (!this.hasSeed)
      this.seed = c, this.destination.next(c);
    else
      return this._tryNext(c);
  }, u.prototype._tryNext = function(c) {
    var l = this.index++, v;
    try {
      v = this.accumulator(this.seed, c, l);
    } catch (S) {
      this.destination.error(S);
    }
    this.seed = v, this.destination.next(v);
  }, u;
}(Subscriber);
function reduce(a, u) {
  return arguments.length >= 2 ? function(l) {
    return pipe(scan(a, u), takeLast(1), defaultIfEmpty(u))(l);
  } : function(l) {
    return pipe(scan(function(v, S, g) {
      return a(v, S, g + 1);
    }), takeLast(1))(l);
  };
}
function max(a) {
  var u = typeof a == "function" ? function(c, l) {
    return a(c, l) > 0 ? c : l;
  } : function(c, l) {
    return c > l ? c : l;
  };
  return reduce(u);
}
function merge$2() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = Number.POSITIVE_INFINITY, l = null, v = a[a.length - 1];
  return isScheduler(v) ? (l = a.pop(), a.length > 1 && typeof a[a.length - 1] == "number" && (c = a.pop())) : typeof v == "number" && (c = a.pop()), l === null && a.length === 1 && a[0] instanceof Observable ? a[0] : mergeAll(c)(fromArray(a, l));
}
function merge$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    return c.lift.call(merge$2.apply(void 0, [c].concat(a)));
  };
}
function mergeMapTo(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), typeof u == "function" ? mergeMap(function() {
    return a;
  }, u, c) : (typeof u == "number" && (c = u), mergeMap(function() {
    return a;
  }, c));
}
function mergeScan(a, u, c) {
  return c === void 0 && (c = Number.POSITIVE_INFINITY), function(l) {
    return l.lift(new MergeScanOperator(a, u, c));
  };
}
var MergeScanOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.accumulator = u, this.seed = c, this.concurrent = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new MergeScanSubscriber(u, this.accumulator, this.seed, this.concurrent));
  }, a;
}(), MergeScanSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, S) {
    var g = a.call(this, c) || this;
    return g.accumulator = l, g.acc = v, g.concurrent = S, g.hasValue = !1, g.hasCompleted = !1, g.buffer = [], g.active = 0, g.index = 0, g;
  }
  return u.prototype._next = function(c) {
    if (this.active < this.concurrent) {
      var l = this.index++, v = this.destination, S = void 0;
      try {
        var g = this.accumulator;
        S = g(this.acc, c, l);
      } catch (E) {
        return v.error(E);
      }
      this.active++, this._innerSub(S);
    } else
      this.buffer.push(c);
  }, u.prototype._innerSub = function(c) {
    var l = new SimpleInnerSubscriber(this), v = this.destination;
    v.add(l);
    var S = innerSubscribe(c, l);
    S !== l && v.add(S);
  }, u.prototype._complete = function() {
    this.hasCompleted = !0, this.active === 0 && this.buffer.length === 0 && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete()), this.unsubscribe();
  }, u.prototype.notifyNext = function(c) {
    var l = this.destination;
    this.acc = c, this.hasValue = !0, l.next(c);
  }, u.prototype.notifyComplete = function() {
    var c = this.buffer;
    this.active--, c.length > 0 ? this._next(c.shift()) : this.active === 0 && this.hasCompleted && (this.hasValue === !1 && this.destination.next(this.acc), this.destination.complete());
  }, u;
}(SimpleOuterSubscriber);
function min(a) {
  var u = typeof a == "function" ? function(c, l) {
    return a(c, l) < 0 ? c : l;
  } : function(c, l) {
    return c < l ? c : l;
  };
  return reduce(u);
}
function refCount() {
  return function(u) {
    return u.lift(new RefCountOperator(u));
  };
}
var RefCountOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.connectable = u;
  }
  return a.prototype.call = function(u, c) {
    var l = this.connectable;
    l._refCount++;
    var v = new RefCountSubscriber(u, l), S = c.subscribe(v);
    return v.closed || (v.connection = l.connect()), S;
  }, a;
}(), RefCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.connectable = l, v;
  }
  return u.prototype._unsubscribe = function() {
    var c = this.connectable;
    if (!c) {
      this.connection = null;
      return;
    }
    this.connectable = null;
    var l = c._refCount;
    if (l <= 0) {
      this.connection = null;
      return;
    }
    if (c._refCount = l - 1, l > 1) {
      this.connection = null;
      return;
    }
    var v = this.connection, S = c._connection;
    this.connection = null, S && (!v || S === v) && S.unsubscribe();
  }, u;
}(Subscriber), ConnectableObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this) || this;
    return v.source = c, v.subjectFactory = l, v._refCount = 0, v._isComplete = !1, v;
  }
  return u.prototype._subscribe = function(c) {
    return this.getSubject().subscribe(c);
  }, u.prototype.getSubject = function() {
    var c = this._subject;
    return (!c || c.isStopped) && (this._subject = this.subjectFactory()), this._subject;
  }, u.prototype.connect = function() {
    var c = this._connection;
    return c || (this._isComplete = !1, c = this._connection = new Subscription(), c.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this))), c.closed && (this._connection = null, c = Subscription.EMPTY)), c;
  }, u.prototype.refCount = function() {
    return refCount()(this);
  }, u;
}(Observable), connectableObservableDescriptor = /* @__PURE__ */ function() {
  var a = ConnectableObservable.prototype;
  return {
    operator: { value: null },
    _refCount: { value: 0, writable: !0 },
    _subject: { value: null, writable: !0 },
    _connection: { value: null, writable: !0 },
    _subscribe: { value: a._subscribe },
    _isComplete: { value: a._isComplete, writable: !0 },
    getSubject: { value: a.getSubject },
    connect: { value: a.connect },
    refCount: { value: a.refCount }
  };
}(), ConnectableSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.connectable = l, v;
  }
  return u.prototype._error = function(c) {
    this._unsubscribe(), a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    this.connectable._isComplete = !0, this._unsubscribe(), a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    var c = this.connectable;
    if (c) {
      this.connectable = null;
      var l = c._connection;
      c._refCount = 0, c._subject = null, c._connection = null, l && l.unsubscribe();
    }
  }, u;
}(SubjectSubscriber);
function multicast(a, u) {
  return function(l) {
    var v;
    if (typeof a == "function" ? v = a : v = function() {
      return a;
    }, typeof u == "function")
      return l.lift(new MulticastOperator(v, u));
    var S = Object.create(l, connectableObservableDescriptor);
    return S.source = l, S.subjectFactory = v, S;
  };
}
var MulticastOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.subjectFactory = u, this.selector = c;
  }
  return a.prototype.call = function(u, c) {
    var l = this.selector, v = this.subjectFactory(), S = l(v).subscribe(u);
    return S.add(c.subscribe(v)), S;
  }, a;
}();
function observeOn(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new ObserveOnOperator(a, u));
  };
}
var ObserveOnOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    c === void 0 && (c = 0), this.scheduler = u, this.delay = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ObserveOnSubscriber(u, this.scheduler, this.delay));
  }, a;
}(), ObserveOnSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    v === void 0 && (v = 0);
    var S = a.call(this, c) || this;
    return S.scheduler = l, S.delay = v, S;
  }
  return u.dispatch = function(c) {
    var l = c.notification, v = c.destination;
    l.observe(v), this.unsubscribe();
  }, u.prototype.scheduleMessage = function(c) {
    var l = this.destination;
    l.add(this.scheduler.schedule(u.dispatch, this.delay, new ObserveOnMessage(c, this.destination)));
  }, u.prototype._next = function(c) {
    this.scheduleMessage(Notification.createNext(c));
  }, u.prototype._error = function(c) {
    this.scheduleMessage(Notification.createError(c)), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.scheduleMessage(Notification.createComplete()), this.unsubscribe();
  }, u;
}(Subscriber), ObserveOnMessage = /* @__PURE__ */ function() {
  function a(u, c) {
    this.notification = u, this.destination = c;
  }
  return a;
}();
function onErrorResumeNext() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return a.length === 1 && isArray$4(a[0]) && (a = a[0]), function(c) {
    return c.lift(new OnErrorResumeNextOperator(a));
  };
}
var OnErrorResumeNextOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.nextSources = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new OnErrorResumeNextSubscriber(u, this.nextSources));
  }, a;
}(), OnErrorResumeNextSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.destination = c, v.nextSources = l, v;
  }
  return u.prototype.notifyError = function() {
    this.subscribeToNextSource();
  }, u.prototype.notifyComplete = function() {
    this.subscribeToNextSource();
  }, u.prototype._error = function(c) {
    this.subscribeToNextSource(), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.subscribeToNextSource(), this.unsubscribe();
  }, u.prototype.subscribeToNextSource = function() {
    var c = this.nextSources.shift();
    if (c) {
      var l = new SimpleInnerSubscriber(this), v = this.destination;
      v.add(l);
      var S = innerSubscribe(c, l);
      S !== l && v.add(S);
    } else
      this.destination.complete();
  }, u;
}(SimpleOuterSubscriber);
function pairwise() {
  return function(a) {
    return a.lift(new PairwiseOperator());
  };
}
var PairwiseOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new PairwiseSubscriber(u));
  }, a;
}(), PairwiseSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasPrev = !1, l;
  }
  return u.prototype._next = function(c) {
    var l;
    this.hasPrev ? l = [this.prev, c] : this.hasPrev = !0, this.prev = c, l && this.destination.next(l);
  }, u;
}(Subscriber);
function not(a, u) {
  function c() {
    return !c.pred.apply(c.thisArg, arguments);
  }
  return c.pred = a, c.thisArg = u, c;
}
function partition(a, u) {
  return function(c) {
    return [
      filter(a, u)(c),
      filter(not(a, u))(c)
    ];
  };
}
function pluck() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a.length;
  if (c === 0)
    throw new Error("list of properties cannot be empty.");
  return function(l) {
    return map(plucker(a, c))(l);
  };
}
function plucker(a, u) {
  var c = function(l) {
    for (var v = l, S = 0; S < u; S++) {
      var g = v != null ? v[a[S]] : void 0;
      if (g !== void 0)
        v = g;
      else
        return;
    }
    return v;
  };
  return c;
}
function publish(a) {
  return a ? multicast(function() {
    return new Subject();
  }, a) : multicast(new Subject());
}
var BehaviorSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this) || this;
    return l._value = c, l;
  }
  return Object.defineProperty(u.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: !0,
    configurable: !0
  }), u.prototype._subscribe = function(c) {
    var l = a.prototype._subscribe.call(this, c);
    return l && !l.closed && c.next(this._value), l;
  }, u.prototype.getValue = function() {
    if (this.hasError)
      throw this.thrownError;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    return this._value;
  }, u.prototype.next = function(c) {
    a.prototype.next.call(this, this._value = c);
  }, u;
}(Subject);
function publishBehavior(a) {
  return function(u) {
    return multicast(new BehaviorSubject(a))(u);
  };
}
var AsyncSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c.value = null, c.hasNext = !1, c.hasCompleted = !1, c;
  }
  return u.prototype._subscribe = function(c) {
    return this.hasError ? (c.error(this.thrownError), Subscription.EMPTY) : this.hasCompleted && this.hasNext ? (c.next(this.value), c.complete(), Subscription.EMPTY) : a.prototype._subscribe.call(this, c);
  }, u.prototype.next = function(c) {
    this.hasCompleted || (this.value = c, this.hasNext = !0);
  }, u.prototype.error = function(c) {
    this.hasCompleted || a.prototype.error.call(this, c);
  }, u.prototype.complete = function() {
    this.hasCompleted = !0, this.hasNext && a.prototype.next.call(this, this.value), a.prototype.complete.call(this);
  }, u;
}(Subject);
function publishLast() {
  return function(a) {
    return multicast(new AsyncSubject())(a);
  };
}
var QueueAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v;
  }
  return u.prototype.schedule = function(c, l) {
    return l === void 0 && (l = 0), l > 0 ? a.prototype.schedule.call(this, c, l) : (this.delay = l, this.state = c, this.scheduler.flush(this), this);
  }, u.prototype.execute = function(c, l) {
    return l > 0 || this.closed ? a.prototype.execute.call(this, c, l) : this._execute(c, l);
  }, u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), v !== null && v > 0 || v === null && this.delay > 0 ? a.prototype.requestAsyncId.call(this, c, l, v) : c.flush(this);
  }, u;
}(AsyncAction), QueueScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u;
}(AsyncScheduler), queueScheduler = /* @__PURE__ */ new QueueScheduler(QueueAction), queue = queueScheduler, ReplaySubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    c === void 0 && (c = Number.POSITIVE_INFINITY), l === void 0 && (l = Number.POSITIVE_INFINITY);
    var S = a.call(this) || this;
    return S.scheduler = v, S._events = [], S._infiniteTimeWindow = !1, S._bufferSize = c < 1 ? 1 : c, S._windowTime = l < 1 ? 1 : l, l === Number.POSITIVE_INFINITY ? (S._infiniteTimeWindow = !0, S.next = S.nextInfiniteTimeWindow) : S.next = S.nextTimeWindow, S;
  }
  return u.prototype.nextInfiniteTimeWindow = function(c) {
    if (!this.isStopped) {
      var l = this._events;
      l.push(c), l.length > this._bufferSize && l.shift();
    }
    a.prototype.next.call(this, c);
  }, u.prototype.nextTimeWindow = function(c) {
    this.isStopped || (this._events.push(new ReplayEvent(this._getNow(), c)), this._trimBufferThenGetEvents()), a.prototype.next.call(this, c);
  }, u.prototype._subscribe = function(c) {
    var l = this._infiniteTimeWindow, v = l ? this._events : this._trimBufferThenGetEvents(), S = this.scheduler, g = v.length, E;
    if (this.closed)
      throw new ObjectUnsubscribedError();
    if (this.isStopped || this.hasError ? E = Subscription.EMPTY : (this.observers.push(c), E = new SubjectSubscription(this, c)), S && c.add(c = new ObserveOnSubscriber(c, S)), l)
      for (var _ = 0; _ < g && !c.closed; _++)
        c.next(v[_]);
    else
      for (var _ = 0; _ < g && !c.closed; _++)
        c.next(v[_].value);
    return this.hasError ? c.error(this.thrownError) : this.isStopped && c.complete(), E;
  }, u.prototype._getNow = function() {
    return (this.scheduler || queue).now();
  }, u.prototype._trimBufferThenGetEvents = function() {
    for (var c = this._getNow(), l = this._bufferSize, v = this._windowTime, S = this._events, g = S.length, E = 0; E < g && !(c - S[E].time < v); )
      E++;
    return g > l && (E = Math.max(E, g - l)), E > 0 && S.splice(0, E), S;
  }, u;
}(Subject), ReplayEvent = /* @__PURE__ */ function() {
  function a(u, c) {
    this.time = u, this.value = c;
  }
  return a;
}();
function publishReplay(a, u, c, l) {
  c && typeof c != "function" && (l = c);
  var v = typeof c == "function" ? c : void 0, S = new ReplaySubject(a, u, l);
  return function(g) {
    return multicast(function() {
      return S;
    }, v)(g);
  };
}
function race$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  if (a.length === 1)
    if (isArray$4(a[0]))
      a = a[0];
    else
      return a[0];
  return fromArray(a, void 0).lift(new RaceOperator());
}
var RaceOperator = /* @__PURE__ */ function() {
  function a() {
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RaceSubscriber(u));
  }, a;
}(), RaceSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.hasFirst = !1, l.observables = [], l.subscriptions = [], l;
  }
  return u.prototype._next = function(c) {
    this.observables.push(c);
  }, u.prototype._complete = function() {
    var c = this.observables, l = c.length;
    if (l === 0)
      this.destination.complete();
    else {
      for (var v = 0; v < l && !this.hasFirst; v++) {
        var S = c[v], g = subscribeToResult(this, S, void 0, v);
        this.subscriptions && this.subscriptions.push(g), this.add(g);
      }
      this.observables = null;
    }
  }, u.prototype.notifyNext = function(c, l, v) {
    if (!this.hasFirst) {
      this.hasFirst = !0;
      for (var S = 0; S < this.subscriptions.length; S++)
        if (S !== v) {
          var g = this.subscriptions[S];
          g.unsubscribe(), this.remove(g);
        }
      this.subscriptions = null;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function race() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(l) {
    return a.length === 1 && isArray$4(a[0]) && (a = a[0]), l.lift.call(race$1.apply(void 0, [l].concat(a)));
  };
}
function repeat(a) {
  return a === void 0 && (a = -1), function(u) {
    return a === 0 ? empty$1() : a < 0 ? u.lift(new RepeatOperator(-1, u)) : u.lift(new RepeatOperator(a - 1, u));
  };
}
var RepeatOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.count = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RepeatSubscriber(u, this.count, this.source));
  }, a;
}(), RepeatSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.count = l, S.source = v, S;
  }
  return u.prototype.complete = function() {
    if (!this.isStopped) {
      var c = this, l = c.source, v = c.count;
      if (v === 0)
        return a.prototype.complete.call(this);
      v > -1 && (this.count = v - 1), l.subscribe(this._unsubscribeAndRecycle());
    }
  }, u;
}(Subscriber);
function repeatWhen(a) {
  return function(u) {
    return u.lift(new RepeatWhenOperator(a));
  };
}
var RepeatWhenOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RepeatWhenSubscriber(u, this.notifier, c));
  }, a;
}(), RepeatWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.notifier = l, S.source = v, S.sourceIsBeingSubscribedTo = !0, S;
  }
  return u.prototype.notifyNext = function() {
    this.sourceIsBeingSubscribedTo = !0, this.source.subscribe(this);
  }, u.prototype.notifyComplete = function() {
    if (this.sourceIsBeingSubscribedTo === !1)
      return a.prototype.complete.call(this);
  }, u.prototype.complete = function() {
    if (this.sourceIsBeingSubscribedTo = !1, !this.isStopped) {
      if (this.retries || this.subscribeToRetries(), !this.retriesSubscription || this.retriesSubscription.closed)
        return a.prototype.complete.call(this);
      this._unsubscribeAndRecycle(), this.notifications.next(void 0);
    }
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.notifications, v = c.retriesSubscription;
    l && (l.unsubscribe(), this.notifications = void 0), v && (v.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, u.prototype._unsubscribeAndRecycle = function() {
    var c = this._unsubscribe;
    return this._unsubscribe = null, a.prototype._unsubscribeAndRecycle.call(this), this._unsubscribe = c, this;
  }, u.prototype.subscribeToRetries = function() {
    this.notifications = new Subject();
    var c;
    try {
      var l = this.notifier;
      c = l(this.notifications);
    } catch {
      return a.prototype.complete.call(this);
    }
    this.retries = c, this.retriesSubscription = innerSubscribe(c, new SimpleInnerSubscriber(this));
  }, u;
}(SimpleOuterSubscriber);
function retry(a) {
  return a === void 0 && (a = -1), function(u) {
    return u.lift(new RetryOperator(a, u));
  };
}
var RetryOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.count = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RetrySubscriber(u, this.count, this.source));
  }, a;
}(), RetrySubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.count = l, S.source = v, S;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this, v = l.source, S = l.count;
      if (S === 0)
        return a.prototype.error.call(this, c);
      S > -1 && (this.count = S - 1), v.subscribe(this._unsubscribeAndRecycle());
    }
  }, u;
}(Subscriber);
function retryWhen(a) {
  return function(u) {
    return u.lift(new RetryWhenOperator(a, u));
  };
}
var RetryWhenOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.notifier = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new RetryWhenSubscriber(u, this.notifier, this.source));
  }, a;
}(), RetryWhenSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.notifier = l, S.source = v, S;
  }
  return u.prototype.error = function(c) {
    if (!this.isStopped) {
      var l = this.errors, v = this.retries, S = this.retriesSubscription;
      if (v)
        this.errors = void 0, this.retriesSubscription = void 0;
      else {
        l = new Subject();
        try {
          var g = this.notifier;
          v = g(l);
        } catch (E) {
          return a.prototype.error.call(this, E);
        }
        S = innerSubscribe(v, new SimpleInnerSubscriber(this));
      }
      this._unsubscribeAndRecycle(), this.errors = l, this.retries = v, this.retriesSubscription = S, l.next(c);
    }
  }, u.prototype._unsubscribe = function() {
    var c = this, l = c.errors, v = c.retriesSubscription;
    l && (l.unsubscribe(), this.errors = void 0), v && (v.unsubscribe(), this.retriesSubscription = void 0), this.retries = void 0;
  }, u.prototype.notifyNext = function() {
    var c = this._unsubscribe;
    this._unsubscribe = null, this._unsubscribeAndRecycle(), this._unsubscribe = c, this.source.subscribe(this);
  }, u;
}(SimpleOuterSubscriber);
function sample(a) {
  return function(u) {
    return u.lift(new SampleOperator(a));
  };
}
var SampleOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new SampleSubscriber(u), v = c.subscribe(l);
    return v.add(innerSubscribe(this.notifier, new SimpleInnerSubscriber(l))), v;
  }, a;
}(), SampleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c.hasValue = !1, c;
  }
  return u.prototype._next = function(c) {
    this.value = c, this.hasValue = !0;
  }, u.prototype.notifyNext = function() {
    this.emitValue();
  }, u.prototype.notifyComplete = function() {
    this.emitValue();
  }, u.prototype.emitValue = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.value));
  }, u;
}(SimpleOuterSubscriber);
function sampleTime(a, u) {
  return u === void 0 && (u = async), function(c) {
    return c.lift(new SampleTimeOperator(a, u));
  };
}
var SampleTimeOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.period = u, this.scheduler = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SampleTimeSubscriber(u, this.period, this.scheduler));
  }, a;
}(), SampleTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.period = l, S.scheduler = v, S.hasValue = !1, S.add(v.schedule(dispatchNotification, l, { subscriber: S, period: l })), S;
  }
  return u.prototype._next = function(c) {
    this.lastValue = c, this.hasValue = !0;
  }, u.prototype.notifyNext = function() {
    this.hasValue && (this.hasValue = !1, this.destination.next(this.lastValue));
  }, u;
}(Subscriber);
function dispatchNotification(a) {
  var u = a.subscriber, c = a.period;
  u.notifyNext(), this.schedule(a, c);
}
function sequenceEqual(a, u) {
  return function(c) {
    return c.lift(new SequenceEqualOperator(a, u));
  };
}
var SequenceEqualOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.compareTo = u, this.comparator = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SequenceEqualSubscriber(u, this.compareTo, this.comparator));
  }, a;
}(), SequenceEqualSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.compareTo = l, S.comparator = v, S._a = [], S._b = [], S._oneComplete = !1, S.destination.add(l.subscribe(new SequenceEqualCompareToSubscriber(c, S))), S;
  }
  return u.prototype._next = function(c) {
    this._oneComplete && this._b.length === 0 ? this.emit(!1) : (this._a.push(c), this.checkValues());
  }, u.prototype._complete = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0, this.unsubscribe();
  }, u.prototype.checkValues = function() {
    for (var c = this, l = c._a, v = c._b, S = c.comparator; l.length > 0 && v.length > 0; ) {
      var g = l.shift(), E = v.shift(), _ = !1;
      try {
        _ = S ? S(g, E) : g === E;
      } catch (k) {
        this.destination.error(k);
      }
      _ || this.emit(!1);
    }
  }, u.prototype.emit = function(c) {
    var l = this.destination;
    l.next(c), l.complete();
  }, u.prototype.nextB = function(c) {
    this._oneComplete && this._a.length === 0 ? this.emit(!1) : (this._b.push(c), this.checkValues());
  }, u.prototype.completeB = function() {
    this._oneComplete ? this.emit(this._a.length === 0 && this._b.length === 0) : this._oneComplete = !0;
  }, u;
}(Subscriber), SequenceEqualCompareToSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.parent = l, v;
  }
  return u.prototype._next = function(c) {
    this.parent.nextB(c);
  }, u.prototype._error = function(c) {
    this.parent.error(c), this.unsubscribe();
  }, u.prototype._complete = function() {
    this.parent.completeB(), this.unsubscribe();
  }, u;
}(Subscriber);
function shareSubjectFactory() {
  return new Subject();
}
function share() {
  return function(a) {
    return refCount()(multicast(shareSubjectFactory)(a));
  };
}
function shareReplay(a, u, c) {
  var l;
  return a && typeof a == "object" ? l = a : l = {
    bufferSize: a,
    windowTime: u,
    refCount: !1,
    scheduler: c
  }, function(v) {
    return v.lift(shareReplayOperator(l));
  };
}
function shareReplayOperator(a) {
  var u = a.bufferSize, c = u === void 0 ? Number.POSITIVE_INFINITY : u, l = a.windowTime, v = l === void 0 ? Number.POSITIVE_INFINITY : l, S = a.refCount, g = a.scheduler, E, _ = 0, k, L = !1, M = !1;
  return function(J) {
    _++;
    var V;
    !E || L ? (L = !1, E = new ReplaySubject(c, v, g), V = E.subscribe(this), k = J.subscribe({
      next: function(q) {
        E.next(q);
      },
      error: function(q) {
        L = !0, E.error(q);
      },
      complete: function() {
        M = !0, k = void 0, E.complete();
      }
    }), M && (k = void 0)) : V = E.subscribe(this), this.add(function() {
      _--, V.unsubscribe(), V = void 0, k && !M && S && _ === 0 && (k.unsubscribe(), k = void 0, E = void 0);
    });
  };
}
function single(a) {
  return function(u) {
    return u.lift(new SingleOperator(a, u));
  };
}
var SingleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.source = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SingleSubscriber(u, this.predicate, this.source));
  }, a;
}(), SingleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.predicate = l, S.source = v, S.seenValue = !1, S.index = 0, S;
  }
  return u.prototype.applySingleValue = function(c) {
    this.seenValue ? this.destination.error("Sequence contains more than one element") : (this.seenValue = !0, this.singleValue = c);
  }, u.prototype._next = function(c) {
    var l = this.index++;
    this.predicate ? this.tryNext(c, l) : this.applySingleValue(c);
  }, u.prototype.tryNext = function(c, l) {
    try {
      this.predicate(c, l, this.source) && this.applySingleValue(c);
    } catch (v) {
      this.destination.error(v);
    }
  }, u.prototype._complete = function() {
    var c = this.destination;
    this.index > 0 ? (c.next(this.seenValue ? this.singleValue : void 0), c.complete()) : c.error(new EmptyError());
  }, u;
}(Subscriber);
function skip(a) {
  return function(u) {
    return u.lift(new SkipOperator(a));
  };
}
var SkipOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.total = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipSubscriber(u, this.total));
  }, a;
}(), SkipSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.total = l, v.count = 0, v;
  }
  return u.prototype._next = function(c) {
    ++this.count > this.total && this.destination.next(c);
  }, u;
}(Subscriber);
function skipLast(a) {
  return function(u) {
    return u.lift(new SkipLastOperator(a));
  };
}
var SkipLastOperator = /* @__PURE__ */ function() {
  function a(u) {
    if (this._skipCount = u, this._skipCount < 0)
      throw new ArgumentOutOfRangeError();
  }
  return a.prototype.call = function(u, c) {
    return this._skipCount === 0 ? c.subscribe(new Subscriber(u)) : c.subscribe(new SkipLastSubscriber(u, this._skipCount));
  }, a;
}(), SkipLastSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v._skipCount = l, v._count = 0, v._ring = new Array(l), v;
  }
  return u.prototype._next = function(c) {
    var l = this._skipCount, v = this._count++;
    if (v < l)
      this._ring[v] = c;
    else {
      var S = v % l, g = this._ring, E = g[S];
      g[S] = c, this.destination.next(E);
    }
  }, u;
}(Subscriber);
function skipUntil(a) {
  return function(u) {
    return u.lift(new SkipUntilOperator(a));
  };
}
var SkipUntilOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipUntilSubscriber(u, this.notifier));
  }, a;
}(), SkipUntilSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    v.hasValue = !1;
    var S = new SimpleInnerSubscriber(v);
    v.add(S), v.innerSubscription = S;
    var g = innerSubscribe(l, S);
    return g !== S && (v.add(g), v.innerSubscription = g), v;
  }
  return u.prototype._next = function(c) {
    this.hasValue && a.prototype._next.call(this, c);
  }, u.prototype.notifyNext = function() {
    this.hasValue = !0, this.innerSubscription && this.innerSubscription.unsubscribe();
  }, u.prototype.notifyComplete = function() {
  }, u;
}(SimpleOuterSubscriber);
function skipWhile(a) {
  return function(u) {
    return u.lift(new SkipWhileOperator(a));
  };
}
var SkipWhileOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.predicate = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SkipWhileSubscriber(u, this.predicate));
  }, a;
}(), SkipWhileSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.predicate = l, v.skipping = !0, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    var l = this.destination;
    this.skipping && this.tryCallPredicate(c), this.skipping || l.next(c);
  }, u.prototype.tryCallPredicate = function(c) {
    try {
      var l = this.predicate(c, this.index++);
      this.skipping = !!l;
    } catch (v) {
      this.destination.error(v);
    }
  }, u;
}(Subscriber);
function startWith() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return isScheduler(c) ? (a.pop(), function(l) {
    return concat$1(a, l, c);
  }) : function(l) {
    return concat$1(a, l);
  };
}
var nextHandle = 1, RESOLVED = /* @__PURE__ */ function() {
  return /* @__PURE__ */ Promise.resolve();
}(), activeHandles = {};
function findAndClearHandle(a) {
  return a in activeHandles ? (delete activeHandles[a], !0) : !1;
}
var Immediate = {
  setImmediate: function(a) {
    var u = nextHandle++;
    return activeHandles[u] = !0, RESOLVED.then(function() {
      return findAndClearHandle(u) && a();
    }), u;
  },
  clearImmediate: function(a) {
    findAndClearHandle(a);
  }
}, AsapAction = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c, l) || this;
    return v.scheduler = c, v.work = l, v;
  }
  return u.prototype.requestAsyncId = function(c, l, v) {
    return v === void 0 && (v = 0), v !== null && v > 0 ? a.prototype.requestAsyncId.call(this, c, l, v) : (c.actions.push(this), c.scheduled || (c.scheduled = Immediate.setImmediate(c.flush.bind(c, null))));
  }, u.prototype.recycleAsyncId = function(c, l, v) {
    if (v === void 0 && (v = 0), v !== null && v > 0 || v === null && this.delay > 0)
      return a.prototype.recycleAsyncId.call(this, c, l, v);
    c.actions.length === 0 && (Immediate.clearImmediate(l), c.scheduled = void 0);
  }, u;
}(AsyncAction), AsapScheduler = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    return a !== null && a.apply(this, arguments) || this;
  }
  return u.prototype.flush = function(c) {
    this.active = !0, this.scheduled = void 0;
    var l = this.actions, v, S = -1, g = l.length;
    c = c || l.shift();
    do
      if (v = c.execute(c.state, c.delay))
        break;
    while (++S < g && (c = l.shift()));
    if (this.active = !1, v) {
      for (; ++S < g && (c = l.shift()); )
        c.unsubscribe();
      throw v;
    }
  }, u;
}(AsyncScheduler), asapScheduler = /* @__PURE__ */ new AsapScheduler(AsapAction), asap = asapScheduler, SubscribeOnObservable = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    l === void 0 && (l = 0), v === void 0 && (v = asap);
    var S = a.call(this) || this;
    return S.source = c, S.delayTime = l, S.scheduler = v, (!isNumeric(l) || l < 0) && (S.delayTime = 0), (!v || typeof v.schedule != "function") && (S.scheduler = asap), S;
  }
  return u.create = function(c, l, v) {
    return l === void 0 && (l = 0), v === void 0 && (v = asap), new u(c, l, v);
  }, u.dispatch = function(c) {
    var l = c.source, v = c.subscriber;
    return this.add(l.subscribe(v));
  }, u.prototype._subscribe = function(c) {
    var l = this.delayTime, v = this.source, S = this.scheduler;
    return S.schedule(u.dispatch, l, {
      source: v,
      subscriber: c
    });
  }, u;
}(Observable);
function subscribeOn(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new SubscribeOnOperator(a, u));
  };
}
var SubscribeOnOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.scheduler = u, this.delay = c;
  }
  return a.prototype.call = function(u, c) {
    return new SubscribeOnObservable(c, this.delay, this.scheduler).subscribe(u);
  }, a;
}();
function switchMap(a, u) {
  return typeof u == "function" ? function(c) {
    return c.pipe(switchMap(function(l, v) {
      return from(a(l, v)).pipe(map(function(S, g) {
        return u(l, S, v, g);
      }));
    }));
  } : function(c) {
    return c.lift(new SwitchMapOperator(a));
  };
}
var SwitchMapOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.project = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new SwitchMapSubscriber(u, this.project));
  }, a;
}(), SwitchMapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.project = l, v.index = 0, v;
  }
  return u.prototype._next = function(c) {
    var l, v = this.index++;
    try {
      l = this.project(c, v);
    } catch (S) {
      this.destination.error(S);
      return;
    }
    this._innerSub(l);
  }, u.prototype._innerSub = function(c) {
    var l = this.innerSubscription;
    l && l.unsubscribe();
    var v = new SimpleInnerSubscriber(this), S = this.destination;
    S.add(v), this.innerSubscription = innerSubscribe(c, v), this.innerSubscription !== v && S.add(this.innerSubscription);
  }, u.prototype._complete = function() {
    var c = this.innerSubscription;
    (!c || c.closed) && a.prototype._complete.call(this), this.unsubscribe();
  }, u.prototype._unsubscribe = function() {
    this.innerSubscription = void 0;
  }, u.prototype.notifyComplete = function() {
    this.innerSubscription = void 0, this.isStopped && a.prototype._complete.call(this);
  }, u.prototype.notifyNext = function(c) {
    this.destination.next(c);
  }, u;
}(SimpleOuterSubscriber);
function switchAll() {
  return switchMap(identity);
}
function switchMapTo(a, u) {
  return u ? switchMap(function() {
    return a;
  }, u) : switchMap(function() {
    return a;
  });
}
function takeUntil(a) {
  return function(u) {
    return u.lift(new TakeUntilOperator(a));
  };
}
var TakeUntilOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.notifier = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new TakeUntilSubscriber(u), v = innerSubscribe(this.notifier, new SimpleInnerSubscriber(l));
    return v && !l.seenValue ? (l.add(v), c.subscribe(l)) : l;
  }, a;
}(), TakeUntilSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.seenValue = !1, l;
  }
  return u.prototype.notifyNext = function() {
    this.seenValue = !0, this.complete();
  }, u.prototype.notifyComplete = function() {
  }, u;
}(SimpleOuterSubscriber);
function takeWhile(a, u) {
  return u === void 0 && (u = !1), function(c) {
    return c.lift(new TakeWhileOperator(a, u));
  };
}
var TakeWhileOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.predicate = u, this.inclusive = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TakeWhileSubscriber(u, this.predicate, this.inclusive));
  }, a;
}(), TakeWhileSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.predicate = l, S.inclusive = v, S.index = 0, S;
  }
  return u.prototype._next = function(c) {
    var l = this.destination, v;
    try {
      v = this.predicate(c, this.index++);
    } catch (S) {
      l.error(S);
      return;
    }
    this.nextOrComplete(c, v);
  }, u.prototype.nextOrComplete = function(c, l) {
    var v = this.destination;
    l ? v.next(c) : (this.inclusive && v.next(c), v.complete());
  }, u;
}(Subscriber);
function noop$1() {
}
function tap(a, u, c) {
  return function(v) {
    return v.lift(new DoOperator(a, u, c));
  };
}
var DoOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.nextOrObserver = u, this.error = c, this.complete = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TapSubscriber(u, this.nextOrObserver, this.error, this.complete));
  }, a;
}(), TapSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, S) {
    var g = a.call(this, c) || this;
    return g._tapNext = noop$1, g._tapError = noop$1, g._tapComplete = noop$1, g._tapError = v || noop$1, g._tapComplete = S || noop$1, isFunction$2(l) ? (g._context = g, g._tapNext = l) : l && (g._context = l, g._tapNext = l.next || noop$1, g._tapError = l.error || noop$1, g._tapComplete = l.complete || noop$1), g;
  }
  return u.prototype._next = function(c) {
    try {
      this._tapNext.call(this._context, c);
    } catch (l) {
      this.destination.error(l);
      return;
    }
    this.destination.next(c);
  }, u.prototype._error = function(c) {
    try {
      this._tapError.call(this._context, c);
    } catch (l) {
      this.destination.error(l);
      return;
    }
    this.destination.error(c);
  }, u.prototype._complete = function() {
    try {
      this._tapComplete.call(this._context);
    } catch (c) {
      this.destination.error(c);
      return;
    }
    return this.destination.complete();
  }, u;
}(Subscriber), defaultThrottleConfig = {
  leading: !0,
  trailing: !1
};
function throttle(a, u) {
  return u === void 0 && (u = defaultThrottleConfig), function(c) {
    return c.lift(new ThrottleOperator(a, !!u.leading, !!u.trailing));
  };
}
var ThrottleOperator = /* @__PURE__ */ function() {
  function a(u, c, l) {
    this.durationSelector = u, this.leading = c, this.trailing = l;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrottleSubscriber(u, this.durationSelector, this.leading, this.trailing));
  }, a;
}(), ThrottleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, S) {
    var g = a.call(this, c) || this;
    return g.destination = c, g.durationSelector = l, g._leading = v, g._trailing = S, g._hasValue = !1, g;
  }
  return u.prototype._next = function(c) {
    this._hasValue = !0, this._sendValue = c, this._throttled || (this._leading ? this.send() : this.throttle(c));
  }, u.prototype.send = function() {
    var c = this, l = c._hasValue, v = c._sendValue;
    l && (this.destination.next(v), this.throttle(v)), this._hasValue = !1, this._sendValue = void 0;
  }, u.prototype.throttle = function(c) {
    var l = this.tryDurationSelector(c);
    l && this.add(this._throttled = innerSubscribe(l, new SimpleInnerSubscriber(this)));
  }, u.prototype.tryDurationSelector = function(c) {
    try {
      return this.durationSelector(c);
    } catch (l) {
      return this.destination.error(l), null;
    }
  }, u.prototype.throttlingDone = function() {
    var c = this, l = c._throttled, v = c._trailing;
    l && l.unsubscribe(), this._throttled = void 0, v && this.send();
  }, u.prototype.notifyNext = function() {
    this.throttlingDone();
  }, u.prototype.notifyComplete = function() {
    this.throttlingDone();
  }, u;
}(SimpleOuterSubscriber);
function throttleTime(a, u, c) {
  return u === void 0 && (u = async), c === void 0 && (c = defaultThrottleConfig), function(l) {
    return l.lift(new ThrottleTimeOperator(a, u, c.leading, c.trailing));
  };
}
var ThrottleTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.duration = u, this.scheduler = c, this.leading = l, this.trailing = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ThrottleTimeSubscriber(u, this.duration, this.scheduler, this.leading, this.trailing));
  }, a;
}(), ThrottleTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, S, g) {
    var E = a.call(this, c) || this;
    return E.duration = l, E.scheduler = v, E.leading = S, E.trailing = g, E._hasTrailingValue = !1, E._trailingValue = null, E;
  }
  return u.prototype._next = function(c) {
    this.throttled ? this.trailing && (this._trailingValue = c, this._hasTrailingValue = !0) : (this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this })), this.leading ? this.destination.next(c) : this.trailing && (this._trailingValue = c, this._hasTrailingValue = !0));
  }, u.prototype._complete = function() {
    this._hasTrailingValue ? (this.destination.next(this._trailingValue), this.destination.complete()) : this.destination.complete();
  }, u.prototype.clearThrottle = function() {
    var c = this.throttled;
    c && (this.trailing && this._hasTrailingValue && (this.destination.next(this._trailingValue), this._trailingValue = null, this._hasTrailingValue = !1), c.unsubscribe(), this.remove(c), this.throttled = null);
  }, u;
}(Subscriber);
function dispatchNext(a) {
  var u = a.subscriber;
  u.clearThrottle();
}
function defer(a) {
  return new Observable(function(u) {
    var c;
    try {
      c = a();
    } catch (v) {
      u.error(v);
      return;
    }
    var l = c ? from(c) : empty$1();
    return l.subscribe(u);
  });
}
function timeInterval(a) {
  return a === void 0 && (a = async), function(u) {
    return defer(function() {
      return u.pipe(scan(function(c, l) {
        var v = c.current;
        return { value: l, current: a.now(), last: v };
      }, { current: a.now(), value: void 0, last: void 0 }), map(function(c) {
        var l = c.current, v = c.last, S = c.value;
        return new TimeInterval(S, l - v);
      }));
    });
  };
}
var TimeInterval = /* @__PURE__ */ function() {
  function a(u, c) {
    this.value = u, this.interval = c;
  }
  return a;
}(), TimeoutErrorImpl = /* @__PURE__ */ function() {
  function a() {
    return Error.call(this), this.message = "Timeout has occurred", this.name = "TimeoutError", this;
  }
  return a.prototype = /* @__PURE__ */ Object.create(Error.prototype), a;
}(), TimeoutError = TimeoutErrorImpl;
function timeoutWith(a, u, c) {
  return c === void 0 && (c = async), function(l) {
    var v = isDate$1(a), S = v ? +a - c.now() : Math.abs(a);
    return l.lift(new TimeoutWithOperator(S, v, u, c));
  };
}
var TimeoutWithOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.waitFor = u, this.absoluteTimeout = c, this.withObservable = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new TimeoutWithSubscriber(u, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  }, a;
}(), TimeoutWithSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, S, g) {
    var E = a.call(this, c) || this;
    return E.absoluteTimeout = l, E.waitFor = v, E.withObservable = S, E.scheduler = g, E.scheduleTimeout(), E;
  }
  return u.dispatchTimeout = function(c) {
    var l = c.withObservable;
    c._unsubscribeAndRecycle(), c.add(innerSubscribe(l, new SimpleInnerSubscriber(c)));
  }, u.prototype.scheduleTimeout = function() {
    var c = this.action;
    c ? this.action = c.schedule(this, this.waitFor) : this.add(this.action = this.scheduler.schedule(u.dispatchTimeout, this.waitFor, this));
  }, u.prototype._next = function(c) {
    this.absoluteTimeout || this.scheduleTimeout(), a.prototype._next.call(this, c);
  }, u.prototype._unsubscribe = function() {
    this.action = void 0, this.scheduler = null, this.withObservable = null;
  }, u;
}(SimpleOuterSubscriber);
function timeout(a, u) {
  return u === void 0 && (u = async), timeoutWith(a, throwError(new TimeoutError()), u);
}
function timestamp$1(a) {
  return a === void 0 && (a = async), map(function(u) {
    return new Timestamp$1(u, a.now());
  });
}
var Timestamp$1 = /* @__PURE__ */ function() {
  function a(u, c) {
    this.value = u, this.timestamp = c;
  }
  return a;
}();
function toArrayReducer(a, u, c) {
  return c === 0 ? [u] : (a.push(u), a);
}
function toArray() {
  return reduce(toArrayReducer, []);
}
function window$1(a) {
  return function(c) {
    return c.lift(new WindowOperator$1(a));
  };
}
var WindowOperator$1 = /* @__PURE__ */ function() {
  function a(u) {
    this.windowBoundaries = u;
  }
  return a.prototype.call = function(u, c) {
    var l = new WindowSubscriber$1(u), v = c.subscribe(l);
    return v.closed || l.add(innerSubscribe(this.windowBoundaries, new SimpleInnerSubscriber(l))), v;
  }, a;
}(), WindowSubscriber$1 = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c) {
    var l = a.call(this, c) || this;
    return l.window = new Subject(), c.next(l.window), l;
  }
  return u.prototype.notifyNext = function() {
    this.openWindow();
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype.notifyComplete = function() {
    this._complete();
  }, u.prototype._next = function(c) {
    this.window.next(c);
  }, u.prototype._error = function(c) {
    this.window.error(c), this.destination.error(c);
  }, u.prototype._complete = function() {
    this.window.complete(), this.destination.complete();
  }, u.prototype._unsubscribe = function() {
    this.window = null;
  }, u.prototype.openWindow = function() {
    var c = this.window;
    c && c.complete();
    var l = this.destination, v = this.window = new Subject();
    l.next(v);
  }, u;
}(SimpleOuterSubscriber);
function windowCount(a, u) {
  return u === void 0 && (u = 0), function(l) {
    return l.lift(new WindowCountOperator(a, u));
  };
}
var WindowCountOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.windowSize = u, this.startWindowEvery = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowCountSubscriber(u, this.windowSize, this.startWindowEvery));
  }, a;
}(), WindowCountSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.destination = c, S.windowSize = l, S.startWindowEvery = v, S.windows = [new Subject()], S.count = 0, c.next(S.windows[0]), S;
  }
  return u.prototype._next = function(c) {
    for (var l = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize, v = this.destination, S = this.windowSize, g = this.windows, E = g.length, _ = 0; _ < E && !this.closed; _++)
      g[_].next(c);
    var k = this.count - S + 1;
    if (k >= 0 && k % l === 0 && !this.closed && g.shift().complete(), ++this.count % l === 0 && !this.closed) {
      var L = new Subject();
      g.push(L), v.next(L);
    }
  }, u.prototype._error = function(c) {
    var l = this.windows;
    if (l)
      for (; l.length > 0 && !this.closed; )
        l.shift().error(c);
    this.destination.error(c);
  }, u.prototype._complete = function() {
    var c = this.windows;
    if (c)
      for (; c.length > 0 && !this.closed; )
        c.shift().complete();
    this.destination.complete();
  }, u.prototype._unsubscribe = function() {
    this.count = 0, this.windows = null;
  }, u;
}(Subscriber);
function windowTime(a) {
  var u = async, c = null, l = Number.POSITIVE_INFINITY;
  return isScheduler(arguments[3]) && (u = arguments[3]), isScheduler(arguments[2]) ? u = arguments[2] : isNumeric(arguments[2]) && (l = Number(arguments[2])), isScheduler(arguments[1]) ? u = arguments[1] : isNumeric(arguments[1]) && (c = Number(arguments[1])), function(S) {
    return S.lift(new WindowTimeOperator(a, c, l, u));
  };
}
var WindowTimeOperator = /* @__PURE__ */ function() {
  function a(u, c, l, v) {
    this.windowTimeSpan = u, this.windowCreationInterval = c, this.maxWindowSize = l, this.scheduler = v;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowTimeSubscriber(u, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
  }, a;
}(), CountedSubject = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u() {
    var c = a !== null && a.apply(this, arguments) || this;
    return c._numberOfNextedValues = 0, c;
  }
  return u.prototype.next = function(c) {
    this._numberOfNextedValues++, a.prototype.next.call(this, c);
  }, Object.defineProperty(u.prototype, "numberOfNextedValues", {
    get: function() {
      return this._numberOfNextedValues;
    },
    enumerable: !0,
    configurable: !0
  }), u;
}(Subject), WindowTimeSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v, S, g) {
    var E = a.call(this, c) || this;
    E.destination = c, E.windowTimeSpan = l, E.windowCreationInterval = v, E.maxWindowSize = S, E.scheduler = g, E.windows = [];
    var _ = E.openWindow();
    if (v !== null && v >= 0) {
      var k = { subscriber: E, window: _, context: null }, L = { windowTimeSpan: l, windowCreationInterval: v, subscriber: E, scheduler: g };
      E.add(g.schedule(dispatchWindowClose, l, k)), E.add(g.schedule(dispatchWindowCreation, v, L));
    } else {
      var M = { subscriber: E, window: _, windowTimeSpan: l };
      E.add(g.schedule(dispatchWindowTimeSpanOnly, l, M));
    }
    return E;
  }
  return u.prototype._next = function(c) {
    for (var l = this.windows, v = l.length, S = 0; S < v; S++) {
      var g = l[S];
      g.closed || (g.next(c), g.numberOfNextedValues >= this.maxWindowSize && this.closeWindow(g));
    }
  }, u.prototype._error = function(c) {
    for (var l = this.windows; l.length > 0; )
      l.shift().error(c);
    this.destination.error(c);
  }, u.prototype._complete = function() {
    for (var c = this.windows; c.length > 0; ) {
      var l = c.shift();
      l.closed || l.complete();
    }
    this.destination.complete();
  }, u.prototype.openWindow = function() {
    var c = new CountedSubject();
    this.windows.push(c);
    var l = this.destination;
    return l.next(c), c;
  }, u.prototype.closeWindow = function(c) {
    c.complete();
    var l = this.windows;
    l.splice(l.indexOf(c), 1);
  }, u;
}(Subscriber);
function dispatchWindowTimeSpanOnly(a) {
  var u = a.subscriber, c = a.windowTimeSpan, l = a.window;
  l && u.closeWindow(l), a.window = u.openWindow(), this.schedule(a, c);
}
function dispatchWindowCreation(a) {
  var u = a.windowTimeSpan, c = a.subscriber, l = a.scheduler, v = a.windowCreationInterval, S = c.openWindow(), g = this, E = { action: g, subscription: null }, _ = { subscriber: c, window: S, context: E };
  E.subscription = l.schedule(dispatchWindowClose, u, _), g.add(E.subscription), g.schedule(a, v);
}
function dispatchWindowClose(a) {
  var u = a.subscriber, c = a.window, l = a.context;
  l && l.action && l.subscription && l.action.remove(l.subscription), u.closeWindow(c);
}
function windowToggle(a, u) {
  return function(c) {
    return c.lift(new WindowToggleOperator(a, u));
  };
}
var WindowToggleOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.openings = u, this.closingSelector = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowToggleSubscriber(u, this.openings, this.closingSelector));
  }, a;
}(), WindowToggleSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.openings = l, S.closingSelector = v, S.contexts = [], S.add(S.openSubscription = subscribeToResult(S, l, l)), S;
  }
  return u.prototype._next = function(c) {
    var l = this.contexts;
    if (l)
      for (var v = l.length, S = 0; S < v; S++)
        l[S].window.next(c);
  }, u.prototype._error = function(c) {
    var l = this.contexts;
    if (this.contexts = null, l)
      for (var v = l.length, S = -1; ++S < v; ) {
        var g = l[S];
        g.window.error(c), g.subscription.unsubscribe();
      }
    a.prototype._error.call(this, c);
  }, u.prototype._complete = function() {
    var c = this.contexts;
    if (this.contexts = null, c)
      for (var l = c.length, v = -1; ++v < l; ) {
        var S = c[v];
        S.window.complete(), S.subscription.unsubscribe();
      }
    a.prototype._complete.call(this);
  }, u.prototype._unsubscribe = function() {
    var c = this.contexts;
    if (this.contexts = null, c)
      for (var l = c.length, v = -1; ++v < l; ) {
        var S = c[v];
        S.window.unsubscribe(), S.subscription.unsubscribe();
      }
  }, u.prototype.notifyNext = function(c, l, v, S, g) {
    if (c === this.openings) {
      var E = void 0;
      try {
        var _ = this.closingSelector;
        E = _(l);
      } catch (J) {
        return this.error(J);
      }
      var k = new Subject(), L = new Subscription(), M = { window: k, subscription: L };
      this.contexts.push(M);
      var $ = subscribeToResult(this, E, M);
      $.closed ? this.closeWindow(this.contexts.length - 1) : ($.context = M, L.add($)), this.destination.next(k);
    } else
      this.closeWindow(this.contexts.indexOf(c));
  }, u.prototype.notifyError = function(c) {
    this.error(c);
  }, u.prototype.notifyComplete = function(c) {
    c !== this.openSubscription && this.closeWindow(this.contexts.indexOf(c.context));
  }, u.prototype.closeWindow = function(c) {
    if (c !== -1) {
      var l = this.contexts, v = l[c], S = v.window, g = v.subscription;
      l.splice(c, 1), S.complete(), g.unsubscribe();
    }
  }, u;
}(OuterSubscriber);
function windowWhen(a) {
  return function(c) {
    return c.lift(new WindowOperator(a));
  };
}
var WindowOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.closingSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WindowSubscriber(u, this.closingSelector));
  }, a;
}(), WindowSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l) {
    var v = a.call(this, c) || this;
    return v.destination = c, v.closingSelector = l, v.openWindow(), v;
  }
  return u.prototype.notifyNext = function(c, l, v, S, g) {
    this.openWindow(g);
  }, u.prototype.notifyError = function(c) {
    this._error(c);
  }, u.prototype.notifyComplete = function(c) {
    this.openWindow(c);
  }, u.prototype._next = function(c) {
    this.window.next(c);
  }, u.prototype._error = function(c) {
    this.window.error(c), this.destination.error(c), this.unsubscribeClosingNotification();
  }, u.prototype._complete = function() {
    this.window.complete(), this.destination.complete(), this.unsubscribeClosingNotification();
  }, u.prototype.unsubscribeClosingNotification = function() {
    this.closingNotification && this.closingNotification.unsubscribe();
  }, u.prototype.openWindow = function(c) {
    c === void 0 && (c = null), c && (this.remove(c), c.unsubscribe());
    var l = this.window;
    l && l.complete();
    var v = this.window = new Subject();
    this.destination.next(v);
    var S;
    try {
      var g = this.closingSelector;
      S = g();
    } catch (E) {
      this.destination.error(E), this.window.error(E);
      return;
    }
    this.add(this.closingNotification = subscribeToResult(this, S));
  }, u;
}(OuterSubscriber);
function withLatestFrom() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(c) {
    var l;
    typeof a[a.length - 1] == "function" && (l = a.pop());
    var v = a;
    return c.lift(new WithLatestFromOperator(v, l));
  };
}
var WithLatestFromOperator = /* @__PURE__ */ function() {
  function a(u, c) {
    this.observables = u, this.project = c;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new WithLatestFromSubscriber(u, this.observables, this.project));
  }, a;
}(), WithLatestFromSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    S.observables = l, S.project = v, S.toRespond = [];
    var g = l.length;
    S.values = new Array(g);
    for (var E = 0; E < g; E++)
      S.toRespond.push(E);
    for (var E = 0; E < g; E++) {
      var _ = l[E];
      S.add(subscribeToResult(S, _, void 0, E));
    }
    return S;
  }
  return u.prototype.notifyNext = function(c, l, v) {
    this.values[v] = l;
    var S = this.toRespond;
    if (S.length > 0) {
      var g = S.indexOf(v);
      g !== -1 && S.splice(g, 1);
    }
  }, u.prototype.notifyComplete = function() {
  }, u.prototype._next = function(c) {
    if (this.toRespond.length === 0) {
      var l = [c].concat(this.values);
      this.project ? this._tryProject(l) : this.destination.next(l);
    }
  }, u.prototype._tryProject = function(c) {
    var l;
    try {
      l = this.project.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(OuterSubscriber);
function zip$1() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  var c = a[a.length - 1];
  return typeof c == "function" && a.pop(), fromArray(a, void 0).lift(new ZipOperator(c));
}
var ZipOperator = /* @__PURE__ */ function() {
  function a(u) {
    this.resultSelector = u;
  }
  return a.prototype.call = function(u, c) {
    return c.subscribe(new ZipSubscriber(u, this.resultSelector));
  }, a;
}(), ZipSubscriber = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.resultSelector = l, S.iterators = [], S.active = 0, S.resultSelector = typeof l == "function" ? l : void 0, S;
  }
  return u.prototype._next = function(c) {
    var l = this.iterators;
    isArray$4(c) ? l.push(new StaticArrayIterator(c)) : typeof c[iterator] == "function" ? l.push(new StaticIterator(c[iterator]())) : l.push(new ZipBufferIterator(this.destination, this, c));
  }, u.prototype._complete = function() {
    var c = this.iterators, l = c.length;
    if (this.unsubscribe(), l === 0) {
      this.destination.complete();
      return;
    }
    this.active = l;
    for (var v = 0; v < l; v++) {
      var S = c[v];
      if (S.stillUnsubscribed) {
        var g = this.destination;
        g.add(S.subscribe());
      } else
        this.active--;
    }
  }, u.prototype.notifyInactive = function() {
    this.active--, this.active === 0 && this.destination.complete();
  }, u.prototype.checkIterators = function() {
    for (var c = this.iterators, l = c.length, v = this.destination, S = 0; S < l; S++) {
      var g = c[S];
      if (typeof g.hasValue == "function" && !g.hasValue())
        return;
    }
    for (var E = !1, _ = [], S = 0; S < l; S++) {
      var g = c[S], k = g.next();
      if (g.hasCompleted() && (E = !0), k.done) {
        v.complete();
        return;
      }
      _.push(k.value);
    }
    this.resultSelector ? this._tryresultSelector(_) : v.next(_), E && v.complete();
  }, u.prototype._tryresultSelector = function(c) {
    var l;
    try {
      l = this.resultSelector.apply(this, c);
    } catch (v) {
      this.destination.error(v);
      return;
    }
    this.destination.next(l);
  }, u;
}(Subscriber), StaticIterator = /* @__PURE__ */ function() {
  function a(u) {
    this.iterator = u, this.nextResult = u.next();
  }
  return a.prototype.hasValue = function() {
    return !0;
  }, a.prototype.next = function() {
    var u = this.nextResult;
    return this.nextResult = this.iterator.next(), u;
  }, a.prototype.hasCompleted = function() {
    var u = this.nextResult;
    return !!(u && u.done);
  }, a;
}(), StaticArrayIterator = /* @__PURE__ */ function() {
  function a(u) {
    this.array = u, this.index = 0, this.length = 0, this.length = u.length;
  }
  return a.prototype[iterator] = function() {
    return this;
  }, a.prototype.next = function(u) {
    var c = this.index++, l = this.array;
    return c < this.length ? { value: l[c], done: !1 } : { value: null, done: !0 };
  }, a.prototype.hasValue = function() {
    return this.array.length > this.index;
  }, a.prototype.hasCompleted = function() {
    return this.array.length === this.index;
  }, a;
}(), ZipBufferIterator = /* @__PURE__ */ function(a) {
  __extends(u, a);
  function u(c, l, v) {
    var S = a.call(this, c) || this;
    return S.parent = l, S.observable = v, S.stillUnsubscribed = !0, S.buffer = [], S.isComplete = !1, S;
  }
  return u.prototype[iterator] = function() {
    return this;
  }, u.prototype.next = function() {
    var c = this.buffer;
    return c.length === 0 && this.isComplete ? { value: null, done: !0 } : { value: c.shift(), done: !1 };
  }, u.prototype.hasValue = function() {
    return this.buffer.length > 0;
  }, u.prototype.hasCompleted = function() {
    return this.buffer.length === 0 && this.isComplete;
  }, u.prototype.notifyComplete = function() {
    this.buffer.length > 0 ? (this.isComplete = !0, this.parent.notifyInactive()) : this.destination.complete();
  }, u.prototype.notifyNext = function(c) {
    this.buffer.push(c), this.parent.checkIterators();
  }, u.prototype.subscribe = function() {
    return innerSubscribe(this.observable, new SimpleInnerSubscriber(this));
  }, u;
}(SimpleOuterSubscriber);
function zip() {
  for (var a = [], u = 0; u < arguments.length; u++)
    a[u] = arguments[u];
  return function(l) {
    return l.lift.call(zip$1.apply(void 0, [l].concat(a)));
  };
}
function zipAll(a) {
  return function(u) {
    return u.lift(new ZipOperator(a));
  };
}
const operators = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audit,
  auditTime,
  buffer,
  bufferCount,
  bufferTime,
  bufferToggle,
  bufferWhen,
  catchError,
  combineAll,
  combineLatest,
  concat,
  concatAll,
  concatMap,
  concatMapTo,
  count,
  debounce,
  debounceTime,
  defaultIfEmpty,
  delay,
  delayWhen,
  dematerialize,
  distinct,
  distinctUntilChanged,
  distinctUntilKeyChanged,
  elementAt,
  endWith,
  every,
  exhaust,
  exhaustMap,
  expand,
  filter,
  finalize,
  find: find$1,
  findIndex,
  first,
  flatMap,
  groupBy,
  ignoreElements,
  isEmpty,
  last,
  map,
  mapTo,
  materialize,
  max,
  merge: merge$1,
  mergeAll,
  mergeMap,
  mergeMapTo,
  mergeScan,
  min,
  multicast,
  observeOn,
  onErrorResumeNext,
  pairwise,
  partition,
  pluck,
  publish,
  publishBehavior,
  publishLast,
  publishReplay,
  race,
  reduce,
  refCount,
  repeat,
  repeatWhen,
  retry,
  retryWhen,
  sample,
  sampleTime,
  scan,
  sequenceEqual,
  share,
  shareReplay,
  single,
  skip,
  skipLast,
  skipUntil,
  skipWhile,
  startWith,
  subscribeOn,
  switchAll,
  switchMap,
  switchMapTo,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttle,
  throttleTime,
  throwIfEmpty,
  timeInterval,
  timeout,
  timeoutWith,
  timestamp: timestamp$1,
  toArray,
  window: window$1,
  windowCount,
  windowTime,
  windowToggle,
  windowWhen,
  withLatestFrom,
  zip,
  zipAll
}, Symbol.toStringTag, { value: "Module" })), require$$2 = /* @__PURE__ */ getAugmentedNamespace(operators);
var struct = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(B, Y, ne, Z) {
    Z === void 0 && (Z = ne), Object.defineProperty(B, Z, { enumerable: !0, get: function() {
      return Y[ne];
    } });
  } : function(B, Y, ne, Z) {
    Z === void 0 && (Z = ne), B[Z] = Y[ne];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(B, Y) {
    Object.defineProperty(B, "default", { enumerable: !0, value: Y });
  } : function(B, Y) {
    B.default = Y;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(B) {
    if (B && B.__esModule)
      return B;
    var Y = {};
    if (B != null)
      for (var ne in B)
        ne !== "default" && Object.hasOwnProperty.call(B, ne) && u(Y, B, ne);
    return c(Y, B), Y;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(B) {
    return B && B.__esModule ? B : { default: B };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ListValue = a.Value = a.Struct_FieldsEntry = a.Struct = a.nullValueToNumber = a.nullValueToJSON = a.nullValueFromJSON = a.NullValue = a.protobufPackage = void 0;
  const S = v(umdExports), g = l(minimal);
  a.protobufPackage = "google.protobuf";
  var E;
  (function(B) {
    B.NULL_VALUE = "NULL_VALUE";
  })(E = a.NullValue || (a.NullValue = {}));
  function _(B) {
    switch (B) {
      case 0:
      case "NULL_VALUE":
        return E.NULL_VALUE;
      default:
        throw new q.Error("Unrecognized enum value " + B + " for enum NullValue");
    }
  }
  a.nullValueFromJSON = _;
  function k(B) {
    switch (B) {
      case E.NULL_VALUE:
        return "NULL_VALUE";
      default:
        return "UNKNOWN";
    }
  }
  a.nullValueToJSON = k;
  function L(B) {
    switch (B) {
      case E.NULL_VALUE:
        return 0;
      default:
        return 0;
    }
  }
  a.nullValueToNumber = L;
  function M() {
    return { fields: {} };
  }
  a.Struct = {
    encode(B, Y = g.Writer.create()) {
      return Object.entries(B.fields).forEach(([ne, Z]) => {
        Z !== void 0 && a.Struct_FieldsEntry.encode({ key: ne, value: Z }, Y.uint32(10).fork()).ldelim();
      }), Y;
    },
    decode(B, Y) {
      const ne = B instanceof g.Reader ? B : new g.Reader(B);
      let Z = Y === void 0 ? ne.len : ne.pos + Y;
      const re = M();
      for (; ne.pos < Z; ) {
        const oe = ne.uint32();
        switch (oe >>> 3) {
          case 1:
            const de = a.Struct_FieldsEntry.decode(ne, ne.uint32());
            de.value !== void 0 && (re.fields[de.key] = de.value);
            break;
          default:
            ne.skipType(oe & 7);
            break;
        }
      }
      return re;
    },
    fromJSON(B) {
      return {
        fields: G(B.fields) ? Object.entries(B.fields).reduce((Y, [ne, Z]) => (Y[ne] = Z, Y), {}) : {}
      };
    },
    toJSON(B) {
      const Y = {};
      return Y.fields = {}, B.fields && Object.entries(B.fields).forEach(([ne, Z]) => {
        Y.fields[ne] = Z;
      }), Y;
    },
    fromPartial(B) {
      var Y;
      const ne = M();
      return ne.fields = Object.entries((Y = B.fields) !== null && Y !== void 0 ? Y : {}).reduce((Z, [re, oe]) => (oe !== void 0 && (Z[re] = oe), Z), {}), ne;
    },
    wrap(B) {
      const Y = M();
      return B !== void 0 && Object.keys(B).forEach((ne) => {
        Y.fields[ne] = B[ne];
      }), Y;
    },
    unwrap(B) {
      const Y = {};
      return Object.keys(B.fields).forEach((ne) => {
        Y[ne] = B.fields[ne];
      }), Y;
    }
  };
  function $() {
    return { key: "", value: void 0 };
  }
  a.Struct_FieldsEntry = {
    encode(B, Y = g.Writer.create()) {
      return B.key !== "" && Y.uint32(10).string(B.key), B.value !== void 0 && a.Value.encode(a.Value.wrap(B.value), Y.uint32(18).fork()).ldelim(), Y;
    },
    decode(B, Y) {
      const ne = B instanceof g.Reader ? B : new g.Reader(B);
      let Z = Y === void 0 ? ne.len : ne.pos + Y;
      const re = $();
      for (; ne.pos < Z; ) {
        const oe = ne.uint32();
        switch (oe >>> 3) {
          case 1:
            re.key = ne.string();
            break;
          case 2:
            re.value = a.Value.unwrap(a.Value.decode(ne, ne.uint32()));
            break;
          default:
            ne.skipType(oe & 7);
            break;
        }
      }
      return re;
    },
    fromJSON(B) {
      return {
        key: H(B.key) ? String(B.key) : "",
        value: H(B == null ? void 0 : B.value) ? B.value : void 0
      };
    },
    toJSON(B) {
      const Y = {};
      return B.key !== void 0 && (Y.key = B.key), B.value !== void 0 && (Y.value = B.value), Y;
    },
    fromPartial(B) {
      var Y, ne;
      const Z = $();
      return Z.key = (Y = B.key) !== null && Y !== void 0 ? Y : "", Z.value = (ne = B.value) !== null && ne !== void 0 ? ne : void 0, Z;
    }
  };
  function J() {
    return {
      nullValue: void 0,
      numberValue: void 0,
      stringValue: void 0,
      boolValue: void 0,
      structValue: void 0,
      listValue: void 0
    };
  }
  a.Value = {
    encode(B, Y = g.Writer.create()) {
      return B.nullValue !== void 0 && Y.uint32(8).int32(L(B.nullValue)), B.numberValue !== void 0 && Y.uint32(17).double(B.numberValue), B.stringValue !== void 0 && Y.uint32(26).string(B.stringValue), B.boolValue !== void 0 && Y.uint32(32).bool(B.boolValue), B.structValue !== void 0 && a.Struct.encode(a.Struct.wrap(B.structValue), Y.uint32(42).fork()).ldelim(), B.listValue !== void 0 && a.ListValue.encode(a.ListValue.wrap(B.listValue), Y.uint32(50).fork()).ldelim(), Y;
    },
    decode(B, Y) {
      const ne = B instanceof g.Reader ? B : new g.Reader(B);
      let Z = Y === void 0 ? ne.len : ne.pos + Y;
      const re = J();
      for (; ne.pos < Z; ) {
        const oe = ne.uint32();
        switch (oe >>> 3) {
          case 1:
            re.nullValue = _(ne.int32());
            break;
          case 2:
            re.numberValue = ne.double();
            break;
          case 3:
            re.stringValue = ne.string();
            break;
          case 4:
            re.boolValue = ne.bool();
            break;
          case 5:
            re.structValue = a.Struct.unwrap(a.Struct.decode(ne, ne.uint32()));
            break;
          case 6:
            re.listValue = a.ListValue.unwrap(a.ListValue.decode(ne, ne.uint32()));
            break;
          default:
            ne.skipType(oe & 7);
            break;
        }
      }
      return re;
    },
    fromJSON(B) {
      return {
        nullValue: H(B.nullValue) ? _(B.nullValue) : void 0,
        numberValue: H(B.numberValue) ? Number(B.numberValue) : void 0,
        stringValue: H(B.stringValue) ? String(B.stringValue) : void 0,
        boolValue: H(B.boolValue) ? !!B.boolValue : void 0,
        structValue: G(B.structValue) ? B.structValue : void 0,
        listValue: Array.isArray(B.listValue) ? [...B.listValue] : void 0
      };
    },
    toJSON(B) {
      const Y = {};
      return B.nullValue !== void 0 && (Y.nullValue = B.nullValue !== void 0 ? k(B.nullValue) : void 0), B.numberValue !== void 0 && (Y.numberValue = B.numberValue), B.stringValue !== void 0 && (Y.stringValue = B.stringValue), B.boolValue !== void 0 && (Y.boolValue = B.boolValue), B.structValue !== void 0 && (Y.structValue = B.structValue), B.listValue !== void 0 && (Y.listValue = B.listValue), Y;
    },
    fromPartial(B) {
      var Y, ne, Z, re, oe, de;
      const A = J();
      return A.nullValue = (Y = B.nullValue) !== null && Y !== void 0 ? Y : void 0, A.numberValue = (ne = B.numberValue) !== null && ne !== void 0 ? ne : void 0, A.stringValue = (Z = B.stringValue) !== null && Z !== void 0 ? Z : void 0, A.boolValue = (re = B.boolValue) !== null && re !== void 0 ? re : void 0, A.structValue = (oe = B.structValue) !== null && oe !== void 0 ? oe : void 0, A.listValue = (de = B.listValue) !== null && de !== void 0 ? de : void 0, A;
    },
    wrap(B) {
      const Y = J();
      if (B === null)
        Y.nullValue = E.NULL_VALUE;
      else if (typeof B == "boolean")
        Y.boolValue = B;
      else if (typeof B == "number")
        Y.numberValue = B;
      else if (typeof B == "string")
        Y.stringValue = B;
      else if (Array.isArray(B))
        Y.listValue = B;
      else if (typeof B == "object")
        Y.structValue = B;
      else if (typeof B < "u")
        throw new Error("Unsupported any value type: " + typeof B);
      return Y;
    },
    unwrap(B) {
      if ((B == null ? void 0 : B.stringValue) !== void 0)
        return B.stringValue;
      if ((B == null ? void 0 : B.numberValue) !== void 0)
        return B.numberValue;
      if ((B == null ? void 0 : B.boolValue) !== void 0)
        return B.boolValue;
      if ((B == null ? void 0 : B.structValue) !== void 0)
        return B.structValue;
      if ((B == null ? void 0 : B.listValue) !== void 0)
        return B.listValue;
      if ((B == null ? void 0 : B.nullValue) !== void 0)
        return null;
    }
  };
  function V() {
    return { values: [] };
  }
  a.ListValue = {
    encode(B, Y = g.Writer.create()) {
      for (const ne of B.values)
        a.Value.encode(a.Value.wrap(ne), Y.uint32(10).fork()).ldelim();
      return Y;
    },
    decode(B, Y) {
      const ne = B instanceof g.Reader ? B : new g.Reader(B);
      let Z = Y === void 0 ? ne.len : ne.pos + Y;
      const re = V();
      for (; ne.pos < Z; ) {
        const oe = ne.uint32();
        switch (oe >>> 3) {
          case 1:
            re.values.push(a.Value.unwrap(a.Value.decode(ne, ne.uint32())));
            break;
          default:
            ne.skipType(oe & 7);
            break;
        }
      }
      return re;
    },
    fromJSON(B) {
      return {
        values: Array.isArray(B == null ? void 0 : B.values) ? [...B.values] : []
      };
    },
    toJSON(B) {
      const Y = {};
      return B.values ? Y.values = B.values.map((ne) => ne) : Y.values = [], Y;
    },
    fromPartial(B) {
      var Y;
      const ne = V();
      return ne.values = ((Y = B.values) === null || Y === void 0 ? void 0 : Y.map((Z) => Z)) || [], ne;
    },
    wrap(B) {
      const Y = V();
      return Y.values = B ?? [], Y;
    },
    unwrap(B) {
      return B.values;
    }
  };
  var q = (() => {
    if (typeof q < "u")
      return q;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  g.util.Long !== S.default && (g.util.Long = S.default, g.configure());
  function G(B) {
    return typeof B == "object" && B !== null;
  }
  function H(B) {
    return B != null;
  }
})(struct);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(A, N, D, W) {
    W === void 0 && (W = D), Object.defineProperty(A, W, { enumerable: !0, get: function() {
      return N[D];
    } });
  } : function(A, N, D, W) {
    W === void 0 && (W = D), A[W] = N[D];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(A, N) {
    Object.defineProperty(A, "default", { enumerable: !0, value: N });
  } : function(A, N) {
    A.default = N;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(A) {
    if (A && A.__esModule)
      return A;
    var N = {};
    if (A != null)
      for (var D in A)
        D !== "default" && Object.hasOwnProperty.call(A, D) && u(N, A, D);
    return c(N, A), N;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(A) {
    return A && A.__esModule ? A : { default: A };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.EventServiceDefinition = a.EventServiceClientImpl = a.EventsStreamResponse = a.EventsStreamRequest = a.EventsStreamReconnectRequest = a.EventsStreamError = a.SubscribePayload = a.PublishEventResponse = a.PublishEventRequest = a.EventTarget = a.eventsStreamMessageTypeToNumber = a.eventsStreamMessageTypeToJSON = a.eventsStreamMessageTypeFromJSON = a.EventsStreamMessageType = a.protobufPackage = void 0;
  const S = v(umdExports), g = l(minimal), E = require$$2, _ = struct;
  a.protobufPackage = "apis.event.v2";
  var k;
  (function(A) {
    A.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED = "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED", A.EVENTS_STREAM_MESSAGE_TYPE_PING = "EVENTS_STREAM_MESSAGE_TYPE_PING", A.EVENTS_STREAM_MESSAGE_TYPE_ERROR = "EVENTS_STREAM_MESSAGE_TYPE_ERROR", A.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED = "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED", A.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED = "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED", A.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED = "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
  })(k = a.EventsStreamMessageType || (a.EventsStreamMessageType = {}));
  function L(A) {
    switch (A) {
      case 0:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED":
        return k.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED;
      case 1:
      case "EVENTS_STREAM_MESSAGE_TYPE_PING":
        return k.EVENTS_STREAM_MESSAGE_TYPE_PING;
      case 2:
      case "EVENTS_STREAM_MESSAGE_TYPE_ERROR":
        return k.EVENTS_STREAM_MESSAGE_TYPE_ERROR;
      case 3:
      case "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED":
        return k.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED;
      case 4:
      case "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED":
        return k.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED;
      case 5:
      case "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED":
        return k.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED;
      default:
        throw new re.Error("Unrecognized enum value " + A + " for enum EventsStreamMessageType");
    }
  }
  a.eventsStreamMessageTypeFromJSON = L;
  function M(A) {
    switch (A) {
      case k.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED";
      case k.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return "EVENTS_STREAM_MESSAGE_TYPE_PING";
      case k.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return "EVENTS_STREAM_MESSAGE_TYPE_ERROR";
      case k.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED";
      case k.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return "EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED";
      case k.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return "EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED";
      default:
        return "UNKNOWN";
    }
  }
  a.eventsStreamMessageTypeToJSON = M;
  function $(A) {
    switch (A) {
      case k.EVENTS_STREAM_MESSAGE_TYPE_UNSPECIFIED:
        return 0;
      case k.EVENTS_STREAM_MESSAGE_TYPE_PING:
        return 1;
      case k.EVENTS_STREAM_MESSAGE_TYPE_ERROR:
        return 2;
      case k.EVENTS_STREAM_MESSAGE_TYPE_SUBSCRIBED:
        return 3;
      case k.EVENTS_STREAM_MESSAGE_TYPE_UNSUBSCRIBED:
        return 4;
      case k.EVENTS_STREAM_MESSAGE_TYPE_PUBLISHED:
        return 5;
      default:
        return 0;
    }
  }
  a.eventsStreamMessageTypeToNumber = $;
  function J() {
    return { collectionId: void 0, projectId: void 0, layoutId: void 0 };
  }
  a.EventTarget = {
    encode(A, N = g.Writer.create()) {
      return A.collectionId !== void 0 && N.uint32(42).string(A.collectionId), A.projectId !== void 0 && N.uint32(34).string(A.projectId), A.layoutId !== void 0 && N.uint32(10).string(A.layoutId), N;
    },
    decode(A, N) {
      const D = A instanceof g.Reader ? A : new g.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = J();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 5:
            ee.collectionId = D.string();
            break;
          case 4:
            ee.projectId = D.string();
            break;
          case 1:
            ee.layoutId = D.string();
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        collectionId: de(A.collectionId) ? String(A.collectionId) : void 0,
        projectId: de(A.projectId) ? String(A.projectId) : void 0,
        layoutId: de(A.layoutId) ? String(A.layoutId) : void 0
      };
    },
    toJSON(A) {
      const N = {};
      return A.collectionId !== void 0 && (N.collectionId = A.collectionId), A.projectId !== void 0 && (N.projectId = A.projectId), A.layoutId !== void 0 && (N.layoutId = A.layoutId), N;
    },
    fromPartial(A) {
      var N, D, W;
      const ee = J();
      return ee.collectionId = (N = A.collectionId) !== null && N !== void 0 ? N : void 0, ee.projectId = (D = A.projectId) !== null && D !== void 0 ? D : void 0, ee.layoutId = (W = A.layoutId) !== null && W !== void 0 ? W : void 0, ee;
    }
  };
  function V() {
    return {
      name: "",
      payload: void 0,
      requestMetadata: void 0,
      target: void 0
    };
  }
  a.PublishEventRequest = {
    encode(A, N = g.Writer.create()) {
      return A.name !== "" && N.uint32(10).string(A.name), A.payload !== void 0 && _.Struct.encode(_.Struct.wrap(A.payload), N.uint32(18).fork()).ldelim(), A.requestMetadata !== void 0 && _.Value.encode(_.Value.wrap(A.requestMetadata), N.uint32(34).fork()).ldelim(), A.target !== void 0 && a.EventTarget.encode(A.target, N.uint32(26).fork()).ldelim(), N;
    },
    decode(A, N) {
      const D = A instanceof g.Reader ? A : new g.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = V();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.name = D.string();
            break;
          case 2:
            ee.payload = _.Struct.unwrap(_.Struct.decode(D, D.uint32()));
            break;
          case 4:
            ee.requestMetadata = _.Value.unwrap(_.Value.decode(D, D.uint32()));
            break;
          case 3:
            ee.target = a.EventTarget.decode(D, D.uint32());
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        name: de(A.name) ? String(A.name) : "",
        payload: oe(A.payload) ? A.payload : void 0,
        requestMetadata: de(A == null ? void 0 : A.requestMetadata) ? A.requestMetadata : void 0,
        target: de(A.target) ? a.EventTarget.fromJSON(A.target) : void 0
      };
    },
    toJSON(A) {
      const N = {};
      return A.name !== void 0 && (N.name = A.name), A.payload !== void 0 && (N.payload = A.payload), A.requestMetadata !== void 0 && (N.requestMetadata = A.requestMetadata), A.target !== void 0 && (N.target = A.target ? a.EventTarget.toJSON(A.target) : void 0), N;
    },
    fromPartial(A) {
      var N, D, W;
      const ee = V();
      return ee.name = (N = A.name) !== null && N !== void 0 ? N : "", ee.payload = (D = A.payload) !== null && D !== void 0 ? D : void 0, ee.requestMetadata = (W = A.requestMetadata) !== null && W !== void 0 ? W : void 0, ee.target = A.target !== void 0 && A.target !== null ? a.EventTarget.fromPartial(A.target) : void 0, ee;
    }
  };
  function q() {
    return {
      name: "",
      payload: void 0,
      target: void 0,
      requestMetadata: void 0,
      id: ""
    };
  }
  a.PublishEventResponse = {
    encode(A, N = g.Writer.create()) {
      return A.name !== "" && N.uint32(10).string(A.name), A.payload !== void 0 && _.Struct.encode(_.Struct.wrap(A.payload), N.uint32(18).fork()).ldelim(), A.target !== void 0 && a.EventTarget.encode(A.target, N.uint32(26).fork()).ldelim(), A.requestMetadata !== void 0 && _.Value.encode(_.Value.wrap(A.requestMetadata), N.uint32(34).fork()).ldelim(), A.id !== "" && N.uint32(42).string(A.id), N;
    },
    decode(A, N) {
      const D = A instanceof g.Reader ? A : new g.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = q();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.name = D.string();
            break;
          case 2:
            ee.payload = _.Struct.unwrap(_.Struct.decode(D, D.uint32()));
            break;
          case 3:
            ee.target = a.EventTarget.decode(D, D.uint32());
            break;
          case 4:
            ee.requestMetadata = _.Value.unwrap(_.Value.decode(D, D.uint32()));
            break;
          case 5:
            ee.id = D.string();
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        name: de(A.name) ? String(A.name) : "",
        payload: oe(A.payload) ? A.payload : void 0,
        target: de(A.target) ? a.EventTarget.fromJSON(A.target) : void 0,
        requestMetadata: de(A == null ? void 0 : A.requestMetadata) ? A.requestMetadata : void 0,
        id: de(A.id) ? String(A.id) : ""
      };
    },
    toJSON(A) {
      const N = {};
      return A.name !== void 0 && (N.name = A.name), A.payload !== void 0 && (N.payload = A.payload), A.target !== void 0 && (N.target = A.target ? a.EventTarget.toJSON(A.target) : void 0), A.requestMetadata !== void 0 && (N.requestMetadata = A.requestMetadata), A.id !== void 0 && (N.id = A.id), N;
    },
    fromPartial(A) {
      var N, D, W, ee;
      const ae = q();
      return ae.name = (N = A.name) !== null && N !== void 0 ? N : "", ae.payload = (D = A.payload) !== null && D !== void 0 ? D : void 0, ae.target = A.target !== void 0 && A.target !== null ? a.EventTarget.fromPartial(A.target) : void 0, ae.requestMetadata = (W = A.requestMetadata) !== null && W !== void 0 ? W : void 0, ae.id = (ee = A.id) !== null && ee !== void 0 ? ee : "", ae;
    }
  };
  function G() {
    return { name: "", target: void 0 };
  }
  a.SubscribePayload = {
    encode(A, N = g.Writer.create()) {
      return A.name !== "" && N.uint32(10).string(A.name), A.target !== void 0 && a.EventTarget.encode(A.target, N.uint32(18).fork()).ldelim(), N;
    },
    decode(A, N) {
      const D = A instanceof g.Reader ? A : new g.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = G();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.name = D.string();
            break;
          case 2:
            ee.target = a.EventTarget.decode(D, D.uint32());
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        name: de(A.name) ? String(A.name) : "",
        target: de(A.target) ? a.EventTarget.fromJSON(A.target) : void 0
      };
    },
    toJSON(A) {
      const N = {};
      return A.name !== void 0 && (N.name = A.name), A.target !== void 0 && (N.target = A.target ? a.EventTarget.toJSON(A.target) : void 0), N;
    },
    fromPartial(A) {
      var N;
      const D = G();
      return D.name = (N = A.name) !== null && N !== void 0 ? N : "", D.target = A.target !== void 0 && A.target !== null ? a.EventTarget.fromPartial(A.target) : void 0, D;
    }
  };
  function H() {
    return { code: 0, message: "" };
  }
  a.EventsStreamError = {
    encode(A, N = g.Writer.create()) {
      return A.code !== 0 && N.uint32(8).int32(A.code), A.message !== "" && N.uint32(18).string(A.message), N;
    },
    decode(A, N) {
      const D = A instanceof g.Reader ? A : new g.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = H();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.code = D.int32();
            break;
          case 2:
            ee.message = D.string();
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        code: de(A.code) ? Number(A.code) : 0,
        message: de(A.message) ? String(A.message) : ""
      };
    },
    toJSON(A) {
      const N = {};
      return A.code !== void 0 && (N.code = Math.round(A.code)), A.message !== void 0 && (N.message = A.message), N;
    },
    fromPartial(A) {
      var N, D;
      const W = H();
      return W.code = (N = A.code) !== null && N !== void 0 ? N : 0, W.message = (D = A.message) !== null && D !== void 0 ? D : "", W;
    }
  };
  function B() {
    return { reauthenticate: !1, beforeTimestamp: "" };
  }
  a.EventsStreamReconnectRequest = {
    encode(A, N = g.Writer.create()) {
      return A.reauthenticate === !0 && N.uint32(8).bool(A.reauthenticate), A.beforeTimestamp !== "" && N.uint32(18).string(A.beforeTimestamp), N;
    },
    decode(A, N) {
      const D = A instanceof g.Reader ? A : new g.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = B();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.reauthenticate = D.bool();
            break;
          case 2:
            ee.beforeTimestamp = D.string();
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        reauthenticate: de(A.reauthenticate) ? !!A.reauthenticate : !1,
        beforeTimestamp: de(A.beforeTimestamp) ? String(A.beforeTimestamp) : ""
      };
    },
    toJSON(A) {
      const N = {};
      return A.reauthenticate !== void 0 && (N.reauthenticate = A.reauthenticate), A.beforeTimestamp !== void 0 && (N.beforeTimestamp = A.beforeTimestamp), N;
    },
    fromPartial(A) {
      var N, D;
      const W = B();
      return W.reauthenticate = (N = A.reauthenticate) !== null && N !== void 0 ? N : !1, W.beforeTimestamp = (D = A.beforeTimestamp) !== null && D !== void 0 ? D : "", W;
    }
  };
  function Y() {
    return {
      correlationId: void 0,
      subscribe: void 0,
      unsubscribe: void 0,
      publish: void 0,
      ping: void 0
    };
  }
  a.EventsStreamRequest = {
    encode(A, N = g.Writer.create()) {
      return A.correlationId !== void 0 && N.uint32(10).string(A.correlationId), A.subscribe !== void 0 && a.SubscribePayload.encode(A.subscribe, N.uint32(802).fork()).ldelim(), A.unsubscribe !== void 0 && a.SubscribePayload.encode(A.unsubscribe, N.uint32(810).fork()).ldelim(), A.publish !== void 0 && a.PublishEventRequest.encode(A.publish, N.uint32(818).fork()).ldelim(), A.ping !== void 0 && N.uint32(826).string(A.ping), N;
    },
    decode(A, N) {
      const D = A instanceof g.Reader ? A : new g.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = Y();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.correlationId = D.string();
            break;
          case 100:
            ee.subscribe = a.SubscribePayload.decode(D, D.uint32());
            break;
          case 101:
            ee.unsubscribe = a.SubscribePayload.decode(D, D.uint32());
            break;
          case 102:
            ee.publish = a.PublishEventRequest.decode(D, D.uint32());
            break;
          case 103:
            ee.ping = D.string();
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        correlationId: de(A.correlationId) ? String(A.correlationId) : void 0,
        subscribe: de(A.subscribe) ? a.SubscribePayload.fromJSON(A.subscribe) : void 0,
        unsubscribe: de(A.unsubscribe) ? a.SubscribePayload.fromJSON(A.unsubscribe) : void 0,
        publish: de(A.publish) ? a.PublishEventRequest.fromJSON(A.publish) : void 0,
        ping: de(A.ping) ? String(A.ping) : void 0
      };
    },
    toJSON(A) {
      const N = {};
      return A.correlationId !== void 0 && (N.correlationId = A.correlationId), A.subscribe !== void 0 && (N.subscribe = A.subscribe ? a.SubscribePayload.toJSON(A.subscribe) : void 0), A.unsubscribe !== void 0 && (N.unsubscribe = A.unsubscribe ? a.SubscribePayload.toJSON(A.unsubscribe) : void 0), A.publish !== void 0 && (N.publish = A.publish ? a.PublishEventRequest.toJSON(A.publish) : void 0), A.ping !== void 0 && (N.ping = A.ping), N;
    },
    fromPartial(A) {
      var N, D;
      const W = Y();
      return W.correlationId = (N = A.correlationId) !== null && N !== void 0 ? N : void 0, W.subscribe = A.subscribe !== void 0 && A.subscribe !== null ? a.SubscribePayload.fromPartial(A.subscribe) : void 0, W.unsubscribe = A.unsubscribe !== void 0 && A.unsubscribe !== null ? a.SubscribePayload.fromPartial(A.unsubscribe) : void 0, W.publish = A.publish !== void 0 && A.publish !== null ? a.PublishEventRequest.fromPartial(A.publish) : void 0, W.ping = (D = A.ping) !== null && D !== void 0 ? D : void 0, W;
    }
  };
  function ne() {
    return {
      correlationId: void 0,
      sessionId: void 0,
      event: void 0,
      pong: void 0,
      error: void 0,
      subscribed: void 0,
      unsubscribed: void 0,
      published: void 0,
      reconnectBefore: void 0
    };
  }
  a.EventsStreamResponse = {
    encode(A, N = g.Writer.create()) {
      return A.correlationId !== void 0 && N.uint32(18).string(A.correlationId), A.sessionId !== void 0 && N.uint32(26).string(A.sessionId), A.event !== void 0 && a.PublishEventResponse.encode(A.event, N.uint32(802).fork()).ldelim(), A.pong !== void 0 && N.uint32(1602).string(A.pong), A.error !== void 0 && a.EventsStreamError.encode(A.error, N.uint32(1610).fork()).ldelim(), A.subscribed !== void 0 && a.SubscribePayload.encode(A.subscribed, N.uint32(1618).fork()).ldelim(), A.unsubscribed !== void 0 && a.SubscribePayload.encode(A.unsubscribed, N.uint32(1626).fork()).ldelim(), A.published !== void 0 && a.PublishEventResponse.encode(A.published, N.uint32(1634).fork()).ldelim(), A.reconnectBefore !== void 0 && a.EventsStreamReconnectRequest.encode(A.reconnectBefore, N.uint32(1642).fork()).ldelim(), N;
    },
    decode(A, N) {
      const D = A instanceof g.Reader ? A : new g.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = ne();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 2:
            ee.correlationId = D.string();
            break;
          case 3:
            ee.sessionId = D.string();
            break;
          case 100:
            ee.event = a.PublishEventResponse.decode(D, D.uint32());
            break;
          case 200:
            ee.pong = D.string();
            break;
          case 201:
            ee.error = a.EventsStreamError.decode(D, D.uint32());
            break;
          case 202:
            ee.subscribed = a.SubscribePayload.decode(D, D.uint32());
            break;
          case 203:
            ee.unsubscribed = a.SubscribePayload.decode(D, D.uint32());
            break;
          case 204:
            ee.published = a.PublishEventResponse.decode(D, D.uint32());
            break;
          case 205:
            ee.reconnectBefore = a.EventsStreamReconnectRequest.decode(D, D.uint32());
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        correlationId: de(A.correlationId) ? String(A.correlationId) : void 0,
        sessionId: de(A.sessionId) ? String(A.sessionId) : void 0,
        event: de(A.event) ? a.PublishEventResponse.fromJSON(A.event) : void 0,
        pong: de(A.pong) ? String(A.pong) : void 0,
        error: de(A.error) ? a.EventsStreamError.fromJSON(A.error) : void 0,
        subscribed: de(A.subscribed) ? a.SubscribePayload.fromJSON(A.subscribed) : void 0,
        unsubscribed: de(A.unsubscribed) ? a.SubscribePayload.fromJSON(A.unsubscribed) : void 0,
        published: de(A.published) ? a.PublishEventResponse.fromJSON(A.published) : void 0,
        reconnectBefore: de(A.reconnectBefore) ? a.EventsStreamReconnectRequest.fromJSON(A.reconnectBefore) : void 0
      };
    },
    toJSON(A) {
      const N = {};
      return A.correlationId !== void 0 && (N.correlationId = A.correlationId), A.sessionId !== void 0 && (N.sessionId = A.sessionId), A.event !== void 0 && (N.event = A.event ? a.PublishEventResponse.toJSON(A.event) : void 0), A.pong !== void 0 && (N.pong = A.pong), A.error !== void 0 && (N.error = A.error ? a.EventsStreamError.toJSON(A.error) : void 0), A.subscribed !== void 0 && (N.subscribed = A.subscribed ? a.SubscribePayload.toJSON(A.subscribed) : void 0), A.unsubscribed !== void 0 && (N.unsubscribed = A.unsubscribed ? a.SubscribePayload.toJSON(A.unsubscribed) : void 0), A.published !== void 0 && (N.published = A.published ? a.PublishEventResponse.toJSON(A.published) : void 0), A.reconnectBefore !== void 0 && (N.reconnectBefore = A.reconnectBefore ? a.EventsStreamReconnectRequest.toJSON(A.reconnectBefore) : void 0), N;
    },
    fromPartial(A) {
      var N, D, W;
      const ee = ne();
      return ee.correlationId = (N = A.correlationId) !== null && N !== void 0 ? N : void 0, ee.sessionId = (D = A.sessionId) !== null && D !== void 0 ? D : void 0, ee.event = A.event !== void 0 && A.event !== null ? a.PublishEventResponse.fromPartial(A.event) : void 0, ee.pong = (W = A.pong) !== null && W !== void 0 ? W : void 0, ee.error = A.error !== void 0 && A.error !== null ? a.EventsStreamError.fromPartial(A.error) : void 0, ee.subscribed = A.subscribed !== void 0 && A.subscribed !== null ? a.SubscribePayload.fromPartial(A.subscribed) : void 0, ee.unsubscribed = A.unsubscribed !== void 0 && A.unsubscribed !== null ? a.SubscribePayload.fromPartial(A.unsubscribed) : void 0, ee.published = A.published !== void 0 && A.published !== null ? a.PublishEventResponse.fromPartial(A.published) : void 0, ee.reconnectBefore = A.reconnectBefore !== void 0 && A.reconnectBefore !== null ? a.EventsStreamReconnectRequest.fromPartial(A.reconnectBefore) : void 0, ee;
    }
  };
  class Z {
    constructor(N) {
      this.rpc = N, this.Stream = this.Stream.bind(this), this.Publish = this.Publish.bind(this);
    }
    Stream(N) {
      const D = N.pipe(E.map((ee) => a.EventsStreamRequest.encode(ee).finish()));
      return this.rpc.bidirectionalStreamingRequest("apis.event.v2.EventService", "Stream", D).pipe(E.map((ee) => a.EventsStreamResponse.decode(new g.Reader(ee))));
    }
    Publish(N) {
      const D = a.PublishEventRequest.encode(N).finish();
      return this.rpc.request("apis.event.v2.EventService", "Publish", D).then((ee) => a.PublishEventResponse.decode(new g.Reader(ee)));
    }
  }
  a.EventServiceClientImpl = Z, a.EventServiceDefinition = {
    name: "EventService",
    fullName: "apis.event.v2.EventService",
    methods: {
      /**
       * Stream Events
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      stream: {
        name: "Stream",
        requestType: a.EventsStreamRequest,
        requestStream: !0,
        responseType: a.EventsStreamResponse,
        responseStream: !0,
        options: {}
      },
      /**
       * Publish Event
       * buf:lint:ignore RPC_REQUEST_STANDARD_NAME
       * buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
       */
      publish: {
        name: "Publish",
        requestType: a.PublishEventRequest,
        requestStream: !1,
        responseType: a.PublishEventResponse,
        responseStream: !1,
        options: {}
      }
    }
  };
  var re = (() => {
    if (typeof re < "u")
      return re;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  g.util.Long !== S.default && (g.util.Long = S.default, g.configure());
  function oe(A) {
    return typeof A == "object" && A !== null;
  }
  function de(A) {
    return A != null;
  }
})(api);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(l, v, S, g) {
    g === void 0 && (g = S), Object.defineProperty(l, g, { enumerable: !0, get: function() {
      return v[S];
    } });
  } : function(l, v, S, g) {
    g === void 0 && (g = S), l[g] = v[S];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(l, v) {
    for (var S in l)
      S !== "default" && !v.hasOwnProperty(S) && u(v, l, S);
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.eventsApiSupportedEvents = a.eventsApiEventRpcCalls = void 0, c(api, a), a.eventsApiEventRpcCalls = {
    ping: "pong",
    publish: "published",
    subscribe: "subscribed",
    unsubscribe: "unsubscribed"
  }, a.eventsApiSupportedEvents = [...Object.values(a.eventsApiEventRpcCalls), "error", "event", "reconnectBefore"];
})(dist$1);
var ws = null;
typeof WebSocket < "u" ? ws = WebSocket : typeof MozWebSocket < "u" ? ws = MozWebSocket : typeof commonjsGlobal$1 < "u" ? ws = commonjsGlobal$1.WebSocket || commonjsGlobal$1.MozWebSocket : typeof window < "u" ? ws = window.WebSocket || window.MozWebSocket : typeof self < "u" && (ws = self.WebSocket || self.MozWebSocket);
var browser$1 = ws, matcher = { exports: {} }, escapeStringRegexp$1 = (a) => {
  if (typeof a != "string")
    throw new TypeError("Expected a string");
  return a.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
const escapeStringRegexp = escapeStringRegexp$1, regexpCache = /* @__PURE__ */ new Map();
function sanitizeArray(a, u) {
  if (!Array.isArray(a))
    switch (typeof a) {
      case "string":
        a = [a];
        break;
      case "undefined":
        a = [];
        break;
      default:
        throw new TypeError(`Expected '${u}' to be a string or an array, but got a type of '${typeof a}'`);
    }
  return a.filter((c) => {
    if (typeof c != "string") {
      if (typeof c > "u")
        return !1;
      throw new TypeError(`Expected '${u}' to be an array of strings, but found a type of '${typeof c}' in the array`);
    }
    return !0;
  });
}
function makeRegexp(a, u) {
  u = {
    caseSensitive: !1,
    ...u
  };
  const c = a + JSON.stringify(u);
  if (regexpCache.has(c))
    return regexpCache.get(c);
  const l = a[0] === "!";
  l && (a = a.slice(1)), a = escapeStringRegexp(a).replace(/\\\*/g, "[\\s\\S]*");
  const v = new RegExp(`^${a}$`, u.caseSensitive ? "" : "i");
  return v.negated = l, regexpCache.set(c, v), v;
}
matcher.exports = (a, u, c) => {
  if (a = sanitizeArray(a, "inputs"), u = sanitizeArray(u, "patterns"), u.length === 0)
    return [];
  const l = u[0][0] === "!";
  u = u.map((S) => makeRegexp(S, c));
  const v = [];
  for (const S of a) {
    let g = l;
    for (const E of u)
      E.test(S) && (g = !E.negated);
    g && v.push(S);
  }
  return v;
};
matcher.exports.isMatch = (a, u, c) => (a = sanitizeArray(a, "inputs"), u = sanitizeArray(u, "patterns"), u.length === 0 ? !1 : a.some((l) => u.every((v) => {
  const S = makeRegexp(v, c), g = S.test(l);
  return S.negated ? !g : g;
})));
var matcherExports = matcher.exports, __createBinding$1 = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c);
  var v = Object.getOwnPropertyDescriptor(u, c);
  (!v || ("get" in v ? !u.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
    return u[c];
  } }), Object.defineProperty(a, l, v);
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar$1 = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding$1(u, a, c);
  return __setModuleDefault$1(u, a), u;
}, __importDefault$8 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(eventapi, "__esModule", { value: !0 });
eventapi.EventApi = void 0;
const EventApiModel = __importStar$1(dist$1), isomorphic_ws_1 = __importDefault$8(browser$1), uuid_1 = require$$1$2, NiceGrpc = __importStar$1(lib$1), matcher_1 = matcherExports, api_1 = api$2, clientVersion = version$3, WS_PING_INTERVAL = 2e4, WS_PING_TIMEOUT = 1e4, WS_RECONNECT_DELAY = 2e3, WS_MAX_BADAUTH_ATTEMPTS = 3, LOG_CATEGORY = "EventApi";
class EventApi extends api_1.ApiClient {
  constructor(u, c, l, v, S, g) {
    super(u, c, v, LOG_CATEGORY, S, g), this.websocketServer = l, this.subscriptions = /* @__PURE__ */ new Set(), this.eventHandlers = {}, this.calls = {}, this.messageQueue = [], this.websocketReady = !1, this.reconnectionAttempts = 0, this.badAuthentication = !1, this.eventsClient = null;
  }
  /**
   * Publish a custom event
   *
   * note: if this session has an established stream, all custom
   * events will use that transport.
   *
   * @param request
   * @returns
   */
  publish(...u) {
    return this.websocketReady ? this.call("publish", u[0]) : this.eventsClient.publish(...u);
  }
  /**
   * Open the connection
   */
  connect() {
    if (!this.ws) {
      this.cleanup();
      const u = this.accessToken, c = [`version=${clientVersion}`, `sessionid=${this.sessionId}`];
      this.sdkVersion && c.push(`sdkversion=${this.sdkVersion}`), this.ws = new isomorphic_ws_1.default(`${this.websocketServer}/stream?${c.join("&")}`, [
        "Bearer",
        this.accessToken
      ]);
      let l;
      this.ws.addEventListener("message", (v) => {
        const S = JSON.parse(v.data.toString()), g = S.result;
        if (S.error && (l = S.error, this.handleEvent("error", {
          error: {
            code: S.code,
            message: S.message
          }
        }), ["You do not have permission to this resource", "You do not have permission to this resource"].includes(S.message) && (this.badAuthentication = !0)), !g)
          return;
        g.reconnectBefore && g.reconnectBefore.reauthenticate && this.accessToken === u && (this.badAuthentication = !0);
        const E = EventApiModel.eventsApiSupportedEvents.find((_) => !!g[_]);
        E && this.handleEvent(E, g);
      }), this.ws.addEventListener("open", () => {
        this.log.info("websocket connected"), this.call("ping", "hello", { timeout: WS_PING_TIMEOUT, skipQueue: !0 }).then(() => {
          this.ready();
        }).catch((v) => {
          !l && v.message !== "Stream connection closed" && this.disconnect("hello timeout");
        });
      }), this.ws.addEventListener("close", (v) => {
        var S;
        l ? this.reconnect(`${(S = l == null ? void 0 : l.message) !== null && S !== void 0 ? S : "unknown"}`) : this.reconnect(`closed - ${v.reason || v.code}`);
      }), this.ws.addEventListener("error", (v) => {
        l = v;
      });
    }
  }
  /**
   * Subscribe to an event
   *
   * note: if a connection does not exist, one will be established.
   *
   * @param type
   * @param payload
   */
  async subscribe(u, c = {}) {
    return this.call("subscribe", { name: u, ...c }).then(() => {
      this.subscriptions.add(JSON.stringify({ name: u, ...c }));
    });
  }
  /**
   * Unsubscribe from an event
   * @param type
   * @param payload
   */
  async unsubscribe(u, c = {}) {
    this.subscriptions.delete(JSON.stringify({ name: u, payload: c })), await this.call("unsubscribe", { name: u, ...c });
  }
  on(u, c, l) {
    const v = l || c, S = {
      ignoreSessionEvents: !1,
      allowedSessionEvents: [],
      ...l ? c : {}
    };
    this.eventHandlers[u] || (this.eventHandlers[u] = []), this.eventHandlers[u].push({
      ...S,
      handler: v
    });
  }
  off(u, c, l) {
    var v;
    const S = l || c, g = {
      ignoreSessionEvents: !1,
      allowedSessionEvents: [],
      ...l ? c : {}
    };
    this.eventHandlers[u] = ((v = this.eventHandlers[u]) !== null && v !== void 0 ? v : []).filter((E) => !(E.ignoreSessionEvents === g.ignoreSessionEvents && E.allowedSessionEvents === g.allowedSessionEvents && E.handler === S && E.name === g.name));
  }
  /**
   * Disconnect the websocket connection
   */
  disconnect(u) {
    this.log.warn(`disconnected from events reason=${u}`), Object.values(this.calls).forEach((c) => {
      clearTimeout(c.timeout), c.reject(new Error("Stream connection closed"));
    }), this.calls = {}, this.cleanup();
  }
  _setup(u) {
    this.eventsClient = this.clientFactory.create(EventApiModel.EventServiceDefinition, this.channel, {
      "*": u
    }), this.badAuthentication && (this.badAuthentication = !1, this.reconnectionAttempts = 0, this.reconnect("updated token"));
  }
  /**
   * Called when the websocket is ready.
   */
  ready() {
    this.reconnectionAttempts = 0, this.badAuthentication = !1, this.websocketReady = !0, this.handleEvent("connected", { connected: void 0 });
    for (const u of this.subscriptions.values())
      this.send({ subscribe: JSON.parse(u), correlationId: (0, uuid_1.v4)() });
    for (const u of this.messageQueue)
      this.send(u);
    this.messageQueue = [], this.pingLoop = setInterval(() => {
      this.ping();
    }, WS_PING_INTERVAL);
  }
  ping() {
    this.call("ping", `${+/* @__PURE__ */ new Date()}`, { timeout: WS_PING_TIMEOUT }).catch(() => {
      this.reconnect("connection stalled");
    });
  }
  /**
   * Reconnect event stream
   *
   * @param reason Rec
   */
  reconnect(u) {
    this.disconnect(u), this.reconnectTimeout = setTimeout(() => {
      if (this.reconnectionAttempts++, this.badAuthentication && this.reconnectionAttempts >= WS_MAX_BADAUTH_ATTEMPTS) {
        this.log.warn("Maximum number of reconnection attempts reached with bad authentication, please re-authenticate the SDK");
        return;
      }
      this.connect();
    }, WS_RECONNECT_DELAY);
  }
  /**
   * Send a raw message to the websocket.
   *
   * @param data
   */
  send(u) {
    this.ws && this.ws.readyState === this.ws.OPEN ? this.ws.send(JSON.stringify(u)) : this.log.warn("Message sent to a disconnected stream");
  }
  /**
   * Process a stream event
   *
   * @param name the name of the event
   * @param payload the full event stream payload
   *
   * @returns void
   */
  handleEvent(u, c) {
    var l;
    if (this.calls[c.correlationId]) {
      const v = EventApiModel.eventsApiEventRpcCalls[this.calls[c.correlationId].method] === u, S = !!c.error;
      if (v || S) {
        this.resolveCall(u, c);
        return;
      }
    }
    for (const v of (l = this.eventHandlers[u]) !== null && l !== void 0 ? l : []) {
      if (u === "event" && c.event) {
        if (c.sessionId === this.sessionId && v.ignoreSessionEvents && !v.allowedSessionEvents.includes(c.event.name)) {
          this.log.trace("ignoring user event from self: " + c.event.name + ", payload.sessionId=" + c.sessionId + ", this.sessionId");
          continue;
        }
        if (v.name && !(0, matcher_1.isMatch)(c.event.name, v.name))
          continue;
        if (this.eventLogCallback) {
          let S, g = c.event.name, E;
          if (c.event.name.startsWith(EventApi.APISTREAM_EVENT_PREFIX)) {
            let _ = c.event.name.split(":");
            _.length == 4 && (S = _[1], g = _[2], E = _[3]), this.eventLogCallback(S, g, E, c);
          }
        }
      } else if (c.sessionId === this.sessionId && v.ignoreSessionEvents) {
        this.log.trace("ignoring event from self: " + c.event.name + ", payload.sessionId=" + c.sessionId + ", this.sessionId");
        continue;
      }
      this.log.trace("processing event: payload.sessionId=" + c.sessionId + ", this.sessionId"), v.handler(c ? c[u] : void 0, { isFromCurrentSession: c.sessionId === this.sessionId });
    }
  }
  /**
   * Make an RPC call
   *
   * Initiates an async request via the stream. A correlationId is generated and used to track
   * responses and errors. A handler is registered
   *
   * @param method request method to call
   * @param payload payload to send
   * @param opts timeout
   * @returns
   */
  async call(u, c, l = { timeout: 2e4, skipQueue: !1 }) {
    this.ws || this.connect();
    const v = (0, uuid_1.v4)();
    return new Promise((S, g) => {
      const E = setTimeout(() => {
        delete this.calls[v], g(new Error("Request timed out"));
      }, l.timeout);
      this.calls[v] = { resolve: S, reject: g, timeout: E, method: u }, this.websocketReady || l.skipQueue ? this.send({ [u]: c, correlationId: v }) : this.messageQueue.push({ [u]: c, correlationId: v });
    });
  }
  /**
   * Handler for `.call()`
   *
   * Handle response events for a socket call.
   *
   * @param name name of responding event
   * @param payload payload of the event
   * @returns void
   */
  resolveCall(u, c) {
    const l = this.calls[c.correlationId];
    if (l) {
      if (clearTimeout(l.timeout), delete this.calls[c.correlationId], u === "error" && c.error) {
        l.reject(new NiceGrpc.ClientError("error", c.error.code, c.error.message));
        return;
      }
      l.resolve(c[u]);
    }
  }
  /**
   * Cleanup connection
   *
   * This cleans up the local state for a given websocket connection.
   */
  cleanup() {
    clearTimeout(this.pingLoop), clearTimeout(this.reconnectTimeout), this.websocketReady = !1, this.ws && (this.ws.onclose = function() {
    }, this.ws.close(), this.ws = null);
  }
}
eventapi.EventApi = EventApi;
EventApi.APISTREAM_EVENT_PREFIX = "apistream";
var livekit = {}, __importDefault$7 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(livekit, "__esModule", { value: !0 });
livekit.LiveKitUtils = void 0;
const jwt_decode_1 = __importDefault$7(require$$0$2);
class LiveKitUtils {
  static decodeJwt(u) {
    return (0, jwt_decode_1.default)(u, { header: !1 });
  }
  static isRoomAdmin(u) {
    return LiveKitUtils.decodeJwt(u).video.roomAdmin;
  }
  static getRoomName(u) {
    return LiveKitUtils.decodeJwt(u).video.room;
  }
}
livekit.LiveKitUtils = LiveKitUtils;
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(de, A, N, D) {
    D === void 0 && (D = N);
    var W = Object.getOwnPropertyDescriptor(A, N);
    (!W || ("get" in W ? !A.__esModule : W.writable || W.configurable)) && (W = { enumerable: !0, get: function() {
      return A[N];
    } }), Object.defineProperty(de, D, W);
  } : function(de, A, N, D) {
    D === void 0 && (D = N), de[D] = A[N];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(de, A) {
    Object.defineProperty(de, "default", { enumerable: !0, value: A });
  } : function(de, A) {
    de.default = A;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(de) {
    if (de && de.__esModule)
      return de;
    var A = {};
    if (de != null)
      for (var N in de)
        N !== "default" && Object.prototype.hasOwnProperty.call(de, N) && u(A, de, N);
    return c(A, de), A;
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(de) {
    return de && de.__esModule ? de : { default: de };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.ApiStream = a.LiveKitUtils = a.EventApiModel = a.LayoutApiModel = a.LiveApiModel = void 0;
  const S = v(require$$0$2), g = require$$1$2, E = require$$2$1, _ = layoutapi, k = liveapi, L = eventapi, M = l(api$1);
  a.LiveApiModel = M;
  const $ = l(dist$2);
  a.LayoutApiModel = $;
  const J = l(dist$1);
  a.EventApiModel = J;
  const V = livekit;
  Object.defineProperty(a, "LiveKitUtils", { enumerable: !0, get: function() {
    return V.LiveKitUtils;
  } });
  const q = logger, G = version$3, H = {
    dev: "http://127.0.0.1:8081",
    stage: "https://live.silly.horse/grpcweb/live/v2",
    prod: "https://live.api.stream/grpcweb/live/v2"
  }, B = {
    dev: "https://live.silly.horse/grpcweb/layout/v2",
    stage: "https://live.silly.horse/grpcweb/layout/v2",
    prod: "https://live.api.stream/grpcweb/layout/v2"
  }, Y = {
    dev: "wss://live.silly.horse/event/v2",
    stage: "wss://live.silly.horse/event/v2",
    prod: "wss://live.api.stream/event/v2"
  }, ne = {
    dev: "https://live.silly.horse/grpcweb/event/v2",
    stage: "https://live.silly.horse/grpcweb/event/v2",
    prod: "https://live.api.stream/grpcweb/event/v2"
  }, Z = {
    dev: "wss://live.silly.horse/webrtc/v2",
    stage: "wss://live.silly.horse/webrtc/v2",
    prod: "wss://live.api.stream/webrtc/v2"
  }, re = {
    dev: "https://live.silly.horse/webrtc/v2",
    stage: "https://live.silly.horse/webrtc/v2",
    prod: "https://live.api.stream/webrtc/v2"
  };
  class oe {
    /**
     * Create an ApiStream API Client
     */
    constructor(A = {}) {
      var N;
      const D = {
        env: "prod",
        logLevel: "Warn",
        ...A
      };
      this.env = D.env;
      let W = (0, g.v4)();
      D.sessionId != null && (W = D.sessionId), this.log = q.logger.getCategory("ApiStream"), this.setLogLevel(D.env == "dev" ? "Trace" : D.logLevel);
      const ee = (N = D.overrideEndpoints) !== null && N !== void 0 ? N : {};
      ee.liveApiServer == null && (ee.liveApiServer = H[this.env]), ee.layoutApiServer == null && (ee.layoutApiServer = B[this.env]), ee.eventApiServer == null && (ee.eventApiServer = ne[this.env]), ee.eventApiWebSocketServer == null && (ee.eventApiWebSocketServer = Y[this.env]), this.eventApi = new L.EventApi(W, ee.eventApiServer, ee.eventApiWebSocketServer, D.sdkVersion, D.apiLogCallback, D.eventLogCallback), this.layoutApi = new _.LayoutApi(W, this.eventApi, ee.layoutApiServer, D.sdkVersion, D.apiLogCallback), this.liveApi = new k.LiveApi(W, this.eventApi, ee.liveApiServer, this.setAccessToken.bind(this), D.apiKey, D.sdkVersion, D.apiLogCallback), this.eventApi.on("reconnectBefore", (ae) => {
        ae.reauthenticate && this.liveApi.authentication.refreshAccessToken({}).catch(() => {
        });
      }), this.log.info("api.stream: sessionid=" + W + ", version=" + G + ", sdkVersion=" + D.sdkVersion);
    }
    /**
     * Returns the live api client
     *
     * @returns the live api client
     */
    LiveApi() {
      return this.liveApi;
    }
    /**
     * Returns the layout api client
     *
     * @returns the layout api client
     */
    LayoutApi() {
      return this.layoutApi;
    }
    /**
     * Returns the layout api client
     *
     * @returns the layout api client
     */
    EventApi() {
      return this.eventApi;
    }
    setLogLevel(A) {
      try {
        let N = E.LogLevel.toLogLevel(A);
        q.logger.updateRuntimeSettings({
          level: N
        });
      } catch {
        this.log.warn(`unknown logging level ${A}`);
      }
    }
    setAccessToken(A) {
      this.decodedAccessToken = oe.decodeAccessToken(A), this.log.debug("setting accessToken", A, this.decodedAccessToken), this.layoutApi.setAccessToken(A), this.liveApi.setAccessToken(A), this.eventApi.setAccessToken(A);
    }
    getAccessToken() {
      return this.decodedAccessToken;
    }
    /**
     * Are we running as a guest role?
     *
     * @returns {(ApiStream.GuestProject | null)} return the active project if running as a guest role
     */
    getGuestProject() {
      return this.decodedAccessToken.guestControl;
    }
    /**
     * Initialize the api library and check if we are running inside of the rendering engine
     * @async
     * @param {string} accessToken - a valid ApiStream access token
     * @returns {(ApiStream.GuestProject | null)} if we are operating inside of the rendering engine, this is the active project
     */
    async load(A) {
      if (A == null && typeof window < "u") {
        let N = this.parseQuery();
        N.get(oe.ACCESS_TOKEN_QUERY_PARAM) != null && (A = N.get(oe.ACCESS_TOKEN_QUERY_PARAM));
      }
      return A != null && (this.setAccessToken(A), this.decodedAccessToken.guestControl != null) ? (this.log.info("loading guest token and exchanging"), await this.LiveApi().authentication.refreshAccessToken({}), this.log.info("auto-loading project = " + JSON.stringify(this.decodedAccessToken.guestControl)), this.decodedAccessToken.guestControl) : null;
    }
    /**
     * get the signaling address of the appropriate livekit webrtc server
     *
     * @param {boolean} admin - if true, return the admin (vs. client) address
     * @returns {string} the address of the appropriate livekit webrtc server
     */
    getLiveKitServer(A = !1) {
      return A ? re[this.env] : Z[this.env];
    }
    parseQuery() {
      let A = window.location.search, N = /* @__PURE__ */ new Map(), D = (A[0] === "?" ? A.substr(1) : A).split("&");
      for (let W = 0; W < D.length; W++) {
        let ee = D[W].split("=");
        ee.length == 2 && (N.set(decodeURIComponent(ee[0]), decodeURIComponent(ee[1] || "")), this.log.debug(`found query param: ${decodeURIComponent(ee[0])}=${decodeURIComponent(ee[1] || "")}`));
      }
      return N;
    }
    static decodeAccessToken(A) {
      let N = (0, S.default)(A, { header: !1 }), D = {
        serviceUserId: N.user.serviceUserId,
        userId: N.user.userId,
        displayName: N.user.displayName,
        trial: N.user.trial,
        demo: N.user.demo
      };
      return N.guestControl != null && (D.guestControl = {
        collectionId: N.guestControl.collectionId,
        projectId: N.guestControl.projectId,
        role: M.roleFromJSON(N.guestControl.role)
      }), D;
    }
  }
  a.ApiStream = oe, oe.ACCESS_TOKEN_QUERY_PARAM = "at";
})(lib$2);
var dist = {}, AccessToken$1 = {}, jws$3 = {}, safeBuffer = { exports: {} };
(function(a, u) {
  var c = require$$0$1, l = c.Buffer;
  function v(g, E) {
    for (var _ in g)
      E[_] = g[_];
  }
  l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? a.exports = c : (v(c, u), u.Buffer = S);
  function S(g, E, _) {
    return l(g, E, _);
  }
  v(l, S), S.from = function(g, E, _) {
    if (typeof g == "number")
      throw new TypeError("Argument must not be a number");
    return l(g, E, _);
  }, S.alloc = function(g, E, _) {
    if (typeof g != "number")
      throw new TypeError("Argument must be a number");
    var k = l(g);
    return E !== void 0 ? typeof _ == "string" ? k.fill(E, _) : k.fill(E) : k.fill(0), k;
  }, S.allocUnsafe = function(g) {
    if (typeof g != "number")
      throw new TypeError("Argument must be a number");
    return l(g);
  }, S.allocUnsafeSlow = function(g) {
    if (typeof g != "number")
      throw new TypeError("Argument must be a number");
    return c.SlowBuffer(g);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports, Buffer$7 = safeBufferExports.Buffer, Stream$2 = require$$0$1, util$3 = require$$0$1;
function DataStream$2(a) {
  if (this.buffer = null, this.writable = !0, this.readable = !0, !a)
    return this.buffer = Buffer$7.alloc(0), this;
  if (typeof a.pipe == "function")
    return this.buffer = Buffer$7.alloc(0), a.pipe(this), this;
  if (a.length || typeof a == "object")
    return this.buffer = a, this.writable = !1, process.nextTick((function() {
      this.emit("end", a), this.readable = !1, this.emit("close");
    }).bind(this)), this;
  throw new TypeError("Unexpected data type (" + typeof a + ")");
}
util$3.inherits(DataStream$2, Stream$2);
DataStream$2.prototype.write = function a(u) {
  this.buffer = Buffer$7.concat([this.buffer, Buffer$7.from(u)]), this.emit("data", u);
};
DataStream$2.prototype.end = function a(u) {
  u && this.write(u), this.emit("end", u), this.emit("close"), this.writable = !1, this.readable = !1;
};
var dataStream = DataStream$2, Buffer$6 = require$$0$1.Buffer, SlowBuffer = require$$0$1.SlowBuffer, bufferEqualConstantTime = bufferEq;
function bufferEq(a, u) {
  if (!Buffer$6.isBuffer(a) || !Buffer$6.isBuffer(u) || a.length !== u.length)
    return !1;
  for (var c = 0, l = 0; l < a.length; l++)
    c |= a[l] ^ u[l];
  return c === 0;
}
bufferEq.install = function() {
  Buffer$6.prototype.equal = SlowBuffer.prototype.equal = function(u) {
    return bufferEq(this, u);
  };
};
var origBufEqual = Buffer$6.prototype.equal, origSlowBufEqual = SlowBuffer.prototype.equal;
bufferEq.restore = function() {
  Buffer$6.prototype.equal = origBufEqual, SlowBuffer.prototype.equal = origSlowBufEqual;
};
function getParamSize(a) {
  var u = (a / 8 | 0) + (a % 8 === 0 ? 0 : 1);
  return u;
}
var paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg$1(a) {
  var u = paramBytesForAlg[a];
  if (u)
    return u;
  throw new Error('Unknown algorithm "' + a + '"');
}
var paramBytesForAlg_1 = getParamBytesForAlg$1, Buffer$5 = safeBufferExports.Buffer, getParamBytesForAlg = paramBytesForAlg_1, MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function base64Url(a) {
  return a.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function signatureAsBuffer(a) {
  if (Buffer$5.isBuffer(a))
    return a;
  if (typeof a == "string")
    return Buffer$5.from(a, "base64");
  throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
}
function derToJose(a, u) {
  a = signatureAsBuffer(a);
  var c = getParamBytesForAlg(u), l = c + 1, v = a.length, S = 0;
  if (a[S++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  var g = a[S++];
  if (g === (MAX_OCTET | 1) && (g = a[S++]), v - S < g)
    throw new Error('"seq" specified length of "' + g + '", only "' + (v - S) + '" remaining');
  if (a[S++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  var E = a[S++];
  if (v - S - 2 < E)
    throw new Error('"r" specified length of "' + E + '", only "' + (v - S - 2) + '" available');
  if (l < E)
    throw new Error('"r" specified length of "' + E + '", max of "' + l + '" is acceptable');
  var _ = S;
  if (S += E, a[S++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  var k = a[S++];
  if (v - S !== k)
    throw new Error('"s" specified length of "' + k + '", expected "' + (v - S) + '"');
  if (l < k)
    throw new Error('"s" specified length of "' + k + '", max of "' + l + '" is acceptable');
  var L = S;
  if (S += k, S !== v)
    throw new Error('Expected to consume entire buffer, but "' + (v - S) + '" bytes remain');
  var M = c - E, $ = c - k, J = Buffer$5.allocUnsafe(M + E + $ + k);
  for (S = 0; S < M; ++S)
    J[S] = 0;
  a.copy(J, S, _ + Math.max(-M, 0), _ + E), S = c;
  for (var V = S; S < V + $; ++S)
    J[S] = 0;
  return a.copy(J, S, L + Math.max(-$, 0), L + k), J = J.toString("base64"), J = base64Url(J), J;
}
function countPadding(a, u, c) {
  for (var l = 0; u + l < c && a[u + l] === 0; )
    ++l;
  var v = a[u + l] >= MAX_OCTET;
  return v && --l, l;
}
function joseToDer(a, u) {
  a = signatureAsBuffer(a);
  var c = getParamBytesForAlg(u), l = a.length;
  if (l !== c * 2)
    throw new TypeError('"' + u + '" signatures must be "' + c * 2 + '" bytes, saw "' + l + '"');
  var v = countPadding(a, 0, c), S = countPadding(a, c, a.length), g = c - v, E = c - S, _ = 2 + g + 1 + 1 + E, k = _ < MAX_OCTET, L = Buffer$5.allocUnsafe((k ? 2 : 3) + _), M = 0;
  return L[M++] = ENCODED_TAG_SEQ, k ? L[M++] = _ : (L[M++] = MAX_OCTET | 1, L[M++] = _ & 255), L[M++] = ENCODED_TAG_INT, L[M++] = g, v < 0 ? (L[M++] = 0, M += a.copy(L, M, 0, c)) : M += a.copy(L, M, v, c), L[M++] = ENCODED_TAG_INT, L[M++] = E, S < 0 ? (L[M++] = 0, a.copy(L, M, c)) : a.copy(L, M, c + S), L;
}
var ecdsaSigFormatter = {
  derToJose,
  joseToDer
}, bufferEqual = bufferEqualConstantTime, Buffer$4 = safeBufferExports.Buffer, crypto$1 = require$$0$1, formatEcdsa = ecdsaSigFormatter, util$2 = require$$0$1, MSG_INVALID_ALGORITHM = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`, MSG_INVALID_SECRET = "secret must be a string or buffer", MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer", MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object", supportsKeyObjects = typeof crypto$1.createPublicKey == "function";
supportsKeyObjects && (MSG_INVALID_VERIFIER_KEY += " or a KeyObject", MSG_INVALID_SECRET += "or a KeyObject");
function checkIsPublicKey(a) {
  if (!Buffer$4.isBuffer(a) && typeof a != "string" && (!supportsKeyObjects || typeof a != "object" || typeof a.type != "string" || typeof a.asymmetricKeyType != "string" || typeof a.export != "function"))
    throw typeError(MSG_INVALID_VERIFIER_KEY);
}
function checkIsPrivateKey(a) {
  if (!Buffer$4.isBuffer(a) && typeof a != "string" && typeof a != "object")
    throw typeError(MSG_INVALID_SIGNER_KEY);
}
function checkIsSecretKey(a) {
  if (!Buffer$4.isBuffer(a)) {
    if (typeof a == "string")
      return a;
    if (!supportsKeyObjects || typeof a != "object" || a.type !== "secret" || typeof a.export != "function")
      throw typeError(MSG_INVALID_SECRET);
  }
}
function fromBase64(a) {
  return a.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBase64(a) {
  a = a.toString();
  var u = 4 - a.length % 4;
  if (u !== 4)
    for (var c = 0; c < u; ++c)
      a += "=";
  return a.replace(/\-/g, "+").replace(/_/g, "/");
}
function typeError(a) {
  var u = [].slice.call(arguments, 1), c = util$2.format.bind(util$2, a).apply(null, u);
  return new TypeError(c);
}
function bufferOrString(a) {
  return Buffer$4.isBuffer(a) || typeof a == "string";
}
function normalizeInput(a) {
  return bufferOrString(a) || (a = JSON.stringify(a)), a;
}
function createHmacSigner(a) {
  return function(c, l) {
    checkIsSecretKey(l), c = normalizeInput(c);
    var v = crypto$1.createHmac("sha" + a, l), S = (v.update(c), v.digest("base64"));
    return fromBase64(S);
  };
}
function createHmacVerifier(a) {
  return function(c, l, v) {
    var S = createHmacSigner(a)(c, v);
    return bufferEqual(Buffer$4.from(l), Buffer$4.from(S));
  };
}
function createKeySigner(a) {
  return function(c, l) {
    checkIsPrivateKey(l), c = normalizeInput(c);
    var v = crypto$1.createSign("RSA-SHA" + a), S = (v.update(c), v.sign(l, "base64"));
    return fromBase64(S);
  };
}
function createKeyVerifier(a) {
  return function(c, l, v) {
    checkIsPublicKey(v), c = normalizeInput(c), l = toBase64(l);
    var S = crypto$1.createVerify("RSA-SHA" + a);
    return S.update(c), S.verify(v, l, "base64");
  };
}
function createPSSKeySigner(a) {
  return function(c, l) {
    checkIsPrivateKey(l), c = normalizeInput(c);
    var v = crypto$1.createSign("RSA-SHA" + a), S = (v.update(c), v.sign({
      key: l,
      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
    }, "base64"));
    return fromBase64(S);
  };
}
function createPSSKeyVerifier(a) {
  return function(c, l, v) {
    checkIsPublicKey(v), c = normalizeInput(c), l = toBase64(l);
    var S = crypto$1.createVerify("RSA-SHA" + a);
    return S.update(c), S.verify({
      key: v,
      padding: crypto$1.constants.RSA_PKCS1_PSS_PADDING,
      saltLength: crypto$1.constants.RSA_PSS_SALTLEN_DIGEST
    }, l, "base64");
  };
}
function createECDSASigner(a) {
  var u = createKeySigner(a);
  return function() {
    var l = u.apply(null, arguments);
    return l = formatEcdsa.derToJose(l, "ES" + a), l;
  };
}
function createECDSAVerifer(a) {
  var u = createKeyVerifier(a);
  return function(l, v, S) {
    v = formatEcdsa.joseToDer(v, "ES" + a).toString("base64");
    var g = u(l, v, S);
    return g;
  };
}
function createNoneSigner() {
  return function() {
    return "";
  };
}
function createNoneVerifier() {
  return function(u, c) {
    return c === "";
  };
}
var jwa$2 = function a(u) {
  var c = {
    hs: createHmacSigner,
    rs: createKeySigner,
    ps: createPSSKeySigner,
    es: createECDSASigner,
    none: createNoneSigner
  }, l = {
    hs: createHmacVerifier,
    rs: createKeyVerifier,
    ps: createPSSKeyVerifier,
    es: createECDSAVerifer,
    none: createNoneVerifier
  }, v = u.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
  if (!v)
    throw typeError(MSG_INVALID_ALGORITHM, u);
  var S = (v[1] || v[3]).toLowerCase(), g = v[2];
  return {
    sign: c[S](g),
    verify: l[S](g)
  };
}, Buffer$3 = require$$0$1.Buffer, tostring = function a(u) {
  return typeof u == "string" ? u : typeof u == "number" || Buffer$3.isBuffer(u) ? u.toString() : JSON.stringify(u);
}, Buffer$2 = safeBufferExports.Buffer, DataStream$1 = dataStream, jwa$1 = jwa$2, Stream$1 = require$$0$1, toString$2 = tostring, util$1 = require$$0$1;
function base64url(a, u) {
  return Buffer$2.from(a, u).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function jwsSecuredInput(a, u, c) {
  c = c || "utf8";
  var l = base64url(toString$2(a), "binary"), v = base64url(toString$2(u), c);
  return util$1.format("%s.%s", l, v);
}
function jwsSign(a) {
  var u = a.header, c = a.payload, l = a.secret || a.privateKey, v = a.encoding, S = jwa$1(u.alg), g = jwsSecuredInput(u, c, v), E = S.sign(g, l);
  return util$1.format("%s.%s", g, E);
}
function SignStream$1(a) {
  var u = a.secret || a.privateKey || a.key, c = new DataStream$1(u);
  this.readable = !0, this.header = a.header, this.encoding = a.encoding, this.secret = this.privateKey = this.key = c, this.payload = new DataStream$1(a.payload), this.secret.once("close", (function() {
    !this.payload.writable && this.readable && this.sign();
  }).bind(this)), this.payload.once("close", (function() {
    !this.secret.writable && this.readable && this.sign();
  }).bind(this));
}
util$1.inherits(SignStream$1, Stream$1);
SignStream$1.prototype.sign = function a() {
  try {
    var u = jwsSign({
      header: this.header,
      payload: this.payload.buffer,
      secret: this.secret.buffer,
      encoding: this.encoding
    });
    return this.emit("done", u), this.emit("data", u), this.emit("end"), this.readable = !1, u;
  } catch (c) {
    this.readable = !1, this.emit("error", c), this.emit("close");
  }
};
SignStream$1.sign = jwsSign;
var signStream = SignStream$1, Buffer$1 = safeBufferExports.Buffer, DataStream = dataStream, jwa = jwa$2, Stream = require$$0$1, toString$1 = tostring, util = require$$0$1, JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
function isObject$7(a) {
  return Object.prototype.toString.call(a) === "[object Object]";
}
function safeJsonParse(a) {
  if (isObject$7(a))
    return a;
  try {
    return JSON.parse(a);
  } catch {
    return;
  }
}
function headerFromJWS(a) {
  var u = a.split(".", 1)[0];
  return safeJsonParse(Buffer$1.from(u, "base64").toString("binary"));
}
function securedInputFromJWS(a) {
  return a.split(".", 2).join(".");
}
function signatureFromJWS(a) {
  return a.split(".")[2];
}
function payloadFromJWS(a, u) {
  u = u || "utf8";
  var c = a.split(".")[1];
  return Buffer$1.from(c, "base64").toString(u);
}
function isValidJws(a) {
  return JWS_REGEX.test(a) && !!headerFromJWS(a);
}
function jwsVerify(a, u, c) {
  if (!u) {
    var l = new Error("Missing algorithm parameter for jws.verify");
    throw l.code = "MISSING_ALGORITHM", l;
  }
  a = toString$1(a);
  var v = signatureFromJWS(a), S = securedInputFromJWS(a), g = jwa(u);
  return g.verify(S, v, c);
}
function jwsDecode(a, u) {
  if (u = u || {}, a = toString$1(a), !isValidJws(a))
    return null;
  var c = headerFromJWS(a);
  if (!c)
    return null;
  var l = payloadFromJWS(a);
  return (c.typ === "JWT" || u.json) && (l = JSON.parse(l, u.encoding)), {
    header: c,
    payload: l,
    signature: signatureFromJWS(a)
  };
}
function VerifyStream$1(a) {
  a = a || {};
  var u = a.secret || a.publicKey || a.key, c = new DataStream(u);
  this.readable = !0, this.algorithm = a.algorithm, this.encoding = a.encoding, this.secret = this.publicKey = this.key = c, this.signature = new DataStream(a.signature), this.secret.once("close", (function() {
    !this.signature.writable && this.readable && this.verify();
  }).bind(this)), this.signature.once("close", (function() {
    !this.secret.writable && this.readable && this.verify();
  }).bind(this));
}
util.inherits(VerifyStream$1, Stream);
VerifyStream$1.prototype.verify = function a() {
  try {
    var u = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer), c = jwsDecode(this.signature.buffer, this.encoding);
    return this.emit("done", u, c), this.emit("data", u), this.emit("end"), this.readable = !1, u;
  } catch (l) {
    this.readable = !1, this.emit("error", l), this.emit("close");
  }
};
VerifyStream$1.decode = jwsDecode;
VerifyStream$1.isValid = isValidJws;
VerifyStream$1.verify = jwsVerify;
var verifyStream = VerifyStream$1, SignStream = signStream, VerifyStream = verifyStream, ALGORITHMS = [
  "HS256",
  "HS384",
  "HS512",
  "RS256",
  "RS384",
  "RS512",
  "PS256",
  "PS384",
  "PS512",
  "ES256",
  "ES384",
  "ES512"
];
jws$3.ALGORITHMS = ALGORITHMS;
jws$3.sign = SignStream.sign;
jws$3.verify = VerifyStream.verify;
jws$3.decode = VerifyStream.decode;
jws$3.isValid = VerifyStream.isValid;
jws$3.createSign = function a(u) {
  return new SignStream(u);
};
jws$3.createVerify = function a(u) {
  return new VerifyStream(u);
};
var jws$2 = jws$3, decode$1 = function(a, u) {
  u = u || {};
  var c = jws$2.decode(a, u);
  if (!c)
    return null;
  var l = c.payload;
  if (typeof l == "string")
    try {
      var v = JSON.parse(l);
      v !== null && typeof v == "object" && (l = v);
    } catch {
    }
  return u.complete === !0 ? {
    header: c.header,
    payload: l,
    signature: c.signature
  } : l;
}, JsonWebTokenError$3 = function(a, u) {
  Error.call(this, a), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.name = "JsonWebTokenError", this.message = a, u && (this.inner = u);
};
JsonWebTokenError$3.prototype = Object.create(Error.prototype);
JsonWebTokenError$3.prototype.constructor = JsonWebTokenError$3;
var JsonWebTokenError_1 = JsonWebTokenError$3, JsonWebTokenError$2 = JsonWebTokenError_1, NotBeforeError$1 = function(a, u) {
  JsonWebTokenError$2.call(this, a), this.name = "NotBeforeError", this.date = u;
};
NotBeforeError$1.prototype = Object.create(JsonWebTokenError$2.prototype);
NotBeforeError$1.prototype.constructor = NotBeforeError$1;
var NotBeforeError_1 = NotBeforeError$1, JsonWebTokenError$1 = JsonWebTokenError_1, TokenExpiredError$1 = function(a, u) {
  JsonWebTokenError$1.call(this, a), this.name = "TokenExpiredError", this.expiredAt = u;
};
TokenExpiredError$1.prototype = Object.create(JsonWebTokenError$1.prototype);
TokenExpiredError$1.prototype.constructor = TokenExpiredError$1;
var TokenExpiredError_1 = TokenExpiredError$1, s = 1e3, m = s * 60, h = m * 60, d = h * 24, w = d * 7, y = d * 365.25, ms$1 = function(a, u) {
  u = u || {};
  var c = typeof a;
  if (c === "string" && a.length > 0)
    return parse$2(a);
  if (c === "number" && isFinite(a))
    return u.long ? fmtLong(a) : fmtShort(a);
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(a)
  );
};
function parse$2(a) {
  if (a = String(a), !(a.length > 100)) {
    var u = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      a
    );
    if (u) {
      var c = parseFloat(u[1]), l = (u[2] || "ms").toLowerCase();
      switch (l) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return c * y;
        case "weeks":
        case "week":
        case "w":
          return c * w;
        case "days":
        case "day":
        case "d":
          return c * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return c * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return c * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return c * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return c;
        default:
          return;
      }
    }
  }
}
function fmtShort(a) {
  var u = Math.abs(a);
  return u >= d ? Math.round(a / d) + "d" : u >= h ? Math.round(a / h) + "h" : u >= m ? Math.round(a / m) + "m" : u >= s ? Math.round(a / s) + "s" : a + "ms";
}
function fmtLong(a) {
  var u = Math.abs(a);
  return u >= d ? plural(a, u, d, "day") : u >= h ? plural(a, u, h, "hour") : u >= m ? plural(a, u, m, "minute") : u >= s ? plural(a, u, s, "second") : a + " ms";
}
function plural(a, u, c, l) {
  var v = u >= c * 1.5;
  return Math.round(a / c) + " " + l + (v ? "s" : "");
}
var ms = ms$1, timespan$2 = function(a, u) {
  var c = u || Math.floor(Date.now() / 1e3);
  if (typeof a == "string") {
    var l = ms(a);
    return typeof l > "u" ? void 0 : Math.floor(c + l / 1e3);
  } else
    return typeof a == "number" ? c + a : void 0;
}, semver$1 = { exports: {} };
(function(a, u) {
  u = a.exports = Ie;
  var c;
  typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? c = function() {
    var pe = Array.prototype.slice.call(arguments, 0);
    pe.unshift("SEMVER"), console.log.apply(console, pe);
  } : c = function() {
  }, u.SEMVER_SPEC_VERSION = "2.0.0";
  var l = 256, v = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, S = 16, g = u.re = [], E = u.src = [], _ = 0, k = _++;
  E[k] = "0|[1-9]\\d*";
  var L = _++;
  E[L] = "[0-9]+";
  var M = _++;
  E[M] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
  var $ = _++;
  E[$] = "(" + E[k] + ")\\.(" + E[k] + ")\\.(" + E[k] + ")";
  var J = _++;
  E[J] = "(" + E[L] + ")\\.(" + E[L] + ")\\.(" + E[L] + ")";
  var V = _++;
  E[V] = "(?:" + E[k] + "|" + E[M] + ")";
  var q = _++;
  E[q] = "(?:" + E[L] + "|" + E[M] + ")";
  var G = _++;
  E[G] = "(?:-(" + E[V] + "(?:\\." + E[V] + ")*))";
  var H = _++;
  E[H] = "(?:-?(" + E[q] + "(?:\\." + E[q] + ")*))";
  var B = _++;
  E[B] = "[0-9A-Za-z-]+";
  var Y = _++;
  E[Y] = "(?:\\+(" + E[B] + "(?:\\." + E[B] + ")*))";
  var ne = _++, Z = "v?" + E[$] + E[G] + "?" + E[Y] + "?";
  E[ne] = "^" + Z + "$";
  var re = "[v=\\s]*" + E[J] + E[H] + "?" + E[Y] + "?", oe = _++;
  E[oe] = "^" + re + "$";
  var de = _++;
  E[de] = "((?:<|>)?=?)";
  var A = _++;
  E[A] = E[L] + "|x|X|\\*";
  var N = _++;
  E[N] = E[k] + "|x|X|\\*";
  var D = _++;
  E[D] = "[v=\\s]*(" + E[N] + ")(?:\\.(" + E[N] + ")(?:\\.(" + E[N] + ")(?:" + E[G] + ")?" + E[Y] + "?)?)?";
  var W = _++;
  E[W] = "[v=\\s]*(" + E[A] + ")(?:\\.(" + E[A] + ")(?:\\.(" + E[A] + ")(?:" + E[H] + ")?" + E[Y] + "?)?)?";
  var ee = _++;
  E[ee] = "^" + E[de] + "\\s*" + E[D] + "$";
  var ae = _++;
  E[ae] = "^" + E[de] + "\\s*" + E[W] + "$";
  var ye = _++;
  E[ye] = "(?:^|[^\\d])(\\d{1," + S + "})(?:\\.(\\d{1," + S + "}))?(?:\\.(\\d{1," + S + "}))?(?:$|[^\\d])";
  var he = _++;
  E[he] = "(?:~>?)";
  var le = _++;
  E[le] = "(\\s*)" + E[he] + "\\s+", g[le] = new RegExp(E[le], "g");
  var we = "$1~", Be = _++;
  E[Be] = "^" + E[he] + E[D] + "$";
  var Ne = _++;
  E[Ne] = "^" + E[he] + E[W] + "$";
  var Le = _++;
  E[Le] = "(?:\\^)";
  var $e = _++;
  E[$e] = "(\\s*)" + E[Le] + "\\s+", g[$e] = new RegExp(E[$e], "g");
  var Ue = "$1^", Ge = _++;
  E[Ge] = "^" + E[Le] + E[D] + "$";
  var He = _++;
  E[He] = "^" + E[Le] + E[W] + "$";
  var Ve = _++;
  E[Ve] = "^" + E[de] + "\\s*(" + re + ")$|^$";
  var be = _++;
  E[be] = "^" + E[de] + "\\s*(" + Z + ")$|^$";
  var Ae = _++;
  E[Ae] = "(\\s*)" + E[de] + "\\s*(" + re + "|" + E[D] + ")", g[Ae] = new RegExp(E[Ae], "g");
  var qe = "$1$2$3", xe = _++;
  E[xe] = "^\\s*(" + E[D] + ")\\s+-\\s+(" + E[D] + ")\\s*$";
  var Pe = _++;
  E[Pe] = "^\\s*(" + E[W] + ")\\s+-\\s+(" + E[W] + ")\\s*$";
  var C = _++;
  E[C] = "(<|>)?=?\\s*\\*";
  for (var x = 0; x < _; x++)
    c(x, E[x]), g[x] || (g[x] = new RegExp(E[x]));
  u.parse = Q;
  function Q(pe, ge) {
    if ((!ge || typeof ge != "object") && (ge = {
      loose: !!ge,
      includePrerelease: !1
    }), pe instanceof Ie)
      return pe;
    if (typeof pe != "string" || pe.length > l)
      return null;
    var Re = ge.loose ? g[oe] : g[ne];
    if (!Re.test(pe))
      return null;
    try {
      return new Ie(pe, ge);
    } catch {
      return null;
    }
  }
  u.valid = Se;
  function Se(pe, ge) {
    var Re = Q(pe, ge);
    return Re ? Re.version : null;
  }
  u.clean = me;
  function me(pe, ge) {
    var Re = Q(pe.trim().replace(/^[=v]+/, ""), ge);
    return Re ? Re.version : null;
  }
  u.SemVer = Ie;
  function Ie(pe, ge) {
    if ((!ge || typeof ge != "object") && (ge = {
      loose: !!ge,
      includePrerelease: !1
    }), pe instanceof Ie) {
      if (pe.loose === ge.loose)
        return pe;
      pe = pe.version;
    } else if (typeof pe != "string")
      throw new TypeError("Invalid Version: " + pe);
    if (pe.length > l)
      throw new TypeError("version is longer than " + l + " characters");
    if (!(this instanceof Ie))
      return new Ie(pe, ge);
    c("SemVer", pe, ge), this.options = ge, this.loose = !!ge.loose;
    var Re = pe.trim().match(ge.loose ? g[oe] : g[ne]);
    if (!Re)
      throw new TypeError("Invalid Version: " + pe);
    if (this.raw = pe, this.major = +Re[1], this.minor = +Re[2], this.patch = +Re[3], this.major > v || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > v || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > v || this.patch < 0)
      throw new TypeError("Invalid patch version");
    Re[4] ? this.prerelease = Re[4].split(".").map(function(Je) {
      if (/^[0-9]+$/.test(Je)) {
        var Fe = +Je;
        if (Fe >= 0 && Fe < v)
          return Fe;
      }
      return Je;
    }) : this.prerelease = [], this.build = Re[5] ? Re[5].split(".") : [], this.format();
  }
  Ie.prototype.format = function() {
    return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
  }, Ie.prototype.toString = function() {
    return this.version;
  }, Ie.prototype.compare = function(pe) {
    return c("SemVer.compare", this.version, this.options, pe), pe instanceof Ie || (pe = new Ie(pe, this.options)), this.compareMain(pe) || this.comparePre(pe);
  }, Ie.prototype.compareMain = function(pe) {
    return pe instanceof Ie || (pe = new Ie(pe, this.options)), tt(this.major, pe.major) || tt(this.minor, pe.minor) || tt(this.patch, pe.patch);
  }, Ie.prototype.comparePre = function(pe) {
    if (pe instanceof Ie || (pe = new Ie(pe, this.options)), this.prerelease.length && !pe.prerelease.length)
      return -1;
    if (!this.prerelease.length && pe.prerelease.length)
      return 1;
    if (!this.prerelease.length && !pe.prerelease.length)
      return 0;
    var ge = 0;
    do {
      var Re = this.prerelease[ge], Je = pe.prerelease[ge];
      if (c("prerelease compare", ge, Re, Je), Re === void 0 && Je === void 0)
        return 0;
      if (Je === void 0)
        return 1;
      if (Re === void 0)
        return -1;
      if (Re === Je)
        continue;
      return tt(Re, Je);
    } while (++ge);
  }, Ie.prototype.inc = function(pe, ge) {
    switch (pe) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", ge);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", ge);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", ge), this.inc("pre", ge);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", ge), this.inc("pre", ge);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0)
          this.prerelease = [0];
        else {
          for (var Re = this.prerelease.length; --Re >= 0; )
            typeof this.prerelease[Re] == "number" && (this.prerelease[Re]++, Re = -2);
          Re === -1 && this.prerelease.push(0);
        }
        ge && (this.prerelease[0] === ge ? isNaN(this.prerelease[1]) && (this.prerelease = [ge, 0]) : this.prerelease = [ge, 0]);
        break;
      default:
        throw new Error("invalid increment argument: " + pe);
    }
    return this.format(), this.raw = this.version, this;
  }, u.inc = at;
  function at(pe, ge, Re, Je) {
    typeof Re == "string" && (Je = Re, Re = void 0);
    try {
      return new Ie(pe, Re).inc(ge, Je).version;
    } catch {
      return null;
    }
  }
  u.diff = Ye;
  function Ye(pe, ge) {
    if (De(pe, ge))
      return null;
    var Re = Q(pe), Je = Q(ge), Fe = "";
    if (Re.prerelease.length || Je.prerelease.length) {
      Fe = "pre";
      var ze = "prerelease";
    }
    for (var Me in Re)
      if ((Me === "major" || Me === "minor" || Me === "patch") && Re[Me] !== Je[Me])
        return Fe + Me;
    return ze;
  }
  u.compareIdentifiers = tt;
  var je = /^[0-9]+$/;
  function tt(pe, ge) {
    var Re = je.test(pe), Je = je.test(ge);
    return Re && Je && (pe = +pe, ge = +ge), pe === ge ? 0 : Re && !Je ? -1 : Je && !Re ? 1 : pe < ge ? -1 : 1;
  }
  u.rcompareIdentifiers = Oe;
  function Oe(pe, ge) {
    return tt(ge, pe);
  }
  u.major = P;
  function P(pe, ge) {
    return new Ie(pe, ge).major;
  }
  u.minor = X;
  function X(pe, ge) {
    return new Ie(pe, ge).minor;
  }
  u.patch = ie;
  function ie(pe, ge) {
    return new Ie(pe, ge).patch;
  }
  u.compare = Ee;
  function Ee(pe, ge, Re) {
    return new Ie(pe, Re).compare(new Ie(ge, Re));
  }
  u.compareLoose = ue;
  function ue(pe, ge) {
    return Ee(pe, ge, !0);
  }
  u.rcompare = O;
  function O(pe, ge, Re) {
    return Ee(ge, pe, Re);
  }
  u.sort = j;
  function j(pe, ge) {
    return pe.sort(function(Re, Je) {
      return u.compare(Re, Je, ge);
    });
  }
  u.rsort = se;
  function se(pe, ge) {
    return pe.sort(function(Re, Je) {
      return u.rcompare(Re, Je, ge);
    });
  }
  u.gt = _e;
  function _e(pe, ge, Re) {
    return Ee(pe, ge, Re) > 0;
  }
  u.lt = ve;
  function ve(pe, ge, Re) {
    return Ee(pe, ge, Re) < 0;
  }
  u.eq = De;
  function De(pe, ge, Re) {
    return Ee(pe, ge, Re) === 0;
  }
  u.neq = Ze;
  function Ze(pe, ge, Re) {
    return Ee(pe, ge, Re) !== 0;
  }
  u.gte = Qe;
  function Qe(pe, ge, Re) {
    return Ee(pe, ge, Re) >= 0;
  }
  u.lte = ot;
  function ot(pe, ge, Re) {
    return Ee(pe, ge, Re) <= 0;
  }
  u.cmp = ft;
  function ft(pe, ge, Re, Je) {
    switch (ge) {
      case "===":
        return typeof pe == "object" && (pe = pe.version), typeof Re == "object" && (Re = Re.version), pe === Re;
      case "!==":
        return typeof pe == "object" && (pe = pe.version), typeof Re == "object" && (Re = Re.version), pe !== Re;
      case "":
      case "=":
      case "==":
        return De(pe, Re, Je);
      case "!=":
        return Ze(pe, Re, Je);
      case ">":
        return _e(pe, Re, Je);
      case ">=":
        return Qe(pe, Re, Je);
      case "<":
        return ve(pe, Re, Je);
      case "<=":
        return ot(pe, Re, Je);
      default:
        throw new TypeError("Invalid operator: " + ge);
    }
  }
  u.Comparator = Ce;
  function Ce(pe, ge) {
    if ((!ge || typeof ge != "object") && (ge = {
      loose: !!ge,
      includePrerelease: !1
    }), pe instanceof Ce) {
      if (pe.loose === !!ge.loose)
        return pe;
      pe = pe.value;
    }
    if (!(this instanceof Ce))
      return new Ce(pe, ge);
    c("comparator", pe, ge), this.options = ge, this.loose = !!ge.loose, this.parse(pe), this.semver === I ? this.value = "" : this.value = this.operator + this.semver.version, c("comp", this);
  }
  var I = {};
  Ce.prototype.parse = function(pe) {
    var ge = this.options.loose ? g[Ve] : g[be], Re = pe.match(ge);
    if (!Re)
      throw new TypeError("Invalid comparator: " + pe);
    this.operator = Re[1], this.operator === "=" && (this.operator = ""), Re[2] ? this.semver = new Ie(Re[2], this.options.loose) : this.semver = I;
  }, Ce.prototype.toString = function() {
    return this.value;
  }, Ce.prototype.test = function(pe) {
    return c("Comparator.test", pe, this.options.loose), this.semver === I ? !0 : (typeof pe == "string" && (pe = new Ie(pe, this.options)), ft(pe, this.operator, this.semver, this.options));
  }, Ce.prototype.intersects = function(pe, ge) {
    if (!(pe instanceof Ce))
      throw new TypeError("a Comparator is required");
    (!ge || typeof ge != "object") && (ge = {
      loose: !!ge,
      includePrerelease: !1
    });
    var Re;
    if (this.operator === "")
      return Re = new F(pe.value, ge), St(this.value, Re, ge);
    if (pe.operator === "")
      return Re = new F(this.value, ge), St(pe.semver, Re, ge);
    var Je = (this.operator === ">=" || this.operator === ">") && (pe.operator === ">=" || pe.operator === ">"), Fe = (this.operator === "<=" || this.operator === "<") && (pe.operator === "<=" || pe.operator === "<"), ze = this.semver.version === pe.semver.version, Me = (this.operator === ">=" || this.operator === "<=") && (pe.operator === ">=" || pe.operator === "<="), nt = ft(this.semver, "<", pe.semver, ge) && (this.operator === ">=" || this.operator === ">") && (pe.operator === "<=" || pe.operator === "<"), rt = ft(this.semver, ">", pe.semver, ge) && (this.operator === "<=" || this.operator === "<") && (pe.operator === ">=" || pe.operator === ">");
    return Je || Fe || ze && Me || nt || rt;
  }, u.Range = F;
  function F(pe, ge) {
    if ((!ge || typeof ge != "object") && (ge = {
      loose: !!ge,
      includePrerelease: !1
    }), pe instanceof F)
      return pe.loose === !!ge.loose && pe.includePrerelease === !!ge.includePrerelease ? pe : new F(pe.raw, ge);
    if (pe instanceof Ce)
      return new F(pe.value, ge);
    if (!(this instanceof F))
      return new F(pe, ge);
    if (this.options = ge, this.loose = !!ge.loose, this.includePrerelease = !!ge.includePrerelease, this.raw = pe, this.set = pe.split(/\s*\|\|\s*/).map(function(Re) {
      return this.parseRange(Re.trim());
    }, this).filter(function(Re) {
      return Re.length;
    }), !this.set.length)
      throw new TypeError("Invalid SemVer Range: " + pe);
    this.format();
  }
  F.prototype.format = function() {
    return this.range = this.set.map(function(pe) {
      return pe.join(" ").trim();
    }).join("||").trim(), this.range;
  }, F.prototype.toString = function() {
    return this.range;
  }, F.prototype.parseRange = function(pe) {
    var ge = this.options.loose;
    pe = pe.trim();
    var Re = ge ? g[Pe] : g[xe];
    pe = pe.replace(Re, gt), c("hyphen replace", pe), pe = pe.replace(g[Ae], qe), c("comparator trim", pe, g[Ae]), pe = pe.replace(g[le], we), pe = pe.replace(g[$e], Ue), pe = pe.split(/\s+/).join(" ");
    var Je = ge ? g[Ve] : g[be], Fe = pe.split(" ").map(function(ze) {
      return Te(ze, this.options);
    }, this).join(" ").split(/\s+/);
    return this.options.loose && (Fe = Fe.filter(function(ze) {
      return !!ze.match(Je);
    })), Fe = Fe.map(function(ze) {
      return new Ce(ze, this.options);
    }, this), Fe;
  }, F.prototype.intersects = function(pe, ge) {
    if (!(pe instanceof F))
      throw new TypeError("a Range is required");
    return this.set.some(function(Re) {
      return Re.every(function(Je) {
        return pe.set.some(function(Fe) {
          return Fe.every(function(ze) {
            return Je.intersects(ze, ge);
          });
        });
      });
    });
  }, u.toComparators = z;
  function z(pe, ge) {
    return new F(pe, ge).set.map(function(Re) {
      return Re.map(function(Je) {
        return Je.value;
      }).join(" ").trim().split(" ");
    });
  }
  function Te(pe, ge) {
    return c("comp", pe, ge), pe = mt(pe, ge), c("caret", pe), pe = ke(pe, ge), c("tildes", pe), pe = st(pe, ge), c("xrange", pe), pe = yt(pe, ge), c("stars", pe), pe;
  }
  function fe(pe) {
    return !pe || pe.toLowerCase() === "x" || pe === "*";
  }
  function ke(pe, ge) {
    return pe.trim().split(/\s+/).map(function(Re) {
      return it(Re, ge);
    }).join(" ");
  }
  function it(pe, ge) {
    var Re = ge.loose ? g[Ne] : g[Be];
    return pe.replace(Re, function(Je, Fe, ze, Me, nt) {
      c("tilde", pe, Je, Fe, ze, Me, nt);
      var rt;
      return fe(Fe) ? rt = "" : fe(ze) ? rt = ">=" + Fe + ".0.0 <" + (+Fe + 1) + ".0.0" : fe(Me) ? rt = ">=" + Fe + "." + ze + ".0 <" + Fe + "." + (+ze + 1) + ".0" : nt ? (c("replaceTilde pr", nt), rt = ">=" + Fe + "." + ze + "." + Me + "-" + nt + " <" + Fe + "." + (+ze + 1) + ".0") : rt = ">=" + Fe + "." + ze + "." + Me + " <" + Fe + "." + (+ze + 1) + ".0", c("tilde return", rt), rt;
    });
  }
  function mt(pe, ge) {
    return pe.trim().split(/\s+/).map(function(Re) {
      return vt(Re, ge);
    }).join(" ");
  }
  function vt(pe, ge) {
    c("caret", pe, ge);
    var Re = ge.loose ? g[He] : g[Ge];
    return pe.replace(Re, function(Je, Fe, ze, Me, nt) {
      c("caret", pe, Je, Fe, ze, Me, nt);
      var rt;
      return fe(Fe) ? rt = "" : fe(ze) ? rt = ">=" + Fe + ".0.0 <" + (+Fe + 1) + ".0.0" : fe(Me) ? Fe === "0" ? rt = ">=" + Fe + "." + ze + ".0 <" + Fe + "." + (+ze + 1) + ".0" : rt = ">=" + Fe + "." + ze + ".0 <" + (+Fe + 1) + ".0.0" : nt ? (c("replaceCaret pr", nt), Fe === "0" ? ze === "0" ? rt = ">=" + Fe + "." + ze + "." + Me + "-" + nt + " <" + Fe + "." + ze + "." + (+Me + 1) : rt = ">=" + Fe + "." + ze + "." + Me + "-" + nt + " <" + Fe + "." + (+ze + 1) + ".0" : rt = ">=" + Fe + "." + ze + "." + Me + "-" + nt + " <" + (+Fe + 1) + ".0.0") : (c("no pr"), Fe === "0" ? ze === "0" ? rt = ">=" + Fe + "." + ze + "." + Me + " <" + Fe + "." + ze + "." + (+Me + 1) : rt = ">=" + Fe + "." + ze + "." + Me + " <" + Fe + "." + (+ze + 1) + ".0" : rt = ">=" + Fe + "." + ze + "." + Me + " <" + (+Fe + 1) + ".0.0"), c("caret return", rt), rt;
    });
  }
  function st(pe, ge) {
    return c("replaceXRanges", pe, ge), pe.split(/\s+/).map(function(Re) {
      return ut(Re, ge);
    }).join(" ");
  }
  function ut(pe, ge) {
    pe = pe.trim();
    var Re = ge.loose ? g[ae] : g[ee];
    return pe.replace(Re, function(Je, Fe, ze, Me, nt, rt) {
      c("xRange", pe, Je, Fe, ze, Me, nt, rt);
      var Tt = fe(ze), kt = Tt || fe(Me), It = kt || fe(nt), _t = It;
      return Fe === "=" && _t && (Fe = ""), Tt ? Fe === ">" || Fe === "<" ? Je = "<0.0.0" : Je = "*" : Fe && _t ? (kt && (Me = 0), nt = 0, Fe === ">" ? (Fe = ">=", kt ? (ze = +ze + 1, Me = 0, nt = 0) : (Me = +Me + 1, nt = 0)) : Fe === "<=" && (Fe = "<", kt ? ze = +ze + 1 : Me = +Me + 1), Je = Fe + ze + "." + Me + "." + nt) : kt ? Je = ">=" + ze + ".0.0 <" + (+ze + 1) + ".0.0" : It && (Je = ">=" + ze + "." + Me + ".0 <" + ze + "." + (+Me + 1) + ".0"), c("xRange return", Je), Je;
    });
  }
  function yt(pe, ge) {
    return c("replaceStars", pe, ge), pe.trim().replace(g[C], "");
  }
  function gt(pe, ge, Re, Je, Fe, ze, Me, nt, rt, Tt, kt, It, _t) {
    return fe(Re) ? ge = "" : fe(Je) ? ge = ">=" + Re + ".0.0" : fe(Fe) ? ge = ">=" + Re + "." + Je + ".0" : ge = ">=" + ge, fe(rt) ? nt = "" : fe(Tt) ? nt = "<" + (+rt + 1) + ".0.0" : fe(kt) ? nt = "<" + rt + "." + (+Tt + 1) + ".0" : It ? nt = "<=" + rt + "." + Tt + "." + kt + "-" + It : nt = "<=" + nt, (ge + " " + nt).trim();
  }
  F.prototype.test = function(pe) {
    if (!pe)
      return !1;
    typeof pe == "string" && (pe = new Ie(pe, this.options));
    for (var ge = 0; ge < this.set.length; ge++)
      if (bt(this.set[ge], pe, this.options))
        return !0;
    return !1;
  };
  function bt(pe, ge, Re) {
    for (var Je = 0; Je < pe.length; Je++)
      if (!pe[Je].test(ge))
        return !1;
    if (ge.prerelease.length && !Re.includePrerelease) {
      for (Je = 0; Je < pe.length; Je++)
        if (c(pe[Je].semver), pe[Je].semver !== I && pe[Je].semver.prerelease.length > 0) {
          var Fe = pe[Je].semver;
          if (Fe.major === ge.major && Fe.minor === ge.minor && Fe.patch === ge.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  }
  u.satisfies = St;
  function St(pe, ge, Re) {
    try {
      ge = new F(ge, Re);
    } catch {
      return !1;
    }
    return ge.test(pe);
  }
  u.maxSatisfying = Et;
  function Et(pe, ge, Re) {
    var Je = null, Fe = null;
    try {
      var ze = new F(ge, Re);
    } catch {
      return null;
    }
    return pe.forEach(function(Me) {
      ze.test(Me) && (!Je || Fe.compare(Me) === -1) && (Je = Me, Fe = new Ie(Je, Re));
    }), Je;
  }
  u.minSatisfying = ct;
  function ct(pe, ge, Re) {
    var Je = null, Fe = null;
    try {
      var ze = new F(ge, Re);
    } catch {
      return null;
    }
    return pe.forEach(function(Me) {
      ze.test(Me) && (!Je || Fe.compare(Me) === 1) && (Je = Me, Fe = new Ie(Je, Re));
    }), Je;
  }
  u.minVersion = Xe;
  function Xe(pe, ge) {
    pe = new F(pe, ge);
    var Re = new Ie("0.0.0");
    if (pe.test(Re) || (Re = new Ie("0.0.0-0"), pe.test(Re)))
      return Re;
    Re = null;
    for (var Je = 0; Je < pe.set.length; ++Je) {
      var Fe = pe.set[Je];
      Fe.forEach(function(ze) {
        var Me = new Ie(ze.semver.version);
        switch (ze.operator) {
          case ">":
            Me.prerelease.length === 0 ? Me.patch++ : Me.prerelease.push(0), Me.raw = Me.format();
          case "":
          case ">=":
            (!Re || _e(Re, Me)) && (Re = Me);
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error("Unexpected operation: " + ze.operator);
        }
      });
    }
    return Re && pe.test(Re) ? Re : null;
  }
  u.validRange = Ct;
  function Ct(pe, ge) {
    try {
      return new F(pe, ge).range || "*";
    } catch {
      return null;
    }
  }
  u.ltr = Ot;
  function Ot(pe, ge, Re) {
    return Pt(pe, ge, "<", Re);
  }
  u.gtr = Nt;
  function Nt(pe, ge, Re) {
    return Pt(pe, ge, ">", Re);
  }
  u.outside = Pt;
  function Pt(pe, ge, Re, Je) {
    pe = new Ie(pe, Je), ge = new F(ge, Je);
    var Fe, ze, Me, nt, rt;
    switch (Re) {
      case ">":
        Fe = _e, ze = ot, Me = ve, nt = ">", rt = ">=";
        break;
      case "<":
        Fe = ve, ze = Qe, Me = _e, nt = "<", rt = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (St(pe, ge, Je))
      return !1;
    for (var Tt = 0; Tt < ge.set.length; ++Tt) {
      var kt = ge.set[Tt], It = null, _t = null;
      if (kt.forEach(function(Rt) {
        Rt.semver === I && (Rt = new Ce(">=0.0.0")), It = It || Rt, _t = _t || Rt, Fe(Rt.semver, It.semver, Je) ? It = Rt : Me(Rt.semver, _t.semver, Je) && (_t = Rt);
      }), It.operator === nt || It.operator === rt || (!_t.operator || _t.operator === nt) && ze(pe, _t.semver))
        return !1;
      if (_t.operator === rt && Me(pe, _t.semver))
        return !1;
    }
    return !0;
  }
  u.prerelease = wt;
  function wt(pe, ge) {
    var Re = Q(pe, ge);
    return Re && Re.prerelease.length ? Re.prerelease : null;
  }
  u.intersects = At;
  function At(pe, ge, Re) {
    return pe = new F(pe, Re), ge = new F(ge, Re), pe.intersects(ge);
  }
  u.coerce = Dt;
  function Dt(pe) {
    if (pe instanceof Ie)
      return pe;
    if (typeof pe != "string")
      return null;
    var ge = pe.match(g[ye]);
    return ge == null ? null : Q(ge[1] + "." + (ge[2] || "0") + "." + (ge[3] || "0"));
  }
})(semver$1, semver$1.exports);
var semverExports = semver$1.exports, semver = semverExports, psSupported = semver.satisfies(process.version, "^6.12.0 || >=8.0.0"), JsonWebTokenError = JsonWebTokenError_1, NotBeforeError = NotBeforeError_1, TokenExpiredError = TokenExpiredError_1, decode = decode$1, timespan$1 = timespan$2, PS_SUPPORTED$1 = psSupported, jws$1 = jws$3, PUB_KEY_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512"], RSA_KEY_ALGS = ["RS256", "RS384", "RS512"], HS_ALGS = ["HS256", "HS384", "HS512"];
PS_SUPPORTED$1 && (PUB_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512"), RSA_KEY_ALGS.splice(3, 0, "PS256", "PS384", "PS512"));
var verify = function(a, u, c, l) {
  typeof c == "function" && !l && (l = c, c = {}), c || (c = {}), c = Object.assign({}, c);
  var v;
  if (l ? v = l : v = function(L, M) {
    if (L)
      throw L;
    return M;
  }, c.clockTimestamp && typeof c.clockTimestamp != "number")
    return v(new JsonWebTokenError("clockTimestamp must be a number"));
  if (c.nonce !== void 0 && (typeof c.nonce != "string" || c.nonce.trim() === ""))
    return v(new JsonWebTokenError("nonce must be a non-empty string"));
  var S = c.clockTimestamp || Math.floor(Date.now() / 1e3);
  if (!a)
    return v(new JsonWebTokenError("jwt must be provided"));
  if (typeof a != "string")
    return v(new JsonWebTokenError("jwt must be a string"));
  var g = a.split(".");
  if (g.length !== 3)
    return v(new JsonWebTokenError("jwt malformed"));
  var E;
  try {
    E = decode(a, { complete: !0 });
  } catch (L) {
    return v(L);
  }
  if (!E)
    return v(new JsonWebTokenError("invalid token"));
  var _ = E.header, k;
  if (typeof u == "function") {
    if (!l)
      return v(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
    k = u;
  } else
    k = function(L, M) {
      return M(null, u);
    };
  return k(_, function(L, M) {
    if (L)
      return v(new JsonWebTokenError("error in secret or public key callback: " + L.message));
    var $ = g[2].trim() !== "";
    if (!$ && M)
      return v(new JsonWebTokenError("jwt signature is required"));
    if ($ && !M)
      return v(new JsonWebTokenError("secret or public key must be provided"));
    if (!$ && !c.algorithms && (c.algorithms = ["none"]), c.algorithms || (c.algorithms = ~M.toString().indexOf("BEGIN CERTIFICATE") || ~M.toString().indexOf("BEGIN PUBLIC KEY") ? PUB_KEY_ALGS : ~M.toString().indexOf("BEGIN RSA PUBLIC KEY") ? RSA_KEY_ALGS : HS_ALGS), !~c.algorithms.indexOf(E.header.alg))
      return v(new JsonWebTokenError("invalid algorithm"));
    var J;
    try {
      J = jws$1.verify(a, E.header.alg, M);
    } catch (Z) {
      return v(Z);
    }
    if (!J)
      return v(new JsonWebTokenError("invalid signature"));
    var V = E.payload;
    if (typeof V.nbf < "u" && !c.ignoreNotBefore) {
      if (typeof V.nbf != "number")
        return v(new JsonWebTokenError("invalid nbf value"));
      if (V.nbf > S + (c.clockTolerance || 0))
        return v(new NotBeforeError("jwt not active", new Date(V.nbf * 1e3)));
    }
    if (typeof V.exp < "u" && !c.ignoreExpiration) {
      if (typeof V.exp != "number")
        return v(new JsonWebTokenError("invalid exp value"));
      if (S >= V.exp + (c.clockTolerance || 0))
        return v(new TokenExpiredError("jwt expired", new Date(V.exp * 1e3)));
    }
    if (c.audience) {
      var q = Array.isArray(c.audience) ? c.audience : [c.audience], G = Array.isArray(V.aud) ? V.aud : [V.aud], H = G.some(function(Z) {
        return q.some(function(re) {
          return re instanceof RegExp ? re.test(Z) : re === Z;
        });
      });
      if (!H)
        return v(new JsonWebTokenError("jwt audience invalid. expected: " + q.join(" or ")));
    }
    if (c.issuer) {
      var B = typeof c.issuer == "string" && V.iss !== c.issuer || Array.isArray(c.issuer) && c.issuer.indexOf(V.iss) === -1;
      if (B)
        return v(new JsonWebTokenError("jwt issuer invalid. expected: " + c.issuer));
    }
    if (c.subject && V.sub !== c.subject)
      return v(new JsonWebTokenError("jwt subject invalid. expected: " + c.subject));
    if (c.jwtid && V.jti !== c.jwtid)
      return v(new JsonWebTokenError("jwt jwtid invalid. expected: " + c.jwtid));
    if (c.nonce && V.nonce !== c.nonce)
      return v(new JsonWebTokenError("jwt nonce invalid. expected: " + c.nonce));
    if (c.maxAge) {
      if (typeof V.iat != "number")
        return v(new JsonWebTokenError("iat required when maxAge is specified"));
      var Y = timespan$1(c.maxAge, V.iat);
      if (typeof Y > "u")
        return v(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      if (S >= Y + (c.clockTolerance || 0))
        return v(new TokenExpiredError("maxAge exceeded", new Date(Y * 1e3)));
    }
    if (c.complete === !0) {
      var ne = E.signature;
      return v(null, {
        header: _,
        payload: V,
        signature: ne
      });
    }
    return v(null, V);
  });
}, INFINITY$2 = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER$2 = 17976931348623157e292, NAN$2 = NaN, argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", stringTag$1 = "[object String]", symbolTag$2 = "[object Symbol]", reTrim$2 = /^\s+|\s+$/g, reIsBadHex$2 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$2 = /^0b[01]+$/i, reIsOctal$2 = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, freeParseInt$2 = parseInt;
function arrayMap(a, u) {
  for (var c = -1, l = a ? a.length : 0, v = Array(l); ++c < l; )
    v[c] = u(a[c], c, a);
  return v;
}
function baseFindIndex(a, u, c, l) {
  for (var v = a.length, S = c + (l ? 1 : -1); l ? S-- : ++S < v; )
    if (u(a[S], S, a))
      return S;
  return -1;
}
function baseIndexOf(a, u, c) {
  if (u !== u)
    return baseFindIndex(a, baseIsNaN, c);
  for (var l = c - 1, v = a.length; ++l < v; )
    if (a[l] === u)
      return l;
  return -1;
}
function baseIsNaN(a) {
  return a !== a;
}
function baseTimes(a, u) {
  for (var c = -1, l = Array(a); ++c < a; )
    l[c] = u(c);
  return l;
}
function baseValues(a, u) {
  return arrayMap(u, function(c) {
    return a[c];
  });
}
function overArg$1(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var objectProto$6 = Object.prototype, hasOwnProperty$1 = objectProto$6.hasOwnProperty, objectToString$6 = objectProto$6.toString, propertyIsEnumerable = objectProto$6.propertyIsEnumerable, nativeKeys = overArg$1(Object.keys, Object), nativeMax = Math.max;
function arrayLikeKeys(a, u) {
  var c = isArray$3(a) || isArguments(a) ? baseTimes(a.length, String) : [], l = c.length, v = !!l;
  for (var S in a)
    (u || hasOwnProperty$1.call(a, S)) && !(v && (S == "length" || isIndex(S, l))) && c.push(S);
  return c;
}
function baseKeys(a) {
  if (!isPrototype(a))
    return nativeKeys(a);
  var u = [];
  for (var c in Object(a))
    hasOwnProperty$1.call(a, c) && c != "constructor" && u.push(c);
  return u;
}
function isIndex(a, u) {
  return u = u ?? MAX_SAFE_INTEGER, !!u && (typeof a == "number" || reIsUint.test(a)) && a > -1 && a % 1 == 0 && a < u;
}
function isPrototype(a) {
  var u = a && a.constructor, c = typeof u == "function" && u.prototype || objectProto$6;
  return a === c;
}
function includes$1(a, u, c, l) {
  a = isArrayLike(a) ? a : values(a), c = c && !l ? toInteger$2(c) : 0;
  var v = a.length;
  return c < 0 && (c = nativeMax(v + c, 0)), isString$3(a) ? c <= v && a.indexOf(u, c) > -1 : !!v && baseIndexOf(a, u, c) > -1;
}
function isArguments(a) {
  return isArrayLikeObject(a) && hasOwnProperty$1.call(a, "callee") && (!propertyIsEnumerable.call(a, "callee") || objectToString$6.call(a) == argsTag);
}
var isArray$3 = Array.isArray;
function isArrayLike(a) {
  return a != null && isLength(a.length) && !isFunction$1(a);
}
function isArrayLikeObject(a) {
  return isObjectLike$6(a) && isArrayLike(a);
}
function isFunction$1(a) {
  var u = isObject$6(a) ? objectToString$6.call(a) : "";
  return u == funcTag || u == genTag;
}
function isLength(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= MAX_SAFE_INTEGER;
}
function isObject$6(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike$6(a) {
  return !!a && typeof a == "object";
}
function isString$3(a) {
  return typeof a == "string" || !isArray$3(a) && isObjectLike$6(a) && objectToString$6.call(a) == stringTag$1;
}
function isSymbol$2(a) {
  return typeof a == "symbol" || isObjectLike$6(a) && objectToString$6.call(a) == symbolTag$2;
}
function toFinite$2(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber$2(a), a === INFINITY$2 || a === -INFINITY$2) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER$2;
  }
  return a === a ? a : 0;
}
function toInteger$2(a) {
  var u = toFinite$2(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber$2(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$2(a))
    return NAN$2;
  if (isObject$6(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$6(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim$2, "");
  var c = reIsBinary$2.test(a);
  return c || reIsOctal$2.test(a) ? freeParseInt$2(a.slice(2), c ? 2 : 8) : reIsBadHex$2.test(a) ? NAN$2 : +a;
}
function keys$1(a) {
  return isArrayLike(a) ? arrayLikeKeys(a) : baseKeys(a);
}
function values(a) {
  return a ? baseValues(a, keys$1(a)) : [];
}
var lodash_includes = includes$1, boolTag = "[object Boolean]", objectProto$5 = Object.prototype, objectToString$5 = objectProto$5.toString;
function isBoolean$1(a) {
  return a === !0 || a === !1 || isObjectLike$5(a) && objectToString$5.call(a) == boolTag;
}
function isObjectLike$5(a) {
  return !!a && typeof a == "object";
}
var lodash_isboolean = isBoolean$1, INFINITY$1 = 1 / 0, MAX_INTEGER$1 = 17976931348623157e292, NAN$1 = NaN, symbolTag$1 = "[object Symbol]", reTrim$1 = /^\s+|\s+$/g, reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i, reIsBinary$1 = /^0b[01]+$/i, reIsOctal$1 = /^0o[0-7]+$/i, freeParseInt$1 = parseInt, objectProto$4 = Object.prototype, objectToString$4 = objectProto$4.toString;
function isInteger$1(a) {
  return typeof a == "number" && a == toInteger$1(a);
}
function isObject$5(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike$4(a) {
  return !!a && typeof a == "object";
}
function isSymbol$1(a) {
  return typeof a == "symbol" || isObjectLike$4(a) && objectToString$4.call(a) == symbolTag$1;
}
function toFinite$1(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber$1(a), a === INFINITY$1 || a === -INFINITY$1) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER$1;
  }
  return a === a ? a : 0;
}
function toInteger$1(a) {
  var u = toFinite$1(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber$1(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol$1(a))
    return NAN$1;
  if (isObject$5(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$5(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim$1, "");
  var c = reIsBinary$1.test(a);
  return c || reIsOctal$1.test(a) ? freeParseInt$1(a.slice(2), c ? 2 : 8) : reIsBadHex$1.test(a) ? NAN$1 : +a;
}
var lodash_isinteger = isInteger$1, numberTag = "[object Number]", objectProto$3 = Object.prototype, objectToString$3 = objectProto$3.toString;
function isObjectLike$3(a) {
  return !!a && typeof a == "object";
}
function isNumber$2(a) {
  return typeof a == "number" || isObjectLike$3(a) && objectToString$3.call(a) == numberTag;
}
var lodash_isnumber = isNumber$2, objectTag = "[object Object]";
function isHostObject(a) {
  var u = !1;
  if (a != null && typeof a.toString != "function")
    try {
      u = !!(a + "");
    } catch {
    }
  return u;
}
function overArg(a, u) {
  return function(c) {
    return a(u(c));
  };
}
var funcProto = Function.prototype, objectProto$2 = Object.prototype, funcToString = funcProto.toString, hasOwnProperty = objectProto$2.hasOwnProperty, objectCtorString = funcToString.call(Object), objectToString$2 = objectProto$2.toString, getPrototype = overArg(Object.getPrototypeOf, Object);
function isObjectLike$2(a) {
  return !!a && typeof a == "object";
}
function isPlainObject$2(a) {
  if (!isObjectLike$2(a) || objectToString$2.call(a) != objectTag || isHostObject(a))
    return !1;
  var u = getPrototype(a);
  if (u === null)
    return !0;
  var c = hasOwnProperty.call(u, "constructor") && u.constructor;
  return typeof c == "function" && c instanceof c && funcToString.call(c) == objectCtorString;
}
var lodash_isplainobject = isPlainObject$2, stringTag = "[object String]", objectProto$1 = Object.prototype, objectToString$1 = objectProto$1.toString, isArray$2 = Array.isArray;
function isObjectLike$1(a) {
  return !!a && typeof a == "object";
}
function isString$2(a) {
  return typeof a == "string" || !isArray$2(a) && isObjectLike$1(a) && objectToString$1.call(a) == stringTag;
}
var lodash_isstring = isString$2, FUNC_ERROR_TEXT = "Expected a function", INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292, NAN = NaN, symbolTag = "[object Symbol]", reTrim = /^\s+|\s+$/g, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt, objectProto = Object.prototype, objectToString = objectProto.toString;
function before(a, u) {
  var c;
  if (typeof u != "function")
    throw new TypeError(FUNC_ERROR_TEXT);
  return a = toInteger(a), function() {
    return --a > 0 && (c = u.apply(this, arguments)), a <= 1 && (u = void 0), c;
  };
}
function once$2(a) {
  return before(2, a);
}
function isObject$4(a) {
  var u = typeof a;
  return !!a && (u == "object" || u == "function");
}
function isObjectLike(a) {
  return !!a && typeof a == "object";
}
function isSymbol(a) {
  return typeof a == "symbol" || isObjectLike(a) && objectToString.call(a) == symbolTag;
}
function toFinite(a) {
  if (!a)
    return a === 0 ? a : 0;
  if (a = toNumber(a), a === INFINITY || a === -INFINITY) {
    var u = a < 0 ? -1 : 1;
    return u * MAX_INTEGER;
  }
  return a === a ? a : 0;
}
function toInteger(a) {
  var u = toFinite(a), c = u % 1;
  return u === u ? c ? u - c : u : 0;
}
function toNumber(a) {
  if (typeof a == "number")
    return a;
  if (isSymbol(a))
    return NAN;
  if (isObject$4(a)) {
    var u = typeof a.valueOf == "function" ? a.valueOf() : a;
    a = isObject$4(u) ? u + "" : u;
  }
  if (typeof a != "string")
    return a === 0 ? a : +a;
  a = a.replace(reTrim, "");
  var c = reIsBinary.test(a);
  return c || reIsOctal.test(a) ? freeParseInt(a.slice(2), c ? 2 : 8) : reIsBadHex.test(a) ? NAN : +a;
}
var lodash_once = once$2, timespan = timespan$2, PS_SUPPORTED = psSupported, jws = jws$3, includes = lodash_includes, isBoolean = lodash_isboolean, isInteger = lodash_isinteger, isNumber$1 = lodash_isnumber, isPlainObject$1 = lodash_isplainobject, isString$1 = lodash_isstring, once$1 = lodash_once, SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
PS_SUPPORTED && SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
var sign_options_schema = {
  expiresIn: { isValid: function(a) {
    return isInteger(a) || isString$1(a) && a;
  }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
  notBefore: { isValid: function(a) {
    return isInteger(a) || isString$1(a) && a;
  }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
  audience: { isValid: function(a) {
    return isString$1(a) || Array.isArray(a);
  }, message: '"audience" must be a string or array' },
  algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
  header: { isValid: isPlainObject$1, message: '"header" must be an object' },
  encoding: { isValid: isString$1, message: '"encoding" must be a string' },
  issuer: { isValid: isString$1, message: '"issuer" must be a string' },
  subject: { isValid: isString$1, message: '"subject" must be a string' },
  jwtid: { isValid: isString$1, message: '"jwtid" must be a string' },
  noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
  keyid: { isValid: isString$1, message: '"keyid" must be a string' },
  mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' }
}, registered_claims_schema = {
  iat: { isValid: isNumber$1, message: '"iat" should be a number of seconds' },
  exp: { isValid: isNumber$1, message: '"exp" should be a number of seconds' },
  nbf: { isValid: isNumber$1, message: '"nbf" should be a number of seconds' }
};
function validate(a, u, c, l) {
  if (!isPlainObject$1(c))
    throw new Error('Expected "' + l + '" to be a plain object.');
  Object.keys(c).forEach(function(v) {
    var S = a[v];
    if (!S) {
      if (!u)
        throw new Error('"' + v + '" is not allowed in "' + l + '"');
      return;
    }
    if (!S.isValid(c[v]))
      throw new Error(S.message);
  });
}
function validateOptions(a) {
  return validate(sign_options_schema, !1, a, "options");
}
function validatePayload(a) {
  return validate(registered_claims_schema, !0, a, "payload");
}
var options_to_payload = {
  audience: "aud",
  issuer: "iss",
  subject: "sub",
  jwtid: "jti"
}, options_for_objects = [
  "expiresIn",
  "notBefore",
  "noTimestamp",
  "audience",
  "issuer",
  "subject",
  "jwtid"
], sign = function(a, u, c, l) {
  typeof c == "function" ? (l = c, c = {}) : c = c || {};
  var v = typeof a == "object" && !Buffer.isBuffer(a), S = Object.assign({
    alg: c.algorithm || "HS256",
    typ: v ? "JWT" : void 0,
    kid: c.keyid
  }, c.header);
  function g(L) {
    if (l)
      return l(L);
    throw L;
  }
  if (!u && c.algorithm !== "none")
    return g(new Error("secretOrPrivateKey must have a value"));
  if (typeof a > "u")
    return g(new Error("payload is required"));
  if (v) {
    try {
      validatePayload(a);
    } catch (L) {
      return g(L);
    }
    c.mutatePayload || (a = Object.assign({}, a));
  } else {
    var E = options_for_objects.filter(function(L) {
      return typeof c[L] < "u";
    });
    if (E.length > 0)
      return g(new Error("invalid " + E.join(",") + " option for " + typeof a + " payload"));
  }
  if (typeof a.exp < "u" && typeof c.expiresIn < "u")
    return g(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
  if (typeof a.nbf < "u" && typeof c.notBefore < "u")
    return g(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
  try {
    validateOptions(c);
  } catch (L) {
    return g(L);
  }
  var _ = a.iat || Math.floor(Date.now() / 1e3);
  if (c.noTimestamp ? delete a.iat : v && (a.iat = _), typeof c.notBefore < "u") {
    try {
      a.nbf = timespan(c.notBefore, _);
    } catch (L) {
      return g(L);
    }
    if (typeof a.nbf > "u")
      return g(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  }
  if (typeof c.expiresIn < "u" && typeof a == "object") {
    try {
      a.exp = timespan(c.expiresIn, _);
    } catch (L) {
      return g(L);
    }
    if (typeof a.exp > "u")
      return g(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
  }
  Object.keys(options_to_payload).forEach(function(L) {
    var M = options_to_payload[L];
    if (typeof c[L] < "u") {
      if (typeof a[M] < "u")
        return g(new Error('Bad "options.' + L + '" option. The payload already has an "' + M + '" property.'));
      a[M] = c[L];
    }
  });
  var k = c.encoding || "utf8";
  if (typeof l == "function")
    l = l && once$1(l), jws.createSign({
      header: S,
      privateKey: u,
      payload: a,
      encoding: k
    }).once("error", l).once("done", function(L) {
      l(null, L);
    });
  else
    return jws.sign({ header: S, payload: a, secret: u, encoding: k });
}, jsonwebtoken = {
  decode: decode$1,
  verify,
  sign,
  JsonWebTokenError: JsonWebTokenError_1,
  NotBeforeError: NotBeforeError_1,
  TokenExpiredError: TokenExpiredError_1
}, __createBinding = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(a, u, c, l) {
  l === void 0 && (l = c), Object.defineProperty(a, l, { enumerable: !0, get: function() {
    return u[c];
  } });
} : function(a, u, c, l) {
  l === void 0 && (l = c), a[l] = u[c];
}), __setModuleDefault = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(a, u) {
  Object.defineProperty(a, "default", { enumerable: !0, value: u });
} : function(a, u) {
  a.default = u;
}), __importStar = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(a) {
  if (a && a.__esModule)
    return a;
  var u = {};
  if (a != null)
    for (var c in a)
      c !== "default" && Object.prototype.hasOwnProperty.call(a, c) && __createBinding(u, a, c);
  return __setModuleDefault(u, a), u;
};
Object.defineProperty(AccessToken$1, "__esModule", { value: !0 });
AccessToken$1.TokenVerifier = AccessToken$1.AccessToken = void 0;
const jwt = __importStar(jsonwebtoken), defaultTTL = 6 * 60 * 60;
class AccessToken {
  /**
   * Creates a new AccessToken
   * @param apiKey API Key, can be set in env LIVEKIT_API_KEY
   * @param apiSecret Secret, can be set in env LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    if (u || (u = process.env.LIVEKIT_API_KEY), c || (c = process.env.LIVEKIT_API_SECRET), !u || !c)
      throw Error("api-key and api-secret must be set");
    this.apiKey = u, this.apiSecret = c, this.grants = {}, this.identity = l == null ? void 0 : l.identity, this.ttl = (l == null ? void 0 : l.ttl) || defaultTTL, l != null && l.metadata && (this.metadata = l.metadata), l != null && l.name && (this.name = l.name);
  }
  /**
   * Adds a video grant to this token.
   * @param grant
   */
  addGrant(u) {
    this.grants.video = u;
  }
  /**
   * Set metadata to be passed to the Participant, used only when joining the room
   */
  set metadata(u) {
    this.grants.metadata = u;
  }
  set name(u) {
    this.grants.name = u;
  }
  get sha256() {
    return this.grants.sha256;
  }
  set sha256(u) {
    this.grants.sha256 = u;
  }
  /**
   * @returns JWT encoded token
   */
  toJwt() {
    var u;
    const c = {
      issuer: this.apiKey,
      expiresIn: this.ttl,
      notBefore: 0
    };
    if (this.identity)
      c.subject = this.identity, c.jwtid = this.identity;
    else if (!((u = this.grants.video) === null || u === void 0) && u.roomJoin)
      throw Error("identity is required for join but not set");
    return jwt.sign(this.grants, this.apiSecret, c);
  }
}
AccessToken$1.AccessToken = AccessToken;
class TokenVerifier {
  constructor(u, c) {
    this.apiKey = u, this.apiSecret = c;
  }
  verify(u) {
    const c = jwt.verify(u, this.apiSecret, { issuer: this.apiKey });
    if (!c)
      throw Error("invalid token");
    return c;
  }
}
AccessToken$1.TokenVerifier = TokenVerifier;
var EgressClient$1 = {}, livekit_egress = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(P) {
    return P && P.__esModule ? P : { default: P };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.AutoTrackEgress = a.SegmentsInfo = a.FileInfo = a.StreamInfo = a.StreamInfoList = a.EgressInfo = a.StopEgressRequest = a.ListEgressResponse = a.ListEgressRequest = a.UpdateStreamRequest = a.UpdateLayoutRequest = a.EncodingOptions = a.StreamOutput = a.AliOSSUpload = a.AzureBlobUpload = a.GCPUpload = a.S3Upload_MetadataEntry = a.S3Upload = a.DirectFileOutput = a.SegmentedFileOutput = a.EncodedFileOutput = a.WebEgressRequest = a.TrackEgressRequest = a.TrackCompositeEgressRequest = a.RoomCompositeEgressRequest = a.streamInfo_StatusToJSON = a.streamInfo_StatusFromJSON = a.StreamInfo_Status = a.egressStatusToJSON = a.egressStatusFromJSON = a.EgressStatus = a.encodingOptionsPresetToJSON = a.encodingOptionsPresetFromJSON = a.EncodingOptionsPreset = a.videoCodecToJSON = a.videoCodecFromJSON = a.VideoCodec = a.audioCodecToJSON = a.audioCodecFromJSON = a.AudioCodec = a.segmentedFileProtocolToJSON = a.segmentedFileProtocolFromJSON = a.SegmentedFileProtocol = a.streamProtocolToJSON = a.streamProtocolFromJSON = a.StreamProtocol = a.encodedFileTypeToJSON = a.encodedFileTypeFromJSON = a.EncodedFileType = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal);
  a.protobufPackage = "livekit";
  var v;
  (function(P) {
    P[P.DEFAULT_FILETYPE = 0] = "DEFAULT_FILETYPE", P[P.MP4 = 1] = "MP4", P[P.OGG = 2] = "OGG", P[P.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(v = a.EncodedFileType || (a.EncodedFileType = {}));
  function S(P) {
    switch (P) {
      case 0:
      case "DEFAULT_FILETYPE":
        return v.DEFAULT_FILETYPE;
      case 1:
      case "MP4":
        return v.MP4;
      case 2:
      case "OGG":
        return v.OGG;
      case -1:
      case "UNRECOGNIZED":
      default:
        return v.UNRECOGNIZED;
    }
  }
  a.encodedFileTypeFromJSON = S;
  function g(P) {
    switch (P) {
      case v.DEFAULT_FILETYPE:
        return "DEFAULT_FILETYPE";
      case v.MP4:
        return "MP4";
      case v.OGG:
        return "OGG";
      case v.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.encodedFileTypeToJSON = g;
  var E;
  (function(P) {
    P[P.DEFAULT_PROTOCOL = 0] = "DEFAULT_PROTOCOL", P[P.RTMP = 1] = "RTMP", P[P.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(E = a.StreamProtocol || (a.StreamProtocol = {}));
  function _(P) {
    switch (P) {
      case 0:
      case "DEFAULT_PROTOCOL":
        return E.DEFAULT_PROTOCOL;
      case 1:
      case "RTMP":
        return E.RTMP;
      case -1:
      case "UNRECOGNIZED":
      default:
        return E.UNRECOGNIZED;
    }
  }
  a.streamProtocolFromJSON = _;
  function k(P) {
    switch (P) {
      case E.DEFAULT_PROTOCOL:
        return "DEFAULT_PROTOCOL";
      case E.RTMP:
        return "RTMP";
      case E.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamProtocolToJSON = k;
  var L;
  (function(P) {
    P[P.DEFAULT_SEGMENTED_FILE_PROTOCOL = 0] = "DEFAULT_SEGMENTED_FILE_PROTOCOL", P[P.HLS_PROTOCOL = 1] = "HLS_PROTOCOL", P[P.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(L = a.SegmentedFileProtocol || (a.SegmentedFileProtocol = {}));
  function M(P) {
    switch (P) {
      case 0:
      case "DEFAULT_SEGMENTED_FILE_PROTOCOL":
        return L.DEFAULT_SEGMENTED_FILE_PROTOCOL;
      case 1:
      case "HLS_PROTOCOL":
        return L.HLS_PROTOCOL;
      case -1:
      case "UNRECOGNIZED":
      default:
        return L.UNRECOGNIZED;
    }
  }
  a.segmentedFileProtocolFromJSON = M;
  function $(P) {
    switch (P) {
      case L.DEFAULT_SEGMENTED_FILE_PROTOCOL:
        return "DEFAULT_SEGMENTED_FILE_PROTOCOL";
      case L.HLS_PROTOCOL:
        return "HLS_PROTOCOL";
      case L.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.segmentedFileProtocolToJSON = $;
  var J;
  (function(P) {
    P[P.DEFAULT_AC = 0] = "DEFAULT_AC", P[P.OPUS = 1] = "OPUS", P[P.AAC = 2] = "AAC", P[P.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(J = a.AudioCodec || (a.AudioCodec = {}));
  function V(P) {
    switch (P) {
      case 0:
      case "DEFAULT_AC":
        return J.DEFAULT_AC;
      case 1:
      case "OPUS":
        return J.OPUS;
      case 2:
      case "AAC":
        return J.AAC;
      case -1:
      case "UNRECOGNIZED":
      default:
        return J.UNRECOGNIZED;
    }
  }
  a.audioCodecFromJSON = V;
  function q(P) {
    switch (P) {
      case J.DEFAULT_AC:
        return "DEFAULT_AC";
      case J.OPUS:
        return "OPUS";
      case J.AAC:
        return "AAC";
      case J.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.audioCodecToJSON = q;
  var G;
  (function(P) {
    P[P.DEFAULT_VC = 0] = "DEFAULT_VC", P[P.H264_BASELINE = 1] = "H264_BASELINE", P[P.H264_MAIN = 2] = "H264_MAIN", P[P.H264_HIGH = 3] = "H264_HIGH", P[P.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(G = a.VideoCodec || (a.VideoCodec = {}));
  function H(P) {
    switch (P) {
      case 0:
      case "DEFAULT_VC":
        return G.DEFAULT_VC;
      case 1:
      case "H264_BASELINE":
        return G.H264_BASELINE;
      case 2:
      case "H264_MAIN":
        return G.H264_MAIN;
      case 3:
      case "H264_HIGH":
        return G.H264_HIGH;
      case -1:
      case "UNRECOGNIZED":
      default:
        return G.UNRECOGNIZED;
    }
  }
  a.videoCodecFromJSON = H;
  function B(P) {
    switch (P) {
      case G.DEFAULT_VC:
        return "DEFAULT_VC";
      case G.H264_BASELINE:
        return "H264_BASELINE";
      case G.H264_MAIN:
        return "H264_MAIN";
      case G.H264_HIGH:
        return "H264_HIGH";
      case G.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.videoCodecToJSON = B;
  var Y;
  (function(P) {
    P[P.H264_720P_30 = 0] = "H264_720P_30", P[P.H264_720P_60 = 1] = "H264_720P_60", P[P.H264_1080P_30 = 2] = "H264_1080P_30", P[P.H264_1080P_60 = 3] = "H264_1080P_60", P[P.PORTRAIT_H264_720P_30 = 4] = "PORTRAIT_H264_720P_30", P[P.PORTRAIT_H264_720P_60 = 5] = "PORTRAIT_H264_720P_60", P[P.PORTRAIT_H264_1080P_30 = 6] = "PORTRAIT_H264_1080P_30", P[P.PORTRAIT_H264_1080P_60 = 7] = "PORTRAIT_H264_1080P_60", P[P.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(Y = a.EncodingOptionsPreset || (a.EncodingOptionsPreset = {}));
  function ne(P) {
    switch (P) {
      case 0:
      case "H264_720P_30":
        return Y.H264_720P_30;
      case 1:
      case "H264_720P_60":
        return Y.H264_720P_60;
      case 2:
      case "H264_1080P_30":
        return Y.H264_1080P_30;
      case 3:
      case "H264_1080P_60":
        return Y.H264_1080P_60;
      case 4:
      case "PORTRAIT_H264_720P_30":
        return Y.PORTRAIT_H264_720P_30;
      case 5:
      case "PORTRAIT_H264_720P_60":
        return Y.PORTRAIT_H264_720P_60;
      case 6:
      case "PORTRAIT_H264_1080P_30":
        return Y.PORTRAIT_H264_1080P_30;
      case 7:
      case "PORTRAIT_H264_1080P_60":
        return Y.PORTRAIT_H264_1080P_60;
      case -1:
      case "UNRECOGNIZED":
      default:
        return Y.UNRECOGNIZED;
    }
  }
  a.encodingOptionsPresetFromJSON = ne;
  function Z(P) {
    switch (P) {
      case Y.H264_720P_30:
        return "H264_720P_30";
      case Y.H264_720P_60:
        return "H264_720P_60";
      case Y.H264_1080P_30:
        return "H264_1080P_30";
      case Y.H264_1080P_60:
        return "H264_1080P_60";
      case Y.PORTRAIT_H264_720P_30:
        return "PORTRAIT_H264_720P_30";
      case Y.PORTRAIT_H264_720P_60:
        return "PORTRAIT_H264_720P_60";
      case Y.PORTRAIT_H264_1080P_30:
        return "PORTRAIT_H264_1080P_30";
      case Y.PORTRAIT_H264_1080P_60:
        return "PORTRAIT_H264_1080P_60";
      case Y.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.encodingOptionsPresetToJSON = Z;
  var re;
  (function(P) {
    P[P.EGRESS_STARTING = 0] = "EGRESS_STARTING", P[P.EGRESS_ACTIVE = 1] = "EGRESS_ACTIVE", P[P.EGRESS_ENDING = 2] = "EGRESS_ENDING", P[P.EGRESS_COMPLETE = 3] = "EGRESS_COMPLETE", P[P.EGRESS_FAILED = 4] = "EGRESS_FAILED", P[P.EGRESS_ABORTED = 5] = "EGRESS_ABORTED", P[P.EGRESS_LIMIT_REACHED = 6] = "EGRESS_LIMIT_REACHED", P[P.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(re = a.EgressStatus || (a.EgressStatus = {}));
  function oe(P) {
    switch (P) {
      case 0:
      case "EGRESS_STARTING":
        return re.EGRESS_STARTING;
      case 1:
      case "EGRESS_ACTIVE":
        return re.EGRESS_ACTIVE;
      case 2:
      case "EGRESS_ENDING":
        return re.EGRESS_ENDING;
      case 3:
      case "EGRESS_COMPLETE":
        return re.EGRESS_COMPLETE;
      case 4:
      case "EGRESS_FAILED":
        return re.EGRESS_FAILED;
      case 5:
      case "EGRESS_ABORTED":
        return re.EGRESS_ABORTED;
      case 6:
      case "EGRESS_LIMIT_REACHED":
        return re.EGRESS_LIMIT_REACHED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return re.UNRECOGNIZED;
    }
  }
  a.egressStatusFromJSON = oe;
  function de(P) {
    switch (P) {
      case re.EGRESS_STARTING:
        return "EGRESS_STARTING";
      case re.EGRESS_ACTIVE:
        return "EGRESS_ACTIVE";
      case re.EGRESS_ENDING:
        return "EGRESS_ENDING";
      case re.EGRESS_COMPLETE:
        return "EGRESS_COMPLETE";
      case re.EGRESS_FAILED:
        return "EGRESS_FAILED";
      case re.EGRESS_ABORTED:
        return "EGRESS_ABORTED";
      case re.EGRESS_LIMIT_REACHED:
        return "EGRESS_LIMIT_REACHED";
      case re.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.egressStatusToJSON = de;
  var A;
  (function(P) {
    P[P.ACTIVE = 0] = "ACTIVE", P[P.FINISHED = 1] = "FINISHED", P[P.FAILED = 2] = "FAILED", P[P.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(A = a.StreamInfo_Status || (a.StreamInfo_Status = {}));
  function N(P) {
    switch (P) {
      case 0:
      case "ACTIVE":
        return A.ACTIVE;
      case 1:
      case "FINISHED":
        return A.FINISHED;
      case 2:
      case "FAILED":
        return A.FAILED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return A.UNRECOGNIZED;
    }
  }
  a.streamInfo_StatusFromJSON = N;
  function D(P) {
    switch (P) {
      case A.ACTIVE:
        return "ACTIVE";
      case A.FINISHED:
        return "FINISHED";
      case A.FAILED:
        return "FAILED";
      case A.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamInfo_StatusToJSON = D;
  function W() {
    return {
      roomName: "",
      layout: "",
      audioOnly: !1,
      videoOnly: !1,
      customBaseUrl: "",
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.RoomCompositeEgressRequest = {
    encode(P, X = l.default.Writer.create()) {
      return P.roomName !== void 0 && P.roomName !== "" && X.uint32(10).string(P.roomName), P.layout !== void 0 && P.layout !== "" && X.uint32(18).string(P.layout), P.audioOnly === !0 && X.uint32(24).bool(P.audioOnly), P.videoOnly === !0 && X.uint32(32).bool(P.videoOnly), P.customBaseUrl !== void 0 && P.customBaseUrl !== "" && X.uint32(42).string(P.customBaseUrl), P.file !== void 0 && a.EncodedFileOutput.encode(P.file, X.uint32(50).fork()).ldelim(), P.stream !== void 0 && a.StreamOutput.encode(P.stream, X.uint32(58).fork()).ldelim(), P.segments !== void 0 && a.SegmentedFileOutput.encode(P.segments, X.uint32(82).fork()).ldelim(), P.preset !== void 0 && X.uint32(64).int32(P.preset), P.advanced !== void 0 && a.EncodingOptions.encode(P.advanced, X.uint32(74).fork()).ldelim(), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = W();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.roomName = ie.string();
            break;
          case 2:
            ue.layout = ie.string();
            break;
          case 3:
            ue.audioOnly = ie.bool();
            break;
          case 4:
            ue.videoOnly = ie.bool();
            break;
          case 5:
            ue.customBaseUrl = ie.string();
            break;
          case 6:
            ue.file = a.EncodedFileOutput.decode(ie, ie.uint32());
            break;
          case 7:
            ue.stream = a.StreamOutput.decode(ie, ie.uint32());
            break;
          case 10:
            ue.segments = a.SegmentedFileOutput.decode(ie, ie.uint32());
            break;
          case 8:
            ue.preset = ie.int32();
            break;
          case 9:
            ue.advanced = a.EncodingOptions.decode(ie, ie.uint32());
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        roomName: Oe(P.roomName) ? String(P.roomName) : "",
        layout: Oe(P.layout) ? String(P.layout) : "",
        audioOnly: Oe(P.audioOnly) ? !!P.audioOnly : !1,
        videoOnly: Oe(P.videoOnly) ? !!P.videoOnly : !1,
        customBaseUrl: Oe(P.customBaseUrl) ? String(P.customBaseUrl) : "",
        file: Oe(P.file) ? a.EncodedFileOutput.fromJSON(P.file) : void 0,
        stream: Oe(P.stream) ? a.StreamOutput.fromJSON(P.stream) : void 0,
        segments: Oe(P.segments) ? a.SegmentedFileOutput.fromJSON(P.segments) : void 0,
        preset: Oe(P.preset) ? ne(P.preset) : void 0,
        advanced: Oe(P.advanced) ? a.EncodingOptions.fromJSON(P.advanced) : void 0
      };
    },
    toJSON(P) {
      const X = {};
      return P.roomName !== void 0 && (X.roomName = P.roomName), P.layout !== void 0 && (X.layout = P.layout), P.audioOnly !== void 0 && (X.audioOnly = P.audioOnly), P.videoOnly !== void 0 && (X.videoOnly = P.videoOnly), P.customBaseUrl !== void 0 && (X.customBaseUrl = P.customBaseUrl), P.file !== void 0 && (X.file = P.file ? a.EncodedFileOutput.toJSON(P.file) : void 0), P.stream !== void 0 && (X.stream = P.stream ? a.StreamOutput.toJSON(P.stream) : void 0), P.segments !== void 0 && (X.segments = P.segments ? a.SegmentedFileOutput.toJSON(P.segments) : void 0), P.preset !== void 0 && (X.preset = P.preset !== void 0 ? Z(P.preset) : void 0), P.advanced !== void 0 && (X.advanced = P.advanced ? a.EncodingOptions.toJSON(P.advanced) : void 0), X;
    },
    fromPartial(P) {
      var X, ie, Ee, ue, O, j;
      const se = W();
      return se.roomName = (X = P.roomName) !== null && X !== void 0 ? X : "", se.layout = (ie = P.layout) !== null && ie !== void 0 ? ie : "", se.audioOnly = (Ee = P.audioOnly) !== null && Ee !== void 0 ? Ee : !1, se.videoOnly = (ue = P.videoOnly) !== null && ue !== void 0 ? ue : !1, se.customBaseUrl = (O = P.customBaseUrl) !== null && O !== void 0 ? O : "", se.file = P.file !== void 0 && P.file !== null ? a.EncodedFileOutput.fromPartial(P.file) : void 0, se.stream = P.stream !== void 0 && P.stream !== null ? a.StreamOutput.fromPartial(P.stream) : void 0, se.segments = P.segments !== void 0 && P.segments !== null ? a.SegmentedFileOutput.fromPartial(P.segments) : void 0, se.preset = (j = P.preset) !== null && j !== void 0 ? j : void 0, se.advanced = P.advanced !== void 0 && P.advanced !== null ? a.EncodingOptions.fromPartial(P.advanced) : void 0, se;
    }
  };
  function ee() {
    return {
      roomName: "",
      audioTrackId: "",
      videoTrackId: "",
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.TrackCompositeEgressRequest = {
    encode(P, X = l.default.Writer.create()) {
      return P.roomName !== void 0 && P.roomName !== "" && X.uint32(10).string(P.roomName), P.audioTrackId !== void 0 && P.audioTrackId !== "" && X.uint32(18).string(P.audioTrackId), P.videoTrackId !== void 0 && P.videoTrackId !== "" && X.uint32(26).string(P.videoTrackId), P.file !== void 0 && a.EncodedFileOutput.encode(P.file, X.uint32(34).fork()).ldelim(), P.stream !== void 0 && a.StreamOutput.encode(P.stream, X.uint32(42).fork()).ldelim(), P.segments !== void 0 && a.SegmentedFileOutput.encode(P.segments, X.uint32(66).fork()).ldelim(), P.preset !== void 0 && X.uint32(48).int32(P.preset), P.advanced !== void 0 && a.EncodingOptions.encode(P.advanced, X.uint32(58).fork()).ldelim(), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = ee();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.roomName = ie.string();
            break;
          case 2:
            ue.audioTrackId = ie.string();
            break;
          case 3:
            ue.videoTrackId = ie.string();
            break;
          case 4:
            ue.file = a.EncodedFileOutput.decode(ie, ie.uint32());
            break;
          case 5:
            ue.stream = a.StreamOutput.decode(ie, ie.uint32());
            break;
          case 8:
            ue.segments = a.SegmentedFileOutput.decode(ie, ie.uint32());
            break;
          case 6:
            ue.preset = ie.int32();
            break;
          case 7:
            ue.advanced = a.EncodingOptions.decode(ie, ie.uint32());
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        roomName: Oe(P.roomName) ? String(P.roomName) : "",
        audioTrackId: Oe(P.audioTrackId) ? String(P.audioTrackId) : "",
        videoTrackId: Oe(P.videoTrackId) ? String(P.videoTrackId) : "",
        file: Oe(P.file) ? a.EncodedFileOutput.fromJSON(P.file) : void 0,
        stream: Oe(P.stream) ? a.StreamOutput.fromJSON(P.stream) : void 0,
        segments: Oe(P.segments) ? a.SegmentedFileOutput.fromJSON(P.segments) : void 0,
        preset: Oe(P.preset) ? ne(P.preset) : void 0,
        advanced: Oe(P.advanced) ? a.EncodingOptions.fromJSON(P.advanced) : void 0
      };
    },
    toJSON(P) {
      const X = {};
      return P.roomName !== void 0 && (X.roomName = P.roomName), P.audioTrackId !== void 0 && (X.audioTrackId = P.audioTrackId), P.videoTrackId !== void 0 && (X.videoTrackId = P.videoTrackId), P.file !== void 0 && (X.file = P.file ? a.EncodedFileOutput.toJSON(P.file) : void 0), P.stream !== void 0 && (X.stream = P.stream ? a.StreamOutput.toJSON(P.stream) : void 0), P.segments !== void 0 && (X.segments = P.segments ? a.SegmentedFileOutput.toJSON(P.segments) : void 0), P.preset !== void 0 && (X.preset = P.preset !== void 0 ? Z(P.preset) : void 0), P.advanced !== void 0 && (X.advanced = P.advanced ? a.EncodingOptions.toJSON(P.advanced) : void 0), X;
    },
    fromPartial(P) {
      var X, ie, Ee, ue;
      const O = ee();
      return O.roomName = (X = P.roomName) !== null && X !== void 0 ? X : "", O.audioTrackId = (ie = P.audioTrackId) !== null && ie !== void 0 ? ie : "", O.videoTrackId = (Ee = P.videoTrackId) !== null && Ee !== void 0 ? Ee : "", O.file = P.file !== void 0 && P.file !== null ? a.EncodedFileOutput.fromPartial(P.file) : void 0, O.stream = P.stream !== void 0 && P.stream !== null ? a.StreamOutput.fromPartial(P.stream) : void 0, O.segments = P.segments !== void 0 && P.segments !== null ? a.SegmentedFileOutput.fromPartial(P.segments) : void 0, O.preset = (ue = P.preset) !== null && ue !== void 0 ? ue : void 0, O.advanced = P.advanced !== void 0 && P.advanced !== null ? a.EncodingOptions.fromPartial(P.advanced) : void 0, O;
    }
  };
  function ae() {
    return { roomName: "", trackId: "", file: void 0, websocketUrl: void 0 };
  }
  a.TrackEgressRequest = {
    encode(P, X = l.default.Writer.create()) {
      return P.roomName !== void 0 && P.roomName !== "" && X.uint32(10).string(P.roomName), P.trackId !== void 0 && P.trackId !== "" && X.uint32(18).string(P.trackId), P.file !== void 0 && a.DirectFileOutput.encode(P.file, X.uint32(26).fork()).ldelim(), P.websocketUrl !== void 0 && X.uint32(34).string(P.websocketUrl), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = ae();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.roomName = ie.string();
            break;
          case 2:
            ue.trackId = ie.string();
            break;
          case 3:
            ue.file = a.DirectFileOutput.decode(ie, ie.uint32());
            break;
          case 4:
            ue.websocketUrl = ie.string();
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        roomName: Oe(P.roomName) ? String(P.roomName) : "",
        trackId: Oe(P.trackId) ? String(P.trackId) : "",
        file: Oe(P.file) ? a.DirectFileOutput.fromJSON(P.file) : void 0,
        websocketUrl: Oe(P.websocketUrl) ? String(P.websocketUrl) : void 0
      };
    },
    toJSON(P) {
      const X = {};
      return P.roomName !== void 0 && (X.roomName = P.roomName), P.trackId !== void 0 && (X.trackId = P.trackId), P.file !== void 0 && (X.file = P.file ? a.DirectFileOutput.toJSON(P.file) : void 0), P.websocketUrl !== void 0 && (X.websocketUrl = P.websocketUrl), X;
    },
    fromPartial(P) {
      var X, ie, Ee;
      const ue = ae();
      return ue.roomName = (X = P.roomName) !== null && X !== void 0 ? X : "", ue.trackId = (ie = P.trackId) !== null && ie !== void 0 ? ie : "", ue.file = P.file !== void 0 && P.file !== null ? a.DirectFileOutput.fromPartial(P.file) : void 0, ue.websocketUrl = (Ee = P.websocketUrl) !== null && Ee !== void 0 ? Ee : void 0, ue;
    }
  };
  function ye() {
    return {
      url: "",
      audioOnly: !1,
      videoOnly: !1,
      file: void 0,
      stream: void 0,
      segments: void 0,
      preset: void 0,
      advanced: void 0
    };
  }
  a.WebEgressRequest = {
    encode(P, X = l.default.Writer.create()) {
      return P.url !== void 0 && P.url !== "" && X.uint32(10).string(P.url), P.audioOnly === !0 && X.uint32(16).bool(P.audioOnly), P.videoOnly === !0 && X.uint32(24).bool(P.videoOnly), P.file !== void 0 && a.EncodedFileOutput.encode(P.file, X.uint32(34).fork()).ldelim(), P.stream !== void 0 && a.StreamOutput.encode(P.stream, X.uint32(42).fork()).ldelim(), P.segments !== void 0 && a.SegmentedFileOutput.encode(P.segments, X.uint32(50).fork()).ldelim(), P.preset !== void 0 && X.uint32(56).int32(P.preset), P.advanced !== void 0 && a.EncodingOptions.encode(P.advanced, X.uint32(66).fork()).ldelim(), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = ye();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.url = ie.string();
            break;
          case 2:
            ue.audioOnly = ie.bool();
            break;
          case 3:
            ue.videoOnly = ie.bool();
            break;
          case 4:
            ue.file = a.EncodedFileOutput.decode(ie, ie.uint32());
            break;
          case 5:
            ue.stream = a.StreamOutput.decode(ie, ie.uint32());
            break;
          case 6:
            ue.segments = a.SegmentedFileOutput.decode(ie, ie.uint32());
            break;
          case 7:
            ue.preset = ie.int32();
            break;
          case 8:
            ue.advanced = a.EncodingOptions.decode(ie, ie.uint32());
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        url: Oe(P.url) ? String(P.url) : "",
        audioOnly: Oe(P.audioOnly) ? !!P.audioOnly : !1,
        videoOnly: Oe(P.videoOnly) ? !!P.videoOnly : !1,
        file: Oe(P.file) ? a.EncodedFileOutput.fromJSON(P.file) : void 0,
        stream: Oe(P.stream) ? a.StreamOutput.fromJSON(P.stream) : void 0,
        segments: Oe(P.segments) ? a.SegmentedFileOutput.fromJSON(P.segments) : void 0,
        preset: Oe(P.preset) ? ne(P.preset) : void 0,
        advanced: Oe(P.advanced) ? a.EncodingOptions.fromJSON(P.advanced) : void 0
      };
    },
    toJSON(P) {
      const X = {};
      return P.url !== void 0 && (X.url = P.url), P.audioOnly !== void 0 && (X.audioOnly = P.audioOnly), P.videoOnly !== void 0 && (X.videoOnly = P.videoOnly), P.file !== void 0 && (X.file = P.file ? a.EncodedFileOutput.toJSON(P.file) : void 0), P.stream !== void 0 && (X.stream = P.stream ? a.StreamOutput.toJSON(P.stream) : void 0), P.segments !== void 0 && (X.segments = P.segments ? a.SegmentedFileOutput.toJSON(P.segments) : void 0), P.preset !== void 0 && (X.preset = P.preset !== void 0 ? Z(P.preset) : void 0), P.advanced !== void 0 && (X.advanced = P.advanced ? a.EncodingOptions.toJSON(P.advanced) : void 0), X;
    },
    fromPartial(P) {
      var X, ie, Ee, ue;
      const O = ye();
      return O.url = (X = P.url) !== null && X !== void 0 ? X : "", O.audioOnly = (ie = P.audioOnly) !== null && ie !== void 0 ? ie : !1, O.videoOnly = (Ee = P.videoOnly) !== null && Ee !== void 0 ? Ee : !1, O.file = P.file !== void 0 && P.file !== null ? a.EncodedFileOutput.fromPartial(P.file) : void 0, O.stream = P.stream !== void 0 && P.stream !== null ? a.StreamOutput.fromPartial(P.stream) : void 0, O.segments = P.segments !== void 0 && P.segments !== null ? a.SegmentedFileOutput.fromPartial(P.segments) : void 0, O.preset = (ue = P.preset) !== null && ue !== void 0 ? ue : void 0, O.advanced = P.advanced !== void 0 && P.advanced !== null ? a.EncodingOptions.fromPartial(P.advanced) : void 0, O;
    }
  };
  function he() {
    return {
      fileType: 0,
      filepath: "",
      disableManifest: !1,
      s3: void 0,
      gcp: void 0,
      azure: void 0,
      aliOSS: void 0
    };
  }
  a.EncodedFileOutput = {
    encode(P, X = l.default.Writer.create()) {
      return P.fileType !== void 0 && P.fileType !== 0 && X.uint32(8).int32(P.fileType), P.filepath !== void 0 && P.filepath !== "" && X.uint32(18).string(P.filepath), P.disableManifest === !0 && X.uint32(48).bool(P.disableManifest), P.s3 !== void 0 && a.S3Upload.encode(P.s3, X.uint32(26).fork()).ldelim(), P.gcp !== void 0 && a.GCPUpload.encode(P.gcp, X.uint32(34).fork()).ldelim(), P.azure !== void 0 && a.AzureBlobUpload.encode(P.azure, X.uint32(42).fork()).ldelim(), P.aliOSS !== void 0 && a.AliOSSUpload.encode(P.aliOSS, X.uint32(58).fork()).ldelim(), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = he();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.fileType = ie.int32();
            break;
          case 2:
            ue.filepath = ie.string();
            break;
          case 6:
            ue.disableManifest = ie.bool();
            break;
          case 3:
            ue.s3 = a.S3Upload.decode(ie, ie.uint32());
            break;
          case 4:
            ue.gcp = a.GCPUpload.decode(ie, ie.uint32());
            break;
          case 5:
            ue.azure = a.AzureBlobUpload.decode(ie, ie.uint32());
            break;
          case 7:
            ue.aliOSS = a.AliOSSUpload.decode(ie, ie.uint32());
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        fileType: Oe(P.fileType) ? S(P.fileType) : 0,
        filepath: Oe(P.filepath) ? String(P.filepath) : "",
        disableManifest: Oe(P.disableManifest) ? !!P.disableManifest : !1,
        s3: Oe(P.s3) ? a.S3Upload.fromJSON(P.s3) : void 0,
        gcp: Oe(P.gcp) ? a.GCPUpload.fromJSON(P.gcp) : void 0,
        azure: Oe(P.azure) ? a.AzureBlobUpload.fromJSON(P.azure) : void 0,
        aliOSS: Oe(P.aliOSS) ? a.AliOSSUpload.fromJSON(P.aliOSS) : void 0
      };
    },
    toJSON(P) {
      const X = {};
      return P.fileType !== void 0 && (X.fileType = g(P.fileType)), P.filepath !== void 0 && (X.filepath = P.filepath), P.disableManifest !== void 0 && (X.disableManifest = P.disableManifest), P.s3 !== void 0 && (X.s3 = P.s3 ? a.S3Upload.toJSON(P.s3) : void 0), P.gcp !== void 0 && (X.gcp = P.gcp ? a.GCPUpload.toJSON(P.gcp) : void 0), P.azure !== void 0 && (X.azure = P.azure ? a.AzureBlobUpload.toJSON(P.azure) : void 0), P.aliOSS !== void 0 && (X.aliOSS = P.aliOSS ? a.AliOSSUpload.toJSON(P.aliOSS) : void 0), X;
    },
    fromPartial(P) {
      var X, ie, Ee;
      const ue = he();
      return ue.fileType = (X = P.fileType) !== null && X !== void 0 ? X : 0, ue.filepath = (ie = P.filepath) !== null && ie !== void 0 ? ie : "", ue.disableManifest = (Ee = P.disableManifest) !== null && Ee !== void 0 ? Ee : !1, ue.s3 = P.s3 !== void 0 && P.s3 !== null ? a.S3Upload.fromPartial(P.s3) : void 0, ue.gcp = P.gcp !== void 0 && P.gcp !== null ? a.GCPUpload.fromPartial(P.gcp) : void 0, ue.azure = P.azure !== void 0 && P.azure !== null ? a.AzureBlobUpload.fromPartial(P.azure) : void 0, ue.aliOSS = P.aliOSS !== void 0 && P.aliOSS !== null ? a.AliOSSUpload.fromPartial(P.aliOSS) : void 0, ue;
    }
  };
  function le() {
    return {
      protocol: 0,
      filenamePrefix: "",
      playlistName: "",
      segmentDuration: 0,
      disableManifest: !1,
      s3: void 0,
      gcp: void 0,
      azure: void 0,
      aliOSS: void 0
    };
  }
  a.SegmentedFileOutput = {
    encode(P, X = l.default.Writer.create()) {
      return P.protocol !== void 0 && P.protocol !== 0 && X.uint32(8).int32(P.protocol), P.filenamePrefix !== void 0 && P.filenamePrefix !== "" && X.uint32(18).string(P.filenamePrefix), P.playlistName !== void 0 && P.playlistName !== "" && X.uint32(26).string(P.playlistName), P.segmentDuration !== void 0 && P.segmentDuration !== 0 && X.uint32(32).uint32(P.segmentDuration), P.disableManifest === !0 && X.uint32(64).bool(P.disableManifest), P.s3 !== void 0 && a.S3Upload.encode(P.s3, X.uint32(42).fork()).ldelim(), P.gcp !== void 0 && a.GCPUpload.encode(P.gcp, X.uint32(50).fork()).ldelim(), P.azure !== void 0 && a.AzureBlobUpload.encode(P.azure, X.uint32(58).fork()).ldelim(), P.aliOSS !== void 0 && a.AliOSSUpload.encode(P.aliOSS, X.uint32(74).fork()).ldelim(), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = le();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.protocol = ie.int32();
            break;
          case 2:
            ue.filenamePrefix = ie.string();
            break;
          case 3:
            ue.playlistName = ie.string();
            break;
          case 4:
            ue.segmentDuration = ie.uint32();
            break;
          case 8:
            ue.disableManifest = ie.bool();
            break;
          case 5:
            ue.s3 = a.S3Upload.decode(ie, ie.uint32());
            break;
          case 6:
            ue.gcp = a.GCPUpload.decode(ie, ie.uint32());
            break;
          case 7:
            ue.azure = a.AzureBlobUpload.decode(ie, ie.uint32());
            break;
          case 9:
            ue.aliOSS = a.AliOSSUpload.decode(ie, ie.uint32());
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        protocol: Oe(P.protocol) ? M(P.protocol) : 0,
        filenamePrefix: Oe(P.filenamePrefix) ? String(P.filenamePrefix) : "",
        playlistName: Oe(P.playlistName) ? String(P.playlistName) : "",
        segmentDuration: Oe(P.segmentDuration) ? Number(P.segmentDuration) : 0,
        disableManifest: Oe(P.disableManifest) ? !!P.disableManifest : !1,
        s3: Oe(P.s3) ? a.S3Upload.fromJSON(P.s3) : void 0,
        gcp: Oe(P.gcp) ? a.GCPUpload.fromJSON(P.gcp) : void 0,
        azure: Oe(P.azure) ? a.AzureBlobUpload.fromJSON(P.azure) : void 0,
        aliOSS: Oe(P.aliOSS) ? a.AliOSSUpload.fromJSON(P.aliOSS) : void 0
      };
    },
    toJSON(P) {
      const X = {};
      return P.protocol !== void 0 && (X.protocol = $(P.protocol)), P.filenamePrefix !== void 0 && (X.filenamePrefix = P.filenamePrefix), P.playlistName !== void 0 && (X.playlistName = P.playlistName), P.segmentDuration !== void 0 && (X.segmentDuration = Math.round(P.segmentDuration)), P.disableManifest !== void 0 && (X.disableManifest = P.disableManifest), P.s3 !== void 0 && (X.s3 = P.s3 ? a.S3Upload.toJSON(P.s3) : void 0), P.gcp !== void 0 && (X.gcp = P.gcp ? a.GCPUpload.toJSON(P.gcp) : void 0), P.azure !== void 0 && (X.azure = P.azure ? a.AzureBlobUpload.toJSON(P.azure) : void 0), P.aliOSS !== void 0 && (X.aliOSS = P.aliOSS ? a.AliOSSUpload.toJSON(P.aliOSS) : void 0), X;
    },
    fromPartial(P) {
      var X, ie, Ee, ue, O;
      const j = le();
      return j.protocol = (X = P.protocol) !== null && X !== void 0 ? X : 0, j.filenamePrefix = (ie = P.filenamePrefix) !== null && ie !== void 0 ? ie : "", j.playlistName = (Ee = P.playlistName) !== null && Ee !== void 0 ? Ee : "", j.segmentDuration = (ue = P.segmentDuration) !== null && ue !== void 0 ? ue : 0, j.disableManifest = (O = P.disableManifest) !== null && O !== void 0 ? O : !1, j.s3 = P.s3 !== void 0 && P.s3 !== null ? a.S3Upload.fromPartial(P.s3) : void 0, j.gcp = P.gcp !== void 0 && P.gcp !== null ? a.GCPUpload.fromPartial(P.gcp) : void 0, j.azure = P.azure !== void 0 && P.azure !== null ? a.AzureBlobUpload.fromPartial(P.azure) : void 0, j.aliOSS = P.aliOSS !== void 0 && P.aliOSS !== null ? a.AliOSSUpload.fromPartial(P.aliOSS) : void 0, j;
    }
  };
  function we() {
    return { filepath: "", disableManifest: !1, s3: void 0, gcp: void 0, azure: void 0, aliOSS: void 0 };
  }
  a.DirectFileOutput = {
    encode(P, X = l.default.Writer.create()) {
      return P.filepath !== void 0 && P.filepath !== "" && X.uint32(10).string(P.filepath), P.disableManifest === !0 && X.uint32(40).bool(P.disableManifest), P.s3 !== void 0 && a.S3Upload.encode(P.s3, X.uint32(18).fork()).ldelim(), P.gcp !== void 0 && a.GCPUpload.encode(P.gcp, X.uint32(26).fork()).ldelim(), P.azure !== void 0 && a.AzureBlobUpload.encode(P.azure, X.uint32(34).fork()).ldelim(), P.aliOSS !== void 0 && a.AliOSSUpload.encode(P.aliOSS, X.uint32(50).fork()).ldelim(), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = we();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.filepath = ie.string();
            break;
          case 5:
            ue.disableManifest = ie.bool();
            break;
          case 2:
            ue.s3 = a.S3Upload.decode(ie, ie.uint32());
            break;
          case 3:
            ue.gcp = a.GCPUpload.decode(ie, ie.uint32());
            break;
          case 4:
            ue.azure = a.AzureBlobUpload.decode(ie, ie.uint32());
            break;
          case 6:
            ue.aliOSS = a.AliOSSUpload.decode(ie, ie.uint32());
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        filepath: Oe(P.filepath) ? String(P.filepath) : "",
        disableManifest: Oe(P.disableManifest) ? !!P.disableManifest : !1,
        s3: Oe(P.s3) ? a.S3Upload.fromJSON(P.s3) : void 0,
        gcp: Oe(P.gcp) ? a.GCPUpload.fromJSON(P.gcp) : void 0,
        azure: Oe(P.azure) ? a.AzureBlobUpload.fromJSON(P.azure) : void 0,
        aliOSS: Oe(P.aliOSS) ? a.AliOSSUpload.fromJSON(P.aliOSS) : void 0
      };
    },
    toJSON(P) {
      const X = {};
      return P.filepath !== void 0 && (X.filepath = P.filepath), P.disableManifest !== void 0 && (X.disableManifest = P.disableManifest), P.s3 !== void 0 && (X.s3 = P.s3 ? a.S3Upload.toJSON(P.s3) : void 0), P.gcp !== void 0 && (X.gcp = P.gcp ? a.GCPUpload.toJSON(P.gcp) : void 0), P.azure !== void 0 && (X.azure = P.azure ? a.AzureBlobUpload.toJSON(P.azure) : void 0), P.aliOSS !== void 0 && (X.aliOSS = P.aliOSS ? a.AliOSSUpload.toJSON(P.aliOSS) : void 0), X;
    },
    fromPartial(P) {
      var X, ie;
      const Ee = we();
      return Ee.filepath = (X = P.filepath) !== null && X !== void 0 ? X : "", Ee.disableManifest = (ie = P.disableManifest) !== null && ie !== void 0 ? ie : !1, Ee.s3 = P.s3 !== void 0 && P.s3 !== null ? a.S3Upload.fromPartial(P.s3) : void 0, Ee.gcp = P.gcp !== void 0 && P.gcp !== null ? a.GCPUpload.fromPartial(P.gcp) : void 0, Ee.azure = P.azure !== void 0 && P.azure !== null ? a.AzureBlobUpload.fromPartial(P.azure) : void 0, Ee.aliOSS = P.aliOSS !== void 0 && P.aliOSS !== null ? a.AliOSSUpload.fromPartial(P.aliOSS) : void 0, Ee;
    }
  };
  function Be() {
    return {
      accessKey: "",
      secret: "",
      region: "",
      endpoint: "",
      bucket: "",
      forcePathStyle: !1,
      metadata: {},
      tagging: ""
    };
  }
  a.S3Upload = {
    encode(P, X = l.default.Writer.create()) {
      return P.accessKey !== void 0 && P.accessKey !== "" && X.uint32(10).string(P.accessKey), P.secret !== void 0 && P.secret !== "" && X.uint32(18).string(P.secret), P.region !== void 0 && P.region !== "" && X.uint32(26).string(P.region), P.endpoint !== void 0 && P.endpoint !== "" && X.uint32(34).string(P.endpoint), P.bucket !== void 0 && P.bucket !== "" && X.uint32(42).string(P.bucket), P.forcePathStyle === !0 && X.uint32(48).bool(P.forcePathStyle), Object.entries(P.metadata || {}).forEach(([ie, Ee]) => {
        a.S3Upload_MetadataEntry.encode({ key: ie, value: Ee }, X.uint32(58).fork()).ldelim();
      }), P.tagging !== void 0 && P.tagging !== "" && X.uint32(66).string(P.tagging), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = Be();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.accessKey = ie.string();
            break;
          case 2:
            ue.secret = ie.string();
            break;
          case 3:
            ue.region = ie.string();
            break;
          case 4:
            ue.endpoint = ie.string();
            break;
          case 5:
            ue.bucket = ie.string();
            break;
          case 6:
            ue.forcePathStyle = ie.bool();
            break;
          case 7:
            const j = a.S3Upload_MetadataEntry.decode(ie, ie.uint32());
            j.value !== void 0 && (ue.metadata[j.key] = j.value);
            break;
          case 8:
            ue.tagging = ie.string();
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        accessKey: Oe(P.accessKey) ? String(P.accessKey) : "",
        secret: Oe(P.secret) ? String(P.secret) : "",
        region: Oe(P.region) ? String(P.region) : "",
        endpoint: Oe(P.endpoint) ? String(P.endpoint) : "",
        bucket: Oe(P.bucket) ? String(P.bucket) : "",
        forcePathStyle: Oe(P.forcePathStyle) ? !!P.forcePathStyle : !1,
        metadata: tt(P.metadata) ? Object.entries(P.metadata).reduce((X, [ie, Ee]) => (X[ie] = String(Ee), X), {}) : {},
        tagging: Oe(P.tagging) ? String(P.tagging) : ""
      };
    },
    toJSON(P) {
      const X = {};
      return P.accessKey !== void 0 && (X.accessKey = P.accessKey), P.secret !== void 0 && (X.secret = P.secret), P.region !== void 0 && (X.region = P.region), P.endpoint !== void 0 && (X.endpoint = P.endpoint), P.bucket !== void 0 && (X.bucket = P.bucket), P.forcePathStyle !== void 0 && (X.forcePathStyle = P.forcePathStyle), X.metadata = {}, P.metadata && Object.entries(P.metadata).forEach(([ie, Ee]) => {
        X.metadata[ie] = Ee;
      }), P.tagging !== void 0 && (X.tagging = P.tagging), X;
    },
    fromPartial(P) {
      var X, ie, Ee, ue, O, j, se, _e;
      const ve = Be();
      return ve.accessKey = (X = P.accessKey) !== null && X !== void 0 ? X : "", ve.secret = (ie = P.secret) !== null && ie !== void 0 ? ie : "", ve.region = (Ee = P.region) !== null && Ee !== void 0 ? Ee : "", ve.endpoint = (ue = P.endpoint) !== null && ue !== void 0 ? ue : "", ve.bucket = (O = P.bucket) !== null && O !== void 0 ? O : "", ve.forcePathStyle = (j = P.forcePathStyle) !== null && j !== void 0 ? j : !1, ve.metadata = Object.entries((se = P.metadata) !== null && se !== void 0 ? se : {}).reduce((De, [Ze, Qe]) => (Qe !== void 0 && (De[Ze] = String(Qe)), De), {}), ve.tagging = (_e = P.tagging) !== null && _e !== void 0 ? _e : "", ve;
    }
  };
  function Ne() {
    return { key: "", value: "" };
  }
  a.S3Upload_MetadataEntry = {
    encode(P, X = l.default.Writer.create()) {
      return P.key !== "" && X.uint32(10).string(P.key), P.value !== "" && X.uint32(18).string(P.value), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = Ne();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.key = ie.string();
            break;
          case 2:
            ue.value = ie.string();
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return { key: Oe(P.key) ? String(P.key) : "", value: Oe(P.value) ? String(P.value) : "" };
    },
    toJSON(P) {
      const X = {};
      return P.key !== void 0 && (X.key = P.key), P.value !== void 0 && (X.value = P.value), X;
    },
    fromPartial(P) {
      var X, ie;
      const Ee = Ne();
      return Ee.key = (X = P.key) !== null && X !== void 0 ? X : "", Ee.value = (ie = P.value) !== null && ie !== void 0 ? ie : "", Ee;
    }
  };
  function Le() {
    return { credentials: new Uint8Array(), bucket: "" };
  }
  a.GCPUpload = {
    encode(P, X = l.default.Writer.create()) {
      return P.credentials !== void 0 && P.credentials.length !== 0 && X.uint32(10).bytes(P.credentials), P.bucket !== void 0 && P.bucket !== "" && X.uint32(18).string(P.bucket), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = Le();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.credentials = ie.bytes();
            break;
          case 2:
            ue.bucket = ie.string();
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        credentials: Oe(P.credentials) ? at(P.credentials) : new Uint8Array(),
        bucket: Oe(P.bucket) ? String(P.bucket) : ""
      };
    },
    toJSON(P) {
      const X = {};
      return P.credentials !== void 0 && (X.credentials = Ye(P.credentials !== void 0 ? P.credentials : new Uint8Array())), P.bucket !== void 0 && (X.bucket = P.bucket), X;
    },
    fromPartial(P) {
      var X, ie;
      const Ee = Le();
      return Ee.credentials = (X = P.credentials) !== null && X !== void 0 ? X : new Uint8Array(), Ee.bucket = (ie = P.bucket) !== null && ie !== void 0 ? ie : "", Ee;
    }
  };
  function $e() {
    return { accountName: "", accountKey: "", containerName: "" };
  }
  a.AzureBlobUpload = {
    encode(P, X = l.default.Writer.create()) {
      return P.accountName !== void 0 && P.accountName !== "" && X.uint32(10).string(P.accountName), P.accountKey !== void 0 && P.accountKey !== "" && X.uint32(18).string(P.accountKey), P.containerName !== void 0 && P.containerName !== "" && X.uint32(26).string(P.containerName), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = $e();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.accountName = ie.string();
            break;
          case 2:
            ue.accountKey = ie.string();
            break;
          case 3:
            ue.containerName = ie.string();
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        accountName: Oe(P.accountName) ? String(P.accountName) : "",
        accountKey: Oe(P.accountKey) ? String(P.accountKey) : "",
        containerName: Oe(P.containerName) ? String(P.containerName) : ""
      };
    },
    toJSON(P) {
      const X = {};
      return P.accountName !== void 0 && (X.accountName = P.accountName), P.accountKey !== void 0 && (X.accountKey = P.accountKey), P.containerName !== void 0 && (X.containerName = P.containerName), X;
    },
    fromPartial(P) {
      var X, ie, Ee;
      const ue = $e();
      return ue.accountName = (X = P.accountName) !== null && X !== void 0 ? X : "", ue.accountKey = (ie = P.accountKey) !== null && ie !== void 0 ? ie : "", ue.containerName = (Ee = P.containerName) !== null && Ee !== void 0 ? Ee : "", ue;
    }
  };
  function Ue() {
    return { accessKey: "", secret: "", region: "", endpoint: "", bucket: "" };
  }
  a.AliOSSUpload = {
    encode(P, X = l.default.Writer.create()) {
      return P.accessKey !== void 0 && P.accessKey !== "" && X.uint32(10).string(P.accessKey), P.secret !== void 0 && P.secret !== "" && X.uint32(18).string(P.secret), P.region !== void 0 && P.region !== "" && X.uint32(26).string(P.region), P.endpoint !== void 0 && P.endpoint !== "" && X.uint32(34).string(P.endpoint), P.bucket !== void 0 && P.bucket !== "" && X.uint32(42).string(P.bucket), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = Ue();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.accessKey = ie.string();
            break;
          case 2:
            ue.secret = ie.string();
            break;
          case 3:
            ue.region = ie.string();
            break;
          case 4:
            ue.endpoint = ie.string();
            break;
          case 5:
            ue.bucket = ie.string();
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        accessKey: Oe(P.accessKey) ? String(P.accessKey) : "",
        secret: Oe(P.secret) ? String(P.secret) : "",
        region: Oe(P.region) ? String(P.region) : "",
        endpoint: Oe(P.endpoint) ? String(P.endpoint) : "",
        bucket: Oe(P.bucket) ? String(P.bucket) : ""
      };
    },
    toJSON(P) {
      const X = {};
      return P.accessKey !== void 0 && (X.accessKey = P.accessKey), P.secret !== void 0 && (X.secret = P.secret), P.region !== void 0 && (X.region = P.region), P.endpoint !== void 0 && (X.endpoint = P.endpoint), P.bucket !== void 0 && (X.bucket = P.bucket), X;
    },
    fromPartial(P) {
      var X, ie, Ee, ue, O;
      const j = Ue();
      return j.accessKey = (X = P.accessKey) !== null && X !== void 0 ? X : "", j.secret = (ie = P.secret) !== null && ie !== void 0 ? ie : "", j.region = (Ee = P.region) !== null && Ee !== void 0 ? Ee : "", j.endpoint = (ue = P.endpoint) !== null && ue !== void 0 ? ue : "", j.bucket = (O = P.bucket) !== null && O !== void 0 ? O : "", j;
    }
  };
  function Ge() {
    return { protocol: 0, urls: [] };
  }
  a.StreamOutput = {
    encode(P, X = l.default.Writer.create()) {
      if (P.protocol !== void 0 && P.protocol !== 0 && X.uint32(8).int32(P.protocol), P.urls !== void 0 && P.urls.length !== 0)
        for (const ie of P.urls)
          X.uint32(18).string(ie);
      return X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = Ge();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.protocol = ie.int32();
            break;
          case 2:
            ue.urls.push(ie.string());
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        protocol: Oe(P.protocol) ? _(P.protocol) : 0,
        urls: Array.isArray(P == null ? void 0 : P.urls) ? P.urls.map((X) => String(X)) : []
      };
    },
    toJSON(P) {
      const X = {};
      return P.protocol !== void 0 && (X.protocol = k(P.protocol)), P.urls ? X.urls = P.urls.map((ie) => ie) : X.urls = [], X;
    },
    fromPartial(P) {
      var X, ie;
      const Ee = Ge();
      return Ee.protocol = (X = P.protocol) !== null && X !== void 0 ? X : 0, Ee.urls = ((ie = P.urls) === null || ie === void 0 ? void 0 : ie.map((ue) => ue)) || [], Ee;
    }
  };
  function He() {
    return {
      width: 0,
      height: 0,
      depth: 0,
      framerate: 0,
      audioCodec: 0,
      audioBitrate: 0,
      audioFrequency: 0,
      videoCodec: 0,
      videoBitrate: 0
    };
  }
  a.EncodingOptions = {
    encode(P, X = l.default.Writer.create()) {
      return P.width !== void 0 && P.width !== 0 && X.uint32(8).int32(P.width), P.height !== void 0 && P.height !== 0 && X.uint32(16).int32(P.height), P.depth !== void 0 && P.depth !== 0 && X.uint32(24).int32(P.depth), P.framerate !== void 0 && P.framerate !== 0 && X.uint32(32).int32(P.framerate), P.audioCodec !== void 0 && P.audioCodec !== 0 && X.uint32(40).int32(P.audioCodec), P.audioBitrate !== void 0 && P.audioBitrate !== 0 && X.uint32(48).int32(P.audioBitrate), P.audioFrequency !== void 0 && P.audioFrequency !== 0 && X.uint32(56).int32(P.audioFrequency), P.videoCodec !== void 0 && P.videoCodec !== 0 && X.uint32(64).int32(P.videoCodec), P.videoBitrate !== void 0 && P.videoBitrate !== 0 && X.uint32(72).int32(P.videoBitrate), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = He();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.width = ie.int32();
            break;
          case 2:
            ue.height = ie.int32();
            break;
          case 3:
            ue.depth = ie.int32();
            break;
          case 4:
            ue.framerate = ie.int32();
            break;
          case 5:
            ue.audioCodec = ie.int32();
            break;
          case 6:
            ue.audioBitrate = ie.int32();
            break;
          case 7:
            ue.audioFrequency = ie.int32();
            break;
          case 8:
            ue.videoCodec = ie.int32();
            break;
          case 9:
            ue.videoBitrate = ie.int32();
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        width: Oe(P.width) ? Number(P.width) : 0,
        height: Oe(P.height) ? Number(P.height) : 0,
        depth: Oe(P.depth) ? Number(P.depth) : 0,
        framerate: Oe(P.framerate) ? Number(P.framerate) : 0,
        audioCodec: Oe(P.audioCodec) ? V(P.audioCodec) : 0,
        audioBitrate: Oe(P.audioBitrate) ? Number(P.audioBitrate) : 0,
        audioFrequency: Oe(P.audioFrequency) ? Number(P.audioFrequency) : 0,
        videoCodec: Oe(P.videoCodec) ? H(P.videoCodec) : 0,
        videoBitrate: Oe(P.videoBitrate) ? Number(P.videoBitrate) : 0
      };
    },
    toJSON(P) {
      const X = {};
      return P.width !== void 0 && (X.width = Math.round(P.width)), P.height !== void 0 && (X.height = Math.round(P.height)), P.depth !== void 0 && (X.depth = Math.round(P.depth)), P.framerate !== void 0 && (X.framerate = Math.round(P.framerate)), P.audioCodec !== void 0 && (X.audioCodec = q(P.audioCodec)), P.audioBitrate !== void 0 && (X.audioBitrate = Math.round(P.audioBitrate)), P.audioFrequency !== void 0 && (X.audioFrequency = Math.round(P.audioFrequency)), P.videoCodec !== void 0 && (X.videoCodec = B(P.videoCodec)), P.videoBitrate !== void 0 && (X.videoBitrate = Math.round(P.videoBitrate)), X;
    },
    fromPartial(P) {
      var X, ie, Ee, ue, O, j, se, _e, ve;
      const De = He();
      return De.width = (X = P.width) !== null && X !== void 0 ? X : 0, De.height = (ie = P.height) !== null && ie !== void 0 ? ie : 0, De.depth = (Ee = P.depth) !== null && Ee !== void 0 ? Ee : 0, De.framerate = (ue = P.framerate) !== null && ue !== void 0 ? ue : 0, De.audioCodec = (O = P.audioCodec) !== null && O !== void 0 ? O : 0, De.audioBitrate = (j = P.audioBitrate) !== null && j !== void 0 ? j : 0, De.audioFrequency = (se = P.audioFrequency) !== null && se !== void 0 ? se : 0, De.videoCodec = (_e = P.videoCodec) !== null && _e !== void 0 ? _e : 0, De.videoBitrate = (ve = P.videoBitrate) !== null && ve !== void 0 ? ve : 0, De;
    }
  };
  function Ve() {
    return { egressId: "", layout: "" };
  }
  a.UpdateLayoutRequest = {
    encode(P, X = l.default.Writer.create()) {
      return P.egressId !== void 0 && P.egressId !== "" && X.uint32(10).string(P.egressId), P.layout !== void 0 && P.layout !== "" && X.uint32(18).string(P.layout), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = Ve();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.egressId = ie.string();
            break;
          case 2:
            ue.layout = ie.string();
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        egressId: Oe(P.egressId) ? String(P.egressId) : "",
        layout: Oe(P.layout) ? String(P.layout) : ""
      };
    },
    toJSON(P) {
      const X = {};
      return P.egressId !== void 0 && (X.egressId = P.egressId), P.layout !== void 0 && (X.layout = P.layout), X;
    },
    fromPartial(P) {
      var X, ie;
      const Ee = Ve();
      return Ee.egressId = (X = P.egressId) !== null && X !== void 0 ? X : "", Ee.layout = (ie = P.layout) !== null && ie !== void 0 ? ie : "", Ee;
    }
  };
  function be() {
    return { egressId: "", addOutputUrls: [], removeOutputUrls: [] };
  }
  a.UpdateStreamRequest = {
    encode(P, X = l.default.Writer.create()) {
      if (P.egressId !== void 0 && P.egressId !== "" && X.uint32(10).string(P.egressId), P.addOutputUrls !== void 0 && P.addOutputUrls.length !== 0)
        for (const ie of P.addOutputUrls)
          X.uint32(18).string(ie);
      if (P.removeOutputUrls !== void 0 && P.removeOutputUrls.length !== 0)
        for (const ie of P.removeOutputUrls)
          X.uint32(26).string(ie);
      return X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = be();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.egressId = ie.string();
            break;
          case 2:
            ue.addOutputUrls.push(ie.string());
            break;
          case 3:
            ue.removeOutputUrls.push(ie.string());
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        egressId: Oe(P.egressId) ? String(P.egressId) : "",
        addOutputUrls: Array.isArray(P == null ? void 0 : P.addOutputUrls) ? P.addOutputUrls.map((X) => String(X)) : [],
        removeOutputUrls: Array.isArray(P == null ? void 0 : P.removeOutputUrls) ? P.removeOutputUrls.map((X) => String(X)) : []
      };
    },
    toJSON(P) {
      const X = {};
      return P.egressId !== void 0 && (X.egressId = P.egressId), P.addOutputUrls ? X.addOutputUrls = P.addOutputUrls.map((ie) => ie) : X.addOutputUrls = [], P.removeOutputUrls ? X.removeOutputUrls = P.removeOutputUrls.map((ie) => ie) : X.removeOutputUrls = [], X;
    },
    fromPartial(P) {
      var X, ie, Ee;
      const ue = be();
      return ue.egressId = (X = P.egressId) !== null && X !== void 0 ? X : "", ue.addOutputUrls = ((ie = P.addOutputUrls) === null || ie === void 0 ? void 0 : ie.map((O) => O)) || [], ue.removeOutputUrls = ((Ee = P.removeOutputUrls) === null || Ee === void 0 ? void 0 : Ee.map((O) => O)) || [], ue;
    }
  };
  function Ae() {
    return { roomName: "" };
  }
  a.ListEgressRequest = {
    encode(P, X = l.default.Writer.create()) {
      return P.roomName !== void 0 && P.roomName !== "" && X.uint32(10).string(P.roomName), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = Ae();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.roomName = ie.string();
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return { roomName: Oe(P.roomName) ? String(P.roomName) : "" };
    },
    toJSON(P) {
      const X = {};
      return P.roomName !== void 0 && (X.roomName = P.roomName), X;
    },
    fromPartial(P) {
      var X;
      const ie = Ae();
      return ie.roomName = (X = P.roomName) !== null && X !== void 0 ? X : "", ie;
    }
  };
  function qe() {
    return { items: [] };
  }
  a.ListEgressResponse = {
    encode(P, X = l.default.Writer.create()) {
      if (P.items !== void 0 && P.items.length !== 0)
        for (const ie of P.items)
          a.EgressInfo.encode(ie, X.uint32(10).fork()).ldelim();
      return X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = qe();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.items.push(a.EgressInfo.decode(ie, ie.uint32()));
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return { items: Array.isArray(P == null ? void 0 : P.items) ? P.items.map((X) => a.EgressInfo.fromJSON(X)) : [] };
    },
    toJSON(P) {
      const X = {};
      return P.items ? X.items = P.items.map((ie) => ie ? a.EgressInfo.toJSON(ie) : void 0) : X.items = [], X;
    },
    fromPartial(P) {
      var X;
      const ie = qe();
      return ie.items = ((X = P.items) === null || X === void 0 ? void 0 : X.map((Ee) => a.EgressInfo.fromPartial(Ee))) || [], ie;
    }
  };
  function xe() {
    return { egressId: "" };
  }
  a.StopEgressRequest = {
    encode(P, X = l.default.Writer.create()) {
      return P.egressId !== void 0 && P.egressId !== "" && X.uint32(10).string(P.egressId), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = xe();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.egressId = ie.string();
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return { egressId: Oe(P.egressId) ? String(P.egressId) : "" };
    },
    toJSON(P) {
      const X = {};
      return P.egressId !== void 0 && (X.egressId = P.egressId), X;
    },
    fromPartial(P) {
      var X;
      const ie = xe();
      return ie.egressId = (X = P.egressId) !== null && X !== void 0 ? X : "", ie;
    }
  };
  function Pe() {
    return {
      egressId: "",
      roomId: "",
      roomName: "",
      status: 0,
      startedAt: 0,
      endedAt: 0,
      error: "",
      roomComposite: void 0,
      trackComposite: void 0,
      track: void 0,
      web: void 0,
      stream: void 0,
      file: void 0,
      segments: void 0
    };
  }
  a.EgressInfo = {
    encode(P, X = l.default.Writer.create()) {
      return P.egressId !== void 0 && P.egressId !== "" && X.uint32(10).string(P.egressId), P.roomId !== void 0 && P.roomId !== "" && X.uint32(18).string(P.roomId), P.roomName !== void 0 && P.roomName !== "" && X.uint32(106).string(P.roomName), P.status !== void 0 && P.status !== 0 && X.uint32(24).int32(P.status), P.startedAt !== void 0 && P.startedAt !== 0 && X.uint32(80).int64(P.startedAt), P.endedAt !== void 0 && P.endedAt !== 0 && X.uint32(88).int64(P.endedAt), P.error !== void 0 && P.error !== "" && X.uint32(74).string(P.error), P.roomComposite !== void 0 && a.RoomCompositeEgressRequest.encode(P.roomComposite, X.uint32(34).fork()).ldelim(), P.trackComposite !== void 0 && a.TrackCompositeEgressRequest.encode(P.trackComposite, X.uint32(42).fork()).ldelim(), P.track !== void 0 && a.TrackEgressRequest.encode(P.track, X.uint32(50).fork()).ldelim(), P.web !== void 0 && a.WebEgressRequest.encode(P.web, X.uint32(114).fork()).ldelim(), P.stream !== void 0 && a.StreamInfoList.encode(P.stream, X.uint32(58).fork()).ldelim(), P.file !== void 0 && a.FileInfo.encode(P.file, X.uint32(66).fork()).ldelim(), P.segments !== void 0 && a.SegmentsInfo.encode(P.segments, X.uint32(98).fork()).ldelim(), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = Pe();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.egressId = ie.string();
            break;
          case 2:
            ue.roomId = ie.string();
            break;
          case 13:
            ue.roomName = ie.string();
            break;
          case 3:
            ue.status = ie.int32();
            break;
          case 10:
            ue.startedAt = je(ie.int64());
            break;
          case 11:
            ue.endedAt = je(ie.int64());
            break;
          case 9:
            ue.error = ie.string();
            break;
          case 4:
            ue.roomComposite = a.RoomCompositeEgressRequest.decode(ie, ie.uint32());
            break;
          case 5:
            ue.trackComposite = a.TrackCompositeEgressRequest.decode(ie, ie.uint32());
            break;
          case 6:
            ue.track = a.TrackEgressRequest.decode(ie, ie.uint32());
            break;
          case 14:
            ue.web = a.WebEgressRequest.decode(ie, ie.uint32());
            break;
          case 7:
            ue.stream = a.StreamInfoList.decode(ie, ie.uint32());
            break;
          case 8:
            ue.file = a.FileInfo.decode(ie, ie.uint32());
            break;
          case 12:
            ue.segments = a.SegmentsInfo.decode(ie, ie.uint32());
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        egressId: Oe(P.egressId) ? String(P.egressId) : "",
        roomId: Oe(P.roomId) ? String(P.roomId) : "",
        roomName: Oe(P.roomName) ? String(P.roomName) : "",
        status: Oe(P.status) ? oe(P.status) : 0,
        startedAt: Oe(P.startedAt) ? Number(P.startedAt) : 0,
        endedAt: Oe(P.endedAt) ? Number(P.endedAt) : 0,
        error: Oe(P.error) ? String(P.error) : "",
        roomComposite: Oe(P.roomComposite) ? a.RoomCompositeEgressRequest.fromJSON(P.roomComposite) : void 0,
        trackComposite: Oe(P.trackComposite) ? a.TrackCompositeEgressRequest.fromJSON(P.trackComposite) : void 0,
        track: Oe(P.track) ? a.TrackEgressRequest.fromJSON(P.track) : void 0,
        web: Oe(P.web) ? a.WebEgressRequest.fromJSON(P.web) : void 0,
        stream: Oe(P.stream) ? a.StreamInfoList.fromJSON(P.stream) : void 0,
        file: Oe(P.file) ? a.FileInfo.fromJSON(P.file) : void 0,
        segments: Oe(P.segments) ? a.SegmentsInfo.fromJSON(P.segments) : void 0
      };
    },
    toJSON(P) {
      const X = {};
      return P.egressId !== void 0 && (X.egressId = P.egressId), P.roomId !== void 0 && (X.roomId = P.roomId), P.roomName !== void 0 && (X.roomName = P.roomName), P.status !== void 0 && (X.status = de(P.status)), P.startedAt !== void 0 && (X.startedAt = Math.round(P.startedAt)), P.endedAt !== void 0 && (X.endedAt = Math.round(P.endedAt)), P.error !== void 0 && (X.error = P.error), P.roomComposite !== void 0 && (X.roomComposite = P.roomComposite ? a.RoomCompositeEgressRequest.toJSON(P.roomComposite) : void 0), P.trackComposite !== void 0 && (X.trackComposite = P.trackComposite ? a.TrackCompositeEgressRequest.toJSON(P.trackComposite) : void 0), P.track !== void 0 && (X.track = P.track ? a.TrackEgressRequest.toJSON(P.track) : void 0), P.web !== void 0 && (X.web = P.web ? a.WebEgressRequest.toJSON(P.web) : void 0), P.stream !== void 0 && (X.stream = P.stream ? a.StreamInfoList.toJSON(P.stream) : void 0), P.file !== void 0 && (X.file = P.file ? a.FileInfo.toJSON(P.file) : void 0), P.segments !== void 0 && (X.segments = P.segments ? a.SegmentsInfo.toJSON(P.segments) : void 0), X;
    },
    fromPartial(P) {
      var X, ie, Ee, ue, O, j, se;
      const _e = Pe();
      return _e.egressId = (X = P.egressId) !== null && X !== void 0 ? X : "", _e.roomId = (ie = P.roomId) !== null && ie !== void 0 ? ie : "", _e.roomName = (Ee = P.roomName) !== null && Ee !== void 0 ? Ee : "", _e.status = (ue = P.status) !== null && ue !== void 0 ? ue : 0, _e.startedAt = (O = P.startedAt) !== null && O !== void 0 ? O : 0, _e.endedAt = (j = P.endedAt) !== null && j !== void 0 ? j : 0, _e.error = (se = P.error) !== null && se !== void 0 ? se : "", _e.roomComposite = P.roomComposite !== void 0 && P.roomComposite !== null ? a.RoomCompositeEgressRequest.fromPartial(P.roomComposite) : void 0, _e.trackComposite = P.trackComposite !== void 0 && P.trackComposite !== null ? a.TrackCompositeEgressRequest.fromPartial(P.trackComposite) : void 0, _e.track = P.track !== void 0 && P.track !== null ? a.TrackEgressRequest.fromPartial(P.track) : void 0, _e.web = P.web !== void 0 && P.web !== null ? a.WebEgressRequest.fromPartial(P.web) : void 0, _e.stream = P.stream !== void 0 && P.stream !== null ? a.StreamInfoList.fromPartial(P.stream) : void 0, _e.file = P.file !== void 0 && P.file !== null ? a.FileInfo.fromPartial(P.file) : void 0, _e.segments = P.segments !== void 0 && P.segments !== null ? a.SegmentsInfo.fromPartial(P.segments) : void 0, _e;
    }
  };
  function C() {
    return { info: [] };
  }
  a.StreamInfoList = {
    encode(P, X = l.default.Writer.create()) {
      if (P.info !== void 0 && P.info.length !== 0)
        for (const ie of P.info)
          a.StreamInfo.encode(ie, X.uint32(10).fork()).ldelim();
      return X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = C();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.info.push(a.StreamInfo.decode(ie, ie.uint32()));
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return { info: Array.isArray(P == null ? void 0 : P.info) ? P.info.map((X) => a.StreamInfo.fromJSON(X)) : [] };
    },
    toJSON(P) {
      const X = {};
      return P.info ? X.info = P.info.map((ie) => ie ? a.StreamInfo.toJSON(ie) : void 0) : X.info = [], X;
    },
    fromPartial(P) {
      var X;
      const ie = C();
      return ie.info = ((X = P.info) === null || X === void 0 ? void 0 : X.map((Ee) => a.StreamInfo.fromPartial(Ee))) || [], ie;
    }
  };
  function x() {
    return { url: "", startedAt: 0, endedAt: 0, duration: 0, status: 0 };
  }
  a.StreamInfo = {
    encode(P, X = l.default.Writer.create()) {
      return P.url !== void 0 && P.url !== "" && X.uint32(10).string(P.url), P.startedAt !== void 0 && P.startedAt !== 0 && X.uint32(16).int64(P.startedAt), P.endedAt !== void 0 && P.endedAt !== 0 && X.uint32(24).int64(P.endedAt), P.duration !== void 0 && P.duration !== 0 && X.uint32(32).int64(P.duration), P.status !== void 0 && P.status !== 0 && X.uint32(40).int32(P.status), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = x();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.url = ie.string();
            break;
          case 2:
            ue.startedAt = je(ie.int64());
            break;
          case 3:
            ue.endedAt = je(ie.int64());
            break;
          case 4:
            ue.duration = je(ie.int64());
            break;
          case 5:
            ue.status = ie.int32();
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        url: Oe(P.url) ? String(P.url) : "",
        startedAt: Oe(P.startedAt) ? Number(P.startedAt) : 0,
        endedAt: Oe(P.endedAt) ? Number(P.endedAt) : 0,
        duration: Oe(P.duration) ? Number(P.duration) : 0,
        status: Oe(P.status) ? N(P.status) : 0
      };
    },
    toJSON(P) {
      const X = {};
      return P.url !== void 0 && (X.url = P.url), P.startedAt !== void 0 && (X.startedAt = Math.round(P.startedAt)), P.endedAt !== void 0 && (X.endedAt = Math.round(P.endedAt)), P.duration !== void 0 && (X.duration = Math.round(P.duration)), P.status !== void 0 && (X.status = D(P.status)), X;
    },
    fromPartial(P) {
      var X, ie, Ee, ue, O;
      const j = x();
      return j.url = (X = P.url) !== null && X !== void 0 ? X : "", j.startedAt = (ie = P.startedAt) !== null && ie !== void 0 ? ie : 0, j.endedAt = (Ee = P.endedAt) !== null && Ee !== void 0 ? Ee : 0, j.duration = (ue = P.duration) !== null && ue !== void 0 ? ue : 0, j.status = (O = P.status) !== null && O !== void 0 ? O : 0, j;
    }
  };
  function Q() {
    return { filename: "", startedAt: 0, endedAt: 0, duration: 0, size: 0, location: "" };
  }
  a.FileInfo = {
    encode(P, X = l.default.Writer.create()) {
      return P.filename !== void 0 && P.filename !== "" && X.uint32(10).string(P.filename), P.startedAt !== void 0 && P.startedAt !== 0 && X.uint32(16).int64(P.startedAt), P.endedAt !== void 0 && P.endedAt !== 0 && X.uint32(24).int64(P.endedAt), P.duration !== void 0 && P.duration !== 0 && X.uint32(48).int64(P.duration), P.size !== void 0 && P.size !== 0 && X.uint32(32).int64(P.size), P.location !== void 0 && P.location !== "" && X.uint32(42).string(P.location), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = Q();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.filename = ie.string();
            break;
          case 2:
            ue.startedAt = je(ie.int64());
            break;
          case 3:
            ue.endedAt = je(ie.int64());
            break;
          case 6:
            ue.duration = je(ie.int64());
            break;
          case 4:
            ue.size = je(ie.int64());
            break;
          case 5:
            ue.location = ie.string();
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        filename: Oe(P.filename) ? String(P.filename) : "",
        startedAt: Oe(P.startedAt) ? Number(P.startedAt) : 0,
        endedAt: Oe(P.endedAt) ? Number(P.endedAt) : 0,
        duration: Oe(P.duration) ? Number(P.duration) : 0,
        size: Oe(P.size) ? Number(P.size) : 0,
        location: Oe(P.location) ? String(P.location) : ""
      };
    },
    toJSON(P) {
      const X = {};
      return P.filename !== void 0 && (X.filename = P.filename), P.startedAt !== void 0 && (X.startedAt = Math.round(P.startedAt)), P.endedAt !== void 0 && (X.endedAt = Math.round(P.endedAt)), P.duration !== void 0 && (X.duration = Math.round(P.duration)), P.size !== void 0 && (X.size = Math.round(P.size)), P.location !== void 0 && (X.location = P.location), X;
    },
    fromPartial(P) {
      var X, ie, Ee, ue, O, j;
      const se = Q();
      return se.filename = (X = P.filename) !== null && X !== void 0 ? X : "", se.startedAt = (ie = P.startedAt) !== null && ie !== void 0 ? ie : 0, se.endedAt = (Ee = P.endedAt) !== null && Ee !== void 0 ? Ee : 0, se.duration = (ue = P.duration) !== null && ue !== void 0 ? ue : 0, se.size = (O = P.size) !== null && O !== void 0 ? O : 0, se.location = (j = P.location) !== null && j !== void 0 ? j : "", se;
    }
  };
  function Se() {
    return { playlistName: "", duration: 0, size: 0, playlistLocation: "", segmentCount: 0, startedAt: 0, endedAt: 0 };
  }
  a.SegmentsInfo = {
    encode(P, X = l.default.Writer.create()) {
      return P.playlistName !== void 0 && P.playlistName !== "" && X.uint32(10).string(P.playlistName), P.duration !== void 0 && P.duration !== 0 && X.uint32(16).int64(P.duration), P.size !== void 0 && P.size !== 0 && X.uint32(24).int64(P.size), P.playlistLocation !== void 0 && P.playlistLocation !== "" && X.uint32(34).string(P.playlistLocation), P.segmentCount !== void 0 && P.segmentCount !== 0 && X.uint32(40).int64(P.segmentCount), P.startedAt !== void 0 && P.startedAt !== 0 && X.uint32(48).int64(P.startedAt), P.endedAt !== void 0 && P.endedAt !== 0 && X.uint32(56).int64(P.endedAt), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = Se();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.playlistName = ie.string();
            break;
          case 2:
            ue.duration = je(ie.int64());
            break;
          case 3:
            ue.size = je(ie.int64());
            break;
          case 4:
            ue.playlistLocation = ie.string();
            break;
          case 5:
            ue.segmentCount = je(ie.int64());
            break;
          case 6:
            ue.startedAt = je(ie.int64());
            break;
          case 7:
            ue.endedAt = je(ie.int64());
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        playlistName: Oe(P.playlistName) ? String(P.playlistName) : "",
        duration: Oe(P.duration) ? Number(P.duration) : 0,
        size: Oe(P.size) ? Number(P.size) : 0,
        playlistLocation: Oe(P.playlistLocation) ? String(P.playlistLocation) : "",
        segmentCount: Oe(P.segmentCount) ? Number(P.segmentCount) : 0,
        startedAt: Oe(P.startedAt) ? Number(P.startedAt) : 0,
        endedAt: Oe(P.endedAt) ? Number(P.endedAt) : 0
      };
    },
    toJSON(P) {
      const X = {};
      return P.playlistName !== void 0 && (X.playlistName = P.playlistName), P.duration !== void 0 && (X.duration = Math.round(P.duration)), P.size !== void 0 && (X.size = Math.round(P.size)), P.playlistLocation !== void 0 && (X.playlistLocation = P.playlistLocation), P.segmentCount !== void 0 && (X.segmentCount = Math.round(P.segmentCount)), P.startedAt !== void 0 && (X.startedAt = Math.round(P.startedAt)), P.endedAt !== void 0 && (X.endedAt = Math.round(P.endedAt)), X;
    },
    fromPartial(P) {
      var X, ie, Ee, ue, O, j, se;
      const _e = Se();
      return _e.playlistName = (X = P.playlistName) !== null && X !== void 0 ? X : "", _e.duration = (ie = P.duration) !== null && ie !== void 0 ? ie : 0, _e.size = (Ee = P.size) !== null && Ee !== void 0 ? Ee : 0, _e.playlistLocation = (ue = P.playlistLocation) !== null && ue !== void 0 ? ue : "", _e.segmentCount = (O = P.segmentCount) !== null && O !== void 0 ? O : 0, _e.startedAt = (j = P.startedAt) !== null && j !== void 0 ? j : 0, _e.endedAt = (se = P.endedAt) !== null && se !== void 0 ? se : 0, _e;
    }
  };
  function me() {
    return { filepath: "", disableManifest: !1, s3: void 0, gcp: void 0, azure: void 0 };
  }
  a.AutoTrackEgress = {
    encode(P, X = l.default.Writer.create()) {
      return P.filepath !== void 0 && P.filepath !== "" && X.uint32(10).string(P.filepath), P.disableManifest === !0 && X.uint32(40).bool(P.disableManifest), P.s3 !== void 0 && a.S3Upload.encode(P.s3, X.uint32(18).fork()).ldelim(), P.gcp !== void 0 && a.GCPUpload.encode(P.gcp, X.uint32(26).fork()).ldelim(), P.azure !== void 0 && a.AzureBlobUpload.encode(P.azure, X.uint32(34).fork()).ldelim(), X;
    },
    decode(P, X) {
      const ie = P instanceof l.default.Reader ? P : new l.default.Reader(P);
      let Ee = X === void 0 ? ie.len : ie.pos + X;
      const ue = me();
      for (; ie.pos < Ee; ) {
        const O = ie.uint32();
        switch (O >>> 3) {
          case 1:
            ue.filepath = ie.string();
            break;
          case 5:
            ue.disableManifest = ie.bool();
            break;
          case 2:
            ue.s3 = a.S3Upload.decode(ie, ie.uint32());
            break;
          case 3:
            ue.gcp = a.GCPUpload.decode(ie, ie.uint32());
            break;
          case 4:
            ue.azure = a.AzureBlobUpload.decode(ie, ie.uint32());
            break;
          default:
            ie.skipType(O & 7);
            break;
        }
      }
      return ue;
    },
    fromJSON(P) {
      return {
        filepath: Oe(P.filepath) ? String(P.filepath) : "",
        disableManifest: Oe(P.disableManifest) ? !!P.disableManifest : !1,
        s3: Oe(P.s3) ? a.S3Upload.fromJSON(P.s3) : void 0,
        gcp: Oe(P.gcp) ? a.GCPUpload.fromJSON(P.gcp) : void 0,
        azure: Oe(P.azure) ? a.AzureBlobUpload.fromJSON(P.azure) : void 0
      };
    },
    toJSON(P) {
      const X = {};
      return P.filepath !== void 0 && (X.filepath = P.filepath), P.disableManifest !== void 0 && (X.disableManifest = P.disableManifest), P.s3 !== void 0 && (X.s3 = P.s3 ? a.S3Upload.toJSON(P.s3) : void 0), P.gcp !== void 0 && (X.gcp = P.gcp ? a.GCPUpload.toJSON(P.gcp) : void 0), P.azure !== void 0 && (X.azure = P.azure ? a.AzureBlobUpload.toJSON(P.azure) : void 0), X;
    },
    fromPartial(P) {
      var X, ie;
      const Ee = me();
      return Ee.filepath = (X = P.filepath) !== null && X !== void 0 ? X : "", Ee.disableManifest = (ie = P.disableManifest) !== null && ie !== void 0 ? ie : !1, Ee.s3 = P.s3 !== void 0 && P.s3 !== null ? a.S3Upload.fromPartial(P.s3) : void 0, Ee.gcp = P.gcp !== void 0 && P.gcp !== null ? a.GCPUpload.fromPartial(P.gcp) : void 0, Ee.azure = P.azure !== void 0 && P.azure !== null ? a.AzureBlobUpload.fromPartial(P.azure) : void 0, Ee;
    }
  };
  var Ie = (() => {
    if (typeof Ie < "u")
      return Ie;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function at(P) {
    if (Ie.Buffer)
      return Uint8Array.from(Ie.Buffer.from(P, "base64"));
    {
      const X = Ie.atob(P), ie = new Uint8Array(X.length);
      for (let Ee = 0; Ee < X.length; ++Ee)
        ie[Ee] = X.charCodeAt(Ee);
      return ie;
    }
  }
  function Ye(P) {
    if (Ie.Buffer)
      return Ie.Buffer.from(P).toString("base64");
    {
      const X = [];
      return P.forEach((ie) => {
        X.push(String.fromCharCode(ie));
      }), Ie.btoa(X.join(""));
    }
  }
  function je(P) {
    if (P.gt(Number.MAX_SAFE_INTEGER))
      throw new Ie.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return P.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function tt(P) {
    return typeof P == "object" && P !== null;
  }
  function Oe(P) {
    return P != null;
  }
})(livekit_egress);
var ServiceBase$1 = {};
Object.defineProperty(ServiceBase$1, "__esModule", { value: !0 });
const AccessToken_1$1 = AccessToken$1;
class ServiceBase {
  /**
   * @param apiKey API Key.
   * @param secret API Secret.
   * @param ttl token TTL
   */
  constructor(u, c, l) {
    this.apiKey = u, this.secret = c, this.ttl = l || "10m";
  }
  authHeader(u) {
    const c = new AccessToken_1$1.AccessToken(this.apiKey, this.secret, { ttl: this.ttl });
    return c.addGrant(u), {
      Authorization: `Bearer ${c.toJwt()}`
    };
  }
}
ServiceBase$1.default = ServiceBase;
var TwirpRPC = {}, axios$2 = { exports: {} }, bind$2 = function a(u, c) {
  return function() {
    for (var v = new Array(arguments.length), S = 0; S < v.length; S++)
      v[S] = arguments[S];
    return u.apply(c, v);
  };
}, bind$1 = bind$2, toString = Object.prototype.toString;
function isArray$1(a) {
  return toString.call(a) === "[object Array]";
}
function isUndefined(a) {
  return typeof a > "u";
}
function isBuffer(a) {
  return a !== null && !isUndefined(a) && a.constructor !== null && !isUndefined(a.constructor) && typeof a.constructor.isBuffer == "function" && a.constructor.isBuffer(a);
}
function isArrayBuffer(a) {
  return toString.call(a) === "[object ArrayBuffer]";
}
function isFormData(a) {
  return typeof FormData < "u" && a instanceof FormData;
}
function isArrayBufferView(a) {
  var u;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? u = ArrayBuffer.isView(a) : u = a && a.buffer && a.buffer instanceof ArrayBuffer, u;
}
function isString(a) {
  return typeof a == "string";
}
function isNumber(a) {
  return typeof a == "number";
}
function isObject$3(a) {
  return a !== null && typeof a == "object";
}
function isPlainObject(a) {
  if (toString.call(a) !== "[object Object]")
    return !1;
  var u = Object.getPrototypeOf(a);
  return u === null || u === Object.prototype;
}
function isDate(a) {
  return toString.call(a) === "[object Date]";
}
function isFile(a) {
  return toString.call(a) === "[object File]";
}
function isBlob(a) {
  return toString.call(a) === "[object Blob]";
}
function isFunction(a) {
  return toString.call(a) === "[object Function]";
}
function isStream(a) {
  return isObject$3(a) && isFunction(a.pipe);
}
function isURLSearchParams(a) {
  return typeof URLSearchParams < "u" && a instanceof URLSearchParams;
}
function trim$1(a) {
  return a.trim ? a.trim() : a.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  return typeof navigator < "u" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS") ? !1 : typeof window < "u" && typeof document < "u";
}
function forEach(a, u) {
  if (!(a === null || typeof a > "u"))
    if (typeof a != "object" && (a = [a]), isArray$1(a))
      for (var c = 0, l = a.length; c < l; c++)
        u.call(null, a[c], c, a);
    else
      for (var v in a)
        Object.prototype.hasOwnProperty.call(a, v) && u.call(null, a[v], v, a);
}
function merge() {
  var a = {};
  function u(v, S) {
    isPlainObject(a[S]) && isPlainObject(v) ? a[S] = merge(a[S], v) : isPlainObject(v) ? a[S] = merge({}, v) : isArray$1(v) ? a[S] = v.slice() : a[S] = v;
  }
  for (var c = 0, l = arguments.length; c < l; c++)
    forEach(arguments[c], u);
  return a;
}
function extend(a, u, c) {
  return forEach(u, function(v, S) {
    c && typeof v == "function" ? a[S] = bind$1(v, c) : a[S] = v;
  }), a;
}
function stripBOM(a) {
  return a.charCodeAt(0) === 65279 && (a = a.slice(1)), a;
}
var utils$9 = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isObject: isObject$3,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend,
  trim: trim$1,
  stripBOM
}, utils$8 = utils$9;
function encode(a) {
  return encodeURIComponent(a).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$1 = function a(u, c, l) {
  if (!c)
    return u;
  var v;
  if (l)
    v = l(c);
  else if (utils$8.isURLSearchParams(c))
    v = c.toString();
  else {
    var S = [];
    utils$8.forEach(c, function(_, k) {
      _ === null || typeof _ > "u" || (utils$8.isArray(_) ? k = k + "[]" : _ = [_], utils$8.forEach(_, function(M) {
        utils$8.isDate(M) ? M = M.toISOString() : utils$8.isObject(M) && (M = JSON.stringify(M)), S.push(encode(k) + "=" + encode(M));
      }));
    }), v = S.join("&");
  }
  if (v) {
    var g = u.indexOf("#");
    g !== -1 && (u = u.slice(0, g)), u += (u.indexOf("?") === -1 ? "?" : "&") + v;
  }
  return u;
}, utils$7 = utils$9;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function a(u, c, l) {
  return this.handlers.push({
    fulfilled: u,
    rejected: c,
    synchronous: l ? l.synchronous : !1,
    runWhen: l ? l.runWhen : null
  }), this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function a(u) {
  this.handlers[u] && (this.handlers[u] = null);
};
InterceptorManager$1.prototype.forEach = function a(u) {
  utils$7.forEach(this.handlers, function(l) {
    l !== null && u(l);
  });
};
var InterceptorManager_1 = InterceptorManager$1, utils$6 = utils$9, normalizeHeaderName$1 = function a(u, c) {
  utils$6.forEach(u, function(v, S) {
    S !== c && S.toUpperCase() === c.toUpperCase() && (u[c] = v, delete u[S]);
  });
}, enhanceError$1 = function a(u, c, l, v, S) {
  return u.config = c, l && (u.code = l), u.request = v, u.response = S, u.isAxiosError = !0, u.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  }, u;
}, createError, hasRequiredCreateError;
function requireCreateError() {
  if (hasRequiredCreateError)
    return createError;
  hasRequiredCreateError = 1;
  var a = enhanceError$1;
  return createError = function(c, l, v, S, g) {
    var E = new Error(c);
    return a(E, l, v, S, g);
  }, createError;
}
var settle, hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle)
    return settle;
  hasRequiredSettle = 1;
  var a = requireCreateError();
  return settle = function(c, l, v) {
    var S = v.config.validateStatus;
    !v.status || !S || S(v.status) ? c(v) : l(a(
      "Request failed with status code " + v.status,
      v.config,
      null,
      v.request,
      v
    ));
  }, settle;
}
var cookies, hasRequiredCookies;
function requireCookies() {
  if (hasRequiredCookies)
    return cookies;
  hasRequiredCookies = 1;
  var a = utils$9;
  return cookies = a.isStandardBrowserEnv() ? (
    // Standard browser envs support document.cookie
    /* @__PURE__ */ function() {
      return {
        write: function(l, v, S, g, E, _) {
          var k = [];
          k.push(l + "=" + encodeURIComponent(v)), a.isNumber(S) && k.push("expires=" + new Date(S).toGMTString()), a.isString(g) && k.push("path=" + g), a.isString(E) && k.push("domain=" + E), _ === !0 && k.push("secure"), document.cookie = k.join("; ");
        },
        read: function(l) {
          var v = document.cookie.match(new RegExp("(^|;\\s*)(" + l + ")=([^;]*)"));
          return v ? decodeURIComponent(v[3]) : null;
        },
        remove: function(l) {
          this.write(l, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return {
        write: function() {
        },
        read: function() {
          return null;
        },
        remove: function() {
        }
      };
    }()
  ), cookies;
}
var isAbsoluteURL, hasRequiredIsAbsoluteURL;
function requireIsAbsoluteURL() {
  return hasRequiredIsAbsoluteURL || (hasRequiredIsAbsoluteURL = 1, isAbsoluteURL = function(u) {
    return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(u);
  }), isAbsoluteURL;
}
var combineURLs, hasRequiredCombineURLs;
function requireCombineURLs() {
  return hasRequiredCombineURLs || (hasRequiredCombineURLs = 1, combineURLs = function(u, c) {
    return c ? u.replace(/\/+$/, "") + "/" + c.replace(/^\/+/, "") : u;
  }), combineURLs;
}
var buildFullPath, hasRequiredBuildFullPath;
function requireBuildFullPath() {
  if (hasRequiredBuildFullPath)
    return buildFullPath;
  hasRequiredBuildFullPath = 1;
  var a = requireIsAbsoluteURL(), u = requireCombineURLs();
  return buildFullPath = function(l, v) {
    return l && !a(v) ? u(l, v) : v;
  }, buildFullPath;
}
var parseHeaders, hasRequiredParseHeaders;
function requireParseHeaders() {
  if (hasRequiredParseHeaders)
    return parseHeaders;
  hasRequiredParseHeaders = 1;
  var a = utils$9, u = [
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ];
  return parseHeaders = function(l) {
    var v = {}, S, g, E;
    return l && a.forEach(l.split(`
`), function(k) {
      if (E = k.indexOf(":"), S = a.trim(k.substr(0, E)).toLowerCase(), g = a.trim(k.substr(E + 1)), S) {
        if (v[S] && u.indexOf(S) >= 0)
          return;
        S === "set-cookie" ? v[S] = (v[S] ? v[S] : []).concat([g]) : v[S] = v[S] ? v[S] + ", " + g : g;
      }
    }), v;
  }, parseHeaders;
}
var isURLSameOrigin, hasRequiredIsURLSameOrigin;
function requireIsURLSameOrigin() {
  if (hasRequiredIsURLSameOrigin)
    return isURLSameOrigin;
  hasRequiredIsURLSameOrigin = 1;
  var a = utils$9;
  return isURLSameOrigin = a.isStandardBrowserEnv() ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function() {
      var c = /(msie|trident)/i.test(navigator.userAgent), l = document.createElement("a"), v;
      function S(g) {
        var E = g;
        return c && (l.setAttribute("href", E), E = l.href), l.setAttribute("href", E), {
          href: l.href,
          protocol: l.protocol ? l.protocol.replace(/:$/, "") : "",
          host: l.host,
          search: l.search ? l.search.replace(/^\?/, "") : "",
          hash: l.hash ? l.hash.replace(/^#/, "") : "",
          hostname: l.hostname,
          port: l.port,
          pathname: l.pathname.charAt(0) === "/" ? l.pathname : "/" + l.pathname
        };
      }
      return v = S(window.location.href), function(E) {
        var _ = a.isString(E) ? S(E) : E;
        return _.protocol === v.protocol && _.host === v.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    /* @__PURE__ */ function() {
      return function() {
        return !0;
      };
    }()
  ), isURLSameOrigin;
}
var xhr, hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr)
    return xhr;
  hasRequiredXhr = 1;
  var a = utils$9, u = requireSettle(), c = requireCookies(), l = buildURL$1, v = requireBuildFullPath(), S = requireParseHeaders(), g = requireIsURLSameOrigin(), E = requireCreateError();
  return xhr = function(k) {
    return new Promise(function(M, $) {
      var J = k.data, V = k.headers, q = k.responseType;
      a.isFormData(J) && delete V["Content-Type"];
      var G = new XMLHttpRequest();
      if (k.auth) {
        var H = k.auth.username || "", B = k.auth.password ? unescape(encodeURIComponent(k.auth.password)) : "";
        V.Authorization = "Basic " + btoa(H + ":" + B);
      }
      var Y = v(k.baseURL, k.url);
      G.open(k.method.toUpperCase(), l(Y, k.params, k.paramsSerializer), !0), G.timeout = k.timeout;
      function ne() {
        if (G) {
          var re = "getAllResponseHeaders" in G ? S(G.getAllResponseHeaders()) : null, oe = !q || q === "text" || q === "json" ? G.responseText : G.response, de = {
            data: oe,
            status: G.status,
            statusText: G.statusText,
            headers: re,
            config: k,
            request: G
          };
          u(M, $, de), G = null;
        }
      }
      if ("onloadend" in G ? G.onloadend = ne : G.onreadystatechange = function() {
        !G || G.readyState !== 4 || G.status === 0 && !(G.responseURL && G.responseURL.indexOf("file:") === 0) || setTimeout(ne);
      }, G.onabort = function() {
        G && ($(E("Request aborted", k, "ECONNABORTED", G)), G = null);
      }, G.onerror = function() {
        $(E("Network Error", k, null, G)), G = null;
      }, G.ontimeout = function() {
        var oe = "timeout of " + k.timeout + "ms exceeded";
        k.timeoutErrorMessage && (oe = k.timeoutErrorMessage), $(E(
          oe,
          k,
          k.transitional && k.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
          G
        )), G = null;
      }, a.isStandardBrowserEnv()) {
        var Z = (k.withCredentials || g(Y)) && k.xsrfCookieName ? c.read(k.xsrfCookieName) : void 0;
        Z && (V[k.xsrfHeaderName] = Z);
      }
      "setRequestHeader" in G && a.forEach(V, function(oe, de) {
        typeof J > "u" && de.toLowerCase() === "content-type" ? delete V[de] : G.setRequestHeader(de, oe);
      }), a.isUndefined(k.withCredentials) || (G.withCredentials = !!k.withCredentials), q && q !== "json" && (G.responseType = k.responseType), typeof k.onDownloadProgress == "function" && G.addEventListener("progress", k.onDownloadProgress), typeof k.onUploadProgress == "function" && G.upload && G.upload.addEventListener("progress", k.onUploadProgress), k.cancelToken && k.cancelToken.promise.then(function(oe) {
        G && (G.abort(), $(oe), G = null);
      }), J || (J = null), G.send(J);
    });
  }, xhr;
}
var utils$5 = utils$9, normalizeHeaderName = normalizeHeaderName$1, enhanceError = enhanceError$1, DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(a, u) {
  !utils$5.isUndefined(a) && utils$5.isUndefined(a["Content-Type"]) && (a["Content-Type"] = u);
}
function getDefaultAdapter() {
  var a;
  return (typeof XMLHttpRequest < "u" || typeof process < "u" && Object.prototype.toString.call(process) === "[object process]") && (a = requireXhr()), a;
}
function stringifySafely(a, u, c) {
  if (utils$5.isString(a))
    try {
      return (u || JSON.parse)(a), utils$5.trim(a);
    } catch (l) {
      if (l.name !== "SyntaxError")
        throw l;
    }
  return (c || JSON.stringify)(a);
}
var defaults$3 = {
  transitional: {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function a(u, c) {
    return normalizeHeaderName(c, "Accept"), normalizeHeaderName(c, "Content-Type"), utils$5.isFormData(u) || utils$5.isArrayBuffer(u) || utils$5.isBuffer(u) || utils$5.isStream(u) || utils$5.isFile(u) || utils$5.isBlob(u) ? u : utils$5.isArrayBufferView(u) ? u.buffer : utils$5.isURLSearchParams(u) ? (setContentTypeIfUnset(c, "application/x-www-form-urlencoded;charset=utf-8"), u.toString()) : utils$5.isObject(u) || c && c["Content-Type"] === "application/json" ? (setContentTypeIfUnset(c, "application/json"), stringifySafely(u)) : u;
  }],
  transformResponse: [function a(u) {
    var c = this.transitional, l = c && c.silentJSONParsing, v = c && c.forcedJSONParsing, S = !l && this.responseType === "json";
    if (S || v && utils$5.isString(u) && u.length)
      try {
        return JSON.parse(u);
      } catch (g) {
        if (S)
          throw g.name === "SyntaxError" ? enhanceError(g, this, "E_JSON_PARSE") : g;
      }
    return u;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function a(u) {
    return u >= 200 && u < 300;
  }
};
defaults$3.headers = {
  common: {
    Accept: "application/json, text/plain, */*"
  }
};
utils$5.forEach(["delete", "get", "head"], function a(u) {
  defaults$3.headers[u] = {};
});
utils$5.forEach(["post", "put", "patch"], function a(u) {
  defaults$3.headers[u] = utils$5.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$3, utils$4 = utils$9, defaults$2 = defaults_1, transformData$1 = function a(u, c, l) {
  var v = this || defaults$2;
  return utils$4.forEach(l, function(g) {
    u = g.call(v, u, c);
  }), u;
}, isCancel$1, hasRequiredIsCancel;
function requireIsCancel() {
  return hasRequiredIsCancel || (hasRequiredIsCancel = 1, isCancel$1 = function(u) {
    return !!(u && u.__CANCEL__);
  }), isCancel$1;
}
var utils$3 = utils$9, transformData = transformData$1, isCancel = requireIsCancel(), defaults$1 = defaults_1;
function throwIfCancellationRequested(a) {
  a.cancelToken && a.cancelToken.throwIfRequested();
}
var dispatchRequest$1 = function a(u) {
  throwIfCancellationRequested(u), u.headers = u.headers || {}, u.data = transformData.call(
    u,
    u.data,
    u.headers,
    u.transformRequest
  ), u.headers = utils$3.merge(
    u.headers.common || {},
    u.headers[u.method] || {},
    u.headers
  ), utils$3.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function(v) {
      delete u.headers[v];
    }
  );
  var c = u.adapter || defaults$1.adapter;
  return c(u).then(function(v) {
    return throwIfCancellationRequested(u), v.data = transformData.call(
      u,
      v.data,
      v.headers,
      u.transformResponse
    ), v;
  }, function(v) {
    return isCancel(v) || (throwIfCancellationRequested(u), v && v.response && (v.response.data = transformData.call(
      u,
      v.response.data,
      v.response.headers,
      u.transformResponse
    ))), Promise.reject(v);
  });
}, utils$2 = utils$9, mergeConfig$2 = function a(u, c) {
  c = c || {};
  var l = {}, v = ["url", "method", "data"], S = ["headers", "auth", "proxy", "params"], g = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ], E = ["validateStatus"];
  function _($, J) {
    return utils$2.isPlainObject($) && utils$2.isPlainObject(J) ? utils$2.merge($, J) : utils$2.isPlainObject(J) ? utils$2.merge({}, J) : utils$2.isArray(J) ? J.slice() : J;
  }
  function k($) {
    utils$2.isUndefined(c[$]) ? utils$2.isUndefined(u[$]) || (l[$] = _(void 0, u[$])) : l[$] = _(u[$], c[$]);
  }
  utils$2.forEach(v, function(J) {
    utils$2.isUndefined(c[J]) || (l[J] = _(void 0, c[J]));
  }), utils$2.forEach(S, k), utils$2.forEach(g, function(J) {
    utils$2.isUndefined(c[J]) ? utils$2.isUndefined(u[J]) || (l[J] = _(void 0, u[J])) : l[J] = _(void 0, c[J]);
  }), utils$2.forEach(E, function(J) {
    J in c ? l[J] = _(u[J], c[J]) : J in u && (l[J] = _(void 0, u[J]));
  });
  var L = v.concat(S).concat(g).concat(E), M = Object.keys(u).concat(Object.keys(c)).filter(function(J) {
    return L.indexOf(J) === -1;
  });
  return utils$2.forEach(M, k), l;
};
const name = "axios", version$2 = "0.21.4", description = "Promise based HTTP client for the browser and node.js", main = "index.js", scripts = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
}, repository = {
  type: "git",
  url: "https://github.com/axios/axios.git"
}, keywords = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
], author = "Matt Zabriskie", license = "MIT", bugs = {
  url: "https://github.com/axios/axios/issues"
}, homepage = "https://axios-http.com", devDependencies = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
}, browser = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
}, jsdelivr = "dist/axios.min.js", unpkg = "dist/axios.min.js", typings = "./index.d.ts", dependencies = {
  "follow-redirects": "^1.14.0"
}, bundlesize = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
], require$$0 = {
  name,
  version: version$2,
  description,
  main,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  browser,
  jsdelivr,
  unpkg,
  typings,
  dependencies,
  bundlesize
};
var pkg = require$$0, validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(a, u) {
  validators$1[a] = function(l) {
    return typeof l === a || "a" + (u < 1 ? "n " : " ") + a;
  };
});
var deprecatedWarnings = {}, currentVerArr = pkg.version.split(".");
function isOlderVersion(a, u) {
  for (var c = u ? u.split(".") : currentVerArr, l = a.split("."), v = 0; v < 3; v++) {
    if (c[v] > l[v])
      return !0;
    if (c[v] < l[v])
      return !1;
  }
  return !1;
}
validators$1.transitional = function a(u, c, l) {
  var v = c && isOlderVersion(c);
  function S(g, E) {
    return "[Axios v" + pkg.version + "] Transitional option '" + g + "'" + E + (l ? ". " + l : "");
  }
  return function(g, E, _) {
    if (u === !1)
      throw new Error(S(E, " has been removed in " + c));
    return v && !deprecatedWarnings[E] && (deprecatedWarnings[E] = !0, console.warn(
      S(
        E,
        " has been deprecated since v" + c + " and will be removed in the near future"
      )
    )), u ? u(g, E, _) : !0;
  };
};
function assertOptions(a, u, c) {
  if (typeof a != "object")
    throw new TypeError("options must be an object");
  for (var l = Object.keys(a), v = l.length; v-- > 0; ) {
    var S = l[v], g = u[S];
    if (g) {
      var E = a[S], _ = E === void 0 || g(E, S, a);
      if (_ !== !0)
        throw new TypeError("option " + S + " must be " + _);
      continue;
    }
    if (c !== !0)
      throw Error("Unknown option " + S);
  }
}
var validator$1 = {
  isOlderVersion,
  assertOptions,
  validators: validators$1
}, utils$1 = utils$9, buildURL = buildURL$1, InterceptorManager = InterceptorManager_1, dispatchRequest = dispatchRequest$1, mergeConfig$1 = mergeConfig$2, validator = validator$1, validators = validator.validators;
function Axios$1(a) {
  this.defaults = a, this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function a(u) {
  typeof u == "string" ? (u = arguments[1] || {}, u.url = arguments[0]) : u = u || {}, u = mergeConfig$1(this.defaults, u), u.method ? u.method = u.method.toLowerCase() : this.defaults.method ? u.method = this.defaults.method.toLowerCase() : u.method = "get";
  var c = u.transitional;
  c !== void 0 && validator.assertOptions(c, {
    silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
    forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
    clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
  }, !1);
  var l = [], v = !0;
  this.interceptors.request.forEach(function($) {
    typeof $.runWhen == "function" && $.runWhen(u) === !1 || (v = v && $.synchronous, l.unshift($.fulfilled, $.rejected));
  });
  var S = [];
  this.interceptors.response.forEach(function($) {
    S.push($.fulfilled, $.rejected);
  });
  var g;
  if (!v) {
    var E = [dispatchRequest, void 0];
    for (Array.prototype.unshift.apply(E, l), E = E.concat(S), g = Promise.resolve(u); E.length; )
      g = g.then(E.shift(), E.shift());
    return g;
  }
  for (var _ = u; l.length; ) {
    var k = l.shift(), L = l.shift();
    try {
      _ = k(_);
    } catch (M) {
      L(M);
      break;
    }
  }
  try {
    g = dispatchRequest(_);
  } catch (M) {
    return Promise.reject(M);
  }
  for (; S.length; )
    g = g.then(S.shift(), S.shift());
  return g;
};
Axios$1.prototype.getUri = function a(u) {
  return u = mergeConfig$1(this.defaults, u), buildURL(u.url, u.params, u.paramsSerializer).replace(/^\?/, "");
};
utils$1.forEach(["delete", "get", "head", "options"], function a(u) {
  Axios$1.prototype[u] = function(c, l) {
    return this.request(mergeConfig$1(l || {}, {
      method: u,
      url: c,
      data: (l || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function a(u) {
  Axios$1.prototype[u] = function(c, l, v) {
    return this.request(mergeConfig$1(v || {}, {
      method: u,
      url: c,
      data: l
    }));
  };
});
var Axios_1 = Axios$1, Cancel_1, hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel)
    return Cancel_1;
  hasRequiredCancel = 1;
  function a(u) {
    this.message = u;
  }
  return a.prototype.toString = function() {
    return "Cancel" + (this.message ? ": " + this.message : "");
  }, a.prototype.__CANCEL__ = !0, Cancel_1 = a, Cancel_1;
}
var CancelToken_1, hasRequiredCancelToken;
function requireCancelToken() {
  if (hasRequiredCancelToken)
    return CancelToken_1;
  hasRequiredCancelToken = 1;
  var a = requireCancel();
  function u(c) {
    if (typeof c != "function")
      throw new TypeError("executor must be a function.");
    var l;
    this.promise = new Promise(function(g) {
      l = g;
    });
    var v = this;
    c(function(g) {
      v.reason || (v.reason = new a(g), l(v.reason));
    });
  }
  return u.prototype.throwIfRequested = function() {
    if (this.reason)
      throw this.reason;
  }, u.source = function() {
    var l, v = new u(function(g) {
      l = g;
    });
    return {
      token: v,
      cancel: l
    };
  }, CancelToken_1 = u, CancelToken_1;
}
var spread, hasRequiredSpread;
function requireSpread() {
  return hasRequiredSpread || (hasRequiredSpread = 1, spread = function(u) {
    return function(l) {
      return u.apply(null, l);
    };
  }), spread;
}
var isAxiosError, hasRequiredIsAxiosError;
function requireIsAxiosError() {
  return hasRequiredIsAxiosError || (hasRequiredIsAxiosError = 1, isAxiosError = function(u) {
    return typeof u == "object" && u.isAxiosError === !0;
  }), isAxiosError;
}
var utils = utils$9, bind = bind$2, Axios = Axios_1, mergeConfig = mergeConfig$2, defaults = defaults_1;
function createInstance(a) {
  var u = new Axios(a), c = bind(Axios.prototype.request, u);
  return utils.extend(c, Axios.prototype, u), utils.extend(c, u), c;
}
var axios$1 = createInstance(defaults);
axios$1.Axios = Axios;
axios$1.create = function a(u) {
  return createInstance(mergeConfig(axios$1.defaults, u));
};
axios$1.Cancel = requireCancel();
axios$1.CancelToken = requireCancelToken();
axios$1.isCancel = requireIsCancel();
axios$1.all = function a(u) {
  return Promise.all(u);
};
axios$1.spread = requireSpread();
axios$1.isAxiosError = requireIsAxiosError();
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axiosExports = axios$2.exports, axios = axiosExports, mapObj$1 = { exports: {} };
const isObject$2 = (a) => typeof a == "object" && a !== null, mapObjectSkip = Symbol("skip"), isObjectCustom = (a) => isObject$2(a) && !(a instanceof RegExp) && !(a instanceof Error) && !(a instanceof Date), mapObject = (a, u, c, l = /* @__PURE__ */ new WeakMap()) => {
  if (c = {
    deep: !1,
    target: {},
    ...c
  }, l.has(a))
    return l.get(a);
  l.set(a, c.target);
  const { target: v } = c;
  delete c.target;
  const S = (g) => g.map((E) => isObjectCustom(E) ? mapObject(E, u, c, l) : E);
  if (Array.isArray(a))
    return S(a);
  for (const [g, E] of Object.entries(a)) {
    const _ = u(g, E, a);
    if (_ === mapObjectSkip)
      continue;
    let [k, L, { shouldRecurse: M = !0 } = {}] = _;
    k !== "__proto__" && (c.deep && M && isObjectCustom(L) && (L = Array.isArray(L) ? S(L) : mapObject(L, u, c, l)), v[k] = L);
  }
  return v;
};
mapObj$1.exports = (a, u, c) => {
  if (!isObject$2(a))
    throw new TypeError(`Expected an object, got \`${a}\` (${typeof a})`);
  return mapObject(a, u, c);
};
mapObj$1.exports.mapObjectSkip = mapObjectSkip;
var mapObjExports = mapObj$1.exports, camelcase = { exports: {} };
const UPPERCASE = /[\p{Lu}]/u, LOWERCASE = /[\p{Ll}]/u, LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu, IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u, SEPARATORS = /[_.\- ]+/, LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source), SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source, "gu"), NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source, "gu"), preserveCamelCase = (a, u, c) => {
  let l = !1, v = !1, S = !1;
  for (let g = 0; g < a.length; g++) {
    const E = a[g];
    l && UPPERCASE.test(E) ? (a = a.slice(0, g) + "-" + a.slice(g), l = !1, S = v, v = !0, g++) : v && S && LOWERCASE.test(E) ? (a = a.slice(0, g - 1) + "-" + a.slice(g - 1), S = v, v = !1, l = !0) : (l = u(E) === E && c(E) !== E, S = v, v = c(E) === E && u(E) !== E);
  }
  return a;
}, preserveConsecutiveUppercase = (a, u) => (LEADING_CAPITAL.lastIndex = 0, a.replace(LEADING_CAPITAL, (c) => u(c))), postProcess = (a, u) => (SEPARATORS_AND_IDENTIFIER.lastIndex = 0, NUMBERS_AND_IDENTIFIER.lastIndex = 0, a.replace(SEPARATORS_AND_IDENTIFIER, (c, l) => u(l)).replace(NUMBERS_AND_IDENTIFIER, (c) => u(c))), camelCase$1 = (a, u) => {
  if (!(typeof a == "string" || Array.isArray(a)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (u = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...u
  }, Array.isArray(a) ? a = a.map((S) => S.trim()).filter((S) => S.length).join("-") : a = a.trim(), a.length === 0)
    return "";
  const c = u.locale === !1 ? (S) => S.toLowerCase() : (S) => S.toLocaleLowerCase(u.locale), l = u.locale === !1 ? (S) => S.toUpperCase() : (S) => S.toLocaleUpperCase(u.locale);
  return a.length === 1 ? u.pascalCase ? l(a) : c(a) : (a !== c(a) && (a = preserveCamelCase(a, c, l)), a = a.replace(LEADING_SEPARATORS, ""), u.preserveConsecutiveUppercase ? a = preserveConsecutiveUppercase(a, c) : a = c(a), u.pascalCase && (a = l(a.charAt(0)) + a.slice(1)), postProcess(a, l));
};
camelcase.exports = camelCase$1;
camelcase.exports.default = camelCase$1;
var camelcaseExports = camelcase.exports;
class QuickLRU {
  constructor(u = {}) {
    if (!(u.maxSize && u.maxSize > 0))
      throw new TypeError("`maxSize` must be a number greater than 0");
    this.maxSize = u.maxSize, this.onEviction = u.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
  }
  _set(u, c) {
    if (this.cache.set(u, c), this._size++, this._size >= this.maxSize) {
      if (this._size = 0, typeof this.onEviction == "function")
        for (const [l, v] of this.oldCache.entries())
          this.onEviction(l, v);
      this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map();
    }
  }
  get(u) {
    if (this.cache.has(u))
      return this.cache.get(u);
    if (this.oldCache.has(u)) {
      const c = this.oldCache.get(u);
      return this.oldCache.delete(u), this._set(u, c), c;
    }
  }
  set(u, c) {
    return this.cache.has(u) ? this.cache.set(u, c) : this._set(u, c), this;
  }
  has(u) {
    return this.cache.has(u) || this.oldCache.has(u);
  }
  peek(u) {
    if (this.cache.has(u))
      return this.cache.get(u);
    if (this.oldCache.has(u))
      return this.oldCache.get(u);
  }
  delete(u) {
    const c = this.cache.delete(u);
    return c && this._size--, this.oldCache.delete(u) || c;
  }
  clear() {
    this.cache.clear(), this.oldCache.clear(), this._size = 0;
  }
  *keys() {
    for (const [u] of this)
      yield u;
  }
  *values() {
    for (const [, u] of this)
      yield u;
  }
  *[Symbol.iterator]() {
    for (const u of this.cache)
      yield u;
    for (const u of this.oldCache) {
      const [c] = u;
      this.cache.has(c) || (yield u);
    }
  }
  get size() {
    let u = 0;
    for (const c of this.oldCache.keys())
      this.cache.has(c) || u++;
    return Math.min(this._size + u, this.maxSize);
  }
}
var quickLru = QuickLRU;
const mapObj = mapObjExports, camelCase = camelcaseExports, QuickLru = quickLru, has$1 = (a, u) => a.some((c) => typeof c == "string" ? c === u : (c.lastIndex = 0, c.test(u))), cache$1 = new QuickLru({ maxSize: 1e5 }), isObject$1 = (a) => typeof a == "object" && a !== null && !(a instanceof RegExp) && !(a instanceof Error) && !(a instanceof Date), camelCaseConvert = (a, u) => {
  if (!isObject$1(a))
    return a;
  u = {
    deep: !1,
    pascalCase: !1,
    ...u
  };
  const { exclude: c, pascalCase: l, stopPaths: v, deep: S } = u, g = new Set(v), E = (_) => (k, L) => {
    if (S && isObject$1(L)) {
      const M = _ === void 0 ? k : `${_}.${k}`;
      g.has(M) || (L = mapObj(L, E(M)));
    }
    if (!(c && has$1(c, k))) {
      const M = l ? `${k}_` : k;
      if (cache$1.has(M))
        k = cache$1.get(M);
      else {
        const $ = camelCase(k, { pascalCase: l, locale: !1 });
        k.length < 100 && cache$1.set(M, $), k = $;
      }
    }
    return [k, L];
  };
  return mapObj(a, E(void 0));
};
var camelcaseKeys = (a, u) => Array.isArray(a) ? Object.keys(a).map((c) => camelCaseConvert(a[c], u)) : camelCaseConvert(a, u), __importDefault$6 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(TwirpRPC, "__esModule", { value: !0 });
TwirpRPC.TwirpRpc = TwirpRPC.livekitPackage = void 0;
const axios_1 = __importDefault$6(axios), camelcase_keys_1 = __importDefault$6(camelcaseKeys), defaultPrefix = "/twirp";
TwirpRPC.livekitPackage = "livekit";
class TwirpRpc {
  constructor(u, c, l, v) {
    this.host = u, this.pkg = c, this.prefix = l || defaultPrefix, this.instance = axios_1.default.create({
      baseURL: u,
      headers: Object.assign({}, v ? { Host: v } : {})
    });
  }
  request(u, c, l, v) {
    return new Promise((S, g) => {
      const E = `${this.prefix}/${this.pkg}.${u}/${c}`;
      this.instance.post(E, l, { headers: v }).then((_) => {
        S(camelcase_keys_1.default(_.data, { deep: !0 }));
      }).catch(g);
    });
  }
}
TwirpRPC.TwirpRpc = TwirpRpc;
var __awaiter$3 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(S) {
    return S instanceof c ? S : new c(function(g) {
      g(S);
    });
  }
  return new (c || (c = Promise))(function(S, g) {
    function E(L) {
      try {
        k(l.next(L));
      } catch (M) {
        g(M);
      }
    }
    function _(L) {
      try {
        k(l.throw(L));
      } catch (M) {
        g(M);
      }
    }
    function k(L) {
      L.done ? S(L.value) : v(L.value).then(E, _);
    }
    k((l = l.apply(a, u || [])).next());
  });
}, __importDefault$5 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(EgressClient$1, "__esModule", { value: !0 });
EgressClient$1.EgressClient = void 0;
const livekit_egress_1$1 = livekit_egress, ServiceBase_1$2 = __importDefault$5(ServiceBase$1), TwirpRPC_1$2 = TwirpRPC, svc$2 = "Egress";
class EgressClient extends ServiceBase_1$2.default {
  /**
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    super(c, l), this.rpc = new TwirpRPC_1$2.TwirpRpc(u, TwirpRPC_1$2.livekitPackage);
  }
  startRoomCompositeEgress(u, c, l, v, S, g, E) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let _;
      if (l !== void 0)
        if (typeof l == "string")
          _ = l;
        else {
          const G = l;
          _ = G.layout, v = G.encodingOptions, S = G.audioOnly, g = G.videoOnly, E = G.customBaseUrl;
        }
      _ ?? (_ = ""), S ?? (S = !1), g ?? (g = !1), E ?? (E = "");
      const { file: k, segments: L, stream: M, preset: $, advanced: J } = this.getOutputParams(c, v), V = livekit_egress_1$1.RoomCompositeEgressRequest.toJSON({
        roomName: u,
        layout: _,
        audioOnly: S,
        videoOnly: g,
        customBaseUrl: E,
        file: k,
        stream: M,
        segments: L,
        preset: $,
        advanced: J
      }), q = yield this.rpc.request(svc$2, "StartRoomCompositeEgress", V, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(q);
    });
  }
  /**
   * @param url url
   * @param output file or stream output
   * @param opts WebOptions
   */
  startWebEgress(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const v = (l == null ? void 0 : l.audioOnly) || !1, S = (l == null ? void 0 : l.videoOnly) || !1, { file: g, segments: E, stream: _, preset: k, advanced: L } = this.getOutputParams(c, l == null ? void 0 : l.encodingOptions), M = livekit_egress_1$1.WebEgressRequest.toJSON({
        url: u,
        audioOnly: v,
        videoOnly: S,
        file: g,
        stream: _,
        segments: E,
        preset: k,
        advanced: L
      }), $ = yield this.rpc.request(svc$2, "StartWebEgress", M, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON($);
    });
  }
  startTrackCompositeEgress(u, c, l, v, S) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let g;
      if (l !== void 0)
        if (typeof l == "string")
          g = l;
        else {
          const V = l;
          g = V.audioTrackId, v = V.videoTrackId, S = V.encodingOptions;
        }
      g ?? (g = ""), v ?? (v = "");
      const { file: E, segments: _, stream: k, preset: L, advanced: M } = this.getOutputParams(c, S), $ = livekit_egress_1$1.TrackCompositeEgressRequest.toJSON({
        roomName: u,
        audioTrackId: g,
        videoTrackId: v,
        file: E,
        stream: k,
        segments: _,
        preset: L,
        advanced: M
      }), J = yield this.rpc.request(svc$2, "StartTrackCompositeEgress", $, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(J);
    });
  }
  getOutputParams(u, c) {
    let l, v, S, g, E;
    return u.filepath !== void 0 ? l = u : u.filenamePrefix !== void 0 ? S = u : v = u, c && (typeof c == "number" ? g = c : E = c), { file: l, segments: S, stream: v, preset: g, advanced: E };
  }
  /**
   * @param roomName room name
   * @param output file or websocket output
   * @param trackId track Id
   */
  startTrackEgress(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      let v, S;
      c.filepath !== void 0 ? v = c : S = c;
      const g = livekit_egress_1$1.TrackEgressRequest.toJSON({
        roomName: u,
        trackId: l,
        file: v,
        websocketUrl: S
      }), E = yield this.rpc.request(svc$2, "StartTrackEgress", g, this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(E);
    });
  }
  /**
   * @param egressId
   * @param layout
   */
  updateLayout(u, c) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc$2, "UpdateLayout", livekit_egress_1$1.UpdateLayoutRequest.toJSON({ egressId: u, layout: c }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(l);
    });
  }
  /**
   * @param egressId
   * @param addOutputUrls
   * @param removeOutputUrls
   */
  updateStream(u, c, l) {
    return __awaiter$3(this, void 0, void 0, function* () {
      c ?? (c = []), l ?? (l = []);
      const v = yield this.rpc.request(svc$2, "UpdateStream", livekit_egress_1$1.UpdateStreamRequest.toJSON({ egressId: u, addOutputUrls: c, removeOutputUrls: l }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(v);
    });
  }
  /**
   * @param roomName list egress for one room only
   */
  listEgress(u) {
    var c;
    return __awaiter$3(this, void 0, void 0, function* () {
      u ?? (u = "");
      const l = yield this.rpc.request(svc$2, "ListEgress", livekit_egress_1$1.ListEgressRequest.toJSON({ roomName: u }), this.authHeader({ roomRecord: !0 }));
      return (c = livekit_egress_1$1.ListEgressResponse.fromJSON(l).items) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * @param egressId
   */
  stopEgress(u) {
    return __awaiter$3(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc$2, "StopEgress", livekit_egress_1$1.StopEgressRequest.toJSON({ egressId: u }), this.authHeader({ roomRecord: !0 }));
      return livekit_egress_1$1.EgressInfo.fromJSON(c);
    });
  }
}
EgressClient$1.EgressClient = EgressClient;
var grants = {};
Object.defineProperty(grants, "__esModule", { value: !0 });
var IngressClient$1 = {}, livekit_ingress = {}, livekit_models = {}, timestamp = {}, __importDefault$4 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(timestamp, "__esModule", { value: !0 });
timestamp.Timestamp = timestamp.protobufPackage = void 0;
const long_1$1 = __importDefault$4(umdExports), minimal_1$1 = __importDefault$4(minimal);
timestamp.protobufPackage = "google.protobuf";
function createBaseTimestamp() {
  return { seconds: 0, nanos: 0 };
}
timestamp.Timestamp = {
  encode(a, u = minimal_1$1.default.Writer.create()) {
    return a.seconds !== 0 && u.uint32(8).int64(a.seconds), a.nanos !== 0 && u.uint32(16).int32(a.nanos), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1$1.default.Reader ? a : new minimal_1$1.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseTimestamp();
    for (; c.pos < l; ) {
      const S = c.uint32();
      switch (S >>> 3) {
        case 1:
          v.seconds = longToNumber$1(c.int64());
          break;
        case 2:
          v.nanos = c.int32();
          break;
        default:
          c.skipType(S & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      seconds: isSet$1(a.seconds) ? Number(a.seconds) : 0,
      nanos: isSet$1(a.nanos) ? Number(a.nanos) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.seconds !== void 0 && (u.seconds = Math.round(a.seconds)), a.nanos !== void 0 && (u.nanos = Math.round(a.nanos)), u;
  },
  fromPartial(a) {
    var u, c;
    const l = createBaseTimestamp();
    return l.seconds = (u = a.seconds) !== null && u !== void 0 ? u : 0, l.nanos = (c = a.nanos) !== null && c !== void 0 ? c : 0, l;
  }
};
var globalThis$2 = (() => {
  if (typeof globalThis$2 < "u")
    return globalThis$2;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber$1(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1$1.default.util.Long !== long_1$1.default && (minimal_1$1.default.util.Long = long_1$1.default, minimal_1$1.default.configure());
function isSet$1(a) {
  return a != null;
}
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(O) {
    return O && O.__esModule ? O : { default: O };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.RTPStats_GapHistogramEntry = a.RTPStats = a.DisabledCodecs = a.VideoConfiguration = a.ClientConfiguration = a.ClientInfo = a.ServerInfo = a.ParticipantTracks = a.UserPacket = a.SpeakerInfo = a.ActiveSpeakerUpdate = a.DataPacket = a.VideoLayer = a.TrackInfo = a.SimulcastCodecInfo = a.ParticipantInfo = a.ParticipantPermission = a.Codec = a.Room = a.clientInfo_SDKToJSON = a.clientInfo_SDKFromJSON = a.ClientInfo_SDK = a.serverInfo_EditionToJSON = a.serverInfo_EditionFromJSON = a.ServerInfo_Edition = a.dataPacket_KindToJSON = a.dataPacket_KindFromJSON = a.DataPacket_Kind = a.participantInfo_StateToJSON = a.participantInfo_StateFromJSON = a.ParticipantInfo_State = a.disconnectReasonToJSON = a.disconnectReasonFromJSON = a.DisconnectReason = a.clientConfigSettingToJSON = a.clientConfigSettingFromJSON = a.ClientConfigSetting = a.connectionQualityToJSON = a.connectionQualityFromJSON = a.ConnectionQuality = a.videoQualityToJSON = a.videoQualityFromJSON = a.VideoQuality = a.trackSourceToJSON = a.trackSourceFromJSON = a.TrackSource = a.trackTypeToJSON = a.trackTypeFromJSON = a.TrackType = a.protobufPackage = void 0, a.TimedVersion = void 0;
  const c = u(umdExports), l = u(minimal), v = timestamp;
  a.protobufPackage = "livekit";
  var S;
  (function(O) {
    O[O.AUDIO = 0] = "AUDIO", O[O.VIDEO = 1] = "VIDEO", O[O.DATA = 2] = "DATA", O[O.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(S = a.TrackType || (a.TrackType = {}));
  function g(O) {
    switch (O) {
      case 0:
      case "AUDIO":
        return S.AUDIO;
      case 1:
      case "VIDEO":
        return S.VIDEO;
      case 2:
      case "DATA":
        return S.DATA;
      case -1:
      case "UNRECOGNIZED":
      default:
        return S.UNRECOGNIZED;
    }
  }
  a.trackTypeFromJSON = g;
  function E(O) {
    switch (O) {
      case S.AUDIO:
        return "AUDIO";
      case S.VIDEO:
        return "VIDEO";
      case S.DATA:
        return "DATA";
      case S.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.trackTypeToJSON = E;
  var _;
  (function(O) {
    O[O.UNKNOWN = 0] = "UNKNOWN", O[O.CAMERA = 1] = "CAMERA", O[O.MICROPHONE = 2] = "MICROPHONE", O[O.SCREEN_SHARE = 3] = "SCREEN_SHARE", O[O.SCREEN_SHARE_AUDIO = 4] = "SCREEN_SHARE_AUDIO", O[O.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(_ = a.TrackSource || (a.TrackSource = {}));
  function k(O) {
    switch (O) {
      case 0:
      case "UNKNOWN":
        return _.UNKNOWN;
      case 1:
      case "CAMERA":
        return _.CAMERA;
      case 2:
      case "MICROPHONE":
        return _.MICROPHONE;
      case 3:
      case "SCREEN_SHARE":
        return _.SCREEN_SHARE;
      case 4:
      case "SCREEN_SHARE_AUDIO":
        return _.SCREEN_SHARE_AUDIO;
      case -1:
      case "UNRECOGNIZED":
      default:
        return _.UNRECOGNIZED;
    }
  }
  a.trackSourceFromJSON = k;
  function L(O) {
    switch (O) {
      case _.UNKNOWN:
        return "UNKNOWN";
      case _.CAMERA:
        return "CAMERA";
      case _.MICROPHONE:
        return "MICROPHONE";
      case _.SCREEN_SHARE:
        return "SCREEN_SHARE";
      case _.SCREEN_SHARE_AUDIO:
        return "SCREEN_SHARE_AUDIO";
      case _.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.trackSourceToJSON = L;
  var M;
  (function(O) {
    O[O.LOW = 0] = "LOW", O[O.MEDIUM = 1] = "MEDIUM", O[O.HIGH = 2] = "HIGH", O[O.OFF = 3] = "OFF", O[O.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(M = a.VideoQuality || (a.VideoQuality = {}));
  function $(O) {
    switch (O) {
      case 0:
      case "LOW":
        return M.LOW;
      case 1:
      case "MEDIUM":
        return M.MEDIUM;
      case 2:
      case "HIGH":
        return M.HIGH;
      case 3:
      case "OFF":
        return M.OFF;
      case -1:
      case "UNRECOGNIZED":
      default:
        return M.UNRECOGNIZED;
    }
  }
  a.videoQualityFromJSON = $;
  function J(O) {
    switch (O) {
      case M.LOW:
        return "LOW";
      case M.MEDIUM:
        return "MEDIUM";
      case M.HIGH:
        return "HIGH";
      case M.OFF:
        return "OFF";
      case M.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.videoQualityToJSON = J;
  var V;
  (function(O) {
    O[O.POOR = 0] = "POOR", O[O.GOOD = 1] = "GOOD", O[O.EXCELLENT = 2] = "EXCELLENT", O[O.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(V = a.ConnectionQuality || (a.ConnectionQuality = {}));
  function q(O) {
    switch (O) {
      case 0:
      case "POOR":
        return V.POOR;
      case 1:
      case "GOOD":
        return V.GOOD;
      case 2:
      case "EXCELLENT":
        return V.EXCELLENT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return V.UNRECOGNIZED;
    }
  }
  a.connectionQualityFromJSON = q;
  function G(O) {
    switch (O) {
      case V.POOR:
        return "POOR";
      case V.GOOD:
        return "GOOD";
      case V.EXCELLENT:
        return "EXCELLENT";
      case V.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.connectionQualityToJSON = G;
  var H;
  (function(O) {
    O[O.UNSET = 0] = "UNSET", O[O.DISABLED = 1] = "DISABLED", O[O.ENABLED = 2] = "ENABLED", O[O.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(H = a.ClientConfigSetting || (a.ClientConfigSetting = {}));
  function B(O) {
    switch (O) {
      case 0:
      case "UNSET":
        return H.UNSET;
      case 1:
      case "DISABLED":
        return H.DISABLED;
      case 2:
      case "ENABLED":
        return H.ENABLED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return H.UNRECOGNIZED;
    }
  }
  a.clientConfigSettingFromJSON = B;
  function Y(O) {
    switch (O) {
      case H.UNSET:
        return "UNSET";
      case H.DISABLED:
        return "DISABLED";
      case H.ENABLED:
        return "ENABLED";
      case H.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.clientConfigSettingToJSON = Y;
  var ne;
  (function(O) {
    O[O.UNKNOWN_REASON = 0] = "UNKNOWN_REASON", O[O.CLIENT_INITIATED = 1] = "CLIENT_INITIATED", O[O.DUPLICATE_IDENTITY = 2] = "DUPLICATE_IDENTITY", O[O.SERVER_SHUTDOWN = 3] = "SERVER_SHUTDOWN", O[O.PARTICIPANT_REMOVED = 4] = "PARTICIPANT_REMOVED", O[O.ROOM_DELETED = 5] = "ROOM_DELETED", O[O.STATE_MISMATCH = 6] = "STATE_MISMATCH", O[O.JOIN_FAILURE = 7] = "JOIN_FAILURE", O[O.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(ne = a.DisconnectReason || (a.DisconnectReason = {}));
  function Z(O) {
    switch (O) {
      case 0:
      case "UNKNOWN_REASON":
        return ne.UNKNOWN_REASON;
      case 1:
      case "CLIENT_INITIATED":
        return ne.CLIENT_INITIATED;
      case 2:
      case "DUPLICATE_IDENTITY":
        return ne.DUPLICATE_IDENTITY;
      case 3:
      case "SERVER_SHUTDOWN":
        return ne.SERVER_SHUTDOWN;
      case 4:
      case "PARTICIPANT_REMOVED":
        return ne.PARTICIPANT_REMOVED;
      case 5:
      case "ROOM_DELETED":
        return ne.ROOM_DELETED;
      case 6:
      case "STATE_MISMATCH":
        return ne.STATE_MISMATCH;
      case 7:
      case "JOIN_FAILURE":
        return ne.JOIN_FAILURE;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ne.UNRECOGNIZED;
    }
  }
  a.disconnectReasonFromJSON = Z;
  function re(O) {
    switch (O) {
      case ne.UNKNOWN_REASON:
        return "UNKNOWN_REASON";
      case ne.CLIENT_INITIATED:
        return "CLIENT_INITIATED";
      case ne.DUPLICATE_IDENTITY:
        return "DUPLICATE_IDENTITY";
      case ne.SERVER_SHUTDOWN:
        return "SERVER_SHUTDOWN";
      case ne.PARTICIPANT_REMOVED:
        return "PARTICIPANT_REMOVED";
      case ne.ROOM_DELETED:
        return "ROOM_DELETED";
      case ne.STATE_MISMATCH:
        return "STATE_MISMATCH";
      case ne.JOIN_FAILURE:
        return "JOIN_FAILURE";
      case ne.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.disconnectReasonToJSON = re;
  var oe;
  (function(O) {
    O[O.JOINING = 0] = "JOINING", O[O.JOINED = 1] = "JOINED", O[O.ACTIVE = 2] = "ACTIVE", O[O.DISCONNECTED = 3] = "DISCONNECTED", O[O.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(oe = a.ParticipantInfo_State || (a.ParticipantInfo_State = {}));
  function de(O) {
    switch (O) {
      case 0:
      case "JOINING":
        return oe.JOINING;
      case 1:
      case "JOINED":
        return oe.JOINED;
      case 2:
      case "ACTIVE":
        return oe.ACTIVE;
      case 3:
      case "DISCONNECTED":
        return oe.DISCONNECTED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return oe.UNRECOGNIZED;
    }
  }
  a.participantInfo_StateFromJSON = de;
  function A(O) {
    switch (O) {
      case oe.JOINING:
        return "JOINING";
      case oe.JOINED:
        return "JOINED";
      case oe.ACTIVE:
        return "ACTIVE";
      case oe.DISCONNECTED:
        return "DISCONNECTED";
      case oe.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.participantInfo_StateToJSON = A;
  var N;
  (function(O) {
    O[O.RELIABLE = 0] = "RELIABLE", O[O.LOSSY = 1] = "LOSSY", O[O.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(N = a.DataPacket_Kind || (a.DataPacket_Kind = {}));
  function D(O) {
    switch (O) {
      case 0:
      case "RELIABLE":
        return N.RELIABLE;
      case 1:
      case "LOSSY":
        return N.LOSSY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return N.UNRECOGNIZED;
    }
  }
  a.dataPacket_KindFromJSON = D;
  function W(O) {
    switch (O) {
      case N.RELIABLE:
        return "RELIABLE";
      case N.LOSSY:
        return "LOSSY";
      case N.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.dataPacket_KindToJSON = W;
  var ee;
  (function(O) {
    O[O.Standard = 0] = "Standard", O[O.Cloud = 1] = "Cloud", O[O.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(ee = a.ServerInfo_Edition || (a.ServerInfo_Edition = {}));
  function ae(O) {
    switch (O) {
      case 0:
      case "Standard":
        return ee.Standard;
      case 1:
      case "Cloud":
        return ee.Cloud;
      case -1:
      case "UNRECOGNIZED":
      default:
        return ee.UNRECOGNIZED;
    }
  }
  a.serverInfo_EditionFromJSON = ae;
  function ye(O) {
    switch (O) {
      case ee.Standard:
        return "Standard";
      case ee.Cloud:
        return "Cloud";
      case ee.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.serverInfo_EditionToJSON = ye;
  var he;
  (function(O) {
    O[O.UNKNOWN = 0] = "UNKNOWN", O[O.JS = 1] = "JS", O[O.SWIFT = 2] = "SWIFT", O[O.ANDROID = 3] = "ANDROID", O[O.FLUTTER = 4] = "FLUTTER", O[O.GO = 5] = "GO", O[O.UNITY = 6] = "UNITY", O[O.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(he = a.ClientInfo_SDK || (a.ClientInfo_SDK = {}));
  function le(O) {
    switch (O) {
      case 0:
      case "UNKNOWN":
        return he.UNKNOWN;
      case 1:
      case "JS":
        return he.JS;
      case 2:
      case "SWIFT":
        return he.SWIFT;
      case 3:
      case "ANDROID":
        return he.ANDROID;
      case 4:
      case "FLUTTER":
        return he.FLUTTER;
      case 5:
      case "GO":
        return he.GO;
      case 6:
      case "UNITY":
        return he.UNITY;
      case -1:
      case "UNRECOGNIZED":
      default:
        return he.UNRECOGNIZED;
    }
  }
  a.clientInfo_SDKFromJSON = le;
  function we(O) {
    switch (O) {
      case he.UNKNOWN:
        return "UNKNOWN";
      case he.JS:
        return "JS";
      case he.SWIFT:
        return "SWIFT";
      case he.ANDROID:
        return "ANDROID";
      case he.FLUTTER:
        return "FLUTTER";
      case he.GO:
        return "GO";
      case he.UNITY:
        return "UNITY";
      case he.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.clientInfo_SDKToJSON = we;
  function Be() {
    return {
      sid: "",
      name: "",
      emptyTimeout: 0,
      maxParticipants: 0,
      creationTime: 0,
      turnPassword: "",
      enabledCodecs: [],
      metadata: "",
      numParticipants: 0,
      activeRecording: !1
    };
  }
  a.Room = {
    encode(O, j = l.default.Writer.create()) {
      O.sid !== "" && j.uint32(10).string(O.sid), O.name !== "" && j.uint32(18).string(O.name), O.emptyTimeout !== 0 && j.uint32(24).uint32(O.emptyTimeout), O.maxParticipants !== 0 && j.uint32(32).uint32(O.maxParticipants), O.creationTime !== 0 && j.uint32(40).int64(O.creationTime), O.turnPassword !== "" && j.uint32(50).string(O.turnPassword);
      for (const se of O.enabledCodecs)
        a.Codec.encode(se, j.uint32(58).fork()).ldelim();
      return O.metadata !== "" && j.uint32(66).string(O.metadata), O.numParticipants !== 0 && j.uint32(72).uint32(O.numParticipants), O.activeRecording === !0 && j.uint32(80).bool(O.activeRecording), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = Be();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.sid = se.string();
            break;
          case 2:
            ve.name = se.string();
            break;
          case 3:
            ve.emptyTimeout = se.uint32();
            break;
          case 4:
            ve.maxParticipants = se.uint32();
            break;
          case 5:
            ve.creationTime = ie(se.int64());
            break;
          case 6:
            ve.turnPassword = se.string();
            break;
          case 7:
            ve.enabledCodecs.push(a.Codec.decode(se, se.uint32()));
            break;
          case 8:
            ve.metadata = se.string();
            break;
          case 9:
            ve.numParticipants = se.uint32();
            break;
          case 10:
            ve.activeRecording = se.bool();
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        sid: ue(O.sid) ? String(O.sid) : "",
        name: ue(O.name) ? String(O.name) : "",
        emptyTimeout: ue(O.emptyTimeout) ? Number(O.emptyTimeout) : 0,
        maxParticipants: ue(O.maxParticipants) ? Number(O.maxParticipants) : 0,
        creationTime: ue(O.creationTime) ? Number(O.creationTime) : 0,
        turnPassword: ue(O.turnPassword) ? String(O.turnPassword) : "",
        enabledCodecs: Array.isArray(O == null ? void 0 : O.enabledCodecs) ? O.enabledCodecs.map((j) => a.Codec.fromJSON(j)) : [],
        metadata: ue(O.metadata) ? String(O.metadata) : "",
        numParticipants: ue(O.numParticipants) ? Number(O.numParticipants) : 0,
        activeRecording: ue(O.activeRecording) ? !!O.activeRecording : !1
      };
    },
    toJSON(O) {
      const j = {};
      return O.sid !== void 0 && (j.sid = O.sid), O.name !== void 0 && (j.name = O.name), O.emptyTimeout !== void 0 && (j.emptyTimeout = Math.round(O.emptyTimeout)), O.maxParticipants !== void 0 && (j.maxParticipants = Math.round(O.maxParticipants)), O.creationTime !== void 0 && (j.creationTime = Math.round(O.creationTime)), O.turnPassword !== void 0 && (j.turnPassword = O.turnPassword), O.enabledCodecs ? j.enabledCodecs = O.enabledCodecs.map((se) => se ? a.Codec.toJSON(se) : void 0) : j.enabledCodecs = [], O.metadata !== void 0 && (j.metadata = O.metadata), O.numParticipants !== void 0 && (j.numParticipants = Math.round(O.numParticipants)), O.activeRecording !== void 0 && (j.activeRecording = O.activeRecording), j;
    },
    fromPartial(O) {
      var j, se, _e, ve, De, Ze, Qe, ot, ft, Ce;
      const I = Be();
      return I.sid = (j = O.sid) !== null && j !== void 0 ? j : "", I.name = (se = O.name) !== null && se !== void 0 ? se : "", I.emptyTimeout = (_e = O.emptyTimeout) !== null && _e !== void 0 ? _e : 0, I.maxParticipants = (ve = O.maxParticipants) !== null && ve !== void 0 ? ve : 0, I.creationTime = (De = O.creationTime) !== null && De !== void 0 ? De : 0, I.turnPassword = (Ze = O.turnPassword) !== null && Ze !== void 0 ? Ze : "", I.enabledCodecs = ((Qe = O.enabledCodecs) === null || Qe === void 0 ? void 0 : Qe.map((F) => a.Codec.fromPartial(F))) || [], I.metadata = (ot = O.metadata) !== null && ot !== void 0 ? ot : "", I.numParticipants = (ft = O.numParticipants) !== null && ft !== void 0 ? ft : 0, I.activeRecording = (Ce = O.activeRecording) !== null && Ce !== void 0 ? Ce : !1, I;
    }
  };
  function Ne() {
    return { mime: "", fmtpLine: "" };
  }
  a.Codec = {
    encode(O, j = l.default.Writer.create()) {
      return O.mime !== "" && j.uint32(10).string(O.mime), O.fmtpLine !== "" && j.uint32(18).string(O.fmtpLine), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = Ne();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.mime = se.string();
            break;
          case 2:
            ve.fmtpLine = se.string();
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        mime: ue(O.mime) ? String(O.mime) : "",
        fmtpLine: ue(O.fmtpLine) ? String(O.fmtpLine) : ""
      };
    },
    toJSON(O) {
      const j = {};
      return O.mime !== void 0 && (j.mime = O.mime), O.fmtpLine !== void 0 && (j.fmtpLine = O.fmtpLine), j;
    },
    fromPartial(O) {
      var j, se;
      const _e = Ne();
      return _e.mime = (j = O.mime) !== null && j !== void 0 ? j : "", _e.fmtpLine = (se = O.fmtpLine) !== null && se !== void 0 ? se : "", _e;
    }
  };
  function Le() {
    return { canSubscribe: !1, canPublish: !1, canPublishData: !1, hidden: !1, recorder: !1 };
  }
  a.ParticipantPermission = {
    encode(O, j = l.default.Writer.create()) {
      return O.canSubscribe === !0 && j.uint32(8).bool(O.canSubscribe), O.canPublish === !0 && j.uint32(16).bool(O.canPublish), O.canPublishData === !0 && j.uint32(24).bool(O.canPublishData), O.hidden === !0 && j.uint32(56).bool(O.hidden), O.recorder === !0 && j.uint32(64).bool(O.recorder), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = Le();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.canSubscribe = se.bool();
            break;
          case 2:
            ve.canPublish = se.bool();
            break;
          case 3:
            ve.canPublishData = se.bool();
            break;
          case 7:
            ve.hidden = se.bool();
            break;
          case 8:
            ve.recorder = se.bool();
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        canSubscribe: ue(O.canSubscribe) ? !!O.canSubscribe : !1,
        canPublish: ue(O.canPublish) ? !!O.canPublish : !1,
        canPublishData: ue(O.canPublishData) ? !!O.canPublishData : !1,
        hidden: ue(O.hidden) ? !!O.hidden : !1,
        recorder: ue(O.recorder) ? !!O.recorder : !1
      };
    },
    toJSON(O) {
      const j = {};
      return O.canSubscribe !== void 0 && (j.canSubscribe = O.canSubscribe), O.canPublish !== void 0 && (j.canPublish = O.canPublish), O.canPublishData !== void 0 && (j.canPublishData = O.canPublishData), O.hidden !== void 0 && (j.hidden = O.hidden), O.recorder !== void 0 && (j.recorder = O.recorder), j;
    },
    fromPartial(O) {
      var j, se, _e, ve, De;
      const Ze = Le();
      return Ze.canSubscribe = (j = O.canSubscribe) !== null && j !== void 0 ? j : !1, Ze.canPublish = (se = O.canPublish) !== null && se !== void 0 ? se : !1, Ze.canPublishData = (_e = O.canPublishData) !== null && _e !== void 0 ? _e : !1, Ze.hidden = (ve = O.hidden) !== null && ve !== void 0 ? ve : !1, Ze.recorder = (De = O.recorder) !== null && De !== void 0 ? De : !1, Ze;
    }
  };
  function $e() {
    return {
      sid: "",
      identity: "",
      state: 0,
      tracks: [],
      metadata: "",
      joinedAt: 0,
      name: "",
      version: 0,
      permission: void 0,
      region: "",
      isPublisher: !1
    };
  }
  a.ParticipantInfo = {
    encode(O, j = l.default.Writer.create()) {
      O.sid !== "" && j.uint32(10).string(O.sid), O.identity !== "" && j.uint32(18).string(O.identity), O.state !== 0 && j.uint32(24).int32(O.state);
      for (const se of O.tracks)
        a.TrackInfo.encode(se, j.uint32(34).fork()).ldelim();
      return O.metadata !== "" && j.uint32(42).string(O.metadata), O.joinedAt !== 0 && j.uint32(48).int64(O.joinedAt), O.name !== "" && j.uint32(74).string(O.name), O.version !== 0 && j.uint32(80).uint32(O.version), O.permission !== void 0 && a.ParticipantPermission.encode(O.permission, j.uint32(90).fork()).ldelim(), O.region !== "" && j.uint32(98).string(O.region), O.isPublisher === !0 && j.uint32(104).bool(O.isPublisher), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = $e();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.sid = se.string();
            break;
          case 2:
            ve.identity = se.string();
            break;
          case 3:
            ve.state = se.int32();
            break;
          case 4:
            ve.tracks.push(a.TrackInfo.decode(se, se.uint32()));
            break;
          case 5:
            ve.metadata = se.string();
            break;
          case 6:
            ve.joinedAt = ie(se.int64());
            break;
          case 9:
            ve.name = se.string();
            break;
          case 10:
            ve.version = se.uint32();
            break;
          case 11:
            ve.permission = a.ParticipantPermission.decode(se, se.uint32());
            break;
          case 12:
            ve.region = se.string();
            break;
          case 13:
            ve.isPublisher = se.bool();
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        sid: ue(O.sid) ? String(O.sid) : "",
        identity: ue(O.identity) ? String(O.identity) : "",
        state: ue(O.state) ? de(O.state) : 0,
        tracks: Array.isArray(O == null ? void 0 : O.tracks) ? O.tracks.map((j) => a.TrackInfo.fromJSON(j)) : [],
        metadata: ue(O.metadata) ? String(O.metadata) : "",
        joinedAt: ue(O.joinedAt) ? Number(O.joinedAt) : 0,
        name: ue(O.name) ? String(O.name) : "",
        version: ue(O.version) ? Number(O.version) : 0,
        permission: ue(O.permission) ? a.ParticipantPermission.fromJSON(O.permission) : void 0,
        region: ue(O.region) ? String(O.region) : "",
        isPublisher: ue(O.isPublisher) ? !!O.isPublisher : !1
      };
    },
    toJSON(O) {
      const j = {};
      return O.sid !== void 0 && (j.sid = O.sid), O.identity !== void 0 && (j.identity = O.identity), O.state !== void 0 && (j.state = A(O.state)), O.tracks ? j.tracks = O.tracks.map((se) => se ? a.TrackInfo.toJSON(se) : void 0) : j.tracks = [], O.metadata !== void 0 && (j.metadata = O.metadata), O.joinedAt !== void 0 && (j.joinedAt = Math.round(O.joinedAt)), O.name !== void 0 && (j.name = O.name), O.version !== void 0 && (j.version = Math.round(O.version)), O.permission !== void 0 && (j.permission = O.permission ? a.ParticipantPermission.toJSON(O.permission) : void 0), O.region !== void 0 && (j.region = O.region), O.isPublisher !== void 0 && (j.isPublisher = O.isPublisher), j;
    },
    fromPartial(O) {
      var j, se, _e, ve, De, Ze, Qe, ot, ft, Ce;
      const I = $e();
      return I.sid = (j = O.sid) !== null && j !== void 0 ? j : "", I.identity = (se = O.identity) !== null && se !== void 0 ? se : "", I.state = (_e = O.state) !== null && _e !== void 0 ? _e : 0, I.tracks = ((ve = O.tracks) === null || ve === void 0 ? void 0 : ve.map((F) => a.TrackInfo.fromPartial(F))) || [], I.metadata = (De = O.metadata) !== null && De !== void 0 ? De : "", I.joinedAt = (Ze = O.joinedAt) !== null && Ze !== void 0 ? Ze : 0, I.name = (Qe = O.name) !== null && Qe !== void 0 ? Qe : "", I.version = (ot = O.version) !== null && ot !== void 0 ? ot : 0, I.permission = O.permission !== void 0 && O.permission !== null ? a.ParticipantPermission.fromPartial(O.permission) : void 0, I.region = (ft = O.region) !== null && ft !== void 0 ? ft : "", I.isPublisher = (Ce = O.isPublisher) !== null && Ce !== void 0 ? Ce : !1, I;
    }
  };
  function Ue() {
    return { mimeType: "", mid: "", cid: "", layers: [] };
  }
  a.SimulcastCodecInfo = {
    encode(O, j = l.default.Writer.create()) {
      O.mimeType !== "" && j.uint32(10).string(O.mimeType), O.mid !== "" && j.uint32(18).string(O.mid), O.cid !== "" && j.uint32(26).string(O.cid);
      for (const se of O.layers)
        a.VideoLayer.encode(se, j.uint32(34).fork()).ldelim();
      return j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = Ue();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.mimeType = se.string();
            break;
          case 2:
            ve.mid = se.string();
            break;
          case 3:
            ve.cid = se.string();
            break;
          case 4:
            ve.layers.push(a.VideoLayer.decode(se, se.uint32()));
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        mimeType: ue(O.mimeType) ? String(O.mimeType) : "",
        mid: ue(O.mid) ? String(O.mid) : "",
        cid: ue(O.cid) ? String(O.cid) : "",
        layers: Array.isArray(O == null ? void 0 : O.layers) ? O.layers.map((j) => a.VideoLayer.fromJSON(j)) : []
      };
    },
    toJSON(O) {
      const j = {};
      return O.mimeType !== void 0 && (j.mimeType = O.mimeType), O.mid !== void 0 && (j.mid = O.mid), O.cid !== void 0 && (j.cid = O.cid), O.layers ? j.layers = O.layers.map((se) => se ? a.VideoLayer.toJSON(se) : void 0) : j.layers = [], j;
    },
    fromPartial(O) {
      var j, se, _e, ve;
      const De = Ue();
      return De.mimeType = (j = O.mimeType) !== null && j !== void 0 ? j : "", De.mid = (se = O.mid) !== null && se !== void 0 ? se : "", De.cid = (_e = O.cid) !== null && _e !== void 0 ? _e : "", De.layers = ((ve = O.layers) === null || ve === void 0 ? void 0 : ve.map((Ze) => a.VideoLayer.fromPartial(Ze))) || [], De;
    }
  };
  function Ge() {
    return {
      sid: "",
      type: 0,
      name: "",
      muted: !1,
      width: 0,
      height: 0,
      simulcast: !1,
      disableDtx: !1,
      source: 0,
      layers: [],
      mimeType: "",
      mid: "",
      codecs: [],
      stereo: !1,
      disableRed: !1
    };
  }
  a.TrackInfo = {
    encode(O, j = l.default.Writer.create()) {
      O.sid !== "" && j.uint32(10).string(O.sid), O.type !== 0 && j.uint32(16).int32(O.type), O.name !== "" && j.uint32(26).string(O.name), O.muted === !0 && j.uint32(32).bool(O.muted), O.width !== 0 && j.uint32(40).uint32(O.width), O.height !== 0 && j.uint32(48).uint32(O.height), O.simulcast === !0 && j.uint32(56).bool(O.simulcast), O.disableDtx === !0 && j.uint32(64).bool(O.disableDtx), O.source !== 0 && j.uint32(72).int32(O.source);
      for (const se of O.layers)
        a.VideoLayer.encode(se, j.uint32(82).fork()).ldelim();
      O.mimeType !== "" && j.uint32(90).string(O.mimeType), O.mid !== "" && j.uint32(98).string(O.mid);
      for (const se of O.codecs)
        a.SimulcastCodecInfo.encode(se, j.uint32(106).fork()).ldelim();
      return O.stereo === !0 && j.uint32(112).bool(O.stereo), O.disableRed === !0 && j.uint32(120).bool(O.disableRed), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = Ge();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.sid = se.string();
            break;
          case 2:
            ve.type = se.int32();
            break;
          case 3:
            ve.name = se.string();
            break;
          case 4:
            ve.muted = se.bool();
            break;
          case 5:
            ve.width = se.uint32();
            break;
          case 6:
            ve.height = se.uint32();
            break;
          case 7:
            ve.simulcast = se.bool();
            break;
          case 8:
            ve.disableDtx = se.bool();
            break;
          case 9:
            ve.source = se.int32();
            break;
          case 10:
            ve.layers.push(a.VideoLayer.decode(se, se.uint32()));
            break;
          case 11:
            ve.mimeType = se.string();
            break;
          case 12:
            ve.mid = se.string();
            break;
          case 13:
            ve.codecs.push(a.SimulcastCodecInfo.decode(se, se.uint32()));
            break;
          case 14:
            ve.stereo = se.bool();
            break;
          case 15:
            ve.disableRed = se.bool();
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        sid: ue(O.sid) ? String(O.sid) : "",
        type: ue(O.type) ? g(O.type) : 0,
        name: ue(O.name) ? String(O.name) : "",
        muted: ue(O.muted) ? !!O.muted : !1,
        width: ue(O.width) ? Number(O.width) : 0,
        height: ue(O.height) ? Number(O.height) : 0,
        simulcast: ue(O.simulcast) ? !!O.simulcast : !1,
        disableDtx: ue(O.disableDtx) ? !!O.disableDtx : !1,
        source: ue(O.source) ? k(O.source) : 0,
        layers: Array.isArray(O == null ? void 0 : O.layers) ? O.layers.map((j) => a.VideoLayer.fromJSON(j)) : [],
        mimeType: ue(O.mimeType) ? String(O.mimeType) : "",
        mid: ue(O.mid) ? String(O.mid) : "",
        codecs: Array.isArray(O == null ? void 0 : O.codecs) ? O.codecs.map((j) => a.SimulcastCodecInfo.fromJSON(j)) : [],
        stereo: ue(O.stereo) ? !!O.stereo : !1,
        disableRed: ue(O.disableRed) ? !!O.disableRed : !1
      };
    },
    toJSON(O) {
      const j = {};
      return O.sid !== void 0 && (j.sid = O.sid), O.type !== void 0 && (j.type = E(O.type)), O.name !== void 0 && (j.name = O.name), O.muted !== void 0 && (j.muted = O.muted), O.width !== void 0 && (j.width = Math.round(O.width)), O.height !== void 0 && (j.height = Math.round(O.height)), O.simulcast !== void 0 && (j.simulcast = O.simulcast), O.disableDtx !== void 0 && (j.disableDtx = O.disableDtx), O.source !== void 0 && (j.source = L(O.source)), O.layers ? j.layers = O.layers.map((se) => se ? a.VideoLayer.toJSON(se) : void 0) : j.layers = [], O.mimeType !== void 0 && (j.mimeType = O.mimeType), O.mid !== void 0 && (j.mid = O.mid), O.codecs ? j.codecs = O.codecs.map((se) => se ? a.SimulcastCodecInfo.toJSON(se) : void 0) : j.codecs = [], O.stereo !== void 0 && (j.stereo = O.stereo), O.disableRed !== void 0 && (j.disableRed = O.disableRed), j;
    },
    fromPartial(O) {
      var j, se, _e, ve, De, Ze, Qe, ot, ft, Ce, I, F, z, Te, fe;
      const ke = Ge();
      return ke.sid = (j = O.sid) !== null && j !== void 0 ? j : "", ke.type = (se = O.type) !== null && se !== void 0 ? se : 0, ke.name = (_e = O.name) !== null && _e !== void 0 ? _e : "", ke.muted = (ve = O.muted) !== null && ve !== void 0 ? ve : !1, ke.width = (De = O.width) !== null && De !== void 0 ? De : 0, ke.height = (Ze = O.height) !== null && Ze !== void 0 ? Ze : 0, ke.simulcast = (Qe = O.simulcast) !== null && Qe !== void 0 ? Qe : !1, ke.disableDtx = (ot = O.disableDtx) !== null && ot !== void 0 ? ot : !1, ke.source = (ft = O.source) !== null && ft !== void 0 ? ft : 0, ke.layers = ((Ce = O.layers) === null || Ce === void 0 ? void 0 : Ce.map((it) => a.VideoLayer.fromPartial(it))) || [], ke.mimeType = (I = O.mimeType) !== null && I !== void 0 ? I : "", ke.mid = (F = O.mid) !== null && F !== void 0 ? F : "", ke.codecs = ((z = O.codecs) === null || z === void 0 ? void 0 : z.map((it) => a.SimulcastCodecInfo.fromPartial(it))) || [], ke.stereo = (Te = O.stereo) !== null && Te !== void 0 ? Te : !1, ke.disableRed = (fe = O.disableRed) !== null && fe !== void 0 ? fe : !1, ke;
    }
  };
  function He() {
    return { quality: 0, width: 0, height: 0, bitrate: 0, ssrc: 0 };
  }
  a.VideoLayer = {
    encode(O, j = l.default.Writer.create()) {
      return O.quality !== 0 && j.uint32(8).int32(O.quality), O.width !== 0 && j.uint32(16).uint32(O.width), O.height !== 0 && j.uint32(24).uint32(O.height), O.bitrate !== 0 && j.uint32(32).uint32(O.bitrate), O.ssrc !== 0 && j.uint32(40).uint32(O.ssrc), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = He();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.quality = se.int32();
            break;
          case 2:
            ve.width = se.uint32();
            break;
          case 3:
            ve.height = se.uint32();
            break;
          case 4:
            ve.bitrate = se.uint32();
            break;
          case 5:
            ve.ssrc = se.uint32();
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        quality: ue(O.quality) ? $(O.quality) : 0,
        width: ue(O.width) ? Number(O.width) : 0,
        height: ue(O.height) ? Number(O.height) : 0,
        bitrate: ue(O.bitrate) ? Number(O.bitrate) : 0,
        ssrc: ue(O.ssrc) ? Number(O.ssrc) : 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.quality !== void 0 && (j.quality = J(O.quality)), O.width !== void 0 && (j.width = Math.round(O.width)), O.height !== void 0 && (j.height = Math.round(O.height)), O.bitrate !== void 0 && (j.bitrate = Math.round(O.bitrate)), O.ssrc !== void 0 && (j.ssrc = Math.round(O.ssrc)), j;
    },
    fromPartial(O) {
      var j, se, _e, ve, De;
      const Ze = He();
      return Ze.quality = (j = O.quality) !== null && j !== void 0 ? j : 0, Ze.width = (se = O.width) !== null && se !== void 0 ? se : 0, Ze.height = (_e = O.height) !== null && _e !== void 0 ? _e : 0, Ze.bitrate = (ve = O.bitrate) !== null && ve !== void 0 ? ve : 0, Ze.ssrc = (De = O.ssrc) !== null && De !== void 0 ? De : 0, Ze;
    }
  };
  function Ve() {
    return { kind: 0, user: void 0, speaker: void 0 };
  }
  a.DataPacket = {
    encode(O, j = l.default.Writer.create()) {
      return O.kind !== 0 && j.uint32(8).int32(O.kind), O.user !== void 0 && a.UserPacket.encode(O.user, j.uint32(18).fork()).ldelim(), O.speaker !== void 0 && a.ActiveSpeakerUpdate.encode(O.speaker, j.uint32(26).fork()).ldelim(), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = Ve();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.kind = se.int32();
            break;
          case 2:
            ve.user = a.UserPacket.decode(se, se.uint32());
            break;
          case 3:
            ve.speaker = a.ActiveSpeakerUpdate.decode(se, se.uint32());
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        kind: ue(O.kind) ? D(O.kind) : 0,
        user: ue(O.user) ? a.UserPacket.fromJSON(O.user) : void 0,
        speaker: ue(O.speaker) ? a.ActiveSpeakerUpdate.fromJSON(O.speaker) : void 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.kind !== void 0 && (j.kind = W(O.kind)), O.user !== void 0 && (j.user = O.user ? a.UserPacket.toJSON(O.user) : void 0), O.speaker !== void 0 && (j.speaker = O.speaker ? a.ActiveSpeakerUpdate.toJSON(O.speaker) : void 0), j;
    },
    fromPartial(O) {
      var j;
      const se = Ve();
      return se.kind = (j = O.kind) !== null && j !== void 0 ? j : 0, se.user = O.user !== void 0 && O.user !== null ? a.UserPacket.fromPartial(O.user) : void 0, se.speaker = O.speaker !== void 0 && O.speaker !== null ? a.ActiveSpeakerUpdate.fromPartial(O.speaker) : void 0, se;
    }
  };
  function be() {
    return { speakers: [] };
  }
  a.ActiveSpeakerUpdate = {
    encode(O, j = l.default.Writer.create()) {
      for (const se of O.speakers)
        a.SpeakerInfo.encode(se, j.uint32(10).fork()).ldelim();
      return j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = be();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.speakers.push(a.SpeakerInfo.decode(se, se.uint32()));
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        speakers: Array.isArray(O == null ? void 0 : O.speakers) ? O.speakers.map((j) => a.SpeakerInfo.fromJSON(j)) : []
      };
    },
    toJSON(O) {
      const j = {};
      return O.speakers ? j.speakers = O.speakers.map((se) => se ? a.SpeakerInfo.toJSON(se) : void 0) : j.speakers = [], j;
    },
    fromPartial(O) {
      var j;
      const se = be();
      return se.speakers = ((j = O.speakers) === null || j === void 0 ? void 0 : j.map((_e) => a.SpeakerInfo.fromPartial(_e))) || [], se;
    }
  };
  function Ae() {
    return { sid: "", level: 0, active: !1 };
  }
  a.SpeakerInfo = {
    encode(O, j = l.default.Writer.create()) {
      return O.sid !== "" && j.uint32(10).string(O.sid), O.level !== 0 && j.uint32(21).float(O.level), O.active === !0 && j.uint32(24).bool(O.active), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = Ae();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.sid = se.string();
            break;
          case 2:
            ve.level = se.float();
            break;
          case 3:
            ve.active = se.bool();
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        sid: ue(O.sid) ? String(O.sid) : "",
        level: ue(O.level) ? Number(O.level) : 0,
        active: ue(O.active) ? !!O.active : !1
      };
    },
    toJSON(O) {
      const j = {};
      return O.sid !== void 0 && (j.sid = O.sid), O.level !== void 0 && (j.level = O.level), O.active !== void 0 && (j.active = O.active), j;
    },
    fromPartial(O) {
      var j, se, _e;
      const ve = Ae();
      return ve.sid = (j = O.sid) !== null && j !== void 0 ? j : "", ve.level = (se = O.level) !== null && se !== void 0 ? se : 0, ve.active = (_e = O.active) !== null && _e !== void 0 ? _e : !1, ve;
    }
  };
  function qe() {
    return { participantSid: "", payload: new Uint8Array(), destinationSids: [] };
  }
  a.UserPacket = {
    encode(O, j = l.default.Writer.create()) {
      O.participantSid !== "" && j.uint32(10).string(O.participantSid), O.payload.length !== 0 && j.uint32(18).bytes(O.payload);
      for (const se of O.destinationSids)
        j.uint32(26).string(se);
      return j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = qe();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.participantSid = se.string();
            break;
          case 2:
            ve.payload = se.bytes();
            break;
          case 3:
            ve.destinationSids.push(se.string());
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        participantSid: ue(O.participantSid) ? String(O.participantSid) : "",
        payload: ue(O.payload) ? je(O.payload) : new Uint8Array(),
        destinationSids: Array.isArray(O == null ? void 0 : O.destinationSids) ? O.destinationSids.map((j) => String(j)) : []
      };
    },
    toJSON(O) {
      const j = {};
      return O.participantSid !== void 0 && (j.participantSid = O.participantSid), O.payload !== void 0 && (j.payload = tt(O.payload !== void 0 ? O.payload : new Uint8Array())), O.destinationSids ? j.destinationSids = O.destinationSids.map((se) => se) : j.destinationSids = [], j;
    },
    fromPartial(O) {
      var j, se, _e;
      const ve = qe();
      return ve.participantSid = (j = O.participantSid) !== null && j !== void 0 ? j : "", ve.payload = (se = O.payload) !== null && se !== void 0 ? se : new Uint8Array(), ve.destinationSids = ((_e = O.destinationSids) === null || _e === void 0 ? void 0 : _e.map((De) => De)) || [], ve;
    }
  };
  function xe() {
    return { participantSid: "", trackSids: [] };
  }
  a.ParticipantTracks = {
    encode(O, j = l.default.Writer.create()) {
      O.participantSid !== "" && j.uint32(10).string(O.participantSid);
      for (const se of O.trackSids)
        j.uint32(18).string(se);
      return j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = xe();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.participantSid = se.string();
            break;
          case 2:
            ve.trackSids.push(se.string());
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        participantSid: ue(O.participantSid) ? String(O.participantSid) : "",
        trackSids: Array.isArray(O == null ? void 0 : O.trackSids) ? O.trackSids.map((j) => String(j)) : []
      };
    },
    toJSON(O) {
      const j = {};
      return O.participantSid !== void 0 && (j.participantSid = O.participantSid), O.trackSids ? j.trackSids = O.trackSids.map((se) => se) : j.trackSids = [], j;
    },
    fromPartial(O) {
      var j, se;
      const _e = xe();
      return _e.participantSid = (j = O.participantSid) !== null && j !== void 0 ? j : "", _e.trackSids = ((se = O.trackSids) === null || se === void 0 ? void 0 : se.map((ve) => ve)) || [], _e;
    }
  };
  function Pe() {
    return { edition: 0, version: "", protocol: 0, region: "", nodeId: "", debugInfo: "" };
  }
  a.ServerInfo = {
    encode(O, j = l.default.Writer.create()) {
      return O.edition !== 0 && j.uint32(8).int32(O.edition), O.version !== "" && j.uint32(18).string(O.version), O.protocol !== 0 && j.uint32(24).int32(O.protocol), O.region !== "" && j.uint32(34).string(O.region), O.nodeId !== "" && j.uint32(42).string(O.nodeId), O.debugInfo !== "" && j.uint32(50).string(O.debugInfo), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = Pe();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.edition = se.int32();
            break;
          case 2:
            ve.version = se.string();
            break;
          case 3:
            ve.protocol = se.int32();
            break;
          case 4:
            ve.region = se.string();
            break;
          case 5:
            ve.nodeId = se.string();
            break;
          case 6:
            ve.debugInfo = se.string();
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        edition: ue(O.edition) ? ae(O.edition) : 0,
        version: ue(O.version) ? String(O.version) : "",
        protocol: ue(O.protocol) ? Number(O.protocol) : 0,
        region: ue(O.region) ? String(O.region) : "",
        nodeId: ue(O.nodeId) ? String(O.nodeId) : "",
        debugInfo: ue(O.debugInfo) ? String(O.debugInfo) : ""
      };
    },
    toJSON(O) {
      const j = {};
      return O.edition !== void 0 && (j.edition = ye(O.edition)), O.version !== void 0 && (j.version = O.version), O.protocol !== void 0 && (j.protocol = Math.round(O.protocol)), O.region !== void 0 && (j.region = O.region), O.nodeId !== void 0 && (j.nodeId = O.nodeId), O.debugInfo !== void 0 && (j.debugInfo = O.debugInfo), j;
    },
    fromPartial(O) {
      var j, se, _e, ve, De, Ze;
      const Qe = Pe();
      return Qe.edition = (j = O.edition) !== null && j !== void 0 ? j : 0, Qe.version = (se = O.version) !== null && se !== void 0 ? se : "", Qe.protocol = (_e = O.protocol) !== null && _e !== void 0 ? _e : 0, Qe.region = (ve = O.region) !== null && ve !== void 0 ? ve : "", Qe.nodeId = (De = O.nodeId) !== null && De !== void 0 ? De : "", Qe.debugInfo = (Ze = O.debugInfo) !== null && Ze !== void 0 ? Ze : "", Qe;
    }
  };
  function C() {
    return {
      sdk: 0,
      version: "",
      protocol: 0,
      os: "",
      osVersion: "",
      deviceModel: "",
      browser: "",
      browserVersion: "",
      address: "",
      network: ""
    };
  }
  a.ClientInfo = {
    encode(O, j = l.default.Writer.create()) {
      return O.sdk !== 0 && j.uint32(8).int32(O.sdk), O.version !== "" && j.uint32(18).string(O.version), O.protocol !== 0 && j.uint32(24).int32(O.protocol), O.os !== "" && j.uint32(34).string(O.os), O.osVersion !== "" && j.uint32(42).string(O.osVersion), O.deviceModel !== "" && j.uint32(50).string(O.deviceModel), O.browser !== "" && j.uint32(58).string(O.browser), O.browserVersion !== "" && j.uint32(66).string(O.browserVersion), O.address !== "" && j.uint32(74).string(O.address), O.network !== "" && j.uint32(82).string(O.network), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = C();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.sdk = se.int32();
            break;
          case 2:
            ve.version = se.string();
            break;
          case 3:
            ve.protocol = se.int32();
            break;
          case 4:
            ve.os = se.string();
            break;
          case 5:
            ve.osVersion = se.string();
            break;
          case 6:
            ve.deviceModel = se.string();
            break;
          case 7:
            ve.browser = se.string();
            break;
          case 8:
            ve.browserVersion = se.string();
            break;
          case 9:
            ve.address = se.string();
            break;
          case 10:
            ve.network = se.string();
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        sdk: ue(O.sdk) ? le(O.sdk) : 0,
        version: ue(O.version) ? String(O.version) : "",
        protocol: ue(O.protocol) ? Number(O.protocol) : 0,
        os: ue(O.os) ? String(O.os) : "",
        osVersion: ue(O.osVersion) ? String(O.osVersion) : "",
        deviceModel: ue(O.deviceModel) ? String(O.deviceModel) : "",
        browser: ue(O.browser) ? String(O.browser) : "",
        browserVersion: ue(O.browserVersion) ? String(O.browserVersion) : "",
        address: ue(O.address) ? String(O.address) : "",
        network: ue(O.network) ? String(O.network) : ""
      };
    },
    toJSON(O) {
      const j = {};
      return O.sdk !== void 0 && (j.sdk = we(O.sdk)), O.version !== void 0 && (j.version = O.version), O.protocol !== void 0 && (j.protocol = Math.round(O.protocol)), O.os !== void 0 && (j.os = O.os), O.osVersion !== void 0 && (j.osVersion = O.osVersion), O.deviceModel !== void 0 && (j.deviceModel = O.deviceModel), O.browser !== void 0 && (j.browser = O.browser), O.browserVersion !== void 0 && (j.browserVersion = O.browserVersion), O.address !== void 0 && (j.address = O.address), O.network !== void 0 && (j.network = O.network), j;
    },
    fromPartial(O) {
      var j, se, _e, ve, De, Ze, Qe, ot, ft, Ce;
      const I = C();
      return I.sdk = (j = O.sdk) !== null && j !== void 0 ? j : 0, I.version = (se = O.version) !== null && se !== void 0 ? se : "", I.protocol = (_e = O.protocol) !== null && _e !== void 0 ? _e : 0, I.os = (ve = O.os) !== null && ve !== void 0 ? ve : "", I.osVersion = (De = O.osVersion) !== null && De !== void 0 ? De : "", I.deviceModel = (Ze = O.deviceModel) !== null && Ze !== void 0 ? Ze : "", I.browser = (Qe = O.browser) !== null && Qe !== void 0 ? Qe : "", I.browserVersion = (ot = O.browserVersion) !== null && ot !== void 0 ? ot : "", I.address = (ft = O.address) !== null && ft !== void 0 ? ft : "", I.network = (Ce = O.network) !== null && Ce !== void 0 ? Ce : "", I;
    }
  };
  function x() {
    return { video: void 0, screen: void 0, resumeConnection: 0, disabledCodecs: void 0, forceRelay: 0 };
  }
  a.ClientConfiguration = {
    encode(O, j = l.default.Writer.create()) {
      return O.video !== void 0 && a.VideoConfiguration.encode(O.video, j.uint32(10).fork()).ldelim(), O.screen !== void 0 && a.VideoConfiguration.encode(O.screen, j.uint32(18).fork()).ldelim(), O.resumeConnection !== 0 && j.uint32(24).int32(O.resumeConnection), O.disabledCodecs !== void 0 && a.DisabledCodecs.encode(O.disabledCodecs, j.uint32(34).fork()).ldelim(), O.forceRelay !== 0 && j.uint32(40).int32(O.forceRelay), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = x();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.video = a.VideoConfiguration.decode(se, se.uint32());
            break;
          case 2:
            ve.screen = a.VideoConfiguration.decode(se, se.uint32());
            break;
          case 3:
            ve.resumeConnection = se.int32();
            break;
          case 4:
            ve.disabledCodecs = a.DisabledCodecs.decode(se, se.uint32());
            break;
          case 5:
            ve.forceRelay = se.int32();
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        video: ue(O.video) ? a.VideoConfiguration.fromJSON(O.video) : void 0,
        screen: ue(O.screen) ? a.VideoConfiguration.fromJSON(O.screen) : void 0,
        resumeConnection: ue(O.resumeConnection) ? B(O.resumeConnection) : 0,
        disabledCodecs: ue(O.disabledCodecs) ? a.DisabledCodecs.fromJSON(O.disabledCodecs) : void 0,
        forceRelay: ue(O.forceRelay) ? B(O.forceRelay) : 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.video !== void 0 && (j.video = O.video ? a.VideoConfiguration.toJSON(O.video) : void 0), O.screen !== void 0 && (j.screen = O.screen ? a.VideoConfiguration.toJSON(O.screen) : void 0), O.resumeConnection !== void 0 && (j.resumeConnection = Y(O.resumeConnection)), O.disabledCodecs !== void 0 && (j.disabledCodecs = O.disabledCodecs ? a.DisabledCodecs.toJSON(O.disabledCodecs) : void 0), O.forceRelay !== void 0 && (j.forceRelay = Y(O.forceRelay)), j;
    },
    fromPartial(O) {
      var j, se;
      const _e = x();
      return _e.video = O.video !== void 0 && O.video !== null ? a.VideoConfiguration.fromPartial(O.video) : void 0, _e.screen = O.screen !== void 0 && O.screen !== null ? a.VideoConfiguration.fromPartial(O.screen) : void 0, _e.resumeConnection = (j = O.resumeConnection) !== null && j !== void 0 ? j : 0, _e.disabledCodecs = O.disabledCodecs !== void 0 && O.disabledCodecs !== null ? a.DisabledCodecs.fromPartial(O.disabledCodecs) : void 0, _e.forceRelay = (se = O.forceRelay) !== null && se !== void 0 ? se : 0, _e;
    }
  };
  function Q() {
    return { hardwareEncoder: 0 };
  }
  a.VideoConfiguration = {
    encode(O, j = l.default.Writer.create()) {
      return O.hardwareEncoder !== 0 && j.uint32(8).int32(O.hardwareEncoder), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = Q();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.hardwareEncoder = se.int32();
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return { hardwareEncoder: ue(O.hardwareEncoder) ? B(O.hardwareEncoder) : 0 };
    },
    toJSON(O) {
      const j = {};
      return O.hardwareEncoder !== void 0 && (j.hardwareEncoder = Y(O.hardwareEncoder)), j;
    },
    fromPartial(O) {
      var j;
      const se = Q();
      return se.hardwareEncoder = (j = O.hardwareEncoder) !== null && j !== void 0 ? j : 0, se;
    }
  };
  function Se() {
    return { codecs: [] };
  }
  a.DisabledCodecs = {
    encode(O, j = l.default.Writer.create()) {
      for (const se of O.codecs)
        a.Codec.encode(se, j.uint32(10).fork()).ldelim();
      return j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = Se();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.codecs.push(a.Codec.decode(se, se.uint32()));
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return { codecs: Array.isArray(O == null ? void 0 : O.codecs) ? O.codecs.map((j) => a.Codec.fromJSON(j)) : [] };
    },
    toJSON(O) {
      const j = {};
      return O.codecs ? j.codecs = O.codecs.map((se) => se ? a.Codec.toJSON(se) : void 0) : j.codecs = [], j;
    },
    fromPartial(O) {
      var j;
      const se = Se();
      return se.codecs = ((j = O.codecs) === null || j === void 0 ? void 0 : j.map((_e) => a.Codec.fromPartial(_e))) || [], se;
    }
  };
  function me() {
    return {
      startTime: void 0,
      endTime: void 0,
      duration: 0,
      packets: 0,
      packetRate: 0,
      bytes: 0,
      headerBytes: 0,
      bitrate: 0,
      packetsLost: 0,
      packetLossRate: 0,
      packetLossPercentage: 0,
      packetsDuplicate: 0,
      packetDuplicateRate: 0,
      bytesDuplicate: 0,
      headerBytesDuplicate: 0,
      bitrateDuplicate: 0,
      packetsPadding: 0,
      packetPaddingRate: 0,
      bytesPadding: 0,
      headerBytesPadding: 0,
      bitratePadding: 0,
      packetsOutOfOrder: 0,
      frames: 0,
      frameRate: 0,
      jitterCurrent: 0,
      jitterMax: 0,
      gapHistogram: {},
      nacks: 0,
      nackAcks: 0,
      nackMisses: 0,
      nackRepeated: 0,
      plis: 0,
      lastPli: void 0,
      firs: 0,
      lastFir: void 0,
      rttCurrent: 0,
      rttMax: 0,
      keyFrames: 0,
      lastKeyFrame: void 0,
      layerLockPlis: 0,
      lastLayerLockPli: void 0
    };
  }
  a.RTPStats = {
    encode(O, j = l.default.Writer.create()) {
      return O.startTime !== void 0 && v.Timestamp.encode(Oe(O.startTime), j.uint32(10).fork()).ldelim(), O.endTime !== void 0 && v.Timestamp.encode(Oe(O.endTime), j.uint32(18).fork()).ldelim(), O.duration !== 0 && j.uint32(25).double(O.duration), O.packets !== 0 && j.uint32(32).uint32(O.packets), O.packetRate !== 0 && j.uint32(41).double(O.packetRate), O.bytes !== 0 && j.uint32(48).uint64(O.bytes), O.headerBytes !== 0 && j.uint32(312).uint64(O.headerBytes), O.bitrate !== 0 && j.uint32(57).double(O.bitrate), O.packetsLost !== 0 && j.uint32(64).uint32(O.packetsLost), O.packetLossRate !== 0 && j.uint32(73).double(O.packetLossRate), O.packetLossPercentage !== 0 && j.uint32(85).float(O.packetLossPercentage), O.packetsDuplicate !== 0 && j.uint32(88).uint32(O.packetsDuplicate), O.packetDuplicateRate !== 0 && j.uint32(97).double(O.packetDuplicateRate), O.bytesDuplicate !== 0 && j.uint32(104).uint64(O.bytesDuplicate), O.headerBytesDuplicate !== 0 && j.uint32(320).uint64(O.headerBytesDuplicate), O.bitrateDuplicate !== 0 && j.uint32(113).double(O.bitrateDuplicate), O.packetsPadding !== 0 && j.uint32(120).uint32(O.packetsPadding), O.packetPaddingRate !== 0 && j.uint32(129).double(O.packetPaddingRate), O.bytesPadding !== 0 && j.uint32(136).uint64(O.bytesPadding), O.headerBytesPadding !== 0 && j.uint32(328).uint64(O.headerBytesPadding), O.bitratePadding !== 0 && j.uint32(145).double(O.bitratePadding), O.packetsOutOfOrder !== 0 && j.uint32(152).uint32(O.packetsOutOfOrder), O.frames !== 0 && j.uint32(160).uint32(O.frames), O.frameRate !== 0 && j.uint32(169).double(O.frameRate), O.jitterCurrent !== 0 && j.uint32(177).double(O.jitterCurrent), O.jitterMax !== 0 && j.uint32(185).double(O.jitterMax), Object.entries(O.gapHistogram).forEach(([se, _e]) => {
        a.RTPStats_GapHistogramEntry.encode({ key: se, value: _e }, j.uint32(194).fork()).ldelim();
      }), O.nacks !== 0 && j.uint32(200).uint32(O.nacks), O.nackAcks !== 0 && j.uint32(296).uint32(O.nackAcks), O.nackMisses !== 0 && j.uint32(208).uint32(O.nackMisses), O.nackRepeated !== 0 && j.uint32(304).uint32(O.nackRepeated), O.plis !== 0 && j.uint32(216).uint32(O.plis), O.lastPli !== void 0 && v.Timestamp.encode(Oe(O.lastPli), j.uint32(226).fork()).ldelim(), O.firs !== 0 && j.uint32(232).uint32(O.firs), O.lastFir !== void 0 && v.Timestamp.encode(Oe(O.lastFir), j.uint32(242).fork()).ldelim(), O.rttCurrent !== 0 && j.uint32(248).uint32(O.rttCurrent), O.rttMax !== 0 && j.uint32(256).uint32(O.rttMax), O.keyFrames !== 0 && j.uint32(264).uint32(O.keyFrames), O.lastKeyFrame !== void 0 && v.Timestamp.encode(Oe(O.lastKeyFrame), j.uint32(274).fork()).ldelim(), O.layerLockPlis !== 0 && j.uint32(280).uint32(O.layerLockPlis), O.lastLayerLockPli !== void 0 && v.Timestamp.encode(Oe(O.lastLayerLockPli), j.uint32(290).fork()).ldelim(), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = me();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.startTime = P(v.Timestamp.decode(se, se.uint32()));
            break;
          case 2:
            ve.endTime = P(v.Timestamp.decode(se, se.uint32()));
            break;
          case 3:
            ve.duration = se.double();
            break;
          case 4:
            ve.packets = se.uint32();
            break;
          case 5:
            ve.packetRate = se.double();
            break;
          case 6:
            ve.bytes = ie(se.uint64());
            break;
          case 39:
            ve.headerBytes = ie(se.uint64());
            break;
          case 7:
            ve.bitrate = se.double();
            break;
          case 8:
            ve.packetsLost = se.uint32();
            break;
          case 9:
            ve.packetLossRate = se.double();
            break;
          case 10:
            ve.packetLossPercentage = se.float();
            break;
          case 11:
            ve.packetsDuplicate = se.uint32();
            break;
          case 12:
            ve.packetDuplicateRate = se.double();
            break;
          case 13:
            ve.bytesDuplicate = ie(se.uint64());
            break;
          case 40:
            ve.headerBytesDuplicate = ie(se.uint64());
            break;
          case 14:
            ve.bitrateDuplicate = se.double();
            break;
          case 15:
            ve.packetsPadding = se.uint32();
            break;
          case 16:
            ve.packetPaddingRate = se.double();
            break;
          case 17:
            ve.bytesPadding = ie(se.uint64());
            break;
          case 41:
            ve.headerBytesPadding = ie(se.uint64());
            break;
          case 18:
            ve.bitratePadding = se.double();
            break;
          case 19:
            ve.packetsOutOfOrder = se.uint32();
            break;
          case 20:
            ve.frames = se.uint32();
            break;
          case 21:
            ve.frameRate = se.double();
            break;
          case 22:
            ve.jitterCurrent = se.double();
            break;
          case 23:
            ve.jitterMax = se.double();
            break;
          case 24:
            const Ze = a.RTPStats_GapHistogramEntry.decode(se, se.uint32());
            Ze.value !== void 0 && (ve.gapHistogram[Ze.key] = Ze.value);
            break;
          case 25:
            ve.nacks = se.uint32();
            break;
          case 37:
            ve.nackAcks = se.uint32();
            break;
          case 26:
            ve.nackMisses = se.uint32();
            break;
          case 38:
            ve.nackRepeated = se.uint32();
            break;
          case 27:
            ve.plis = se.uint32();
            break;
          case 28:
            ve.lastPli = P(v.Timestamp.decode(se, se.uint32()));
            break;
          case 29:
            ve.firs = se.uint32();
            break;
          case 30:
            ve.lastFir = P(v.Timestamp.decode(se, se.uint32()));
            break;
          case 31:
            ve.rttCurrent = se.uint32();
            break;
          case 32:
            ve.rttMax = se.uint32();
            break;
          case 33:
            ve.keyFrames = se.uint32();
            break;
          case 34:
            ve.lastKeyFrame = P(v.Timestamp.decode(se, se.uint32()));
            break;
          case 35:
            ve.layerLockPlis = se.uint32();
            break;
          case 36:
            ve.lastLayerLockPli = P(v.Timestamp.decode(se, se.uint32()));
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        startTime: ue(O.startTime) ? X(O.startTime) : void 0,
        endTime: ue(O.endTime) ? X(O.endTime) : void 0,
        duration: ue(O.duration) ? Number(O.duration) : 0,
        packets: ue(O.packets) ? Number(O.packets) : 0,
        packetRate: ue(O.packetRate) ? Number(O.packetRate) : 0,
        bytes: ue(O.bytes) ? Number(O.bytes) : 0,
        headerBytes: ue(O.headerBytes) ? Number(O.headerBytes) : 0,
        bitrate: ue(O.bitrate) ? Number(O.bitrate) : 0,
        packetsLost: ue(O.packetsLost) ? Number(O.packetsLost) : 0,
        packetLossRate: ue(O.packetLossRate) ? Number(O.packetLossRate) : 0,
        packetLossPercentage: ue(O.packetLossPercentage) ? Number(O.packetLossPercentage) : 0,
        packetsDuplicate: ue(O.packetsDuplicate) ? Number(O.packetsDuplicate) : 0,
        packetDuplicateRate: ue(O.packetDuplicateRate) ? Number(O.packetDuplicateRate) : 0,
        bytesDuplicate: ue(O.bytesDuplicate) ? Number(O.bytesDuplicate) : 0,
        headerBytesDuplicate: ue(O.headerBytesDuplicate) ? Number(O.headerBytesDuplicate) : 0,
        bitrateDuplicate: ue(O.bitrateDuplicate) ? Number(O.bitrateDuplicate) : 0,
        packetsPadding: ue(O.packetsPadding) ? Number(O.packetsPadding) : 0,
        packetPaddingRate: ue(O.packetPaddingRate) ? Number(O.packetPaddingRate) : 0,
        bytesPadding: ue(O.bytesPadding) ? Number(O.bytesPadding) : 0,
        headerBytesPadding: ue(O.headerBytesPadding) ? Number(O.headerBytesPadding) : 0,
        bitratePadding: ue(O.bitratePadding) ? Number(O.bitratePadding) : 0,
        packetsOutOfOrder: ue(O.packetsOutOfOrder) ? Number(O.packetsOutOfOrder) : 0,
        frames: ue(O.frames) ? Number(O.frames) : 0,
        frameRate: ue(O.frameRate) ? Number(O.frameRate) : 0,
        jitterCurrent: ue(O.jitterCurrent) ? Number(O.jitterCurrent) : 0,
        jitterMax: ue(O.jitterMax) ? Number(O.jitterMax) : 0,
        gapHistogram: Ee(O.gapHistogram) ? Object.entries(O.gapHistogram).reduce((j, [se, _e]) => (j[Number(se)] = Number(_e), j), {}) : {},
        nacks: ue(O.nacks) ? Number(O.nacks) : 0,
        nackAcks: ue(O.nackAcks) ? Number(O.nackAcks) : 0,
        nackMisses: ue(O.nackMisses) ? Number(O.nackMisses) : 0,
        nackRepeated: ue(O.nackRepeated) ? Number(O.nackRepeated) : 0,
        plis: ue(O.plis) ? Number(O.plis) : 0,
        lastPli: ue(O.lastPli) ? X(O.lastPli) : void 0,
        firs: ue(O.firs) ? Number(O.firs) : 0,
        lastFir: ue(O.lastFir) ? X(O.lastFir) : void 0,
        rttCurrent: ue(O.rttCurrent) ? Number(O.rttCurrent) : 0,
        rttMax: ue(O.rttMax) ? Number(O.rttMax) : 0,
        keyFrames: ue(O.keyFrames) ? Number(O.keyFrames) : 0,
        lastKeyFrame: ue(O.lastKeyFrame) ? X(O.lastKeyFrame) : void 0,
        layerLockPlis: ue(O.layerLockPlis) ? Number(O.layerLockPlis) : 0,
        lastLayerLockPli: ue(O.lastLayerLockPli) ? X(O.lastLayerLockPli) : void 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.startTime !== void 0 && (j.startTime = O.startTime.toISOString()), O.endTime !== void 0 && (j.endTime = O.endTime.toISOString()), O.duration !== void 0 && (j.duration = O.duration), O.packets !== void 0 && (j.packets = Math.round(O.packets)), O.packetRate !== void 0 && (j.packetRate = O.packetRate), O.bytes !== void 0 && (j.bytes = Math.round(O.bytes)), O.headerBytes !== void 0 && (j.headerBytes = Math.round(O.headerBytes)), O.bitrate !== void 0 && (j.bitrate = O.bitrate), O.packetsLost !== void 0 && (j.packetsLost = Math.round(O.packetsLost)), O.packetLossRate !== void 0 && (j.packetLossRate = O.packetLossRate), O.packetLossPercentage !== void 0 && (j.packetLossPercentage = O.packetLossPercentage), O.packetsDuplicate !== void 0 && (j.packetsDuplicate = Math.round(O.packetsDuplicate)), O.packetDuplicateRate !== void 0 && (j.packetDuplicateRate = O.packetDuplicateRate), O.bytesDuplicate !== void 0 && (j.bytesDuplicate = Math.round(O.bytesDuplicate)), O.headerBytesDuplicate !== void 0 && (j.headerBytesDuplicate = Math.round(O.headerBytesDuplicate)), O.bitrateDuplicate !== void 0 && (j.bitrateDuplicate = O.bitrateDuplicate), O.packetsPadding !== void 0 && (j.packetsPadding = Math.round(O.packetsPadding)), O.packetPaddingRate !== void 0 && (j.packetPaddingRate = O.packetPaddingRate), O.bytesPadding !== void 0 && (j.bytesPadding = Math.round(O.bytesPadding)), O.headerBytesPadding !== void 0 && (j.headerBytesPadding = Math.round(O.headerBytesPadding)), O.bitratePadding !== void 0 && (j.bitratePadding = O.bitratePadding), O.packetsOutOfOrder !== void 0 && (j.packetsOutOfOrder = Math.round(O.packetsOutOfOrder)), O.frames !== void 0 && (j.frames = Math.round(O.frames)), O.frameRate !== void 0 && (j.frameRate = O.frameRate), O.jitterCurrent !== void 0 && (j.jitterCurrent = O.jitterCurrent), O.jitterMax !== void 0 && (j.jitterMax = O.jitterMax), j.gapHistogram = {}, O.gapHistogram && Object.entries(O.gapHistogram).forEach(([se, _e]) => {
        j.gapHistogram[se] = Math.round(_e);
      }), O.nacks !== void 0 && (j.nacks = Math.round(O.nacks)), O.nackAcks !== void 0 && (j.nackAcks = Math.round(O.nackAcks)), O.nackMisses !== void 0 && (j.nackMisses = Math.round(O.nackMisses)), O.nackRepeated !== void 0 && (j.nackRepeated = Math.round(O.nackRepeated)), O.plis !== void 0 && (j.plis = Math.round(O.plis)), O.lastPli !== void 0 && (j.lastPli = O.lastPli.toISOString()), O.firs !== void 0 && (j.firs = Math.round(O.firs)), O.lastFir !== void 0 && (j.lastFir = O.lastFir.toISOString()), O.rttCurrent !== void 0 && (j.rttCurrent = Math.round(O.rttCurrent)), O.rttMax !== void 0 && (j.rttMax = Math.round(O.rttMax)), O.keyFrames !== void 0 && (j.keyFrames = Math.round(O.keyFrames)), O.lastKeyFrame !== void 0 && (j.lastKeyFrame = O.lastKeyFrame.toISOString()), O.layerLockPlis !== void 0 && (j.layerLockPlis = Math.round(O.layerLockPlis)), O.lastLayerLockPli !== void 0 && (j.lastLayerLockPli = O.lastLayerLockPli.toISOString()), j;
    },
    fromPartial(O) {
      var j, se, _e, ve, De, Ze, Qe, ot, ft, Ce, I, F, z, Te, fe, ke, it, mt, vt, st, ut, yt, gt, bt, St, Et, ct, Xe, Ct, Ot, Nt, Pt, wt, At, Dt, pe, ge, Re, Je, Fe, ze;
      const Me = me();
      return Me.startTime = (j = O.startTime) !== null && j !== void 0 ? j : void 0, Me.endTime = (se = O.endTime) !== null && se !== void 0 ? se : void 0, Me.duration = (_e = O.duration) !== null && _e !== void 0 ? _e : 0, Me.packets = (ve = O.packets) !== null && ve !== void 0 ? ve : 0, Me.packetRate = (De = O.packetRate) !== null && De !== void 0 ? De : 0, Me.bytes = (Ze = O.bytes) !== null && Ze !== void 0 ? Ze : 0, Me.headerBytes = (Qe = O.headerBytes) !== null && Qe !== void 0 ? Qe : 0, Me.bitrate = (ot = O.bitrate) !== null && ot !== void 0 ? ot : 0, Me.packetsLost = (ft = O.packetsLost) !== null && ft !== void 0 ? ft : 0, Me.packetLossRate = (Ce = O.packetLossRate) !== null && Ce !== void 0 ? Ce : 0, Me.packetLossPercentage = (I = O.packetLossPercentage) !== null && I !== void 0 ? I : 0, Me.packetsDuplicate = (F = O.packetsDuplicate) !== null && F !== void 0 ? F : 0, Me.packetDuplicateRate = (z = O.packetDuplicateRate) !== null && z !== void 0 ? z : 0, Me.bytesDuplicate = (Te = O.bytesDuplicate) !== null && Te !== void 0 ? Te : 0, Me.headerBytesDuplicate = (fe = O.headerBytesDuplicate) !== null && fe !== void 0 ? fe : 0, Me.bitrateDuplicate = (ke = O.bitrateDuplicate) !== null && ke !== void 0 ? ke : 0, Me.packetsPadding = (it = O.packetsPadding) !== null && it !== void 0 ? it : 0, Me.packetPaddingRate = (mt = O.packetPaddingRate) !== null && mt !== void 0 ? mt : 0, Me.bytesPadding = (vt = O.bytesPadding) !== null && vt !== void 0 ? vt : 0, Me.headerBytesPadding = (st = O.headerBytesPadding) !== null && st !== void 0 ? st : 0, Me.bitratePadding = (ut = O.bitratePadding) !== null && ut !== void 0 ? ut : 0, Me.packetsOutOfOrder = (yt = O.packetsOutOfOrder) !== null && yt !== void 0 ? yt : 0, Me.frames = (gt = O.frames) !== null && gt !== void 0 ? gt : 0, Me.frameRate = (bt = O.frameRate) !== null && bt !== void 0 ? bt : 0, Me.jitterCurrent = (St = O.jitterCurrent) !== null && St !== void 0 ? St : 0, Me.jitterMax = (Et = O.jitterMax) !== null && Et !== void 0 ? Et : 0, Me.gapHistogram = Object.entries((ct = O.gapHistogram) !== null && ct !== void 0 ? ct : {}).reduce((nt, [rt, Tt]) => (Tt !== void 0 && (nt[Number(rt)] = Number(Tt)), nt), {}), Me.nacks = (Xe = O.nacks) !== null && Xe !== void 0 ? Xe : 0, Me.nackAcks = (Ct = O.nackAcks) !== null && Ct !== void 0 ? Ct : 0, Me.nackMisses = (Ot = O.nackMisses) !== null && Ot !== void 0 ? Ot : 0, Me.nackRepeated = (Nt = O.nackRepeated) !== null && Nt !== void 0 ? Nt : 0, Me.plis = (Pt = O.plis) !== null && Pt !== void 0 ? Pt : 0, Me.lastPli = (wt = O.lastPli) !== null && wt !== void 0 ? wt : void 0, Me.firs = (At = O.firs) !== null && At !== void 0 ? At : 0, Me.lastFir = (Dt = O.lastFir) !== null && Dt !== void 0 ? Dt : void 0, Me.rttCurrent = (pe = O.rttCurrent) !== null && pe !== void 0 ? pe : 0, Me.rttMax = (ge = O.rttMax) !== null && ge !== void 0 ? ge : 0, Me.keyFrames = (Re = O.keyFrames) !== null && Re !== void 0 ? Re : 0, Me.lastKeyFrame = (Je = O.lastKeyFrame) !== null && Je !== void 0 ? Je : void 0, Me.layerLockPlis = (Fe = O.layerLockPlis) !== null && Fe !== void 0 ? Fe : 0, Me.lastLayerLockPli = (ze = O.lastLayerLockPli) !== null && ze !== void 0 ? ze : void 0, Me;
    }
  };
  function Ie() {
    return { key: 0, value: 0 };
  }
  a.RTPStats_GapHistogramEntry = {
    encode(O, j = l.default.Writer.create()) {
      return O.key !== 0 && j.uint32(8).int32(O.key), O.value !== 0 && j.uint32(16).uint32(O.value), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = Ie();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.key = se.int32();
            break;
          case 2:
            ve.value = se.uint32();
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return { key: ue(O.key) ? Number(O.key) : 0, value: ue(O.value) ? Number(O.value) : 0 };
    },
    toJSON(O) {
      const j = {};
      return O.key !== void 0 && (j.key = Math.round(O.key)), O.value !== void 0 && (j.value = Math.round(O.value)), j;
    },
    fromPartial(O) {
      var j, se;
      const _e = Ie();
      return _e.key = (j = O.key) !== null && j !== void 0 ? j : 0, _e.value = (se = O.value) !== null && se !== void 0 ? se : 0, _e;
    }
  };
  function at() {
    return { unixMicro: 0, ticks: 0 };
  }
  a.TimedVersion = {
    encode(O, j = l.default.Writer.create()) {
      return O.unixMicro !== 0 && j.uint32(8).int64(O.unixMicro), O.ticks !== 0 && j.uint32(16).int32(O.ticks), j;
    },
    decode(O, j) {
      const se = O instanceof l.default.Reader ? O : new l.default.Reader(O);
      let _e = j === void 0 ? se.len : se.pos + j;
      const ve = at();
      for (; se.pos < _e; ) {
        const De = se.uint32();
        switch (De >>> 3) {
          case 1:
            ve.unixMicro = ie(se.int64());
            break;
          case 2:
            ve.ticks = se.int32();
            break;
          default:
            se.skipType(De & 7);
            break;
        }
      }
      return ve;
    },
    fromJSON(O) {
      return {
        unixMicro: ue(O.unixMicro) ? Number(O.unixMicro) : 0,
        ticks: ue(O.ticks) ? Number(O.ticks) : 0
      };
    },
    toJSON(O) {
      const j = {};
      return O.unixMicro !== void 0 && (j.unixMicro = Math.round(O.unixMicro)), O.ticks !== void 0 && (j.ticks = Math.round(O.ticks)), j;
    },
    fromPartial(O) {
      var j, se;
      const _e = at();
      return _e.unixMicro = (j = O.unixMicro) !== null && j !== void 0 ? j : 0, _e.ticks = (se = O.ticks) !== null && se !== void 0 ? se : 0, _e;
    }
  };
  var Ye = (() => {
    if (typeof Ye < "u")
      return Ye;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function je(O) {
    if (Ye.Buffer)
      return Uint8Array.from(Ye.Buffer.from(O, "base64"));
    {
      const j = Ye.atob(O), se = new Uint8Array(j.length);
      for (let _e = 0; _e < j.length; ++_e)
        se[_e] = j.charCodeAt(_e);
      return se;
    }
  }
  function tt(O) {
    if (Ye.Buffer)
      return Ye.Buffer.from(O).toString("base64");
    {
      const j = [];
      return O.forEach((se) => {
        j.push(String.fromCharCode(se));
      }), Ye.btoa(j.join(""));
    }
  }
  function Oe(O) {
    const j = O.getTime() / 1e3, se = O.getTime() % 1e3 * 1e6;
    return { seconds: j, nanos: se };
  }
  function P(O) {
    let j = O.seconds * 1e3;
    return j += O.nanos / 1e6, new Date(j);
  }
  function X(O) {
    return O instanceof Date ? O : typeof O == "string" ? new Date(O) : P(v.Timestamp.fromJSON(O));
  }
  function ie(O) {
    if (O.gt(Number.MAX_SAFE_INTEGER))
      throw new Ye.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return O.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function Ee(O) {
    return typeof O == "object" && O !== null;
  }
  function ue(O) {
    return O != null;
  }
})(livekit_models);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(A) {
    return A && A.__esModule ? A : { default: A };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.DeleteIngressRequest = a.ListIngressResponse = a.ListIngressRequest = a.UpdateIngressRequest = a.InputAudioState = a.InputVideoState = a.IngressState = a.IngressInfo = a.IngressVideoOptions = a.IngressAudioOptions = a.CreateIngressRequest = a.ingressState_StatusToJSON = a.ingressState_StatusFromJSON = a.IngressState_Status = a.ingressInputToJSON = a.ingressInputFromJSON = a.IngressInput = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_models;
  a.protobufPackage = "livekit";
  var S;
  (function(A) {
    A[A.RTMP_INPUT = 0] = "RTMP_INPUT", A[A.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(S = a.IngressInput || (a.IngressInput = {}));
  function g(A) {
    switch (A) {
      case 0:
      case "RTMP_INPUT":
        return S.RTMP_INPUT;
      case -1:
      case "UNRECOGNIZED":
      default:
        return S.UNRECOGNIZED;
    }
  }
  a.ingressInputFromJSON = g;
  function E(A) {
    switch (A) {
      case S.RTMP_INPUT:
        return "RTMP_INPUT";
      case S.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.ingressInputToJSON = E;
  var _;
  (function(A) {
    A[A.ENDPOINT_INACTIVE = 0] = "ENDPOINT_INACTIVE", A[A.ENDPOINT_BUFFERING = 1] = "ENDPOINT_BUFFERING", A[A.ENDPOINT_PUBLISHING = 2] = "ENDPOINT_PUBLISHING", A[A.ENDPOINT_ERROR = 3] = "ENDPOINT_ERROR", A[A.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(_ = a.IngressState_Status || (a.IngressState_Status = {}));
  function k(A) {
    switch (A) {
      case 0:
      case "ENDPOINT_INACTIVE":
        return _.ENDPOINT_INACTIVE;
      case 1:
      case "ENDPOINT_BUFFERING":
        return _.ENDPOINT_BUFFERING;
      case 2:
      case "ENDPOINT_PUBLISHING":
        return _.ENDPOINT_PUBLISHING;
      case 3:
      case "ENDPOINT_ERROR":
        return _.ENDPOINT_ERROR;
      case -1:
      case "UNRECOGNIZED":
      default:
        return _.UNRECOGNIZED;
    }
  }
  a.ingressState_StatusFromJSON = k;
  function L(A) {
    switch (A) {
      case _.ENDPOINT_INACTIVE:
        return "ENDPOINT_INACTIVE";
      case _.ENDPOINT_BUFFERING:
        return "ENDPOINT_BUFFERING";
      case _.ENDPOINT_PUBLISHING:
        return "ENDPOINT_PUBLISHING";
      case _.ENDPOINT_ERROR:
        return "ENDPOINT_ERROR";
      case _.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.ingressState_StatusToJSON = L;
  function M() {
    return {
      inputType: 0,
      name: "",
      roomName: "",
      participantIdentity: "",
      participantName: "",
      audio: void 0,
      video: void 0
    };
  }
  a.CreateIngressRequest = {
    encode(A, N = l.default.Writer.create()) {
      return A.inputType !== void 0 && A.inputType !== 0 && N.uint32(8).int32(A.inputType), A.name !== void 0 && A.name !== "" && N.uint32(18).string(A.name), A.roomName !== void 0 && A.roomName !== "" && N.uint32(26).string(A.roomName), A.participantIdentity !== void 0 && A.participantIdentity !== "" && N.uint32(34).string(A.participantIdentity), A.participantName !== void 0 && A.participantName !== "" && N.uint32(42).string(A.participantName), A.audio !== void 0 && a.IngressAudioOptions.encode(A.audio, N.uint32(50).fork()).ldelim(), A.video !== void 0 && a.IngressVideoOptions.encode(A.video, N.uint32(58).fork()).ldelim(), N;
    },
    decode(A, N) {
      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = M();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.inputType = D.int32();
            break;
          case 2:
            ee.name = D.string();
            break;
          case 3:
            ee.roomName = D.string();
            break;
          case 4:
            ee.participantIdentity = D.string();
            break;
          case 5:
            ee.participantName = D.string();
            break;
          case 6:
            ee.audio = a.IngressAudioOptions.decode(D, D.uint32());
            break;
          case 7:
            ee.video = a.IngressVideoOptions.decode(D, D.uint32());
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        inputType: de(A.inputType) ? g(A.inputType) : 0,
        name: de(A.name) ? String(A.name) : "",
        roomName: de(A.roomName) ? String(A.roomName) : "",
        participantIdentity: de(A.participantIdentity) ? String(A.participantIdentity) : "",
        participantName: de(A.participantName) ? String(A.participantName) : "",
        audio: de(A.audio) ? a.IngressAudioOptions.fromJSON(A.audio) : void 0,
        video: de(A.video) ? a.IngressVideoOptions.fromJSON(A.video) : void 0
      };
    },
    toJSON(A) {
      const N = {};
      return A.inputType !== void 0 && (N.inputType = E(A.inputType)), A.name !== void 0 && (N.name = A.name), A.roomName !== void 0 && (N.roomName = A.roomName), A.participantIdentity !== void 0 && (N.participantIdentity = A.participantIdentity), A.participantName !== void 0 && (N.participantName = A.participantName), A.audio !== void 0 && (N.audio = A.audio ? a.IngressAudioOptions.toJSON(A.audio) : void 0), A.video !== void 0 && (N.video = A.video ? a.IngressVideoOptions.toJSON(A.video) : void 0), N;
    },
    fromPartial(A) {
      var N, D, W, ee, ae;
      const ye = M();
      return ye.inputType = (N = A.inputType) !== null && N !== void 0 ? N : 0, ye.name = (D = A.name) !== null && D !== void 0 ? D : "", ye.roomName = (W = A.roomName) !== null && W !== void 0 ? W : "", ye.participantIdentity = (ee = A.participantIdentity) !== null && ee !== void 0 ? ee : "", ye.participantName = (ae = A.participantName) !== null && ae !== void 0 ? ae : "", ye.audio = A.audio !== void 0 && A.audio !== null ? a.IngressAudioOptions.fromPartial(A.audio) : void 0, ye.video = A.video !== void 0 && A.video !== null ? a.IngressVideoOptions.fromPartial(A.video) : void 0, ye;
    }
  };
  function $() {
    return { name: "", source: 0, mimeType: "", bitrate: 0, disableDtx: !1, channels: 0 };
  }
  a.IngressAudioOptions = {
    encode(A, N = l.default.Writer.create()) {
      return A.name !== void 0 && A.name !== "" && N.uint32(10).string(A.name), A.source !== void 0 && A.source !== 0 && N.uint32(16).int32(A.source), A.mimeType !== void 0 && A.mimeType !== "" && N.uint32(26).string(A.mimeType), A.bitrate !== void 0 && A.bitrate !== 0 && N.uint32(32).uint32(A.bitrate), A.disableDtx === !0 && N.uint32(40).bool(A.disableDtx), A.channels !== void 0 && A.channels !== 0 && N.uint32(48).uint32(A.channels), N;
    },
    decode(A, N) {
      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = $();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.name = D.string();
            break;
          case 2:
            ee.source = D.int32();
            break;
          case 3:
            ee.mimeType = D.string();
            break;
          case 4:
            ee.bitrate = D.uint32();
            break;
          case 5:
            ee.disableDtx = D.bool();
            break;
          case 6:
            ee.channels = D.uint32();
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        name: de(A.name) ? String(A.name) : "",
        source: de(A.source) ? v.trackSourceFromJSON(A.source) : 0,
        mimeType: de(A.mimeType) ? String(A.mimeType) : "",
        bitrate: de(A.bitrate) ? Number(A.bitrate) : 0,
        disableDtx: de(A.disableDtx) ? !!A.disableDtx : !1,
        channels: de(A.channels) ? Number(A.channels) : 0
      };
    },
    toJSON(A) {
      const N = {};
      return A.name !== void 0 && (N.name = A.name), A.source !== void 0 && (N.source = v.trackSourceToJSON(A.source)), A.mimeType !== void 0 && (N.mimeType = A.mimeType), A.bitrate !== void 0 && (N.bitrate = Math.round(A.bitrate)), A.disableDtx !== void 0 && (N.disableDtx = A.disableDtx), A.channels !== void 0 && (N.channels = Math.round(A.channels)), N;
    },
    fromPartial(A) {
      var N, D, W, ee, ae, ye;
      const he = $();
      return he.name = (N = A.name) !== null && N !== void 0 ? N : "", he.source = (D = A.source) !== null && D !== void 0 ? D : 0, he.mimeType = (W = A.mimeType) !== null && W !== void 0 ? W : "", he.bitrate = (ee = A.bitrate) !== null && ee !== void 0 ? ee : 0, he.disableDtx = (ae = A.disableDtx) !== null && ae !== void 0 ? ae : !1, he.channels = (ye = A.channels) !== null && ye !== void 0 ? ye : 0, he;
    }
  };
  function J() {
    return { name: "", source: 0, mimeType: "", layers: [] };
  }
  a.IngressVideoOptions = {
    encode(A, N = l.default.Writer.create()) {
      if (A.name !== void 0 && A.name !== "" && N.uint32(10).string(A.name), A.source !== void 0 && A.source !== 0 && N.uint32(16).int32(A.source), A.mimeType !== void 0 && A.mimeType !== "" && N.uint32(26).string(A.mimeType), A.layers !== void 0 && A.layers.length !== 0)
        for (const D of A.layers)
          v.VideoLayer.encode(D, N.uint32(34).fork()).ldelim();
      return N;
    },
    decode(A, N) {
      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = J();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.name = D.string();
            break;
          case 2:
            ee.source = D.int32();
            break;
          case 3:
            ee.mimeType = D.string();
            break;
          case 4:
            ee.layers.push(v.VideoLayer.decode(D, D.uint32()));
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        name: de(A.name) ? String(A.name) : "",
        source: de(A.source) ? v.trackSourceFromJSON(A.source) : 0,
        mimeType: de(A.mimeType) ? String(A.mimeType) : "",
        layers: Array.isArray(A == null ? void 0 : A.layers) ? A.layers.map((N) => v.VideoLayer.fromJSON(N)) : []
      };
    },
    toJSON(A) {
      const N = {};
      return A.name !== void 0 && (N.name = A.name), A.source !== void 0 && (N.source = v.trackSourceToJSON(A.source)), A.mimeType !== void 0 && (N.mimeType = A.mimeType), A.layers ? N.layers = A.layers.map((D) => D ? v.VideoLayer.toJSON(D) : void 0) : N.layers = [], N;
    },
    fromPartial(A) {
      var N, D, W, ee;
      const ae = J();
      return ae.name = (N = A.name) !== null && N !== void 0 ? N : "", ae.source = (D = A.source) !== null && D !== void 0 ? D : 0, ae.mimeType = (W = A.mimeType) !== null && W !== void 0 ? W : "", ae.layers = ((ee = A.layers) === null || ee === void 0 ? void 0 : ee.map((ye) => v.VideoLayer.fromPartial(ye))) || [], ae;
    }
  };
  function V() {
    return {
      ingressId: "",
      name: "",
      streamKey: "",
      url: "",
      inputType: 0,
      audio: void 0,
      video: void 0,
      roomName: "",
      participantIdentity: "",
      participantName: "",
      reusable: !1,
      state: void 0
    };
  }
  a.IngressInfo = {
    encode(A, N = l.default.Writer.create()) {
      return A.ingressId !== void 0 && A.ingressId !== "" && N.uint32(10).string(A.ingressId), A.name !== void 0 && A.name !== "" && N.uint32(18).string(A.name), A.streamKey !== void 0 && A.streamKey !== "" && N.uint32(26).string(A.streamKey), A.url !== void 0 && A.url !== "" && N.uint32(34).string(A.url), A.inputType !== void 0 && A.inputType !== 0 && N.uint32(40).int32(A.inputType), A.audio !== void 0 && a.IngressAudioOptions.encode(A.audio, N.uint32(50).fork()).ldelim(), A.video !== void 0 && a.IngressVideoOptions.encode(A.video, N.uint32(58).fork()).ldelim(), A.roomName !== void 0 && A.roomName !== "" && N.uint32(66).string(A.roomName), A.participantIdentity !== void 0 && A.participantIdentity !== "" && N.uint32(74).string(A.participantIdentity), A.participantName !== void 0 && A.participantName !== "" && N.uint32(82).string(A.participantName), A.reusable === !0 && N.uint32(88).bool(A.reusable), A.state !== void 0 && a.IngressState.encode(A.state, N.uint32(98).fork()).ldelim(), N;
    },
    decode(A, N) {
      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = V();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.ingressId = D.string();
            break;
          case 2:
            ee.name = D.string();
            break;
          case 3:
            ee.streamKey = D.string();
            break;
          case 4:
            ee.url = D.string();
            break;
          case 5:
            ee.inputType = D.int32();
            break;
          case 6:
            ee.audio = a.IngressAudioOptions.decode(D, D.uint32());
            break;
          case 7:
            ee.video = a.IngressVideoOptions.decode(D, D.uint32());
            break;
          case 8:
            ee.roomName = D.string();
            break;
          case 9:
            ee.participantIdentity = D.string();
            break;
          case 10:
            ee.participantName = D.string();
            break;
          case 11:
            ee.reusable = D.bool();
            break;
          case 12:
            ee.state = a.IngressState.decode(D, D.uint32());
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        ingressId: de(A.ingressId) ? String(A.ingressId) : "",
        name: de(A.name) ? String(A.name) : "",
        streamKey: de(A.streamKey) ? String(A.streamKey) : "",
        url: de(A.url) ? String(A.url) : "",
        inputType: de(A.inputType) ? g(A.inputType) : 0,
        audio: de(A.audio) ? a.IngressAudioOptions.fromJSON(A.audio) : void 0,
        video: de(A.video) ? a.IngressVideoOptions.fromJSON(A.video) : void 0,
        roomName: de(A.roomName) ? String(A.roomName) : "",
        participantIdentity: de(A.participantIdentity) ? String(A.participantIdentity) : "",
        participantName: de(A.participantName) ? String(A.participantName) : "",
        reusable: de(A.reusable) ? !!A.reusable : !1,
        state: de(A.state) ? a.IngressState.fromJSON(A.state) : void 0
      };
    },
    toJSON(A) {
      const N = {};
      return A.ingressId !== void 0 && (N.ingressId = A.ingressId), A.name !== void 0 && (N.name = A.name), A.streamKey !== void 0 && (N.streamKey = A.streamKey), A.url !== void 0 && (N.url = A.url), A.inputType !== void 0 && (N.inputType = E(A.inputType)), A.audio !== void 0 && (N.audio = A.audio ? a.IngressAudioOptions.toJSON(A.audio) : void 0), A.video !== void 0 && (N.video = A.video ? a.IngressVideoOptions.toJSON(A.video) : void 0), A.roomName !== void 0 && (N.roomName = A.roomName), A.participantIdentity !== void 0 && (N.participantIdentity = A.participantIdentity), A.participantName !== void 0 && (N.participantName = A.participantName), A.reusable !== void 0 && (N.reusable = A.reusable), A.state !== void 0 && (N.state = A.state ? a.IngressState.toJSON(A.state) : void 0), N;
    },
    fromPartial(A) {
      var N, D, W, ee, ae, ye, he, le, we;
      const Be = V();
      return Be.ingressId = (N = A.ingressId) !== null && N !== void 0 ? N : "", Be.name = (D = A.name) !== null && D !== void 0 ? D : "", Be.streamKey = (W = A.streamKey) !== null && W !== void 0 ? W : "", Be.url = (ee = A.url) !== null && ee !== void 0 ? ee : "", Be.inputType = (ae = A.inputType) !== null && ae !== void 0 ? ae : 0, Be.audio = A.audio !== void 0 && A.audio !== null ? a.IngressAudioOptions.fromPartial(A.audio) : void 0, Be.video = A.video !== void 0 && A.video !== null ? a.IngressVideoOptions.fromPartial(A.video) : void 0, Be.roomName = (ye = A.roomName) !== null && ye !== void 0 ? ye : "", Be.participantIdentity = (he = A.participantIdentity) !== null && he !== void 0 ? he : "", Be.participantName = (le = A.participantName) !== null && le !== void 0 ? le : "", Be.reusable = (we = A.reusable) !== null && we !== void 0 ? we : !1, Be.state = A.state !== void 0 && A.state !== null ? a.IngressState.fromPartial(A.state) : void 0, Be;
    }
  };
  function q() {
    return { status: 0, error: "", video: void 0, audio: void 0, roomId: "", startedAt: 0, tracks: [] };
  }
  a.IngressState = {
    encode(A, N = l.default.Writer.create()) {
      if (A.status !== void 0 && A.status !== 0 && N.uint32(8).int32(A.status), A.error !== void 0 && A.error !== "" && N.uint32(18).string(A.error), A.video !== void 0 && a.InputVideoState.encode(A.video, N.uint32(26).fork()).ldelim(), A.audio !== void 0 && a.InputAudioState.encode(A.audio, N.uint32(34).fork()).ldelim(), A.roomId !== void 0 && A.roomId !== "" && N.uint32(42).string(A.roomId), A.startedAt !== void 0 && A.startedAt !== 0 && N.uint32(56).int64(A.startedAt), A.tracks !== void 0 && A.tracks.length !== 0)
        for (const D of A.tracks)
          v.TrackInfo.encode(D, N.uint32(50).fork()).ldelim();
      return N;
    },
    decode(A, N) {
      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = q();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.status = D.int32();
            break;
          case 2:
            ee.error = D.string();
            break;
          case 3:
            ee.video = a.InputVideoState.decode(D, D.uint32());
            break;
          case 4:
            ee.audio = a.InputAudioState.decode(D, D.uint32());
            break;
          case 5:
            ee.roomId = D.string();
            break;
          case 7:
            ee.startedAt = oe(D.int64());
            break;
          case 6:
            ee.tracks.push(v.TrackInfo.decode(D, D.uint32()));
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        status: de(A.status) ? k(A.status) : 0,
        error: de(A.error) ? String(A.error) : "",
        video: de(A.video) ? a.InputVideoState.fromJSON(A.video) : void 0,
        audio: de(A.audio) ? a.InputAudioState.fromJSON(A.audio) : void 0,
        roomId: de(A.roomId) ? String(A.roomId) : "",
        startedAt: de(A.startedAt) ? Number(A.startedAt) : 0,
        tracks: Array.isArray(A == null ? void 0 : A.tracks) ? A.tracks.map((N) => v.TrackInfo.fromJSON(N)) : []
      };
    },
    toJSON(A) {
      const N = {};
      return A.status !== void 0 && (N.status = L(A.status)), A.error !== void 0 && (N.error = A.error), A.video !== void 0 && (N.video = A.video ? a.InputVideoState.toJSON(A.video) : void 0), A.audio !== void 0 && (N.audio = A.audio ? a.InputAudioState.toJSON(A.audio) : void 0), A.roomId !== void 0 && (N.roomId = A.roomId), A.startedAt !== void 0 && (N.startedAt = Math.round(A.startedAt)), A.tracks ? N.tracks = A.tracks.map((D) => D ? v.TrackInfo.toJSON(D) : void 0) : N.tracks = [], N;
    },
    fromPartial(A) {
      var N, D, W, ee, ae;
      const ye = q();
      return ye.status = (N = A.status) !== null && N !== void 0 ? N : 0, ye.error = (D = A.error) !== null && D !== void 0 ? D : "", ye.video = A.video !== void 0 && A.video !== null ? a.InputVideoState.fromPartial(A.video) : void 0, ye.audio = A.audio !== void 0 && A.audio !== null ? a.InputAudioState.fromPartial(A.audio) : void 0, ye.roomId = (W = A.roomId) !== null && W !== void 0 ? W : "", ye.startedAt = (ee = A.startedAt) !== null && ee !== void 0 ? ee : 0, ye.tracks = ((ae = A.tracks) === null || ae === void 0 ? void 0 : ae.map((he) => v.TrackInfo.fromPartial(he))) || [], ye;
    }
  };
  function G() {
    return { mimeType: 0, width: 0, height: 0, framerate: 0 };
  }
  a.InputVideoState = {
    encode(A, N = l.default.Writer.create()) {
      return A.mimeType !== void 0 && A.mimeType !== 0 && N.uint32(8).uint32(A.mimeType), A.width !== void 0 && A.width !== 0 && N.uint32(24).uint32(A.width), A.height !== void 0 && A.height !== 0 && N.uint32(32).uint32(A.height), A.framerate !== void 0 && A.framerate !== 0 && N.uint32(40).uint32(A.framerate), N;
    },
    decode(A, N) {
      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = G();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.mimeType = D.uint32();
            break;
          case 3:
            ee.width = D.uint32();
            break;
          case 4:
            ee.height = D.uint32();
            break;
          case 5:
            ee.framerate = D.uint32();
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        mimeType: de(A.mimeType) ? Number(A.mimeType) : 0,
        width: de(A.width) ? Number(A.width) : 0,
        height: de(A.height) ? Number(A.height) : 0,
        framerate: de(A.framerate) ? Number(A.framerate) : 0
      };
    },
    toJSON(A) {
      const N = {};
      return A.mimeType !== void 0 && (N.mimeType = Math.round(A.mimeType)), A.width !== void 0 && (N.width = Math.round(A.width)), A.height !== void 0 && (N.height = Math.round(A.height)), A.framerate !== void 0 && (N.framerate = Math.round(A.framerate)), N;
    },
    fromPartial(A) {
      var N, D, W, ee;
      const ae = G();
      return ae.mimeType = (N = A.mimeType) !== null && N !== void 0 ? N : 0, ae.width = (D = A.width) !== null && D !== void 0 ? D : 0, ae.height = (W = A.height) !== null && W !== void 0 ? W : 0, ae.framerate = (ee = A.framerate) !== null && ee !== void 0 ? ee : 0, ae;
    }
  };
  function H() {
    return { mimeType: 0, channels: 0, sampleRate: 0 };
  }
  a.InputAudioState = {
    encode(A, N = l.default.Writer.create()) {
      return A.mimeType !== void 0 && A.mimeType !== 0 && N.uint32(8).uint32(A.mimeType), A.channels !== void 0 && A.channels !== 0 && N.uint32(24).uint32(A.channels), A.sampleRate !== void 0 && A.sampleRate !== 0 && N.uint32(32).uint32(A.sampleRate), N;
    },
    decode(A, N) {
      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = H();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.mimeType = D.uint32();
            break;
          case 3:
            ee.channels = D.uint32();
            break;
          case 4:
            ee.sampleRate = D.uint32();
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        mimeType: de(A.mimeType) ? Number(A.mimeType) : 0,
        channels: de(A.channels) ? Number(A.channels) : 0,
        sampleRate: de(A.sampleRate) ? Number(A.sampleRate) : 0
      };
    },
    toJSON(A) {
      const N = {};
      return A.mimeType !== void 0 && (N.mimeType = Math.round(A.mimeType)), A.channels !== void 0 && (N.channels = Math.round(A.channels)), A.sampleRate !== void 0 && (N.sampleRate = Math.round(A.sampleRate)), N;
    },
    fromPartial(A) {
      var N, D, W;
      const ee = H();
      return ee.mimeType = (N = A.mimeType) !== null && N !== void 0 ? N : 0, ee.channels = (D = A.channels) !== null && D !== void 0 ? D : 0, ee.sampleRate = (W = A.sampleRate) !== null && W !== void 0 ? W : 0, ee;
    }
  };
  function B() {
    return {
      ingressId: "",
      name: "",
      roomName: "",
      participantIdentity: "",
      participantName: "",
      audio: void 0,
      video: void 0
    };
  }
  a.UpdateIngressRequest = {
    encode(A, N = l.default.Writer.create()) {
      return A.ingressId !== void 0 && A.ingressId !== "" && N.uint32(10).string(A.ingressId), A.name !== void 0 && A.name !== "" && N.uint32(18).string(A.name), A.roomName !== void 0 && A.roomName !== "" && N.uint32(26).string(A.roomName), A.participantIdentity !== void 0 && A.participantIdentity !== "" && N.uint32(34).string(A.participantIdentity), A.participantName !== void 0 && A.participantName !== "" && N.uint32(42).string(A.participantName), A.audio !== void 0 && a.IngressAudioOptions.encode(A.audio, N.uint32(50).fork()).ldelim(), A.video !== void 0 && a.IngressVideoOptions.encode(A.video, N.uint32(58).fork()).ldelim(), N;
    },
    decode(A, N) {
      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = B();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.ingressId = D.string();
            break;
          case 2:
            ee.name = D.string();
            break;
          case 3:
            ee.roomName = D.string();
            break;
          case 4:
            ee.participantIdentity = D.string();
            break;
          case 5:
            ee.participantName = D.string();
            break;
          case 6:
            ee.audio = a.IngressAudioOptions.decode(D, D.uint32());
            break;
          case 7:
            ee.video = a.IngressVideoOptions.decode(D, D.uint32());
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return {
        ingressId: de(A.ingressId) ? String(A.ingressId) : "",
        name: de(A.name) ? String(A.name) : "",
        roomName: de(A.roomName) ? String(A.roomName) : "",
        participantIdentity: de(A.participantIdentity) ? String(A.participantIdentity) : "",
        participantName: de(A.participantName) ? String(A.participantName) : "",
        audio: de(A.audio) ? a.IngressAudioOptions.fromJSON(A.audio) : void 0,
        video: de(A.video) ? a.IngressVideoOptions.fromJSON(A.video) : void 0
      };
    },
    toJSON(A) {
      const N = {};
      return A.ingressId !== void 0 && (N.ingressId = A.ingressId), A.name !== void 0 && (N.name = A.name), A.roomName !== void 0 && (N.roomName = A.roomName), A.participantIdentity !== void 0 && (N.participantIdentity = A.participantIdentity), A.participantName !== void 0 && (N.participantName = A.participantName), A.audio !== void 0 && (N.audio = A.audio ? a.IngressAudioOptions.toJSON(A.audio) : void 0), A.video !== void 0 && (N.video = A.video ? a.IngressVideoOptions.toJSON(A.video) : void 0), N;
    },
    fromPartial(A) {
      var N, D, W, ee, ae;
      const ye = B();
      return ye.ingressId = (N = A.ingressId) !== null && N !== void 0 ? N : "", ye.name = (D = A.name) !== null && D !== void 0 ? D : "", ye.roomName = (W = A.roomName) !== null && W !== void 0 ? W : "", ye.participantIdentity = (ee = A.participantIdentity) !== null && ee !== void 0 ? ee : "", ye.participantName = (ae = A.participantName) !== null && ae !== void 0 ? ae : "", ye.audio = A.audio !== void 0 && A.audio !== null ? a.IngressAudioOptions.fromPartial(A.audio) : void 0, ye.video = A.video !== void 0 && A.video !== null ? a.IngressVideoOptions.fromPartial(A.video) : void 0, ye;
    }
  };
  function Y() {
    return { roomName: "" };
  }
  a.ListIngressRequest = {
    encode(A, N = l.default.Writer.create()) {
      return A.roomName !== void 0 && A.roomName !== "" && N.uint32(10).string(A.roomName), N;
    },
    decode(A, N) {
      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = Y();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.roomName = D.string();
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return { roomName: de(A.roomName) ? String(A.roomName) : "" };
    },
    toJSON(A) {
      const N = {};
      return A.roomName !== void 0 && (N.roomName = A.roomName), N;
    },
    fromPartial(A) {
      var N;
      const D = Y();
      return D.roomName = (N = A.roomName) !== null && N !== void 0 ? N : "", D;
    }
  };
  function ne() {
    return { items: [] };
  }
  a.ListIngressResponse = {
    encode(A, N = l.default.Writer.create()) {
      if (A.items !== void 0 && A.items.length !== 0)
        for (const D of A.items)
          a.IngressInfo.encode(D, N.uint32(10).fork()).ldelim();
      return N;
    },
    decode(A, N) {
      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = ne();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.items.push(a.IngressInfo.decode(D, D.uint32()));
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return { items: Array.isArray(A == null ? void 0 : A.items) ? A.items.map((N) => a.IngressInfo.fromJSON(N)) : [] };
    },
    toJSON(A) {
      const N = {};
      return A.items ? N.items = A.items.map((D) => D ? a.IngressInfo.toJSON(D) : void 0) : N.items = [], N;
    },
    fromPartial(A) {
      var N;
      const D = ne();
      return D.items = ((N = A.items) === null || N === void 0 ? void 0 : N.map((W) => a.IngressInfo.fromPartial(W))) || [], D;
    }
  };
  function Z() {
    return { ingressId: "" };
  }
  a.DeleteIngressRequest = {
    encode(A, N = l.default.Writer.create()) {
      return A.ingressId !== void 0 && A.ingressId !== "" && N.uint32(10).string(A.ingressId), N;
    },
    decode(A, N) {
      const D = A instanceof l.default.Reader ? A : new l.default.Reader(A);
      let W = N === void 0 ? D.len : D.pos + N;
      const ee = Z();
      for (; D.pos < W; ) {
        const ae = D.uint32();
        switch (ae >>> 3) {
          case 1:
            ee.ingressId = D.string();
            break;
          default:
            D.skipType(ae & 7);
            break;
        }
      }
      return ee;
    },
    fromJSON(A) {
      return { ingressId: de(A.ingressId) ? String(A.ingressId) : "" };
    },
    toJSON(A) {
      const N = {};
      return A.ingressId !== void 0 && (N.ingressId = A.ingressId), N;
    },
    fromPartial(A) {
      var N;
      const D = Z();
      return D.ingressId = (N = A.ingressId) !== null && N !== void 0 ? N : "", D;
    }
  };
  var re = (() => {
    if (typeof re < "u")
      return re;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function oe(A) {
    if (A.gt(Number.MAX_SAFE_INTEGER))
      throw new re.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return A.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function de(A) {
    return A != null;
  }
})(livekit_ingress);
var __awaiter$2 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(S) {
    return S instanceof c ? S : new c(function(g) {
      g(S);
    });
  }
  return new (c || (c = Promise))(function(S, g) {
    function E(L) {
      try {
        k(l.next(L));
      } catch (M) {
        g(M);
      }
    }
    function _(L) {
      try {
        k(l.throw(L));
      } catch (M) {
        g(M);
      }
    }
    function k(L) {
      L.done ? S(L.value) : v(L.value).then(E, _);
    }
    k((l = l.apply(a, u || [])).next());
  });
}, __importDefault$3 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(IngressClient$1, "__esModule", { value: !0 });
IngressClient$1.IngressClient = void 0;
const livekit_ingress_1$1 = livekit_ingress, ServiceBase_1$1 = __importDefault$3(ServiceBase$1), TwirpRPC_1$1 = TwirpRPC, svc$1 = "Ingress";
class IngressClient extends ServiceBase_1$1.default {
  /**
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   */
  constructor(u, c, l) {
    super(c, l), this.rpc = new TwirpRPC_1$1.TwirpRpc(u, TwirpRPC_1$1.livekitPackage);
  }
  /**
   * @param inputType protocol for the ingress
   * @param opts CreateIngressOptions
   */
  createIngress(u, c) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let l = "", v = "", S = "", g = "", E, _;
      c !== void 0 && (l = c.name || "", v = c.roomName || "", S = c.participantName || "", g = c.participantIdentity || "", E = c.audioParams, _ = c.videoParams);
      const k = livekit_ingress_1$1.CreateIngressRequest.toJSON({
        inputType: u,
        name: l,
        roomName: v,
        participantIdentity: g,
        participantName: S,
        audio: E,
        video: _
      }), L = yield this.rpc.request(svc$1, "CreateIngress", k, this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(L);
    });
  }
  /**
   * @param ingressId ID of the ingress to update
   * @param opts UpdateIngressOptions
   */
  updateIngress(u, c) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const l = c.name || "", v = c.roomName || "", S = c.participantName || "", g = c.participantIdentity || "", E = c.audioParams, _ = c.videoParams, k = livekit_ingress_1$1.UpdateIngressRequest.toJSON({
        ingressId: u,
        name: l,
        roomName: v,
        participantIdentity: g,
        participantName: S,
        audio: E,
        video: _
      }), L = yield this.rpc.request(svc$1, "UpdateIngress", k, this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(L);
    });
  }
  /**
   * @param roomName list ingress for one room only
   */
  listIngress(u) {
    var c;
    return __awaiter$2(this, void 0, void 0, function* () {
      u ?? (u = "");
      const l = yield this.rpc.request(svc$1, "ListIngress", livekit_ingress_1$1.ListIngressRequest.toJSON({ roomName: u }), this.authHeader({ ingressAdmin: !0 }));
      return (c = livekit_ingress_1$1.ListIngressResponse.fromJSON(l).items) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * @param ingressId ingress to delete
   */
  deleteIngress(u) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc$1, "DeleteIngress", livekit_ingress_1$1.DeleteIngressRequest.toJSON({ ingressId: u }), this.authHeader({ ingressAdmin: !0 }));
      return livekit_ingress_1$1.IngressInfo.fromJSON(c);
    });
  }
}
IngressClient$1.IngressClient = IngressClient;
var RoomServiceClient$1 = {}, livekit_room = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(D) {
    return D && D.__esModule ? D : { default: D };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.UpdateRoomMetadataRequest = a.SendDataResponse = a.SendDataRequest = a.UpdateSubscriptionsResponse = a.UpdateSubscriptionsRequest = a.UpdateParticipantRequest = a.MuteRoomTrackResponse = a.MuteRoomTrackRequest = a.RemoveParticipantResponse = a.RoomParticipantIdentity = a.ListParticipantsResponse = a.ListParticipantsRequest = a.DeleteRoomResponse = a.DeleteRoomRequest = a.ListRoomsResponse = a.ListRoomsRequest = a.RoomEgress = a.CreateRoomRequest = a.protobufPackage = void 0;
  const c = u(minimal), l = livekit_egress, v = livekit_models;
  a.protobufPackage = "livekit";
  function S() {
    return { name: "", emptyTimeout: 0, maxParticipants: 0, nodeId: "", metadata: "", egress: void 0 };
  }
  a.CreateRoomRequest = {
    encode(D, W = c.default.Writer.create()) {
      return D.name !== void 0 && D.name !== "" && W.uint32(10).string(D.name), D.emptyTimeout !== void 0 && D.emptyTimeout !== 0 && W.uint32(16).uint32(D.emptyTimeout), D.maxParticipants !== void 0 && D.maxParticipants !== 0 && W.uint32(24).uint32(D.maxParticipants), D.nodeId !== void 0 && D.nodeId !== "" && W.uint32(34).string(D.nodeId), D.metadata !== void 0 && D.metadata !== "" && W.uint32(42).string(D.metadata), D.egress !== void 0 && a.RoomEgress.encode(D.egress, W.uint32(50).fork()).ldelim(), W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = S();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.name = ee.string();
            break;
          case 2:
            ye.emptyTimeout = ee.uint32();
            break;
          case 3:
            ye.maxParticipants = ee.uint32();
            break;
          case 4:
            ye.nodeId = ee.string();
            break;
          case 5:
            ye.metadata = ee.string();
            break;
          case 6:
            ye.egress = a.RoomEgress.decode(ee, ee.uint32());
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return {
        name: N(D.name) ? String(D.name) : "",
        emptyTimeout: N(D.emptyTimeout) ? Number(D.emptyTimeout) : 0,
        maxParticipants: N(D.maxParticipants) ? Number(D.maxParticipants) : 0,
        nodeId: N(D.nodeId) ? String(D.nodeId) : "",
        metadata: N(D.metadata) ? String(D.metadata) : "",
        egress: N(D.egress) ? a.RoomEgress.fromJSON(D.egress) : void 0
      };
    },
    toJSON(D) {
      const W = {};
      return D.name !== void 0 && (W.name = D.name), D.emptyTimeout !== void 0 && (W.emptyTimeout = Math.round(D.emptyTimeout)), D.maxParticipants !== void 0 && (W.maxParticipants = Math.round(D.maxParticipants)), D.nodeId !== void 0 && (W.nodeId = D.nodeId), D.metadata !== void 0 && (W.metadata = D.metadata), D.egress !== void 0 && (W.egress = D.egress ? a.RoomEgress.toJSON(D.egress) : void 0), W;
    },
    fromPartial(D) {
      var W, ee, ae, ye, he;
      const le = S();
      return le.name = (W = D.name) !== null && W !== void 0 ? W : "", le.emptyTimeout = (ee = D.emptyTimeout) !== null && ee !== void 0 ? ee : 0, le.maxParticipants = (ae = D.maxParticipants) !== null && ae !== void 0 ? ae : 0, le.nodeId = (ye = D.nodeId) !== null && ye !== void 0 ? ye : "", le.metadata = (he = D.metadata) !== null && he !== void 0 ? he : "", le.egress = D.egress !== void 0 && D.egress !== null ? a.RoomEgress.fromPartial(D.egress) : void 0, le;
    }
  };
  function g() {
    return { room: void 0, tracks: void 0 };
  }
  a.RoomEgress = {
    encode(D, W = c.default.Writer.create()) {
      return D.room !== void 0 && l.RoomCompositeEgressRequest.encode(D.room, W.uint32(10).fork()).ldelim(), D.tracks !== void 0 && l.AutoTrackEgress.encode(D.tracks, W.uint32(18).fork()).ldelim(), W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = g();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.room = l.RoomCompositeEgressRequest.decode(ee, ee.uint32());
            break;
          case 2:
            ye.tracks = l.AutoTrackEgress.decode(ee, ee.uint32());
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return {
        room: N(D.room) ? l.RoomCompositeEgressRequest.fromJSON(D.room) : void 0,
        tracks: N(D.tracks) ? l.AutoTrackEgress.fromJSON(D.tracks) : void 0
      };
    },
    toJSON(D) {
      const W = {};
      return D.room !== void 0 && (W.room = D.room ? l.RoomCompositeEgressRequest.toJSON(D.room) : void 0), D.tracks !== void 0 && (W.tracks = D.tracks ? l.AutoTrackEgress.toJSON(D.tracks) : void 0), W;
    },
    fromPartial(D) {
      const W = g();
      return W.room = D.room !== void 0 && D.room !== null ? l.RoomCompositeEgressRequest.fromPartial(D.room) : void 0, W.tracks = D.tracks !== void 0 && D.tracks !== null ? l.AutoTrackEgress.fromPartial(D.tracks) : void 0, W;
    }
  };
  function E() {
    return { names: [] };
  }
  a.ListRoomsRequest = {
    encode(D, W = c.default.Writer.create()) {
      if (D.names !== void 0 && D.names.length !== 0)
        for (const ee of D.names)
          W.uint32(10).string(ee);
      return W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = E();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.names.push(ee.string());
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return { names: Array.isArray(D == null ? void 0 : D.names) ? D.names.map((W) => String(W)) : [] };
    },
    toJSON(D) {
      const W = {};
      return D.names ? W.names = D.names.map((ee) => ee) : W.names = [], W;
    },
    fromPartial(D) {
      var W;
      const ee = E();
      return ee.names = ((W = D.names) === null || W === void 0 ? void 0 : W.map((ae) => ae)) || [], ee;
    }
  };
  function _() {
    return { rooms: [] };
  }
  a.ListRoomsResponse = {
    encode(D, W = c.default.Writer.create()) {
      if (D.rooms !== void 0 && D.rooms.length !== 0)
        for (const ee of D.rooms)
          v.Room.encode(ee, W.uint32(10).fork()).ldelim();
      return W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = _();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.rooms.push(v.Room.decode(ee, ee.uint32()));
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return { rooms: Array.isArray(D == null ? void 0 : D.rooms) ? D.rooms.map((W) => v.Room.fromJSON(W)) : [] };
    },
    toJSON(D) {
      const W = {};
      return D.rooms ? W.rooms = D.rooms.map((ee) => ee ? v.Room.toJSON(ee) : void 0) : W.rooms = [], W;
    },
    fromPartial(D) {
      var W;
      const ee = _();
      return ee.rooms = ((W = D.rooms) === null || W === void 0 ? void 0 : W.map((ae) => v.Room.fromPartial(ae))) || [], ee;
    }
  };
  function k() {
    return { room: "" };
  }
  a.DeleteRoomRequest = {
    encode(D, W = c.default.Writer.create()) {
      return D.room !== void 0 && D.room !== "" && W.uint32(10).string(D.room), W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = k();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.room = ee.string();
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return { room: N(D.room) ? String(D.room) : "" };
    },
    toJSON(D) {
      const W = {};
      return D.room !== void 0 && (W.room = D.room), W;
    },
    fromPartial(D) {
      var W;
      const ee = k();
      return ee.room = (W = D.room) !== null && W !== void 0 ? W : "", ee;
    }
  };
  function L() {
    return {};
  }
  a.DeleteRoomResponse = {
    encode(D, W = c.default.Writer.create()) {
      return W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = L();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return {};
    },
    toJSON(D) {
      return {};
    },
    fromPartial(D) {
      return L();
    }
  };
  function M() {
    return { room: "" };
  }
  a.ListParticipantsRequest = {
    encode(D, W = c.default.Writer.create()) {
      return D.room !== void 0 && D.room !== "" && W.uint32(10).string(D.room), W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = M();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.room = ee.string();
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return { room: N(D.room) ? String(D.room) : "" };
    },
    toJSON(D) {
      const W = {};
      return D.room !== void 0 && (W.room = D.room), W;
    },
    fromPartial(D) {
      var W;
      const ee = M();
      return ee.room = (W = D.room) !== null && W !== void 0 ? W : "", ee;
    }
  };
  function $() {
    return { participants: [] };
  }
  a.ListParticipantsResponse = {
    encode(D, W = c.default.Writer.create()) {
      if (D.participants !== void 0 && D.participants.length !== 0)
        for (const ee of D.participants)
          v.ParticipantInfo.encode(ee, W.uint32(10).fork()).ldelim();
      return W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = $();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.participants.push(v.ParticipantInfo.decode(ee, ee.uint32()));
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return {
        participants: Array.isArray(D == null ? void 0 : D.participants) ? D.participants.map((W) => v.ParticipantInfo.fromJSON(W)) : []
      };
    },
    toJSON(D) {
      const W = {};
      return D.participants ? W.participants = D.participants.map((ee) => ee ? v.ParticipantInfo.toJSON(ee) : void 0) : W.participants = [], W;
    },
    fromPartial(D) {
      var W;
      const ee = $();
      return ee.participants = ((W = D.participants) === null || W === void 0 ? void 0 : W.map((ae) => v.ParticipantInfo.fromPartial(ae))) || [], ee;
    }
  };
  function J() {
    return { room: "", identity: "" };
  }
  a.RoomParticipantIdentity = {
    encode(D, W = c.default.Writer.create()) {
      return D.room !== void 0 && D.room !== "" && W.uint32(10).string(D.room), D.identity !== void 0 && D.identity !== "" && W.uint32(18).string(D.identity), W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = J();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.room = ee.string();
            break;
          case 2:
            ye.identity = ee.string();
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return {
        room: N(D.room) ? String(D.room) : "",
        identity: N(D.identity) ? String(D.identity) : ""
      };
    },
    toJSON(D) {
      const W = {};
      return D.room !== void 0 && (W.room = D.room), D.identity !== void 0 && (W.identity = D.identity), W;
    },
    fromPartial(D) {
      var W, ee;
      const ae = J();
      return ae.room = (W = D.room) !== null && W !== void 0 ? W : "", ae.identity = (ee = D.identity) !== null && ee !== void 0 ? ee : "", ae;
    }
  };
  function V() {
    return {};
  }
  a.RemoveParticipantResponse = {
    encode(D, W = c.default.Writer.create()) {
      return W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = V();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return {};
    },
    toJSON(D) {
      return {};
    },
    fromPartial(D) {
      return V();
    }
  };
  function q() {
    return { room: "", identity: "", trackSid: "", muted: !1 };
  }
  a.MuteRoomTrackRequest = {
    encode(D, W = c.default.Writer.create()) {
      return D.room !== void 0 && D.room !== "" && W.uint32(10).string(D.room), D.identity !== void 0 && D.identity !== "" && W.uint32(18).string(D.identity), D.trackSid !== void 0 && D.trackSid !== "" && W.uint32(26).string(D.trackSid), D.muted === !0 && W.uint32(32).bool(D.muted), W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = q();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.room = ee.string();
            break;
          case 2:
            ye.identity = ee.string();
            break;
          case 3:
            ye.trackSid = ee.string();
            break;
          case 4:
            ye.muted = ee.bool();
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return {
        room: N(D.room) ? String(D.room) : "",
        identity: N(D.identity) ? String(D.identity) : "",
        trackSid: N(D.trackSid) ? String(D.trackSid) : "",
        muted: N(D.muted) ? !!D.muted : !1
      };
    },
    toJSON(D) {
      const W = {};
      return D.room !== void 0 && (W.room = D.room), D.identity !== void 0 && (W.identity = D.identity), D.trackSid !== void 0 && (W.trackSid = D.trackSid), D.muted !== void 0 && (W.muted = D.muted), W;
    },
    fromPartial(D) {
      var W, ee, ae, ye;
      const he = q();
      return he.room = (W = D.room) !== null && W !== void 0 ? W : "", he.identity = (ee = D.identity) !== null && ee !== void 0 ? ee : "", he.trackSid = (ae = D.trackSid) !== null && ae !== void 0 ? ae : "", he.muted = (ye = D.muted) !== null && ye !== void 0 ? ye : !1, he;
    }
  };
  function G() {
    return { track: void 0 };
  }
  a.MuteRoomTrackResponse = {
    encode(D, W = c.default.Writer.create()) {
      return D.track !== void 0 && v.TrackInfo.encode(D.track, W.uint32(10).fork()).ldelim(), W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = G();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.track = v.TrackInfo.decode(ee, ee.uint32());
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return { track: N(D.track) ? v.TrackInfo.fromJSON(D.track) : void 0 };
    },
    toJSON(D) {
      const W = {};
      return D.track !== void 0 && (W.track = D.track ? v.TrackInfo.toJSON(D.track) : void 0), W;
    },
    fromPartial(D) {
      const W = G();
      return W.track = D.track !== void 0 && D.track !== null ? v.TrackInfo.fromPartial(D.track) : void 0, W;
    }
  };
  function H() {
    return { room: "", identity: "", metadata: "", permission: void 0, name: "" };
  }
  a.UpdateParticipantRequest = {
    encode(D, W = c.default.Writer.create()) {
      return D.room !== void 0 && D.room !== "" && W.uint32(10).string(D.room), D.identity !== void 0 && D.identity !== "" && W.uint32(18).string(D.identity), D.metadata !== void 0 && D.metadata !== "" && W.uint32(26).string(D.metadata), D.permission !== void 0 && v.ParticipantPermission.encode(D.permission, W.uint32(34).fork()).ldelim(), D.name !== void 0 && D.name !== "" && W.uint32(42).string(D.name), W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = H();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.room = ee.string();
            break;
          case 2:
            ye.identity = ee.string();
            break;
          case 3:
            ye.metadata = ee.string();
            break;
          case 4:
            ye.permission = v.ParticipantPermission.decode(ee, ee.uint32());
            break;
          case 5:
            ye.name = ee.string();
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return {
        room: N(D.room) ? String(D.room) : "",
        identity: N(D.identity) ? String(D.identity) : "",
        metadata: N(D.metadata) ? String(D.metadata) : "",
        permission: N(D.permission) ? v.ParticipantPermission.fromJSON(D.permission) : void 0,
        name: N(D.name) ? String(D.name) : ""
      };
    },
    toJSON(D) {
      const W = {};
      return D.room !== void 0 && (W.room = D.room), D.identity !== void 0 && (W.identity = D.identity), D.metadata !== void 0 && (W.metadata = D.metadata), D.permission !== void 0 && (W.permission = D.permission ? v.ParticipantPermission.toJSON(D.permission) : void 0), D.name !== void 0 && (W.name = D.name), W;
    },
    fromPartial(D) {
      var W, ee, ae, ye;
      const he = H();
      return he.room = (W = D.room) !== null && W !== void 0 ? W : "", he.identity = (ee = D.identity) !== null && ee !== void 0 ? ee : "", he.metadata = (ae = D.metadata) !== null && ae !== void 0 ? ae : "", he.permission = D.permission !== void 0 && D.permission !== null ? v.ParticipantPermission.fromPartial(D.permission) : void 0, he.name = (ye = D.name) !== null && ye !== void 0 ? ye : "", he;
    }
  };
  function B() {
    return { room: "", identity: "", trackSids: [], subscribe: !1, participantTracks: [] };
  }
  a.UpdateSubscriptionsRequest = {
    encode(D, W = c.default.Writer.create()) {
      if (D.room !== void 0 && D.room !== "" && W.uint32(10).string(D.room), D.identity !== void 0 && D.identity !== "" && W.uint32(18).string(D.identity), D.trackSids !== void 0 && D.trackSids.length !== 0)
        for (const ee of D.trackSids)
          W.uint32(26).string(ee);
      if (D.subscribe === !0 && W.uint32(32).bool(D.subscribe), D.participantTracks !== void 0 && D.participantTracks.length !== 0)
        for (const ee of D.participantTracks)
          v.ParticipantTracks.encode(ee, W.uint32(42).fork()).ldelim();
      return W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = B();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.room = ee.string();
            break;
          case 2:
            ye.identity = ee.string();
            break;
          case 3:
            ye.trackSids.push(ee.string());
            break;
          case 4:
            ye.subscribe = ee.bool();
            break;
          case 5:
            ye.participantTracks.push(v.ParticipantTracks.decode(ee, ee.uint32()));
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return {
        room: N(D.room) ? String(D.room) : "",
        identity: N(D.identity) ? String(D.identity) : "",
        trackSids: Array.isArray(D == null ? void 0 : D.trackSids) ? D.trackSids.map((W) => String(W)) : [],
        subscribe: N(D.subscribe) ? !!D.subscribe : !1,
        participantTracks: Array.isArray(D == null ? void 0 : D.participantTracks) ? D.participantTracks.map((W) => v.ParticipantTracks.fromJSON(W)) : []
      };
    },
    toJSON(D) {
      const W = {};
      return D.room !== void 0 && (W.room = D.room), D.identity !== void 0 && (W.identity = D.identity), D.trackSids ? W.trackSids = D.trackSids.map((ee) => ee) : W.trackSids = [], D.subscribe !== void 0 && (W.subscribe = D.subscribe), D.participantTracks ? W.participantTracks = D.participantTracks.map((ee) => ee ? v.ParticipantTracks.toJSON(ee) : void 0) : W.participantTracks = [], W;
    },
    fromPartial(D) {
      var W, ee, ae, ye, he;
      const le = B();
      return le.room = (W = D.room) !== null && W !== void 0 ? W : "", le.identity = (ee = D.identity) !== null && ee !== void 0 ? ee : "", le.trackSids = ((ae = D.trackSids) === null || ae === void 0 ? void 0 : ae.map((we) => we)) || [], le.subscribe = (ye = D.subscribe) !== null && ye !== void 0 ? ye : !1, le.participantTracks = ((he = D.participantTracks) === null || he === void 0 ? void 0 : he.map((we) => v.ParticipantTracks.fromPartial(we))) || [], le;
    }
  };
  function Y() {
    return {};
  }
  a.UpdateSubscriptionsResponse = {
    encode(D, W = c.default.Writer.create()) {
      return W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = Y();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return {};
    },
    toJSON(D) {
      return {};
    },
    fromPartial(D) {
      return Y();
    }
  };
  function ne() {
    return { room: "", data: new Uint8Array(), kind: 0, destinationSids: [] };
  }
  a.SendDataRequest = {
    encode(D, W = c.default.Writer.create()) {
      if (D.room !== void 0 && D.room !== "" && W.uint32(10).string(D.room), D.data !== void 0 && D.data.length !== 0 && W.uint32(18).bytes(D.data), D.kind !== void 0 && D.kind !== 0 && W.uint32(24).int32(D.kind), D.destinationSids !== void 0 && D.destinationSids.length !== 0)
        for (const ee of D.destinationSids)
          W.uint32(34).string(ee);
      return W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = ne();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.room = ee.string();
            break;
          case 2:
            ye.data = ee.bytes();
            break;
          case 3:
            ye.kind = ee.int32();
            break;
          case 4:
            ye.destinationSids.push(ee.string());
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return {
        room: N(D.room) ? String(D.room) : "",
        data: N(D.data) ? de(D.data) : new Uint8Array(),
        kind: N(D.kind) ? v.dataPacket_KindFromJSON(D.kind) : 0,
        destinationSids: Array.isArray(D == null ? void 0 : D.destinationSids) ? D.destinationSids.map((W) => String(W)) : []
      };
    },
    toJSON(D) {
      const W = {};
      return D.room !== void 0 && (W.room = D.room), D.data !== void 0 && (W.data = A(D.data !== void 0 ? D.data : new Uint8Array())), D.kind !== void 0 && (W.kind = v.dataPacket_KindToJSON(D.kind)), D.destinationSids ? W.destinationSids = D.destinationSids.map((ee) => ee) : W.destinationSids = [], W;
    },
    fromPartial(D) {
      var W, ee, ae, ye;
      const he = ne();
      return he.room = (W = D.room) !== null && W !== void 0 ? W : "", he.data = (ee = D.data) !== null && ee !== void 0 ? ee : new Uint8Array(), he.kind = (ae = D.kind) !== null && ae !== void 0 ? ae : 0, he.destinationSids = ((ye = D.destinationSids) === null || ye === void 0 ? void 0 : ye.map((le) => le)) || [], he;
    }
  };
  function Z() {
    return {};
  }
  a.SendDataResponse = {
    encode(D, W = c.default.Writer.create()) {
      return W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = Z();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return {};
    },
    toJSON(D) {
      return {};
    },
    fromPartial(D) {
      return Z();
    }
  };
  function re() {
    return { room: "", metadata: "" };
  }
  a.UpdateRoomMetadataRequest = {
    encode(D, W = c.default.Writer.create()) {
      return D.room !== void 0 && D.room !== "" && W.uint32(10).string(D.room), D.metadata !== void 0 && D.metadata !== "" && W.uint32(18).string(D.metadata), W;
    },
    decode(D, W) {
      const ee = D instanceof c.default.Reader ? D : new c.default.Reader(D);
      let ae = W === void 0 ? ee.len : ee.pos + W;
      const ye = re();
      for (; ee.pos < ae; ) {
        const he = ee.uint32();
        switch (he >>> 3) {
          case 1:
            ye.room = ee.string();
            break;
          case 2:
            ye.metadata = ee.string();
            break;
          default:
            ee.skipType(he & 7);
            break;
        }
      }
      return ye;
    },
    fromJSON(D) {
      return {
        room: N(D.room) ? String(D.room) : "",
        metadata: N(D.metadata) ? String(D.metadata) : ""
      };
    },
    toJSON(D) {
      const W = {};
      return D.room !== void 0 && (W.room = D.room), D.metadata !== void 0 && (W.metadata = D.metadata), W;
    },
    fromPartial(D) {
      var W, ee;
      const ae = re();
      return ae.room = (W = D.room) !== null && W !== void 0 ? W : "", ae.metadata = (ee = D.metadata) !== null && ee !== void 0 ? ee : "", ae;
    }
  };
  var oe = (() => {
    if (typeof oe < "u")
      return oe;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function de(D) {
    if (oe.Buffer)
      return Uint8Array.from(oe.Buffer.from(D, "base64"));
    {
      const W = oe.atob(D), ee = new Uint8Array(W.length);
      for (let ae = 0; ae < W.length; ++ae)
        ee[ae] = W.charCodeAt(ae);
      return ee;
    }
  }
  function A(D) {
    if (oe.Buffer)
      return oe.Buffer.from(D).toString("base64");
    {
      const W = [];
      return D.forEach((ee) => {
        W.push(String.fromCharCode(ee));
      }), oe.btoa(W.join(""));
    }
  }
  function N(D) {
    return D != null;
  }
})(livekit_room);
var __awaiter$1 = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(a, u, c, l) {
  function v(S) {
    return S instanceof c ? S : new c(function(g) {
      g(S);
    });
  }
  return new (c || (c = Promise))(function(S, g) {
    function E(L) {
      try {
        k(l.next(L));
      } catch (M) {
        g(M);
      }
    }
    function _(L) {
      try {
        k(l.throw(L));
      } catch (M) {
        g(M);
      }
    }
    function k(L) {
      L.done ? S(L.value) : v(L.value).then(E, _);
    }
    k((l = l.apply(a, u || [])).next());
  });
}, __importDefault$2 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(RoomServiceClient$1, "__esModule", { value: !0 });
RoomServiceClient$1.RoomServiceClient = void 0;
const livekit_models_1$1 = livekit_models, livekit_room_1 = livekit_room, ServiceBase_1 = __importDefault$2(ServiceBase$1), TwirpRPC_1 = TwirpRPC, svc = "RoomService";
class RoomServiceClient extends ServiceBase_1.default {
  /**
   *
   * @param host hostname including protocol. i.e. 'https://cluster.livekit.io'
   * @param apiKey API Key, can be set in env var LIVEKIT_API_KEY
   * @param secret API Secret, can be set in env var LIVEKIT_API_SECRET
   * @param jwt JWT Token, a pregenerated JWT token for authentication.
   * @param hostHeader A host header to send with the request.
   *
   */
  constructor(u, c, l, v, S) {
    super(c, l), this.jwt = v, this.rpc = new TwirpRPC_1.TwirpRpc(u, TwirpRPC_1.livekitPackage, void 0, S);
  }
  /**
   * Creates a new room. Explicit room creation is not required, since rooms will
   * be automatically created when the first participant joins. This method can be
   * used to customize room settings.
   * @param options
   */
  createRoom(u) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const c = yield this.rpc.request(svc, "CreateRoom", livekit_room_1.CreateRoomRequest.toJSON(livekit_room_1.CreateRoomRequest.fromPartial(u)), this.authHeader({ roomCreate: !0 }));
      return livekit_models_1$1.Room.fromJSON(c);
    });
  }
  /**
   * List active rooms
   * @param names when undefined or empty, list all rooms.
   *              otherwise returns rooms with matching names
   * @returns
   */
  listRooms(u) {
    var c;
    return __awaiter$1(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "ListRooms", livekit_room_1.ListRoomsRequest.toJSON({ names: u ?? [] }), this.authHeader({ roomList: !0 }));
      return (c = livekit_room_1.ListRoomsResponse.fromJSON(l).rooms) !== null && c !== void 0 ? c : [];
    });
  }
  deleteRoom(u) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "DeleteRoom", livekit_room_1.DeleteRoomRequest.toJSON({ room: u }), this.authHeader({ roomCreate: !0 }));
    });
  }
  /**
   * Update metadata of a room
   * @param room name of the room
   * @param metadata the new metadata for the room
   */
  updateRoomMetadata(u, c) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "UpdateRoomMetadata", livekit_room_1.UpdateRoomMetadataRequest.toJSON({ room: u, metadata: c }), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.Room.fromJSON(l);
    });
  }
  /**
   * List participants in a room
   * @param room name of the room
   */
  listParticipants(u) {
    var c;
    return __awaiter$1(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "ListParticipants", livekit_room_1.ListParticipantsRequest.toJSON({ room: u }), this.authHeader({ roomAdmin: !0, room: u }));
      return (c = livekit_room_1.ListParticipantsResponse.fromJSON(l).participants) !== null && c !== void 0 ? c : [];
    });
  }
  /**
   * Get information on a specific participant, including the tracks that participant
   * has published
   * @param room name of the room
   * @param identity identity of the participant to return
   */
  getParticipant(u, c) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const l = yield this.rpc.request(svc, "GetParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room: u, identity: c }), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.ParticipantInfo.fromJSON(l);
    });
  }
  /**
   * Removes a participant in the room. This will disconnect the participant
   * and will emit a Disconnected event for that participant.
   * Even after being removed, the participant can still re-join the room.
   * @param room
   * @param identity
   */
  removeParticipant(u, c) {
    return __awaiter$1(this, void 0, void 0, function* () {
      yield this.rpc.request(svc, "RemoveParticipant", livekit_room_1.RoomParticipantIdentity.toJSON({ room: u, identity: c }), this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  /**
   * Mutes a track that the participant has published.
   * @param room
   * @param identity
   * @param trackSid sid of the track to be muted
   * @param muted true to mute, false to unmute
   */
  mutePublishedTrack(u, c, l, v) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const S = livekit_room_1.MuteRoomTrackRequest.toJSON({
        room: u,
        identity: c,
        trackSid: l,
        muted: v
      }), g = yield this.rpc.request(svc, "MutePublishedTrack", S, this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_room_1.MuteRoomTrackResponse.fromJSON(g).track;
    });
  }
  /**
   * Updates a participant's metadata or permissions
   * @param room
   * @param identity
   * @param metadata optional, metadata to update
   * @param permission optional, new permissions to assign to participant
   * @param name optional, new name for participant
   */
  updateParticipant(u, c, l, v, S) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const g = {
        room: u,
        identity: c,
        metadata: l || "",
        permission: v,
        name: S || ""
      }, E = yield this.rpc.request(svc, "UpdateParticipant", livekit_room_1.UpdateParticipantRequest.toJSON(g), this.authHeader({ roomAdmin: !0, room: u }));
      return livekit_models_1$1.ParticipantInfo.fromJSON(E);
    });
  }
  /**
   * Updates a participant's subscription to tracks
   * @param room
   * @param identity
   * @param trackSids
   * @param subscribe true to subscribe, false to unsubscribe
   */
  updateSubscriptions(u, c, l, v) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const S = livekit_room_1.UpdateSubscriptionsRequest.toJSON({
        room: u,
        identity: c,
        trackSids: l,
        subscribe: v,
        participantTracks: []
      });
      yield this.rpc.request(svc, "UpdateSubscriptions", S, this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  /**
   * Sends data message to participants in the room
   * @param room
   * @param data opaque payload to send
   * @param kind delivery reliability
   * @param destinationSids optional. when empty, message is sent to everyone
   */
  sendData(u, c, l, v = []) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const S = livekit_room_1.SendDataRequest.toJSON({
        room: u,
        data: c,
        kind: l,
        destinationSids: v
      });
      yield this.rpc.request(svc, "SendData", S, this.authHeader({ roomAdmin: !0, room: u }));
    });
  }
  authHeader(u) {
    return this.jwt ? { Authorization: `Bearer ${this.jwt}` } : super.authHeader(u);
  }
}
RoomServiceClient$1.RoomServiceClient = RoomServiceClient;
var WebhookReceiver$1 = {}, livekit_webhook = {}, __importDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(livekit_webhook, "__esModule", { value: !0 });
livekit_webhook.WebhookEvent = livekit_webhook.protobufPackage = void 0;
const long_1 = __importDefault$1(umdExports), minimal_1 = __importDefault$1(minimal), livekit_egress_1 = livekit_egress, livekit_ingress_1 = livekit_ingress, livekit_models_1 = livekit_models;
livekit_webhook.protobufPackage = "livekit";
function createBaseWebhookEvent() {
  return {
    event: "",
    room: void 0,
    participant: void 0,
    egressInfo: void 0,
    ingressInfo: void 0,
    track: void 0,
    id: "",
    createdAt: 0
  };
}
livekit_webhook.WebhookEvent = {
  encode(a, u = minimal_1.default.Writer.create()) {
    return a.event !== void 0 && a.event !== "" && u.uint32(10).string(a.event), a.room !== void 0 && livekit_models_1.Room.encode(a.room, u.uint32(18).fork()).ldelim(), a.participant !== void 0 && livekit_models_1.ParticipantInfo.encode(a.participant, u.uint32(26).fork()).ldelim(), a.egressInfo !== void 0 && livekit_egress_1.EgressInfo.encode(a.egressInfo, u.uint32(74).fork()).ldelim(), a.ingressInfo !== void 0 && livekit_ingress_1.IngressInfo.encode(a.ingressInfo, u.uint32(82).fork()).ldelim(), a.track !== void 0 && livekit_models_1.TrackInfo.encode(a.track, u.uint32(66).fork()).ldelim(), a.id !== void 0 && a.id !== "" && u.uint32(50).string(a.id), a.createdAt !== void 0 && a.createdAt !== 0 && u.uint32(56).int64(a.createdAt), u;
  },
  decode(a, u) {
    const c = a instanceof minimal_1.default.Reader ? a : new minimal_1.default.Reader(a);
    let l = u === void 0 ? c.len : c.pos + u;
    const v = createBaseWebhookEvent();
    for (; c.pos < l; ) {
      const S = c.uint32();
      switch (S >>> 3) {
        case 1:
          v.event = c.string();
          break;
        case 2:
          v.room = livekit_models_1.Room.decode(c, c.uint32());
          break;
        case 3:
          v.participant = livekit_models_1.ParticipantInfo.decode(c, c.uint32());
          break;
        case 9:
          v.egressInfo = livekit_egress_1.EgressInfo.decode(c, c.uint32());
          break;
        case 10:
          v.ingressInfo = livekit_ingress_1.IngressInfo.decode(c, c.uint32());
          break;
        case 8:
          v.track = livekit_models_1.TrackInfo.decode(c, c.uint32());
          break;
        case 6:
          v.id = c.string();
          break;
        case 7:
          v.createdAt = longToNumber(c.int64());
          break;
        default:
          c.skipType(S & 7);
          break;
      }
    }
    return v;
  },
  fromJSON(a) {
    return {
      event: isSet(a.event) ? String(a.event) : "",
      room: isSet(a.room) ? livekit_models_1.Room.fromJSON(a.room) : void 0,
      participant: isSet(a.participant) ? livekit_models_1.ParticipantInfo.fromJSON(a.participant) : void 0,
      egressInfo: isSet(a.egressInfo) ? livekit_egress_1.EgressInfo.fromJSON(a.egressInfo) : void 0,
      ingressInfo: isSet(a.ingressInfo) ? livekit_ingress_1.IngressInfo.fromJSON(a.ingressInfo) : void 0,
      track: isSet(a.track) ? livekit_models_1.TrackInfo.fromJSON(a.track) : void 0,
      id: isSet(a.id) ? String(a.id) : "",
      createdAt: isSet(a.createdAt) ? Number(a.createdAt) : 0
    };
  },
  toJSON(a) {
    const u = {};
    return a.event !== void 0 && (u.event = a.event), a.room !== void 0 && (u.room = a.room ? livekit_models_1.Room.toJSON(a.room) : void 0), a.participant !== void 0 && (u.participant = a.participant ? livekit_models_1.ParticipantInfo.toJSON(a.participant) : void 0), a.egressInfo !== void 0 && (u.egressInfo = a.egressInfo ? livekit_egress_1.EgressInfo.toJSON(a.egressInfo) : void 0), a.ingressInfo !== void 0 && (u.ingressInfo = a.ingressInfo ? livekit_ingress_1.IngressInfo.toJSON(a.ingressInfo) : void 0), a.track !== void 0 && (u.track = a.track ? livekit_models_1.TrackInfo.toJSON(a.track) : void 0), a.id !== void 0 && (u.id = a.id), a.createdAt !== void 0 && (u.createdAt = Math.round(a.createdAt)), u;
  },
  fromPartial(a) {
    var u, c, l;
    const v = createBaseWebhookEvent();
    return v.event = (u = a.event) !== null && u !== void 0 ? u : "", v.room = a.room !== void 0 && a.room !== null ? livekit_models_1.Room.fromPartial(a.room) : void 0, v.participant = a.participant !== void 0 && a.participant !== null ? livekit_models_1.ParticipantInfo.fromPartial(a.participant) : void 0, v.egressInfo = a.egressInfo !== void 0 && a.egressInfo !== null ? livekit_egress_1.EgressInfo.fromPartial(a.egressInfo) : void 0, v.ingressInfo = a.ingressInfo !== void 0 && a.ingressInfo !== null ? livekit_ingress_1.IngressInfo.fromPartial(a.ingressInfo) : void 0, v.track = a.track !== void 0 && a.track !== null ? livekit_models_1.TrackInfo.fromPartial(a.track) : void 0, v.id = (c = a.id) !== null && c !== void 0 ? c : "", v.createdAt = (l = a.createdAt) !== null && l !== void 0 ? l : 0, v;
  }
};
var globalThis$1 = (() => {
  if (typeof globalThis$1 < "u")
    return globalThis$1;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof commonjsGlobal$1 < "u")
    return commonjsGlobal$1;
  throw "Unable to locate global object";
})();
function longToNumber(a) {
  if (a.gt(Number.MAX_SAFE_INTEGER))
    throw new globalThis$1.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  return a.toNumber();
}
minimal_1.default.util.Long !== long_1.default && (minimal_1.default.util.Long = long_1.default, minimal_1.default.configure());
function isSet(a) {
  return a != null;
}
var __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(a) {
  return a && a.__esModule ? a : { default: a };
};
Object.defineProperty(WebhookReceiver$1, "__esModule", { value: !0 });
WebhookReceiver$1.WebhookReceiver = WebhookReceiver$1.authorizeHeader = void 0;
const crypto_1 = __importDefault(require$$0$1), AccessToken_1 = AccessToken$1, livekit_webhook_1 = livekit_webhook;
WebhookReceiver$1.authorizeHeader = "Authorize";
class WebhookReceiver {
  constructor(u, c) {
    this.verifier = new AccessToken_1.TokenVerifier(u, c);
  }
  /**
   *
   * @param body string of the posted body
   * @param authHeader `Authorization` header from the request
   * @param skipAuth true to skip auth validation
   * @returns
   */
  receive(u, c, l = !1) {
    if (!l) {
      if (!c)
        throw new Error("authorization header is empty");
      const v = this.verifier.verify(c), S = crypto_1.default.createHash("sha256");
      if (S.update(u), v.sha256 !== S.digest("base64"))
        throw new Error("sha256 checksum of body does not match");
    }
    return livekit_webhook_1.WebhookEvent.fromJSON(JSON.parse(u));
  }
}
WebhookReceiver$1.WebhookReceiver = WebhookReceiver;
var livekit_internal = {}, livekit_rtc = {};
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(C) {
    return C && C.__esModule ? C : { default: C };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.SimulateScenario = a.DataChannelInfo = a.SyncState = a.SubscriptionPermissionUpdate = a.SubscriptionPermission = a.TrackPermission = a.SubscribedQualityUpdate = a.SubscribedCodec = a.SubscribedQuality = a.StreamStateUpdate = a.StreamStateInfo = a.ConnectionQualityUpdate = a.ConnectionQualityInfo = a.RoomUpdate = a.SpeakersChanged = a.ICEServer = a.UpdateVideoLayers = a.LeaveRequest = a.UpdateTrackSettings = a.UpdateSubscription = a.ParticipantUpdate = a.SessionDescription = a.TrackUnpublishedResponse = a.TrackPublishedResponse = a.JoinResponse = a.MuteTrackRequest = a.TrickleRequest = a.AddTrackRequest = a.SimulcastCodec = a.SignalResponse = a.SignalRequest = a.candidateProtocolToJSON = a.candidateProtocolFromJSON = a.CandidateProtocol = a.streamStateToJSON = a.streamStateFromJSON = a.StreamState = a.signalTargetToJSON = a.signalTargetFromJSON = a.SignalTarget = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_models;
  a.protobufPackage = "livekit";
  var S;
  (function(C) {
    C[C.PUBLISHER = 0] = "PUBLISHER", C[C.SUBSCRIBER = 1] = "SUBSCRIBER", C[C.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(S = a.SignalTarget || (a.SignalTarget = {}));
  function g(C) {
    switch (C) {
      case 0:
      case "PUBLISHER":
        return S.PUBLISHER;
      case 1:
      case "SUBSCRIBER":
        return S.SUBSCRIBER;
      case -1:
      case "UNRECOGNIZED":
      default:
        return S.UNRECOGNIZED;
    }
  }
  a.signalTargetFromJSON = g;
  function E(C) {
    switch (C) {
      case S.PUBLISHER:
        return "PUBLISHER";
      case S.SUBSCRIBER:
        return "SUBSCRIBER";
      case S.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.signalTargetToJSON = E;
  var _;
  (function(C) {
    C[C.ACTIVE = 0] = "ACTIVE", C[C.PAUSED = 1] = "PAUSED", C[C.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(_ = a.StreamState || (a.StreamState = {}));
  function k(C) {
    switch (C) {
      case 0:
      case "ACTIVE":
        return _.ACTIVE;
      case 1:
      case "PAUSED":
        return _.PAUSED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return _.UNRECOGNIZED;
    }
  }
  a.streamStateFromJSON = k;
  function L(C) {
    switch (C) {
      case _.ACTIVE:
        return "ACTIVE";
      case _.PAUSED:
        return "PAUSED";
      case _.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.streamStateToJSON = L;
  var M;
  (function(C) {
    C[C.UDP = 0] = "UDP", C[C.TCP = 1] = "TCP", C[C.TLS = 2] = "TLS", C[C.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(M = a.CandidateProtocol || (a.CandidateProtocol = {}));
  function $(C) {
    switch (C) {
      case 0:
      case "UDP":
        return M.UDP;
      case 1:
      case "TCP":
        return M.TCP;
      case 2:
      case "TLS":
        return M.TLS;
      case -1:
      case "UNRECOGNIZED":
      default:
        return M.UNRECOGNIZED;
    }
  }
  a.candidateProtocolFromJSON = $;
  function J(C) {
    switch (C) {
      case M.UDP:
        return "UDP";
      case M.TCP:
        return "TCP";
      case M.TLS:
        return "TLS";
      case M.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.candidateProtocolToJSON = J;
  function V() {
    return {
      offer: void 0,
      answer: void 0,
      trickle: void 0,
      addTrack: void 0,
      mute: void 0,
      subscription: void 0,
      trackSetting: void 0,
      leave: void 0,
      updateLayers: void 0,
      subscriptionPermission: void 0,
      syncState: void 0,
      simulate: void 0,
      ping: void 0
    };
  }
  a.SignalRequest = {
    encode(C, x = l.default.Writer.create()) {
      return C.offer !== void 0 && a.SessionDescription.encode(C.offer, x.uint32(10).fork()).ldelim(), C.answer !== void 0 && a.SessionDescription.encode(C.answer, x.uint32(18).fork()).ldelim(), C.trickle !== void 0 && a.TrickleRequest.encode(C.trickle, x.uint32(26).fork()).ldelim(), C.addTrack !== void 0 && a.AddTrackRequest.encode(C.addTrack, x.uint32(34).fork()).ldelim(), C.mute !== void 0 && a.MuteTrackRequest.encode(C.mute, x.uint32(42).fork()).ldelim(), C.subscription !== void 0 && a.UpdateSubscription.encode(C.subscription, x.uint32(50).fork()).ldelim(), C.trackSetting !== void 0 && a.UpdateTrackSettings.encode(C.trackSetting, x.uint32(58).fork()).ldelim(), C.leave !== void 0 && a.LeaveRequest.encode(C.leave, x.uint32(66).fork()).ldelim(), C.updateLayers !== void 0 && a.UpdateVideoLayers.encode(C.updateLayers, x.uint32(82).fork()).ldelim(), C.subscriptionPermission !== void 0 && a.SubscriptionPermission.encode(C.subscriptionPermission, x.uint32(90).fork()).ldelim(), C.syncState !== void 0 && a.SyncState.encode(C.syncState, x.uint32(98).fork()).ldelim(), C.simulate !== void 0 && a.SimulateScenario.encode(C.simulate, x.uint32(106).fork()).ldelim(), C.ping !== void 0 && x.uint32(112).int64(C.ping), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = V();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.offer = a.SessionDescription.decode(Q, Q.uint32());
            break;
          case 2:
            me.answer = a.SessionDescription.decode(Q, Q.uint32());
            break;
          case 3:
            me.trickle = a.TrickleRequest.decode(Q, Q.uint32());
            break;
          case 4:
            me.addTrack = a.AddTrackRequest.decode(Q, Q.uint32());
            break;
          case 5:
            me.mute = a.MuteTrackRequest.decode(Q, Q.uint32());
            break;
          case 6:
            me.subscription = a.UpdateSubscription.decode(Q, Q.uint32());
            break;
          case 7:
            me.trackSetting = a.UpdateTrackSettings.decode(Q, Q.uint32());
            break;
          case 8:
            me.leave = a.LeaveRequest.decode(Q, Q.uint32());
            break;
          case 10:
            me.updateLayers = a.UpdateVideoLayers.decode(Q, Q.uint32());
            break;
          case 11:
            me.subscriptionPermission = a.SubscriptionPermission.decode(Q, Q.uint32());
            break;
          case 12:
            me.syncState = a.SyncState.decode(Q, Q.uint32());
            break;
          case 13:
            me.simulate = a.SimulateScenario.decode(Q, Q.uint32());
            break;
          case 14:
            me.ping = xe(Q.int64());
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        offer: Pe(C.offer) ? a.SessionDescription.fromJSON(C.offer) : void 0,
        answer: Pe(C.answer) ? a.SessionDescription.fromJSON(C.answer) : void 0,
        trickle: Pe(C.trickle) ? a.TrickleRequest.fromJSON(C.trickle) : void 0,
        addTrack: Pe(C.addTrack) ? a.AddTrackRequest.fromJSON(C.addTrack) : void 0,
        mute: Pe(C.mute) ? a.MuteTrackRequest.fromJSON(C.mute) : void 0,
        subscription: Pe(C.subscription) ? a.UpdateSubscription.fromJSON(C.subscription) : void 0,
        trackSetting: Pe(C.trackSetting) ? a.UpdateTrackSettings.fromJSON(C.trackSetting) : void 0,
        leave: Pe(C.leave) ? a.LeaveRequest.fromJSON(C.leave) : void 0,
        updateLayers: Pe(C.updateLayers) ? a.UpdateVideoLayers.fromJSON(C.updateLayers) : void 0,
        subscriptionPermission: Pe(C.subscriptionPermission) ? a.SubscriptionPermission.fromJSON(C.subscriptionPermission) : void 0,
        syncState: Pe(C.syncState) ? a.SyncState.fromJSON(C.syncState) : void 0,
        simulate: Pe(C.simulate) ? a.SimulateScenario.fromJSON(C.simulate) : void 0,
        ping: Pe(C.ping) ? Number(C.ping) : void 0
      };
    },
    toJSON(C) {
      const x = {};
      return C.offer !== void 0 && (x.offer = C.offer ? a.SessionDescription.toJSON(C.offer) : void 0), C.answer !== void 0 && (x.answer = C.answer ? a.SessionDescription.toJSON(C.answer) : void 0), C.trickle !== void 0 && (x.trickle = C.trickle ? a.TrickleRequest.toJSON(C.trickle) : void 0), C.addTrack !== void 0 && (x.addTrack = C.addTrack ? a.AddTrackRequest.toJSON(C.addTrack) : void 0), C.mute !== void 0 && (x.mute = C.mute ? a.MuteTrackRequest.toJSON(C.mute) : void 0), C.subscription !== void 0 && (x.subscription = C.subscription ? a.UpdateSubscription.toJSON(C.subscription) : void 0), C.trackSetting !== void 0 && (x.trackSetting = C.trackSetting ? a.UpdateTrackSettings.toJSON(C.trackSetting) : void 0), C.leave !== void 0 && (x.leave = C.leave ? a.LeaveRequest.toJSON(C.leave) : void 0), C.updateLayers !== void 0 && (x.updateLayers = C.updateLayers ? a.UpdateVideoLayers.toJSON(C.updateLayers) : void 0), C.subscriptionPermission !== void 0 && (x.subscriptionPermission = C.subscriptionPermission ? a.SubscriptionPermission.toJSON(C.subscriptionPermission) : void 0), C.syncState !== void 0 && (x.syncState = C.syncState ? a.SyncState.toJSON(C.syncState) : void 0), C.simulate !== void 0 && (x.simulate = C.simulate ? a.SimulateScenario.toJSON(C.simulate) : void 0), C.ping !== void 0 && (x.ping = Math.round(C.ping)), x;
    },
    fromPartial(C) {
      var x;
      const Q = V();
      return Q.offer = C.offer !== void 0 && C.offer !== null ? a.SessionDescription.fromPartial(C.offer) : void 0, Q.answer = C.answer !== void 0 && C.answer !== null ? a.SessionDescription.fromPartial(C.answer) : void 0, Q.trickle = C.trickle !== void 0 && C.trickle !== null ? a.TrickleRequest.fromPartial(C.trickle) : void 0, Q.addTrack = C.addTrack !== void 0 && C.addTrack !== null ? a.AddTrackRequest.fromPartial(C.addTrack) : void 0, Q.mute = C.mute !== void 0 && C.mute !== null ? a.MuteTrackRequest.fromPartial(C.mute) : void 0, Q.subscription = C.subscription !== void 0 && C.subscription !== null ? a.UpdateSubscription.fromPartial(C.subscription) : void 0, Q.trackSetting = C.trackSetting !== void 0 && C.trackSetting !== null ? a.UpdateTrackSettings.fromPartial(C.trackSetting) : void 0, Q.leave = C.leave !== void 0 && C.leave !== null ? a.LeaveRequest.fromPartial(C.leave) : void 0, Q.updateLayers = C.updateLayers !== void 0 && C.updateLayers !== null ? a.UpdateVideoLayers.fromPartial(C.updateLayers) : void 0, Q.subscriptionPermission = C.subscriptionPermission !== void 0 && C.subscriptionPermission !== null ? a.SubscriptionPermission.fromPartial(C.subscriptionPermission) : void 0, Q.syncState = C.syncState !== void 0 && C.syncState !== null ? a.SyncState.fromPartial(C.syncState) : void 0, Q.simulate = C.simulate !== void 0 && C.simulate !== null ? a.SimulateScenario.fromPartial(C.simulate) : void 0, Q.ping = (x = C.ping) !== null && x !== void 0 ? x : void 0, Q;
    }
  };
  function q() {
    return {
      join: void 0,
      answer: void 0,
      offer: void 0,
      trickle: void 0,
      update: void 0,
      trackPublished: void 0,
      leave: void 0,
      mute: void 0,
      speakersChanged: void 0,
      roomUpdate: void 0,
      connectionQuality: void 0,
      streamStateUpdate: void 0,
      subscribedQualityUpdate: void 0,
      subscriptionPermissionUpdate: void 0,
      refreshToken: void 0,
      trackUnpublished: void 0,
      pong: void 0
    };
  }
  a.SignalResponse = {
    encode(C, x = l.default.Writer.create()) {
      return C.join !== void 0 && a.JoinResponse.encode(C.join, x.uint32(10).fork()).ldelim(), C.answer !== void 0 && a.SessionDescription.encode(C.answer, x.uint32(18).fork()).ldelim(), C.offer !== void 0 && a.SessionDescription.encode(C.offer, x.uint32(26).fork()).ldelim(), C.trickle !== void 0 && a.TrickleRequest.encode(C.trickle, x.uint32(34).fork()).ldelim(), C.update !== void 0 && a.ParticipantUpdate.encode(C.update, x.uint32(42).fork()).ldelim(), C.trackPublished !== void 0 && a.TrackPublishedResponse.encode(C.trackPublished, x.uint32(50).fork()).ldelim(), C.leave !== void 0 && a.LeaveRequest.encode(C.leave, x.uint32(66).fork()).ldelim(), C.mute !== void 0 && a.MuteTrackRequest.encode(C.mute, x.uint32(74).fork()).ldelim(), C.speakersChanged !== void 0 && a.SpeakersChanged.encode(C.speakersChanged, x.uint32(82).fork()).ldelim(), C.roomUpdate !== void 0 && a.RoomUpdate.encode(C.roomUpdate, x.uint32(90).fork()).ldelim(), C.connectionQuality !== void 0 && a.ConnectionQualityUpdate.encode(C.connectionQuality, x.uint32(98).fork()).ldelim(), C.streamStateUpdate !== void 0 && a.StreamStateUpdate.encode(C.streamStateUpdate, x.uint32(106).fork()).ldelim(), C.subscribedQualityUpdate !== void 0 && a.SubscribedQualityUpdate.encode(C.subscribedQualityUpdate, x.uint32(114).fork()).ldelim(), C.subscriptionPermissionUpdate !== void 0 && a.SubscriptionPermissionUpdate.encode(C.subscriptionPermissionUpdate, x.uint32(122).fork()).ldelim(), C.refreshToken !== void 0 && x.uint32(130).string(C.refreshToken), C.trackUnpublished !== void 0 && a.TrackUnpublishedResponse.encode(C.trackUnpublished, x.uint32(138).fork()).ldelim(), C.pong !== void 0 && x.uint32(144).int64(C.pong), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = q();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.join = a.JoinResponse.decode(Q, Q.uint32());
            break;
          case 2:
            me.answer = a.SessionDescription.decode(Q, Q.uint32());
            break;
          case 3:
            me.offer = a.SessionDescription.decode(Q, Q.uint32());
            break;
          case 4:
            me.trickle = a.TrickleRequest.decode(Q, Q.uint32());
            break;
          case 5:
            me.update = a.ParticipantUpdate.decode(Q, Q.uint32());
            break;
          case 6:
            me.trackPublished = a.TrackPublishedResponse.decode(Q, Q.uint32());
            break;
          case 8:
            me.leave = a.LeaveRequest.decode(Q, Q.uint32());
            break;
          case 9:
            me.mute = a.MuteTrackRequest.decode(Q, Q.uint32());
            break;
          case 10:
            me.speakersChanged = a.SpeakersChanged.decode(Q, Q.uint32());
            break;
          case 11:
            me.roomUpdate = a.RoomUpdate.decode(Q, Q.uint32());
            break;
          case 12:
            me.connectionQuality = a.ConnectionQualityUpdate.decode(Q, Q.uint32());
            break;
          case 13:
            me.streamStateUpdate = a.StreamStateUpdate.decode(Q, Q.uint32());
            break;
          case 14:
            me.subscribedQualityUpdate = a.SubscribedQualityUpdate.decode(Q, Q.uint32());
            break;
          case 15:
            me.subscriptionPermissionUpdate = a.SubscriptionPermissionUpdate.decode(Q, Q.uint32());
            break;
          case 16:
            me.refreshToken = Q.string();
            break;
          case 17:
            me.trackUnpublished = a.TrackUnpublishedResponse.decode(Q, Q.uint32());
            break;
          case 18:
            me.pong = xe(Q.int64());
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        join: Pe(C.join) ? a.JoinResponse.fromJSON(C.join) : void 0,
        answer: Pe(C.answer) ? a.SessionDescription.fromJSON(C.answer) : void 0,
        offer: Pe(C.offer) ? a.SessionDescription.fromJSON(C.offer) : void 0,
        trickle: Pe(C.trickle) ? a.TrickleRequest.fromJSON(C.trickle) : void 0,
        update: Pe(C.update) ? a.ParticipantUpdate.fromJSON(C.update) : void 0,
        trackPublished: Pe(C.trackPublished) ? a.TrackPublishedResponse.fromJSON(C.trackPublished) : void 0,
        leave: Pe(C.leave) ? a.LeaveRequest.fromJSON(C.leave) : void 0,
        mute: Pe(C.mute) ? a.MuteTrackRequest.fromJSON(C.mute) : void 0,
        speakersChanged: Pe(C.speakersChanged) ? a.SpeakersChanged.fromJSON(C.speakersChanged) : void 0,
        roomUpdate: Pe(C.roomUpdate) ? a.RoomUpdate.fromJSON(C.roomUpdate) : void 0,
        connectionQuality: Pe(C.connectionQuality) ? a.ConnectionQualityUpdate.fromJSON(C.connectionQuality) : void 0,
        streamStateUpdate: Pe(C.streamStateUpdate) ? a.StreamStateUpdate.fromJSON(C.streamStateUpdate) : void 0,
        subscribedQualityUpdate: Pe(C.subscribedQualityUpdate) ? a.SubscribedQualityUpdate.fromJSON(C.subscribedQualityUpdate) : void 0,
        subscriptionPermissionUpdate: Pe(C.subscriptionPermissionUpdate) ? a.SubscriptionPermissionUpdate.fromJSON(C.subscriptionPermissionUpdate) : void 0,
        refreshToken: Pe(C.refreshToken) ? String(C.refreshToken) : void 0,
        trackUnpublished: Pe(C.trackUnpublished) ? a.TrackUnpublishedResponse.fromJSON(C.trackUnpublished) : void 0,
        pong: Pe(C.pong) ? Number(C.pong) : void 0
      };
    },
    toJSON(C) {
      const x = {};
      return C.join !== void 0 && (x.join = C.join ? a.JoinResponse.toJSON(C.join) : void 0), C.answer !== void 0 && (x.answer = C.answer ? a.SessionDescription.toJSON(C.answer) : void 0), C.offer !== void 0 && (x.offer = C.offer ? a.SessionDescription.toJSON(C.offer) : void 0), C.trickle !== void 0 && (x.trickle = C.trickle ? a.TrickleRequest.toJSON(C.trickle) : void 0), C.update !== void 0 && (x.update = C.update ? a.ParticipantUpdate.toJSON(C.update) : void 0), C.trackPublished !== void 0 && (x.trackPublished = C.trackPublished ? a.TrackPublishedResponse.toJSON(C.trackPublished) : void 0), C.leave !== void 0 && (x.leave = C.leave ? a.LeaveRequest.toJSON(C.leave) : void 0), C.mute !== void 0 && (x.mute = C.mute ? a.MuteTrackRequest.toJSON(C.mute) : void 0), C.speakersChanged !== void 0 && (x.speakersChanged = C.speakersChanged ? a.SpeakersChanged.toJSON(C.speakersChanged) : void 0), C.roomUpdate !== void 0 && (x.roomUpdate = C.roomUpdate ? a.RoomUpdate.toJSON(C.roomUpdate) : void 0), C.connectionQuality !== void 0 && (x.connectionQuality = C.connectionQuality ? a.ConnectionQualityUpdate.toJSON(C.connectionQuality) : void 0), C.streamStateUpdate !== void 0 && (x.streamStateUpdate = C.streamStateUpdate ? a.StreamStateUpdate.toJSON(C.streamStateUpdate) : void 0), C.subscribedQualityUpdate !== void 0 && (x.subscribedQualityUpdate = C.subscribedQualityUpdate ? a.SubscribedQualityUpdate.toJSON(C.subscribedQualityUpdate) : void 0), C.subscriptionPermissionUpdate !== void 0 && (x.subscriptionPermissionUpdate = C.subscriptionPermissionUpdate ? a.SubscriptionPermissionUpdate.toJSON(C.subscriptionPermissionUpdate) : void 0), C.refreshToken !== void 0 && (x.refreshToken = C.refreshToken), C.trackUnpublished !== void 0 && (x.trackUnpublished = C.trackUnpublished ? a.TrackUnpublishedResponse.toJSON(C.trackUnpublished) : void 0), C.pong !== void 0 && (x.pong = Math.round(C.pong)), x;
    },
    fromPartial(C) {
      var x, Q;
      const Se = q();
      return Se.join = C.join !== void 0 && C.join !== null ? a.JoinResponse.fromPartial(C.join) : void 0, Se.answer = C.answer !== void 0 && C.answer !== null ? a.SessionDescription.fromPartial(C.answer) : void 0, Se.offer = C.offer !== void 0 && C.offer !== null ? a.SessionDescription.fromPartial(C.offer) : void 0, Se.trickle = C.trickle !== void 0 && C.trickle !== null ? a.TrickleRequest.fromPartial(C.trickle) : void 0, Se.update = C.update !== void 0 && C.update !== null ? a.ParticipantUpdate.fromPartial(C.update) : void 0, Se.trackPublished = C.trackPublished !== void 0 && C.trackPublished !== null ? a.TrackPublishedResponse.fromPartial(C.trackPublished) : void 0, Se.leave = C.leave !== void 0 && C.leave !== null ? a.LeaveRequest.fromPartial(C.leave) : void 0, Se.mute = C.mute !== void 0 && C.mute !== null ? a.MuteTrackRequest.fromPartial(C.mute) : void 0, Se.speakersChanged = C.speakersChanged !== void 0 && C.speakersChanged !== null ? a.SpeakersChanged.fromPartial(C.speakersChanged) : void 0, Se.roomUpdate = C.roomUpdate !== void 0 && C.roomUpdate !== null ? a.RoomUpdate.fromPartial(C.roomUpdate) : void 0, Se.connectionQuality = C.connectionQuality !== void 0 && C.connectionQuality !== null ? a.ConnectionQualityUpdate.fromPartial(C.connectionQuality) : void 0, Se.streamStateUpdate = C.streamStateUpdate !== void 0 && C.streamStateUpdate !== null ? a.StreamStateUpdate.fromPartial(C.streamStateUpdate) : void 0, Se.subscribedQualityUpdate = C.subscribedQualityUpdate !== void 0 && C.subscribedQualityUpdate !== null ? a.SubscribedQualityUpdate.fromPartial(C.subscribedQualityUpdate) : void 0, Se.subscriptionPermissionUpdate = C.subscriptionPermissionUpdate !== void 0 && C.subscriptionPermissionUpdate !== null ? a.SubscriptionPermissionUpdate.fromPartial(C.subscriptionPermissionUpdate) : void 0, Se.refreshToken = (x = C.refreshToken) !== null && x !== void 0 ? x : void 0, Se.trackUnpublished = C.trackUnpublished !== void 0 && C.trackUnpublished !== null ? a.TrackUnpublishedResponse.fromPartial(C.trackUnpublished) : void 0, Se.pong = (Q = C.pong) !== null && Q !== void 0 ? Q : void 0, Se;
    }
  };
  function G() {
    return { codec: "", cid: "", enableSimulcastLayers: !1 };
  }
  a.SimulcastCodec = {
    encode(C, x = l.default.Writer.create()) {
      return C.codec !== void 0 && C.codec !== "" && x.uint32(10).string(C.codec), C.cid !== void 0 && C.cid !== "" && x.uint32(18).string(C.cid), C.enableSimulcastLayers === !0 && x.uint32(24).bool(C.enableSimulcastLayers), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = G();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.codec = Q.string();
            break;
          case 2:
            me.cid = Q.string();
            break;
          case 3:
            me.enableSimulcastLayers = Q.bool();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        codec: Pe(C.codec) ? String(C.codec) : "",
        cid: Pe(C.cid) ? String(C.cid) : "",
        enableSimulcastLayers: Pe(C.enableSimulcastLayers) ? !!C.enableSimulcastLayers : !1
      };
    },
    toJSON(C) {
      const x = {};
      return C.codec !== void 0 && (x.codec = C.codec), C.cid !== void 0 && (x.cid = C.cid), C.enableSimulcastLayers !== void 0 && (x.enableSimulcastLayers = C.enableSimulcastLayers), x;
    },
    fromPartial(C) {
      var x, Q, Se;
      const me = G();
      return me.codec = (x = C.codec) !== null && x !== void 0 ? x : "", me.cid = (Q = C.cid) !== null && Q !== void 0 ? Q : "", me.enableSimulcastLayers = (Se = C.enableSimulcastLayers) !== null && Se !== void 0 ? Se : !1, me;
    }
  };
  function H() {
    return {
      cid: "",
      name: "",
      type: 0,
      width: 0,
      height: 0,
      muted: !1,
      disableDtx: !1,
      source: 0,
      layers: [],
      simulcastCodecs: [],
      sid: "",
      stereo: !1,
      disableRed: !1
    };
  }
  a.AddTrackRequest = {
    encode(C, x = l.default.Writer.create()) {
      if (C.cid !== void 0 && C.cid !== "" && x.uint32(10).string(C.cid), C.name !== void 0 && C.name !== "" && x.uint32(18).string(C.name), C.type !== void 0 && C.type !== 0 && x.uint32(24).int32(C.type), C.width !== void 0 && C.width !== 0 && x.uint32(32).uint32(C.width), C.height !== void 0 && C.height !== 0 && x.uint32(40).uint32(C.height), C.muted === !0 && x.uint32(48).bool(C.muted), C.disableDtx === !0 && x.uint32(56).bool(C.disableDtx), C.source !== void 0 && C.source !== 0 && x.uint32(64).int32(C.source), C.layers !== void 0 && C.layers.length !== 0)
        for (const Q of C.layers)
          v.VideoLayer.encode(Q, x.uint32(74).fork()).ldelim();
      if (C.simulcastCodecs !== void 0 && C.simulcastCodecs.length !== 0)
        for (const Q of C.simulcastCodecs)
          a.SimulcastCodec.encode(Q, x.uint32(82).fork()).ldelim();
      return C.sid !== void 0 && C.sid !== "" && x.uint32(90).string(C.sid), C.stereo === !0 && x.uint32(96).bool(C.stereo), C.disableRed === !0 && x.uint32(104).bool(C.disableRed), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = H();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.cid = Q.string();
            break;
          case 2:
            me.name = Q.string();
            break;
          case 3:
            me.type = Q.int32();
            break;
          case 4:
            me.width = Q.uint32();
            break;
          case 5:
            me.height = Q.uint32();
            break;
          case 6:
            me.muted = Q.bool();
            break;
          case 7:
            me.disableDtx = Q.bool();
            break;
          case 8:
            me.source = Q.int32();
            break;
          case 9:
            me.layers.push(v.VideoLayer.decode(Q, Q.uint32()));
            break;
          case 10:
            me.simulcastCodecs.push(a.SimulcastCodec.decode(Q, Q.uint32()));
            break;
          case 11:
            me.sid = Q.string();
            break;
          case 12:
            me.stereo = Q.bool();
            break;
          case 13:
            me.disableRed = Q.bool();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        cid: Pe(C.cid) ? String(C.cid) : "",
        name: Pe(C.name) ? String(C.name) : "",
        type: Pe(C.type) ? v.trackTypeFromJSON(C.type) : 0,
        width: Pe(C.width) ? Number(C.width) : 0,
        height: Pe(C.height) ? Number(C.height) : 0,
        muted: Pe(C.muted) ? !!C.muted : !1,
        disableDtx: Pe(C.disableDtx) ? !!C.disableDtx : !1,
        source: Pe(C.source) ? v.trackSourceFromJSON(C.source) : 0,
        layers: Array.isArray(C == null ? void 0 : C.layers) ? C.layers.map((x) => v.VideoLayer.fromJSON(x)) : [],
        simulcastCodecs: Array.isArray(C == null ? void 0 : C.simulcastCodecs) ? C.simulcastCodecs.map((x) => a.SimulcastCodec.fromJSON(x)) : [],
        sid: Pe(C.sid) ? String(C.sid) : "",
        stereo: Pe(C.stereo) ? !!C.stereo : !1,
        disableRed: Pe(C.disableRed) ? !!C.disableRed : !1
      };
    },
    toJSON(C) {
      const x = {};
      return C.cid !== void 0 && (x.cid = C.cid), C.name !== void 0 && (x.name = C.name), C.type !== void 0 && (x.type = v.trackTypeToJSON(C.type)), C.width !== void 0 && (x.width = Math.round(C.width)), C.height !== void 0 && (x.height = Math.round(C.height)), C.muted !== void 0 && (x.muted = C.muted), C.disableDtx !== void 0 && (x.disableDtx = C.disableDtx), C.source !== void 0 && (x.source = v.trackSourceToJSON(C.source)), C.layers ? x.layers = C.layers.map((Q) => Q ? v.VideoLayer.toJSON(Q) : void 0) : x.layers = [], C.simulcastCodecs ? x.simulcastCodecs = C.simulcastCodecs.map((Q) => Q ? a.SimulcastCodec.toJSON(Q) : void 0) : x.simulcastCodecs = [], C.sid !== void 0 && (x.sid = C.sid), C.stereo !== void 0 && (x.stereo = C.stereo), C.disableRed !== void 0 && (x.disableRed = C.disableRed), x;
    },
    fromPartial(C) {
      var x, Q, Se, me, Ie, at, Ye, je, tt, Oe, P, X, ie;
      const Ee = H();
      return Ee.cid = (x = C.cid) !== null && x !== void 0 ? x : "", Ee.name = (Q = C.name) !== null && Q !== void 0 ? Q : "", Ee.type = (Se = C.type) !== null && Se !== void 0 ? Se : 0, Ee.width = (me = C.width) !== null && me !== void 0 ? me : 0, Ee.height = (Ie = C.height) !== null && Ie !== void 0 ? Ie : 0, Ee.muted = (at = C.muted) !== null && at !== void 0 ? at : !1, Ee.disableDtx = (Ye = C.disableDtx) !== null && Ye !== void 0 ? Ye : !1, Ee.source = (je = C.source) !== null && je !== void 0 ? je : 0, Ee.layers = ((tt = C.layers) === null || tt === void 0 ? void 0 : tt.map((ue) => v.VideoLayer.fromPartial(ue))) || [], Ee.simulcastCodecs = ((Oe = C.simulcastCodecs) === null || Oe === void 0 ? void 0 : Oe.map((ue) => a.SimulcastCodec.fromPartial(ue))) || [], Ee.sid = (P = C.sid) !== null && P !== void 0 ? P : "", Ee.stereo = (X = C.stereo) !== null && X !== void 0 ? X : !1, Ee.disableRed = (ie = C.disableRed) !== null && ie !== void 0 ? ie : !1, Ee;
    }
  };
  function B() {
    return { candidateInit: "", target: 0 };
  }
  a.TrickleRequest = {
    encode(C, x = l.default.Writer.create()) {
      return C.candidateInit !== void 0 && C.candidateInit !== "" && x.uint32(10).string(C.candidateInit), C.target !== void 0 && C.target !== 0 && x.uint32(16).int32(C.target), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = B();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.candidateInit = Q.string();
            break;
          case 2:
            me.target = Q.int32();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        candidateInit: Pe(C.candidateInit) ? String(C.candidateInit) : "",
        target: Pe(C.target) ? g(C.target) : 0
      };
    },
    toJSON(C) {
      const x = {};
      return C.candidateInit !== void 0 && (x.candidateInit = C.candidateInit), C.target !== void 0 && (x.target = E(C.target)), x;
    },
    fromPartial(C) {
      var x, Q;
      const Se = B();
      return Se.candidateInit = (x = C.candidateInit) !== null && x !== void 0 ? x : "", Se.target = (Q = C.target) !== null && Q !== void 0 ? Q : 0, Se;
    }
  };
  function Y() {
    return { sid: "", muted: !1 };
  }
  a.MuteTrackRequest = {
    encode(C, x = l.default.Writer.create()) {
      return C.sid !== void 0 && C.sid !== "" && x.uint32(10).string(C.sid), C.muted === !0 && x.uint32(16).bool(C.muted), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = Y();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.sid = Q.string();
            break;
          case 2:
            me.muted = Q.bool();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        sid: Pe(C.sid) ? String(C.sid) : "",
        muted: Pe(C.muted) ? !!C.muted : !1
      };
    },
    toJSON(C) {
      const x = {};
      return C.sid !== void 0 && (x.sid = C.sid), C.muted !== void 0 && (x.muted = C.muted), x;
    },
    fromPartial(C) {
      var x, Q;
      const Se = Y();
      return Se.sid = (x = C.sid) !== null && x !== void 0 ? x : "", Se.muted = (Q = C.muted) !== null && Q !== void 0 ? Q : !1, Se;
    }
  };
  function ne() {
    return {
      room: void 0,
      participant: void 0,
      otherParticipants: [],
      serverVersion: "",
      iceServers: [],
      subscriberPrimary: !1,
      alternativeUrl: "",
      clientConfiguration: void 0,
      serverRegion: "",
      pingTimeout: 0,
      pingInterval: 0,
      serverInfo: void 0
    };
  }
  a.JoinResponse = {
    encode(C, x = l.default.Writer.create()) {
      if (C.room !== void 0 && v.Room.encode(C.room, x.uint32(10).fork()).ldelim(), C.participant !== void 0 && v.ParticipantInfo.encode(C.participant, x.uint32(18).fork()).ldelim(), C.otherParticipants !== void 0 && C.otherParticipants.length !== 0)
        for (const Q of C.otherParticipants)
          v.ParticipantInfo.encode(Q, x.uint32(26).fork()).ldelim();
      if (C.serverVersion !== void 0 && C.serverVersion !== "" && x.uint32(34).string(C.serverVersion), C.iceServers !== void 0 && C.iceServers.length !== 0)
        for (const Q of C.iceServers)
          a.ICEServer.encode(Q, x.uint32(42).fork()).ldelim();
      return C.subscriberPrimary === !0 && x.uint32(48).bool(C.subscriberPrimary), C.alternativeUrl !== void 0 && C.alternativeUrl !== "" && x.uint32(58).string(C.alternativeUrl), C.clientConfiguration !== void 0 && v.ClientConfiguration.encode(C.clientConfiguration, x.uint32(66).fork()).ldelim(), C.serverRegion !== void 0 && C.serverRegion !== "" && x.uint32(74).string(C.serverRegion), C.pingTimeout !== void 0 && C.pingTimeout !== 0 && x.uint32(80).int32(C.pingTimeout), C.pingInterval !== void 0 && C.pingInterval !== 0 && x.uint32(88).int32(C.pingInterval), C.serverInfo !== void 0 && v.ServerInfo.encode(C.serverInfo, x.uint32(98).fork()).ldelim(), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = ne();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.room = v.Room.decode(Q, Q.uint32());
            break;
          case 2:
            me.participant = v.ParticipantInfo.decode(Q, Q.uint32());
            break;
          case 3:
            me.otherParticipants.push(v.ParticipantInfo.decode(Q, Q.uint32()));
            break;
          case 4:
            me.serverVersion = Q.string();
            break;
          case 5:
            me.iceServers.push(a.ICEServer.decode(Q, Q.uint32()));
            break;
          case 6:
            me.subscriberPrimary = Q.bool();
            break;
          case 7:
            me.alternativeUrl = Q.string();
            break;
          case 8:
            me.clientConfiguration = v.ClientConfiguration.decode(Q, Q.uint32());
            break;
          case 9:
            me.serverRegion = Q.string();
            break;
          case 10:
            me.pingTimeout = Q.int32();
            break;
          case 11:
            me.pingInterval = Q.int32();
            break;
          case 12:
            me.serverInfo = v.ServerInfo.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        room: Pe(C.room) ? v.Room.fromJSON(C.room) : void 0,
        participant: Pe(C.participant) ? v.ParticipantInfo.fromJSON(C.participant) : void 0,
        otherParticipants: Array.isArray(C == null ? void 0 : C.otherParticipants) ? C.otherParticipants.map((x) => v.ParticipantInfo.fromJSON(x)) : [],
        serverVersion: Pe(C.serverVersion) ? String(C.serverVersion) : "",
        iceServers: Array.isArray(C == null ? void 0 : C.iceServers) ? C.iceServers.map((x) => a.ICEServer.fromJSON(x)) : [],
        subscriberPrimary: Pe(C.subscriberPrimary) ? !!C.subscriberPrimary : !1,
        alternativeUrl: Pe(C.alternativeUrl) ? String(C.alternativeUrl) : "",
        clientConfiguration: Pe(C.clientConfiguration) ? v.ClientConfiguration.fromJSON(C.clientConfiguration) : void 0,
        serverRegion: Pe(C.serverRegion) ? String(C.serverRegion) : "",
        pingTimeout: Pe(C.pingTimeout) ? Number(C.pingTimeout) : 0,
        pingInterval: Pe(C.pingInterval) ? Number(C.pingInterval) : 0,
        serverInfo: Pe(C.serverInfo) ? v.ServerInfo.fromJSON(C.serverInfo) : void 0
      };
    },
    toJSON(C) {
      const x = {};
      return C.room !== void 0 && (x.room = C.room ? v.Room.toJSON(C.room) : void 0), C.participant !== void 0 && (x.participant = C.participant ? v.ParticipantInfo.toJSON(C.participant) : void 0), C.otherParticipants ? x.otherParticipants = C.otherParticipants.map((Q) => Q ? v.ParticipantInfo.toJSON(Q) : void 0) : x.otherParticipants = [], C.serverVersion !== void 0 && (x.serverVersion = C.serverVersion), C.iceServers ? x.iceServers = C.iceServers.map((Q) => Q ? a.ICEServer.toJSON(Q) : void 0) : x.iceServers = [], C.subscriberPrimary !== void 0 && (x.subscriberPrimary = C.subscriberPrimary), C.alternativeUrl !== void 0 && (x.alternativeUrl = C.alternativeUrl), C.clientConfiguration !== void 0 && (x.clientConfiguration = C.clientConfiguration ? v.ClientConfiguration.toJSON(C.clientConfiguration) : void 0), C.serverRegion !== void 0 && (x.serverRegion = C.serverRegion), C.pingTimeout !== void 0 && (x.pingTimeout = Math.round(C.pingTimeout)), C.pingInterval !== void 0 && (x.pingInterval = Math.round(C.pingInterval)), C.serverInfo !== void 0 && (x.serverInfo = C.serverInfo ? v.ServerInfo.toJSON(C.serverInfo) : void 0), x;
    },
    fromPartial(C) {
      var x, Q, Se, me, Ie, at, Ye, je;
      const tt = ne();
      return tt.room = C.room !== void 0 && C.room !== null ? v.Room.fromPartial(C.room) : void 0, tt.participant = C.participant !== void 0 && C.participant !== null ? v.ParticipantInfo.fromPartial(C.participant) : void 0, tt.otherParticipants = ((x = C.otherParticipants) === null || x === void 0 ? void 0 : x.map((Oe) => v.ParticipantInfo.fromPartial(Oe))) || [], tt.serverVersion = (Q = C.serverVersion) !== null && Q !== void 0 ? Q : "", tt.iceServers = ((Se = C.iceServers) === null || Se === void 0 ? void 0 : Se.map((Oe) => a.ICEServer.fromPartial(Oe))) || [], tt.subscriberPrimary = (me = C.subscriberPrimary) !== null && me !== void 0 ? me : !1, tt.alternativeUrl = (Ie = C.alternativeUrl) !== null && Ie !== void 0 ? Ie : "", tt.clientConfiguration = C.clientConfiguration !== void 0 && C.clientConfiguration !== null ? v.ClientConfiguration.fromPartial(C.clientConfiguration) : void 0, tt.serverRegion = (at = C.serverRegion) !== null && at !== void 0 ? at : "", tt.pingTimeout = (Ye = C.pingTimeout) !== null && Ye !== void 0 ? Ye : 0, tt.pingInterval = (je = C.pingInterval) !== null && je !== void 0 ? je : 0, tt.serverInfo = C.serverInfo !== void 0 && C.serverInfo !== null ? v.ServerInfo.fromPartial(C.serverInfo) : void 0, tt;
    }
  };
  function Z() {
    return { cid: "", track: void 0 };
  }
  a.TrackPublishedResponse = {
    encode(C, x = l.default.Writer.create()) {
      return C.cid !== void 0 && C.cid !== "" && x.uint32(10).string(C.cid), C.track !== void 0 && v.TrackInfo.encode(C.track, x.uint32(18).fork()).ldelim(), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = Z();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.cid = Q.string();
            break;
          case 2:
            me.track = v.TrackInfo.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        cid: Pe(C.cid) ? String(C.cid) : "",
        track: Pe(C.track) ? v.TrackInfo.fromJSON(C.track) : void 0
      };
    },
    toJSON(C) {
      const x = {};
      return C.cid !== void 0 && (x.cid = C.cid), C.track !== void 0 && (x.track = C.track ? v.TrackInfo.toJSON(C.track) : void 0), x;
    },
    fromPartial(C) {
      var x;
      const Q = Z();
      return Q.cid = (x = C.cid) !== null && x !== void 0 ? x : "", Q.track = C.track !== void 0 && C.track !== null ? v.TrackInfo.fromPartial(C.track) : void 0, Q;
    }
  };
  function re() {
    return { trackSid: "" };
  }
  a.TrackUnpublishedResponse = {
    encode(C, x = l.default.Writer.create()) {
      return C.trackSid !== void 0 && C.trackSid !== "" && x.uint32(10).string(C.trackSid), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = re();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.trackSid = Q.string();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return { trackSid: Pe(C.trackSid) ? String(C.trackSid) : "" };
    },
    toJSON(C) {
      const x = {};
      return C.trackSid !== void 0 && (x.trackSid = C.trackSid), x;
    },
    fromPartial(C) {
      var x;
      const Q = re();
      return Q.trackSid = (x = C.trackSid) !== null && x !== void 0 ? x : "", Q;
    }
  };
  function oe() {
    return { type: "", sdp: "" };
  }
  a.SessionDescription = {
    encode(C, x = l.default.Writer.create()) {
      return C.type !== void 0 && C.type !== "" && x.uint32(10).string(C.type), C.sdp !== void 0 && C.sdp !== "" && x.uint32(18).string(C.sdp), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = oe();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.type = Q.string();
            break;
          case 2:
            me.sdp = Q.string();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return { type: Pe(C.type) ? String(C.type) : "", sdp: Pe(C.sdp) ? String(C.sdp) : "" };
    },
    toJSON(C) {
      const x = {};
      return C.type !== void 0 && (x.type = C.type), C.sdp !== void 0 && (x.sdp = C.sdp), x;
    },
    fromPartial(C) {
      var x, Q;
      const Se = oe();
      return Se.type = (x = C.type) !== null && x !== void 0 ? x : "", Se.sdp = (Q = C.sdp) !== null && Q !== void 0 ? Q : "", Se;
    }
  };
  function de() {
    return { participants: [] };
  }
  a.ParticipantUpdate = {
    encode(C, x = l.default.Writer.create()) {
      if (C.participants !== void 0 && C.participants.length !== 0)
        for (const Q of C.participants)
          v.ParticipantInfo.encode(Q, x.uint32(10).fork()).ldelim();
      return x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = de();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.participants.push(v.ParticipantInfo.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        participants: Array.isArray(C == null ? void 0 : C.participants) ? C.participants.map((x) => v.ParticipantInfo.fromJSON(x)) : []
      };
    },
    toJSON(C) {
      const x = {};
      return C.participants ? x.participants = C.participants.map((Q) => Q ? v.ParticipantInfo.toJSON(Q) : void 0) : x.participants = [], x;
    },
    fromPartial(C) {
      var x;
      const Q = de();
      return Q.participants = ((x = C.participants) === null || x === void 0 ? void 0 : x.map((Se) => v.ParticipantInfo.fromPartial(Se))) || [], Q;
    }
  };
  function A() {
    return { trackSids: [], subscribe: !1, participantTracks: [] };
  }
  a.UpdateSubscription = {
    encode(C, x = l.default.Writer.create()) {
      if (C.trackSids !== void 0 && C.trackSids.length !== 0)
        for (const Q of C.trackSids)
          x.uint32(10).string(Q);
      if (C.subscribe === !0 && x.uint32(16).bool(C.subscribe), C.participantTracks !== void 0 && C.participantTracks.length !== 0)
        for (const Q of C.participantTracks)
          v.ParticipantTracks.encode(Q, x.uint32(26).fork()).ldelim();
      return x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = A();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.trackSids.push(Q.string());
            break;
          case 2:
            me.subscribe = Q.bool();
            break;
          case 3:
            me.participantTracks.push(v.ParticipantTracks.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        trackSids: Array.isArray(C == null ? void 0 : C.trackSids) ? C.trackSids.map((x) => String(x)) : [],
        subscribe: Pe(C.subscribe) ? !!C.subscribe : !1,
        participantTracks: Array.isArray(C == null ? void 0 : C.participantTracks) ? C.participantTracks.map((x) => v.ParticipantTracks.fromJSON(x)) : []
      };
    },
    toJSON(C) {
      const x = {};
      return C.trackSids ? x.trackSids = C.trackSids.map((Q) => Q) : x.trackSids = [], C.subscribe !== void 0 && (x.subscribe = C.subscribe), C.participantTracks ? x.participantTracks = C.participantTracks.map((Q) => Q ? v.ParticipantTracks.toJSON(Q) : void 0) : x.participantTracks = [], x;
    },
    fromPartial(C) {
      var x, Q, Se;
      const me = A();
      return me.trackSids = ((x = C.trackSids) === null || x === void 0 ? void 0 : x.map((Ie) => Ie)) || [], me.subscribe = (Q = C.subscribe) !== null && Q !== void 0 ? Q : !1, me.participantTracks = ((Se = C.participantTracks) === null || Se === void 0 ? void 0 : Se.map((Ie) => v.ParticipantTracks.fromPartial(Ie))) || [], me;
    }
  };
  function N() {
    return { trackSids: [], disabled: !1, quality: 0, width: 0, height: 0, fps: 0 };
  }
  a.UpdateTrackSettings = {
    encode(C, x = l.default.Writer.create()) {
      if (C.trackSids !== void 0 && C.trackSids.length !== 0)
        for (const Q of C.trackSids)
          x.uint32(10).string(Q);
      return C.disabled === !0 && x.uint32(24).bool(C.disabled), C.quality !== void 0 && C.quality !== 0 && x.uint32(32).int32(C.quality), C.width !== void 0 && C.width !== 0 && x.uint32(40).uint32(C.width), C.height !== void 0 && C.height !== 0 && x.uint32(48).uint32(C.height), C.fps !== void 0 && C.fps !== 0 && x.uint32(56).uint32(C.fps), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = N();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.trackSids.push(Q.string());
            break;
          case 3:
            me.disabled = Q.bool();
            break;
          case 4:
            me.quality = Q.int32();
            break;
          case 5:
            me.width = Q.uint32();
            break;
          case 6:
            me.height = Q.uint32();
            break;
          case 7:
            me.fps = Q.uint32();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        trackSids: Array.isArray(C == null ? void 0 : C.trackSids) ? C.trackSids.map((x) => String(x)) : [],
        disabled: Pe(C.disabled) ? !!C.disabled : !1,
        quality: Pe(C.quality) ? v.videoQualityFromJSON(C.quality) : 0,
        width: Pe(C.width) ? Number(C.width) : 0,
        height: Pe(C.height) ? Number(C.height) : 0,
        fps: Pe(C.fps) ? Number(C.fps) : 0
      };
    },
    toJSON(C) {
      const x = {};
      return C.trackSids ? x.trackSids = C.trackSids.map((Q) => Q) : x.trackSids = [], C.disabled !== void 0 && (x.disabled = C.disabled), C.quality !== void 0 && (x.quality = v.videoQualityToJSON(C.quality)), C.width !== void 0 && (x.width = Math.round(C.width)), C.height !== void 0 && (x.height = Math.round(C.height)), C.fps !== void 0 && (x.fps = Math.round(C.fps)), x;
    },
    fromPartial(C) {
      var x, Q, Se, me, Ie, at;
      const Ye = N();
      return Ye.trackSids = ((x = C.trackSids) === null || x === void 0 ? void 0 : x.map((je) => je)) || [], Ye.disabled = (Q = C.disabled) !== null && Q !== void 0 ? Q : !1, Ye.quality = (Se = C.quality) !== null && Se !== void 0 ? Se : 0, Ye.width = (me = C.width) !== null && me !== void 0 ? me : 0, Ye.height = (Ie = C.height) !== null && Ie !== void 0 ? Ie : 0, Ye.fps = (at = C.fps) !== null && at !== void 0 ? at : 0, Ye;
    }
  };
  function D() {
    return { canReconnect: !1, reason: 0 };
  }
  a.LeaveRequest = {
    encode(C, x = l.default.Writer.create()) {
      return C.canReconnect === !0 && x.uint32(8).bool(C.canReconnect), C.reason !== void 0 && C.reason !== 0 && x.uint32(16).int32(C.reason), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = D();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.canReconnect = Q.bool();
            break;
          case 2:
            me.reason = Q.int32();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        canReconnect: Pe(C.canReconnect) ? !!C.canReconnect : !1,
        reason: Pe(C.reason) ? v.disconnectReasonFromJSON(C.reason) : 0
      };
    },
    toJSON(C) {
      const x = {};
      return C.canReconnect !== void 0 && (x.canReconnect = C.canReconnect), C.reason !== void 0 && (x.reason = v.disconnectReasonToJSON(C.reason)), x;
    },
    fromPartial(C) {
      var x, Q;
      const Se = D();
      return Se.canReconnect = (x = C.canReconnect) !== null && x !== void 0 ? x : !1, Se.reason = (Q = C.reason) !== null && Q !== void 0 ? Q : 0, Se;
    }
  };
  function W() {
    return { trackSid: "", layers: [] };
  }
  a.UpdateVideoLayers = {
    encode(C, x = l.default.Writer.create()) {
      if (C.trackSid !== void 0 && C.trackSid !== "" && x.uint32(10).string(C.trackSid), C.layers !== void 0 && C.layers.length !== 0)
        for (const Q of C.layers)
          v.VideoLayer.encode(Q, x.uint32(18).fork()).ldelim();
      return x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = W();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.trackSid = Q.string();
            break;
          case 2:
            me.layers.push(v.VideoLayer.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        trackSid: Pe(C.trackSid) ? String(C.trackSid) : "",
        layers: Array.isArray(C == null ? void 0 : C.layers) ? C.layers.map((x) => v.VideoLayer.fromJSON(x)) : []
      };
    },
    toJSON(C) {
      const x = {};
      return C.trackSid !== void 0 && (x.trackSid = C.trackSid), C.layers ? x.layers = C.layers.map((Q) => Q ? v.VideoLayer.toJSON(Q) : void 0) : x.layers = [], x;
    },
    fromPartial(C) {
      var x, Q;
      const Se = W();
      return Se.trackSid = (x = C.trackSid) !== null && x !== void 0 ? x : "", Se.layers = ((Q = C.layers) === null || Q === void 0 ? void 0 : Q.map((me) => v.VideoLayer.fromPartial(me))) || [], Se;
    }
  };
  function ee() {
    return { urls: [], username: "", credential: "" };
  }
  a.ICEServer = {
    encode(C, x = l.default.Writer.create()) {
      if (C.urls !== void 0 && C.urls.length !== 0)
        for (const Q of C.urls)
          x.uint32(10).string(Q);
      return C.username !== void 0 && C.username !== "" && x.uint32(18).string(C.username), C.credential !== void 0 && C.credential !== "" && x.uint32(26).string(C.credential), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = ee();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.urls.push(Q.string());
            break;
          case 2:
            me.username = Q.string();
            break;
          case 3:
            me.credential = Q.string();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        urls: Array.isArray(C == null ? void 0 : C.urls) ? C.urls.map((x) => String(x)) : [],
        username: Pe(C.username) ? String(C.username) : "",
        credential: Pe(C.credential) ? String(C.credential) : ""
      };
    },
    toJSON(C) {
      const x = {};
      return C.urls ? x.urls = C.urls.map((Q) => Q) : x.urls = [], C.username !== void 0 && (x.username = C.username), C.credential !== void 0 && (x.credential = C.credential), x;
    },
    fromPartial(C) {
      var x, Q, Se;
      const me = ee();
      return me.urls = ((x = C.urls) === null || x === void 0 ? void 0 : x.map((Ie) => Ie)) || [], me.username = (Q = C.username) !== null && Q !== void 0 ? Q : "", me.credential = (Se = C.credential) !== null && Se !== void 0 ? Se : "", me;
    }
  };
  function ae() {
    return { speakers: [] };
  }
  a.SpeakersChanged = {
    encode(C, x = l.default.Writer.create()) {
      if (C.speakers !== void 0 && C.speakers.length !== 0)
        for (const Q of C.speakers)
          v.SpeakerInfo.encode(Q, x.uint32(10).fork()).ldelim();
      return x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = ae();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.speakers.push(v.SpeakerInfo.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        speakers: Array.isArray(C == null ? void 0 : C.speakers) ? C.speakers.map((x) => v.SpeakerInfo.fromJSON(x)) : []
      };
    },
    toJSON(C) {
      const x = {};
      return C.speakers ? x.speakers = C.speakers.map((Q) => Q ? v.SpeakerInfo.toJSON(Q) : void 0) : x.speakers = [], x;
    },
    fromPartial(C) {
      var x;
      const Q = ae();
      return Q.speakers = ((x = C.speakers) === null || x === void 0 ? void 0 : x.map((Se) => v.SpeakerInfo.fromPartial(Se))) || [], Q;
    }
  };
  function ye() {
    return { room: void 0 };
  }
  a.RoomUpdate = {
    encode(C, x = l.default.Writer.create()) {
      return C.room !== void 0 && v.Room.encode(C.room, x.uint32(10).fork()).ldelim(), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = ye();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.room = v.Room.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return { room: Pe(C.room) ? v.Room.fromJSON(C.room) : void 0 };
    },
    toJSON(C) {
      const x = {};
      return C.room !== void 0 && (x.room = C.room ? v.Room.toJSON(C.room) : void 0), x;
    },
    fromPartial(C) {
      const x = ye();
      return x.room = C.room !== void 0 && C.room !== null ? v.Room.fromPartial(C.room) : void 0, x;
    }
  };
  function he() {
    return { participantSid: "", quality: 0, score: 0 };
  }
  a.ConnectionQualityInfo = {
    encode(C, x = l.default.Writer.create()) {
      return C.participantSid !== void 0 && C.participantSid !== "" && x.uint32(10).string(C.participantSid), C.quality !== void 0 && C.quality !== 0 && x.uint32(16).int32(C.quality), C.score !== void 0 && C.score !== 0 && x.uint32(29).float(C.score), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = he();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.participantSid = Q.string();
            break;
          case 2:
            me.quality = Q.int32();
            break;
          case 3:
            me.score = Q.float();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        participantSid: Pe(C.participantSid) ? String(C.participantSid) : "",
        quality: Pe(C.quality) ? v.connectionQualityFromJSON(C.quality) : 0,
        score: Pe(C.score) ? Number(C.score) : 0
      };
    },
    toJSON(C) {
      const x = {};
      return C.participantSid !== void 0 && (x.participantSid = C.participantSid), C.quality !== void 0 && (x.quality = v.connectionQualityToJSON(C.quality)), C.score !== void 0 && (x.score = C.score), x;
    },
    fromPartial(C) {
      var x, Q, Se;
      const me = he();
      return me.participantSid = (x = C.participantSid) !== null && x !== void 0 ? x : "", me.quality = (Q = C.quality) !== null && Q !== void 0 ? Q : 0, me.score = (Se = C.score) !== null && Se !== void 0 ? Se : 0, me;
    }
  };
  function le() {
    return { updates: [] };
  }
  a.ConnectionQualityUpdate = {
    encode(C, x = l.default.Writer.create()) {
      if (C.updates !== void 0 && C.updates.length !== 0)
        for (const Q of C.updates)
          a.ConnectionQualityInfo.encode(Q, x.uint32(10).fork()).ldelim();
      return x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = le();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.updates.push(a.ConnectionQualityInfo.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        updates: Array.isArray(C == null ? void 0 : C.updates) ? C.updates.map((x) => a.ConnectionQualityInfo.fromJSON(x)) : []
      };
    },
    toJSON(C) {
      const x = {};
      return C.updates ? x.updates = C.updates.map((Q) => Q ? a.ConnectionQualityInfo.toJSON(Q) : void 0) : x.updates = [], x;
    },
    fromPartial(C) {
      var x;
      const Q = le();
      return Q.updates = ((x = C.updates) === null || x === void 0 ? void 0 : x.map((Se) => a.ConnectionQualityInfo.fromPartial(Se))) || [], Q;
    }
  };
  function we() {
    return { participantSid: "", trackSid: "", state: 0 };
  }
  a.StreamStateInfo = {
    encode(C, x = l.default.Writer.create()) {
      return C.participantSid !== void 0 && C.participantSid !== "" && x.uint32(10).string(C.participantSid), C.trackSid !== void 0 && C.trackSid !== "" && x.uint32(18).string(C.trackSid), C.state !== void 0 && C.state !== 0 && x.uint32(24).int32(C.state), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = we();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.participantSid = Q.string();
            break;
          case 2:
            me.trackSid = Q.string();
            break;
          case 3:
            me.state = Q.int32();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        participantSid: Pe(C.participantSid) ? String(C.participantSid) : "",
        trackSid: Pe(C.trackSid) ? String(C.trackSid) : "",
        state: Pe(C.state) ? k(C.state) : 0
      };
    },
    toJSON(C) {
      const x = {};
      return C.participantSid !== void 0 && (x.participantSid = C.participantSid), C.trackSid !== void 0 && (x.trackSid = C.trackSid), C.state !== void 0 && (x.state = L(C.state)), x;
    },
    fromPartial(C) {
      var x, Q, Se;
      const me = we();
      return me.participantSid = (x = C.participantSid) !== null && x !== void 0 ? x : "", me.trackSid = (Q = C.trackSid) !== null && Q !== void 0 ? Q : "", me.state = (Se = C.state) !== null && Se !== void 0 ? Se : 0, me;
    }
  };
  function Be() {
    return { streamStates: [] };
  }
  a.StreamStateUpdate = {
    encode(C, x = l.default.Writer.create()) {
      if (C.streamStates !== void 0 && C.streamStates.length !== 0)
        for (const Q of C.streamStates)
          a.StreamStateInfo.encode(Q, x.uint32(10).fork()).ldelim();
      return x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = Be();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.streamStates.push(a.StreamStateInfo.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        streamStates: Array.isArray(C == null ? void 0 : C.streamStates) ? C.streamStates.map((x) => a.StreamStateInfo.fromJSON(x)) : []
      };
    },
    toJSON(C) {
      const x = {};
      return C.streamStates ? x.streamStates = C.streamStates.map((Q) => Q ? a.StreamStateInfo.toJSON(Q) : void 0) : x.streamStates = [], x;
    },
    fromPartial(C) {
      var x;
      const Q = Be();
      return Q.streamStates = ((x = C.streamStates) === null || x === void 0 ? void 0 : x.map((Se) => a.StreamStateInfo.fromPartial(Se))) || [], Q;
    }
  };
  function Ne() {
    return { quality: 0, enabled: !1 };
  }
  a.SubscribedQuality = {
    encode(C, x = l.default.Writer.create()) {
      return C.quality !== void 0 && C.quality !== 0 && x.uint32(8).int32(C.quality), C.enabled === !0 && x.uint32(16).bool(C.enabled), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = Ne();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.quality = Q.int32();
            break;
          case 2:
            me.enabled = Q.bool();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        quality: Pe(C.quality) ? v.videoQualityFromJSON(C.quality) : 0,
        enabled: Pe(C.enabled) ? !!C.enabled : !1
      };
    },
    toJSON(C) {
      const x = {};
      return C.quality !== void 0 && (x.quality = v.videoQualityToJSON(C.quality)), C.enabled !== void 0 && (x.enabled = C.enabled), x;
    },
    fromPartial(C) {
      var x, Q;
      const Se = Ne();
      return Se.quality = (x = C.quality) !== null && x !== void 0 ? x : 0, Se.enabled = (Q = C.enabled) !== null && Q !== void 0 ? Q : !1, Se;
    }
  };
  function Le() {
    return { codec: "", qualities: [] };
  }
  a.SubscribedCodec = {
    encode(C, x = l.default.Writer.create()) {
      if (C.codec !== void 0 && C.codec !== "" && x.uint32(10).string(C.codec), C.qualities !== void 0 && C.qualities.length !== 0)
        for (const Q of C.qualities)
          a.SubscribedQuality.encode(Q, x.uint32(18).fork()).ldelim();
      return x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = Le();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.codec = Q.string();
            break;
          case 2:
            me.qualities.push(a.SubscribedQuality.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        codec: Pe(C.codec) ? String(C.codec) : "",
        qualities: Array.isArray(C == null ? void 0 : C.qualities) ? C.qualities.map((x) => a.SubscribedQuality.fromJSON(x)) : []
      };
    },
    toJSON(C) {
      const x = {};
      return C.codec !== void 0 && (x.codec = C.codec), C.qualities ? x.qualities = C.qualities.map((Q) => Q ? a.SubscribedQuality.toJSON(Q) : void 0) : x.qualities = [], x;
    },
    fromPartial(C) {
      var x, Q;
      const Se = Le();
      return Se.codec = (x = C.codec) !== null && x !== void 0 ? x : "", Se.qualities = ((Q = C.qualities) === null || Q === void 0 ? void 0 : Q.map((me) => a.SubscribedQuality.fromPartial(me))) || [], Se;
    }
  };
  function $e() {
    return { trackSid: "", subscribedQualities: [], subscribedCodecs: [] };
  }
  a.SubscribedQualityUpdate = {
    encode(C, x = l.default.Writer.create()) {
      if (C.trackSid !== void 0 && C.trackSid !== "" && x.uint32(10).string(C.trackSid), C.subscribedQualities !== void 0 && C.subscribedQualities.length !== 0)
        for (const Q of C.subscribedQualities)
          a.SubscribedQuality.encode(Q, x.uint32(18).fork()).ldelim();
      if (C.subscribedCodecs !== void 0 && C.subscribedCodecs.length !== 0)
        for (const Q of C.subscribedCodecs)
          a.SubscribedCodec.encode(Q, x.uint32(26).fork()).ldelim();
      return x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = $e();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.trackSid = Q.string();
            break;
          case 2:
            me.subscribedQualities.push(a.SubscribedQuality.decode(Q, Q.uint32()));
            break;
          case 3:
            me.subscribedCodecs.push(a.SubscribedCodec.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        trackSid: Pe(C.trackSid) ? String(C.trackSid) : "",
        subscribedQualities: Array.isArray(C == null ? void 0 : C.subscribedQualities) ? C.subscribedQualities.map((x) => a.SubscribedQuality.fromJSON(x)) : [],
        subscribedCodecs: Array.isArray(C == null ? void 0 : C.subscribedCodecs) ? C.subscribedCodecs.map((x) => a.SubscribedCodec.fromJSON(x)) : []
      };
    },
    toJSON(C) {
      const x = {};
      return C.trackSid !== void 0 && (x.trackSid = C.trackSid), C.subscribedQualities ? x.subscribedQualities = C.subscribedQualities.map((Q) => Q ? a.SubscribedQuality.toJSON(Q) : void 0) : x.subscribedQualities = [], C.subscribedCodecs ? x.subscribedCodecs = C.subscribedCodecs.map((Q) => Q ? a.SubscribedCodec.toJSON(Q) : void 0) : x.subscribedCodecs = [], x;
    },
    fromPartial(C) {
      var x, Q, Se;
      const me = $e();
      return me.trackSid = (x = C.trackSid) !== null && x !== void 0 ? x : "", me.subscribedQualities = ((Q = C.subscribedQualities) === null || Q === void 0 ? void 0 : Q.map((Ie) => a.SubscribedQuality.fromPartial(Ie))) || [], me.subscribedCodecs = ((Se = C.subscribedCodecs) === null || Se === void 0 ? void 0 : Se.map((Ie) => a.SubscribedCodec.fromPartial(Ie))) || [], me;
    }
  };
  function Ue() {
    return { participantSid: "", allTracks: !1, trackSids: [], participantIdentity: "" };
  }
  a.TrackPermission = {
    encode(C, x = l.default.Writer.create()) {
      if (C.participantSid !== void 0 && C.participantSid !== "" && x.uint32(10).string(C.participantSid), C.allTracks === !0 && x.uint32(16).bool(C.allTracks), C.trackSids !== void 0 && C.trackSids.length !== 0)
        for (const Q of C.trackSids)
          x.uint32(26).string(Q);
      return C.participantIdentity !== void 0 && C.participantIdentity !== "" && x.uint32(34).string(C.participantIdentity), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = Ue();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.participantSid = Q.string();
            break;
          case 2:
            me.allTracks = Q.bool();
            break;
          case 3:
            me.trackSids.push(Q.string());
            break;
          case 4:
            me.participantIdentity = Q.string();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        participantSid: Pe(C.participantSid) ? String(C.participantSid) : "",
        allTracks: Pe(C.allTracks) ? !!C.allTracks : !1,
        trackSids: Array.isArray(C == null ? void 0 : C.trackSids) ? C.trackSids.map((x) => String(x)) : [],
        participantIdentity: Pe(C.participantIdentity) ? String(C.participantIdentity) : ""
      };
    },
    toJSON(C) {
      const x = {};
      return C.participantSid !== void 0 && (x.participantSid = C.participantSid), C.allTracks !== void 0 && (x.allTracks = C.allTracks), C.trackSids ? x.trackSids = C.trackSids.map((Q) => Q) : x.trackSids = [], C.participantIdentity !== void 0 && (x.participantIdentity = C.participantIdentity), x;
    },
    fromPartial(C) {
      var x, Q, Se, me;
      const Ie = Ue();
      return Ie.participantSid = (x = C.participantSid) !== null && x !== void 0 ? x : "", Ie.allTracks = (Q = C.allTracks) !== null && Q !== void 0 ? Q : !1, Ie.trackSids = ((Se = C.trackSids) === null || Se === void 0 ? void 0 : Se.map((at) => at)) || [], Ie.participantIdentity = (me = C.participantIdentity) !== null && me !== void 0 ? me : "", Ie;
    }
  };
  function Ge() {
    return { allParticipants: !1, trackPermissions: [] };
  }
  a.SubscriptionPermission = {
    encode(C, x = l.default.Writer.create()) {
      if (C.allParticipants === !0 && x.uint32(8).bool(C.allParticipants), C.trackPermissions !== void 0 && C.trackPermissions.length !== 0)
        for (const Q of C.trackPermissions)
          a.TrackPermission.encode(Q, x.uint32(18).fork()).ldelim();
      return x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = Ge();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.allParticipants = Q.bool();
            break;
          case 2:
            me.trackPermissions.push(a.TrackPermission.decode(Q, Q.uint32()));
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        allParticipants: Pe(C.allParticipants) ? !!C.allParticipants : !1,
        trackPermissions: Array.isArray(C == null ? void 0 : C.trackPermissions) ? C.trackPermissions.map((x) => a.TrackPermission.fromJSON(x)) : []
      };
    },
    toJSON(C) {
      const x = {};
      return C.allParticipants !== void 0 && (x.allParticipants = C.allParticipants), C.trackPermissions ? x.trackPermissions = C.trackPermissions.map((Q) => Q ? a.TrackPermission.toJSON(Q) : void 0) : x.trackPermissions = [], x;
    },
    fromPartial(C) {
      var x, Q;
      const Se = Ge();
      return Se.allParticipants = (x = C.allParticipants) !== null && x !== void 0 ? x : !1, Se.trackPermissions = ((Q = C.trackPermissions) === null || Q === void 0 ? void 0 : Q.map((me) => a.TrackPermission.fromPartial(me))) || [], Se;
    }
  };
  function He() {
    return { participantSid: "", trackSid: "", allowed: !1 };
  }
  a.SubscriptionPermissionUpdate = {
    encode(C, x = l.default.Writer.create()) {
      return C.participantSid !== void 0 && C.participantSid !== "" && x.uint32(10).string(C.participantSid), C.trackSid !== void 0 && C.trackSid !== "" && x.uint32(18).string(C.trackSid), C.allowed === !0 && x.uint32(24).bool(C.allowed), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = He();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.participantSid = Q.string();
            break;
          case 2:
            me.trackSid = Q.string();
            break;
          case 3:
            me.allowed = Q.bool();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        participantSid: Pe(C.participantSid) ? String(C.participantSid) : "",
        trackSid: Pe(C.trackSid) ? String(C.trackSid) : "",
        allowed: Pe(C.allowed) ? !!C.allowed : !1
      };
    },
    toJSON(C) {
      const x = {};
      return C.participantSid !== void 0 && (x.participantSid = C.participantSid), C.trackSid !== void 0 && (x.trackSid = C.trackSid), C.allowed !== void 0 && (x.allowed = C.allowed), x;
    },
    fromPartial(C) {
      var x, Q, Se;
      const me = He();
      return me.participantSid = (x = C.participantSid) !== null && x !== void 0 ? x : "", me.trackSid = (Q = C.trackSid) !== null && Q !== void 0 ? Q : "", me.allowed = (Se = C.allowed) !== null && Se !== void 0 ? Se : !1, me;
    }
  };
  function Ve() {
    return { answer: void 0, subscription: void 0, publishTracks: [], dataChannels: [], offer: void 0 };
  }
  a.SyncState = {
    encode(C, x = l.default.Writer.create()) {
      if (C.answer !== void 0 && a.SessionDescription.encode(C.answer, x.uint32(10).fork()).ldelim(), C.subscription !== void 0 && a.UpdateSubscription.encode(C.subscription, x.uint32(18).fork()).ldelim(), C.publishTracks !== void 0 && C.publishTracks.length !== 0)
        for (const Q of C.publishTracks)
          a.TrackPublishedResponse.encode(Q, x.uint32(26).fork()).ldelim();
      if (C.dataChannels !== void 0 && C.dataChannels.length !== 0)
        for (const Q of C.dataChannels)
          a.DataChannelInfo.encode(Q, x.uint32(34).fork()).ldelim();
      return C.offer !== void 0 && a.SessionDescription.encode(C.offer, x.uint32(42).fork()).ldelim(), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = Ve();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.answer = a.SessionDescription.decode(Q, Q.uint32());
            break;
          case 2:
            me.subscription = a.UpdateSubscription.decode(Q, Q.uint32());
            break;
          case 3:
            me.publishTracks.push(a.TrackPublishedResponse.decode(Q, Q.uint32()));
            break;
          case 4:
            me.dataChannels.push(a.DataChannelInfo.decode(Q, Q.uint32()));
            break;
          case 5:
            me.offer = a.SessionDescription.decode(Q, Q.uint32());
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        answer: Pe(C.answer) ? a.SessionDescription.fromJSON(C.answer) : void 0,
        subscription: Pe(C.subscription) ? a.UpdateSubscription.fromJSON(C.subscription) : void 0,
        publishTracks: Array.isArray(C == null ? void 0 : C.publishTracks) ? C.publishTracks.map((x) => a.TrackPublishedResponse.fromJSON(x)) : [],
        dataChannels: Array.isArray(C == null ? void 0 : C.dataChannels) ? C.dataChannels.map((x) => a.DataChannelInfo.fromJSON(x)) : [],
        offer: Pe(C.offer) ? a.SessionDescription.fromJSON(C.offer) : void 0
      };
    },
    toJSON(C) {
      const x = {};
      return C.answer !== void 0 && (x.answer = C.answer ? a.SessionDescription.toJSON(C.answer) : void 0), C.subscription !== void 0 && (x.subscription = C.subscription ? a.UpdateSubscription.toJSON(C.subscription) : void 0), C.publishTracks ? x.publishTracks = C.publishTracks.map((Q) => Q ? a.TrackPublishedResponse.toJSON(Q) : void 0) : x.publishTracks = [], C.dataChannels ? x.dataChannels = C.dataChannels.map((Q) => Q ? a.DataChannelInfo.toJSON(Q) : void 0) : x.dataChannels = [], C.offer !== void 0 && (x.offer = C.offer ? a.SessionDescription.toJSON(C.offer) : void 0), x;
    },
    fromPartial(C) {
      var x, Q;
      const Se = Ve();
      return Se.answer = C.answer !== void 0 && C.answer !== null ? a.SessionDescription.fromPartial(C.answer) : void 0, Se.subscription = C.subscription !== void 0 && C.subscription !== null ? a.UpdateSubscription.fromPartial(C.subscription) : void 0, Se.publishTracks = ((x = C.publishTracks) === null || x === void 0 ? void 0 : x.map((me) => a.TrackPublishedResponse.fromPartial(me))) || [], Se.dataChannels = ((Q = C.dataChannels) === null || Q === void 0 ? void 0 : Q.map((me) => a.DataChannelInfo.fromPartial(me))) || [], Se.offer = C.offer !== void 0 && C.offer !== null ? a.SessionDescription.fromPartial(C.offer) : void 0, Se;
    }
  };
  function be() {
    return { label: "", id: 0, target: 0 };
  }
  a.DataChannelInfo = {
    encode(C, x = l.default.Writer.create()) {
      return C.label !== void 0 && C.label !== "" && x.uint32(10).string(C.label), C.id !== void 0 && C.id !== 0 && x.uint32(16).uint32(C.id), C.target !== void 0 && C.target !== 0 && x.uint32(24).int32(C.target), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = be();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.label = Q.string();
            break;
          case 2:
            me.id = Q.uint32();
            break;
          case 3:
            me.target = Q.int32();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        label: Pe(C.label) ? String(C.label) : "",
        id: Pe(C.id) ? Number(C.id) : 0,
        target: Pe(C.target) ? g(C.target) : 0
      };
    },
    toJSON(C) {
      const x = {};
      return C.label !== void 0 && (x.label = C.label), C.id !== void 0 && (x.id = Math.round(C.id)), C.target !== void 0 && (x.target = E(C.target)), x;
    },
    fromPartial(C) {
      var x, Q, Se;
      const me = be();
      return me.label = (x = C.label) !== null && x !== void 0 ? x : "", me.id = (Q = C.id) !== null && Q !== void 0 ? Q : 0, me.target = (Se = C.target) !== null && Se !== void 0 ? Se : 0, me;
    }
  };
  function Ae() {
    return {
      speakerUpdate: void 0,
      nodeFailure: void 0,
      migration: void 0,
      serverLeave: void 0,
      switchCandidateProtocol: void 0
    };
  }
  a.SimulateScenario = {
    encode(C, x = l.default.Writer.create()) {
      return C.speakerUpdate !== void 0 && x.uint32(8).int32(C.speakerUpdate), C.nodeFailure !== void 0 && x.uint32(16).bool(C.nodeFailure), C.migration !== void 0 && x.uint32(24).bool(C.migration), C.serverLeave !== void 0 && x.uint32(32).bool(C.serverLeave), C.switchCandidateProtocol !== void 0 && x.uint32(40).int32(C.switchCandidateProtocol), x;
    },
    decode(C, x) {
      const Q = C instanceof l.default.Reader ? C : new l.default.Reader(C);
      let Se = x === void 0 ? Q.len : Q.pos + x;
      const me = Ae();
      for (; Q.pos < Se; ) {
        const Ie = Q.uint32();
        switch (Ie >>> 3) {
          case 1:
            me.speakerUpdate = Q.int32();
            break;
          case 2:
            me.nodeFailure = Q.bool();
            break;
          case 3:
            me.migration = Q.bool();
            break;
          case 4:
            me.serverLeave = Q.bool();
            break;
          case 5:
            me.switchCandidateProtocol = Q.int32();
            break;
          default:
            Q.skipType(Ie & 7);
            break;
        }
      }
      return me;
    },
    fromJSON(C) {
      return {
        speakerUpdate: Pe(C.speakerUpdate) ? Number(C.speakerUpdate) : void 0,
        nodeFailure: Pe(C.nodeFailure) ? !!C.nodeFailure : void 0,
        migration: Pe(C.migration) ? !!C.migration : void 0,
        serverLeave: Pe(C.serverLeave) ? !!C.serverLeave : void 0,
        switchCandidateProtocol: Pe(C.switchCandidateProtocol) ? $(C.switchCandidateProtocol) : void 0
      };
    },
    toJSON(C) {
      const x = {};
      return C.speakerUpdate !== void 0 && (x.speakerUpdate = Math.round(C.speakerUpdate)), C.nodeFailure !== void 0 && (x.nodeFailure = C.nodeFailure), C.migration !== void 0 && (x.migration = C.migration), C.serverLeave !== void 0 && (x.serverLeave = C.serverLeave), C.switchCandidateProtocol !== void 0 && (x.switchCandidateProtocol = C.switchCandidateProtocol !== void 0 ? J(C.switchCandidateProtocol) : void 0), x;
    },
    fromPartial(C) {
      var x, Q, Se, me, Ie;
      const at = Ae();
      return at.speakerUpdate = (x = C.speakerUpdate) !== null && x !== void 0 ? x : void 0, at.nodeFailure = (Q = C.nodeFailure) !== null && Q !== void 0 ? Q : void 0, at.migration = (Se = C.migration) !== null && Se !== void 0 ? Se : void 0, at.serverLeave = (me = C.serverLeave) !== null && me !== void 0 ? me : void 0, at.switchCandidateProtocol = (Ie = C.switchCandidateProtocol) !== null && Ie !== void 0 ? Ie : void 0, at;
    }
  };
  var qe = (() => {
    if (typeof qe < "u")
      return qe;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function xe(C) {
    if (C.gt(Number.MAX_SAFE_INTEGER))
      throw new qe.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return C.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function Pe(C) {
    return C != null;
  }
})(livekit_rtc);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(N) {
    return N && N.__esModule ? N : { default: N };
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.RoomInternal = a.KeepAlive = a.RemoveParticipant = a.EndSession = a.StartSession = a.SignalNodeMessage = a.RTCNodeMessage = a.NodeStats = a.Node = a.nodeStateToJSON = a.nodeStateFromJSON = a.NodeState = a.nodeTypeToJSON = a.nodeTypeFromJSON = a.NodeType = a.protobufPackage = void 0;
  const c = u(umdExports), l = u(minimal), v = livekit_egress, S = livekit_models, g = livekit_room, E = livekit_rtc;
  a.protobufPackage = "livekit";
  var _;
  (function(N) {
    N[N.SERVER = 0] = "SERVER", N[N.CONTROLLER = 1] = "CONTROLLER", N[N.MEDIA = 2] = "MEDIA", N[N.TURN = 4] = "TURN", N[N.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(_ = a.NodeType || (a.NodeType = {}));
  function k(N) {
    switch (N) {
      case 0:
      case "SERVER":
        return _.SERVER;
      case 1:
      case "CONTROLLER":
        return _.CONTROLLER;
      case 2:
      case "MEDIA":
        return _.MEDIA;
      case 4:
      case "TURN":
        return _.TURN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return _.UNRECOGNIZED;
    }
  }
  a.nodeTypeFromJSON = k;
  function L(N) {
    switch (N) {
      case _.SERVER:
        return "SERVER";
      case _.CONTROLLER:
        return "CONTROLLER";
      case _.MEDIA:
        return "MEDIA";
      case _.TURN:
        return "TURN";
      case _.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.nodeTypeToJSON = L;
  var M;
  (function(N) {
    N[N.STARTING_UP = 0] = "STARTING_UP", N[N.SERVING = 1] = "SERVING", N[N.SHUTTING_DOWN = 2] = "SHUTTING_DOWN", N[N.UNRECOGNIZED = -1] = "UNRECOGNIZED";
  })(M = a.NodeState || (a.NodeState = {}));
  function $(N) {
    switch (N) {
      case 0:
      case "STARTING_UP":
        return M.STARTING_UP;
      case 1:
      case "SERVING":
        return M.SERVING;
      case 2:
      case "SHUTTING_DOWN":
        return M.SHUTTING_DOWN;
      case -1:
      case "UNRECOGNIZED":
      default:
        return M.UNRECOGNIZED;
    }
  }
  a.nodeStateFromJSON = $;
  function J(N) {
    switch (N) {
      case M.STARTING_UP:
        return "STARTING_UP";
      case M.SERVING:
        return "SERVING";
      case M.SHUTTING_DOWN:
        return "SHUTTING_DOWN";
      case M.UNRECOGNIZED:
      default:
        return "UNRECOGNIZED";
    }
  }
  a.nodeStateToJSON = J;
  function V() {
    return { id: "", ip: "", numCpus: 0, stats: void 0, type: 0, state: 0, region: "" };
  }
  a.Node = {
    encode(N, D = l.default.Writer.create()) {
      return N.id !== void 0 && N.id !== "" && D.uint32(10).string(N.id), N.ip !== void 0 && N.ip !== "" && D.uint32(18).string(N.ip), N.numCpus !== void 0 && N.numCpus !== 0 && D.uint32(24).uint32(N.numCpus), N.stats !== void 0 && a.NodeStats.encode(N.stats, D.uint32(34).fork()).ldelim(), N.type !== void 0 && N.type !== 0 && D.uint32(40).int32(N.type), N.state !== void 0 && N.state !== 0 && D.uint32(48).int32(N.state), N.region !== void 0 && N.region !== "" && D.uint32(58).string(N.region), D;
    },
    decode(N, D) {
      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let ee = D === void 0 ? W.len : W.pos + D;
      const ae = V();
      for (; W.pos < ee; ) {
        const ye = W.uint32();
        switch (ye >>> 3) {
          case 1:
            ae.id = W.string();
            break;
          case 2:
            ae.ip = W.string();
            break;
          case 3:
            ae.numCpus = W.uint32();
            break;
          case 4:
            ae.stats = a.NodeStats.decode(W, W.uint32());
            break;
          case 5:
            ae.type = W.int32();
            break;
          case 6:
            ae.state = W.int32();
            break;
          case 7:
            ae.region = W.string();
            break;
          default:
            W.skipType(ye & 7);
            break;
        }
      }
      return ae;
    },
    fromJSON(N) {
      return {
        id: A(N.id) ? String(N.id) : "",
        ip: A(N.ip) ? String(N.ip) : "",
        numCpus: A(N.numCpus) ? Number(N.numCpus) : 0,
        stats: A(N.stats) ? a.NodeStats.fromJSON(N.stats) : void 0,
        type: A(N.type) ? k(N.type) : 0,
        state: A(N.state) ? $(N.state) : 0,
        region: A(N.region) ? String(N.region) : ""
      };
    },
    toJSON(N) {
      const D = {};
      return N.id !== void 0 && (D.id = N.id), N.ip !== void 0 && (D.ip = N.ip), N.numCpus !== void 0 && (D.numCpus = Math.round(N.numCpus)), N.stats !== void 0 && (D.stats = N.stats ? a.NodeStats.toJSON(N.stats) : void 0), N.type !== void 0 && (D.type = L(N.type)), N.state !== void 0 && (D.state = J(N.state)), N.region !== void 0 && (D.region = N.region), D;
    },
    fromPartial(N) {
      var D, W, ee, ae, ye, he;
      const le = V();
      return le.id = (D = N.id) !== null && D !== void 0 ? D : "", le.ip = (W = N.ip) !== null && W !== void 0 ? W : "", le.numCpus = (ee = N.numCpus) !== null && ee !== void 0 ? ee : 0, le.stats = N.stats !== void 0 && N.stats !== null ? a.NodeStats.fromPartial(N.stats) : void 0, le.type = (ae = N.type) !== null && ae !== void 0 ? ae : 0, le.state = (ye = N.state) !== null && ye !== void 0 ? ye : 0, le.region = (he = N.region) !== null && he !== void 0 ? he : "", le;
    }
  };
  function q() {
    return {
      startedAt: 0,
      updatedAt: 0,
      numRooms: 0,
      numClients: 0,
      numTracksIn: 0,
      numTracksOut: 0,
      bytesIn: 0,
      bytesOut: 0,
      packetsIn: 0,
      packetsOut: 0,
      nackTotal: 0,
      bytesInPerSec: 0,
      bytesOutPerSec: 0,
      packetsInPerSec: 0,
      packetsOutPerSec: 0,
      nackPerSec: 0,
      numCpus: 0,
      loadAvgLast1min: 0,
      loadAvgLast5min: 0,
      loadAvgLast15min: 0,
      cpuLoad: 0,
      memoryLoad: 0,
      sysPacketsOut: 0,
      sysPacketsDropped: 0,
      sysPacketsOutPerSec: 0,
      sysPacketsDroppedPerSec: 0,
      sysPacketsDroppedPctPerSec: 0,
      retransmitBytesOut: 0,
      retransmitPacketsOut: 0,
      retransmitBytesOutPerSec: 0,
      retransmitPacketsOutPerSec: 0,
      participantJoin: 0,
      participantJoinPerSec: 0
    };
  }
  a.NodeStats = {
    encode(N, D = l.default.Writer.create()) {
      return N.startedAt !== void 0 && N.startedAt !== 0 && D.uint32(8).int64(N.startedAt), N.updatedAt !== void 0 && N.updatedAt !== 0 && D.uint32(16).int64(N.updatedAt), N.numRooms !== void 0 && N.numRooms !== 0 && D.uint32(24).int32(N.numRooms), N.numClients !== void 0 && N.numClients !== 0 && D.uint32(32).int32(N.numClients), N.numTracksIn !== void 0 && N.numTracksIn !== 0 && D.uint32(40).int32(N.numTracksIn), N.numTracksOut !== void 0 && N.numTracksOut !== 0 && D.uint32(48).int32(N.numTracksOut), N.bytesIn !== void 0 && N.bytesIn !== 0 && D.uint32(56).uint64(N.bytesIn), N.bytesOut !== void 0 && N.bytesOut !== 0 && D.uint32(64).uint64(N.bytesOut), N.packetsIn !== void 0 && N.packetsIn !== 0 && D.uint32(72).uint64(N.packetsIn), N.packetsOut !== void 0 && N.packetsOut !== 0 && D.uint32(80).uint64(N.packetsOut), N.nackTotal !== void 0 && N.nackTotal !== 0 && D.uint32(88).uint64(N.nackTotal), N.bytesInPerSec !== void 0 && N.bytesInPerSec !== 0 && D.uint32(101).float(N.bytesInPerSec), N.bytesOutPerSec !== void 0 && N.bytesOutPerSec !== 0 && D.uint32(109).float(N.bytesOutPerSec), N.packetsInPerSec !== void 0 && N.packetsInPerSec !== 0 && D.uint32(117).float(N.packetsInPerSec), N.packetsOutPerSec !== void 0 && N.packetsOutPerSec !== 0 && D.uint32(125).float(N.packetsOutPerSec), N.nackPerSec !== void 0 && N.nackPerSec !== 0 && D.uint32(133).float(N.nackPerSec), N.numCpus !== void 0 && N.numCpus !== 0 && D.uint32(136).uint32(N.numCpus), N.loadAvgLast1min !== void 0 && N.loadAvgLast1min !== 0 && D.uint32(149).float(N.loadAvgLast1min), N.loadAvgLast5min !== void 0 && N.loadAvgLast5min !== 0 && D.uint32(157).float(N.loadAvgLast5min), N.loadAvgLast15min !== void 0 && N.loadAvgLast15min !== 0 && D.uint32(165).float(N.loadAvgLast15min), N.cpuLoad !== void 0 && N.cpuLoad !== 0 && D.uint32(173).float(N.cpuLoad), N.memoryLoad !== void 0 && N.memoryLoad !== 0 && D.uint32(269).float(N.memoryLoad), N.sysPacketsOut !== void 0 && N.sysPacketsOut !== 0 && D.uint32(224).uint32(N.sysPacketsOut), N.sysPacketsDropped !== void 0 && N.sysPacketsDropped !== 0 && D.uint32(232).uint32(N.sysPacketsDropped), N.sysPacketsOutPerSec !== void 0 && N.sysPacketsOutPerSec !== 0 && D.uint32(245).float(N.sysPacketsOutPerSec), N.sysPacketsDroppedPerSec !== void 0 && N.sysPacketsDroppedPerSec !== 0 && D.uint32(253).float(N.sysPacketsDroppedPerSec), N.sysPacketsDroppedPctPerSec !== void 0 && N.sysPacketsDroppedPctPerSec !== 0 && D.uint32(261).float(N.sysPacketsDroppedPctPerSec), N.retransmitBytesOut !== void 0 && N.retransmitBytesOut !== 0 && D.uint32(176).uint64(N.retransmitBytesOut), N.retransmitPacketsOut !== void 0 && N.retransmitPacketsOut !== 0 && D.uint32(184).uint64(N.retransmitPacketsOut), N.retransmitBytesOutPerSec !== void 0 && N.retransmitBytesOutPerSec !== 0 && D.uint32(197).float(N.retransmitBytesOutPerSec), N.retransmitPacketsOutPerSec !== void 0 && N.retransmitPacketsOutPerSec !== 0 && D.uint32(205).float(N.retransmitPacketsOutPerSec), N.participantJoin !== void 0 && N.participantJoin !== 0 && D.uint32(208).uint64(N.participantJoin), N.participantJoinPerSec !== void 0 && N.participantJoinPerSec !== 0 && D.uint32(221).float(N.participantJoinPerSec), D;
    },
    decode(N, D) {
      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let ee = D === void 0 ? W.len : W.pos + D;
      const ae = q();
      for (; W.pos < ee; ) {
        const ye = W.uint32();
        switch (ye >>> 3) {
          case 1:
            ae.startedAt = de(W.int64());
            break;
          case 2:
            ae.updatedAt = de(W.int64());
            break;
          case 3:
            ae.numRooms = W.int32();
            break;
          case 4:
            ae.numClients = W.int32();
            break;
          case 5:
            ae.numTracksIn = W.int32();
            break;
          case 6:
            ae.numTracksOut = W.int32();
            break;
          case 7:
            ae.bytesIn = de(W.uint64());
            break;
          case 8:
            ae.bytesOut = de(W.uint64());
            break;
          case 9:
            ae.packetsIn = de(W.uint64());
            break;
          case 10:
            ae.packetsOut = de(W.uint64());
            break;
          case 11:
            ae.nackTotal = de(W.uint64());
            break;
          case 12:
            ae.bytesInPerSec = W.float();
            break;
          case 13:
            ae.bytesOutPerSec = W.float();
            break;
          case 14:
            ae.packetsInPerSec = W.float();
            break;
          case 15:
            ae.packetsOutPerSec = W.float();
            break;
          case 16:
            ae.nackPerSec = W.float();
            break;
          case 17:
            ae.numCpus = W.uint32();
            break;
          case 18:
            ae.loadAvgLast1min = W.float();
            break;
          case 19:
            ae.loadAvgLast5min = W.float();
            break;
          case 20:
            ae.loadAvgLast15min = W.float();
            break;
          case 21:
            ae.cpuLoad = W.float();
            break;
          case 33:
            ae.memoryLoad = W.float();
            break;
          case 28:
            ae.sysPacketsOut = W.uint32();
            break;
          case 29:
            ae.sysPacketsDropped = W.uint32();
            break;
          case 30:
            ae.sysPacketsOutPerSec = W.float();
            break;
          case 31:
            ae.sysPacketsDroppedPerSec = W.float();
            break;
          case 32:
            ae.sysPacketsDroppedPctPerSec = W.float();
            break;
          case 22:
            ae.retransmitBytesOut = de(W.uint64());
            break;
          case 23:
            ae.retransmitPacketsOut = de(W.uint64());
            break;
          case 24:
            ae.retransmitBytesOutPerSec = W.float();
            break;
          case 25:
            ae.retransmitPacketsOutPerSec = W.float();
            break;
          case 26:
            ae.participantJoin = de(W.uint64());
            break;
          case 27:
            ae.participantJoinPerSec = W.float();
            break;
          default:
            W.skipType(ye & 7);
            break;
        }
      }
      return ae;
    },
    fromJSON(N) {
      return {
        startedAt: A(N.startedAt) ? Number(N.startedAt) : 0,
        updatedAt: A(N.updatedAt) ? Number(N.updatedAt) : 0,
        numRooms: A(N.numRooms) ? Number(N.numRooms) : 0,
        numClients: A(N.numClients) ? Number(N.numClients) : 0,
        numTracksIn: A(N.numTracksIn) ? Number(N.numTracksIn) : 0,
        numTracksOut: A(N.numTracksOut) ? Number(N.numTracksOut) : 0,
        bytesIn: A(N.bytesIn) ? Number(N.bytesIn) : 0,
        bytesOut: A(N.bytesOut) ? Number(N.bytesOut) : 0,
        packetsIn: A(N.packetsIn) ? Number(N.packetsIn) : 0,
        packetsOut: A(N.packetsOut) ? Number(N.packetsOut) : 0,
        nackTotal: A(N.nackTotal) ? Number(N.nackTotal) : 0,
        bytesInPerSec: A(N.bytesInPerSec) ? Number(N.bytesInPerSec) : 0,
        bytesOutPerSec: A(N.bytesOutPerSec) ? Number(N.bytesOutPerSec) : 0,
        packetsInPerSec: A(N.packetsInPerSec) ? Number(N.packetsInPerSec) : 0,
        packetsOutPerSec: A(N.packetsOutPerSec) ? Number(N.packetsOutPerSec) : 0,
        nackPerSec: A(N.nackPerSec) ? Number(N.nackPerSec) : 0,
        numCpus: A(N.numCpus) ? Number(N.numCpus) : 0,
        loadAvgLast1min: A(N.loadAvgLast1min) ? Number(N.loadAvgLast1min) : 0,
        loadAvgLast5min: A(N.loadAvgLast5min) ? Number(N.loadAvgLast5min) : 0,
        loadAvgLast15min: A(N.loadAvgLast15min) ? Number(N.loadAvgLast15min) : 0,
        cpuLoad: A(N.cpuLoad) ? Number(N.cpuLoad) : 0,
        memoryLoad: A(N.memoryLoad) ? Number(N.memoryLoad) : 0,
        sysPacketsOut: A(N.sysPacketsOut) ? Number(N.sysPacketsOut) : 0,
        sysPacketsDropped: A(N.sysPacketsDropped) ? Number(N.sysPacketsDropped) : 0,
        sysPacketsOutPerSec: A(N.sysPacketsOutPerSec) ? Number(N.sysPacketsOutPerSec) : 0,
        sysPacketsDroppedPerSec: A(N.sysPacketsDroppedPerSec) ? Number(N.sysPacketsDroppedPerSec) : 0,
        sysPacketsDroppedPctPerSec: A(N.sysPacketsDroppedPctPerSec) ? Number(N.sysPacketsDroppedPctPerSec) : 0,
        retransmitBytesOut: A(N.retransmitBytesOut) ? Number(N.retransmitBytesOut) : 0,
        retransmitPacketsOut: A(N.retransmitPacketsOut) ? Number(N.retransmitPacketsOut) : 0,
        retransmitBytesOutPerSec: A(N.retransmitBytesOutPerSec) ? Number(N.retransmitBytesOutPerSec) : 0,
        retransmitPacketsOutPerSec: A(N.retransmitPacketsOutPerSec) ? Number(N.retransmitPacketsOutPerSec) : 0,
        participantJoin: A(N.participantJoin) ? Number(N.participantJoin) : 0,
        participantJoinPerSec: A(N.participantJoinPerSec) ? Number(N.participantJoinPerSec) : 0
      };
    },
    toJSON(N) {
      const D = {};
      return N.startedAt !== void 0 && (D.startedAt = Math.round(N.startedAt)), N.updatedAt !== void 0 && (D.updatedAt = Math.round(N.updatedAt)), N.numRooms !== void 0 && (D.numRooms = Math.round(N.numRooms)), N.numClients !== void 0 && (D.numClients = Math.round(N.numClients)), N.numTracksIn !== void 0 && (D.numTracksIn = Math.round(N.numTracksIn)), N.numTracksOut !== void 0 && (D.numTracksOut = Math.round(N.numTracksOut)), N.bytesIn !== void 0 && (D.bytesIn = Math.round(N.bytesIn)), N.bytesOut !== void 0 && (D.bytesOut = Math.round(N.bytesOut)), N.packetsIn !== void 0 && (D.packetsIn = Math.round(N.packetsIn)), N.packetsOut !== void 0 && (D.packetsOut = Math.round(N.packetsOut)), N.nackTotal !== void 0 && (D.nackTotal = Math.round(N.nackTotal)), N.bytesInPerSec !== void 0 && (D.bytesInPerSec = N.bytesInPerSec), N.bytesOutPerSec !== void 0 && (D.bytesOutPerSec = N.bytesOutPerSec), N.packetsInPerSec !== void 0 && (D.packetsInPerSec = N.packetsInPerSec), N.packetsOutPerSec !== void 0 && (D.packetsOutPerSec = N.packetsOutPerSec), N.nackPerSec !== void 0 && (D.nackPerSec = N.nackPerSec), N.numCpus !== void 0 && (D.numCpus = Math.round(N.numCpus)), N.loadAvgLast1min !== void 0 && (D.loadAvgLast1min = N.loadAvgLast1min), N.loadAvgLast5min !== void 0 && (D.loadAvgLast5min = N.loadAvgLast5min), N.loadAvgLast15min !== void 0 && (D.loadAvgLast15min = N.loadAvgLast15min), N.cpuLoad !== void 0 && (D.cpuLoad = N.cpuLoad), N.memoryLoad !== void 0 && (D.memoryLoad = N.memoryLoad), N.sysPacketsOut !== void 0 && (D.sysPacketsOut = Math.round(N.sysPacketsOut)), N.sysPacketsDropped !== void 0 && (D.sysPacketsDropped = Math.round(N.sysPacketsDropped)), N.sysPacketsOutPerSec !== void 0 && (D.sysPacketsOutPerSec = N.sysPacketsOutPerSec), N.sysPacketsDroppedPerSec !== void 0 && (D.sysPacketsDroppedPerSec = N.sysPacketsDroppedPerSec), N.sysPacketsDroppedPctPerSec !== void 0 && (D.sysPacketsDroppedPctPerSec = N.sysPacketsDroppedPctPerSec), N.retransmitBytesOut !== void 0 && (D.retransmitBytesOut = Math.round(N.retransmitBytesOut)), N.retransmitPacketsOut !== void 0 && (D.retransmitPacketsOut = Math.round(N.retransmitPacketsOut)), N.retransmitBytesOutPerSec !== void 0 && (D.retransmitBytesOutPerSec = N.retransmitBytesOutPerSec), N.retransmitPacketsOutPerSec !== void 0 && (D.retransmitPacketsOutPerSec = N.retransmitPacketsOutPerSec), N.participantJoin !== void 0 && (D.participantJoin = Math.round(N.participantJoin)), N.participantJoinPerSec !== void 0 && (D.participantJoinPerSec = N.participantJoinPerSec), D;
    },
    fromPartial(N) {
      var D, W, ee, ae, ye, he, le, we, Be, Ne, Le, $e, Ue, Ge, He, Ve, be, Ae, qe, xe, Pe, C, x, Q, Se, me, Ie, at, Ye, je, tt, Oe, P;
      const X = q();
      return X.startedAt = (D = N.startedAt) !== null && D !== void 0 ? D : 0, X.updatedAt = (W = N.updatedAt) !== null && W !== void 0 ? W : 0, X.numRooms = (ee = N.numRooms) !== null && ee !== void 0 ? ee : 0, X.numClients = (ae = N.numClients) !== null && ae !== void 0 ? ae : 0, X.numTracksIn = (ye = N.numTracksIn) !== null && ye !== void 0 ? ye : 0, X.numTracksOut = (he = N.numTracksOut) !== null && he !== void 0 ? he : 0, X.bytesIn = (le = N.bytesIn) !== null && le !== void 0 ? le : 0, X.bytesOut = (we = N.bytesOut) !== null && we !== void 0 ? we : 0, X.packetsIn = (Be = N.packetsIn) !== null && Be !== void 0 ? Be : 0, X.packetsOut = (Ne = N.packetsOut) !== null && Ne !== void 0 ? Ne : 0, X.nackTotal = (Le = N.nackTotal) !== null && Le !== void 0 ? Le : 0, X.bytesInPerSec = ($e = N.bytesInPerSec) !== null && $e !== void 0 ? $e : 0, X.bytesOutPerSec = (Ue = N.bytesOutPerSec) !== null && Ue !== void 0 ? Ue : 0, X.packetsInPerSec = (Ge = N.packetsInPerSec) !== null && Ge !== void 0 ? Ge : 0, X.packetsOutPerSec = (He = N.packetsOutPerSec) !== null && He !== void 0 ? He : 0, X.nackPerSec = (Ve = N.nackPerSec) !== null && Ve !== void 0 ? Ve : 0, X.numCpus = (be = N.numCpus) !== null && be !== void 0 ? be : 0, X.loadAvgLast1min = (Ae = N.loadAvgLast1min) !== null && Ae !== void 0 ? Ae : 0, X.loadAvgLast5min = (qe = N.loadAvgLast5min) !== null && qe !== void 0 ? qe : 0, X.loadAvgLast15min = (xe = N.loadAvgLast15min) !== null && xe !== void 0 ? xe : 0, X.cpuLoad = (Pe = N.cpuLoad) !== null && Pe !== void 0 ? Pe : 0, X.memoryLoad = (C = N.memoryLoad) !== null && C !== void 0 ? C : 0, X.sysPacketsOut = (x = N.sysPacketsOut) !== null && x !== void 0 ? x : 0, X.sysPacketsDropped = (Q = N.sysPacketsDropped) !== null && Q !== void 0 ? Q : 0, X.sysPacketsOutPerSec = (Se = N.sysPacketsOutPerSec) !== null && Se !== void 0 ? Se : 0, X.sysPacketsDroppedPerSec = (me = N.sysPacketsDroppedPerSec) !== null && me !== void 0 ? me : 0, X.sysPacketsDroppedPctPerSec = (Ie = N.sysPacketsDroppedPctPerSec) !== null && Ie !== void 0 ? Ie : 0, X.retransmitBytesOut = (at = N.retransmitBytesOut) !== null && at !== void 0 ? at : 0, X.retransmitPacketsOut = (Ye = N.retransmitPacketsOut) !== null && Ye !== void 0 ? Ye : 0, X.retransmitBytesOutPerSec = (je = N.retransmitBytesOutPerSec) !== null && je !== void 0 ? je : 0, X.retransmitPacketsOutPerSec = (tt = N.retransmitPacketsOutPerSec) !== null && tt !== void 0 ? tt : 0, X.participantJoin = (Oe = N.participantJoin) !== null && Oe !== void 0 ? Oe : 0, X.participantJoinPerSec = (P = N.participantJoinPerSec) !== null && P !== void 0 ? P : 0, X;
    }
  };
  function G() {
    return {
      participantKey: "",
      senderTime: 0,
      connectionId: "",
      startSession: void 0,
      request: void 0,
      removeParticipant: void 0,
      muteTrack: void 0,
      updateParticipant: void 0,
      deleteRoom: void 0,
      updateSubscriptions: void 0,
      sendData: void 0,
      updateRoomMetadata: void 0,
      keepAlive: void 0
    };
  }
  a.RTCNodeMessage = {
    encode(N, D = l.default.Writer.create()) {
      return N.participantKey !== void 0 && N.participantKey !== "" && D.uint32(10).string(N.participantKey), N.senderTime !== void 0 && N.senderTime !== 0 && D.uint32(88).int64(N.senderTime), N.connectionId !== void 0 && N.connectionId !== "" && D.uint32(106).string(N.connectionId), N.startSession !== void 0 && a.StartSession.encode(N.startSession, D.uint32(18).fork()).ldelim(), N.request !== void 0 && E.SignalRequest.encode(N.request, D.uint32(26).fork()).ldelim(), N.removeParticipant !== void 0 && g.RoomParticipantIdentity.encode(N.removeParticipant, D.uint32(34).fork()).ldelim(), N.muteTrack !== void 0 && g.MuteRoomTrackRequest.encode(N.muteTrack, D.uint32(42).fork()).ldelim(), N.updateParticipant !== void 0 && g.UpdateParticipantRequest.encode(N.updateParticipant, D.uint32(50).fork()).ldelim(), N.deleteRoom !== void 0 && g.DeleteRoomRequest.encode(N.deleteRoom, D.uint32(58).fork()).ldelim(), N.updateSubscriptions !== void 0 && g.UpdateSubscriptionsRequest.encode(N.updateSubscriptions, D.uint32(66).fork()).ldelim(), N.sendData !== void 0 && g.SendDataRequest.encode(N.sendData, D.uint32(74).fork()).ldelim(), N.updateRoomMetadata !== void 0 && g.UpdateRoomMetadataRequest.encode(N.updateRoomMetadata, D.uint32(82).fork()).ldelim(), N.keepAlive !== void 0 && a.KeepAlive.encode(N.keepAlive, D.uint32(98).fork()).ldelim(), D;
    },
    decode(N, D) {
      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let ee = D === void 0 ? W.len : W.pos + D;
      const ae = G();
      for (; W.pos < ee; ) {
        const ye = W.uint32();
        switch (ye >>> 3) {
          case 1:
            ae.participantKey = W.string();
            break;
          case 11:
            ae.senderTime = de(W.int64());
            break;
          case 13:
            ae.connectionId = W.string();
            break;
          case 2:
            ae.startSession = a.StartSession.decode(W, W.uint32());
            break;
          case 3:
            ae.request = E.SignalRequest.decode(W, W.uint32());
            break;
          case 4:
            ae.removeParticipant = g.RoomParticipantIdentity.decode(W, W.uint32());
            break;
          case 5:
            ae.muteTrack = g.MuteRoomTrackRequest.decode(W, W.uint32());
            break;
          case 6:
            ae.updateParticipant = g.UpdateParticipantRequest.decode(W, W.uint32());
            break;
          case 7:
            ae.deleteRoom = g.DeleteRoomRequest.decode(W, W.uint32());
            break;
          case 8:
            ae.updateSubscriptions = g.UpdateSubscriptionsRequest.decode(W, W.uint32());
            break;
          case 9:
            ae.sendData = g.SendDataRequest.decode(W, W.uint32());
            break;
          case 10:
            ae.updateRoomMetadata = g.UpdateRoomMetadataRequest.decode(W, W.uint32());
            break;
          case 12:
            ae.keepAlive = a.KeepAlive.decode(W, W.uint32());
            break;
          default:
            W.skipType(ye & 7);
            break;
        }
      }
      return ae;
    },
    fromJSON(N) {
      return {
        participantKey: A(N.participantKey) ? String(N.participantKey) : "",
        senderTime: A(N.senderTime) ? Number(N.senderTime) : 0,
        connectionId: A(N.connectionId) ? String(N.connectionId) : "",
        startSession: A(N.startSession) ? a.StartSession.fromJSON(N.startSession) : void 0,
        request: A(N.request) ? E.SignalRequest.fromJSON(N.request) : void 0,
        removeParticipant: A(N.removeParticipant) ? g.RoomParticipantIdentity.fromJSON(N.removeParticipant) : void 0,
        muteTrack: A(N.muteTrack) ? g.MuteRoomTrackRequest.fromJSON(N.muteTrack) : void 0,
        updateParticipant: A(N.updateParticipant) ? g.UpdateParticipantRequest.fromJSON(N.updateParticipant) : void 0,
        deleteRoom: A(N.deleteRoom) ? g.DeleteRoomRequest.fromJSON(N.deleteRoom) : void 0,
        updateSubscriptions: A(N.updateSubscriptions) ? g.UpdateSubscriptionsRequest.fromJSON(N.updateSubscriptions) : void 0,
        sendData: A(N.sendData) ? g.SendDataRequest.fromJSON(N.sendData) : void 0,
        updateRoomMetadata: A(N.updateRoomMetadata) ? g.UpdateRoomMetadataRequest.fromJSON(N.updateRoomMetadata) : void 0,
        keepAlive: A(N.keepAlive) ? a.KeepAlive.fromJSON(N.keepAlive) : void 0
      };
    },
    toJSON(N) {
      const D = {};
      return N.participantKey !== void 0 && (D.participantKey = N.participantKey), N.senderTime !== void 0 && (D.senderTime = Math.round(N.senderTime)), N.connectionId !== void 0 && (D.connectionId = N.connectionId), N.startSession !== void 0 && (D.startSession = N.startSession ? a.StartSession.toJSON(N.startSession) : void 0), N.request !== void 0 && (D.request = N.request ? E.SignalRequest.toJSON(N.request) : void 0), N.removeParticipant !== void 0 && (D.removeParticipant = N.removeParticipant ? g.RoomParticipantIdentity.toJSON(N.removeParticipant) : void 0), N.muteTrack !== void 0 && (D.muteTrack = N.muteTrack ? g.MuteRoomTrackRequest.toJSON(N.muteTrack) : void 0), N.updateParticipant !== void 0 && (D.updateParticipant = N.updateParticipant ? g.UpdateParticipantRequest.toJSON(N.updateParticipant) : void 0), N.deleteRoom !== void 0 && (D.deleteRoom = N.deleteRoom ? g.DeleteRoomRequest.toJSON(N.deleteRoom) : void 0), N.updateSubscriptions !== void 0 && (D.updateSubscriptions = N.updateSubscriptions ? g.UpdateSubscriptionsRequest.toJSON(N.updateSubscriptions) : void 0), N.sendData !== void 0 && (D.sendData = N.sendData ? g.SendDataRequest.toJSON(N.sendData) : void 0), N.updateRoomMetadata !== void 0 && (D.updateRoomMetadata = N.updateRoomMetadata ? g.UpdateRoomMetadataRequest.toJSON(N.updateRoomMetadata) : void 0), N.keepAlive !== void 0 && (D.keepAlive = N.keepAlive ? a.KeepAlive.toJSON(N.keepAlive) : void 0), D;
    },
    fromPartial(N) {
      var D, W, ee;
      const ae = G();
      return ae.participantKey = (D = N.participantKey) !== null && D !== void 0 ? D : "", ae.senderTime = (W = N.senderTime) !== null && W !== void 0 ? W : 0, ae.connectionId = (ee = N.connectionId) !== null && ee !== void 0 ? ee : "", ae.startSession = N.startSession !== void 0 && N.startSession !== null ? a.StartSession.fromPartial(N.startSession) : void 0, ae.request = N.request !== void 0 && N.request !== null ? E.SignalRequest.fromPartial(N.request) : void 0, ae.removeParticipant = N.removeParticipant !== void 0 && N.removeParticipant !== null ? g.RoomParticipantIdentity.fromPartial(N.removeParticipant) : void 0, ae.muteTrack = N.muteTrack !== void 0 && N.muteTrack !== null ? g.MuteRoomTrackRequest.fromPartial(N.muteTrack) : void 0, ae.updateParticipant = N.updateParticipant !== void 0 && N.updateParticipant !== null ? g.UpdateParticipantRequest.fromPartial(N.updateParticipant) : void 0, ae.deleteRoom = N.deleteRoom !== void 0 && N.deleteRoom !== null ? g.DeleteRoomRequest.fromPartial(N.deleteRoom) : void 0, ae.updateSubscriptions = N.updateSubscriptions !== void 0 && N.updateSubscriptions !== null ? g.UpdateSubscriptionsRequest.fromPartial(N.updateSubscriptions) : void 0, ae.sendData = N.sendData !== void 0 && N.sendData !== null ? g.SendDataRequest.fromPartial(N.sendData) : void 0, ae.updateRoomMetadata = N.updateRoomMetadata !== void 0 && N.updateRoomMetadata !== null ? g.UpdateRoomMetadataRequest.fromPartial(N.updateRoomMetadata) : void 0, ae.keepAlive = N.keepAlive !== void 0 && N.keepAlive !== null ? a.KeepAlive.fromPartial(N.keepAlive) : void 0, ae;
    }
  };
  function H() {
    return { connectionId: "", response: void 0, endSession: void 0 };
  }
  a.SignalNodeMessage = {
    encode(N, D = l.default.Writer.create()) {
      return N.connectionId !== void 0 && N.connectionId !== "" && D.uint32(10).string(N.connectionId), N.response !== void 0 && E.SignalResponse.encode(N.response, D.uint32(18).fork()).ldelim(), N.endSession !== void 0 && a.EndSession.encode(N.endSession, D.uint32(26).fork()).ldelim(), D;
    },
    decode(N, D) {
      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let ee = D === void 0 ? W.len : W.pos + D;
      const ae = H();
      for (; W.pos < ee; ) {
        const ye = W.uint32();
        switch (ye >>> 3) {
          case 1:
            ae.connectionId = W.string();
            break;
          case 2:
            ae.response = E.SignalResponse.decode(W, W.uint32());
            break;
          case 3:
            ae.endSession = a.EndSession.decode(W, W.uint32());
            break;
          default:
            W.skipType(ye & 7);
            break;
        }
      }
      return ae;
    },
    fromJSON(N) {
      return {
        connectionId: A(N.connectionId) ? String(N.connectionId) : "",
        response: A(N.response) ? E.SignalResponse.fromJSON(N.response) : void 0,
        endSession: A(N.endSession) ? a.EndSession.fromJSON(N.endSession) : void 0
      };
    },
    toJSON(N) {
      const D = {};
      return N.connectionId !== void 0 && (D.connectionId = N.connectionId), N.response !== void 0 && (D.response = N.response ? E.SignalResponse.toJSON(N.response) : void 0), N.endSession !== void 0 && (D.endSession = N.endSession ? a.EndSession.toJSON(N.endSession) : void 0), D;
    },
    fromPartial(N) {
      var D;
      const W = H();
      return W.connectionId = (D = N.connectionId) !== null && D !== void 0 ? D : "", W.response = N.response !== void 0 && N.response !== null ? E.SignalResponse.fromPartial(N.response) : void 0, W.endSession = N.endSession !== void 0 && N.endSession !== null ? a.EndSession.fromPartial(N.endSession) : void 0, W;
    }
  };
  function B() {
    return {
      roomName: "",
      identity: "",
      connectionId: "",
      reconnect: !1,
      autoSubscribe: !1,
      hidden: !1,
      client: void 0,
      recorder: !1,
      name: "",
      grantsJson: "",
      adaptiveStream: !1,
      participantId: ""
    };
  }
  a.StartSession = {
    encode(N, D = l.default.Writer.create()) {
      return N.roomName !== void 0 && N.roomName !== "" && D.uint32(10).string(N.roomName), N.identity !== void 0 && N.identity !== "" && D.uint32(18).string(N.identity), N.connectionId !== void 0 && N.connectionId !== "" && D.uint32(26).string(N.connectionId), N.reconnect === !0 && D.uint32(32).bool(N.reconnect), N.autoSubscribe === !0 && D.uint32(72).bool(N.autoSubscribe), N.hidden === !0 && D.uint32(80).bool(N.hidden), N.client !== void 0 && S.ClientInfo.encode(N.client, D.uint32(90).fork()).ldelim(), N.recorder === !0 && D.uint32(96).bool(N.recorder), N.name !== void 0 && N.name !== "" && D.uint32(106).string(N.name), N.grantsJson !== void 0 && N.grantsJson !== "" && D.uint32(114).string(N.grantsJson), N.adaptiveStream === !0 && D.uint32(120).bool(N.adaptiveStream), N.participantId !== void 0 && N.participantId !== "" && D.uint32(130).string(N.participantId), D;
    },
    decode(N, D) {
      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let ee = D === void 0 ? W.len : W.pos + D;
      const ae = B();
      for (; W.pos < ee; ) {
        const ye = W.uint32();
        switch (ye >>> 3) {
          case 1:
            ae.roomName = W.string();
            break;
          case 2:
            ae.identity = W.string();
            break;
          case 3:
            ae.connectionId = W.string();
            break;
          case 4:
            ae.reconnect = W.bool();
            break;
          case 9:
            ae.autoSubscribe = W.bool();
            break;
          case 10:
            ae.hidden = W.bool();
            break;
          case 11:
            ae.client = S.ClientInfo.decode(W, W.uint32());
            break;
          case 12:
            ae.recorder = W.bool();
            break;
          case 13:
            ae.name = W.string();
            break;
          case 14:
            ae.grantsJson = W.string();
            break;
          case 15:
            ae.adaptiveStream = W.bool();
            break;
          case 16:
            ae.participantId = W.string();
            break;
          default:
            W.skipType(ye & 7);
            break;
        }
      }
      return ae;
    },
    fromJSON(N) {
      return {
        roomName: A(N.roomName) ? String(N.roomName) : "",
        identity: A(N.identity) ? String(N.identity) : "",
        connectionId: A(N.connectionId) ? String(N.connectionId) : "",
        reconnect: A(N.reconnect) ? !!N.reconnect : !1,
        autoSubscribe: A(N.autoSubscribe) ? !!N.autoSubscribe : !1,
        hidden: A(N.hidden) ? !!N.hidden : !1,
        client: A(N.client) ? S.ClientInfo.fromJSON(N.client) : void 0,
        recorder: A(N.recorder) ? !!N.recorder : !1,
        name: A(N.name) ? String(N.name) : "",
        grantsJson: A(N.grantsJson) ? String(N.grantsJson) : "",
        adaptiveStream: A(N.adaptiveStream) ? !!N.adaptiveStream : !1,
        participantId: A(N.participantId) ? String(N.participantId) : ""
      };
    },
    toJSON(N) {
      const D = {};
      return N.roomName !== void 0 && (D.roomName = N.roomName), N.identity !== void 0 && (D.identity = N.identity), N.connectionId !== void 0 && (D.connectionId = N.connectionId), N.reconnect !== void 0 && (D.reconnect = N.reconnect), N.autoSubscribe !== void 0 && (D.autoSubscribe = N.autoSubscribe), N.hidden !== void 0 && (D.hidden = N.hidden), N.client !== void 0 && (D.client = N.client ? S.ClientInfo.toJSON(N.client) : void 0), N.recorder !== void 0 && (D.recorder = N.recorder), N.name !== void 0 && (D.name = N.name), N.grantsJson !== void 0 && (D.grantsJson = N.grantsJson), N.adaptiveStream !== void 0 && (D.adaptiveStream = N.adaptiveStream), N.participantId !== void 0 && (D.participantId = N.participantId), D;
    },
    fromPartial(N) {
      var D, W, ee, ae, ye, he, le, we, Be, Ne, Le;
      const $e = B();
      return $e.roomName = (D = N.roomName) !== null && D !== void 0 ? D : "", $e.identity = (W = N.identity) !== null && W !== void 0 ? W : "", $e.connectionId = (ee = N.connectionId) !== null && ee !== void 0 ? ee : "", $e.reconnect = (ae = N.reconnect) !== null && ae !== void 0 ? ae : !1, $e.autoSubscribe = (ye = N.autoSubscribe) !== null && ye !== void 0 ? ye : !1, $e.hidden = (he = N.hidden) !== null && he !== void 0 ? he : !1, $e.client = N.client !== void 0 && N.client !== null ? S.ClientInfo.fromPartial(N.client) : void 0, $e.recorder = (le = N.recorder) !== null && le !== void 0 ? le : !1, $e.name = (we = N.name) !== null && we !== void 0 ? we : "", $e.grantsJson = (Be = N.grantsJson) !== null && Be !== void 0 ? Be : "", $e.adaptiveStream = (Ne = N.adaptiveStream) !== null && Ne !== void 0 ? Ne : !1, $e.participantId = (Le = N.participantId) !== null && Le !== void 0 ? Le : "", $e;
    }
  };
  function Y() {
    return {};
  }
  a.EndSession = {
    encode(N, D = l.default.Writer.create()) {
      return D;
    },
    decode(N, D) {
      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let ee = D === void 0 ? W.len : W.pos + D;
      const ae = Y();
      for (; W.pos < ee; ) {
        const ye = W.uint32();
        switch (ye >>> 3) {
          default:
            W.skipType(ye & 7);
            break;
        }
      }
      return ae;
    },
    fromJSON(N) {
      return {};
    },
    toJSON(N) {
      return {};
    },
    fromPartial(N) {
      return Y();
    }
  };
  function ne() {
    return { participantId: "" };
  }
  a.RemoveParticipant = {
    encode(N, D = l.default.Writer.create()) {
      return N.participantId !== void 0 && N.participantId !== "" && D.uint32(10).string(N.participantId), D;
    },
    decode(N, D) {
      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let ee = D === void 0 ? W.len : W.pos + D;
      const ae = ne();
      for (; W.pos < ee; ) {
        const ye = W.uint32();
        switch (ye >>> 3) {
          case 1:
            ae.participantId = W.string();
            break;
          default:
            W.skipType(ye & 7);
            break;
        }
      }
      return ae;
    },
    fromJSON(N) {
      return { participantId: A(N.participantId) ? String(N.participantId) : "" };
    },
    toJSON(N) {
      const D = {};
      return N.participantId !== void 0 && (D.participantId = N.participantId), D;
    },
    fromPartial(N) {
      var D;
      const W = ne();
      return W.participantId = (D = N.participantId) !== null && D !== void 0 ? D : "", W;
    }
  };
  function Z() {
    return {};
  }
  a.KeepAlive = {
    encode(N, D = l.default.Writer.create()) {
      return D;
    },
    decode(N, D) {
      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let ee = D === void 0 ? W.len : W.pos + D;
      const ae = Z();
      for (; W.pos < ee; ) {
        const ye = W.uint32();
        switch (ye >>> 3) {
          default:
            W.skipType(ye & 7);
            break;
        }
      }
      return ae;
    },
    fromJSON(N) {
      return {};
    },
    toJSON(N) {
      return {};
    },
    fromPartial(N) {
      return Z();
    }
  };
  function re() {
    return { trackEgress: void 0 };
  }
  a.RoomInternal = {
    encode(N, D = l.default.Writer.create()) {
      return N.trackEgress !== void 0 && v.AutoTrackEgress.encode(N.trackEgress, D.uint32(10).fork()).ldelim(), D;
    },
    decode(N, D) {
      const W = N instanceof l.default.Reader ? N : new l.default.Reader(N);
      let ee = D === void 0 ? W.len : W.pos + D;
      const ae = re();
      for (; W.pos < ee; ) {
        const ye = W.uint32();
        switch (ye >>> 3) {
          case 1:
            ae.trackEgress = v.AutoTrackEgress.decode(W, W.uint32());
            break;
          default:
            W.skipType(ye & 7);
            break;
        }
      }
      return ae;
    },
    fromJSON(N) {
      return { trackEgress: A(N.trackEgress) ? v.AutoTrackEgress.fromJSON(N.trackEgress) : void 0 };
    },
    toJSON(N) {
      const D = {};
      return N.trackEgress !== void 0 && (D.trackEgress = N.trackEgress ? v.AutoTrackEgress.toJSON(N.trackEgress) : void 0), D;
    },
    fromPartial(N) {
      const D = re();
      return D.trackEgress = N.trackEgress !== void 0 && N.trackEgress !== null ? v.AutoTrackEgress.fromPartial(N.trackEgress) : void 0, D;
    }
  };
  var oe = (() => {
    if (typeof oe < "u")
      return oe;
    if (typeof self < "u")
      return self;
    if (typeof window < "u")
      return window;
    if (typeof commonjsGlobal$1 < "u")
      return commonjsGlobal$1;
    throw "Unable to locate global object";
  })();
  function de(N) {
    if (N.gt(Number.MAX_SAFE_INTEGER))
      throw new oe.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    return N.toNumber();
  }
  l.default.util.Long !== c.default && (l.default.util.Long = c.default, l.default.configure());
  function A(N) {
    return N != null;
  }
})(livekit_internal);
(function(a) {
  var u = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(_, k, L, M) {
    M === void 0 && (M = L), Object.defineProperty(_, M, { enumerable: !0, get: function() {
      return k[L];
    } });
  } : function(_, k, L, M) {
    M === void 0 && (M = L), _[M] = k[L];
  }), c = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(_, k) {
    Object.defineProperty(_, "default", { enumerable: !0, value: k });
  } : function(_, k) {
    _.default = k;
  }), l = commonjsGlobal$1 && commonjsGlobal$1.__exportStar || function(_, k) {
    for (var L in _)
      L !== "default" && !Object.prototype.hasOwnProperty.call(k, L) && u(k, _, L);
  }, v = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(_) {
    if (_ && _.__esModule)
      return _;
    var k = {};
    if (_ != null)
      for (var L in _)
        L !== "default" && Object.prototype.hasOwnProperty.call(_, L) && u(k, _, L);
    return c(k, _), k;
  };
  Object.defineProperty(a, "__esModule", { value: !0 }), a.LivekitInternal = a.TrackType = a.TrackInfo = a.Room = a.ParticipantPermission = a.ParticipantInfo_State = a.ParticipantInfo = a.DataPacket_Kind = a.IngressVideoOptions = a.IngressState = a.IngressInput = a.IngressInfo = a.IngressAudioOptions = a.StreamProtocol = a.StreamOutput = a.SegmentedFileProtocol = a.SegmentedFileOutput = a.EncodingOptionsPreset = a.EncodingOptions = a.EncodedFileType = a.EncodedFileOutput = a.EgressInfo = a.DirectFileOutput = void 0, l(AccessToken$1, a), l(EgressClient$1, a), l(grants, a), l(IngressClient$1, a);
  var S = livekit_egress;
  Object.defineProperty(a, "DirectFileOutput", { enumerable: !0, get: function() {
    return S.DirectFileOutput;
  } }), Object.defineProperty(a, "EgressInfo", { enumerable: !0, get: function() {
    return S.EgressInfo;
  } }), Object.defineProperty(a, "EncodedFileOutput", { enumerable: !0, get: function() {
    return S.EncodedFileOutput;
  } }), Object.defineProperty(a, "EncodedFileType", { enumerable: !0, get: function() {
    return S.EncodedFileType;
  } }), Object.defineProperty(a, "EncodingOptions", { enumerable: !0, get: function() {
    return S.EncodingOptions;
  } }), Object.defineProperty(a, "EncodingOptionsPreset", { enumerable: !0, get: function() {
    return S.EncodingOptionsPreset;
  } }), Object.defineProperty(a, "SegmentedFileOutput", { enumerable: !0, get: function() {
    return S.SegmentedFileOutput;
  } }), Object.defineProperty(a, "SegmentedFileProtocol", { enumerable: !0, get: function() {
    return S.SegmentedFileProtocol;
  } }), Object.defineProperty(a, "StreamOutput", { enumerable: !0, get: function() {
    return S.StreamOutput;
  } }), Object.defineProperty(a, "StreamProtocol", { enumerable: !0, get: function() {
    return S.StreamProtocol;
  } });
  var g = livekit_ingress;
  Object.defineProperty(a, "IngressAudioOptions", { enumerable: !0, get: function() {
    return g.IngressAudioOptions;
  } }), Object.defineProperty(a, "IngressInfo", { enumerable: !0, get: function() {
    return g.IngressInfo;
  } }), Object.defineProperty(a, "IngressInput", { enumerable: !0, get: function() {
    return g.IngressInput;
  } }), Object.defineProperty(a, "IngressState", { enumerable: !0, get: function() {
    return g.IngressState;
  } }), Object.defineProperty(a, "IngressVideoOptions", { enumerable: !0, get: function() {
    return g.IngressVideoOptions;
  } });
  var E = livekit_models;
  Object.defineProperty(a, "DataPacket_Kind", { enumerable: !0, get: function() {
    return E.DataPacket_Kind;
  } }), Object.defineProperty(a, "ParticipantInfo", { enumerable: !0, get: function() {
    return E.ParticipantInfo;
  } }), Object.defineProperty(a, "ParticipantInfo_State", { enumerable: !0, get: function() {
    return E.ParticipantInfo_State;
  } }), Object.defineProperty(a, "ParticipantPermission", { enumerable: !0, get: function() {
    return E.ParticipantPermission;
  } }), Object.defineProperty(a, "Room", { enumerable: !0, get: function() {
    return E.Room;
  } }), Object.defineProperty(a, "TrackInfo", { enumerable: !0, get: function() {
    return E.TrackInfo;
  } }), Object.defineProperty(a, "TrackType", { enumerable: !0, get: function() {
    return E.TrackType;
  } }), l(RoomServiceClient$1, a), l(WebhookReceiver$1, a), a.LivekitInternal = v(livekit_internal);
})(dist);
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(a) {
  return decodeURIComponent(atob(a).replace(/(.)/g, (u, c) => {
    let l = c.charCodeAt(0).toString(16).toUpperCase();
    return l.length < 2 && (l = "0" + l), "%" + l;
  }));
}
function base64UrlDecode(a) {
  let u = a.replace(/-/g, "+").replace(/_/g, "/");
  switch (u.length % 4) {
    case 0:
      break;
    case 2:
      u += "==";
      break;
    case 3:
      u += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(u);
  } catch {
    return atob(u);
  }
}
function jwtDecode(a, u) {
  if (typeof a != "string")
    throw new InvalidTokenError("Invalid token specified: must be a string");
  u || (u = {});
  const c = u.header === !0 ? 0 : 1, l = a.split(".")[c];
  if (typeof l != "string")
    throw new InvalidTokenError(`Invalid token specified: missing part #${c + 1}`);
  let v;
  try {
    v = base64UrlDecode(l);
  } catch (S) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${c + 1} (${S.message})`);
  }
  try {
    return JSON.parse(v);
  } catch (S) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${c + 1} (${S.message})`);
  }
}
function _mergeNamespaces(a, u) {
  return u.forEach(function(c) {
    c && typeof c != "string" && !Array.isArray(c) && Object.keys(c).forEach(function(l) {
      if (l !== "default" && !(l in a)) {
        var v = Object.getOwnPropertyDescriptor(c, l);
        Object.defineProperty(a, l, v.get ? v : {
          enumerable: !0,
          get: function() {
            return c[l];
          }
        });
      }
    });
  }), Object.freeze(a);
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var loglevel = { exports: {} };
(function(a) {
  (function(u, c) {
    a.exports ? a.exports = c() : u.log = c();
  })(commonjsGlobal, function() {
    var u = function() {
    }, c = "undefined", l = typeof window !== c && typeof window.navigator !== c && /Trident\/|MSIE /.test(window.navigator.userAgent), v = ["trace", "debug", "info", "warn", "error"];
    function S(q, G) {
      var H = q[G];
      if (typeof H.bind == "function")
        return H.bind(q);
      try {
        return Function.prototype.bind.call(H, q);
      } catch {
        return function() {
          return Function.prototype.apply.apply(H, [q, arguments]);
        };
      }
    }
    function g() {
      console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
    }
    function E(q) {
      return q === "debug" && (q = "log"), typeof console === c ? !1 : q === "trace" && l ? g : console[q] !== void 0 ? S(console, q) : console.log !== void 0 ? S(console, "log") : u;
    }
    function _(q, G) {
      for (var H = 0; H < v.length; H++) {
        var B = v[H];
        this[B] = H < q ? u : this.methodFactory(B, q, G);
      }
      this.log = this.debug;
    }
    function k(q, G, H) {
      return function() {
        typeof console !== c && (_.call(this, G, H), this[q].apply(this, arguments));
      };
    }
    function L(q, G, H) {
      return E(q) || k.apply(this, arguments);
    }
    function M(q, G, H) {
      var B = this, Y;
      G = G ?? "WARN";
      var ne = "loglevel";
      typeof q == "string" ? ne += ":" + q : typeof q == "symbol" && (ne = void 0);
      function Z(A) {
        var N = (v[A] || "silent").toUpperCase();
        if (!(typeof window === c || !ne)) {
          try {
            window.localStorage[ne] = N;
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(ne) + "=" + N + ";";
          } catch {
          }
        }
      }
      function re() {
        var A;
        if (!(typeof window === c || !ne)) {
          try {
            A = window.localStorage[ne];
          } catch {
          }
          if (typeof A === c)
            try {
              var N = window.document.cookie, D = N.indexOf(encodeURIComponent(ne) + "=");
              D !== -1 && (A = /^([^;]+)/.exec(N.slice(D))[1]);
            } catch {
            }
          return B.levels[A] === void 0 && (A = void 0), A;
        }
      }
      function oe() {
        if (!(typeof window === c || !ne)) {
          try {
            window.localStorage.removeItem(ne);
            return;
          } catch {
          }
          try {
            window.document.cookie = encodeURIComponent(ne) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
          } catch {
          }
        }
      }
      B.name = q, B.levels = {
        TRACE: 0,
        DEBUG: 1,
        INFO: 2,
        WARN: 3,
        ERROR: 4,
        SILENT: 5
      }, B.methodFactory = H || L, B.getLevel = function() {
        return Y;
      }, B.setLevel = function(A, N) {
        if (typeof A == "string" && B.levels[A.toUpperCase()] !== void 0 && (A = B.levels[A.toUpperCase()]), typeof A == "number" && A >= 0 && A <= B.levels.SILENT) {
          if (Y = A, N !== !1 && Z(A), _.call(B, A, q), typeof console === c && A < B.levels.SILENT)
            return "No console available for logging";
        } else
          throw "log.setLevel() called with invalid level: " + A;
      }, B.setDefaultLevel = function(A) {
        G = A, re() || B.setLevel(A, !1);
      }, B.resetLevel = function() {
        B.setLevel(G, !1), oe();
      }, B.enableAll = function(A) {
        B.setLevel(B.levels.TRACE, A);
      }, B.disableAll = function(A) {
        B.setLevel(B.levels.SILENT, A);
      };
      var de = re();
      de == null && (de = G), B.setLevel(de, !1);
    }
    var $ = new M(), J = {};
    $.getLogger = function(G) {
      if (typeof G != "symbol" && typeof G != "string" || G === "")
        throw new TypeError("You must supply a name when creating a logger.");
      var H = J[G];
      return H || (H = J[G] = new M(G, $.getLevel(), $.methodFactory)), H;
    };
    var V = typeof window !== c ? window.log : void 0;
    return $.noConflict = function() {
      return typeof window !== c && window.log === $ && (window.log = V), $;
    }, $.getLoggers = function() {
      return J;
    }, $.default = $, $;
  });
})(loglevel);
var loglevelExports = loglevel.exports, LogLevel;
(function(a) {
  a[a.trace = 0] = "trace", a[a.debug = 1] = "debug", a[a.info = 2] = "info", a[a.warn = 3] = "warn", a[a.error = 4] = "error", a[a.silent = 5] = "silent";
})(LogLevel || (LogLevel = {}));
var LoggerNames;
(function(a) {
  a.Default = "livekit", a.Room = "livekit-room", a.Participant = "livekit-participant", a.Track = "livekit-track", a.Publication = "livekit-track-publication", a.Engine = "livekit-engine", a.Signal = "livekit-signal", a.PCManager = "livekit-pc-manager", a.PCTransport = "livekit-pc-transport", a.E2EE = "lk-e2ee";
})(LoggerNames || (LoggerNames = {}));
let livekitLogger = loglevelExports.getLogger("livekit");
livekitLogger.setDefaultLevel(LogLevel.info);
function getLogger(a) {
  const u = loglevelExports.getLogger(a);
  return u.setDefaultLevel(livekitLogger.getLevel()), u;
}
function setLogLevel(a, u) {
  u && loglevelExports.getLogger(u).setLevel(a);
  for (const c of Object.entries(loglevelExports.getLoggers()).filter((l) => {
    let [v] = l;
    return v.startsWith("livekit");
  }).map((l) => {
    let [, v] = l;
    return v;
  }))
    c.setLevel(a);
}
loglevelExports.getLogger("lk-e2ee");
function assert(a, u) {
  if (!a)
    throw new Error(u);
}
const FLOAT32_MAX = 34028234663852886e22, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 4294967295, INT32_MAX = 2147483647, INT32_MIN = -2147483648;
function assertInt32(a) {
  if (typeof a != "number")
    throw new Error("invalid int 32: " + typeof a);
  if (!Number.isInteger(a) || a > INT32_MAX || a < INT32_MIN)
    throw new Error("invalid int 32: " + a);
}
function assertUInt32(a) {
  if (typeof a != "number")
    throw new Error("invalid uint 32: " + typeof a);
  if (!Number.isInteger(a) || a > UINT32_MAX || a < 0)
    throw new Error("invalid uint 32: " + a);
}
function assertFloat32(a) {
  if (typeof a != "number")
    throw new Error("invalid float 32: " + typeof a);
  if (Number.isFinite(a) && (a > FLOAT32_MAX || a < FLOAT32_MIN))
    throw new Error("invalid float 32: " + a);
}
const enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
function getEnumType(a) {
  const u = a[enumTypeSymbol];
  return assert(u, "missing enum type on enum object"), u;
}
function setEnumType(a, u, c, l) {
  a[enumTypeSymbol] = makeEnumType(u, c.map((v) => ({
    no: v.no,
    name: v.name,
    localName: a[v.no]
  })));
}
function makeEnumType(a, u, c) {
  const l = /* @__PURE__ */ Object.create(null), v = /* @__PURE__ */ Object.create(null), S = [];
  for (const g of u) {
    const E = normalizeEnumValue(g);
    S.push(E), l[g.name] = E, v[g.no] = E;
  }
  return {
    typeName: a,
    values: S,
    // We do not surface options at this time
    // options: opt?.options ?? Object.create(null),
    findName(g) {
      return l[g];
    },
    findNumber(g) {
      return v[g];
    }
  };
}
function makeEnum(a, u, c) {
  const l = {};
  for (const v of u) {
    const S = normalizeEnumValue(v);
    l[S.localName] = S.no, l[S.no] = S.localName;
  }
  return setEnumType(l, a, u), l;
}
function normalizeEnumValue(a) {
  return "localName" in a ? a : Object.assign(Object.assign({}, a), {
    localName: a.name
  });
}
class Message {
  /**
   * Compare with a message of the same type.
   */
  equals(u) {
    return this.getType().runtime.util.equals(this.getType(), this, u);
  }
  /**
   * Create a deep copy.
   */
  clone() {
    return this.getType().runtime.util.clone(this);
  }
  /**
   * Parse from binary data, merging fields.
   *
   * Repeated fields are appended. Map entries are added, overwriting
   * existing keys.
   *
   * If a message field is already present, it will be merged with the
   * new data.
   */
  fromBinary(u, c) {
    const l = this.getType(), v = l.runtime.bin, S = v.makeReadOptions(c);
    return v.readMessage(this, S.readerFactory(u), u.byteLength, S), this;
  }
  /**
   * Parse a message from a JSON value.
   */
  fromJson(u, c) {
    const l = this.getType(), v = l.runtime.json, S = v.makeReadOptions(c);
    return v.readMessage(l, u, S, this), this;
  }
  /**
   * Parse a message from a JSON string.
   */
  fromJsonString(u, c) {
    let l;
    try {
      l = JSON.parse(u);
    } catch (v) {
      throw new Error("cannot decode ".concat(this.getType().typeName, " from JSON: ").concat(v instanceof Error ? v.message : String(v)));
    }
    return this.fromJson(l, c);
  }
  /**
   * Serialize the message to binary data.
   */
  toBinary(u) {
    const c = this.getType(), l = c.runtime.bin, v = l.makeWriteOptions(u), S = v.writerFactory();
    return l.writeMessage(this, S, v), S.finish();
  }
  /**
   * Serialize the message to a JSON value, a JavaScript value that can be
   * passed to JSON.stringify().
   */
  toJson(u) {
    const c = this.getType(), l = c.runtime.json, v = l.makeWriteOptions(u);
    return l.writeMessage(this, v);
  }
  /**
   * Serialize the message to a JSON string.
   */
  toJsonString(u) {
    var c;
    const l = this.toJson(u);
    return JSON.stringify(l, null, (c = u == null ? void 0 : u.prettySpaces) !== null && c !== void 0 ? c : 0);
  }
  /**
   * Override for serialization behavior. This will be invoked when calling
   * JSON.stringify on this message (i.e. JSON.stringify(msg)).
   *
   * Note that this will not serialize google.protobuf.Any with a packed
   * message because the protobuf JSON format specifies that it needs to be
   * unpacked, and this is only possible with a type registry to look up the
   * message type.  As a result, attempting to serialize a message with this
   * type will throw an Error.
   *
   * This method is protected because you should not need to invoke it
   * directly -- instead use JSON.stringify or toJsonString for
   * stringified JSON.  Alternatively, if actual JSON is desired, you should
   * use toJson.
   */
  toJSON() {
    return this.toJson({
      emitDefaultValues: !0
    });
  }
  /**
   * Retrieve the MessageType of this message - a singleton that represents
   * the protobuf message declaration and provides metadata for reflection-
   * based operations.
   */
  getType() {
    return Object.getPrototypeOf(this).constructor;
  }
}
function makeMessageType(a, u, c, l) {
  var v;
  const S = (v = l == null ? void 0 : l.localName) !== null && v !== void 0 ? v : u.substring(u.lastIndexOf(".") + 1), g = {
    [S]: function(E) {
      a.util.initFields(this), a.util.initPartial(E, this);
    }
  }[S];
  return Object.setPrototypeOf(g.prototype, new Message()), Object.assign(g, {
    runtime: a,
    typeName: u,
    fields: a.util.newFieldList(c),
    fromBinary(E, _) {
      return new g().fromBinary(E, _);
    },
    fromJson(E, _) {
      return new g().fromJson(E, _);
    },
    fromJsonString(E, _) {
      return new g().fromJsonString(E, _);
    },
    equals(E, _) {
      return a.util.equals(g, E, _);
    }
  }), g;
}
function makeProtoRuntime(a, u, c, l) {
  return {
    syntax: a,
    json: u,
    bin: c,
    util: l,
    makeMessageType(v, S, g) {
      return makeMessageType(this, v, S, g);
    },
    makeEnum,
    makeEnumType,
    getEnumType
  };
}
var ScalarType;
(function(a) {
  a[a.DOUBLE = 1] = "DOUBLE", a[a.FLOAT = 2] = "FLOAT", a[a.INT64 = 3] = "INT64", a[a.UINT64 = 4] = "UINT64", a[a.INT32 = 5] = "INT32", a[a.FIXED64 = 6] = "FIXED64", a[a.FIXED32 = 7] = "FIXED32", a[a.BOOL = 8] = "BOOL", a[a.STRING = 9] = "STRING", a[a.BYTES = 12] = "BYTES", a[a.UINT32 = 13] = "UINT32", a[a.SFIXED32 = 15] = "SFIXED32", a[a.SFIXED64 = 16] = "SFIXED64", a[a.SINT32 = 17] = "SINT32", a[a.SINT64 = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));
var LongType;
(function(a) {
  a[a.BIGINT = 0] = "BIGINT", a[a.STRING = 1] = "STRING";
})(LongType || (LongType = {}));
function varint64read() {
  let a = 0, u = 0;
  for (let l = 0; l < 28; l += 7) {
    let v = this.buf[this.pos++];
    if (a |= (v & 127) << l, !(v & 128))
      return this.assertBounds(), [a, u];
  }
  let c = this.buf[this.pos++];
  if (a |= (c & 15) << 28, u = (c & 112) >> 4, !(c & 128))
    return this.assertBounds(), [a, u];
  for (let l = 3; l <= 31; l += 7) {
    let v = this.buf[this.pos++];
    if (u |= (v & 127) << l, !(v & 128))
      return this.assertBounds(), [a, u];
  }
  throw new Error("invalid varint");
}
function varint64write(a, u, c) {
  for (let S = 0; S < 28; S = S + 7) {
    const g = a >>> S, E = !(!(g >>> 7) && u == 0), _ = (E ? g | 128 : g) & 255;
    if (c.push(_), !E)
      return;
  }
  const l = a >>> 28 & 15 | (u & 7) << 4, v = !!(u >> 3);
  if (c.push((v ? l | 128 : l) & 255), !!v) {
    for (let S = 3; S < 31; S = S + 7) {
      const g = u >>> S, E = !!(g >>> 7), _ = (E ? g | 128 : g) & 255;
      if (c.push(_), !E)
        return;
    }
    c.push(u >>> 31 & 1);
  }
}
const TWO_PWR_32_DBL = 4294967296;
function int64FromString(a) {
  const u = a[0] === "-";
  u && (a = a.slice(1));
  const c = 1e6;
  let l = 0, v = 0;
  function S(g, E) {
    const _ = Number(a.slice(g, E));
    v *= c, l = l * c + _, l >= TWO_PWR_32_DBL && (v = v + (l / TWO_PWR_32_DBL | 0), l = l % TWO_PWR_32_DBL);
  }
  return S(-24, -18), S(-18, -12), S(-12, -6), S(-6), u ? negate(l, v) : newBits(l, v);
}
function int64ToString(a, u) {
  let c = newBits(a, u);
  const l = c.hi & 2147483648;
  l && (c = negate(c.lo, c.hi));
  const v = uInt64ToString(c.lo, c.hi);
  return l ? "-" + v : v;
}
function uInt64ToString(a, u) {
  if ({
    lo: a,
    hi: u
  } = toUnsigned(a, u), u <= 2097151)
    return String(TWO_PWR_32_DBL * u + a);
  const c = a & 16777215, l = (a >>> 24 | u << 8) & 16777215, v = u >> 16 & 65535;
  let S = c + l * 6777216 + v * 6710656, g = l + v * 8147497, E = v * 2;
  const _ = 1e7;
  return S >= _ && (g += Math.floor(S / _), S %= _), g >= _ && (E += Math.floor(g / _), g %= _), E.toString() + decimalFrom1e7WithLeadingZeros(g) + decimalFrom1e7WithLeadingZeros(S);
}
function toUnsigned(a, u) {
  return {
    lo: a >>> 0,
    hi: u >>> 0
  };
}
function newBits(a, u) {
  return {
    lo: a | 0,
    hi: u | 0
  };
}
function negate(a, u) {
  return u = ~u, a ? a = ~a + 1 : u += 1, newBits(a, u);
}
const decimalFrom1e7WithLeadingZeros = (a) => {
  const u = String(a);
  return "0000000".slice(u.length) + u;
};
function varint32write(a, u) {
  if (a >= 0) {
    for (; a > 127; )
      u.push(a & 127 | 128), a = a >>> 7;
    u.push(a);
  } else {
    for (let c = 0; c < 9; c++)
      u.push(a & 127 | 128), a = a >> 7;
    u.push(1);
  }
}
function varint32read() {
  let a = this.buf[this.pos++], u = a & 127;
  if (!(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 7, !(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 14, !(a & 128))
    return this.assertBounds(), u;
  if (a = this.buf[this.pos++], u |= (a & 127) << 21, !(a & 128))
    return this.assertBounds(), u;
  a = this.buf[this.pos++], u |= (a & 15) << 28;
  for (let c = 5; a & 128 && c < 10; c++)
    a = this.buf[this.pos++];
  if (a & 128)
    throw new Error("invalid varint");
  return this.assertBounds(), u >>> 0;
}
function makeInt64Support() {
  const a = new DataView(new ArrayBuffer(8));
  if (typeof BigInt == "function" && typeof a.getBigInt64 == "function" && typeof a.getBigUint64 == "function" && typeof a.setBigInt64 == "function" && typeof a.setBigUint64 == "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1")) {
    const v = BigInt("-9223372036854775808"), S = BigInt("9223372036854775807"), g = BigInt("0"), E = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: !0,
      parse(_) {
        const k = typeof _ == "bigint" ? _ : BigInt(_);
        if (k > S || k < v)
          throw new Error("int64 invalid: ".concat(_));
        return k;
      },
      uParse(_) {
        const k = typeof _ == "bigint" ? _ : BigInt(_);
        if (k > E || k < g)
          throw new Error("uint64 invalid: ".concat(_));
        return k;
      },
      enc(_) {
        return a.setBigInt64(0, this.parse(_), !0), {
          lo: a.getInt32(0, !0),
          hi: a.getInt32(4, !0)
        };
      },
      uEnc(_) {
        return a.setBigInt64(0, this.uParse(_), !0), {
          lo: a.getInt32(0, !0),
          hi: a.getInt32(4, !0)
        };
      },
      dec(_, k) {
        return a.setInt32(0, _, !0), a.setInt32(4, k, !0), a.getBigInt64(0, !0);
      },
      uDec(_, k) {
        return a.setInt32(0, _, !0), a.setInt32(4, k, !0), a.getBigUint64(0, !0);
      }
    };
  }
  const c = (v) => assert(/^-?[0-9]+$/.test(v), "int64 invalid: ".concat(v)), l = (v) => assert(/^[0-9]+$/.test(v), "uint64 invalid: ".concat(v));
  return {
    zero: "0",
    supported: !1,
    parse(v) {
      return typeof v != "string" && (v = v.toString()), c(v), v;
    },
    uParse(v) {
      return typeof v != "string" && (v = v.toString()), l(v), v;
    },
    enc(v) {
      return typeof v != "string" && (v = v.toString()), c(v), int64FromString(v);
    },
    uEnc(v) {
      return typeof v != "string" && (v = v.toString()), l(v), int64FromString(v);
    },
    dec(v, S) {
      return int64ToString(v, S);
    },
    uDec(v, S) {
      return uInt64ToString(v, S);
    }
  };
}
const protoInt64 = makeInt64Support();
var WireType;
(function(a) {
  a[a.Varint = 0] = "Varint", a[a.Bit64 = 1] = "Bit64", a[a.LengthDelimited = 2] = "LengthDelimited", a[a.StartGroup = 3] = "StartGroup", a[a.EndGroup = 4] = "EndGroup", a[a.Bit32 = 5] = "Bit32";
})(WireType || (WireType = {}));
class BinaryWriter {
  constructor(u) {
    this.stack = [], this.textEncoder = u ?? new TextEncoder(), this.chunks = [], this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    this.chunks.push(new Uint8Array(this.buf));
    let u = 0;
    for (let v = 0; v < this.chunks.length; v++)
      u += this.chunks[v].length;
    let c = new Uint8Array(u), l = 0;
    for (let v = 0; v < this.chunks.length; v++)
      c.set(this.chunks[v], l), l += this.chunks[v].length;
    return this.chunks = [], c;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    return this.stack.push({
      chunks: this.chunks,
      buf: this.buf
    }), this.chunks = [], this.buf = [], this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let u = this.finish(), c = this.stack.pop();
    if (!c)
      throw new Error("invalid state, fork stack empty");
    return this.chunks = c.chunks, this.buf = c.buf, this.uint32(u.byteLength), this.raw(u);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(u, c) {
    return this.uint32((u << 3 | c) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(u) {
    return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(u), this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(u) {
    for (assertUInt32(u); u > 127; )
      this.buf.push(u & 127 | 128), u = u >>> 7;
    return this.buf.push(u), this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(u) {
    return assertInt32(u), varint32write(u, this.buf), this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(u) {
    return this.buf.push(u ? 1 : 0), this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(u) {
    return this.uint32(u.byteLength), this.raw(u);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(u) {
    let c = this.textEncoder.encode(u);
    return this.uint32(c.byteLength), this.raw(c);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(u) {
    assertFloat32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setFloat32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(u) {
    let c = new Uint8Array(8);
    return new DataView(c.buffer).setFloat64(0, u, !0), this.raw(c);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(u) {
    assertUInt32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setUint32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(u) {
    assertInt32(u);
    let c = new Uint8Array(4);
    return new DataView(c.buffer).setInt32(0, u, !0), this.raw(c);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(u) {
    return assertInt32(u), u = (u << 1 ^ u >> 31) >>> 0, varint32write(u, this.buf), this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(u) {
    let c = new Uint8Array(8), l = new DataView(c.buffer), v = protoInt64.enc(u);
    return l.setInt32(0, v.lo, !0), l.setInt32(4, v.hi, !0), this.raw(c);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(u) {
    let c = new Uint8Array(8), l = new DataView(c.buffer), v = protoInt64.uEnc(u);
    return l.setInt32(0, v.lo, !0), l.setInt32(4, v.hi, !0), this.raw(c);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(u) {
    let c = protoInt64.enc(u);
    return varint64write(c.lo, c.hi, this.buf), this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(u) {
    let c = protoInt64.enc(u), l = c.hi >> 31, v = c.lo << 1 ^ l, S = (c.hi << 1 | c.lo >>> 31) ^ l;
    return varint64write(v, S, this.buf), this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(u) {
    let c = protoInt64.uEnc(u);
    return varint64write(c.lo, c.hi, this.buf), this;
  }
}
class BinaryReader {
  constructor(u, c) {
    this.varint64 = varint64read, this.uint32 = varint32read, this.buf = u, this.len = u.length, this.pos = 0, this.view = new DataView(u.buffer, u.byteOffset, u.byteLength), this.textDecoder = c ?? new TextDecoder();
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let u = this.uint32(), c = u >>> 3, l = u & 7;
    if (c <= 0 || l < 0 || l > 5)
      throw new Error("illegal tag: field no " + c + " wire type " + l);
    return [c, l];
  }
  /**
   * Skip one element on the wire and return the skipped data.
   * Supports WireType.StartGroup since v2.0.0-alpha.23.
   */
  skip(u) {
    let c = this.pos;
    switch (u) {
      case WireType.Varint:
        for (; this.buf[this.pos++] & 128; )
          ;
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let l = this.uint32();
        this.pos += l;
        break;
      case WireType.StartGroup:
        let v;
        for (; (v = this.tag()[1]) !== WireType.EndGroup; )
          this.skip(v);
        break;
      default:
        throw new Error("cant skip wire type " + u);
    }
    return this.assertBounds(), this.buf.subarray(c, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let u = this.uint32();
    return u >>> 1 ^ -(u & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [u, c] = this.varint64(), l = -(u & 1);
    return u = (u >>> 1 | (c & 1) << 31) ^ l, c = c >>> 1 ^ l, protoInt64.dec(u, c);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [u, c] = this.varint64();
    return u !== 0 || c !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let u = this.uint32(), c = this.pos;
    return this.pos += u, this.assertBounds(), this.buf.subarray(c, c + u);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.textDecoder.decode(this.bytes());
  }
}
function wrapField(a, u) {
  return u instanceof Message || !a.fieldWrapper ? u : a.fieldWrapper.wrapField(u);
}
ScalarType.DOUBLE, ScalarType.FLOAT, ScalarType.INT64, ScalarType.UINT64, ScalarType.INT32, ScalarType.UINT32, ScalarType.BOOL, ScalarType.STRING, ScalarType.BYTES;
function scalarEquals(a, u, c) {
  if (u === c)
    return !0;
  if (a == ScalarType.BYTES) {
    if (!(u instanceof Uint8Array) || !(c instanceof Uint8Array) || u.length !== c.length)
      return !1;
    for (let l = 0; l < u.length; l++)
      if (u[l] !== c[l])
        return !1;
    return !0;
  }
  switch (a) {
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return u == c;
  }
  return !1;
}
function scalarDefaultValue(a, u) {
  switch (a) {
    case ScalarType.BOOL:
      return !1;
    case ScalarType.UINT64:
    case ScalarType.FIXED64:
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      return u == 0 ? protoInt64.zero : "0";
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      return 0;
    case ScalarType.BYTES:
      return new Uint8Array(0);
    case ScalarType.STRING:
      return "";
    default:
      return 0;
  }
}
function scalarTypeInfo(a, u) {
  const c = u === void 0;
  let l = WireType.Varint, v = u === 0;
  switch (a) {
    case ScalarType.STRING:
      v = c || !u.length, l = WireType.LengthDelimited;
      break;
    case ScalarType.BOOL:
      v = u === !1;
      break;
    case ScalarType.DOUBLE:
      l = WireType.Bit64;
      break;
    case ScalarType.FLOAT:
      l = WireType.Bit32;
      break;
    case ScalarType.INT64:
      v = c || u == 0;
      break;
    case ScalarType.UINT64:
      v = c || u == 0;
      break;
    case ScalarType.FIXED64:
      v = c || u == 0, l = WireType.Bit64;
      break;
    case ScalarType.BYTES:
      v = c || !u.byteLength, l = WireType.LengthDelimited;
      break;
    case ScalarType.FIXED32:
      l = WireType.Bit32;
      break;
    case ScalarType.SFIXED32:
      l = WireType.Bit32;
      break;
    case ScalarType.SFIXED64:
      v = c || u == 0, l = WireType.Bit64;
      break;
    case ScalarType.SINT64:
      v = c || u == 0;
      break;
  }
  const S = ScalarType[a].toLowerCase();
  return [l, S, c || v];
}
const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields"), readDefaults = {
  readUnknownFields: !0,
  readerFactory: (a) => new BinaryReader(a)
}, writeDefaults = {
  writeUnknownFields: !0,
  writerFactory: () => new BinaryWriter()
};
function makeReadOptions$1(a) {
  return a ? Object.assign(Object.assign({}, readDefaults), a) : readDefaults;
}
function makeWriteOptions$1(a) {
  return a ? Object.assign(Object.assign({}, writeDefaults), a) : writeDefaults;
}
function makeBinaryFormatCommon() {
  return {
    makeReadOptions: makeReadOptions$1,
    makeWriteOptions: makeWriteOptions$1,
    listUnknownFields(a) {
      var u;
      return (u = a[unknownFieldsSymbol]) !== null && u !== void 0 ? u : [];
    },
    discardUnknownFields(a) {
      delete a[unknownFieldsSymbol];
    },
    writeUnknownFields(a, u) {
      const l = a[unknownFieldsSymbol];
      if (l)
        for (const v of l)
          u.tag(v.no, v.wireType).raw(v.data);
    },
    onUnknownField(a, u, c, l) {
      const v = a;
      Array.isArray(v[unknownFieldsSymbol]) || (v[unknownFieldsSymbol] = []), v[unknownFieldsSymbol].push({
        no: u,
        wireType: c,
        data: l
      });
    },
    readMessage(a, u, c, l) {
      const v = a.getType(), S = c === void 0 ? u.len : u.pos + c;
      for (; u.pos < S; ) {
        const [g, E] = u.tag(), _ = v.fields.find(g);
        if (!_) {
          const $ = u.skip(E);
          l.readUnknownFields && this.onUnknownField(a, g, E, $);
          continue;
        }
        let k = a, L = _.repeated, M = _.localName;
        switch (_.oneof && (k = k[_.oneof.localName], k.case != M && delete k.value, k.case = M, M = "value"), _.kind) {
          case "scalar":
          case "enum":
            const $ = _.kind == "enum" ? ScalarType.INT32 : _.T;
            let J = readScalar$1;
            if (_.kind == "scalar" && _.L > 0 && (J = readScalarLTString), L) {
              let H = k[M];
              if (E == WireType.LengthDelimited && $ != ScalarType.STRING && $ != ScalarType.BYTES) {
                let B = u.uint32() + u.pos;
                for (; u.pos < B; )
                  H.push(J(u, $));
              } else
                H.push(J(u, $));
            } else
              k[M] = J(u, $);
            break;
          case "message":
            const V = _.T;
            L ? k[M].push(readMessageField(u, new V(), l)) : k[M] instanceof Message ? readMessageField(u, k[M], l) : (k[M] = readMessageField(u, new V(), l), V.fieldWrapper && !_.oneof && !_.repeated && (k[M] = V.fieldWrapper.unwrapField(k[M])));
            break;
          case "map":
            let [q, G] = readMapEntry(_, u, l);
            k[M][q] = G;
            break;
        }
      }
    }
  };
}
function readMessageField(a, u, c) {
  return u.getType().runtime.bin.readMessage(u, a, a.uint32(), c), u;
}
function readMapEntry(a, u, c) {
  const l = u.uint32(), v = u.pos + l;
  let S, g;
  for (; u.pos < v; ) {
    let [E] = u.tag();
    switch (E) {
      case 1:
        S = readScalar$1(u, a.K);
        break;
      case 2:
        switch (a.V.kind) {
          case "scalar":
            g = readScalar$1(u, a.V.T);
            break;
          case "enum":
            g = u.int32();
            break;
          case "message":
            g = readMessageField(u, new a.V.T(), c);
            break;
        }
        break;
    }
  }
  if (S === void 0) {
    let E = scalarDefaultValue(a.K, LongType.BIGINT);
    S = a.K == ScalarType.BOOL ? E.toString() : E;
  }
  if (typeof S != "string" && typeof S != "number" && (S = S.toString()), g === void 0)
    switch (a.V.kind) {
      case "scalar":
        g = scalarDefaultValue(a.V.T, LongType.BIGINT);
        break;
      case "enum":
        g = 0;
        break;
      case "message":
        g = new a.V.T();
        break;
    }
  return [S, g];
}
function readScalarLTString(a, u) {
  const c = readScalar$1(a, u);
  return typeof c == "bigint" ? c.toString() : c;
}
function readScalar$1(a, u) {
  switch (u) {
    case ScalarType.STRING:
      return a.string();
    case ScalarType.BOOL:
      return a.bool();
    case ScalarType.DOUBLE:
      return a.double();
    case ScalarType.FLOAT:
      return a.float();
    case ScalarType.INT32:
      return a.int32();
    case ScalarType.INT64:
      return a.int64();
    case ScalarType.UINT64:
      return a.uint64();
    case ScalarType.FIXED64:
      return a.fixed64();
    case ScalarType.BYTES:
      return a.bytes();
    case ScalarType.FIXED32:
      return a.fixed32();
    case ScalarType.SFIXED32:
      return a.sfixed32();
    case ScalarType.SFIXED64:
      return a.sfixed64();
    case ScalarType.SINT64:
      return a.sint64();
    case ScalarType.UINT32:
      return a.uint32();
    case ScalarType.SINT32:
      return a.sint32();
  }
}
function writeMapEntry(a, u, c, l, v) {
  a.tag(c.no, WireType.LengthDelimited), a.fork();
  let S = l;
  switch (c.K) {
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.UINT32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
      S = Number.parseInt(l);
      break;
    case ScalarType.BOOL:
      assert(l == "true" || l == "false"), S = l == "true";
      break;
  }
  switch (writeScalar$1(a, c.K, 1, S, !0), c.V.kind) {
    case "scalar":
      writeScalar$1(a, c.V.T, 2, v, !0);
      break;
    case "enum":
      writeScalar$1(a, ScalarType.INT32, 2, v, !0);
      break;
    case "message":
      writeMessageField(a, u, c.V.T, 2, v);
      break;
  }
  a.join();
}
function writeMessageField(a, u, c, l, v) {
  if (v !== void 0) {
    const S = wrapField(c, v);
    a.tag(l, WireType.LengthDelimited).bytes(S.toBinary(u));
  }
}
function writeScalar$1(a, u, c, l, v) {
  let [S, g, E] = scalarTypeInfo(u, l);
  (!E || v) && a.tag(c, S)[g](l);
}
function writePacked(a, u, c, l) {
  if (!l.length)
    return;
  a.tag(c, WireType.LengthDelimited).fork();
  let [, v] = scalarTypeInfo(u);
  for (let S = 0; S < l.length; S++)
    a[v](l[S]);
  a.join();
}
function makeBinaryFormatProto3() {
  return Object.assign(Object.assign({}, makeBinaryFormatCommon()), {
    writeMessage(a, u, c) {
      const l = a.getType();
      for (const v of l.fields.byNumber()) {
        let S, g = v.repeated, E = v.localName;
        if (v.oneof) {
          const _ = a[v.oneof.localName];
          if (_.case !== E)
            continue;
          S = _.value;
        } else
          S = a[E];
        switch (v.kind) {
          case "scalar":
          case "enum":
            let _ = v.kind == "enum" ? ScalarType.INT32 : v.T;
            if (g)
              if (v.packed)
                writePacked(u, _, v.no, S);
              else
                for (const k of S)
                  writeScalar$1(u, _, v.no, k, !0);
            else
              S !== void 0 && writeScalar$1(u, _, v.no, S, !!v.oneof || v.opt);
            break;
          case "message":
            if (g)
              for (const k of S)
                writeMessageField(u, c, v.T, v.no, k);
            else
              writeMessageField(u, c, v.T, v.no, S);
            break;
          case "map":
            for (const [k, L] of Object.entries(S))
              writeMapEntry(u, c, v, k, L);
            break;
        }
      }
      return c.writeUnknownFields && this.writeUnknownFields(a, u), u;
    }
  });
}
let encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), decTable = [];
for (let a = 0; a < encTable.length; a++)
  decTable[encTable[a].charCodeAt(0)] = a;
decTable[45] = encTable.indexOf("+");
decTable[95] = encTable.indexOf("/");
const protoBase64 = {
  /**
   * Decodes a base64 string to a byte array.
   *
   * - ignores white-space, including line breaks and tabs
   * - allows inner padding (can decode concatenated base64 strings)
   * - does not require padding
   * - understands base64url encoding:
   *   "-" instead of "+",
   *   "_" instead of "/",
   *   no padding
   */
  dec(a) {
    let u = a.length * 3 / 4;
    a[a.length - 2] == "=" ? u -= 2 : a[a.length - 1] == "=" && (u -= 1);
    let c = new Uint8Array(u), l = 0, v = 0, S, g = 0;
    for (let E = 0; E < a.length; E++) {
      if (S = decTable[a.charCodeAt(E)], S === void 0)
        switch (a[E]) {
          case "=":
            v = 0;
          case `
`:
          case "\r":
          case "	":
          case " ":
            continue;
          default:
            throw Error("invalid base64 string.");
        }
      switch (v) {
        case 0:
          g = S, v = 1;
          break;
        case 1:
          c[l++] = g << 2 | (S & 48) >> 4, g = S, v = 2;
          break;
        case 2:
          c[l++] = (g & 15) << 4 | (S & 60) >> 2, g = S, v = 3;
          break;
        case 3:
          c[l++] = (g & 3) << 6 | S, v = 0;
          break;
      }
    }
    if (v == 1)
      throw Error("invalid base64 string.");
    return c.subarray(0, l);
  },
  /**
   * Encode a byte array to a base64 string.
   */
  enc(a) {
    let u = "", c = 0, l, v = 0;
    for (let S = 0; S < a.length; S++)
      switch (l = a[S], c) {
        case 0:
          u += encTable[l >> 2], v = (l & 3) << 4, c = 1;
          break;
        case 1:
          u += encTable[v | l >> 4], v = (l & 15) << 2, c = 2;
          break;
        case 2:
          u += encTable[v | l >> 6], u += encTable[l & 63], c = 0;
          break;
      }
    return c && (u += encTable[v], u += "=", c == 1 && (u += "=")), u;
  }
}, jsonReadDefaults = {
  ignoreUnknownFields: !1
}, jsonWriteDefaults = {
  emitDefaultValues: !1,
  enumAsInteger: !1,
  useProtoFieldName: !1,
  prettySpaces: 0
};
function makeReadOptions(a) {
  return a ? Object.assign(Object.assign({}, jsonReadDefaults), a) : jsonReadDefaults;
}
function makeWriteOptions(a) {
  return a ? Object.assign(Object.assign({}, jsonWriteDefaults), a) : jsonWriteDefaults;
}
function makeJsonFormatCommon(a) {
  const u = a(writeEnum, writeScalar);
  return {
    makeReadOptions,
    makeWriteOptions,
    readMessage(c, l, v, S) {
      if (l == null || Array.isArray(l) || typeof l != "object")
        throw new Error("cannot decode message ".concat(c.typeName, " from JSON: ").concat(this.debug(l)));
      S = S ?? new c();
      const g = {};
      for (const [E, _] of Object.entries(l)) {
        const k = c.fields.findJsonName(E);
        if (!k) {
          if (!v.ignoreUnknownFields)
            throw new Error("cannot decode message ".concat(c.typeName, ' from JSON: key "').concat(E, '" is unknown'));
          continue;
        }
        let L = k.localName, M = S;
        if (k.oneof) {
          if (_ === null && k.kind == "scalar")
            continue;
          const $ = g[k.oneof.localName];
          if ($)
            throw new Error("cannot decode message ".concat(c.typeName, ' from JSON: multiple keys for oneof "').concat(k.oneof.name, '" present: "').concat($, '", "').concat(E, '"'));
          g[k.oneof.localName] = E, M = M[k.oneof.localName] = {
            case: L
          }, L = "value";
        }
        if (k.repeated) {
          if (_ === null)
            continue;
          if (!Array.isArray(_))
            throw new Error("cannot decode field ".concat(c.typeName, ".").concat(k.name, " from JSON: ").concat(this.debug(_)));
          const $ = M[L];
          for (const J of _) {
            if (J === null)
              throw new Error("cannot decode field ".concat(c.typeName, ".").concat(k.name, " from JSON: ").concat(this.debug(J)));
            let V;
            switch (k.kind) {
              case "message":
                V = k.T.fromJson(J, v);
                break;
              case "enum":
                if (V = readEnum(k.T, J, v.ignoreUnknownFields), V === void 0)
                  continue;
                break;
              case "scalar":
                try {
                  V = readScalar(k.T, J, k.L);
                } catch (q) {
                  let G = "cannot decode field ".concat(c.typeName, ".").concat(k.name, " from JSON: ").concat(this.debug(J));
                  throw q instanceof Error && q.message.length > 0 && (G += ": ".concat(q.message)), new Error(G);
                }
                break;
            }
            $.push(V);
          }
        } else if (k.kind == "map") {
          if (_ === null)
            continue;
          if (Array.isArray(_) || typeof _ != "object")
            throw new Error("cannot decode field ".concat(c.typeName, ".").concat(k.name, " from JSON: ").concat(this.debug(_)));
          const $ = M[L];
          for (const [J, V] of Object.entries(_)) {
            if (V === null)
              throw new Error("cannot decode field ".concat(c.typeName, ".").concat(k.name, " from JSON: map value null"));
            let q;
            switch (k.V.kind) {
              case "message":
                q = k.V.T.fromJson(V, v);
                break;
              case "enum":
                if (q = readEnum(k.V.T, V, v.ignoreUnknownFields), q === void 0)
                  continue;
                break;
              case "scalar":
                try {
                  q = readScalar(k.V.T, V, LongType.BIGINT);
                } catch (G) {
                  let H = "cannot decode map value for field ".concat(c.typeName, ".").concat(k.name, " from JSON: ").concat(this.debug(_));
                  throw G instanceof Error && G.message.length > 0 && (H += ": ".concat(G.message)), new Error(H);
                }
                break;
            }
            try {
              $[readScalar(k.K, k.K == ScalarType.BOOL ? J == "true" ? !0 : J == "false" ? !1 : J : J, LongType.BIGINT).toString()] = q;
            } catch (G) {
              let H = "cannot decode map key for field ".concat(c.typeName, ".").concat(k.name, " from JSON: ").concat(this.debug(_));
              throw G instanceof Error && G.message.length > 0 && (H += ": ".concat(G.message)), new Error(H);
            }
          }
        } else
          switch (k.kind) {
            case "message":
              const $ = k.T;
              if (_ === null && $.typeName != "google.protobuf.Value") {
                if (k.oneof)
                  throw new Error("cannot decode field ".concat(c.typeName, ".").concat(k.name, ' from JSON: null is invalid for oneof field "').concat(E, '"'));
                continue;
              }
              M[L] instanceof Message ? M[L].fromJson(_, v) : (M[L] = $.fromJson(_, v), $.fieldWrapper && !k.oneof && (M[L] = $.fieldWrapper.unwrapField(M[L])));
              break;
            case "enum":
              const J = readEnum(k.T, _, v.ignoreUnknownFields);
              J !== void 0 && (M[L] = J);
              break;
            case "scalar":
              try {
                M[L] = readScalar(k.T, _, k.L);
              } catch (V) {
                let q = "cannot decode field ".concat(c.typeName, ".").concat(k.name, " from JSON: ").concat(this.debug(_));
                throw V instanceof Error && V.message.length > 0 && (q += ": ".concat(V.message)), new Error(q);
              }
              break;
          }
      }
      return S;
    },
    writeMessage(c, l) {
      const v = c.getType(), S = {};
      let g;
      try {
        for (const E of v.fields.byMember()) {
          let _;
          if (E.kind == "oneof") {
            const k = c[E.localName];
            if (k.value === void 0)
              continue;
            if (g = E.findField(k.case), !g)
              throw "oneof case not found: " + k.case;
            _ = u(g, k.value, l);
          } else
            g = E, _ = u(g, c[g.localName], l);
          _ !== void 0 && (S[l.useProtoFieldName ? g.name : g.jsonName] = _);
        }
      } catch (E) {
        const _ = g ? "cannot encode field ".concat(v.typeName, ".").concat(g.name, " to JSON") : "cannot encode message ".concat(v.typeName, " to JSON"), k = E instanceof Error ? E.message : String(E);
        throw new Error(_ + (k.length > 0 ? ": ".concat(k) : ""));
      }
      return S;
    },
    readScalar,
    writeScalar,
    debug: debugJsonValue
  };
}
function debugJsonValue(a) {
  if (a === null)
    return "null";
  switch (typeof a) {
    case "object":
      return Array.isArray(a) ? "array" : "object";
    case "string":
      return a.length > 100 ? "string" : '"'.concat(a.split('"').join('\\"'), '"');
    default:
      return String(a);
  }
}
function readScalar(a, u, c) {
  switch (a) {
    case ScalarType.DOUBLE:
    case ScalarType.FLOAT:
      if (u === null)
        return 0;
      if (u === "NaN")
        return Number.NaN;
      if (u === "Infinity")
        return Number.POSITIVE_INFINITY;
      if (u === "-Infinity")
        return Number.NEGATIVE_INFINITY;
      if (u === "" || typeof u == "string" && u.trim().length !== u.length || typeof u != "string" && typeof u != "number")
        break;
      const l = Number(u);
      if (Number.isNaN(l) || !Number.isFinite(l))
        break;
      return a == ScalarType.FLOAT && assertFloat32(l), l;
    case ScalarType.INT32:
    case ScalarType.FIXED32:
    case ScalarType.SFIXED32:
    case ScalarType.SINT32:
    case ScalarType.UINT32:
      if (u === null)
        return 0;
      let v;
      if (typeof u == "number" ? v = u : typeof u == "string" && u.length > 0 && u.trim().length === u.length && (v = Number(u)), v === void 0)
        break;
      return a == ScalarType.UINT32 ? assertUInt32(v) : assertInt32(v), v;
    case ScalarType.INT64:
    case ScalarType.SFIXED64:
    case ScalarType.SINT64:
      if (u === null)
        return protoInt64.zero;
      if (typeof u != "number" && typeof u != "string")
        break;
      const S = protoInt64.parse(u);
      return c ? S.toString() : S;
    case ScalarType.FIXED64:
    case ScalarType.UINT64:
      if (u === null)
        return protoInt64.zero;
      if (typeof u != "number" && typeof u != "string")
        break;
      const g = protoInt64.uParse(u);
      return c ? g.toString() : g;
    case ScalarType.BOOL:
      if (u === null)
        return !1;
      if (typeof u != "boolean")
        break;
      return u;
    case ScalarType.STRING:
      if (u === null)
        return "";
      if (typeof u != "string")
        break;
      try {
        encodeURIComponent(u);
      } catch {
        throw new Error("invalid UTF8");
      }
      return u;
    case ScalarType.BYTES:
      if (u === null || u === "")
        return new Uint8Array(0);
      if (typeof u != "string")
        break;
      return protoBase64.dec(u);
  }
  throw new Error();
}
function readEnum(a, u, c) {
  if (u === null)
    return 0;
  switch (typeof u) {
    case "number":
      if (Number.isInteger(u))
        return u;
      break;
    case "string":
      const l = a.findName(u);
      if (l || c)
        return l == null ? void 0 : l.no;
      break;
  }
  throw new Error("cannot decode enum ".concat(a.typeName, " from JSON: ").concat(debugJsonValue(u)));
}
function writeEnum(a, u, c, l) {
  var v;
  if (u === void 0)
    return u;
  if (u === 0 && !c)
    return;
  if (l)
    return u;
  if (a.typeName == "google.protobuf.NullValue")
    return null;
  const S = a.findNumber(u);
  return (v = S == null ? void 0 : S.name) !== null && v !== void 0 ? v : u;
}
function writeScalar(a, u, c) {
  if (u !== void 0)
    switch (a) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        return assert(typeof u == "number"), u != 0 || c ? u : void 0;
      case ScalarType.FLOAT:
      case ScalarType.DOUBLE:
        return assert(typeof u == "number"), Number.isNaN(u) ? "NaN" : u === Number.POSITIVE_INFINITY ? "Infinity" : u === Number.NEGATIVE_INFINITY ? "-Infinity" : u !== 0 || c ? u : void 0;
      case ScalarType.STRING:
        return assert(typeof u == "string"), u.length > 0 || c ? u : void 0;
      case ScalarType.BOOL:
        return assert(typeof u == "boolean"), u || c ? u : void 0;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return assert(typeof u == "bigint" || typeof u == "string" || typeof u == "number"), c || u != 0 ? u.toString(10) : void 0;
      case ScalarType.BYTES:
        return assert(u instanceof Uint8Array), c || u.byteLength > 0 ? protoBase64.enc(u) : void 0;
    }
}
function makeJsonFormatProto3() {
  return makeJsonFormatCommon((a, u) => function(l, v, S) {
    if (l.kind == "map") {
      const g = {};
      switch (l.V.kind) {
        case "scalar":
          for (const [_, k] of Object.entries(v)) {
            const L = u(l.V.T, k, !0);
            assert(L !== void 0), g[_.toString()] = L;
          }
          break;
        case "message":
          for (const [_, k] of Object.entries(v))
            g[_.toString()] = k.toJson(S);
          break;
        case "enum":
          const E = l.V.T;
          for (const [_, k] of Object.entries(v)) {
            assert(k === void 0 || typeof k == "number");
            const L = a(E, k, !0, S.enumAsInteger);
            assert(L !== void 0), g[_.toString()] = L;
          }
          break;
      }
      return S.emitDefaultValues || Object.keys(g).length > 0 ? g : void 0;
    } else if (l.repeated) {
      const g = [];
      switch (l.kind) {
        case "scalar":
          for (let E = 0; E < v.length; E++)
            g.push(u(l.T, v[E], !0));
          break;
        case "enum":
          for (let E = 0; E < v.length; E++)
            g.push(a(l.T, v[E], !0, S.enumAsInteger));
          break;
        case "message":
          for (let E = 0; E < v.length; E++)
            g.push(wrapField(l.T, v[E]).toJson(S));
          break;
      }
      return S.emitDefaultValues || g.length > 0 ? g : void 0;
    } else
      switch (l.kind) {
        case "scalar":
          return u(l.T, v, !!l.oneof || l.opt || S.emitDefaultValues);
        case "enum":
          return a(l.T, v, !!l.oneof || l.opt || S.emitDefaultValues, S.enumAsInteger);
        case "message":
          return v !== void 0 ? wrapField(l.T, v).toJson(S) : void 0;
      }
  });
}
function makeUtilCommon() {
  return {
    setEnumType,
    initPartial(a, u) {
      if (a === void 0)
        return;
      const c = u.getType();
      for (const l of c.fields.byMember()) {
        const v = l.localName, S = u, g = a;
        if (g[v] !== void 0)
          switch (l.kind) {
            case "oneof":
              const E = g[v].case;
              if (E === void 0)
                continue;
              const _ = l.findField(E);
              let k = g[v].value;
              _ && _.kind == "message" && !(k instanceof _.T) ? k = new _.T(k) : _ && _.kind === "scalar" && _.T === ScalarType.BYTES && (k = toU8Arr(k)), S[v] = {
                case: E,
                value: k
              };
              break;
            case "scalar":
            case "enum":
              let L = g[v];
              l.T === ScalarType.BYTES && (L = l.repeated ? L.map(toU8Arr) : toU8Arr(L)), S[v] = L;
              break;
            case "map":
              switch (l.V.kind) {
                case "scalar":
                case "enum":
                  if (l.V.T === ScalarType.BYTES)
                    for (const [J, V] of Object.entries(g[v]))
                      S[v][J] = toU8Arr(V);
                  else
                    Object.assign(S[v], g[v]);
                  break;
                case "message":
                  const $ = l.V.T;
                  for (const J of Object.keys(g[v])) {
                    let V = g[v][J];
                    $.fieldWrapper || (V = new $(V)), S[v][J] = V;
                  }
                  break;
              }
              break;
            case "message":
              const M = l.T;
              if (l.repeated)
                S[v] = g[v].map(($) => $ instanceof M ? $ : new M($));
              else if (g[v] !== void 0) {
                const $ = g[v];
                M.fieldWrapper ? /* We can't use BytesValue.typeName as that will create a circular import */ M.typeName === "google.protobuf.BytesValue" ? S[v] = toU8Arr($) : S[v] = $ : S[v] = $ instanceof M ? $ : new M($);
              }
              break;
          }
      }
    },
    equals(a, u, c) {
      return u === c ? !0 : !u || !c ? !1 : a.fields.byMember().every((l) => {
        const v = u[l.localName], S = c[l.localName];
        if (l.repeated) {
          if (v.length !== S.length)
            return !1;
          switch (l.kind) {
            case "message":
              return v.every((g, E) => l.T.equals(g, S[E]));
            case "scalar":
              return v.every((g, E) => scalarEquals(l.T, g, S[E]));
            case "enum":
              return v.every((g, E) => scalarEquals(ScalarType.INT32, g, S[E]));
          }
          throw new Error("repeated cannot contain ".concat(l.kind));
        }
        switch (l.kind) {
          case "message":
            return l.T.equals(v, S);
          case "enum":
            return scalarEquals(ScalarType.INT32, v, S);
          case "scalar":
            return scalarEquals(l.T, v, S);
          case "oneof":
            if (v.case !== S.case)
              return !1;
            const g = l.findField(v.case);
            if (g === void 0)
              return !0;
            switch (g.kind) {
              case "message":
                return g.T.equals(v.value, S.value);
              case "enum":
                return scalarEquals(ScalarType.INT32, v.value, S.value);
              case "scalar":
                return scalarEquals(g.T, v.value, S.value);
            }
            throw new Error("oneof cannot contain ".concat(g.kind));
          case "map":
            const E = Object.keys(v).concat(Object.keys(S));
            switch (l.V.kind) {
              case "message":
                const _ = l.V.T;
                return E.every((L) => _.equals(v[L], S[L]));
              case "enum":
                return E.every((L) => scalarEquals(ScalarType.INT32, v[L], S[L]));
              case "scalar":
                const k = l.V.T;
                return E.every((L) => scalarEquals(k, v[L], S[L]));
            }
            break;
        }
      });
    },
    clone(a) {
      const u = a.getType(), c = new u(), l = c;
      for (const v of u.fields.byMember()) {
        const S = a[v.localName];
        let g;
        if (v.repeated)
          g = S.map(cloneSingularField);
        else if (v.kind == "map") {
          g = l[v.localName];
          for (const [E, _] of Object.entries(S))
            g[E] = cloneSingularField(_);
        } else
          v.kind == "oneof" ? g = v.findField(S.case) ? {
            case: S.case,
            value: cloneSingularField(S.value)
          } : {
            case: void 0
          } : g = cloneSingularField(S);
        l[v.localName] = g;
      }
      return c;
    }
  };
}
function cloneSingularField(a) {
  if (a === void 0)
    return a;
  if (a instanceof Message)
    return a.clone();
  if (a instanceof Uint8Array) {
    const u = new Uint8Array(a.byteLength);
    return u.set(a), u;
  }
  return a;
}
function toU8Arr(a) {
  return a instanceof Uint8Array ? a : new Uint8Array(a);
}
class InternalFieldList {
  constructor(u, c) {
    this._fields = u, this._normalizer = c;
  }
  findJsonName(u) {
    if (!this.jsonNames) {
      const c = {};
      for (const l of this.list())
        c[l.jsonName] = c[l.name] = l;
      this.jsonNames = c;
    }
    return this.jsonNames[u];
  }
  find(u) {
    if (!this.numbers) {
      const c = {};
      for (const l of this.list())
        c[l.no] = l;
      this.numbers = c;
    }
    return this.numbers[u];
  }
  list() {
    return this.all || (this.all = this._normalizer(this._fields)), this.all;
  }
  byNumber() {
    return this.numbersAsc || (this.numbersAsc = this.list().concat().sort((u, c) => u.no - c.no)), this.numbersAsc;
  }
  byMember() {
    if (!this.members) {
      this.members = [];
      const u = this.members;
      let c;
      for (const l of this.list())
        l.oneof ? l.oneof !== c && (c = l.oneof, u.push(c)) : u.push(l);
    }
    return this.members;
  }
}
function localFieldName(a, u) {
  const c = protoCamelCase(a);
  return u ? c : safeObjectProperty(safeMessageProperty(c));
}
function localOneofName(a) {
  return localFieldName(a, !1);
}
const fieldJsonName = protoCamelCase;
function protoCamelCase(a) {
  let u = !1;
  const c = [];
  for (let l = 0; l < a.length; l++) {
    let v = a.charAt(l);
    switch (v) {
      case "_":
        u = !0;
        break;
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        c.push(v), u = !1;
        break;
      default:
        u && (u = !1, v = v.toUpperCase()), c.push(v);
        break;
    }
  }
  return c.join("");
}
const reservedObjectProperties = /* @__PURE__ */ new Set([
  // names reserved by JavaScript
  "constructor",
  "toString",
  "toJSON",
  "valueOf"
]), reservedMessageProperties = /* @__PURE__ */ new Set([
  // names reserved by the runtime
  "getType",
  "clone",
  "equals",
  "fromBinary",
  "fromJson",
  "fromJsonString",
  "toBinary",
  "toJson",
  "toJsonString",
  // names reserved by the runtime for the future
  "toObject"
]), fallback = (a) => "".concat(a, "$"), safeMessageProperty = (a) => reservedMessageProperties.has(a) ? fallback(a) : a, safeObjectProperty = (a) => reservedObjectProperties.has(a) ? fallback(a) : a;
class InternalOneofInfo {
  constructor(u) {
    this.kind = "oneof", this.repeated = !1, this.packed = !1, this.opt = !1, this.default = void 0, this.fields = [], this.name = u, this.localName = localOneofName(u);
  }
  addField(u) {
    assert(u.oneof === this, "field ".concat(u.name, " not one of ").concat(this.name)), this.fields.push(u);
  }
  findField(u) {
    if (!this._lookup) {
      this._lookup = /* @__PURE__ */ Object.create(null);
      for (let c = 0; c < this.fields.length; c++)
        this._lookup[this.fields[c].localName] = this.fields[c];
    }
    return this._lookup[u];
  }
}
const proto3 = makeProtoRuntime("proto3", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {
  newFieldList(a) {
    return new InternalFieldList(a, normalizeFieldInfosProto3);
  },
  initFields(a) {
    for (const u of a.getType().fields.byMember()) {
      if (u.opt)
        continue;
      const c = u.localName, l = a;
      if (u.repeated) {
        l[c] = [];
        continue;
      }
      switch (u.kind) {
        case "oneof":
          l[c] = {
            case: void 0
          };
          break;
        case "enum":
          l[c] = 0;
          break;
        case "map":
          l[c] = {};
          break;
        case "scalar":
          l[c] = scalarDefaultValue(u.T, u.L);
          break;
      }
    }
  }
}));
function normalizeFieldInfosProto3(a) {
  var u, c, l, v;
  const S = [];
  let g;
  for (const E of typeof a == "function" ? a() : a) {
    const _ = E;
    if (_.localName = localFieldName(E.name, E.oneof !== void 0), _.jsonName = (u = E.jsonName) !== null && u !== void 0 ? u : fieldJsonName(E.name), _.repeated = (c = E.repeated) !== null && c !== void 0 ? c : !1, E.kind == "scalar" && (_.L = (l = E.L) !== null && l !== void 0 ? l : LongType.BIGINT), _.packed = (v = E.packed) !== null && v !== void 0 ? v : E.kind == "enum" || E.kind == "scalar" && E.T != ScalarType.BYTES && E.T != ScalarType.STRING, E.oneof !== void 0) {
      const k = typeof E.oneof == "string" ? E.oneof : E.oneof.name;
      (!g || g.name != k) && (g = new InternalOneofInfo(k)), _.oneof = g, g.addField(_);
    }
    S.push(_);
  }
  return S;
}
class Timestamp extends Message {
  constructor(u) {
    super(), this.seconds = protoInt64.zero, this.nanos = 0, proto3.util.initPartial(u, this);
  }
  fromJson(u, c) {
    if (typeof u != "string")
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: ".concat(proto3.json.debug(u)));
    const l = u.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
    if (!l)
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    const v = Date.parse(l[1] + "-" + l[2] + "-" + l[3] + "T" + l[4] + ":" + l[5] + ":" + l[6] + (l[8] ? l[8] : "Z"));
    if (Number.isNaN(v))
      throw new Error("cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string");
    if (v < Date.parse("0001-01-01T00:00:00Z") || v > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    return this.seconds = protoInt64.parse(v / 1e3), this.nanos = 0, l[7] && (this.nanos = parseInt("1" + l[7] + "0".repeat(9 - l[7].length)) - 1e9), this;
  }
  toJson(u) {
    const c = Number(this.seconds) * 1e3;
    if (c < Date.parse("0001-01-01T00:00:00Z") || c > Date.parse("9999-12-31T23:59:59Z"))
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive");
    if (this.nanos < 0)
      throw new Error("cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative");
    let l = "Z";
    if (this.nanos > 0) {
      const v = (this.nanos + 1e9).toString().substring(1);
      v.substring(3) === "000000" ? l = "." + v.substring(0, 3) + "Z" : v.substring(6) === "000" ? l = "." + v.substring(0, 6) + "Z" : l = "." + v + "Z";
    }
    return new Date(c).toISOString().replace(".000Z", l);
  }
  toDate() {
    return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
  }
  static now() {
    return Timestamp.fromDate(/* @__PURE__ */ new Date());
  }
  static fromDate(u) {
    const c = u.getTime();
    return new Timestamp({
      seconds: protoInt64.parse(Math.floor(c / 1e3)),
      nanos: c % 1e3 * 1e6
    });
  }
  static fromBinary(u, c) {
    return new Timestamp().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Timestamp().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Timestamp().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Timestamp, u, c);
  }
}
Timestamp.runtime = proto3;
Timestamp.typeName = "google.protobuf.Timestamp";
Timestamp.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "seconds",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "nanos",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
var AudioCodec$1;
(function(a) {
  a[a.DEFAULT_AC = 0] = "DEFAULT_AC", a[a.OPUS = 1] = "OPUS", a[a.AAC = 2] = "AAC";
})(AudioCodec$1 || (AudioCodec$1 = {}));
proto3.util.setEnumType(AudioCodec$1, "livekit.AudioCodec", [{
  no: 0,
  name: "DEFAULT_AC"
}, {
  no: 1,
  name: "OPUS"
}, {
  no: 2,
  name: "AAC"
}]);
var VideoCodec$1;
(function(a) {
  a[a.DEFAULT_VC = 0] = "DEFAULT_VC", a[a.H264_BASELINE = 1] = "H264_BASELINE", a[a.H264_MAIN = 2] = "H264_MAIN", a[a.H264_HIGH = 3] = "H264_HIGH", a[a.VP8 = 4] = "VP8";
})(VideoCodec$1 || (VideoCodec$1 = {}));
proto3.util.setEnumType(VideoCodec$1, "livekit.VideoCodec", [{
  no: 0,
  name: "DEFAULT_VC"
}, {
  no: 1,
  name: "H264_BASELINE"
}, {
  no: 2,
  name: "H264_MAIN"
}, {
  no: 3,
  name: "H264_HIGH"
}, {
  no: 4,
  name: "VP8"
}]);
var ImageCodec;
(function(a) {
  a[a.IC_DEFAULT = 0] = "IC_DEFAULT", a[a.IC_JPEG = 1] = "IC_JPEG";
})(ImageCodec || (ImageCodec = {}));
proto3.util.setEnumType(ImageCodec, "livekit.ImageCodec", [{
  no: 0,
  name: "IC_DEFAULT"
}, {
  no: 1,
  name: "IC_JPEG"
}]);
var TrackType;
(function(a) {
  a[a.AUDIO = 0] = "AUDIO", a[a.VIDEO = 1] = "VIDEO", a[a.DATA = 2] = "DATA";
})(TrackType || (TrackType = {}));
proto3.util.setEnumType(TrackType, "livekit.TrackType", [{
  no: 0,
  name: "AUDIO"
}, {
  no: 1,
  name: "VIDEO"
}, {
  no: 2,
  name: "DATA"
}]);
var TrackSource;
(function(a) {
  a[a.UNKNOWN = 0] = "UNKNOWN", a[a.CAMERA = 1] = "CAMERA", a[a.MICROPHONE = 2] = "MICROPHONE", a[a.SCREEN_SHARE = 3] = "SCREEN_SHARE", a[a.SCREEN_SHARE_AUDIO = 4] = "SCREEN_SHARE_AUDIO";
})(TrackSource || (TrackSource = {}));
proto3.util.setEnumType(TrackSource, "livekit.TrackSource", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "CAMERA"
}, {
  no: 2,
  name: "MICROPHONE"
}, {
  no: 3,
  name: "SCREEN_SHARE"
}, {
  no: 4,
  name: "SCREEN_SHARE_AUDIO"
}]);
var VideoQuality$1;
(function(a) {
  a[a.LOW = 0] = "LOW", a[a.MEDIUM = 1] = "MEDIUM", a[a.HIGH = 2] = "HIGH", a[a.OFF = 3] = "OFF";
})(VideoQuality$1 || (VideoQuality$1 = {}));
proto3.util.setEnumType(VideoQuality$1, "livekit.VideoQuality", [{
  no: 0,
  name: "LOW"
}, {
  no: 1,
  name: "MEDIUM"
}, {
  no: 2,
  name: "HIGH"
}, {
  no: 3,
  name: "OFF"
}]);
var ConnectionQuality$1;
(function(a) {
  a[a.POOR = 0] = "POOR", a[a.GOOD = 1] = "GOOD", a[a.EXCELLENT = 2] = "EXCELLENT", a[a.LOST = 3] = "LOST";
})(ConnectionQuality$1 || (ConnectionQuality$1 = {}));
proto3.util.setEnumType(ConnectionQuality$1, "livekit.ConnectionQuality", [{
  no: 0,
  name: "POOR"
}, {
  no: 1,
  name: "GOOD"
}, {
  no: 2,
  name: "EXCELLENT"
}, {
  no: 3,
  name: "LOST"
}]);
var ClientConfigSetting;
(function(a) {
  a[a.UNSET = 0] = "UNSET", a[a.DISABLED = 1] = "DISABLED", a[a.ENABLED = 2] = "ENABLED";
})(ClientConfigSetting || (ClientConfigSetting = {}));
proto3.util.setEnumType(ClientConfigSetting, "livekit.ClientConfigSetting", [{
  no: 0,
  name: "UNSET"
}, {
  no: 1,
  name: "DISABLED"
}, {
  no: 2,
  name: "ENABLED"
}]);
var DisconnectReason;
(function(a) {
  a[a.UNKNOWN_REASON = 0] = "UNKNOWN_REASON", a[a.CLIENT_INITIATED = 1] = "CLIENT_INITIATED", a[a.DUPLICATE_IDENTITY = 2] = "DUPLICATE_IDENTITY", a[a.SERVER_SHUTDOWN = 3] = "SERVER_SHUTDOWN", a[a.PARTICIPANT_REMOVED = 4] = "PARTICIPANT_REMOVED", a[a.ROOM_DELETED = 5] = "ROOM_DELETED", a[a.STATE_MISMATCH = 6] = "STATE_MISMATCH", a[a.JOIN_FAILURE = 7] = "JOIN_FAILURE", a[a.MIGRATION = 8] = "MIGRATION", a[a.SIGNAL_CLOSE = 9] = "SIGNAL_CLOSE";
})(DisconnectReason || (DisconnectReason = {}));
proto3.util.setEnumType(DisconnectReason, "livekit.DisconnectReason", [{
  no: 0,
  name: "UNKNOWN_REASON"
}, {
  no: 1,
  name: "CLIENT_INITIATED"
}, {
  no: 2,
  name: "DUPLICATE_IDENTITY"
}, {
  no: 3,
  name: "SERVER_SHUTDOWN"
}, {
  no: 4,
  name: "PARTICIPANT_REMOVED"
}, {
  no: 5,
  name: "ROOM_DELETED"
}, {
  no: 6,
  name: "STATE_MISMATCH"
}, {
  no: 7,
  name: "JOIN_FAILURE"
}, {
  no: 8,
  name: "MIGRATION"
}, {
  no: 9,
  name: "SIGNAL_CLOSE"
}]);
var ReconnectReason;
(function(a) {
  a[a.RR_UNKNOWN = 0] = "RR_UNKNOWN", a[a.RR_SIGNAL_DISCONNECTED = 1] = "RR_SIGNAL_DISCONNECTED", a[a.RR_PUBLISHER_FAILED = 2] = "RR_PUBLISHER_FAILED", a[a.RR_SUBSCRIBER_FAILED = 3] = "RR_SUBSCRIBER_FAILED", a[a.RR_SWITCH_CANDIDATE = 4] = "RR_SWITCH_CANDIDATE";
})(ReconnectReason || (ReconnectReason = {}));
proto3.util.setEnumType(ReconnectReason, "livekit.ReconnectReason", [{
  no: 0,
  name: "RR_UNKNOWN"
}, {
  no: 1,
  name: "RR_SIGNAL_DISCONNECTED"
}, {
  no: 2,
  name: "RR_PUBLISHER_FAILED"
}, {
  no: 3,
  name: "RR_SUBSCRIBER_FAILED"
}, {
  no: 4,
  name: "RR_SWITCH_CANDIDATE"
}]);
var SubscriptionError;
(function(a) {
  a[a.SE_UNKNOWN = 0] = "SE_UNKNOWN", a[a.SE_CODEC_UNSUPPORTED = 1] = "SE_CODEC_UNSUPPORTED", a[a.SE_TRACK_NOTFOUND = 2] = "SE_TRACK_NOTFOUND";
})(SubscriptionError || (SubscriptionError = {}));
proto3.util.setEnumType(SubscriptionError, "livekit.SubscriptionError", [{
  no: 0,
  name: "SE_UNKNOWN"
}, {
  no: 1,
  name: "SE_CODEC_UNSUPPORTED"
}, {
  no: 2,
  name: "SE_TRACK_NOTFOUND"
}]);
let Room$1 = class Lt extends Message {
  constructor(u) {
    super(), this.sid = "", this.name = "", this.emptyTimeout = 0, this.maxParticipants = 0, this.creationTime = protoInt64.zero, this.turnPassword = "", this.enabledCodecs = [], this.metadata = "", this.numParticipants = 0, this.numPublishers = 0, this.activeRecording = !1, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new Lt().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Lt().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Lt().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Lt, u, c);
  }
};
Room$1.runtime = proto3;
Room$1.typeName = "livekit.Room";
Room$1.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "empty_timeout",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "max_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "creation_time",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 6,
  name: "turn_password",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "enabled_codecs",
  kind: "message",
  T: Codec,
  repeated: !0
}, {
  no: 8,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "num_participants",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "num_publishers",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 10,
  name: "active_recording",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "version",
  kind: "message",
  T: TimedVersion
}]);
class Codec extends Message {
  constructor(u) {
    super(), this.mime = "", this.fmtpLine = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new Codec().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Codec().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Codec().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Codec, u, c);
  }
}
Codec.runtime = proto3;
Codec.typeName = "livekit.Codec";
Codec.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "mime",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "fmtp_line",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class PlayoutDelay extends Message {
  constructor(u) {
    super(), this.enabled = !1, this.min = 0, this.max = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new PlayoutDelay().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new PlayoutDelay().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new PlayoutDelay().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(PlayoutDelay, u, c);
  }
}
PlayoutDelay.runtime = proto3;
PlayoutDelay.typeName = "livekit.PlayoutDelay";
PlayoutDelay.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "enabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "min",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "max",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
class ParticipantPermission extends Message {
  constructor(u) {
    super(), this.canSubscribe = !1, this.canPublish = !1, this.canPublishData = !1, this.canPublishSources = [], this.hidden = !1, this.recorder = !1, this.canUpdateMetadata = !1, this.agent = !1, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ParticipantPermission().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ParticipantPermission().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ParticipantPermission().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ParticipantPermission, u, c);
  }
}
ParticipantPermission.runtime = proto3;
ParticipantPermission.typeName = "livekit.ParticipantPermission";
ParticipantPermission.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "can_subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "can_publish",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "can_publish_data",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "can_publish_sources",
  kind: "enum",
  T: proto3.getEnumType(TrackSource),
  repeated: !0
}, {
  no: 7,
  name: "hidden",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "recorder",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 10,
  name: "can_update_metadata",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 11,
  name: "agent",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
class ParticipantInfo extends Message {
  constructor(u) {
    super(), this.sid = "", this.identity = "", this.state = ParticipantInfo_State.JOINING, this.tracks = [], this.metadata = "", this.joinedAt = protoInt64.zero, this.name = "", this.version = 0, this.region = "", this.isPublisher = !1, this.kind = ParticipantInfo_Kind.STANDARD, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ParticipantInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ParticipantInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ParticipantInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ParticipantInfo, u, c);
  }
}
ParticipantInfo.runtime = proto3;
ParticipantInfo.typeName = "livekit.ParticipantInfo";
ParticipantInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: proto3.getEnumType(ParticipantInfo_State)
}, {
  no: 4,
  name: "tracks",
  kind: "message",
  T: TrackInfo,
  repeated: !0
}, {
  no: 5,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "joined_at",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 9,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "version",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 11,
  name: "permission",
  kind: "message",
  T: ParticipantPermission
}, {
  no: 12,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "is_publisher",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(ParticipantInfo_Kind)
}]);
var ParticipantInfo_State;
(function(a) {
  a[a.JOINING = 0] = "JOINING", a[a.JOINED = 1] = "JOINED", a[a.ACTIVE = 2] = "ACTIVE", a[a.DISCONNECTED = 3] = "DISCONNECTED";
})(ParticipantInfo_State || (ParticipantInfo_State = {}));
proto3.util.setEnumType(ParticipantInfo_State, "livekit.ParticipantInfo.State", [{
  no: 0,
  name: "JOINING"
}, {
  no: 1,
  name: "JOINED"
}, {
  no: 2,
  name: "ACTIVE"
}, {
  no: 3,
  name: "DISCONNECTED"
}]);
var ParticipantInfo_Kind;
(function(a) {
  a[a.STANDARD = 0] = "STANDARD", a[a.INGRESS = 1] = "INGRESS", a[a.EGRESS = 2] = "EGRESS", a[a.SIP = 3] = "SIP", a[a.AGENT = 4] = "AGENT";
})(ParticipantInfo_Kind || (ParticipantInfo_Kind = {}));
proto3.util.setEnumType(ParticipantInfo_Kind, "livekit.ParticipantInfo.Kind", [{
  no: 0,
  name: "STANDARD"
}, {
  no: 1,
  name: "INGRESS"
}, {
  no: 2,
  name: "EGRESS"
}, {
  no: 3,
  name: "SIP"
}, {
  no: 4,
  name: "AGENT"
}]);
class Encryption extends Message {
  constructor(u) {
    super(), proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new Encryption().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Encryption().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Encryption().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Encryption, u, c);
  }
}
Encryption.runtime = proto3;
Encryption.typeName = "livekit.Encryption";
Encryption.fields = proto3.util.newFieldList(() => []);
var Encryption_Type;
(function(a) {
  a[a.NONE = 0] = "NONE", a[a.GCM = 1] = "GCM", a[a.CUSTOM = 2] = "CUSTOM";
})(Encryption_Type || (Encryption_Type = {}));
proto3.util.setEnumType(Encryption_Type, "livekit.Encryption.Type", [{
  no: 0,
  name: "NONE"
}, {
  no: 1,
  name: "GCM"
}, {
  no: 2,
  name: "CUSTOM"
}]);
class SimulcastCodecInfo extends Message {
  constructor(u) {
    super(), this.mimeType = "", this.mid = "", this.cid = "", this.layers = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SimulcastCodecInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SimulcastCodecInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SimulcastCodecInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SimulcastCodecInfo, u, c);
  }
}
SimulcastCodecInfo.runtime = proto3;
SimulcastCodecInfo.typeName = "livekit.SimulcastCodecInfo";
SimulcastCodecInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}]);
class TrackInfo extends Message {
  constructor(u) {
    super(), this.sid = "", this.type = TrackType.AUDIO, this.name = "", this.muted = !1, this.width = 0, this.height = 0, this.simulcast = !1, this.disableDtx = !1, this.source = TrackSource.UNKNOWN, this.layers = [], this.mimeType = "", this.mid = "", this.codecs = [], this.stereo = !1, this.disableRed = !1, this.encryption = Encryption_Type.NONE, this.stream = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new TrackInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new TrackInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new TrackInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(TrackInfo, u, c);
  }
}
TrackInfo.runtime = proto3;
TrackInfo.typeName = "livekit.TrackInfo";
TrackInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(TrackType)
}, {
  no: 3,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 4,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "simulcast",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 9,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 10,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}, {
  no: 11,
  name: "mime_type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "mid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 13,
  name: "codecs",
  kind: "message",
  T: SimulcastCodecInfo,
  repeated: !0
}, {
  no: 14,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 15,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 16,
  name: "encryption",
  kind: "enum",
  T: proto3.getEnumType(Encryption_Type)
}, {
  no: 17,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 18,
  name: "version",
  kind: "message",
  T: TimedVersion
}]);
class VideoLayer extends Message {
  constructor(u) {
    super(), this.quality = VideoQuality$1.LOW, this.width = 0, this.height = 0, this.bitrate = 0, this.ssrc = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new VideoLayer().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new VideoLayer().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new VideoLayer().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(VideoLayer, u, c);
  }
}
VideoLayer.runtime = proto3;
VideoLayer.typeName = "livekit.VideoLayer";
VideoLayer.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 2,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 4,
  name: "bitrate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "ssrc",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
class DataPacket extends Message {
  constructor(u) {
    super(), this.kind = DataPacket_Kind.RELIABLE, this.value = {
      case: void 0
    }, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new DataPacket().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new DataPacket().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new DataPacket().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(DataPacket, u, c);
  }
}
DataPacket.runtime = proto3;
DataPacket.typeName = "livekit.DataPacket";
DataPacket.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "kind",
  kind: "enum",
  T: proto3.getEnumType(DataPacket_Kind)
}, {
  no: 2,
  name: "user",
  kind: "message",
  T: UserPacket,
  oneof: "value"
}, {
  no: 3,
  name: "speaker",
  kind: "message",
  T: ActiveSpeakerUpdate,
  oneof: "value"
}]);
var DataPacket_Kind;
(function(a) {
  a[a.RELIABLE = 0] = "RELIABLE", a[a.LOSSY = 1] = "LOSSY";
})(DataPacket_Kind || (DataPacket_Kind = {}));
proto3.util.setEnumType(DataPacket_Kind, "livekit.DataPacket.Kind", [{
  no: 0,
  name: "RELIABLE"
}, {
  no: 1,
  name: "LOSSY"
}]);
class ActiveSpeakerUpdate extends Message {
  constructor(u) {
    super(), this.speakers = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ActiveSpeakerUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ActiveSpeakerUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ActiveSpeakerUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ActiveSpeakerUpdate, u, c);
  }
}
ActiveSpeakerUpdate.runtime = proto3;
ActiveSpeakerUpdate.typeName = "livekit.ActiveSpeakerUpdate";
ActiveSpeakerUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: SpeakerInfo,
  repeated: !0
}]);
class SpeakerInfo extends Message {
  constructor(u) {
    super(), this.sid = "", this.level = 0, this.active = !1, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SpeakerInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SpeakerInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SpeakerInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SpeakerInfo, u, c);
  }
}
SpeakerInfo.runtime = proto3;
SpeakerInfo.typeName = "livekit.SpeakerInfo";
SpeakerInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "level",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}, {
  no: 3,
  name: "active",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
class UserPacket extends Message {
  constructor(u) {
    super(), this.participantSid = "", this.participantIdentity = "", this.payload = new Uint8Array(0), this.destinationSids = [], this.destinationIdentities = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new UserPacket().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new UserPacket().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new UserPacket().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(UserPacket, u, c);
  }
}
UserPacket.runtime = proto3;
UserPacket.typeName = "livekit.UserPacket";
UserPacket.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "payload",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}, {
  no: 3,
  name: "destination_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 6,
  name: "destination_identities",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "topic",
  kind: "scalar",
  T: 9,
  opt: !0
}]);
class ParticipantTracks extends Message {
  constructor(u) {
    super(), this.participantSid = "", this.trackSids = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ParticipantTracks().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ParticipantTracks().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ParticipantTracks().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ParticipantTracks, u, c);
  }
}
ParticipantTracks.runtime = proto3;
ParticipantTracks.typeName = "livekit.ParticipantTracks";
ParticipantTracks.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}]);
class ServerInfo extends Message {
  constructor(u) {
    super(), this.edition = ServerInfo_Edition.Standard, this.version = "", this.protocol = 0, this.region = "", this.nodeId = "", this.debugInfo = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ServerInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ServerInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ServerInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ServerInfo, u, c);
  }
}
ServerInfo.runtime = proto3;
ServerInfo.typeName = "livekit.ServerInfo";
ServerInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "edition",
  kind: "enum",
  T: proto3.getEnumType(ServerInfo_Edition)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "node_id",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "debug_info",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var ServerInfo_Edition;
(function(a) {
  a[a.Standard = 0] = "Standard", a[a.Cloud = 1] = "Cloud";
})(ServerInfo_Edition || (ServerInfo_Edition = {}));
proto3.util.setEnumType(ServerInfo_Edition, "livekit.ServerInfo.Edition", [{
  no: 0,
  name: "Standard"
}, {
  no: 1,
  name: "Cloud"
}]);
class ClientInfo extends Message {
  constructor(u) {
    super(), this.sdk = ClientInfo_SDK.UNKNOWN, this.version = "", this.protocol = 0, this.os = "", this.osVersion = "", this.deviceModel = "", this.browser = "", this.browserVersion = "", this.address = "", this.network = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ClientInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ClientInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ClientInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ClientInfo, u, c);
  }
}
ClientInfo.runtime = proto3;
ClientInfo.typeName = "livekit.ClientInfo";
ClientInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "sdk",
  kind: "enum",
  T: proto3.getEnumType(ClientInfo_SDK)
}, {
  no: 2,
  name: "version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "protocol",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 4,
  name: "os",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "os_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 6,
  name: "device_model",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 7,
  name: "browser",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "browser_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 9,
  name: "address",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "network",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
var ClientInfo_SDK;
(function(a) {
  a[a.UNKNOWN = 0] = "UNKNOWN", a[a.JS = 1] = "JS", a[a.SWIFT = 2] = "SWIFT", a[a.ANDROID = 3] = "ANDROID", a[a.FLUTTER = 4] = "FLUTTER", a[a.GO = 5] = "GO", a[a.UNITY = 6] = "UNITY", a[a.REACT_NATIVE = 7] = "REACT_NATIVE", a[a.RUST = 8] = "RUST", a[a.PYTHON = 9] = "PYTHON", a[a.CPP = 10] = "CPP";
})(ClientInfo_SDK || (ClientInfo_SDK = {}));
proto3.util.setEnumType(ClientInfo_SDK, "livekit.ClientInfo.SDK", [{
  no: 0,
  name: "UNKNOWN"
}, {
  no: 1,
  name: "JS"
}, {
  no: 2,
  name: "SWIFT"
}, {
  no: 3,
  name: "ANDROID"
}, {
  no: 4,
  name: "FLUTTER"
}, {
  no: 5,
  name: "GO"
}, {
  no: 6,
  name: "UNITY"
}, {
  no: 7,
  name: "REACT_NATIVE"
}, {
  no: 8,
  name: "RUST"
}, {
  no: 9,
  name: "PYTHON"
}, {
  no: 10,
  name: "CPP"
}]);
class ClientConfiguration extends Message {
  constructor(u) {
    super(), this.resumeConnection = ClientConfigSetting.UNSET, this.forceRelay = ClientConfigSetting.UNSET, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ClientConfiguration().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ClientConfiguration().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ClientConfiguration().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ClientConfiguration, u, c);
  }
}
ClientConfiguration.runtime = proto3;
ClientConfiguration.typeName = "livekit.ClientConfiguration";
ClientConfiguration.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "video",
  kind: "message",
  T: VideoConfiguration
}, {
  no: 2,
  name: "screen",
  kind: "message",
  T: VideoConfiguration
}, {
  no: 3,
  name: "resume_connection",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}, {
  no: 4,
  name: "disabled_codecs",
  kind: "message",
  T: DisabledCodecs
}, {
  no: 5,
  name: "force_relay",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}]);
class VideoConfiguration extends Message {
  constructor(u) {
    super(), this.hardwareEncoder = ClientConfigSetting.UNSET, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new VideoConfiguration().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new VideoConfiguration().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new VideoConfiguration().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(VideoConfiguration, u, c);
  }
}
VideoConfiguration.runtime = proto3;
VideoConfiguration.typeName = "livekit.VideoConfiguration";
VideoConfiguration.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "hardware_encoder",
  kind: "enum",
  T: proto3.getEnumType(ClientConfigSetting)
}]);
class DisabledCodecs extends Message {
  constructor(u) {
    super(), this.codecs = [], this.publish = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new DisabledCodecs().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new DisabledCodecs().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new DisabledCodecs().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(DisabledCodecs, u, c);
  }
}
DisabledCodecs.runtime = proto3;
DisabledCodecs.typeName = "livekit.DisabledCodecs";
DisabledCodecs.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "codecs",
  kind: "message",
  T: Codec,
  repeated: !0
}, {
  no: 2,
  name: "publish",
  kind: "message",
  T: Codec,
  repeated: !0
}]);
class RTPDrift extends Message {
  constructor(u) {
    super(), this.duration = 0, this.startTimestamp = protoInt64.zero, this.endTimestamp = protoInt64.zero, this.rtpClockTicks = protoInt64.zero, this.driftSamples = protoInt64.zero, this.driftMs = 0, this.clockRate = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new RTPDrift().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new RTPDrift().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new RTPDrift().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(RTPDrift, u, c);
  }
}
RTPDrift.runtime = proto3;
RTPDrift.typeName = "livekit.RTPDrift";
RTPDrift.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "start_time",
  kind: "message",
  T: Timestamp
}, {
  no: 2,
  name: "end_time",
  kind: "message",
  T: Timestamp
}, {
  no: 3,
  name: "duration",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 4,
  name: "start_timestamp",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 5,
  name: "end_timestamp",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 6,
  name: "rtp_clock_ticks",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 7,
  name: "drift_samples",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 8,
  name: "drift_ms",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 9,
  name: "clock_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}]);
class RTPStats extends Message {
  constructor(u) {
    super(), this.duration = 0, this.packets = 0, this.packetRate = 0, this.bytes = protoInt64.zero, this.headerBytes = protoInt64.zero, this.bitrate = 0, this.packetsLost = 0, this.packetLossRate = 0, this.packetLossPercentage = 0, this.packetsDuplicate = 0, this.packetDuplicateRate = 0, this.bytesDuplicate = protoInt64.zero, this.headerBytesDuplicate = protoInt64.zero, this.bitrateDuplicate = 0, this.packetsPadding = 0, this.packetPaddingRate = 0, this.bytesPadding = protoInt64.zero, this.headerBytesPadding = protoInt64.zero, this.bitratePadding = 0, this.packetsOutOfOrder = 0, this.frames = 0, this.frameRate = 0, this.jitterCurrent = 0, this.jitterMax = 0, this.gapHistogram = {}, this.nacks = 0, this.nackAcks = 0, this.nackMisses = 0, this.nackRepeated = 0, this.plis = 0, this.firs = 0, this.rttCurrent = 0, this.rttMax = 0, this.keyFrames = 0, this.layerLockPlis = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new RTPStats().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new RTPStats().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new RTPStats().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(RTPStats, u, c);
  }
}
RTPStats.runtime = proto3;
RTPStats.typeName = "livekit.RTPStats";
RTPStats.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "start_time",
  kind: "message",
  T: Timestamp
}, {
  no: 2,
  name: "end_time",
  kind: "message",
  T: Timestamp
}, {
  no: 3,
  name: "duration",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 4,
  name: "packets",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "packet_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 6,
  name: "bytes",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 39,
  name: "header_bytes",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 7,
  name: "bitrate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 8,
  name: "packets_lost",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 9,
  name: "packet_loss_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 10,
  name: "packet_loss_percentage",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}, {
  no: 11,
  name: "packets_duplicate",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 12,
  name: "packet_duplicate_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 13,
  name: "bytes_duplicate",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 40,
  name: "header_bytes_duplicate",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 14,
  name: "bitrate_duplicate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 15,
  name: "packets_padding",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 16,
  name: "packet_padding_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 17,
  name: "bytes_padding",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 41,
  name: "header_bytes_padding",
  kind: "scalar",
  T: 4
  /* ScalarType.UINT64 */
}, {
  no: 18,
  name: "bitrate_padding",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 19,
  name: "packets_out_of_order",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 20,
  name: "frames",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 21,
  name: "frame_rate",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 22,
  name: "jitter_current",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 23,
  name: "jitter_max",
  kind: "scalar",
  T: 1
  /* ScalarType.DOUBLE */
}, {
  no: 24,
  name: "gap_histogram",
  kind: "map",
  K: 5,
  V: {
    kind: "scalar",
    T: 13
    /* ScalarType.UINT32 */
  }
}, {
  no: 25,
  name: "nacks",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 37,
  name: "nack_acks",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 26,
  name: "nack_misses",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 38,
  name: "nack_repeated",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 27,
  name: "plis",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 28,
  name: "last_pli",
  kind: "message",
  T: Timestamp
}, {
  no: 29,
  name: "firs",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 30,
  name: "last_fir",
  kind: "message",
  T: Timestamp
}, {
  no: 31,
  name: "rtt_current",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 32,
  name: "rtt_max",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 33,
  name: "key_frames",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 34,
  name: "last_key_frame",
  kind: "message",
  T: Timestamp
}, {
  no: 35,
  name: "layer_lock_plis",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 36,
  name: "last_layer_lock_pli",
  kind: "message",
  T: Timestamp
}, {
  no: 44,
  name: "packet_drift",
  kind: "message",
  T: RTPDrift
}, {
  no: 45,
  name: "report_drift",
  kind: "message",
  T: RTPDrift
}]);
class TimedVersion extends Message {
  constructor(u) {
    super(), this.unixMicro = protoInt64.zero, this.ticks = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new TimedVersion().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new TimedVersion().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new TimedVersion().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(TimedVersion, u, c);
  }
}
TimedVersion.runtime = proto3;
TimedVersion.typeName = "livekit.TimedVersion";
TimedVersion.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "unix_micro",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "ticks",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}]);
const maxRetryDelay = 7e3, DEFAULT_RETRY_DELAYS_IN_MS = [0, 300, 2 * 2 * 300, 3 * 3 * 300, 4 * 4 * 300, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay, maxRetryDelay];
class DefaultReconnectPolicy {
  constructor(u) {
    this._retryDelays = u !== void 0 ? [...u] : DEFAULT_RETRY_DELAYS_IN_MS;
  }
  nextRetryDelayInMs(u) {
    if (u.retryCount >= this._retryDelays.length)
      return null;
    const c = this._retryDelays[u.retryCount];
    return u.retryCount <= 1 ? c : c + Math.random() * 1e3;
  }
}
function __awaiter(a, u, c, l) {
  function v(S) {
    return S instanceof c ? S : new c(function(g) {
      g(S);
    });
  }
  return new (c || (c = Promise))(function(S, g) {
    function E(L) {
      try {
        k(l.next(L));
      } catch (M) {
        g(M);
      }
    }
    function _(L) {
      try {
        k(l.throw(L));
      } catch (M) {
        g(M);
      }
    }
    function k(L) {
      L.done ? S(L.value) : v(L.value).then(E, _);
    }
    k((l = l.apply(a, u || [])).next());
  });
}
function __values(a) {
  var u = typeof Symbol == "function" && Symbol.iterator, c = u && a[u], l = 0;
  if (c)
    return c.call(a);
  if (a && typeof a.length == "number")
    return {
      next: function() {
        return a && l >= a.length && (a = void 0), { value: a && a[l++], done: !a };
      }
    };
  throw new TypeError(u ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __asyncValues(a) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var u = a[Symbol.asyncIterator], c;
  return u ? u.call(a) : (a = typeof __values == "function" ? __values(a) : a[Symbol.iterator](), c = {}, l("next"), l("throw"), l("return"), c[Symbol.asyncIterator] = function() {
    return this;
  }, c);
  function l(S) {
    c[S] = a[S] && function(g) {
      return new Promise(function(E, _) {
        g = a[S](g), v(E, _, g.done, g.value);
      });
    };
  }
  function v(S, g, E, _) {
    Promise.resolve(_).then(function(k) {
      S({ value: k, done: E });
    }, g);
  }
}
typeof SuppressedError == "function" && SuppressedError;
var events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function a(u, c, l) {
  return Function.prototype.apply.call(u, c, l);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(u) {
  return Object.getOwnPropertyNames(u).concat(Object.getOwnPropertySymbols(u));
} : ReflectOwnKeys = function(u) {
  return Object.getOwnPropertyNames(u);
};
function ProcessEmitWarning(a) {
  console && console.warn && console.warn(a);
}
var NumberIsNaN = Number.isNaN || function a(u) {
  return u !== u;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(a) {
  if (typeof a != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof a);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(a) {
    if (typeof a != "number" || a < 0 || NumberIsNaN(a))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + a + ".");
    defaultMaxListeners = a;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function a(u) {
  if (typeof u != "number" || u < 0 || NumberIsNaN(u))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + u + ".");
  return this._maxListeners = u, this;
};
function _getMaxListeners(a) {
  return a._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : a._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function a() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function a(u) {
  for (var c = [], l = 1; l < arguments.length; l++)
    c.push(arguments[l]);
  var v = u === "error", S = this._events;
  if (S !== void 0)
    v = v && S.error === void 0;
  else if (!v)
    return !1;
  if (v) {
    var g;
    if (c.length > 0 && (g = c[0]), g instanceof Error)
      throw g;
    var E = new Error("Unhandled error." + (g ? " (" + g.message + ")" : ""));
    throw E.context = g, E;
  }
  var _ = S[u];
  if (_ === void 0)
    return !1;
  if (typeof _ == "function")
    ReflectApply(_, this, c);
  else
    for (var k = _.length, L = arrayClone(_, k), l = 0; l < k; ++l)
      ReflectApply(L[l], this, c);
  return !0;
};
function _addListener(a, u, c, l) {
  var v, S, g;
  if (checkListener(c), S = a._events, S === void 0 ? (S = a._events = /* @__PURE__ */ Object.create(null), a._eventsCount = 0) : (S.newListener !== void 0 && (a.emit("newListener", u, c.listener ? c.listener : c), S = a._events), g = S[u]), g === void 0)
    g = S[u] = c, ++a._eventsCount;
  else if (typeof g == "function" ? g = S[u] = l ? [c, g] : [g, c] : l ? g.unshift(c) : g.push(c), v = _getMaxListeners(a), v > 0 && g.length > v && !g.warned) {
    g.warned = !0;
    var E = new Error("Possible EventEmitter memory leak detected. " + g.length + " " + String(u) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    E.name = "MaxListenersExceededWarning", E.emitter = a, E.type = u, E.count = g.length, ProcessEmitWarning(E);
  }
  return a;
}
EventEmitter.prototype.addListener = function a(u, c) {
  return _addListener(this, u, c, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function a(u, c) {
  return _addListener(this, u, c, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(a, u, c) {
  var l = {
    fired: !1,
    wrapFn: void 0,
    target: a,
    type: u,
    listener: c
  }, v = onceWrapper.bind(l);
  return v.listener = c, l.wrapFn = v, v;
}
EventEmitter.prototype.once = function a(u, c) {
  return checkListener(c), this.on(u, _onceWrap(this, u, c)), this;
};
EventEmitter.prototype.prependOnceListener = function a(u, c) {
  return checkListener(c), this.prependListener(u, _onceWrap(this, u, c)), this;
};
EventEmitter.prototype.removeListener = function a(u, c) {
  var l, v, S, g, E;
  if (checkListener(c), v = this._events, v === void 0)
    return this;
  if (l = v[u], l === void 0)
    return this;
  if (l === c || l.listener === c)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete v[u], v.removeListener && this.emit("removeListener", u, l.listener || c));
  else if (typeof l != "function") {
    for (S = -1, g = l.length - 1; g >= 0; g--)
      if (l[g] === c || l[g].listener === c) {
        E = l[g].listener, S = g;
        break;
      }
    if (S < 0)
      return this;
    S === 0 ? l.shift() : spliceOne(l, S), l.length === 1 && (v[u] = l[0]), v.removeListener !== void 0 && this.emit("removeListener", u, E || c);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function a(u) {
  var c, l, v;
  if (l = this._events, l === void 0)
    return this;
  if (l.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : l[u] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete l[u]), this;
  if (arguments.length === 0) {
    var S = Object.keys(l), g;
    for (v = 0; v < S.length; ++v)
      g = S[v], g !== "removeListener" && this.removeAllListeners(g);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (c = l[u], typeof c == "function")
    this.removeListener(u, c);
  else if (c !== void 0)
    for (v = c.length - 1; v >= 0; v--)
      this.removeListener(u, c[v]);
  return this;
};
function _listeners(a, u, c) {
  var l = a._events;
  if (l === void 0)
    return [];
  var v = l[u];
  return v === void 0 ? [] : typeof v == "function" ? c ? [v.listener || v] : [v] : c ? unwrapListeners(v) : arrayClone(v, v.length);
}
EventEmitter.prototype.listeners = function a(u) {
  return _listeners(this, u, !0);
};
EventEmitter.prototype.rawListeners = function a(u) {
  return _listeners(this, u, !1);
};
EventEmitter.listenerCount = function(a, u) {
  return typeof a.listenerCount == "function" ? a.listenerCount(u) : listenerCount.call(a, u);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(a) {
  var u = this._events;
  if (u !== void 0) {
    var c = u[a];
    if (typeof c == "function")
      return 1;
    if (c !== void 0)
      return c.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function a() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(a, u) {
  for (var c = new Array(u), l = 0; l < u; ++l)
    c[l] = a[l];
  return c;
}
function spliceOne(a, u) {
  for (; u + 1 < a.length; u++)
    a[u] = a[u + 1];
  a.pop();
}
function unwrapListeners(a) {
  for (var u = new Array(a.length), c = 0; c < u.length; ++c)
    u[c] = a[c].listener || a[c];
  return u;
}
function once(a, u) {
  return new Promise(function(c, l) {
    function v(g) {
      a.removeListener(u, S), l(g);
    }
    function S() {
      typeof a.removeListener == "function" && a.removeListener("error", v), c([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(a, u, S, {
      once: !0
    }), u !== "error" && addErrorHandlerIfEventEmitter(a, v, {
      once: !0
    });
  });
}
function addErrorHandlerIfEventEmitter(a, u, c) {
  typeof a.on == "function" && eventTargetAgnosticAddListener(a, "error", u, c);
}
function eventTargetAgnosticAddListener(a, u, c, l) {
  if (typeof a.on == "function")
    l.once ? a.once(u, c) : a.on(u, c);
  else if (typeof a.addEventListener == "function")
    a.addEventListener(u, function v(S) {
      l.once && a.removeEventListener(u, v), c(S);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof a);
}
var eventsExports = events.exports;
let logDisabled_ = !0, deprecationWarnings_ = !0;
function extractVersion(a, u, c) {
  const l = a.match(u);
  return l && l.length >= c && parseInt(l[c], 10);
}
function wrapPeerConnectionEvent(a, u, c) {
  if (!a.RTCPeerConnection)
    return;
  const l = a.RTCPeerConnection.prototype, v = l.addEventListener;
  l.addEventListener = function(g, E) {
    if (g !== u)
      return v.apply(this, arguments);
    const _ = (k) => {
      const L = c(k);
      L && (E.handleEvent ? E.handleEvent(L) : E(L));
    };
    return this._eventMap = this._eventMap || {}, this._eventMap[u] || (this._eventMap[u] = /* @__PURE__ */ new Map()), this._eventMap[u].set(E, _), v.apply(this, [g, _]);
  };
  const S = l.removeEventListener;
  l.removeEventListener = function(g, E) {
    if (g !== u || !this._eventMap || !this._eventMap[u])
      return S.apply(this, arguments);
    if (!this._eventMap[u].has(E))
      return S.apply(this, arguments);
    const _ = this._eventMap[u].get(E);
    return this._eventMap[u].delete(E), this._eventMap[u].size === 0 && delete this._eventMap[u], Object.keys(this._eventMap).length === 0 && delete this._eventMap, S.apply(this, [g, _]);
  }, Object.defineProperty(l, "on" + u, {
    get() {
      return this["_on" + u];
    },
    set(g) {
      this["_on" + u] && (this.removeEventListener(u, this["_on" + u]), delete this["_on" + u]), g && this.addEventListener(u, this["_on" + u] = g);
    },
    enumerable: !0,
    configurable: !0
  });
}
function disableLog(a) {
  return typeof a != "boolean" ? new Error("Argument type: " + typeof a + ". Please use a boolean.") : (logDisabled_ = a, a ? "adapter.js logging disabled" : "adapter.js logging enabled");
}
function disableWarnings(a) {
  return typeof a != "boolean" ? new Error("Argument type: " + typeof a + ". Please use a boolean.") : (deprecationWarnings_ = !a, "adapter.js deprecation warnings " + (a ? "disabled" : "enabled"));
}
function log() {
  if (typeof window == "object") {
    if (logDisabled_)
      return;
    typeof console < "u" && typeof console.log == "function" && console.log.apply(console, arguments);
  }
}
function deprecated(a, u) {
  deprecationWarnings_ && console.warn(a + " is deprecated, please use " + u + " instead.");
}
function detectBrowser(a) {
  const u = {
    browser: null,
    version: null
  };
  if (typeof a > "u" || !a.navigator || !a.navigator.userAgent)
    return u.browser = "Not a browser.", u;
  const {
    navigator: c
  } = a;
  if (c.mozGetUserMedia)
    u.browser = "firefox", u.version = extractVersion(c.userAgent, /Firefox\/(\d+)\./, 1);
  else if (c.webkitGetUserMedia || a.isSecureContext === !1 && a.webkitRTCPeerConnection)
    u.browser = "chrome", u.version = extractVersion(c.userAgent, /Chrom(e|ium)\/(\d+)\./, 2);
  else if (a.RTCPeerConnection && c.userAgent.match(/AppleWebKit\/(\d+)\./))
    u.browser = "safari", u.version = extractVersion(c.userAgent, /AppleWebKit\/(\d+)\./, 1), u.supportsUnifiedPlan = a.RTCRtpTransceiver && "currentDirection" in a.RTCRtpTransceiver.prototype;
  else
    return u.browser = "Not a supported browser.", u;
  return u;
}
function isObject(a) {
  return Object.prototype.toString.call(a) === "[object Object]";
}
function compactObject(a) {
  return isObject(a) ? Object.keys(a).reduce(function(u, c) {
    const l = isObject(a[c]), v = l ? compactObject(a[c]) : a[c], S = l && !Object.keys(v).length;
    return v === void 0 || S ? u : Object.assign(u, {
      [c]: v
    });
  }, {}) : a;
}
function walkStats(a, u, c) {
  !u || c.has(u.id) || (c.set(u.id, u), Object.keys(u).forEach((l) => {
    l.endsWith("Id") ? walkStats(a, a.get(u[l]), c) : l.endsWith("Ids") && u[l].forEach((v) => {
      walkStats(a, a.get(v), c);
    });
  }));
}
function filterStats(a, u, c) {
  const l = c ? "outbound-rtp" : "inbound-rtp", v = /* @__PURE__ */ new Map();
  if (u === null)
    return v;
  const S = [];
  return a.forEach((g) => {
    g.type === "track" && g.trackIdentifier === u.id && S.push(g);
  }), S.forEach((g) => {
    a.forEach((E) => {
      E.type === l && E.trackId === g.id && walkStats(a, E, v);
    });
  }), v;
}
const logging = log;
function shimGetUserMedia$2(a, u) {
  const c = a && a.navigator;
  if (!c.mediaDevices)
    return;
  const l = function(E) {
    if (typeof E != "object" || E.mandatory || E.optional)
      return E;
    const _ = {};
    return Object.keys(E).forEach((k) => {
      if (k === "require" || k === "advanced" || k === "mediaSource")
        return;
      const L = typeof E[k] == "object" ? E[k] : {
        ideal: E[k]
      };
      L.exact !== void 0 && typeof L.exact == "number" && (L.min = L.max = L.exact);
      const M = function($, J) {
        return $ ? $ + J.charAt(0).toUpperCase() + J.slice(1) : J === "deviceId" ? "sourceId" : J;
      };
      if (L.ideal !== void 0) {
        _.optional = _.optional || [];
        let $ = {};
        typeof L.ideal == "number" ? ($[M("min", k)] = L.ideal, _.optional.push($), $ = {}, $[M("max", k)] = L.ideal, _.optional.push($)) : ($[M("", k)] = L.ideal, _.optional.push($));
      }
      L.exact !== void 0 && typeof L.exact != "number" ? (_.mandatory = _.mandatory || {}, _.mandatory[M("", k)] = L.exact) : ["min", "max"].forEach(($) => {
        L[$] !== void 0 && (_.mandatory = _.mandatory || {}, _.mandatory[M($, k)] = L[$]);
      });
    }), E.advanced && (_.optional = (_.optional || []).concat(E.advanced)), _;
  }, v = function(E, _) {
    if (u.version >= 61)
      return _(E);
    if (E = JSON.parse(JSON.stringify(E)), E && typeof E.audio == "object") {
      const k = function(L, M, $) {
        M in L && !($ in L) && (L[$] = L[M], delete L[M]);
      };
      E = JSON.parse(JSON.stringify(E)), k(E.audio, "autoGainControl", "googAutoGainControl"), k(E.audio, "noiseSuppression", "googNoiseSuppression"), E.audio = l(E.audio);
    }
    if (E && typeof E.video == "object") {
      let k = E.video.facingMode;
      k = k && (typeof k == "object" ? k : {
        ideal: k
      });
      const L = u.version < 66;
      if (k && (k.exact === "user" || k.exact === "environment" || k.ideal === "user" || k.ideal === "environment") && !(c.mediaDevices.getSupportedConstraints && c.mediaDevices.getSupportedConstraints().facingMode && !L)) {
        delete E.video.facingMode;
        let M;
        if (k.exact === "environment" || k.ideal === "environment" ? M = ["back", "rear"] : (k.exact === "user" || k.ideal === "user") && (M = ["front"]), M)
          return c.mediaDevices.enumerateDevices().then(($) => {
            $ = $.filter((V) => V.kind === "videoinput");
            let J = $.find((V) => M.some((q) => V.label.toLowerCase().includes(q)));
            return !J && $.length && M.includes("back") && (J = $[$.length - 1]), J && (E.video.deviceId = k.exact ? {
              exact: J.deviceId
            } : {
              ideal: J.deviceId
            }), E.video = l(E.video), logging("chrome: " + JSON.stringify(E)), _(E);
          });
      }
      E.video = l(E.video);
    }
    return logging("chrome: " + JSON.stringify(E)), _(E);
  }, S = function(E) {
    return u.version >= 64 ? E : {
      name: {
        PermissionDeniedError: "NotAllowedError",
        PermissionDismissedError: "NotAllowedError",
        InvalidStateError: "NotAllowedError",
        DevicesNotFoundError: "NotFoundError",
        ConstraintNotSatisfiedError: "OverconstrainedError",
        TrackStartError: "NotReadableError",
        MediaDeviceFailedDueToShutdown: "NotAllowedError",
        MediaDeviceKillSwitchOn: "NotAllowedError",
        TabCaptureError: "AbortError",
        ScreenCaptureError: "AbortError",
        DeviceCaptureError: "AbortError"
      }[E.name] || E.name,
      message: E.message,
      constraint: E.constraint || E.constraintName,
      toString() {
        return this.name + (this.message && ": ") + this.message;
      }
    };
  }, g = function(E, _, k) {
    v(E, (L) => {
      c.webkitGetUserMedia(L, _, (M) => {
        k && k(S(M));
      });
    });
  };
  if (c.getUserMedia = g.bind(c), c.mediaDevices.getUserMedia) {
    const E = c.mediaDevices.getUserMedia.bind(c.mediaDevices);
    c.mediaDevices.getUserMedia = function(_) {
      return v(_, (k) => E(k).then((L) => {
        if (k.audio && !L.getAudioTracks().length || k.video && !L.getVideoTracks().length)
          throw L.getTracks().forEach((M) => {
            M.stop();
          }), new DOMException("", "NotFoundError");
        return L;
      }, (L) => Promise.reject(S(L))));
    };
  }
}
function shimGetDisplayMedia$1(a, u) {
  if (!(a.navigator.mediaDevices && "getDisplayMedia" in a.navigator.mediaDevices) && a.navigator.mediaDevices) {
    if (typeof u != "function") {
      console.error("shimGetDisplayMedia: getSourceId argument is not a function");
      return;
    }
    a.navigator.mediaDevices.getDisplayMedia = function(l) {
      return u(l).then((v) => {
        const S = l.video && l.video.width, g = l.video && l.video.height, E = l.video && l.video.frameRate;
        return l.video = {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: v,
            maxFrameRate: E || 3
          }
        }, S && (l.video.mandatory.maxWidth = S), g && (l.video.mandatory.maxHeight = g), a.navigator.mediaDevices.getUserMedia(l);
      });
    };
  }
}
function shimMediaStream(a) {
  a.MediaStream = a.MediaStream || a.webkitMediaStream;
}
function shimOnTrack$1(a) {
  if (typeof a == "object" && a.RTCPeerConnection && !("ontrack" in a.RTCPeerConnection.prototype)) {
    Object.defineProperty(a.RTCPeerConnection.prototype, "ontrack", {
      get() {
        return this._ontrack;
      },
      set(c) {
        this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = c);
      },
      enumerable: !0,
      configurable: !0
    });
    const u = a.RTCPeerConnection.prototype.setRemoteDescription;
    a.RTCPeerConnection.prototype.setRemoteDescription = function() {
      return this._ontrackpoly || (this._ontrackpoly = (l) => {
        l.stream.addEventListener("addtrack", (v) => {
          let S;
          a.RTCPeerConnection.prototype.getReceivers ? S = this.getReceivers().find((E) => E.track && E.track.id === v.track.id) : S = {
            track: v.track
          };
          const g = new Event("track");
          g.track = v.track, g.receiver = S, g.transceiver = {
            receiver: S
          }, g.streams = [l.stream], this.dispatchEvent(g);
        }), l.stream.getTracks().forEach((v) => {
          let S;
          a.RTCPeerConnection.prototype.getReceivers ? S = this.getReceivers().find((E) => E.track && E.track.id === v.id) : S = {
            track: v
          };
          const g = new Event("track");
          g.track = v, g.receiver = S, g.transceiver = {
            receiver: S
          }, g.streams = [l.stream], this.dispatchEvent(g);
        });
      }, this.addEventListener("addstream", this._ontrackpoly)), u.apply(this, arguments);
    };
  } else
    wrapPeerConnectionEvent(a, "track", (u) => (u.transceiver || Object.defineProperty(u, "transceiver", {
      value: {
        receiver: u.receiver
      }
    }), u));
}
function shimGetSendersWithDtmf(a) {
  if (typeof a == "object" && a.RTCPeerConnection && !("getSenders" in a.RTCPeerConnection.prototype) && "createDTMFSender" in a.RTCPeerConnection.prototype) {
    const u = function(v, S) {
      return {
        track: S,
        get dtmf() {
          return this._dtmf === void 0 && (S.kind === "audio" ? this._dtmf = v.createDTMFSender(S) : this._dtmf = null), this._dtmf;
        },
        _pc: v
      };
    };
    if (!a.RTCPeerConnection.prototype.getSenders) {
      a.RTCPeerConnection.prototype.getSenders = function() {
        return this._senders = this._senders || [], this._senders.slice();
      };
      const v = a.RTCPeerConnection.prototype.addTrack;
      a.RTCPeerConnection.prototype.addTrack = function(E, _) {
        let k = v.apply(this, arguments);
        return k || (k = u(this, E), this._senders.push(k)), k;
      };
      const S = a.RTCPeerConnection.prototype.removeTrack;
      a.RTCPeerConnection.prototype.removeTrack = function(E) {
        S.apply(this, arguments);
        const _ = this._senders.indexOf(E);
        _ !== -1 && this._senders.splice(_, 1);
      };
    }
    const c = a.RTCPeerConnection.prototype.addStream;
    a.RTCPeerConnection.prototype.addStream = function(S) {
      this._senders = this._senders || [], c.apply(this, [S]), S.getTracks().forEach((g) => {
        this._senders.push(u(this, g));
      });
    };
    const l = a.RTCPeerConnection.prototype.removeStream;
    a.RTCPeerConnection.prototype.removeStream = function(S) {
      this._senders = this._senders || [], l.apply(this, [S]), S.getTracks().forEach((g) => {
        const E = this._senders.find((_) => _.track === g);
        E && this._senders.splice(this._senders.indexOf(E), 1);
      });
    };
  } else if (typeof a == "object" && a.RTCPeerConnection && "getSenders" in a.RTCPeerConnection.prototype && "createDTMFSender" in a.RTCPeerConnection.prototype && a.RTCRtpSender && !("dtmf" in a.RTCRtpSender.prototype)) {
    const u = a.RTCPeerConnection.prototype.getSenders;
    a.RTCPeerConnection.prototype.getSenders = function() {
      const l = u.apply(this, []);
      return l.forEach((v) => v._pc = this), l;
    }, Object.defineProperty(a.RTCRtpSender.prototype, "dtmf", {
      get() {
        return this._dtmf === void 0 && (this.track.kind === "audio" ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf;
      }
    });
  }
}
function shimGetStats(a) {
  if (!a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    const [l, v, S] = arguments;
    if (arguments.length > 0 && typeof l == "function")
      return u.apply(this, arguments);
    if (u.length === 0 && (arguments.length === 0 || typeof l != "function"))
      return u.apply(this, []);
    const g = function(_) {
      const k = {};
      return _.result().forEach((M) => {
        const $ = {
          id: M.id,
          timestamp: M.timestamp,
          type: {
            localcandidate: "local-candidate",
            remotecandidate: "remote-candidate"
          }[M.type] || M.type
        };
        M.names().forEach((J) => {
          $[J] = M.stat(J);
        }), k[$.id] = $;
      }), k;
    }, E = function(_) {
      return new Map(Object.keys(_).map((k) => [k, _[k]]));
    };
    if (arguments.length >= 2) {
      const _ = function(k) {
        v(E(g(k)));
      };
      return u.apply(this, [_, l]);
    }
    return new Promise((_, k) => {
      u.apply(this, [function(L) {
        _(E(g(L)));
      }, k]);
    }).then(v, S);
  };
}
function shimSenderReceiverGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender && a.RTCRtpReceiver))
    return;
  if (!("getStats" in a.RTCRtpSender.prototype)) {
    const c = a.RTCPeerConnection.prototype.getSenders;
    c && (a.RTCPeerConnection.prototype.getSenders = function() {
      const S = c.apply(this, []);
      return S.forEach((g) => g._pc = this), S;
    });
    const l = a.RTCPeerConnection.prototype.addTrack;
    l && (a.RTCPeerConnection.prototype.addTrack = function() {
      const S = l.apply(this, arguments);
      return S._pc = this, S;
    }), a.RTCRtpSender.prototype.getStats = function() {
      const S = this;
      return this._pc.getStats().then((g) => (
        /* Note: this will include stats of all senders that
         *   send a track with the same id as sender.track as
         *   it is not possible to identify the RTCRtpSender.
         */
        filterStats(g, S.track, !0)
      ));
    };
  }
  if (!("getStats" in a.RTCRtpReceiver.prototype)) {
    const c = a.RTCPeerConnection.prototype.getReceivers;
    c && (a.RTCPeerConnection.prototype.getReceivers = function() {
      const v = c.apply(this, []);
      return v.forEach((S) => S._pc = this), v;
    }), wrapPeerConnectionEvent(a, "track", (l) => (l.receiver._pc = l.srcElement, l)), a.RTCRtpReceiver.prototype.getStats = function() {
      const v = this;
      return this._pc.getStats().then((S) => filterStats(S, v.track, !1));
    };
  }
  if (!("getStats" in a.RTCRtpSender.prototype && "getStats" in a.RTCRtpReceiver.prototype))
    return;
  const u = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    if (arguments.length > 0 && arguments[0] instanceof a.MediaStreamTrack) {
      const l = arguments[0];
      let v, S, g;
      return this.getSenders().forEach((E) => {
        E.track === l && (v ? g = !0 : v = E);
      }), this.getReceivers().forEach((E) => (E.track === l && (S ? g = !0 : S = E), E.track === l)), g || v && S ? Promise.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : v ? v.getStats() : S ? S.getStats() : Promise.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"));
    }
    return u.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrackWithNative(a) {
  a.RTCPeerConnection.prototype.getLocalStreams = function() {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map((g) => this._shimmedLocalStreams[g][0]);
  };
  const u = a.RTCPeerConnection.prototype.addTrack;
  a.RTCPeerConnection.prototype.addTrack = function(g, E) {
    if (!E)
      return u.apply(this, arguments);
    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
    const _ = u.apply(this, arguments);
    return this._shimmedLocalStreams[E.id] ? this._shimmedLocalStreams[E.id].indexOf(_) === -1 && this._shimmedLocalStreams[E.id].push(_) : this._shimmedLocalStreams[E.id] = [E, _], _;
  };
  const c = a.RTCPeerConnection.prototype.addStream;
  a.RTCPeerConnection.prototype.addStream = function(g) {
    this._shimmedLocalStreams = this._shimmedLocalStreams || {}, g.getTracks().forEach((k) => {
      if (this.getSenders().find((M) => M.track === k))
        throw new DOMException("Track already exists.", "InvalidAccessError");
    });
    const E = this.getSenders();
    c.apply(this, arguments);
    const _ = this.getSenders().filter((k) => E.indexOf(k) === -1);
    this._shimmedLocalStreams[g.id] = [g].concat(_);
  };
  const l = a.RTCPeerConnection.prototype.removeStream;
  a.RTCPeerConnection.prototype.removeStream = function(g) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[g.id], l.apply(this, arguments);
  };
  const v = a.RTCPeerConnection.prototype.removeTrack;
  a.RTCPeerConnection.prototype.removeTrack = function(g) {
    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, g && Object.keys(this._shimmedLocalStreams).forEach((E) => {
      const _ = this._shimmedLocalStreams[E].indexOf(g);
      _ !== -1 && this._shimmedLocalStreams[E].splice(_, 1), this._shimmedLocalStreams[E].length === 1 && delete this._shimmedLocalStreams[E];
    }), v.apply(this, arguments);
  };
}
function shimAddTrackRemoveTrack(a, u) {
  if (!a.RTCPeerConnection)
    return;
  if (a.RTCPeerConnection.prototype.addTrack && u.version >= 65)
    return shimAddTrackRemoveTrackWithNative(a);
  const c = a.RTCPeerConnection.prototype.getLocalStreams;
  a.RTCPeerConnection.prototype.getLocalStreams = function() {
    const L = c.apply(this);
    return this._reverseStreams = this._reverseStreams || {}, L.map((M) => this._reverseStreams[M.id]);
  };
  const l = a.RTCPeerConnection.prototype.addStream;
  a.RTCPeerConnection.prototype.addStream = function(L) {
    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, L.getTracks().forEach((M) => {
      if (this.getSenders().find((J) => J.track === M))
        throw new DOMException("Track already exists.", "InvalidAccessError");
    }), !this._reverseStreams[L.id]) {
      const M = new a.MediaStream(L.getTracks());
      this._streams[L.id] = M, this._reverseStreams[M.id] = L, L = M;
    }
    l.apply(this, [L]);
  };
  const v = a.RTCPeerConnection.prototype.removeStream;
  a.RTCPeerConnection.prototype.removeStream = function(L) {
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, v.apply(this, [this._streams[L.id] || L]), delete this._reverseStreams[this._streams[L.id] ? this._streams[L.id].id : L.id], delete this._streams[L.id];
  }, a.RTCPeerConnection.prototype.addTrack = function(L, M) {
    if (this.signalingState === "closed")
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    const $ = [].slice.call(arguments, 1);
    if ($.length !== 1 || !$[0].getTracks().find((q) => q === L))
      throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
    if (this.getSenders().find((q) => q.track === L))
      throw new DOMException("Track already exists.", "InvalidAccessError");
    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
    const V = this._streams[M.id];
    if (V)
      V.addTrack(L), Promise.resolve().then(() => {
        this.dispatchEvent(new Event("negotiationneeded"));
      });
    else {
      const q = new a.MediaStream([L]);
      this._streams[M.id] = q, this._reverseStreams[q.id] = M, this.addStream(q);
    }
    return this.getSenders().find((q) => q.track === L);
  };
  function S(k, L) {
    let M = L.sdp;
    return Object.keys(k._reverseStreams || []).forEach(($) => {
      const J = k._reverseStreams[$], V = k._streams[J.id];
      M = M.replace(new RegExp(V.id, "g"), J.id);
    }), new RTCSessionDescription({
      type: L.type,
      sdp: M
    });
  }
  function g(k, L) {
    let M = L.sdp;
    return Object.keys(k._reverseStreams || []).forEach(($) => {
      const J = k._reverseStreams[$], V = k._streams[J.id];
      M = M.replace(new RegExp(J.id, "g"), V.id);
    }), new RTCSessionDescription({
      type: L.type,
      sdp: M
    });
  }
  ["createOffer", "createAnswer"].forEach(function(k) {
    const L = a.RTCPeerConnection.prototype[k], M = {
      [k]() {
        const $ = arguments;
        return arguments.length && typeof arguments[0] == "function" ? L.apply(this, [(V) => {
          const q = S(this, V);
          $[0].apply(null, [q]);
        }, (V) => {
          $[1] && $[1].apply(null, V);
        }, arguments[2]]) : L.apply(this, arguments).then((V) => S(this, V));
      }
    };
    a.RTCPeerConnection.prototype[k] = M[k];
  });
  const E = a.RTCPeerConnection.prototype.setLocalDescription;
  a.RTCPeerConnection.prototype.setLocalDescription = function() {
    return !arguments.length || !arguments[0].type ? E.apply(this, arguments) : (arguments[0] = g(this, arguments[0]), E.apply(this, arguments));
  };
  const _ = Object.getOwnPropertyDescriptor(a.RTCPeerConnection.prototype, "localDescription");
  Object.defineProperty(a.RTCPeerConnection.prototype, "localDescription", {
    get() {
      const k = _.get.apply(this);
      return k.type === "" ? k : S(this, k);
    }
  }), a.RTCPeerConnection.prototype.removeTrack = function(L) {
    if (this.signalingState === "closed")
      throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
    if (!L._pc)
      throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
    if (!(L._pc === this))
      throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
    this._streams = this._streams || {};
    let $;
    Object.keys(this._streams).forEach((J) => {
      this._streams[J].getTracks().find((q) => L.track === q) && ($ = this._streams[J]);
    }), $ && ($.getTracks().length === 1 ? this.removeStream(this._reverseStreams[$.id]) : $.removeTrack(L.track), this.dispatchEvent(new Event("negotiationneeded")));
  };
}
function shimPeerConnection$1(a, u) {
  !a.RTCPeerConnection && a.webkitRTCPeerConnection && (a.RTCPeerConnection = a.webkitRTCPeerConnection), a.RTCPeerConnection && u.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(c) {
    const l = a.RTCPeerConnection.prototype[c], v = {
      [c]() {
        return arguments[0] = new (c === "addIceCandidate" ? a.RTCIceCandidate : a.RTCSessionDescription)(arguments[0]), l.apply(this, arguments);
      }
    };
    a.RTCPeerConnection.prototype[c] = v[c];
  });
}
function fixNegotiationNeeded(a, u) {
  wrapPeerConnectionEvent(a, "negotiationneeded", (c) => {
    const l = c.target;
    if (!((u.version < 72 || l.getConfiguration && l.getConfiguration().sdpSemantics === "plan-b") && l.signalingState !== "stable"))
      return c;
  });
}
var chromeShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fixNegotiationNeeded,
  shimAddTrackRemoveTrack,
  shimAddTrackRemoveTrackWithNative,
  shimGetDisplayMedia: shimGetDisplayMedia$1,
  shimGetSendersWithDtmf,
  shimGetStats,
  shimGetUserMedia: shimGetUserMedia$2,
  shimMediaStream,
  shimOnTrack: shimOnTrack$1,
  shimPeerConnection: shimPeerConnection$1,
  shimSenderReceiverGetStats
});
function shimGetUserMedia$1(a, u) {
  const c = a && a.navigator, l = a && a.MediaStreamTrack;
  if (c.getUserMedia = function(v, S, g) {
    deprecated("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), c.mediaDevices.getUserMedia(v).then(S, g);
  }, !(u.version > 55 && "autoGainControl" in c.mediaDevices.getSupportedConstraints())) {
    const v = function(g, E, _) {
      E in g && !(_ in g) && (g[_] = g[E], delete g[E]);
    }, S = c.mediaDevices.getUserMedia.bind(c.mediaDevices);
    if (c.mediaDevices.getUserMedia = function(g) {
      return typeof g == "object" && typeof g.audio == "object" && (g = JSON.parse(JSON.stringify(g)), v(g.audio, "autoGainControl", "mozAutoGainControl"), v(g.audio, "noiseSuppression", "mozNoiseSuppression")), S(g);
    }, l && l.prototype.getSettings) {
      const g = l.prototype.getSettings;
      l.prototype.getSettings = function() {
        const E = g.apply(this, arguments);
        return v(E, "mozAutoGainControl", "autoGainControl"), v(E, "mozNoiseSuppression", "noiseSuppression"), E;
      };
    }
    if (l && l.prototype.applyConstraints) {
      const g = l.prototype.applyConstraints;
      l.prototype.applyConstraints = function(E) {
        return this.kind === "audio" && typeof E == "object" && (E = JSON.parse(JSON.stringify(E)), v(E, "autoGainControl", "mozAutoGainControl"), v(E, "noiseSuppression", "mozNoiseSuppression")), g.apply(this, [E]);
      };
    }
  }
}
function shimGetDisplayMedia(a, u) {
  a.navigator.mediaDevices && "getDisplayMedia" in a.navigator.mediaDevices || a.navigator.mediaDevices && (a.navigator.mediaDevices.getDisplayMedia = function(l) {
    if (!(l && l.video)) {
      const v = new DOMException("getDisplayMedia without video constraints is undefined");
      return v.name = "NotFoundError", v.code = 8, Promise.reject(v);
    }
    return l.video === !0 ? l.video = {
      mediaSource: u
    } : l.video.mediaSource = u, a.navigator.mediaDevices.getUserMedia(l);
  });
}
function shimOnTrack(a) {
  typeof a == "object" && a.RTCTrackEvent && "receiver" in a.RTCTrackEvent.prototype && !("transceiver" in a.RTCTrackEvent.prototype) && Object.defineProperty(a.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function shimPeerConnection(a, u) {
  if (typeof a != "object" || !(a.RTCPeerConnection || a.mozRTCPeerConnection))
    return;
  !a.RTCPeerConnection && a.mozRTCPeerConnection && (a.RTCPeerConnection = a.mozRTCPeerConnection), u.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function(v) {
    const S = a.RTCPeerConnection.prototype[v], g = {
      [v]() {
        return arguments[0] = new (v === "addIceCandidate" ? a.RTCIceCandidate : a.RTCSessionDescription)(arguments[0]), S.apply(this, arguments);
      }
    };
    a.RTCPeerConnection.prototype[v] = g[v];
  });
  const c = {
    inboundrtp: "inbound-rtp",
    outboundrtp: "outbound-rtp",
    candidatepair: "candidate-pair",
    localcandidate: "local-candidate",
    remotecandidate: "remote-candidate"
  }, l = a.RTCPeerConnection.prototype.getStats;
  a.RTCPeerConnection.prototype.getStats = function() {
    const [S, g, E] = arguments;
    return l.apply(this, [S || null]).then((_) => {
      if (u.version < 53 && !g)
        try {
          _.forEach((k) => {
            k.type = c[k.type] || k.type;
          });
        } catch (k) {
          if (k.name !== "TypeError")
            throw k;
          _.forEach((L, M) => {
            _.set(M, Object.assign({}, L, {
              type: c[L.type] || L.type
            }));
          });
        }
      return _;
    }).then(g, E);
  };
}
function shimSenderGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender) || a.RTCRtpSender && "getStats" in a.RTCRtpSender.prototype)
    return;
  const u = a.RTCPeerConnection.prototype.getSenders;
  u && (a.RTCPeerConnection.prototype.getSenders = function() {
    const v = u.apply(this, []);
    return v.forEach((S) => S._pc = this), v;
  });
  const c = a.RTCPeerConnection.prototype.addTrack;
  c && (a.RTCPeerConnection.prototype.addTrack = function() {
    const v = c.apply(this, arguments);
    return v._pc = this, v;
  }), a.RTCRtpSender.prototype.getStats = function() {
    return this.track ? this._pc.getStats(this.track) : Promise.resolve(/* @__PURE__ */ new Map());
  };
}
function shimReceiverGetStats(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection && a.RTCRtpSender) || a.RTCRtpSender && "getStats" in a.RTCRtpReceiver.prototype)
    return;
  const u = a.RTCPeerConnection.prototype.getReceivers;
  u && (a.RTCPeerConnection.prototype.getReceivers = function() {
    const l = u.apply(this, []);
    return l.forEach((v) => v._pc = this), l;
  }), wrapPeerConnectionEvent(a, "track", (c) => (c.receiver._pc = c.srcElement, c)), a.RTCRtpReceiver.prototype.getStats = function() {
    return this._pc.getStats(this.track);
  };
}
function shimRemoveStream(a) {
  !a.RTCPeerConnection || "removeStream" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.removeStream = function(c) {
    deprecated("removeStream", "removeTrack"), this.getSenders().forEach((l) => {
      l.track && c.getTracks().includes(l.track) && this.removeTrack(l);
    });
  });
}
function shimRTCDataChannel(a) {
  a.DataChannel && !a.RTCDataChannel && (a.RTCDataChannel = a.DataChannel);
}
function shimAddTransceiver(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.addTransceiver;
  u && (a.RTCPeerConnection.prototype.addTransceiver = function() {
    this.setParametersPromises = [];
    let l = arguments[1] && arguments[1].sendEncodings;
    l === void 0 && (l = []), l = [...l];
    const v = l.length > 0;
    v && l.forEach((g) => {
      if ("rid" in g && !/^[a-z0-9]{0,16}$/i.test(g.rid))
        throw new TypeError("Invalid RID value provided.");
      if ("scaleResolutionDownBy" in g && !(parseFloat(g.scaleResolutionDownBy) >= 1))
        throw new RangeError("scale_resolution_down_by must be >= 1.0");
      if ("maxFramerate" in g && !(parseFloat(g.maxFramerate) >= 0))
        throw new RangeError("max_framerate must be >= 0.0");
    });
    const S = u.apply(this, arguments);
    if (v) {
      const {
        sender: g
      } = S, E = g.getParameters();
      (!("encodings" in E) || // Avoid being fooled by patched getParameters() below.
      E.encodings.length === 1 && Object.keys(E.encodings[0]).length === 0) && (E.encodings = l, g.sendEncodings = l, this.setParametersPromises.push(g.setParameters(E).then(() => {
        delete g.sendEncodings;
      }).catch(() => {
        delete g.sendEncodings;
      })));
    }
    return S;
  });
}
function shimGetParameters(a) {
  if (!(typeof a == "object" && a.RTCRtpSender))
    return;
  const u = a.RTCRtpSender.prototype.getParameters;
  u && (a.RTCRtpSender.prototype.getParameters = function() {
    const l = u.apply(this, arguments);
    return "encodings" in l || (l.encodings = [].concat(this.sendEncodings || [{}])), l;
  });
}
function shimCreateOffer(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.createOffer;
  a.RTCPeerConnection.prototype.createOffer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => u.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : u.apply(this, arguments);
  };
}
function shimCreateAnswer(a) {
  if (!(typeof a == "object" && a.RTCPeerConnection))
    return;
  const u = a.RTCPeerConnection.prototype.createAnswer;
  a.RTCPeerConnection.prototype.createAnswer = function() {
    return this.setParametersPromises && this.setParametersPromises.length ? Promise.all(this.setParametersPromises).then(() => u.apply(this, arguments)).finally(() => {
      this.setParametersPromises = [];
    }) : u.apply(this, arguments);
  };
}
var firefoxShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAddTransceiver,
  shimCreateAnswer,
  shimCreateOffer,
  shimGetDisplayMedia,
  shimGetParameters,
  shimGetUserMedia: shimGetUserMedia$1,
  shimOnTrack,
  shimPeerConnection,
  shimRTCDataChannel,
  shimReceiverGetStats,
  shimRemoveStream,
  shimSenderGetStats
});
function shimLocalStreamsAPI(a) {
  if (!(typeof a != "object" || !a.RTCPeerConnection)) {
    if ("getLocalStreams" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this._localStreams || (this._localStreams = []), this._localStreams;
    }), !("addStream" in a.RTCPeerConnection.prototype)) {
      const u = a.RTCPeerConnection.prototype.addTrack;
      a.RTCPeerConnection.prototype.addStream = function(l) {
        this._localStreams || (this._localStreams = []), this._localStreams.includes(l) || this._localStreams.push(l), l.getAudioTracks().forEach((v) => u.call(this, v, l)), l.getVideoTracks().forEach((v) => u.call(this, v, l));
      }, a.RTCPeerConnection.prototype.addTrack = function(l) {
        for (var v = arguments.length, S = new Array(v > 1 ? v - 1 : 0), g = 1; g < v; g++)
          S[g - 1] = arguments[g];
        return S && S.forEach((E) => {
          this._localStreams ? this._localStreams.includes(E) || this._localStreams.push(E) : this._localStreams = [E];
        }), u.apply(this, arguments);
      };
    }
    "removeStream" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.removeStream = function(c) {
      this._localStreams || (this._localStreams = []);
      const l = this._localStreams.indexOf(c);
      if (l === -1)
        return;
      this._localStreams.splice(l, 1);
      const v = c.getTracks();
      this.getSenders().forEach((S) => {
        v.includes(S.track) && this.removeTrack(S);
      });
    });
  }
}
function shimRemoteStreamsAPI(a) {
  if (!(typeof a != "object" || !a.RTCPeerConnection) && ("getRemoteStreams" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getRemoteStreams = function() {
    return this._remoteStreams ? this._remoteStreams : [];
  }), !("onaddstream" in a.RTCPeerConnection.prototype))) {
    Object.defineProperty(a.RTCPeerConnection.prototype, "onaddstream", {
      get() {
        return this._onaddstream;
      },
      set(c) {
        this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = c), this.addEventListener("track", this._onaddstreampoly = (l) => {
          l.streams.forEach((v) => {
            if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(v))
              return;
            this._remoteStreams.push(v);
            const S = new Event("addstream");
            S.stream = v, this.dispatchEvent(S);
          });
        });
      }
    });
    const u = a.RTCPeerConnection.prototype.setRemoteDescription;
    a.RTCPeerConnection.prototype.setRemoteDescription = function() {
      const l = this;
      return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function(v) {
        v.streams.forEach((S) => {
          if (l._remoteStreams || (l._remoteStreams = []), l._remoteStreams.indexOf(S) >= 0)
            return;
          l._remoteStreams.push(S);
          const g = new Event("addstream");
          g.stream = S, l.dispatchEvent(g);
        });
      }), u.apply(l, arguments);
    };
  }
}
function shimCallbacksAPI(a) {
  if (typeof a != "object" || !a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection.prototype, c = u.createOffer, l = u.createAnswer, v = u.setLocalDescription, S = u.setRemoteDescription, g = u.addIceCandidate;
  u.createOffer = function(k, L) {
    const M = arguments.length >= 2 ? arguments[2] : arguments[0], $ = c.apply(this, [M]);
    return L ? ($.then(k, L), Promise.resolve()) : $;
  }, u.createAnswer = function(k, L) {
    const M = arguments.length >= 2 ? arguments[2] : arguments[0], $ = l.apply(this, [M]);
    return L ? ($.then(k, L), Promise.resolve()) : $;
  };
  let E = function(_, k, L) {
    const M = v.apply(this, [_]);
    return L ? (M.then(k, L), Promise.resolve()) : M;
  };
  u.setLocalDescription = E, E = function(_, k, L) {
    const M = S.apply(this, [_]);
    return L ? (M.then(k, L), Promise.resolve()) : M;
  }, u.setRemoteDescription = E, E = function(_, k, L) {
    const M = g.apply(this, [_]);
    return L ? (M.then(k, L), Promise.resolve()) : M;
  }, u.addIceCandidate = E;
}
function shimGetUserMedia(a) {
  const u = a && a.navigator;
  if (u.mediaDevices && u.mediaDevices.getUserMedia) {
    const c = u.mediaDevices, l = c.getUserMedia.bind(c);
    u.mediaDevices.getUserMedia = (v) => l(shimConstraints(v));
  }
  !u.getUserMedia && u.mediaDevices && u.mediaDevices.getUserMedia && (u.getUserMedia = (function(l, v, S) {
    u.mediaDevices.getUserMedia(l).then(v, S);
  }).bind(u));
}
function shimConstraints(a) {
  return a && a.video !== void 0 ? Object.assign({}, a, {
    video: compactObject(a.video)
  }) : a;
}
function shimRTCIceServerUrls(a) {
  if (!a.RTCPeerConnection)
    return;
  const u = a.RTCPeerConnection;
  a.RTCPeerConnection = function(l, v) {
    if (l && l.iceServers) {
      const S = [];
      for (let g = 0; g < l.iceServers.length; g++) {
        let E = l.iceServers[g];
        E.urls === void 0 && E.url ? (deprecated("RTCIceServer.url", "RTCIceServer.urls"), E = JSON.parse(JSON.stringify(E)), E.urls = E.url, delete E.url, S.push(E)) : S.push(l.iceServers[g]);
      }
      l.iceServers = S;
    }
    return new u(l, v);
  }, a.RTCPeerConnection.prototype = u.prototype, "generateCertificate" in u && Object.defineProperty(a.RTCPeerConnection, "generateCertificate", {
    get() {
      return u.generateCertificate;
    }
  });
}
function shimTrackEventTransceiver(a) {
  typeof a == "object" && a.RTCTrackEvent && "receiver" in a.RTCTrackEvent.prototype && !("transceiver" in a.RTCTrackEvent.prototype) && Object.defineProperty(a.RTCTrackEvent.prototype, "transceiver", {
    get() {
      return {
        receiver: this.receiver
      };
    }
  });
}
function shimCreateOfferLegacy(a) {
  const u = a.RTCPeerConnection.prototype.createOffer;
  a.RTCPeerConnection.prototype.createOffer = function(l) {
    if (l) {
      typeof l.offerToReceiveAudio < "u" && (l.offerToReceiveAudio = !!l.offerToReceiveAudio);
      const v = this.getTransceivers().find((g) => g.receiver.track.kind === "audio");
      l.offerToReceiveAudio === !1 && v ? v.direction === "sendrecv" ? v.setDirection ? v.setDirection("sendonly") : v.direction = "sendonly" : v.direction === "recvonly" && (v.setDirection ? v.setDirection("inactive") : v.direction = "inactive") : l.offerToReceiveAudio === !0 && !v && this.addTransceiver("audio", {
        direction: "recvonly"
      }), typeof l.offerToReceiveVideo < "u" && (l.offerToReceiveVideo = !!l.offerToReceiveVideo);
      const S = this.getTransceivers().find((g) => g.receiver.track.kind === "video");
      l.offerToReceiveVideo === !1 && S ? S.direction === "sendrecv" ? S.setDirection ? S.setDirection("sendonly") : S.direction = "sendonly" : S.direction === "recvonly" && (S.setDirection ? S.setDirection("inactive") : S.direction = "inactive") : l.offerToReceiveVideo === !0 && !S && this.addTransceiver("video", {
        direction: "recvonly"
      });
    }
    return u.apply(this, arguments);
  };
}
function shimAudioContext(a) {
  typeof a != "object" || a.AudioContext || (a.AudioContext = a.webkitAudioContext);
}
var safariShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  shimAudioContext,
  shimCallbacksAPI,
  shimConstraints,
  shimCreateOfferLegacy,
  shimGetUserMedia,
  shimLocalStreamsAPI,
  shimRTCIceServerUrls,
  shimRemoteStreamsAPI,
  shimTrackEventTransceiver
}), sdp$1 = { exports: {} };
(function(a) {
  const u = {};
  u.generateIdentifier = function() {
    return Math.random().toString(36).substring(2, 12);
  }, u.localCName = u.generateIdentifier(), u.splitLines = function(c) {
    return c.trim().split(`
`).map((l) => l.trim());
  }, u.splitSections = function(c) {
    return c.split(`
m=`).map((v, S) => (S > 0 ? "m=" + v : v).trim() + `\r
`);
  }, u.getDescription = function(c) {
    const l = u.splitSections(c);
    return l && l[0];
  }, u.getMediaSections = function(c) {
    const l = u.splitSections(c);
    return l.shift(), l;
  }, u.matchPrefix = function(c, l) {
    return u.splitLines(c).filter((v) => v.indexOf(l) === 0);
  }, u.parseCandidate = function(c) {
    let l;
    c.indexOf("a=candidate:") === 0 ? l = c.substring(12).split(" ") : l = c.substring(10).split(" ");
    const v = {
      foundation: l[0],
      component: {
        1: "rtp",
        2: "rtcp"
      }[l[1]] || l[1],
      protocol: l[2].toLowerCase(),
      priority: parseInt(l[3], 10),
      ip: l[4],
      address: l[4],
      // address is an alias for ip.
      port: parseInt(l[5], 10),
      // skip parts[6] == 'typ'
      type: l[7]
    };
    for (let S = 8; S < l.length; S += 2)
      switch (l[S]) {
        case "raddr":
          v.relatedAddress = l[S + 1];
          break;
        case "rport":
          v.relatedPort = parseInt(l[S + 1], 10);
          break;
        case "tcptype":
          v.tcpType = l[S + 1];
          break;
        case "ufrag":
          v.ufrag = l[S + 1], v.usernameFragment = l[S + 1];
          break;
        default:
          v[l[S]] === void 0 && (v[l[S]] = l[S + 1]);
          break;
      }
    return v;
  }, u.writeCandidate = function(c) {
    const l = [];
    l.push(c.foundation);
    const v = c.component;
    v === "rtp" ? l.push(1) : v === "rtcp" ? l.push(2) : l.push(v), l.push(c.protocol.toUpperCase()), l.push(c.priority), l.push(c.address || c.ip), l.push(c.port);
    const S = c.type;
    return l.push("typ"), l.push(S), S !== "host" && c.relatedAddress && c.relatedPort && (l.push("raddr"), l.push(c.relatedAddress), l.push("rport"), l.push(c.relatedPort)), c.tcpType && c.protocol.toLowerCase() === "tcp" && (l.push("tcptype"), l.push(c.tcpType)), (c.usernameFragment || c.ufrag) && (l.push("ufrag"), l.push(c.usernameFragment || c.ufrag)), "candidate:" + l.join(" ");
  }, u.parseIceOptions = function(c) {
    return c.substring(14).split(" ");
  }, u.parseRtpMap = function(c) {
    let l = c.substring(9).split(" ");
    const v = {
      payloadType: parseInt(l.shift(), 10)
      // was: id
    };
    return l = l[0].split("/"), v.name = l[0], v.clockRate = parseInt(l[1], 10), v.channels = l.length === 3 ? parseInt(l[2], 10) : 1, v.numChannels = v.channels, v;
  }, u.writeRtpMap = function(c) {
    let l = c.payloadType;
    c.preferredPayloadType !== void 0 && (l = c.preferredPayloadType);
    const v = c.channels || c.numChannels || 1;
    return "a=rtpmap:" + l + " " + c.name + "/" + c.clockRate + (v !== 1 ? "/" + v : "") + `\r
`;
  }, u.parseExtmap = function(c) {
    const l = c.substring(9).split(" ");
    return {
      id: parseInt(l[0], 10),
      direction: l[0].indexOf("/") > 0 ? l[0].split("/")[1] : "sendrecv",
      uri: l[1],
      attributes: l.slice(2).join(" ")
    };
  }, u.writeExtmap = function(c) {
    return "a=extmap:" + (c.id || c.preferredId) + (c.direction && c.direction !== "sendrecv" ? "/" + c.direction : "") + " " + c.uri + (c.attributes ? " " + c.attributes : "") + `\r
`;
  }, u.parseFmtp = function(c) {
    const l = {};
    let v;
    const S = c.substring(c.indexOf(" ") + 1).split(";");
    for (let g = 0; g < S.length; g++)
      v = S[g].trim().split("="), l[v[0].trim()] = v[1];
    return l;
  }, u.writeFmtp = function(c) {
    let l = "", v = c.payloadType;
    if (c.preferredPayloadType !== void 0 && (v = c.preferredPayloadType), c.parameters && Object.keys(c.parameters).length) {
      const S = [];
      Object.keys(c.parameters).forEach((g) => {
        c.parameters[g] !== void 0 ? S.push(g + "=" + c.parameters[g]) : S.push(g);
      }), l += "a=fmtp:" + v + " " + S.join(";") + `\r
`;
    }
    return l;
  }, u.parseRtcpFb = function(c) {
    const l = c.substring(c.indexOf(" ") + 1).split(" ");
    return {
      type: l.shift(),
      parameter: l.join(" ")
    };
  }, u.writeRtcpFb = function(c) {
    let l = "", v = c.payloadType;
    return c.preferredPayloadType !== void 0 && (v = c.preferredPayloadType), c.rtcpFeedback && c.rtcpFeedback.length && c.rtcpFeedback.forEach((S) => {
      l += "a=rtcp-fb:" + v + " " + S.type + (S.parameter && S.parameter.length ? " " + S.parameter : "") + `\r
`;
    }), l;
  }, u.parseSsrcMedia = function(c) {
    const l = c.indexOf(" "), v = {
      ssrc: parseInt(c.substring(7, l), 10)
    }, S = c.indexOf(":", l);
    return S > -1 ? (v.attribute = c.substring(l + 1, S), v.value = c.substring(S + 1)) : v.attribute = c.substring(l + 1), v;
  }, u.parseSsrcGroup = function(c) {
    const l = c.substring(13).split(" ");
    return {
      semantics: l.shift(),
      ssrcs: l.map((v) => parseInt(v, 10))
    };
  }, u.getMid = function(c) {
    const l = u.matchPrefix(c, "a=mid:")[0];
    if (l)
      return l.substring(6);
  }, u.parseFingerprint = function(c) {
    const l = c.substring(14).split(" ");
    return {
      algorithm: l[0].toLowerCase(),
      // algorithm is case-sensitive in Edge.
      value: l[1].toUpperCase()
      // the definition is upper-case in RFC 4572.
    };
  }, u.getDtlsParameters = function(c, l) {
    return {
      role: "auto",
      fingerprints: u.matchPrefix(c + l, "a=fingerprint:").map(u.parseFingerprint)
    };
  }, u.writeDtlsParameters = function(c, l) {
    let v = "a=setup:" + l + `\r
`;
    return c.fingerprints.forEach((S) => {
      v += "a=fingerprint:" + S.algorithm + " " + S.value + `\r
`;
    }), v;
  }, u.parseCryptoLine = function(c) {
    const l = c.substring(9).split(" ");
    return {
      tag: parseInt(l[0], 10),
      cryptoSuite: l[1],
      keyParams: l[2],
      sessionParams: l.slice(3)
    };
  }, u.writeCryptoLine = function(c) {
    return "a=crypto:" + c.tag + " " + c.cryptoSuite + " " + (typeof c.keyParams == "object" ? u.writeCryptoKeyParams(c.keyParams) : c.keyParams) + (c.sessionParams ? " " + c.sessionParams.join(" ") : "") + `\r
`;
  }, u.parseCryptoKeyParams = function(c) {
    if (c.indexOf("inline:") !== 0)
      return null;
    const l = c.substring(7).split("|");
    return {
      keyMethod: "inline",
      keySalt: l[0],
      lifeTime: l[1],
      mkiValue: l[2] ? l[2].split(":")[0] : void 0,
      mkiLength: l[2] ? l[2].split(":")[1] : void 0
    };
  }, u.writeCryptoKeyParams = function(c) {
    return c.keyMethod + ":" + c.keySalt + (c.lifeTime ? "|" + c.lifeTime : "") + (c.mkiValue && c.mkiLength ? "|" + c.mkiValue + ":" + c.mkiLength : "");
  }, u.getCryptoParameters = function(c, l) {
    return u.matchPrefix(c + l, "a=crypto:").map(u.parseCryptoLine);
  }, u.getIceParameters = function(c, l) {
    const v = u.matchPrefix(c + l, "a=ice-ufrag:")[0], S = u.matchPrefix(c + l, "a=ice-pwd:")[0];
    return v && S ? {
      usernameFragment: v.substring(12),
      password: S.substring(10)
    } : null;
  }, u.writeIceParameters = function(c) {
    let l = "a=ice-ufrag:" + c.usernameFragment + `\r
a=ice-pwd:` + c.password + `\r
`;
    return c.iceLite && (l += `a=ice-lite\r
`), l;
  }, u.parseRtpParameters = function(c) {
    const l = {
      codecs: [],
      headerExtensions: [],
      fecMechanisms: [],
      rtcp: []
    }, S = u.splitLines(c)[0].split(" ");
    l.profile = S[2];
    for (let E = 3; E < S.length; E++) {
      const _ = S[E], k = u.matchPrefix(c, "a=rtpmap:" + _ + " ")[0];
      if (k) {
        const L = u.parseRtpMap(k), M = u.matchPrefix(c, "a=fmtp:" + _ + " ");
        switch (L.parameters = M.length ? u.parseFmtp(M[0]) : {}, L.rtcpFeedback = u.matchPrefix(c, "a=rtcp-fb:" + _ + " ").map(u.parseRtcpFb), l.codecs.push(L), L.name.toUpperCase()) {
          case "RED":
          case "ULPFEC":
            l.fecMechanisms.push(L.name.toUpperCase());
            break;
        }
      }
    }
    u.matchPrefix(c, "a=extmap:").forEach((E) => {
      l.headerExtensions.push(u.parseExtmap(E));
    });
    const g = u.matchPrefix(c, "a=rtcp-fb:* ").map(u.parseRtcpFb);
    return l.codecs.forEach((E) => {
      g.forEach((_) => {
        E.rtcpFeedback.find((L) => L.type === _.type && L.parameter === _.parameter) || E.rtcpFeedback.push(_);
      });
    }), l;
  }, u.writeRtpDescription = function(c, l) {
    let v = "";
    v += "m=" + c + " ", v += l.codecs.length > 0 ? "9" : "0", v += " " + (l.profile || "UDP/TLS/RTP/SAVPF") + " ", v += l.codecs.map((g) => g.preferredPayloadType !== void 0 ? g.preferredPayloadType : g.payloadType).join(" ") + `\r
`, v += `c=IN IP4 0.0.0.0\r
`, v += `a=rtcp:9 IN IP4 0.0.0.0\r
`, l.codecs.forEach((g) => {
      v += u.writeRtpMap(g), v += u.writeFmtp(g), v += u.writeRtcpFb(g);
    });
    let S = 0;
    return l.codecs.forEach((g) => {
      g.maxptime > S && (S = g.maxptime);
    }), S > 0 && (v += "a=maxptime:" + S + `\r
`), l.headerExtensions && l.headerExtensions.forEach((g) => {
      v += u.writeExtmap(g);
    }), v;
  }, u.parseRtpEncodingParameters = function(c) {
    const l = [], v = u.parseRtpParameters(c), S = v.fecMechanisms.indexOf("RED") !== -1, g = v.fecMechanisms.indexOf("ULPFEC") !== -1, E = u.matchPrefix(c, "a=ssrc:").map(($) => u.parseSsrcMedia($)).filter(($) => $.attribute === "cname"), _ = E.length > 0 && E[0].ssrc;
    let k;
    const L = u.matchPrefix(c, "a=ssrc-group:FID").map(($) => $.substring(17).split(" ").map((V) => parseInt(V, 10)));
    L.length > 0 && L[0].length > 1 && L[0][0] === _ && (k = L[0][1]), v.codecs.forEach(($) => {
      if ($.name.toUpperCase() === "RTX" && $.parameters.apt) {
        let J = {
          ssrc: _,
          codecPayloadType: parseInt($.parameters.apt, 10)
        };
        _ && k && (J.rtx = {
          ssrc: k
        }), l.push(J), S && (J = JSON.parse(JSON.stringify(J)), J.fec = {
          ssrc: _,
          mechanism: g ? "red+ulpfec" : "red"
        }, l.push(J));
      }
    }), l.length === 0 && _ && l.push({
      ssrc: _
    });
    let M = u.matchPrefix(c, "b=");
    return M.length && (M[0].indexOf("b=TIAS:") === 0 ? M = parseInt(M[0].substring(7), 10) : M[0].indexOf("b=AS:") === 0 ? M = parseInt(M[0].substring(5), 10) * 1e3 * 0.95 - 50 * 40 * 8 : M = void 0, l.forEach(($) => {
      $.maxBitrate = M;
    })), l;
  }, u.parseRtcpParameters = function(c) {
    const l = {}, v = u.matchPrefix(c, "a=ssrc:").map((E) => u.parseSsrcMedia(E)).filter((E) => E.attribute === "cname")[0];
    v && (l.cname = v.value, l.ssrc = v.ssrc);
    const S = u.matchPrefix(c, "a=rtcp-rsize");
    l.reducedSize = S.length > 0, l.compound = S.length === 0;
    const g = u.matchPrefix(c, "a=rtcp-mux");
    return l.mux = g.length > 0, l;
  }, u.writeRtcpParameters = function(c) {
    let l = "";
    return c.reducedSize && (l += `a=rtcp-rsize\r
`), c.mux && (l += `a=rtcp-mux\r
`), c.ssrc !== void 0 && c.cname && (l += "a=ssrc:" + c.ssrc + " cname:" + c.cname + `\r
`), l;
  }, u.parseMsid = function(c) {
    let l;
    const v = u.matchPrefix(c, "a=msid:");
    if (v.length === 1)
      return l = v[0].substring(7).split(" "), {
        stream: l[0],
        track: l[1]
      };
    const S = u.matchPrefix(c, "a=ssrc:").map((g) => u.parseSsrcMedia(g)).filter((g) => g.attribute === "msid");
    if (S.length > 0)
      return l = S[0].value.split(" "), {
        stream: l[0],
        track: l[1]
      };
  }, u.parseSctpDescription = function(c) {
    const l = u.parseMLine(c), v = u.matchPrefix(c, "a=max-message-size:");
    let S;
    v.length > 0 && (S = parseInt(v[0].substring(19), 10)), isNaN(S) && (S = 65536);
    const g = u.matchPrefix(c, "a=sctp-port:");
    if (g.length > 0)
      return {
        port: parseInt(g[0].substring(12), 10),
        protocol: l.fmt,
        maxMessageSize: S
      };
    const E = u.matchPrefix(c, "a=sctpmap:");
    if (E.length > 0) {
      const _ = E[0].substring(10).split(" ");
      return {
        port: parseInt(_[0], 10),
        protocol: _[1],
        maxMessageSize: S
      };
    }
  }, u.writeSctpDescription = function(c, l) {
    let v = [];
    return c.protocol !== "DTLS/SCTP" ? v = ["m=" + c.kind + " 9 " + c.protocol + " " + l.protocol + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctp-port:" + l.port + `\r
`] : v = ["m=" + c.kind + " 9 " + c.protocol + " " + l.port + `\r
`, `c=IN IP4 0.0.0.0\r
`, "a=sctpmap:" + l.port + " " + l.protocol + ` 65535\r
`], l.maxMessageSize !== void 0 && v.push("a=max-message-size:" + l.maxMessageSize + `\r
`), v.join("");
  }, u.generateSessionId = function() {
    return Math.random().toString().substr(2, 22);
  }, u.writeSessionBoilerplate = function(c, l, v) {
    let S;
    const g = l !== void 0 ? l : 2;
    return c ? S = c : S = u.generateSessionId(), `v=0\r
o=` + (v || "thisisadapterortc") + " " + S + " " + g + ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`;
  }, u.getDirection = function(c, l) {
    const v = u.splitLines(c);
    for (let S = 0; S < v.length; S++)
      switch (v[S]) {
        case "a=sendrecv":
        case "a=sendonly":
        case "a=recvonly":
        case "a=inactive":
          return v[S].substring(2);
      }
    return l ? u.getDirection(l) : "sendrecv";
  }, u.getKind = function(c) {
    return u.splitLines(c)[0].split(" ")[0].substring(2);
  }, u.isRejected = function(c) {
    return c.split(" ", 2)[1] === "0";
  }, u.parseMLine = function(c) {
    const v = u.splitLines(c)[0].substring(2).split(" ");
    return {
      kind: v[0],
      port: parseInt(v[1], 10),
      protocol: v[2],
      fmt: v.slice(3).join(" ")
    };
  }, u.parseOLine = function(c) {
    const v = u.matchPrefix(c, "o=")[0].substring(2).split(" ");
    return {
      username: v[0],
      sessionId: v[1],
      sessionVersion: parseInt(v[2], 10),
      netType: v[3],
      addressType: v[4],
      address: v[5]
    };
  }, u.isValidSDP = function(c) {
    if (typeof c != "string" || c.length === 0)
      return !1;
    const l = u.splitLines(c);
    for (let v = 0; v < l.length; v++)
      if (l[v].length < 2 || l[v].charAt(1) !== "=")
        return !1;
    return !0;
  }, a.exports = u;
})(sdp$1);
var sdpExports = sdp$1.exports, SDPUtils = /* @__PURE__ */ getDefaultExportFromCjs(sdpExports), sdp = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: SDPUtils
}, [sdpExports]);
function shimRTCIceCandidate(a) {
  if (!a.RTCIceCandidate || a.RTCIceCandidate && "foundation" in a.RTCIceCandidate.prototype)
    return;
  const u = a.RTCIceCandidate;
  a.RTCIceCandidate = function(l) {
    if (typeof l == "object" && l.candidate && l.candidate.indexOf("a=") === 0 && (l = JSON.parse(JSON.stringify(l)), l.candidate = l.candidate.substring(2)), l.candidate && l.candidate.length) {
      const v = new u(l), S = SDPUtils.parseCandidate(l.candidate);
      for (const g in S)
        g in v || Object.defineProperty(v, g, {
          value: S[g]
        });
      return v.toJSON = function() {
        return {
          candidate: v.candidate,
          sdpMid: v.sdpMid,
          sdpMLineIndex: v.sdpMLineIndex,
          usernameFragment: v.usernameFragment
        };
      }, v;
    }
    return new u(l);
  }, a.RTCIceCandidate.prototype = u.prototype, wrapPeerConnectionEvent(a, "icecandidate", (c) => (c.candidate && Object.defineProperty(c, "candidate", {
    value: new a.RTCIceCandidate(c.candidate),
    writable: "false"
  }), c));
}
function shimRTCIceCandidateRelayProtocol(a) {
  !a.RTCIceCandidate || a.RTCIceCandidate && "relayProtocol" in a.RTCIceCandidate.prototype || wrapPeerConnectionEvent(a, "icecandidate", (u) => {
    if (u.candidate) {
      const c = SDPUtils.parseCandidate(u.candidate.candidate);
      c.type === "relay" && (u.candidate.relayProtocol = {
        0: "tls",
        1: "tcp",
        2: "udp"
      }[c.priority >> 24]);
    }
    return u;
  });
}
function shimMaxMessageSize(a, u) {
  if (!a.RTCPeerConnection)
    return;
  "sctp" in a.RTCPeerConnection.prototype || Object.defineProperty(a.RTCPeerConnection.prototype, "sctp", {
    get() {
      return typeof this._sctp > "u" ? null : this._sctp;
    }
  });
  const c = function(E) {
    if (!E || !E.sdp)
      return !1;
    const _ = SDPUtils.splitSections(E.sdp);
    return _.shift(), _.some((k) => {
      const L = SDPUtils.parseMLine(k);
      return L && L.kind === "application" && L.protocol.indexOf("SCTP") !== -1;
    });
  }, l = function(E) {
    const _ = E.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
    if (_ === null || _.length < 2)
      return -1;
    const k = parseInt(_[1], 10);
    return k !== k ? -1 : k;
  }, v = function(E) {
    let _ = 65536;
    return u.browser === "firefox" && (u.version < 57 ? E === -1 ? _ = 16384 : _ = 2147483637 : u.version < 60 ? _ = u.version === 57 ? 65535 : 65536 : _ = 2147483637), _;
  }, S = function(E, _) {
    let k = 65536;
    u.browser === "firefox" && u.version === 57 && (k = 65535);
    const L = SDPUtils.matchPrefix(E.sdp, "a=max-message-size:");
    return L.length > 0 ? k = parseInt(L[0].substring(19), 10) : u.browser === "firefox" && _ !== -1 && (k = 2147483637), k;
  }, g = a.RTCPeerConnection.prototype.setRemoteDescription;
  a.RTCPeerConnection.prototype.setRemoteDescription = function() {
    if (this._sctp = null, u.browser === "chrome" && u.version >= 76) {
      const {
        sdpSemantics: _
      } = this.getConfiguration();
      _ === "plan-b" && Object.defineProperty(this, "sctp", {
        get() {
          return typeof this._sctp > "u" ? null : this._sctp;
        },
        enumerable: !0,
        configurable: !0
      });
    }
    if (c(arguments[0])) {
      const _ = l(arguments[0]), k = v(_), L = S(arguments[0], _);
      let M;
      k === 0 && L === 0 ? M = Number.POSITIVE_INFINITY : k === 0 || L === 0 ? M = Math.max(k, L) : M = Math.min(k, L);
      const $ = {};
      Object.defineProperty($, "maxMessageSize", {
        get() {
          return M;
        }
      }), this._sctp = $;
    }
    return g.apply(this, arguments);
  };
}
function shimSendThrowTypeError(a) {
  if (!(a.RTCPeerConnection && "createDataChannel" in a.RTCPeerConnection.prototype))
    return;
  function u(l, v) {
    const S = l.send;
    l.send = function() {
      const E = arguments[0], _ = E.length || E.size || E.byteLength;
      if (l.readyState === "open" && v.sctp && _ > v.sctp.maxMessageSize)
        throw new TypeError("Message too large (can send a maximum of " + v.sctp.maxMessageSize + " bytes)");
      return S.apply(l, arguments);
    };
  }
  const c = a.RTCPeerConnection.prototype.createDataChannel;
  a.RTCPeerConnection.prototype.createDataChannel = function() {
    const v = c.apply(this, arguments);
    return u(v, this), v;
  }, wrapPeerConnectionEvent(a, "datachannel", (l) => (u(l.channel, l.target), l));
}
function shimConnectionState(a) {
  if (!a.RTCPeerConnection || "connectionState" in a.RTCPeerConnection.prototype)
    return;
  const u = a.RTCPeerConnection.prototype;
  Object.defineProperty(u, "connectionState", {
    get() {
      return {
        completed: "connected",
        checking: "connecting"
      }[this.iceConnectionState] || this.iceConnectionState;
    },
    enumerable: !0,
    configurable: !0
  }), Object.defineProperty(u, "onconnectionstatechange", {
    get() {
      return this._onconnectionstatechange || null;
    },
    set(c) {
      this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), c && this.addEventListener("connectionstatechange", this._onconnectionstatechange = c);
    },
    enumerable: !0,
    configurable: !0
  }), ["setLocalDescription", "setRemoteDescription"].forEach((c) => {
    const l = u[c];
    u[c] = function() {
      return this._connectionstatechangepoly || (this._connectionstatechangepoly = (v) => {
        const S = v.target;
        if (S._lastConnectionState !== S.connectionState) {
          S._lastConnectionState = S.connectionState;
          const g = new Event("connectionstatechange", v);
          S.dispatchEvent(g);
        }
        return v;
      }, this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), l.apply(this, arguments);
    };
  });
}
function removeExtmapAllowMixed(a, u) {
  if (!a.RTCPeerConnection || u.browser === "chrome" && u.version >= 71 || u.browser === "safari" && u.version >= 605)
    return;
  const c = a.RTCPeerConnection.prototype.setRemoteDescription;
  a.RTCPeerConnection.prototype.setRemoteDescription = function(v) {
    if (v && v.sdp && v.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1) {
      const S = v.sdp.split(`
`).filter((g) => g.trim() !== "a=extmap-allow-mixed").join(`
`);
      a.RTCSessionDescription && v instanceof a.RTCSessionDescription ? arguments[0] = new a.RTCSessionDescription({
        type: v.type,
        sdp: S
      }) : v.sdp = S;
    }
    return c.apply(this, arguments);
  };
}
function shimAddIceCandidateNullOrEmpty(a, u) {
  if (!(a.RTCPeerConnection && a.RTCPeerConnection.prototype))
    return;
  const c = a.RTCPeerConnection.prototype.addIceCandidate;
  !c || c.length === 0 || (a.RTCPeerConnection.prototype.addIceCandidate = function() {
    return arguments[0] ? (u.browser === "chrome" && u.version < 78 || u.browser === "firefox" && u.version < 68 || u.browser === "safari") && arguments[0] && arguments[0].candidate === "" ? Promise.resolve() : c.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
  });
}
function shimParameterlessSetLocalDescription(a, u) {
  if (!(a.RTCPeerConnection && a.RTCPeerConnection.prototype))
    return;
  const c = a.RTCPeerConnection.prototype.setLocalDescription;
  !c || c.length === 0 || (a.RTCPeerConnection.prototype.setLocalDescription = function() {
    let v = arguments[0] || {};
    if (typeof v != "object" || v.type && v.sdp)
      return c.apply(this, arguments);
    if (v = {
      type: v.type,
      sdp: v.sdp
    }, !v.type)
      switch (this.signalingState) {
        case "stable":
        case "have-local-offer":
        case "have-remote-pranswer":
          v.type = "offer";
          break;
        default:
          v.type = "answer";
          break;
      }
    return v.sdp || v.type !== "offer" && v.type !== "answer" ? c.apply(this, [v]) : (v.type === "offer" ? this.createOffer : this.createAnswer).apply(this).then((g) => c.apply(this, [g]));
  });
}
var commonShim = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  removeExtmapAllowMixed,
  shimAddIceCandidateNullOrEmpty,
  shimConnectionState,
  shimMaxMessageSize,
  shimParameterlessSetLocalDescription,
  shimRTCIceCandidate,
  shimRTCIceCandidateRelayProtocol,
  shimSendThrowTypeError
});
function adapterFactory() {
  let {
    window: a
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    shimChrome: !0,
    shimFirefox: !0,
    shimSafari: !0
  };
  const c = log, l = detectBrowser(a), v = {
    browserDetails: l,
    commonShim,
    extractVersion,
    disableLog,
    disableWarnings,
    // Expose sdp as a convenience. For production apps include directly.
    sdp
  };
  switch (l.browser) {
    case "chrome":
      if (!chromeShim || !shimPeerConnection$1 || !u.shimChrome)
        return c("Chrome shim is not included in this adapter release."), v;
      if (l.version === null)
        return c("Chrome shim can not determine version, not shimming."), v;
      c("adapter.js shimming chrome."), v.browserShim = chromeShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimGetUserMedia$2(a, l), shimMediaStream(a), shimPeerConnection$1(a, l), shimOnTrack$1(a), shimAddTrackRemoveTrack(a, l), shimGetSendersWithDtmf(a), shimGetStats(a), shimSenderReceiverGetStats(a), fixNegotiationNeeded(a, l), shimRTCIceCandidate(a), shimRTCIceCandidateRelayProtocol(a), shimConnectionState(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a), removeExtmapAllowMixed(a, l);
      break;
    case "firefox":
      if (!firefoxShim || !shimPeerConnection || !u.shimFirefox)
        return c("Firefox shim is not included in this adapter release."), v;
      c("adapter.js shimming firefox."), v.browserShim = firefoxShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimGetUserMedia$1(a, l), shimPeerConnection(a, l), shimOnTrack(a), shimRemoveStream(a), shimSenderGetStats(a), shimReceiverGetStats(a), shimRTCDataChannel(a), shimAddTransceiver(a), shimGetParameters(a), shimCreateOffer(a), shimCreateAnswer(a), shimRTCIceCandidate(a), shimConnectionState(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a);
      break;
    case "safari":
      if (!safariShim || !u.shimSafari)
        return c("Safari shim is not included in this adapter release."), v;
      c("adapter.js shimming safari."), v.browserShim = safariShim, shimAddIceCandidateNullOrEmpty(a, l), shimParameterlessSetLocalDescription(a), shimRTCIceServerUrls(a), shimCreateOfferLegacy(a), shimCallbacksAPI(a), shimLocalStreamsAPI(a), shimRemoteStreamsAPI(a), shimTrackEventTransceiver(a), shimGetUserMedia(a), shimAudioContext(a), shimRTCIceCandidate(a), shimRTCIceCandidateRelayProtocol(a), shimMaxMessageSize(a, l), shimSendThrowTypeError(a), removeExtmapAllowMixed(a, l);
      break;
    default:
      c("Unsupported browser!");
      break;
  }
  return v;
}
adapterFactory({
  window: typeof window > "u" ? void 0 : window
});
const DECRYPTION_FAILURE_TOLERANCE = 10, E2EE_FLAG = "lk_e2ee", SALT = "LKFrameEncryptionKey", KEY_PROVIDER_DEFAULTS = {
  sharedKey: !1,
  ratchetSalt: SALT,
  ratchetWindowSize: 8,
  failureTolerance: DECRYPTION_FAILURE_TOLERANCE
};
var KeyProviderEvent;
(function(a) {
  a.SetKey = "setKey", a.RatchetRequest = "ratchetRequest", a.KeyRatcheted = "keyRatcheted";
})(KeyProviderEvent || (KeyProviderEvent = {}));
var KeyHandlerEvent;
(function(a) {
  a.KeyRatcheted = "keyRatcheted";
})(KeyHandlerEvent || (KeyHandlerEvent = {}));
var EncryptionEvent;
(function(a) {
  a.ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged", a.EncryptionError = "encryptionError";
})(EncryptionEvent || (EncryptionEvent = {}));
var CryptorEvent;
(function(a) {
  a.Error = "cryptorError";
})(CryptorEvent || (CryptorEvent = {}));
function isE2EESupported() {
  return isInsertableStreamSupported() || isScriptTransformSupported();
}
function isScriptTransformSupported() {
  return typeof window.RTCRtpScriptTransform < "u";
}
function isInsertableStreamSupported() {
  return typeof window.RTCRtpSender < "u" && // @ts-ignore
  typeof window.RTCRtpSender.prototype.createEncodedStreams < "u";
}
class BaseKeyProvider extends eventsExports.EventEmitter {
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(), this.onKeyRatcheted = (c, l) => {
      livekitLogger.debug("key ratcheted event received", {
        material: c,
        keyIndex: l
      });
    }, this.keyInfoMap = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), u), this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);
  }
  /**
   * callback to invoke once a key has been set for a participant
   * @param key
   * @param participantIdentity
   * @param keyIndex
   */
  onSetEncryptionKey(u, c, l) {
    const v = {
      key: u,
      participantIdentity: c,
      keyIndex: l
    };
    this.keyInfoMap.set("".concat(c ?? "shared", "-").concat(l ?? 0), v), this.emit(KeyProviderEvent.SetKey, v);
  }
  getKeys() {
    return Array.from(this.keyInfoMap.values());
  }
  getOptions() {
    return this.options;
  }
  ratchetKey(u, c) {
    this.emit(KeyProviderEvent.RatchetRequest, u, c);
  }
}
class LivekitError extends Error {
  constructor(u, c) {
    super(c || "an error has occured"), this.code = u;
  }
}
class ConnectionError extends LivekitError {
  constructor(u, c, l) {
    super(1, u), this.status = l, this.reason = c;
  }
}
class DeviceUnsupportedError extends LivekitError {
  constructor(u) {
    super(21, u ?? "device is unsupported");
  }
}
class TrackInvalidError extends LivekitError {
  constructor(u) {
    super(20, u ?? "track is invalid");
  }
}
class UnsupportedServer extends LivekitError {
  constructor(u) {
    super(10, u ?? "unsupported server");
  }
}
class UnexpectedConnectionState extends LivekitError {
  constructor(u) {
    super(12, u ?? "unexpected connection state");
  }
}
class NegotiationError extends LivekitError {
  constructor(u) {
    super(13, u ?? "unable to negotiate");
  }
}
var MediaDeviceFailure;
(function(a) {
  a.PermissionDenied = "PermissionDenied", a.NotFound = "NotFound", a.DeviceInUse = "DeviceInUse", a.Other = "Other";
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
(function(a) {
  function u(c) {
    if (c && "name" in c)
      return c.name === "NotFoundError" || c.name === "DevicesNotFoundError" ? a.NotFound : c.name === "NotAllowedError" || c.name === "PermissionDeniedError" ? a.PermissionDenied : c.name === "NotReadableError" || c.name === "TrackStartError" ? a.DeviceInUse : a.Other;
  }
  a.getFailure = u;
})(MediaDeviceFailure || (MediaDeviceFailure = {}));
var RoomEvent;
(function(a) {
  a.Connected = "connected", a.Reconnecting = "reconnecting", a.Reconnected = "reconnected", a.Disconnected = "disconnected", a.ConnectionStateChanged = "connectionStateChanged", a.MediaDevicesChanged = "mediaDevicesChanged", a.ParticipantConnected = "participantConnected", a.ParticipantDisconnected = "participantDisconnected", a.TrackPublished = "trackPublished", a.TrackSubscribed = "trackSubscribed", a.TrackSubscriptionFailed = "trackSubscriptionFailed", a.TrackUnpublished = "trackUnpublished", a.TrackUnsubscribed = "trackUnsubscribed", a.TrackMuted = "trackMuted", a.TrackUnmuted = "trackUnmuted", a.LocalTrackPublished = "localTrackPublished", a.LocalTrackUnpublished = "localTrackUnpublished", a.LocalAudioSilenceDetected = "localAudioSilenceDetected", a.ActiveSpeakersChanged = "activeSpeakersChanged", a.ParticipantMetadataChanged = "participantMetadataChanged", a.ParticipantNameChanged = "participantNameChanged", a.RoomMetadataChanged = "roomMetadataChanged", a.DataReceived = "dataReceived", a.ConnectionQualityChanged = "connectionQualityChanged", a.TrackStreamStateChanged = "trackStreamStateChanged", a.TrackSubscriptionPermissionChanged = "trackSubscriptionPermissionChanged", a.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged", a.AudioPlaybackStatusChanged = "audioPlaybackChanged", a.VideoPlaybackStatusChanged = "videoPlaybackChanged", a.MediaDevicesError = "mediaDevicesError", a.ParticipantPermissionsChanged = "participantPermissionsChanged", a.SignalConnected = "signalConnected", a.RecordingStatusChanged = "recordingStatusChanged", a.ParticipantEncryptionStatusChanged = "participantEncryptionStatusChanged", a.EncryptionError = "encryptionError", a.DCBufferStatusChanged = "dcBufferStatusChanged", a.ActiveDeviceChanged = "activeDeviceChanged";
})(RoomEvent || (RoomEvent = {}));
var ParticipantEvent;
(function(a) {
  a.TrackPublished = "trackPublished", a.TrackSubscribed = "trackSubscribed", a.TrackSubscriptionFailed = "trackSubscriptionFailed", a.TrackUnpublished = "trackUnpublished", a.TrackUnsubscribed = "trackUnsubscribed", a.TrackMuted = "trackMuted", a.TrackUnmuted = "trackUnmuted", a.LocalTrackPublished = "localTrackPublished", a.LocalTrackUnpublished = "localTrackUnpublished", a.ParticipantMetadataChanged = "participantMetadataChanged", a.ParticipantNameChanged = "participantNameChanged", a.DataReceived = "dataReceived", a.IsSpeakingChanged = "isSpeakingChanged", a.ConnectionQualityChanged = "connectionQualityChanged", a.TrackStreamStateChanged = "trackStreamStateChanged", a.TrackSubscriptionPermissionChanged = "trackSubscriptionPermissionChanged", a.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged", a.MediaDevicesError = "mediaDevicesError", a.AudioStreamAcquired = "audioStreamAcquired", a.ParticipantPermissionsChanged = "participantPermissionsChanged", a.PCTrackAdded = "pcTrackAdded";
})(ParticipantEvent || (ParticipantEvent = {}));
var EngineEvent;
(function(a) {
  a.TransportsCreated = "transportsCreated", a.Connected = "connected", a.Disconnected = "disconnected", a.Resuming = "resuming", a.Resumed = "resumed", a.Restarting = "restarting", a.Restarted = "restarted", a.SignalResumed = "signalResumed", a.SignalRestarted = "signalRestarted", a.Closing = "closing", a.MediaTrackAdded = "mediaTrackAdded", a.ActiveSpeakersUpdate = "activeSpeakersUpdate", a.DataPacketReceived = "dataPacketReceived", a.RTPVideoMapUpdate = "rtpVideoMapUpdate", a.DCBufferStatusChanged = "dcBufferStatusChanged", a.ParticipantUpdate = "participantUpdate", a.RoomUpdate = "roomUpdate", a.SpeakersChanged = "speakersChanged", a.StreamStateChanged = "streamStateChanged", a.ConnectionQualityUpdate = "connectionQualityUpdate", a.SubscriptionError = "subscriptionError", a.SubscriptionPermissionUpdate = "subscriptionPermissionUpdate", a.RemoteMute = "remoteMute", a.SubscribedQualityUpdate = "subscribedQualityUpdate", a.LocalTrackUnpublished = "localTrackUnpublished";
})(EngineEvent || (EngineEvent = {}));
var TrackEvent;
(function(a) {
  a.Message = "message", a.Muted = "muted", a.Unmuted = "unmuted", a.Restarted = "restarted", a.Ended = "ended", a.Subscribed = "subscribed", a.Unsubscribed = "unsubscribed", a.UpdateSettings = "updateSettings", a.UpdateSubscription = "updateSubscription", a.AudioPlaybackStarted = "audioPlaybackStarted", a.AudioPlaybackFailed = "audioPlaybackFailed", a.AudioSilenceDetected = "audioSilenceDetected", a.VisibilityChanged = "visibilityChanged", a.VideoDimensionsChanged = "videoDimensionsChanged", a.VideoPlaybackStarted = "videoPlaybackStarted", a.VideoPlaybackFailed = "videoPlaybackFailed", a.ElementAttached = "elementAttached", a.ElementDetached = "elementDetached", a.UpstreamPaused = "upstreamPaused", a.UpstreamResumed = "upstreamResumed", a.SubscriptionPermissionChanged = "subscriptionPermissionChanged", a.SubscriptionStatusChanged = "subscriptionStatusChanged", a.SubscriptionFailed = "subscriptionFailed";
})(TrackEvent || (TrackEvent = {}));
function r(a, u, c) {
  var l, v, S;
  u === void 0 && (u = 50), c === void 0 && (c = {});
  var g = (l = c.isImmediate) != null && l, E = (v = c.callback) != null && v, _ = c.maxWait, k = Date.now(), L = [];
  function M() {
    if (_ !== void 0) {
      var J = Date.now() - k;
      if (J + u >= _)
        return _ - J;
    }
    return u;
  }
  var $ = function() {
    var J = [].slice.call(arguments), V = this;
    return new Promise(function(q, G) {
      var H = g && S === void 0;
      if (S !== void 0 && clearTimeout(S), S = setTimeout(function() {
        if (S = void 0, k = Date.now(), !g) {
          var Y = a.apply(V, J);
          E && E(Y), L.forEach(function(ne) {
            return (0, ne.resolve)(Y);
          }), L = [];
        }
      }, M()), H) {
        var B = a.apply(V, J);
        return E && E(B), q(B);
      }
      L.push({
        resolve: q,
        reject: G
      });
    });
  };
  return $.cancel = function(J) {
    S !== void 0 && clearTimeout(S), L.forEach(function(V) {
      return (0, V.reject)(J);
    }), L = [];
  }, $;
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
let browserDetails;
function getBrowser(a) {
  let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  if (typeof a > "u" && typeof navigator > "u")
    return;
  const c = (a ?? navigator.userAgent).toLowerCase();
  if (browserDetails === void 0 || u) {
    const l = browsersList.find((v) => {
      let {
        test: S
      } = v;
      return S.test(c);
    });
    browserDetails = l == null ? void 0 : l.describe(c);
  }
  return browserDetails;
}
const browsersList = [
  {
    test: /firefox|iceweasel|fxios/i,
    describe(a) {
      return {
        name: "Firefox",
        version: getMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, a),
        os: a.toLowerCase().includes("fxios") ? "iOS" : void 0
      };
    }
  },
  {
    test: /chrom|crios|crmo/i,
    describe(a) {
      return {
        name: "Chrome",
        version: getMatch(/(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i, a),
        os: a.toLowerCase().includes("crios") ? "iOS" : void 0
      };
    }
  },
  /* Safari */
  {
    test: /safari|applewebkit/i,
    describe(a) {
      return {
        name: "Safari",
        version: getMatch(commonVersionIdentifier, a),
        os: a.includes("mobile/") ? "iOS" : "macOS"
      };
    }
  }
];
function getMatch(a, u) {
  let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  const l = u.match(a);
  return l && l.length >= c && l[c] || "";
}
var version$1 = "2.0.1";
const version = version$1, protocolVersion = 12;
class CriticalTimers {
}
CriticalTimers.setTimeout = function() {
  return setTimeout(...arguments);
};
CriticalTimers.setInterval = function() {
  return setInterval(...arguments);
};
CriticalTimers.clearTimeout = function() {
  return clearTimeout(...arguments);
};
CriticalTimers.clearInterval = function() {
  return clearInterval(...arguments);
};
class VideoPreset {
  constructor(u, c, l, v, S) {
    this.width = u, this.height = c, this.encoding = {
      maxBitrate: l,
      maxFramerate: v,
      priority: S
    };
  }
  get resolution() {
    return {
      width: this.width,
      height: this.height,
      frameRate: this.encoding.maxFramerate,
      aspectRatio: this.width / this.height
    };
  }
}
const backupCodecs = ["vp8", "h264"], videoCodecs = ["vp8", "h264", "vp9", "av1"];
function isBackupCodec(a) {
  return !!backupCodecs.find((u) => u === a);
}
var AudioPresets;
(function(a) {
  a.telephone = {
    maxBitrate: 12e3
  }, a.speech = {
    maxBitrate: 2e4
  }, a.music = {
    maxBitrate: 32e3
  }, a.musicStereo = {
    maxBitrate: 48e3
  }, a.musicHighQuality = {
    maxBitrate: 64e3
  }, a.musicHighQualityStereo = {
    maxBitrate: 96e3
  };
})(AudioPresets || (AudioPresets = {}));
const VideoPresets = {
  h90: new VideoPreset(160, 90, 9e4, 20),
  h180: new VideoPreset(320, 180, 16e4, 20),
  h216: new VideoPreset(384, 216, 18e4, 20),
  h360: new VideoPreset(640, 360, 45e4, 20),
  h540: new VideoPreset(960, 540, 8e5, 25),
  h720: new VideoPreset(1280, 720, 17e5, 30),
  h1080: new VideoPreset(1920, 1080, 3e6, 30),
  h1440: new VideoPreset(2560, 1440, 5e6, 30),
  h2160: new VideoPreset(3840, 2160, 8e6, 30)
}, VideoPresets43 = {
  h120: new VideoPreset(160, 120, 7e4, 20),
  h180: new VideoPreset(240, 180, 125e3, 20),
  h240: new VideoPreset(320, 240, 14e4, 20),
  h360: new VideoPreset(480, 360, 33e4, 20),
  h480: new VideoPreset(640, 480, 5e5, 20),
  h540: new VideoPreset(720, 540, 6e5, 25),
  h720: new VideoPreset(960, 720, 13e5, 30),
  h1080: new VideoPreset(1440, 1080, 23e5, 30),
  h1440: new VideoPreset(1920, 1440, 38e5, 30)
}, ScreenSharePresets = {
  h360fps3: new VideoPreset(640, 360, 2e5, 3, "medium"),
  h360fps15: new VideoPreset(640, 360, 4e5, 15, "medium"),
  h720fps5: new VideoPreset(1280, 720, 8e5, 5, "medium"),
  h720fps15: new VideoPreset(1280, 720, 15e5, 15, "medium"),
  h720fps30: new VideoPreset(1280, 720, 2e6, 30, "medium"),
  h1080fps15: new VideoPreset(1920, 1080, 25e5, 15, "medium"),
  h1080fps30: new VideoPreset(1920, 1080, 5e6, 30, "medium"),
  // original resolution, without resizing
  original: new VideoPreset(0, 0, 7e6, 30, "medium")
};
var SignalTarget;
(function(a) {
  a[a.PUBLISHER = 0] = "PUBLISHER", a[a.SUBSCRIBER = 1] = "SUBSCRIBER";
})(SignalTarget || (SignalTarget = {}));
proto3.util.setEnumType(SignalTarget, "livekit.SignalTarget", [{
  no: 0,
  name: "PUBLISHER"
}, {
  no: 1,
  name: "SUBSCRIBER"
}]);
var StreamState;
(function(a) {
  a[a.ACTIVE = 0] = "ACTIVE", a[a.PAUSED = 1] = "PAUSED";
})(StreamState || (StreamState = {}));
proto3.util.setEnumType(StreamState, "livekit.StreamState", [{
  no: 0,
  name: "ACTIVE"
}, {
  no: 1,
  name: "PAUSED"
}]);
var CandidateProtocol;
(function(a) {
  a[a.UDP = 0] = "UDP", a[a.TCP = 1] = "TCP", a[a.TLS = 2] = "TLS";
})(CandidateProtocol || (CandidateProtocol = {}));
proto3.util.setEnumType(CandidateProtocol, "livekit.CandidateProtocol", [{
  no: 0,
  name: "UDP"
}, {
  no: 1,
  name: "TCP"
}, {
  no: 2,
  name: "TLS"
}]);
class SignalRequest extends Message {
  constructor(u) {
    super(), this.message = {
      case: void 0
    }, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SignalRequest().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SignalRequest().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SignalRequest().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SignalRequest, u, c);
  }
}
SignalRequest.runtime = proto3;
SignalRequest.typeName = "livekit.SignalRequest";
SignalRequest.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "offer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 3,
  name: "trickle",
  kind: "message",
  T: TrickleRequest,
  oneof: "message"
}, {
  no: 4,
  name: "add_track",
  kind: "message",
  T: AddTrackRequest,
  oneof: "message"
}, {
  no: 5,
  name: "mute",
  kind: "message",
  T: MuteTrackRequest,
  oneof: "message"
}, {
  no: 6,
  name: "subscription",
  kind: "message",
  T: UpdateSubscription,
  oneof: "message"
}, {
  no: 7,
  name: "track_setting",
  kind: "message",
  T: UpdateTrackSettings,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: LeaveRequest,
  oneof: "message"
}, {
  no: 10,
  name: "update_layers",
  kind: "message",
  T: UpdateVideoLayers,
  oneof: "message"
}, {
  no: 11,
  name: "subscription_permission",
  kind: "message",
  T: SubscriptionPermission,
  oneof: "message"
}, {
  no: 12,
  name: "sync_state",
  kind: "message",
  T: SyncState,
  oneof: "message"
}, {
  no: 13,
  name: "simulate",
  kind: "message",
  T: SimulateScenario,
  oneof: "message"
}, {
  no: 14,
  name: "ping",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 15,
  name: "update_metadata",
  kind: "message",
  T: UpdateParticipantMetadata,
  oneof: "message"
}, {
  no: 16,
  name: "ping_req",
  kind: "message",
  T: Ping,
  oneof: "message"
}]);
class SignalResponse extends Message {
  constructor(u) {
    super(), this.message = {
      case: void 0
    }, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SignalResponse().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SignalResponse().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SignalResponse().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SignalResponse, u, c);
  }
}
SignalResponse.runtime = proto3;
SignalResponse.typeName = "livekit.SignalResponse";
SignalResponse.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "join",
  kind: "message",
  T: JoinResponse,
  oneof: "message"
}, {
  no: 2,
  name: "answer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 3,
  name: "offer",
  kind: "message",
  T: SessionDescription,
  oneof: "message"
}, {
  no: 4,
  name: "trickle",
  kind: "message",
  T: TrickleRequest,
  oneof: "message"
}, {
  no: 5,
  name: "update",
  kind: "message",
  T: ParticipantUpdate,
  oneof: "message"
}, {
  no: 6,
  name: "track_published",
  kind: "message",
  T: TrackPublishedResponse,
  oneof: "message"
}, {
  no: 8,
  name: "leave",
  kind: "message",
  T: LeaveRequest,
  oneof: "message"
}, {
  no: 9,
  name: "mute",
  kind: "message",
  T: MuteTrackRequest,
  oneof: "message"
}, {
  no: 10,
  name: "speakers_changed",
  kind: "message",
  T: SpeakersChanged,
  oneof: "message"
}, {
  no: 11,
  name: "room_update",
  kind: "message",
  T: RoomUpdate,
  oneof: "message"
}, {
  no: 12,
  name: "connection_quality",
  kind: "message",
  T: ConnectionQualityUpdate,
  oneof: "message"
}, {
  no: 13,
  name: "stream_state_update",
  kind: "message",
  T: StreamStateUpdate,
  oneof: "message"
}, {
  no: 14,
  name: "subscribed_quality_update",
  kind: "message",
  T: SubscribedQualityUpdate,
  oneof: "message"
}, {
  no: 15,
  name: "subscription_permission_update",
  kind: "message",
  T: SubscriptionPermissionUpdate,
  oneof: "message"
}, {
  no: 16,
  name: "refresh_token",
  kind: "scalar",
  T: 9,
  oneof: "message"
}, {
  no: 17,
  name: "track_unpublished",
  kind: "message",
  T: TrackUnpublishedResponse,
  oneof: "message"
}, {
  no: 18,
  name: "pong",
  kind: "scalar",
  T: 3,
  oneof: "message"
}, {
  no: 19,
  name: "reconnect",
  kind: "message",
  T: ReconnectResponse,
  oneof: "message"
}, {
  no: 20,
  name: "pong_resp",
  kind: "message",
  T: Pong,
  oneof: "message"
}, {
  no: 21,
  name: "subscription_response",
  kind: "message",
  T: SubscriptionResponse,
  oneof: "message"
}]);
class SimulcastCodec extends Message {
  constructor(u) {
    super(), this.codec = "", this.cid = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SimulcastCodec().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SimulcastCodec().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SimulcastCodec().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SimulcastCodec, u, c);
  }
}
SimulcastCodec.runtime = proto3;
SimulcastCodec.typeName = "livekit.SimulcastCodec";
SimulcastCodec.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class AddTrackRequest extends Message {
  constructor(u) {
    super(), this.cid = "", this.name = "", this.type = TrackType.AUDIO, this.width = 0, this.height = 0, this.muted = !1, this.disableDtx = !1, this.source = TrackSource.UNKNOWN, this.layers = [], this.simulcastCodecs = [], this.sid = "", this.stereo = !1, this.disableRed = !1, this.encryption = Encryption_Type.NONE, this.stream = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new AddTrackRequest().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new AddTrackRequest().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new AddTrackRequest().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(AddTrackRequest, u, c);
  }
}
AddTrackRequest.runtime = proto3;
AddTrackRequest.typeName = "livekit.AddTrackRequest";
AddTrackRequest.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "type",
  kind: "enum",
  T: proto3.getEnumType(TrackType)
}, {
  no: 4,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 5,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "disable_dtx",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 8,
  name: "source",
  kind: "enum",
  T: proto3.getEnumType(TrackSource)
}, {
  no: 9,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}, {
  no: 10,
  name: "simulcast_codecs",
  kind: "message",
  T: SimulcastCodec,
  repeated: !0
}, {
  no: 11,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 12,
  name: "stereo",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 13,
  name: "disable_red",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 14,
  name: "encryption",
  kind: "enum",
  T: proto3.getEnumType(Encryption_Type)
}, {
  no: 15,
  name: "stream",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class TrickleRequest extends Message {
  constructor(u) {
    super(), this.candidateInit = "", this.target = SignalTarget.PUBLISHER, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new TrickleRequest().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new TrickleRequest().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new TrickleRequest().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(TrickleRequest, u, c);
  }
}
TrickleRequest.runtime = proto3;
TrickleRequest.typeName = "livekit.TrickleRequest";
TrickleRequest.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "candidateInit",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "target",
  kind: "enum",
  T: proto3.getEnumType(SignalTarget)
}]);
class MuteTrackRequest extends Message {
  constructor(u) {
    super(), this.sid = "", this.muted = !1, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new MuteTrackRequest().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new MuteTrackRequest().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new MuteTrackRequest().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(MuteTrackRequest, u, c);
  }
}
MuteTrackRequest.runtime = proto3;
MuteTrackRequest.typeName = "livekit.MuteTrackRequest";
MuteTrackRequest.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "muted",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
class JoinResponse extends Message {
  constructor(u) {
    super(), this.otherParticipants = [], this.serverVersion = "", this.iceServers = [], this.subscriberPrimary = !1, this.alternativeUrl = "", this.serverRegion = "", this.pingTimeout = 0, this.pingInterval = 0, this.sifTrailer = new Uint8Array(0), proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new JoinResponse().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new JoinResponse().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new JoinResponse().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(JoinResponse, u, c);
  }
}
JoinResponse.runtime = proto3;
JoinResponse.typeName = "livekit.JoinResponse";
JoinResponse.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "room",
  kind: "message",
  T: Room$1
}, {
  no: 2,
  name: "participant",
  kind: "message",
  T: ParticipantInfo
}, {
  no: 3,
  name: "other_participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: !0
}, {
  no: 4,
  name: "server_version",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 5,
  name: "ice_servers",
  kind: "message",
  T: ICEServer,
  repeated: !0
}, {
  no: 6,
  name: "subscriber_primary",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 7,
  name: "alternative_url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 8,
  name: "client_configuration",
  kind: "message",
  T: ClientConfiguration
}, {
  no: 9,
  name: "server_region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 10,
  name: "ping_timeout",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 11,
  name: "ping_interval",
  kind: "scalar",
  T: 5
  /* ScalarType.INT32 */
}, {
  no: 12,
  name: "server_info",
  kind: "message",
  T: ServerInfo
}, {
  no: 13,
  name: "sif_trailer",
  kind: "scalar",
  T: 12
  /* ScalarType.BYTES */
}]);
class ReconnectResponse extends Message {
  constructor(u) {
    super(), this.iceServers = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ReconnectResponse().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ReconnectResponse().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ReconnectResponse().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ReconnectResponse, u, c);
  }
}
ReconnectResponse.runtime = proto3;
ReconnectResponse.typeName = "livekit.ReconnectResponse";
ReconnectResponse.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "ice_servers",
  kind: "message",
  T: ICEServer,
  repeated: !0
}, {
  no: 2,
  name: "client_configuration",
  kind: "message",
  T: ClientConfiguration
}]);
class TrackPublishedResponse extends Message {
  constructor(u) {
    super(), this.cid = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new TrackPublishedResponse().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new TrackPublishedResponse().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new TrackPublishedResponse().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(TrackPublishedResponse, u, c);
  }
}
TrackPublishedResponse.runtime = proto3;
TrackPublishedResponse.typeName = "livekit.TrackPublishedResponse";
TrackPublishedResponse.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "cid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track",
  kind: "message",
  T: TrackInfo
}]);
class TrackUnpublishedResponse extends Message {
  constructor(u) {
    super(), this.trackSid = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new TrackUnpublishedResponse().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new TrackUnpublishedResponse().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new TrackUnpublishedResponse().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(TrackUnpublishedResponse, u, c);
  }
}
TrackUnpublishedResponse.runtime = proto3;
TrackUnpublishedResponse.typeName = "livekit.TrackUnpublishedResponse";
TrackUnpublishedResponse.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class SessionDescription extends Message {
  constructor(u) {
    super(), this.type = "", this.sdp = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SessionDescription().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SessionDescription().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SessionDescription().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SessionDescription, u, c);
  }
}
SessionDescription.runtime = proto3;
SessionDescription.typeName = "livekit.SessionDescription";
SessionDescription.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "type",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "sdp",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class ParticipantUpdate extends Message {
  constructor(u) {
    super(), this.participants = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ParticipantUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ParticipantUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ParticipantUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ParticipantUpdate, u, c);
  }
}
ParticipantUpdate.runtime = proto3;
ParticipantUpdate.typeName = "livekit.ParticipantUpdate";
ParticipantUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participants",
  kind: "message",
  T: ParticipantInfo,
  repeated: !0
}]);
class UpdateSubscription extends Message {
  constructor(u) {
    super(), this.trackSids = [], this.subscribe = !1, this.participantTracks = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new UpdateSubscription().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new UpdateSubscription().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new UpdateSubscription().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(UpdateSubscription, u, c);
  }
}
UpdateSubscription.runtime = proto3;
UpdateSubscription.typeName = "livekit.UpdateSubscription";
UpdateSubscription.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "subscribe",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "participant_tracks",
  kind: "message",
  T: ParticipantTracks,
  repeated: !0
}]);
class UpdateTrackSettings extends Message {
  constructor(u) {
    super(), this.trackSids = [], this.disabled = !1, this.quality = VideoQuality$1.LOW, this.width = 0, this.height = 0, this.fps = 0, this.priority = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new UpdateTrackSettings().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new UpdateTrackSettings().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new UpdateTrackSettings().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(UpdateTrackSettings, u, c);
  }
}
UpdateTrackSettings.runtime = proto3;
UpdateTrackSettings.typeName = "livekit.UpdateTrackSettings";
UpdateTrackSettings.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 3,
  name: "disabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 4,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 5,
  name: "width",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 6,
  name: "height",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 7,
  name: "fps",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 8,
  name: "priority",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}]);
class LeaveRequest extends Message {
  constructor(u) {
    super(), this.canReconnect = !1, this.reason = DisconnectReason.UNKNOWN_REASON, this.action = LeaveRequest_Action.DISCONNECT, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new LeaveRequest().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new LeaveRequest().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new LeaveRequest().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(LeaveRequest, u, c);
  }
}
LeaveRequest.runtime = proto3;
LeaveRequest.typeName = "livekit.LeaveRequest";
LeaveRequest.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "can_reconnect",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "reason",
  kind: "enum",
  T: proto3.getEnumType(DisconnectReason)
}, {
  no: 3,
  name: "action",
  kind: "enum",
  T: proto3.getEnumType(LeaveRequest_Action)
}, {
  no: 4,
  name: "regions",
  kind: "message",
  T: RegionSettings
}]);
var LeaveRequest_Action;
(function(a) {
  a[a.DISCONNECT = 0] = "DISCONNECT", a[a.RESUME = 1] = "RESUME", a[a.RECONNECT = 2] = "RECONNECT";
})(LeaveRequest_Action || (LeaveRequest_Action = {}));
proto3.util.setEnumType(LeaveRequest_Action, "livekit.LeaveRequest.Action", [{
  no: 0,
  name: "DISCONNECT"
}, {
  no: 1,
  name: "RESUME"
}, {
  no: 2,
  name: "RECONNECT"
}]);
class UpdateVideoLayers extends Message {
  constructor(u) {
    super(), this.trackSid = "", this.layers = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new UpdateVideoLayers().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new UpdateVideoLayers().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new UpdateVideoLayers().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(UpdateVideoLayers, u, c);
  }
}
UpdateVideoLayers.runtime = proto3;
UpdateVideoLayers.typeName = "livekit.UpdateVideoLayers";
UpdateVideoLayers.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "layers",
  kind: "message",
  T: VideoLayer,
  repeated: !0
}]);
class UpdateParticipantMetadata extends Message {
  constructor(u) {
    super(), this.metadata = "", this.name = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new UpdateParticipantMetadata().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new UpdateParticipantMetadata().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new UpdateParticipantMetadata().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(UpdateParticipantMetadata, u, c);
  }
}
UpdateParticipantMetadata.runtime = proto3;
UpdateParticipantMetadata.typeName = "livekit.UpdateParticipantMetadata";
UpdateParticipantMetadata.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "metadata",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "name",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class ICEServer extends Message {
  constructor(u) {
    super(), this.urls = [], this.username = "", this.credential = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ICEServer().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ICEServer().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ICEServer().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ICEServer, u, c);
  }
}
ICEServer.runtime = proto3;
ICEServer.typeName = "livekit.ICEServer";
ICEServer.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "urls",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 2,
  name: "username",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "credential",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class SpeakersChanged extends Message {
  constructor(u) {
    super(), this.speakers = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SpeakersChanged().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SpeakersChanged().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SpeakersChanged().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SpeakersChanged, u, c);
  }
}
SpeakersChanged.runtime = proto3;
SpeakersChanged.typeName = "livekit.SpeakersChanged";
SpeakersChanged.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "speakers",
  kind: "message",
  T: SpeakerInfo,
  repeated: !0
}]);
class RoomUpdate extends Message {
  constructor(u) {
    super(), proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new RoomUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new RoomUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new RoomUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(RoomUpdate, u, c);
  }
}
RoomUpdate.runtime = proto3;
RoomUpdate.typeName = "livekit.RoomUpdate";
RoomUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "room",
  kind: "message",
  T: Room$1
}]);
class ConnectionQualityInfo extends Message {
  constructor(u) {
    super(), this.participantSid = "", this.quality = ConnectionQuality$1.POOR, this.score = 0, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ConnectionQualityInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ConnectionQualityInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ConnectionQualityInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ConnectionQualityInfo, u, c);
  }
}
ConnectionQualityInfo.runtime = proto3;
ConnectionQualityInfo.typeName = "livekit.ConnectionQualityInfo";
ConnectionQualityInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(ConnectionQuality$1)
}, {
  no: 3,
  name: "score",
  kind: "scalar",
  T: 2
  /* ScalarType.FLOAT */
}]);
class ConnectionQualityUpdate extends Message {
  constructor(u) {
    super(), this.updates = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new ConnectionQualityUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new ConnectionQualityUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new ConnectionQualityUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(ConnectionQualityUpdate, u, c);
  }
}
ConnectionQualityUpdate.runtime = proto3;
ConnectionQualityUpdate.typeName = "livekit.ConnectionQualityUpdate";
ConnectionQualityUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "updates",
  kind: "message",
  T: ConnectionQualityInfo,
  repeated: !0
}]);
class StreamStateInfo extends Message {
  constructor(u) {
    super(), this.participantSid = "", this.trackSid = "", this.state = StreamState.ACTIVE, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new StreamStateInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new StreamStateInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new StreamStateInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(StreamStateInfo, u, c);
  }
}
StreamStateInfo.runtime = proto3;
StreamStateInfo.typeName = "livekit.StreamStateInfo";
StreamStateInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "state",
  kind: "enum",
  T: proto3.getEnumType(StreamState)
}]);
class StreamStateUpdate extends Message {
  constructor(u) {
    super(), this.streamStates = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new StreamStateUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new StreamStateUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new StreamStateUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(StreamStateUpdate, u, c);
  }
}
StreamStateUpdate.runtime = proto3;
StreamStateUpdate.typeName = "livekit.StreamStateUpdate";
StreamStateUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "stream_states",
  kind: "message",
  T: StreamStateInfo,
  repeated: !0
}]);
class SubscribedQuality extends Message {
  constructor(u) {
    super(), this.quality = VideoQuality$1.LOW, this.enabled = !1, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SubscribedQuality().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SubscribedQuality().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SubscribedQuality().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SubscribedQuality, u, c);
  }
}
SubscribedQuality.runtime = proto3;
SubscribedQuality.typeName = "livekit.SubscribedQuality";
SubscribedQuality.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "quality",
  kind: "enum",
  T: proto3.getEnumType(VideoQuality$1)
}, {
  no: 2,
  name: "enabled",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
class SubscribedCodec extends Message {
  constructor(u) {
    super(), this.codec = "", this.qualities = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SubscribedCodec().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SubscribedCodec().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SubscribedCodec().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SubscribedCodec, u, c);
  }
}
SubscribedCodec.runtime = proto3;
SubscribedCodec.typeName = "livekit.SubscribedCodec";
SubscribedCodec.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "codec",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "qualities",
  kind: "message",
  T: SubscribedQuality,
  repeated: !0
}]);
class SubscribedQualityUpdate extends Message {
  constructor(u) {
    super(), this.trackSid = "", this.subscribedQualities = [], this.subscribedCodecs = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SubscribedQualityUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SubscribedQualityUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SubscribedQualityUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SubscribedQualityUpdate, u, c);
  }
}
SubscribedQualityUpdate.runtime = proto3;
SubscribedQualityUpdate.typeName = "livekit.SubscribedQualityUpdate";
SubscribedQualityUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "subscribed_qualities",
  kind: "message",
  T: SubscribedQuality,
  repeated: !0
}, {
  no: 3,
  name: "subscribed_codecs",
  kind: "message",
  T: SubscribedCodec,
  repeated: !0
}]);
class TrackPermission extends Message {
  constructor(u) {
    super(), this.participantSid = "", this.allTracks = !1, this.trackSids = [], this.participantIdentity = "", proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new TrackPermission().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new TrackPermission().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new TrackPermission().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(TrackPermission, u, c);
  }
}
TrackPermission.runtime = proto3;
TrackPermission.typeName = "livekit.TrackPermission";
TrackPermission.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "all_tracks",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 3,
  name: "track_sids",
  kind: "scalar",
  T: 9,
  repeated: !0
}, {
  no: 4,
  name: "participant_identity",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}]);
class SubscriptionPermission extends Message {
  constructor(u) {
    super(), this.allParticipants = !1, this.trackPermissions = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SubscriptionPermission().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SubscriptionPermission().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SubscriptionPermission().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SubscriptionPermission, u, c);
  }
}
SubscriptionPermission.runtime = proto3;
SubscriptionPermission.typeName = "livekit.SubscriptionPermission";
SubscriptionPermission.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "all_participants",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}, {
  no: 2,
  name: "track_permissions",
  kind: "message",
  T: TrackPermission,
  repeated: !0
}]);
class SubscriptionPermissionUpdate extends Message {
  constructor(u) {
    super(), this.participantSid = "", this.trackSid = "", this.allowed = !1, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SubscriptionPermissionUpdate().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SubscriptionPermissionUpdate().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SubscriptionPermissionUpdate().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SubscriptionPermissionUpdate, u, c);
  }
}
SubscriptionPermissionUpdate.runtime = proto3;
SubscriptionPermissionUpdate.typeName = "livekit.SubscriptionPermissionUpdate";
SubscriptionPermissionUpdate.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "participant_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "allowed",
  kind: "scalar",
  T: 8
  /* ScalarType.BOOL */
}]);
class SyncState extends Message {
  constructor(u) {
    super(), this.publishTracks = [], this.dataChannels = [], this.trackSidsDisabled = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SyncState().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SyncState().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SyncState().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SyncState, u, c);
  }
}
SyncState.runtime = proto3;
SyncState.typeName = "livekit.SyncState";
SyncState.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "answer",
  kind: "message",
  T: SessionDescription
}, {
  no: 2,
  name: "subscription",
  kind: "message",
  T: UpdateSubscription
}, {
  no: 3,
  name: "publish_tracks",
  kind: "message",
  T: TrackPublishedResponse,
  repeated: !0
}, {
  no: 4,
  name: "data_channels",
  kind: "message",
  T: DataChannelInfo,
  repeated: !0
}, {
  no: 5,
  name: "offer",
  kind: "message",
  T: SessionDescription
}, {
  no: 6,
  name: "track_sids_disabled",
  kind: "scalar",
  T: 9,
  repeated: !0
}]);
class DataChannelInfo extends Message {
  constructor(u) {
    super(), this.label = "", this.id = 0, this.target = SignalTarget.PUBLISHER, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new DataChannelInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new DataChannelInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new DataChannelInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(DataChannelInfo, u, c);
  }
}
DataChannelInfo.runtime = proto3;
DataChannelInfo.typeName = "livekit.DataChannelInfo";
DataChannelInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "label",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "id",
  kind: "scalar",
  T: 13
  /* ScalarType.UINT32 */
}, {
  no: 3,
  name: "target",
  kind: "enum",
  T: proto3.getEnumType(SignalTarget)
}]);
class SimulateScenario extends Message {
  constructor(u) {
    super(), this.scenario = {
      case: void 0
    }, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SimulateScenario().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SimulateScenario().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SimulateScenario().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SimulateScenario, u, c);
  }
}
SimulateScenario.runtime = proto3;
SimulateScenario.typeName = "livekit.SimulateScenario";
SimulateScenario.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "speaker_update",
  kind: "scalar",
  T: 5,
  oneof: "scenario"
}, {
  no: 2,
  name: "node_failure",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 3,
  name: "migration",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 4,
  name: "server_leave",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 5,
  name: "switch_candidate_protocol",
  kind: "enum",
  T: proto3.getEnumType(CandidateProtocol),
  oneof: "scenario"
}, {
  no: 6,
  name: "subscriber_bandwidth",
  kind: "scalar",
  T: 3,
  oneof: "scenario"
}, {
  no: 7,
  name: "disconnect_signal_on_resume",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}, {
  no: 8,
  name: "disconnect_signal_on_resume_no_messages",
  kind: "scalar",
  T: 8,
  oneof: "scenario"
}]);
class Ping extends Message {
  constructor(u) {
    super(), this.timestamp = protoInt64.zero, this.rtt = protoInt64.zero, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new Ping().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Ping().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Ping().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Ping, u, c);
  }
}
Ping.runtime = proto3;
Ping.typeName = "livekit.Ping";
Ping.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "rtt",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]);
class Pong extends Message {
  constructor(u) {
    super(), this.lastPingTimestamp = protoInt64.zero, this.timestamp = protoInt64.zero, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new Pong().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new Pong().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new Pong().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(Pong, u, c);
  }
}
Pong.runtime = proto3;
Pong.typeName = "livekit.Pong";
Pong.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "last_ping_timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}, {
  no: 2,
  name: "timestamp",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]);
class RegionSettings extends Message {
  constructor(u) {
    super(), this.regions = [], proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new RegionSettings().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new RegionSettings().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new RegionSettings().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(RegionSettings, u, c);
  }
}
RegionSettings.runtime = proto3;
RegionSettings.typeName = "livekit.RegionSettings";
RegionSettings.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "regions",
  kind: "message",
  T: RegionInfo,
  repeated: !0
}]);
class RegionInfo extends Message {
  constructor(u) {
    super(), this.region = "", this.url = "", this.distance = protoInt64.zero, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new RegionInfo().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new RegionInfo().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new RegionInfo().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(RegionInfo, u, c);
  }
}
RegionInfo.runtime = proto3;
RegionInfo.typeName = "livekit.RegionInfo";
RegionInfo.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "region",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "url",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 3,
  name: "distance",
  kind: "scalar",
  T: 3
  /* ScalarType.INT64 */
}]);
class SubscriptionResponse extends Message {
  constructor(u) {
    super(), this.trackSid = "", this.err = SubscriptionError.SE_UNKNOWN, proto3.util.initPartial(u, this);
  }
  static fromBinary(u, c) {
    return new SubscriptionResponse().fromBinary(u, c);
  }
  static fromJson(u, c) {
    return new SubscriptionResponse().fromJson(u, c);
  }
  static fromJsonString(u, c) {
    return new SubscriptionResponse().fromJsonString(u, c);
  }
  static equals(u, c) {
    return proto3.util.equals(SubscriptionResponse, u, c);
  }
}
SubscriptionResponse.runtime = proto3;
SubscriptionResponse.typeName = "livekit.SubscriptionResponse";
SubscriptionResponse.fields = proto3.util.newFieldList(() => [{
  no: 1,
  name: "track_sid",
  kind: "scalar",
  T: 9
  /* ScalarType.STRING */
}, {
  no: 2,
  name: "err",
  kind: "enum",
  T: proto3.getEnumType(SubscriptionError)
}]);
function cloneDeep(a) {
  if (!(typeof a > "u"))
    return typeof structuredClone == "function" ? structuredClone(a) : JSON.parse(JSON.stringify(a));
}
const BACKGROUND_REACTION_DELAY = 5e3, recycledElements = [];
var VideoQuality;
(function(a) {
  a[a.LOW = 0] = "LOW", a[a.MEDIUM = 1] = "MEDIUM", a[a.HIGH = 2] = "HIGH";
})(VideoQuality || (VideoQuality = {}));
class Track extends eventsExports.EventEmitter {
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var v;
    super(), this.attachedElements = [], this.isMuted = !1, this.streamState = Track.StreamState.Active, this.isInBackground = !1, this._currentBitrate = 0, this.log = livekitLogger, this.appVisibilityChangedListener = () => {
      this.backgroundTimeout && clearTimeout(this.backgroundTimeout), document.visibilityState === "hidden" ? this.backgroundTimeout = setTimeout(() => this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY) : this.handleAppVisibilityChanged();
    }, this.log = getLogger((v = l.loggerName) !== null && v !== void 0 ? v : LoggerNames.Track), this.loggerContextCb = l.loggerContextCb, this.setMaxListeners(100), this.kind = c, this._mediaStreamTrack = u, this._mediaStreamID = u.id, this.source = Track.Source.Unknown;
  }
  get logContext() {
    var u;
    return Object.assign(Object.assign({}, (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)), getLogContextFromTrack(this));
  }
  /** current receive bits per second */
  get currentBitrate() {
    return this._currentBitrate;
  }
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /**
   * @internal
   * used for keep mediaStream's first id, since it's id might change
   * if we disable/enable a track
   */
  get mediaStreamID() {
    return this._mediaStreamID;
  }
  attach(u) {
    let c = "audio";
    this.kind === Track.Kind.Video && (c = "video"), this.attachedElements.length === 0 && Track.Kind.Video && this.addAppVisibilityListener(), u || (c === "audio" && (recycledElements.forEach((S) => {
      S.parentElement === null && !u && (u = S);
    }), u && recycledElements.splice(recycledElements.indexOf(u), 1)), u || (u = document.createElement(c))), this.attachedElements.includes(u) || this.attachedElements.push(u), attachToElement(this.mediaStreamTrack, u);
    const l = u.srcObject.getTracks(), v = l.some((S) => S.kind === "audio");
    return u.play().then(() => {
      this.emit(v ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);
    }).catch((S) => {
      S.name === "NotAllowedError" ? this.emit(v ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, S) : S.name === "AbortError" ? livekitLogger.debug("".concat(v ? "audio" : "video", " playback aborted, likely due to new play request")) : livekitLogger.warn("could not playback ".concat(v ? "audio" : "video"), S), v && u && l.some((g) => g.kind === "video") && S.name === "NotAllowedError" && (u.muted = !0, u.play().catch(() => {
      }));
    }), this.emit(TrackEvent.ElementAttached, u), u;
  }
  detach(u) {
    try {
      if (u) {
        detachTrack(this.mediaStreamTrack, u);
        const l = this.attachedElements.indexOf(u);
        return l >= 0 && (this.attachedElements.splice(l, 1), this.recycleElement(u), this.emit(TrackEvent.ElementDetached, u)), u;
      }
      const c = [];
      return this.attachedElements.forEach((l) => {
        detachTrack(this.mediaStreamTrack, l), c.push(l), this.recycleElement(l), this.emit(TrackEvent.ElementDetached, l);
      }), this.attachedElements = [], c;
    } finally {
      this.attachedElements.length === 0 && this.removeAppVisibilityListener();
    }
  }
  stop() {
    this.stopMonitor(), this._mediaStreamTrack.stop();
  }
  enable() {
    this._mediaStreamTrack.enabled = !0;
  }
  disable() {
    this._mediaStreamTrack.enabled = !1;
  }
  /* @internal */
  stopMonitor() {
    this.monitorInterval && clearInterval(this.monitorInterval);
  }
  /** @internal */
  updateLoggerOptions(u) {
    u.loggerName && (this.log = getLogger(u.loggerName)), u.loggerContextCb && (this.loggerContextCb = u.loggerContextCb);
  }
  recycleElement(u) {
    if (u instanceof HTMLAudioElement) {
      let c = !0;
      u.pause(), recycledElements.forEach((l) => {
        l.parentElement || (c = !1);
      }), c && recycledElements.push(u);
    }
  }
  handleAppVisibilityChanged() {
    return __awaiter(this, void 0, void 0, function* () {
      this.isInBackground = document.visibilityState === "hidden";
    });
  }
  addAppVisibilityListener() {
    isWeb() ? (this.isInBackground = document.visibilityState === "hidden", document.addEventListener("visibilitychange", this.appVisibilityChangedListener)) : this.isInBackground = !1;
  }
  removeAppVisibilityListener() {
    isWeb() && document.removeEventListener("visibilitychange", this.appVisibilityChangedListener);
  }
}
function attachToElement(a, u) {
  let c;
  u.srcObject instanceof MediaStream ? c = u.srcObject : c = new MediaStream();
  let l;
  a.kind === "audio" ? l = c.getAudioTracks() : l = c.getVideoTracks(), l.includes(a) || (l.forEach((v) => {
    c.removeTrack(v);
  }), c.addTrack(a)), (!isSafari() || !(u instanceof HTMLVideoElement)) && (u.autoplay = !0), u.muted = c.getAudioTracks().length === 0, u instanceof HTMLVideoElement && (u.playsInline = !0), u.srcObject !== c && (u.srcObject = c, (isSafari() || isFireFox()) && u instanceof HTMLVideoElement && setTimeout(() => {
    u.srcObject = c, u.play().catch(() => {
    });
  }, 0));
}
function detachTrack(a, u) {
  if (u.srcObject instanceof MediaStream) {
    const c = u.srcObject;
    c.removeTrack(a), c.getTracks().length > 0 ? u.srcObject = c : u.srcObject = null;
  }
}
(function(a) {
  let u;
  (function(k) {
    k.Audio = "audio", k.Video = "video", k.Unknown = "unknown";
  })(u = a.Kind || (a.Kind = {}));
  let c;
  (function(k) {
    k.Camera = "camera", k.Microphone = "microphone", k.ScreenShare = "screen_share", k.ScreenShareAudio = "screen_share_audio", k.Unknown = "unknown";
  })(c = a.Source || (a.Source = {}));
  let l;
  (function(k) {
    k.Active = "active", k.Paused = "paused", k.Unknown = "unknown";
  })(l = a.StreamState || (a.StreamState = {}));
  function v(k) {
    switch (k) {
      case u.Audio:
        return TrackType.AUDIO;
      case u.Video:
        return TrackType.VIDEO;
      default:
        return TrackType.DATA;
    }
  }
  a.kindToProto = v;
  function S(k) {
    switch (k) {
      case TrackType.AUDIO:
        return u.Audio;
      case TrackType.VIDEO:
        return u.Video;
      default:
        return u.Unknown;
    }
  }
  a.kindFromProto = S;
  function g(k) {
    switch (k) {
      case c.Camera:
        return TrackSource.CAMERA;
      case c.Microphone:
        return TrackSource.MICROPHONE;
      case c.ScreenShare:
        return TrackSource.SCREEN_SHARE;
      case c.ScreenShareAudio:
        return TrackSource.SCREEN_SHARE_AUDIO;
      default:
        return TrackSource.UNKNOWN;
    }
  }
  a.sourceToProto = g;
  function E(k) {
    switch (k) {
      case TrackSource.CAMERA:
        return c.Camera;
      case TrackSource.MICROPHONE:
        return c.Microphone;
      case TrackSource.SCREEN_SHARE:
        return c.ScreenShare;
      case TrackSource.SCREEN_SHARE_AUDIO:
        return c.ScreenShareAudio;
      default:
        return c.Unknown;
    }
  }
  a.sourceFromProto = E;
  function _(k) {
    switch (k) {
      case StreamState.ACTIVE:
        return l.Active;
      case StreamState.PAUSED:
        return l.Paused;
      default:
        return l.Unknown;
    }
  }
  a.streamStateFromProto = _;
})(Track || (Track = {}));
function mergeDefaultOptions(a, u, c) {
  var l;
  const v = (l = cloneDeep(a)) !== null && l !== void 0 ? l : {};
  return v.audio === !0 && (v.audio = {}), v.video === !0 && (v.video = {}), v.audio && mergeObjectWithoutOverwriting(v.audio, u), v.video && mergeObjectWithoutOverwriting(v.video, c), v;
}
function mergeObjectWithoutOverwriting(a, u) {
  return Object.keys(u).forEach((c) => {
    a[c] === void 0 && (a[c] = u[c]);
  }), a;
}
function constraintsForOptions(a) {
  const u = {};
  if (a.video)
    if (typeof a.video == "object") {
      const c = {}, l = c, v = a.video;
      Object.keys(v).forEach((S) => {
        switch (S) {
          case "resolution":
            mergeObjectWithoutOverwriting(l, v.resolution);
            break;
          default:
            l[S] = v[S];
        }
      }), u.video = c;
    } else
      u.video = a.video;
  else
    u.video = !1;
  return a.audio ? typeof a.audio == "object" ? u.audio = a.audio : u.audio = !0 : u.audio = !1, u;
}
function detectSilence(a) {
  let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
  return __awaiter(this, void 0, void 0, function* () {
    const c = getNewAudioContext();
    if (c) {
      const l = c.createAnalyser();
      l.fftSize = 2048;
      const v = l.frequencyBinCount, S = new Uint8Array(v);
      c.createMediaStreamSource(new MediaStream([a.mediaStreamTrack])).connect(l), yield sleep(u), l.getByteTimeDomainData(S);
      const E = S.some((_) => _ !== 128 && _ !== 0);
      return c.close(), !E;
    }
    return !1;
  });
}
function getNewAudioContext() {
  const a = (
    // @ts-ignore
    typeof window < "u" && (window.AudioContext || window.webkitAudioContext)
  );
  if (a)
    return new a({
      latencyHint: "interactive"
    });
}
function sourceToKind(a) {
  return a === Track.Source.Microphone ? "audioinput" : a === Track.Source.Camera ? "videoinput" : void 0;
}
function screenCaptureToDisplayMediaStreamOptions(a) {
  var u, c;
  let l = (u = a.video) !== null && u !== void 0 ? u : !0;
  return a.resolution && a.resolution.width > 0 && a.resolution.height > 0 && (l = typeof l == "boolean" ? {} : l, isSafari() ? l = Object.assign(Object.assign({}, l), {
    width: {
      max: a.resolution.width
    },
    height: {
      max: a.resolution.height
    },
    frameRate: a.resolution.frameRate
  }) : l = Object.assign(Object.assign({}, l), {
    width: {
      ideal: a.resolution.width
    },
    height: {
      ideal: a.resolution.height
    },
    frameRate: a.resolution.frameRate
  })), {
    audio: (c = a.audio) !== null && c !== void 0 ? c : !1,
    video: l,
    // @ts-expect-error support for experimental display media features
    controller: a.controller,
    selfBrowserSurface: a.selfBrowserSurface,
    surfaceSwitching: a.surfaceSwitching,
    systemAudio: a.systemAudio
  };
}
function mimeTypeToVideoCodecString(a) {
  const u = a.split("/")[1].toLowerCase();
  if (!videoCodecs.includes(u))
    throw Error("Video codec not supported: ".concat(u));
  return u;
}
function getTrackPublicationInfo(a) {
  const u = [];
  return a.forEach((c) => {
    c.track !== void 0 && u.push(new TrackPublishedResponse({
      cid: c.track.mediaStreamID,
      track: c.trackInfo
    }));
  }), u;
}
function getLogContextFromTrack(a) {
  return a instanceof Track ? {
    trackSid: a.sid,
    trackSource: a.source,
    trackMuted: a.isMuted,
    trackEnabled: a.mediaStreamTrack.enabled,
    trackKind: a.kind
  } : {
    trackSid: a.trackSid,
    trackName: a.trackName,
    track: a.track ? getLogContextFromTrack(a.track) : void 0,
    trackEnabled: a.isEnabled,
    trackEncrypted: a.isEncrypted,
    trackMimeType: a.mimeType
  };
}
const separator = "|", ddExtensionURI = "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";
function unpackStreamId(a) {
  const u = a.split(separator);
  return u.length > 1 ? [u[0], a.substr(u[0].length + 1)] : [a, ""];
}
function sleep(a) {
  return __awaiter(this, void 0, void 0, function* () {
    return new Promise((u) => CriticalTimers.setTimeout(u, a));
  });
}
function supportsTransceiver() {
  return "addTransceiver" in RTCPeerConnection.prototype;
}
function supportsAddTrack() {
  return "addTrack" in RTCPeerConnection.prototype;
}
function supportsAV1() {
  if (!("getCapabilities" in RTCRtpSender) || isSafari())
    return !1;
  const a = RTCRtpSender.getCapabilities("video");
  let u = !1;
  if (a) {
    for (const c of a.codecs)
      if (c.mimeType === "video/AV1") {
        u = !0;
        break;
      }
  }
  return u;
}
function supportsVP9() {
  if (!("getCapabilities" in RTCRtpSender) || isFireFox())
    return !1;
  if (isSafari()) {
    const c = getBrowser();
    if (c != null && c.version && compareVersions(c.version, "16") < 0)
      return !1;
  }
  const a = RTCRtpSender.getCapabilities("video");
  let u = !1;
  if (a) {
    for (const c of a.codecs)
      if (c.mimeType === "video/VP9") {
        u = !0;
        break;
      }
  }
  return u;
}
function isSVCCodec(a) {
  return a === "av1" || a === "vp9";
}
function supportsSetSinkId(a) {
  return document ? (a || (a = document.createElement("audio")), "setSinkId" in a) : !1;
}
const setCodecPreferencesVersions = {
  Chrome: "100",
  Safari: "15",
  Firefox: "100"
};
function supportsSetCodecPreferences(a) {
  if (!isWeb() || !("setCodecPreferences" in a))
    return !1;
  const u = getBrowser();
  if (!(u != null && u.name) || !u.version)
    return !1;
  const c = setCodecPreferencesVersions[u.name];
  return c ? compareVersions(u.version, c) >= 0 : !1;
}
function isFireFox() {
  var a;
  return ((a = getBrowser()) === null || a === void 0 ? void 0 : a.name) === "Firefox";
}
function isSafari() {
  var a;
  return ((a = getBrowser()) === null || a === void 0 ? void 0 : a.name) === "Safari";
}
function isSafari17() {
  const a = getBrowser();
  return (a == null ? void 0 : a.name) === "Safari" && a.version.startsWith("17.");
}
function isMobile() {
  return isWeb() ? /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent) : !1;
}
function isWeb() {
  return typeof document < "u";
}
function isReactNative() {
  return navigator.product == "ReactNative";
}
function isCloud(a) {
  return a.hostname.endsWith(".livekit.cloud") || a.hostname.endsWith(".livekit.run");
}
function getLKReactNativeInfo() {
  if (global && global.LiveKitReactNativeGlobal)
    return global.LiveKitReactNativeGlobal;
}
function getReactNativeOs() {
  if (!isReactNative())
    return;
  let a = getLKReactNativeInfo();
  if (a)
    return a.platform;
}
function getDevicePixelRatio() {
  if (isWeb())
    return window.devicePixelRatio;
  if (isReactNative()) {
    let a = getLKReactNativeInfo();
    if (a)
      return a.devicePixelRatio;
  }
  return 1;
}
function compareVersions(a, u) {
  const c = a.split("."), l = u.split("."), v = Math.min(c.length, l.length);
  for (let S = 0; S < v; ++S) {
    const g = parseInt(c[S], 10), E = parseInt(l[S], 10);
    if (g > E)
      return 1;
    if (g < E)
      return -1;
    if (S === v - 1 && g === E)
      return 0;
  }
  return a === "" && u !== "" ? -1 : u === "" ? 1 : c.length == l.length ? 0 : c.length < l.length ? -1 : 1;
}
function roDispatchCallback(a) {
  for (const u of a)
    u.target.handleResize(u);
}
function ioDispatchCallback(a) {
  for (const u of a)
    u.target.handleVisibilityChanged(u);
}
let resizeObserver = null;
const getResizeObserver = () => (resizeObserver || (resizeObserver = new ResizeObserver(roDispatchCallback)), resizeObserver);
let intersectionObserver = null;
const getIntersectionObserver = () => (intersectionObserver || (intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
  root: null,
  rootMargin: "0px"
})), intersectionObserver);
function getClientInfo() {
  var a;
  const u = new ClientInfo({
    sdk: ClientInfo_SDK.JS,
    protocol: protocolVersion,
    version
  });
  return isReactNative() && (u.os = (a = getReactNativeOs()) !== null && a !== void 0 ? a : ""), u;
}
function createDummyVideoStreamTrack() {
  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16, c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  const v = document.createElement("canvas");
  v.width = a, v.height = u;
  const S = v.getContext("2d");
  S == null || S.fillRect(0, 0, v.width, v.height), l && S && (S.beginPath(), S.arc(a / 2, u / 2, 50, 0, Math.PI * 2, !0), S.closePath(), S.fillStyle = "grey", S.fill());
  const g = v.captureStream(), [E] = g.getTracks();
  if (!E)
    throw Error("Could not get empty media stream video track");
  return E.enabled = c, E;
}
let emptyAudioStreamTrack;
function getEmptyAudioStreamTrack() {
  if (!emptyAudioStreamTrack) {
    const a = new AudioContext(), u = a.createOscillator(), c = a.createGain();
    c.gain.setValueAtTime(0, 0);
    const l = a.createMediaStreamDestination();
    if (u.connect(c), c.connect(l), u.start(), [emptyAudioStreamTrack] = l.stream.getAudioTracks(), !emptyAudioStreamTrack)
      throw Error("Could not get empty media stream audio track");
    emptyAudioStreamTrack.enabled = !1;
  }
  return emptyAudioStreamTrack.clone();
}
class Future {
  constructor(u, c) {
    this.onFinally = c, this.promise = new Promise((l, v) => __awaiter(this, void 0, void 0, function* () {
      this.resolve = l, this.reject = v, u && (yield u(l, v));
    })).finally(() => {
      var l;
      return (l = this.onFinally) === null || l === void 0 ? void 0 : l.call(this);
    });
  }
}
class Mutex {
  constructor() {
    this._locking = Promise.resolve(), this._locks = 0;
  }
  isLocked() {
    return this._locks > 0;
  }
  lock() {
    this._locks += 1;
    let u;
    const c = new Promise((v) => u = () => {
      this._locks -= 1, v();
    }), l = this._locking.then(() => u);
    return this._locking = this._locking.then(() => c), l;
  }
}
function isVideoCodec(a) {
  return videoCodecs.includes(a);
}
function unwrapConstraint(a) {
  if (typeof a == "string")
    return a;
  if (Array.isArray(a))
    return a[0];
  if (a.exact)
    return Array.isArray(a.exact) ? a.exact[0] : a.exact;
  if (a.ideal)
    return Array.isArray(a.ideal) ? a.ideal[0] : a.ideal;
  throw Error("could not unwrap constraint");
}
function toWebsocketUrl(a) {
  return a.startsWith("http") ? a.replace(/^(http)/, "ws") : a;
}
function toHttpUrl(a) {
  return a.startsWith("ws") ? a.replace(/^(ws)/, "http") : a;
}
const defaultId = "default";
class DeviceManager {
  static getInstance() {
    return this.instance === void 0 && (this.instance = new DeviceManager()), this.instance;
  }
  getDevices(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    var l;
    return __awaiter(this, void 0, void 0, function* () {
      if (((l = DeviceManager.userMediaPromiseMap) === null || l === void 0 ? void 0 : l.size) > 0) {
        livekitLogger.debug("awaiting getUserMedia promise");
        try {
          u ? yield DeviceManager.userMediaPromiseMap.get(u) : yield Promise.all(DeviceManager.userMediaPromiseMap.values());
        } catch {
          livekitLogger.warn("error waiting for media permissons");
        }
      }
      let v = yield navigator.mediaDevices.enumerateDevices();
      if (c && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363
      !(isSafari() && this.hasDeviceInUse(u)) && (v.length === 0 || v.some((g) => {
        const E = g.label === "", _ = u ? g.kind === u : !0;
        return E && _;
      }))) {
        const g = {
          video: u !== "audioinput" && u !== "audiooutput",
          audio: u !== "videoinput"
        }, E = yield navigator.mediaDevices.getUserMedia(g);
        v = yield navigator.mediaDevices.enumerateDevices(), E.getTracks().forEach((_) => {
          _.stop();
        });
      }
      return u && (v = v.filter((S) => S.kind === u)), v;
    });
  }
  normalizeDeviceId(u, c, l) {
    return __awaiter(this, void 0, void 0, function* () {
      if (c !== defaultId)
        return c;
      const S = (yield this.getDevices(u)).find((g) => g.groupId === l && g.deviceId !== defaultId);
      return S == null ? void 0 : S.deviceId;
    });
  }
  hasDeviceInUse(u) {
    return u ? DeviceManager.userMediaPromiseMap.has(u) : DeviceManager.userMediaPromiseMap.size > 0;
  }
}
DeviceManager.mediaDeviceKinds = ["audioinput", "audiooutput", "videoinput"];
DeviceManager.userMediaPromiseMap = /* @__PURE__ */ new Map();
const defaultDimensionsTimeout = 1e3;
class LocalTrack extends Track {
  get constraints() {
    return this._constraints;
  }
  /**
   *
   * @param mediaTrack
   * @param kind
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c, l) {
    let v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, S = arguments.length > 4 ? arguments[4] : void 0;
    super(u, c, S), this._isUpstreamPaused = !1, this.handleTrackMuteEvent = () => this.debouncedTrackMuteHandler().catch(() => this.log.debug("track mute bounce got cancelled by an unmute event", this.logContext)), this.debouncedTrackMuteHandler = r(() => __awaiter(this, void 0, void 0, function* () {
      yield this.pauseUpstream();
    }), 5e3), this.handleTrackUnmuteEvent = () => __awaiter(this, void 0, void 0, function* () {
      this.debouncedTrackMuteHandler.cancel("unmute"), yield this.resumeUpstream();
    }), this.handleEnded = () => {
      this.isInBackground && (this.reacquireTrack = !0), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent), this.emit(TrackEvent.Ended, this);
    }, this.reacquireTrack = !1, this.providedByUser = v, this.muteLock = new Mutex(), this.pauseUpstreamLock = new Mutex(), this.processorLock = new Mutex(), this.setMediaStreamTrack(u, !0), this._constraints = u.getConstraints(), l && (this._constraints = l);
  }
  get id() {
    return this._mediaStreamTrack.id;
  }
  get dimensions() {
    if (this.kind !== Track.Kind.Video)
      return;
    const {
      width: u,
      height: c
    } = this._mediaStreamTrack.getSettings();
    if (u && c)
      return {
        width: u,
        height: c
      };
  }
  get isUpstreamPaused() {
    return this._isUpstreamPaused;
  }
  get isUserProvided() {
    return this.providedByUser;
  }
  get mediaStreamTrack() {
    var u, c;
    return (c = (u = this.processor) === null || u === void 0 ? void 0 : u.processedTrack) !== null && c !== void 0 ? c : this._mediaStreamTrack;
  }
  setMediaStreamTrack(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      if (u === this._mediaStreamTrack && !c)
        return;
      this._mediaStreamTrack && (this.attachedElements.forEach((v) => {
        detachTrack(this._mediaStreamTrack, v);
      }), this.debouncedTrackMuteHandler.cancel("new-track"), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent)), this.mediaStream = new MediaStream([u]), u && (u.addEventListener("ended", this.handleEnded), u.addEventListener("mute", this.handleTrackMuteEvent), u.addEventListener("unmute", this.handleTrackUnmuteEvent), this._constraints = u.getConstraints());
      let l;
      if (this.processor && u && this.processorElement) {
        if (this.log.debug("restarting processor", this.logContext), this.kind === "unknown")
          throw TypeError("cannot set processor on track of unknown kind");
        attachToElement(u, this.processorElement), this.processorElement.muted = !0, yield this.processor.restart({
          track: u,
          kind: this.kind,
          element: this.processorElement
        }), l = this.processor.processedTrack;
      }
      this.sender && (yield this.sender.replaceTrack(l ?? u)), !this.providedByUser && this._mediaStreamTrack !== u && this._mediaStreamTrack.stop(), this._mediaStreamTrack = u, u && (this._mediaStreamTrack.enabled = !this.isMuted, yield this.resumeUpstream(), this.attachedElements.forEach((v) => {
        attachToElement(l ?? u, v);
      }));
    });
  }
  waitForDimensions() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDimensionsTimeout;
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      if (this.kind === Track.Kind.Audio)
        throw new Error("cannot get dimensions for audio tracks");
      ((c = getBrowser()) === null || c === void 0 ? void 0 : c.os) === "iOS" && (yield sleep(10));
      const l = Date.now();
      for (; Date.now() - l < u; ) {
        const v = this.dimensions;
        if (v)
          return v;
        yield sleep(50);
      }
      throw new TrackInvalidError("unable to get track dimensions after timeout");
    });
  }
  /**
   * @returns DeviceID of the device that is currently being used for this track
   */
  getDeviceId() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.source === Track.Source.ScreenShare)
        return;
      const {
        deviceId: u,
        groupId: c
      } = this._mediaStreamTrack.getSettings(), l = this.kind === Track.Kind.Audio ? "audioinput" : "videoinput";
      return DeviceManager.getInstance().normalizeDeviceId(l, u, c);
    });
  }
  mute() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.setTrackMuted(!0), this;
    });
  }
  unmute() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.setTrackMuted(!1), this;
    });
  }
  replaceTrack(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.sender)
        throw new TrackInvalidError("unable to replace an unpublished track");
      return this.log.debug("replace MediaStreamTrack", this.logContext), yield this.setMediaStreamTrack(u), this.providedByUser = c, this.processor && (yield this.stopProcessor()), this;
    });
  }
  restart(u) {
    return __awaiter(this, void 0, void 0, function* () {
      u || (u = this._constraints), this.log.debug("restarting track with constraints", Object.assign(Object.assign({}, this.logContext), {
        constraints: u
      }));
      const c = {
        audio: !1,
        video: !1
      };
      this.kind === Track.Kind.Video ? c.video = u : c.audio = u, this.attachedElements.forEach((S) => {
        detachTrack(this.mediaStreamTrack, S);
      }), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.stop();
      const v = (yield navigator.mediaDevices.getUserMedia(c)).getTracks()[0];
      return v.addEventListener("ended", this.handleEnded), this.log.debug("re-acquired MediaStreamTrack", this.logContext), yield this.setMediaStreamTrack(v), this._constraints = u, this.emit(TrackEvent.Restarted, this), this;
    });
  }
  setTrackMuted(u) {
    this.log.debug("setting ".concat(this.kind, " track ").concat(u ? "muted" : "unmuted"), this.logContext), !(this.isMuted === u && this._mediaStreamTrack.enabled !== u) && (this.isMuted = u, this._mediaStreamTrack.enabled = !u, this.emit(u ? TrackEvent.Muted : TrackEvent.Unmuted, this));
  }
  get needsReAcquisition() {
    return this._mediaStreamTrack.readyState !== "live" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), isMobile() && (this.log.debug("visibility changed, is in Background: ".concat(this.isInBackground), this.logContext), !this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted && (this.log.debug("track needs to be reacquired, restarting ".concat(this.source), this.logContext), yield this.restart(), this.reacquireTrack = !1));
    });
  }
  stop() {
    var u;
    super.stop(), this._mediaStreamTrack.removeEventListener("ended", this.handleEnded), this._mediaStreamTrack.removeEventListener("mute", this.handleTrackMuteEvent), this._mediaStreamTrack.removeEventListener("unmute", this.handleTrackUnmuteEvent), (u = this.processor) === null || u === void 0 || u.destroy(), this.processor = void 0;
  }
  /**
   * pauses publishing to the server without disabling the local MediaStreamTrack
   * this is used to display a user's own video locally while pausing publishing to
   * the server.
   * this API is unsupported on Safari < 12 due to a bug
   **/
  pauseUpstream() {
    return __awaiter(this, void 0, void 0, function* () {
      const u = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !0)
          return;
        if (!this.sender) {
          this.log.warn("unable to pause upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = !0, this.emit(TrackEvent.UpstreamPaused, this);
        const c = getBrowser();
        if ((c == null ? void 0 : c.name) === "Safari" && compareVersions(c.version, "12.0") < 0)
          throw new DeviceUnsupportedError("pauseUpstream is not supported on Safari < 12.");
        yield this.sender.replaceTrack(null);
      } finally {
        u();
      }
    });
  }
  resumeUpstream() {
    return __awaiter(this, void 0, void 0, function* () {
      const u = yield this.pauseUpstreamLock.lock();
      try {
        if (this._isUpstreamPaused === !1)
          return;
        if (!this.sender) {
          this.log.warn("unable to resume upstream for an unpublished track", this.logContext);
          return;
        }
        this._isUpstreamPaused = !1, this.emit(TrackEvent.UpstreamResumed, this), yield this.sender.replaceTrack(this._mediaStreamTrack);
      } finally {
        u();
      }
    });
  }
  /**
   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      return !((u = this.sender) === null || u === void 0) && u.getStats ? yield this.sender.getStats() : void 0;
    });
  }
  /**
   * Sets a processor on this track.
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   *
   * @param processor
   * @param showProcessedStreamLocally
   * @returns
   */
  setProcessor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    var l, v;
    return __awaiter(this, void 0, void 0, function* () {
      const S = yield this.processorLock.lock();
      try {
        if (this.log.debug("setting up processor", this.logContext), this.processor && (yield this.stopProcessor()), this.kind === "unknown")
          throw TypeError("cannot set processor on track of unknown kind");
        this.processorElement = (l = this.processorElement) !== null && l !== void 0 ? l : document.createElement(this.kind), attachToElement(this._mediaStreamTrack, this.processorElement), this.processorElement.muted = !0, this.processorElement.play().catch((E) => this.log.error("failed to play processor element", Object.assign(Object.assign({}, this.logContext), {
          error: E
        })));
        const g = {
          kind: this.kind,
          track: this._mediaStreamTrack,
          element: this.processorElement
        };
        if (yield u.init(g), this.processor = u, this.processor.processedTrack) {
          for (const E of this.attachedElements)
            E !== this.processorElement && c && (detachTrack(this._mediaStreamTrack, E), attachToElement(this.processor.processedTrack, E));
          yield (v = this.sender) === null || v === void 0 ? void 0 : v.replaceTrack(this.processor.processedTrack);
        }
      } finally {
        S();
      }
    });
  }
  getProcessor() {
    return this.processor;
  }
  /**
   * Stops the track processor
   * See https://github.com/livekit/track-processors-js for example usage
   *
   * @experimental
   * @returns
   */
  stopProcessor() {
    var u, c;
    return __awaiter(this, void 0, void 0, function* () {
      this.processor && (this.log.debug("stopping processor", this.logContext), (u = this.processor.processedTrack) === null || u === void 0 || u.stop(), yield this.processor.destroy(), this.processor = void 0, (c = this.processorElement) === null || c === void 0 || c.remove(), this.processorElement = void 0, yield this.restart());
    });
  }
}
class E2EEManager extends eventsExports.EventEmitter {
  constructor(u) {
    super(), this.onWorkerMessage = (c) => {
      var l, v;
      const {
        kind: S,
        data: g
      } = c.data;
      switch (S) {
        case "error":
          livekitLogger.error(g.error.message), this.emit(EncryptionEvent.EncryptionError, g.error);
          break;
        case "initAck":
          g.enabled && this.keyProvider.getKeys().forEach((E) => {
            this.postKey(E);
          });
          break;
        case "enable":
          if (this.encryptionEnabled !== g.enabled && g.participantIdentity === ((l = this.room) === null || l === void 0 ? void 0 : l.localParticipant.identity))
            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, g.enabled, this.room.localParticipant), this.encryptionEnabled = g.enabled;
          else if (g.participantIdentity) {
            const E = (v = this.room) === null || v === void 0 ? void 0 : v.getParticipantByIdentity(g.participantIdentity);
            if (!E)
              throw TypeError("couldn't set encryption status, participant not found".concat(g.participantIdentity));
            this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, g.enabled, E);
          }
          this.encryptionEnabled && this.keyProvider.getKeys().forEach((E) => {
            this.postKey(E);
          });
          break;
        case "ratchetKey":
          this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, g.material, g.keyIndex);
          break;
      }
    }, this.onWorkerError = (c) => {
      livekitLogger.error("e2ee worker encountered an error:", {
        error: c.error
      }), this.emit(EncryptionEvent.EncryptionError, c.error);
    }, this.keyProvider = u.keyProvider, this.worker = u.worker, this.encryptionEnabled = !1;
  }
  /**
   * @internal
   */
  setup(u) {
    if (!isE2EESupported())
      throw new DeviceUnsupportedError("tried to setup end-to-end encryption on an unsupported browser");
    if (livekitLogger.info("setting up e2ee"), u !== this.room) {
      this.room = u, this.setupEventListeners(u, this.keyProvider);
      const c = {
        kind: "init",
        data: {
          keyProviderOptions: this.keyProvider.getOptions()
        }
      };
      this.worker && (livekitLogger.info("initializing worker", {
        worker: this.worker
      }), this.worker.onmessage = this.onWorkerMessage, this.worker.onerror = this.onWorkerError, this.worker.postMessage(c));
    }
  }
  /**
   * @internal
   */
  setParticipantCryptorEnabled(u, c) {
    livekitLogger.debug("set e2ee to ".concat(u, " for participant ").concat(c)), this.postEnable(u, c);
  }
  /**
   * @internal
   */
  setSifTrailer(u) {
    !u || u.length === 0 ? livekitLogger.warn("ignoring server sent trailer as it's empty") : this.postSifTrailer(u);
  }
  setupEngine(u) {
    u.on(EngineEvent.RTPVideoMapUpdate, (c) => {
      this.postRTPMap(c);
    });
  }
  setupEventListeners(u, c) {
    u.on(RoomEvent.TrackPublished, (l, v) => this.setParticipantCryptorEnabled(l.trackInfo.encryption !== Encryption_Type.NONE, v.identity)), u.on(RoomEvent.ConnectionStateChanged, (l) => {
      l === ConnectionState.Connected && u.remoteParticipants.forEach((v) => {
        v.trackPublications.forEach((S) => {
          this.setParticipantCryptorEnabled(S.trackInfo.encryption !== Encryption_Type.NONE, v.identity);
        });
      });
    }).on(RoomEvent.TrackUnsubscribed, (l, v, S) => {
      var g;
      const E = {
        kind: "removeTransform",
        data: {
          participantIdentity: S.identity,
          trackId: l.mediaStreamID
        }
      };
      (g = this.worker) === null || g === void 0 || g.postMessage(E);
    }).on(RoomEvent.TrackSubscribed, (l, v, S) => {
      this.setupE2EEReceiver(l, S.identity, v.trackInfo);
    }).on(RoomEvent.SignalConnected, () => {
      if (!this.room)
        throw new TypeError("expected room to be present on signal connect");
      this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity), c.getKeys().forEach((l) => {
        this.postKey(l);
      });
    }), u.localParticipant.on(ParticipantEvent.LocalTrackPublished, (l) => __awaiter(this, void 0, void 0, function* () {
      this.setupE2EESender(l.track, l.track.sender);
    })), c.on(KeyProviderEvent.SetKey, (l) => this.postKey(l)).on(KeyProviderEvent.RatchetRequest, (l, v) => this.postRatchetRequest(l, v));
  }
  postRatchetRequest(u, c) {
    if (!this.worker)
      throw Error("could not ratchet key, worker is missing");
    const l = {
      kind: "ratchetRequest",
      data: {
        participantIdentity: u,
        keyIndex: c
      }
    };
    this.worker.postMessage(l);
  }
  postKey(u) {
    let {
      key: c,
      participantIdentity: l,
      keyIndex: v
    } = u;
    var S;
    if (!this.worker)
      throw Error("could not set key, worker is missing");
    const g = {
      kind: "setKey",
      data: {
        participantIdentity: l,
        isPublisher: l === ((S = this.room) === null || S === void 0 ? void 0 : S.localParticipant.identity),
        key: c,
        keyIndex: v
      }
    };
    this.worker.postMessage(g);
  }
  postEnable(u, c) {
    if (this.worker) {
      const l = {
        kind: "enable",
        data: {
          enabled: u,
          participantIdentity: c
        }
      };
      this.worker.postMessage(l);
    } else
      throw new ReferenceError("failed to enable e2ee, worker is not ready");
  }
  postRTPMap(u) {
    var c;
    if (!this.worker)
      throw TypeError("could not post rtp map, worker is missing");
    if (!(!((c = this.room) === null || c === void 0) && c.localParticipant.identity))
      throw TypeError("could not post rtp map, local participant identity is missing");
    const l = {
      kind: "setRTPMap",
      data: {
        map: u,
        participantIdentity: this.room.localParticipant.identity
      }
    };
    this.worker.postMessage(l);
  }
  postSifTrailer(u) {
    if (!this.worker)
      throw Error("could not post SIF trailer, worker is missing");
    const c = {
      kind: "setSifTrailer",
      data: {
        trailer: u
      }
    };
    this.worker.postMessage(c);
  }
  setupE2EEReceiver(u, c, l) {
    if (u.receiver) {
      if (!(l != null && l.mimeType) || l.mimeType === "")
        throw new TypeError("MimeType missing from trackInfo, cannot set up E2EE cryptor");
      this.handleReceiver(u.receiver, u.mediaStreamID, c, u.kind === "video" ? mimeTypeToVideoCodecString(l.mimeType) : void 0);
    }
  }
  setupE2EESender(u, c) {
    if (!(u instanceof LocalTrack) || !c) {
      c || livekitLogger.warn("early return because sender is not ready");
      return;
    }
    this.handleSender(c, u.mediaStreamID, void 0);
  }
  /**
   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject
   * a frame decoder.
   *
   */
  handleReceiver(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.worker) {
        if (isScriptTransformSupported()) {
          const S = {
            kind: "decode",
            participantIdentity: l,
            trackId: c,
            codec: v
          };
          u.transform = new RTCRtpScriptTransform(this.worker, S);
        } else {
          if (E2EE_FLAG in u && v) {
            const _ = {
              kind: "updateCodec",
              data: {
                trackId: c,
                codec: v,
                participantIdentity: l
              }
            };
            this.worker.postMessage(_);
            return;
          }
          let S = u.writableStream, g = u.readableStream;
          if (!S || !g) {
            const _ = u.createEncodedStreams();
            u.writableStream = _.writable, S = _.writable, u.readableStream = _.readable, g = _.readable;
          }
          const E = {
            kind: "decode",
            data: {
              readableStream: g,
              writableStream: S,
              trackId: c,
              codec: v,
              participantIdentity: l
            }
          };
          this.worker.postMessage(E, [g, S]);
        }
        u[E2EE_FLAG] = !0;
      }
    });
  }
  /**
   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject
   * a frame encoder.
   *
   */
  handleSender(u, c, l) {
    var v;
    if (!(E2EE_FLAG in u || !this.worker)) {
      if (!(!((v = this.room) === null || v === void 0) && v.localParticipant.identity) || this.room.localParticipant.identity === "")
        throw TypeError("local identity needs to be known in order to set up encrypted sender");
      if (isScriptTransformSupported()) {
        livekitLogger.info("initialize script transform");
        const S = {
          kind: "encode",
          participantIdentity: this.room.localParticipant.identity,
          trackId: c,
          codec: l
        };
        u.transform = new RTCRtpScriptTransform(this.worker, S);
      } else {
        livekitLogger.info("initialize encoded streams");
        const S = u.createEncodedStreams(), g = {
          kind: "encode",
          data: {
            readableStream: S.readable,
            writableStream: S.writable,
            codec: l,
            trackId: c,
            participantIdentity: this.room.localParticipant.identity
          }
        };
        this.worker.postMessage(g, [S.readable, S.writable]);
      }
      u[E2EE_FLAG] = !0;
    }
  }
}
var QueueTaskStatus;
(function(a) {
  a[a.WAITING = 0] = "WAITING", a[a.RUNNING = 1] = "RUNNING", a[a.COMPLETED = 2] = "COMPLETED";
})(QueueTaskStatus || (QueueTaskStatus = {}));
class AsyncQueue {
  constructor() {
    this.pendingTasks = /* @__PURE__ */ new Map(), this.taskMutex = new Mutex(), this.nextTaskIndex = 0;
  }
  run(u) {
    return __awaiter(this, void 0, void 0, function* () {
      const c = {
        id: this.nextTaskIndex++,
        enqueuedAt: Date.now(),
        status: QueueTaskStatus.WAITING
      };
      this.pendingTasks.set(c.id, c);
      const l = yield this.taskMutex.lock();
      try {
        return c.executedAt = Date.now(), c.status = QueueTaskStatus.RUNNING, yield u();
      } finally {
        c.status = QueueTaskStatus.COMPLETED, this.pendingTasks.delete(c.id), l();
      }
    });
  }
  flush() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.run(() => __awaiter(this, void 0, void 0, function* () {
      }));
    });
  }
  snapshot() {
    return Array.from(this.pendingTasks.values());
  }
}
const passThroughQueueSignals = ["syncState", "trickle", "offer", "answer", "simulate", "leave"];
function canPassThroughQueue(a) {
  const u = passThroughQueueSignals.indexOf(a.case) >= 0;
  return livekitLogger.trace("request allowed to bypass queue:", {
    canPass: u,
    req: a
  }), u;
}
var SignalConnectionState;
(function(a) {
  a[a.CONNECTING = 0] = "CONNECTING", a[a.CONNECTED = 1] = "CONNECTED", a[a.RECONNECTING = 2] = "RECONNECTING", a[a.DISCONNECTING = 3] = "DISCONNECTING", a[a.DISCONNECTED = 4] = "DISCONNECTED";
})(SignalConnectionState || (SignalConnectionState = {}));
class SignalClient {
  get currentState() {
    return this.state;
  }
  get isDisconnected() {
    return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;
  }
  get isEstablishingConnection() {
    return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;
  }
  constructor() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var l;
    this.rtt = 0, this.state = SignalConnectionState.DISCONNECTED, this.log = livekitLogger, this.resetCallbacks = () => {
      this.onAnswer = void 0, this.onLeave = void 0, this.onLocalTrackPublished = void 0, this.onLocalTrackUnpublished = void 0, this.onNegotiateRequested = void 0, this.onOffer = void 0, this.onRemoteMuteChanged = void 0, this.onSubscribedQualityUpdate = void 0, this.onTokenRefresh = void 0, this.onTrickle = void 0, this.onClose = void 0;
    }, this.log = getLogger((l = c.loggerName) !== null && l !== void 0 ? l : LoggerNames.Signal), this.loggerContextCb = c.loggerContextCb, this.useJSON = u, this.requestQueue = new AsyncQueue(), this.queuedRequests = [], this.closingLock = new Mutex(), this.connectionLock = new Mutex(), this.state = SignalConnectionState.DISCONNECTED;
  }
  get logContext() {
    var u, c;
    return (c = (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)) !== null && c !== void 0 ? c : {};
  }
  join(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.state = SignalConnectionState.CONNECTING, this.options = l, yield this.connect(u, c, l, v);
    });
  }
  reconnect(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.options) {
        this.log.warn("attempted to reconnect without signal options being set, ignoring", this.logContext);
        return;
      }
      return this.state = SignalConnectionState.RECONNECTING, this.clearPingInterval(), yield this.connect(u, c, Object.assign(Object.assign({}, this.options), {
        reconnect: !0,
        sid: l,
        reconnectReason: v
      }));
    });
  }
  connect(u, c, l, v) {
    this.connectOptions = l, u = toWebsocketUrl(u), u = u.replace(/\/$/, ""), u += "/rtc";
    const S = getClientInfo(), g = createConnectionParams(c, S, l);
    return new Promise((E, _) => __awaiter(this, void 0, void 0, function* () {
      const k = yield this.connectionLock.lock();
      try {
        const L = () => __awaiter(this, void 0, void 0, function* () {
          this.close(), clearTimeout(M), _(new ConnectionError("room connection has been cancelled (signal)"));
        }), M = setTimeout(() => {
          this.close(), _(new ConnectionError("room connection has timed out (signal)"));
        }, l.websocketTimeout);
        v != null && v.aborted && L(), v == null || v.addEventListener("abort", L), this.log.debug("connecting to ".concat(u + g), this.logContext), this.ws && (yield this.close(!1)), this.ws = new WebSocket(u + g), this.ws.binaryType = "arraybuffer", this.ws.onopen = () => {
          clearTimeout(M);
        }, this.ws.onerror = ($) => __awaiter(this, void 0, void 0, function* () {
          if (this.state !== SignalConnectionState.CONNECTED) {
            clearTimeout(M);
            try {
              const J = yield fetch("http".concat(u.substring(2), "/validate").concat(g));
              if (J.status.toFixed(0).startsWith("4")) {
                const V = yield J.text();
                _(new ConnectionError(V, 0, J.status));
              } else
                _(new ConnectionError("Internal error", 2, J.status));
            } catch {
              _(new ConnectionError(
                "server was not reachable",
                1
                /* ConnectionErrorReason.ServerUnreachable */
              ));
            }
            return;
          }
          this.handleWSError($);
        }), this.ws.onmessage = ($) => __awaiter(this, void 0, void 0, function* () {
          var J, V, q, G;
          let H;
          if (typeof $.data == "string") {
            const B = JSON.parse($.data);
            H = SignalResponse.fromJson(B);
          } else if ($.data instanceof ArrayBuffer)
            H = SignalResponse.fromBinary(new Uint8Array($.data));
          else {
            this.log.error("could not decode websocket message: ".concat(typeof $.data), this.logContext);
            return;
          }
          if (this.state !== SignalConnectionState.CONNECTED) {
            let B = !1;
            if (((J = H.message) === null || J === void 0 ? void 0 : J.case) === "join" ? (this.state = SignalConnectionState.CONNECTED, v == null || v.removeEventListener("abort", L), this.pingTimeoutDuration = H.message.value.pingTimeout, this.pingIntervalDuration = H.message.value.pingInterval, this.pingTimeoutDuration && this.pingTimeoutDuration > 0 && (this.log.debug("ping config", Object.assign(Object.assign({}, this.logContext), {
              timeout: this.pingTimeoutDuration,
              interval: this.pingIntervalDuration
            })), this.startPingInterval()), E(H.message.value)) : this.state === SignalConnectionState.RECONNECTING && H.message.case !== "leave" ? (this.state = SignalConnectionState.CONNECTED, v == null || v.removeEventListener("abort", L), this.startPingInterval(), ((V = H.message) === null || V === void 0 ? void 0 : V.case) === "reconnect" ? E((q = H.message) === null || q === void 0 ? void 0 : q.value) : (E(), B = !0)) : this.isEstablishingConnection && H.message.case === "leave" ? _(new ConnectionError(
              "Received leave request while trying to (re)connect",
              4
              /* ConnectionErrorReason.LeaveRequest */
            )) : l.reconnect || _(new ConnectionError("did not receive join response, got ".concat((G = H.message) === null || G === void 0 ? void 0 : G.case, " instead"))), !B)
              return;
          }
          this.signalLatency && (yield sleep(this.signalLatency)), this.handleSignalResponse(H);
        }), this.ws.onclose = ($) => {
          this.isEstablishingConnection && _(new ConnectionError("Websocket got closed during a (re)connection attempt")), this.log.warn("websocket closed", Object.assign(Object.assign({}, this.logContext), {
            reason: $.reason,
            code: $.code,
            wasClean: $.wasClean,
            state: this.state
          })), this.handleOnClose($.reason);
        };
      } finally {
        k();
      }
    }));
  }
  close() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield this.closingLock.lock();
      try {
        if (u && (this.state = SignalConnectionState.DISCONNECTING), this.ws) {
          this.ws.onmessage = null, this.ws.onopen = null, this.ws.onclose = null;
          const l = new Promise((v) => {
            this.ws ? this.ws.onclose = () => {
              v();
            } : v();
          });
          this.ws.readyState < this.ws.CLOSING && (this.ws.close(), yield Promise.race([l, sleep(250)])), this.ws = void 0;
        }
      } finally {
        u && (this.state = SignalConnectionState.DISCONNECTED), this.clearPingInterval(), c();
      }
    });
  }
  // initial offer after joining
  sendOffer(u) {
    this.log.debug("sending offer", Object.assign(Object.assign({}, this.logContext), {
      offerSdp: u.sdp
    })), this.sendRequest({
      case: "offer",
      value: toProtoSessionDescription(u)
    });
  }
  // answer a server-initiated offer
  sendAnswer(u) {
    return this.log.debug("sending answer", Object.assign(Object.assign({}, this.logContext), {
      answerSdp: u.sdp
    })), this.sendRequest({
      case: "answer",
      value: toProtoSessionDescription(u)
    });
  }
  sendIceCandidate(u, c) {
    return this.log.trace("sending ice candidate", Object.assign(Object.assign({}, this.logContext), {
      candidate: u
    })), this.sendRequest({
      case: "trickle",
      value: new TrickleRequest({
        candidateInit: JSON.stringify(u),
        target: c
      })
    });
  }
  sendMuteTrack(u, c) {
    return this.sendRequest({
      case: "mute",
      value: new MuteTrackRequest({
        sid: u,
        muted: c
      })
    });
  }
  sendAddTrack(u) {
    return this.sendRequest({
      case: "addTrack",
      value: u
    });
  }
  sendUpdateLocalMetadata(u, c) {
    return this.sendRequest({
      case: "updateMetadata",
      value: new UpdateParticipantMetadata({
        metadata: u,
        name: c
      })
    });
  }
  sendUpdateTrackSettings(u) {
    this.sendRequest({
      case: "trackSetting",
      value: u
    });
  }
  sendUpdateSubscription(u) {
    return this.sendRequest({
      case: "subscription",
      value: u
    });
  }
  sendSyncState(u) {
    return this.sendRequest({
      case: "syncState",
      value: u
    });
  }
  sendUpdateVideoLayers(u, c) {
    return this.sendRequest({
      case: "updateLayers",
      value: new UpdateVideoLayers({
        trackSid: u,
        layers: c
      })
    });
  }
  sendUpdateSubscriptionPermissions(u, c) {
    return this.sendRequest({
      case: "subscriptionPermission",
      value: new SubscriptionPermission({
        allParticipants: u,
        trackPermissions: c
      })
    });
  }
  sendSimulateScenario(u) {
    return this.sendRequest({
      case: "simulate",
      value: u
    });
  }
  sendPing() {
    return Promise.all([this.sendRequest({
      case: "ping",
      value: protoInt64.parse(Date.now())
    }), this.sendRequest({
      case: "pingReq",
      value: new Ping({
        timestamp: protoInt64.parse(Date.now()),
        rtt: protoInt64.parse(this.rtt)
      })
    })]);
  }
  sendLeave() {
    return this.sendRequest({
      case: "leave",
      value: new LeaveRequest({
        canReconnect: !1,
        reason: DisconnectReason.CLIENT_INITIATED
      })
    });
  }
  sendRequest(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    return __awaiter(this, void 0, void 0, function* () {
      if (!c && !canPassThroughQueue(u) && this.state === SignalConnectionState.RECONNECTING) {
        this.queuedRequests.push(() => __awaiter(this, void 0, void 0, function* () {
          yield this.sendRequest(u, !0);
        }));
        return;
      }
      if (c || (yield this.requestQueue.flush()), this.signalLatency && (yield sleep(this.signalLatency)), !this.ws || this.ws.readyState !== this.ws.OPEN) {
        this.log.error("cannot send signal request before connected, type: ".concat(u == null ? void 0 : u.case), this.logContext);
        return;
      }
      const v = new SignalRequest({
        message: u
      });
      try {
        this.useJSON ? this.ws.send(v.toJsonString()) : this.ws.send(v.toBinary());
      } catch (S) {
        this.log.error("error sending signal message", Object.assign(Object.assign({}, this.logContext), {
          error: S
        }));
      }
    });
  }
  handleSignalResponse(u) {
    var c, l;
    const v = u.message;
    if (v == null) {
      this.log.debug("received unsupported message", this.logContext);
      return;
    }
    let S = !1;
    if (v.case === "answer") {
      const g = fromProtoSessionDescription(v.value);
      this.onAnswer && this.onAnswer(g);
    } else if (v.case === "offer") {
      const g = fromProtoSessionDescription(v.value);
      this.onOffer && this.onOffer(g);
    } else if (v.case === "trickle") {
      const g = JSON.parse(v.value.candidateInit);
      this.onTrickle && this.onTrickle(g, v.value.target);
    } else
      v.case === "update" ? this.onParticipantUpdate && this.onParticipantUpdate((c = v.value.participants) !== null && c !== void 0 ? c : []) : v.case === "trackPublished" ? this.onLocalTrackPublished && this.onLocalTrackPublished(v.value) : v.case === "speakersChanged" ? this.onSpeakersChanged && this.onSpeakersChanged((l = v.value.speakers) !== null && l !== void 0 ? l : []) : v.case === "leave" ? this.onLeave && this.onLeave(v.value) : v.case === "mute" ? this.onRemoteMuteChanged && this.onRemoteMuteChanged(v.value.sid, v.value.muted) : v.case === "roomUpdate" ? this.onRoomUpdate && v.value.room && this.onRoomUpdate(v.value.room) : v.case === "connectionQuality" ? this.onConnectionQuality && this.onConnectionQuality(v.value) : v.case === "streamStateUpdate" ? this.onStreamStateUpdate && this.onStreamStateUpdate(v.value) : v.case === "subscribedQualityUpdate" ? this.onSubscribedQualityUpdate && this.onSubscribedQualityUpdate(v.value) : v.case === "subscriptionPermissionUpdate" ? this.onSubscriptionPermissionUpdate && this.onSubscriptionPermissionUpdate(v.value) : v.case === "refreshToken" ? this.onTokenRefresh && this.onTokenRefresh(v.value) : v.case === "trackUnpublished" ? this.onLocalTrackUnpublished && this.onLocalTrackUnpublished(v.value) : v.case === "subscriptionResponse" ? this.onSubscriptionError && this.onSubscriptionError(v.value) : v.case === "pong" || (v.case === "pongResp" ? (this.rtt = Date.now() - Number.parseInt(v.value.lastPingTimestamp.toString()), this.resetPingTimeout(), S = !0) : this.log.debug("unsupported message", Object.assign(Object.assign({}, this.logContext), {
        msgCase: v.case
      })));
    S || this.resetPingTimeout();
  }
  setReconnected() {
    for (; this.queuedRequests.length > 0; ) {
      const u = this.queuedRequests.shift();
      u && this.requestQueue.run(u);
    }
  }
  handleOnClose(u) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.state === SignalConnectionState.DISCONNECTED)
        return;
      const c = this.onClose;
      yield this.close(), this.log.debug("websocket connection closed: ".concat(u), Object.assign(Object.assign({}, this.logContext), {
        reason: u
      })), c && c(u);
    });
  }
  handleWSError(u) {
    this.log.error("websocket error", Object.assign(Object.assign({}, this.logContext), {
      error: u
    }));
  }
  /**
   * Resets the ping timeout and starts a new timeout.
   * Call this after receiving a pong message
   */
  resetPingTimeout() {
    if (this.clearPingTimeout(), !this.pingTimeoutDuration) {
      this.log.warn("ping timeout duration not set", this.logContext);
      return;
    }
    this.pingTimeout = CriticalTimers.setTimeout(() => {
      this.log.warn("ping timeout triggered. last pong received at: ".concat(new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()), this.logContext), this.handleOnClose("ping timeout");
    }, this.pingTimeoutDuration * 1e3);
  }
  /**
   * Clears ping timeout (does not start a new timeout)
   */
  clearPingTimeout() {
    this.pingTimeout && CriticalTimers.clearTimeout(this.pingTimeout);
  }
  startPingInterval() {
    if (this.clearPingInterval(), this.resetPingTimeout(), !this.pingIntervalDuration) {
      this.log.warn("ping interval duration not set", this.logContext);
      return;
    }
    this.log.debug("start ping interval", this.logContext), this.pingInterval = CriticalTimers.setInterval(() => {
      this.sendPing();
    }, this.pingIntervalDuration * 1e3);
  }
  clearPingInterval() {
    this.log.debug("clearing ping interval", this.logContext), this.clearPingTimeout(), this.pingInterval && CriticalTimers.clearInterval(this.pingInterval);
  }
}
function fromProtoSessionDescription(a) {
  const u = {
    type: "offer",
    sdp: a.sdp
  };
  switch (a.type) {
    case "answer":
    case "offer":
    case "pranswer":
    case "rollback":
      u.type = a.type;
      break;
  }
  return u;
}
function toProtoSessionDescription(a) {
  return new SessionDescription({
    sdp: a.sdp,
    type: a.type
  });
}
function createConnectionParams(a, u, c) {
  var l;
  const v = new URLSearchParams();
  return v.set("access_token", a), c.reconnect && (v.set("reconnect", "1"), c.sid && v.set("sid", c.sid)), v.set("auto_subscribe", c.autoSubscribe ? "1" : "0"), v.set("sdk", isReactNative() ? "reactnative" : "js"), v.set("version", u.version), v.set("protocol", u.protocol.toString()), u.deviceModel && v.set("device_model", u.deviceModel), u.os && v.set("os", u.os), u.osVersion && v.set("os_version", u.osVersion), u.browser && v.set("browser", u.browser), u.browserVersion && v.set("browser_version", u.browserVersion), c.adaptiveStream && v.set("adaptive_stream", "1"), c.reconnectReason && v.set("reconnect_reason", c.reconnectReason.toString()), !((l = navigator.connection) === null || l === void 0) && l.type && v.set("network", navigator.connection.type), "?".concat(v.toString());
}
var parser$1 = {}, grammar$2 = { exports: {} }, grammar$1 = grammar$2.exports = {
  v: [{
    name: "version",
    reg: /^(\d*)$/
  }],
  o: [{
    // o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: "origin",
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
    format: "%s %s %d %s IP%d %s"
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{
    name: "name"
  }],
  i: [{
    name: "description"
  }],
  u: [{
    name: "uri"
  }],
  e: [{
    name: "email"
  }],
  p: [{
    name: "phone"
  }],
  z: [{
    name: "timezones"
  }],
  // TODO: this one can actually be parsed properly...
  r: [{
    name: "repeats"
  }],
  // TODO: this one can also be parsed properly
  // k: [{}], // outdated thing ignored
  t: [{
    // t=0 0
    name: "timing",
    reg: /^(\d*) (\d*)/,
    names: ["start", "stop"],
    format: "%d %d"
  }],
  c: [{
    // c=IN IP4 10.47.197.26
    name: "connection",
    reg: /^IN IP(\d) (\S*)/,
    names: ["version", "ip"],
    format: "IN IP%d %s"
  }],
  b: [{
    // b=AS:4000
    push: "bandwidth",
    reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
    names: ["type", "limit"],
    format: "%s:%s"
  }],
  m: [{
    // m=video 51744 RTP/AVP 126 97 98 34 31
    // NB: special - pushes to session
    // TODO: rtp/fmtp should be filtered by the payloads found here?
    reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
    names: ["type", "port", "protocol", "payloads"],
    format: "%s %d %s %s"
  }],
  a: [
    {
      // a=rtpmap:110 opus/48000/2
      push: "rtp",
      reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
      names: ["payload", "codec", "rate", "encoding"],
      format: function(a) {
        return a.encoding ? "rtpmap:%d %s/%s/%s" : a.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
      }
    },
    {
      // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      // a=fmtp:111 minptime=10; useinbandfec=1
      push: "fmtp",
      reg: /^fmtp:(\d*) ([\S| ]*)/,
      names: ["payload", "config"],
      format: "fmtp:%d %s"
    },
    {
      // a=control:streamid=0
      name: "control",
      reg: /^control:(.*)/,
      format: "control:%s"
    },
    {
      // a=rtcp:65179 IN IP4 193.84.77.194
      name: "rtcp",
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ["port", "netType", "ipVer", "address"],
      format: function(a) {
        return a.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
      }
    },
    {
      // a=rtcp-fb:98 trr-int 100
      push: "rtcpFbTrrInt",
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ["payload", "value"],
      format: "rtcp-fb:%s trr-int %d"
    },
    {
      // a=rtcp-fb:98 nack rpsi
      push: "rtcpFb",
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ["payload", "type", "subtype"],
      format: function(a) {
        return a.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
      }
    },
    {
      // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      // a=extmap:1/recvonly URI-gps-string
      // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
      push: "ext",
      reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
      names: ["value", "direction", "encrypt-uri", "uri", "config"],
      format: function(a) {
        return "extmap:%d" + (a.direction ? "/%s" : "%v") + (a["encrypt-uri"] ? " %s" : "%v") + " %s" + (a.config ? " %s" : "");
      }
    },
    {
      // a=extmap-allow-mixed
      name: "extmapAllowMixed",
      reg: /^(extmap-allow-mixed)/
    },
    {
      // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: "crypto",
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ["id", "suite", "config", "sessionConfig"],
      format: function(a) {
        return a.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
      }
    },
    {
      // a=setup:actpass
      name: "setup",
      reg: /^setup:(\w*)/,
      format: "setup:%s"
    },
    {
      // a=connection:new
      name: "connectionType",
      reg: /^connection:(new|existing)/,
      format: "connection:%s"
    },
    {
      // a=mid:1
      name: "mid",
      reg: /^mid:([^\s]*)/,
      format: "mid:%s"
    },
    {
      // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
      name: "msid",
      reg: /^msid:(.*)/,
      format: "msid:%s"
    },
    {
      // a=ptime:20
      name: "ptime",
      reg: /^ptime:(\d*(?:\.\d*)*)/,
      format: "ptime:%d"
    },
    {
      // a=maxptime:60
      name: "maxptime",
      reg: /^maxptime:(\d*(?:\.\d*)*)/,
      format: "maxptime:%d"
    },
    {
      // a=sendrecv
      name: "direction",
      reg: /^(sendrecv|recvonly|sendonly|inactive)/
    },
    {
      // a=ice-lite
      name: "icelite",
      reg: /^(ice-lite)/
    },
    {
      // a=ice-ufrag:F7gI
      name: "iceUfrag",
      reg: /^ice-ufrag:(\S*)/,
      format: "ice-ufrag:%s"
    },
    {
      // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: "icePwd",
      reg: /^ice-pwd:(\S*)/,
      format: "ice-pwd:%s"
    },
    {
      // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: "fingerprint",
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ["type", "hash"],
      format: "fingerprint:%s %s"
    },
    {
      // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
      // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
      // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
      push: "candidates",
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
      names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
      format: function(a) {
        var u = "candidate:%s %d %s %d %s %d typ %s";
        return u += a.raddr != null ? " raddr %s rport %d" : "%v%v", u += a.tcptype != null ? " tcptype %s" : "%v", a.generation != null && (u += " generation %d"), u += a["network-id"] != null ? " network-id %d" : "%v", u += a["network-cost"] != null ? " network-cost %d" : "%v", u;
      }
    },
    {
      // a=end-of-candidates (keep after the candidates line for readability)
      name: "endOfCandidates",
      reg: /^(end-of-candidates)/
    },
    {
      // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: "remoteCandidates",
      reg: /^remote-candidates:(.*)/,
      format: "remote-candidates:%s"
    },
    {
      // a=ice-options:google-ice
      name: "iceOptions",
      reg: /^ice-options:(\S*)/,
      format: "ice-options:%s"
    },
    {
      // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: "ssrcs",
      reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
      names: ["id", "attribute", "value"],
      format: function(a) {
        var u = "ssrc:%d";
        return a.attribute != null && (u += " %s", a.value != null && (u += ":%s")), u;
      }
    },
    {
      // a=ssrc-group:FEC 1 2
      // a=ssrc-group:FEC-FR 3004364195 1080772241
      push: "ssrcGroups",
      // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
      reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
      names: ["semantics", "ssrcs"],
      format: "ssrc-group:%s %s"
    },
    {
      // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: "msidSemantic",
      reg: /^msid-semantic:\s?(\w*) (\S*)/,
      names: ["semantic", "token"],
      format: "msid-semantic: %s %s"
      // space after ':' is not accidental
    },
    {
      // a=group:BUNDLE audio video
      push: "groups",
      reg: /^group:(\w*) (.*)/,
      names: ["type", "mids"],
      format: "group:%s %s"
    },
    {
      // a=rtcp-mux
      name: "rtcpMux",
      reg: /^(rtcp-mux)/
    },
    {
      // a=rtcp-rsize
      name: "rtcpRsize",
      reg: /^(rtcp-rsize)/
    },
    {
      // a=sctpmap:5000 webrtc-datachannel 1024
      name: "sctpmap",
      reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
      names: ["sctpmapNumber", "app", "maxMessageSize"],
      format: function(a) {
        return a.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
      }
    },
    {
      // a=x-google-flag:conference
      name: "xGoogleFlag",
      reg: /^x-google-flag:([^\s]*)/,
      format: "x-google-flag:%s"
    },
    {
      // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
      push: "rids",
      reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
      names: ["id", "direction", "params"],
      format: function(a) {
        return a.params ? "rid:%s %s %s" : "rid:%s %s";
      }
    },
    {
      // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
      // a=imageattr:* send [x=800,y=640] recv *
      // a=imageattr:100 recv [x=320,y=240]
      push: "imageattrs",
      reg: new RegExp(
        // a=imageattr:97
        "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
      ),
      names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
      format: function(a) {
        return "imageattr:%s %s %s" + (a.dir2 ? " %s %s" : "");
      }
    },
    {
      // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
      // a=simulcast:recv 1;4,5 send 6;7
      name: "simulcast",
      reg: new RegExp(
        // a=simulcast:
        "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
      ),
      names: ["dir1", "list1", "dir2", "list2"],
      format: function(a) {
        return "simulcast:%s %s" + (a.dir2 ? " %s %s" : "");
      }
    },
    {
      // old simulcast draft 03 (implemented by Firefox)
      //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
      // a=simulcast: recv pt=97;98 send pt=97
      // a=simulcast: send rid=5;6;7 paused=6,7
      name: "simulcast_03",
      reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
      names: ["value"],
      format: "simulcast: %s"
    },
    {
      // a=framerate:25
      // a=framerate:29.97
      name: "framerate",
      reg: /^framerate:(\d+(?:$|\.\d+))/,
      format: "framerate:%s"
    },
    {
      // RFC4570
      // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
      name: "sourceFilter",
      reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
      names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
      format: "source-filter: %s %s %s %s %s"
    },
    {
      // a=bundle-only
      name: "bundleOnly",
      reg: /^(bundle-only)/
    },
    {
      // a=label:1
      name: "label",
      reg: /^label:(.+)/,
      format: "label:%s"
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
      name: "sctpPort",
      reg: /^sctp-port:(\d+)$/,
      format: "sctp-port:%s"
    },
    {
      // RFC version 26 for SCTP over DTLS
      // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
      name: "maxMessageSize",
      reg: /^max-message-size:(\d+)$/,
      format: "max-message-size:%s"
    },
    {
      // RFC7273
      // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
      push: "tsRefClocks",
      reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
      names: ["clksrc", "clksrcExt"],
      format: function(a) {
        return "ts-refclk:%s" + (a.clksrcExt != null ? "=%s" : "");
      }
    },
    {
      // RFC7273
      // a=mediaclk:direct=963214424
      name: "mediaClk",
      reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
      names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
      format: function(a) {
        var u = "mediaclk:";
        return u += a.id != null ? "id=%s %s" : "%v%s", u += a.mediaClockValue != null ? "=%s" : "", u += a.rateNumerator != null ? " rate=%s" : "", u += a.rateDenominator != null ? "/%s" : "", u;
      }
    },
    {
      // a=keywds:keywords
      name: "keywords",
      reg: /^keywds:(.+)$/,
      format: "keywds:%s"
    },
    {
      // a=content:main
      name: "content",
      reg: /^content:(.+)/,
      format: "content:%s"
    },
    // BFCP https://tools.ietf.org/html/rfc4583
    {
      // a=floorctrl:c-s
      name: "bfcpFloorCtrl",
      reg: /^floorctrl:(c-only|s-only|c-s)/,
      format: "floorctrl:%s"
    },
    {
      // a=confid:1
      name: "bfcpConfId",
      reg: /^confid:(\d+)/,
      format: "confid:%s"
    },
    {
      // a=userid:1
      name: "bfcpUserId",
      reg: /^userid:(\d+)/,
      format: "userid:%s"
    },
    {
      // a=floorid:1
      name: "bfcpFloorId",
      reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
      names: ["id", "mStream"],
      format: "floorid:%s mstrm:%s"
    },
    {
      // any a= that we don't understand is kept verbatim on media.invalid
      push: "invalid",
      names: ["value"]
    }
  ]
};
Object.keys(grammar$1).forEach(function(a) {
  var u = grammar$1[a];
  u.forEach(function(c) {
    c.reg || (c.reg = /(.*)/), c.format || (c.format = "%s");
  });
});
var grammarExports = grammar$2.exports;
(function(a) {
  var u = function(E) {
    return String(Number(E)) === E ? Number(E) : E;
  }, c = function(E, _, k, L) {
    if (L && !k)
      _[L] = u(E[1]);
    else
      for (var M = 0; M < k.length; M += 1)
        E[M + 1] != null && (_[k[M]] = u(E[M + 1]));
  }, l = function(E, _, k) {
    var L = E.name && E.names;
    E.push && !_[E.push] ? _[E.push] = [] : L && !_[E.name] && (_[E.name] = {});
    var M = E.push ? {} : (
      // blank object that will be pushed
      L ? _[E.name] : _
    );
    c(k.match(E.reg), M, E.names, E.name), E.push && _[E.push].push(M);
  }, v = grammarExports, S = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
  a.parse = function(E) {
    var _ = {}, k = [], L = _;
    return E.split(/(\r\n|\r|\n)/).filter(S).forEach(function(M) {
      var $ = M[0], J = M.slice(2);
      $ === "m" && (k.push({
        rtp: [],
        fmtp: []
      }), L = k[k.length - 1]);
      for (var V = 0; V < (v[$] || []).length; V += 1) {
        var q = v[$][V];
        if (q.reg.test(J))
          return l(q, L, J);
      }
    }), _.media = k, _;
  };
  var g = function(E, _) {
    var k = _.split(/=(.+)/, 2);
    return k.length === 2 ? E[k[0]] = u(k[1]) : k.length === 1 && _.length > 1 && (E[k[0]] = void 0), E;
  };
  a.parseParams = function(E) {
    return E.split(/;\s?/).reduce(g, {});
  }, a.parseFmtpConfig = a.parseParams, a.parsePayloads = function(E) {
    return E.toString().split(" ").map(Number);
  }, a.parseRemoteCandidates = function(E) {
    for (var _ = [], k = E.split(" ").map(u), L = 0; L < k.length; L += 3)
      _.push({
        component: k[L],
        ip: k[L + 1],
        port: k[L + 2]
      });
    return _;
  }, a.parseImageAttributes = function(E) {
    return E.split(" ").map(function(_) {
      return _.substring(1, _.length - 1).split(",").reduce(g, {});
    });
  }, a.parseSimulcastStreamList = function(E) {
    return E.split(";").map(function(_) {
      return _.split(",").map(function(k) {
        var L, M = !1;
        return k[0] !== "~" ? L = u(k) : (L = u(k.substring(1, k.length)), M = !0), {
          scid: L,
          paused: M
        };
      });
    });
  };
})(parser$1);
var grammar = grammarExports, formatRegExp = /%[sdv%]/g, format = function(a) {
  var u = 1, c = arguments, l = c.length;
  return a.replace(formatRegExp, function(v) {
    if (u >= l)
      return v;
    var S = c[u];
    switch (u += 1, v) {
      case "%%":
        return "%";
      case "%s":
        return String(S);
      case "%d":
        return Number(S);
      case "%v":
        return "";
    }
  });
}, makeLine = function(a, u, c) {
  var l = u.format instanceof Function ? u.format(u.push ? c : c[u.name]) : u.format, v = [a + "=" + l];
  if (u.names)
    for (var S = 0; S < u.names.length; S += 1) {
      var g = u.names[S];
      u.name ? v.push(c[u.name][g]) : v.push(c[u.names[S]]);
    }
  else
    v.push(c[u.name]);
  return format.apply(null, v);
}, defaultOuterOrder = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"], defaultInnerOrder = ["i", "c", "b", "a"], writer$1 = function(a, u) {
  u = u || {}, a.version == null && (a.version = 0), a.name == null && (a.name = " "), a.media.forEach(function(S) {
    S.payloads == null && (S.payloads = "");
  });
  var c = u.outerOrder || defaultOuterOrder, l = u.innerOrder || defaultInnerOrder, v = [];
  return c.forEach(function(S) {
    grammar[S].forEach(function(g) {
      g.name in a && a[g.name] != null ? v.push(makeLine(S, g, a)) : g.push in a && a[g.push] != null && a[g.push].forEach(function(E) {
        v.push(makeLine(S, g, E));
      });
    });
  }), a.media.forEach(function(S) {
    v.push(makeLine("m", grammar.m[0], S)), l.forEach(function(g) {
      grammar[g].forEach(function(E) {
        E.name in S && S[E.name] != null ? v.push(makeLine(g, E, S)) : E.push in S && S[E.push] != null && S[E.push].forEach(function(_) {
          v.push(makeLine(g, E, _));
        });
      });
    });
  }), v.join(`\r
`) + `\r
`;
}, parser = parser$1, writer = writer$1, write = writer, parse$1 = parser.parse;
const startBitrateForSVC = 0.7, PCEvents = {
  NegotiationStarted: "negotiationStarted",
  NegotiationComplete: "negotiationComplete",
  RTPVideoPayloadTypes: "rtpVideoPayloadTypes"
};
class PCTransport extends eventsExports.EventEmitter {
  get pc() {
    return this._pc || (this._pc = this.createPC()), this._pc;
  }
  constructor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var l;
    super(), this.log = livekitLogger, this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate = !1, this.trackBitrates = [], this.remoteStereoMids = [], this.remoteNackMids = [], this.negotiate = r((v) => __awaiter(this, void 0, void 0, function* () {
      this.emit(PCEvents.NegotiationStarted);
      try {
        yield this.createAndSendOffer();
      } catch (S) {
        if (v)
          v(S);
        else
          throw S;
      }
    }), 100), this.close = () => {
      this._pc && (this._pc.close(), this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.ondatachannel = null, this._pc.onnegotiationneeded = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ondatachannel = null, this._pc.ontrack = null, this._pc.onconnectionstatechange = null, this._pc.oniceconnectionstatechange = null, this._pc = null);
    }, this.log = getLogger((l = c.loggerName) !== null && l !== void 0 ? l : LoggerNames.PCTransport), this.loggerOptions = c, this.config = u, this._pc = this.createPC();
  }
  createPC() {
    const u = new RTCPeerConnection(this.config);
    return u.onicecandidate = (c) => {
      var l;
      c.candidate && ((l = this.onIceCandidate) === null || l === void 0 || l.call(this, c.candidate));
    }, u.onicecandidateerror = (c) => {
      var l;
      (l = this.onIceCandidateError) === null || l === void 0 || l.call(this, c);
    }, u.oniceconnectionstatechange = () => {
      var c;
      (c = this.onIceConnectionStateChange) === null || c === void 0 || c.call(this, u.iceConnectionState);
    }, u.onsignalingstatechange = () => {
      var c;
      (c = this.onSignalingStatechange) === null || c === void 0 || c.call(this, u.signalingState);
    }, u.onconnectionstatechange = () => {
      var c;
      (c = this.onConnectionStateChange) === null || c === void 0 || c.call(this, u.connectionState);
    }, u.ondatachannel = (c) => {
      var l;
      (l = this.onDataChannel) === null || l === void 0 || l.call(this, c);
    }, u.ontrack = (c) => {
      var l;
      (l = this.onTrack) === null || l === void 0 || l.call(this, c);
    }, u;
  }
  get logContext() {
    var u, c;
    return Object.assign({}, (c = (u = this.loggerOptions).loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));
  }
  get isICEConnected() {
    return this._pc !== null && (this.pc.iceConnectionState === "connected" || this.pc.iceConnectionState === "completed");
  }
  addIceCandidate(u) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.pc.remoteDescription && !this.restartingIce)
        return this.pc.addIceCandidate(u);
      this.pendingCandidates.push(u);
    });
  }
  setRemoteDescription(u) {
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      let l;
      if (u.type === "offer") {
        let {
          stereoMids: v,
          nackMids: S
        } = extractStereoAndNackAudioFromOffer(u);
        this.remoteStereoMids = v, this.remoteNackMids = S;
      } else if (u.type === "answer") {
        const v = parse$1((c = u.sdp) !== null && c !== void 0 ? c : "");
        v.media.forEach((S) => {
          S.type === "audio" && this.trackBitrates.some((g) => {
            if (!g.transceiver || S.mid != g.transceiver.mid)
              return !1;
            let E = 0;
            if (S.rtp.some((k) => k.codec.toUpperCase() === g.codec.toUpperCase() ? (E = k.payload, !0) : !1), E === 0)
              return !0;
            let _ = !1;
            for (const k of S.fmtp)
              if (k.payload === E) {
                k.config = k.config.split(";").filter((L) => !L.includes("maxaveragebitrate")).join(";"), g.maxbr > 0 && (k.config += ";maxaveragebitrate=".concat(g.maxbr * 1e3)), _ = !0;
                break;
              }
            return _ || g.maxbr > 0 && S.fmtp.push({
              payload: E,
              config: "maxaveragebitrate=".concat(g.maxbr * 1e3)
            }), !0;
          });
        }), l = write(v);
      }
      yield this.setMungedSDP(u, l, !0), this.pendingCandidates.forEach((v) => {
        this.pc.addIceCandidate(v);
      }), this.pendingCandidates = [], this.restartingIce = !1, this.renegotiate ? (this.renegotiate = !1, yield this.createAndSendOffer()) : u.type === "answer" && (this.emit(PCEvents.NegotiationComplete), u.sdp && parse$1(u.sdp).media.forEach((S) => {
        S.type === "video" && this.emit(PCEvents.RTPVideoPayloadTypes, S.rtp);
      }));
    });
  }
  createAndSendOffer(u) {
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      if (this.onOffer === void 0)
        return;
      if (u != null && u.iceRestart && (this.log.debug("restarting ICE", this.logContext), this.restartingIce = !0), this._pc && this._pc.signalingState === "have-local-offer") {
        const S = this._pc.remoteDescription;
        if (u != null && u.iceRestart && S)
          yield this._pc.setRemoteDescription(S);
        else {
          this.renegotiate = !0;
          return;
        }
      } else if (!this._pc || this._pc.signalingState === "closed") {
        this.log.warn("could not createOffer with closed peer connection", this.logContext);
        return;
      }
      this.log.debug("starting to negotiate", this.logContext);
      const l = yield this.pc.createOffer(u), v = parse$1((c = l.sdp) !== null && c !== void 0 ? c : "");
      v.media.forEach((S) => {
        S.type === "audio" ? ensureAudioNackAndStereo(S, [], []) : S.type === "video" && (ensureVideoDDExtensionForSVC(S), this.trackBitrates.some((g) => {
          if (!S.msid || !g.cid || !S.msid.includes(g.cid))
            return !1;
          let E = 0;
          if (S.rtp.some((k) => k.codec.toUpperCase() === g.codec.toUpperCase() ? (E = k.payload, !0) : !1), E === 0)
            return !0;
          let _ = !1;
          for (const k of S.fmtp)
            if (k.payload === E) {
              k.config.includes("x-google-start-bitrate") || (k.config += ";x-google-start-bitrate=".concat(Math.round(g.maxbr * startBitrateForSVC))), k.config.includes("x-google-max-bitrate") || (k.config += ";x-google-max-bitrate=".concat(g.maxbr)), _ = !0;
              break;
            }
          return _ || S.fmtp.push({
            payload: E,
            config: "x-google-start-bitrate=".concat(Math.round(g.maxbr * startBitrateForSVC), ";x-google-max-bitrate=").concat(g.maxbr)
          }), !0;
        }));
      }), yield this.setMungedSDP(l, write(v)), this.onOffer(l);
    });
  }
  createAndSetAnswer() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield this.pc.createAnswer(), l = parse$1((u = c.sdp) !== null && u !== void 0 ? u : "");
      return l.media.forEach((v) => {
        v.type === "audio" && ensureAudioNackAndStereo(v, this.remoteStereoMids, this.remoteNackMids);
      }), yield this.setMungedSDP(c, write(l)), c;
    });
  }
  createDataChannel(u, c) {
    return this.pc.createDataChannel(u, c);
  }
  addTransceiver(u, c) {
    return this.pc.addTransceiver(u, c);
  }
  addTrack(u) {
    if (!this._pc)
      throw new UnexpectedConnectionState("PC closed, cannot add track");
    return this._pc.addTrack(u);
  }
  setTrackCodecBitrate(u) {
    this.trackBitrates.push(u);
  }
  setConfiguration(u) {
    var c;
    if (!this._pc)
      throw new UnexpectedConnectionState("PC closed, cannot configure");
    return (c = this._pc) === null || c === void 0 ? void 0 : c.setConfiguration(u);
  }
  canRemoveTrack() {
    var u;
    return !!(!((u = this._pc) === null || u === void 0) && u.removeTrack);
  }
  removeTrack(u) {
    var c;
    return (c = this._pc) === null || c === void 0 ? void 0 : c.removeTrack(u);
  }
  getConnectionState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.connectionState) !== null && c !== void 0 ? c : "closed";
  }
  getICEConnectionState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.iceConnectionState) !== null && c !== void 0 ? c : "closed";
  }
  getSignallingState() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.signalingState) !== null && c !== void 0 ? c : "closed";
  }
  getTransceivers() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.getTransceivers()) !== null && c !== void 0 ? c : [];
  }
  getSenders() {
    var u, c;
    return (c = (u = this._pc) === null || u === void 0 ? void 0 : u.getSenders()) !== null && c !== void 0 ? c : [];
  }
  getLocalDescription() {
    var u;
    return (u = this._pc) === null || u === void 0 ? void 0 : u.localDescription;
  }
  getRemoteDescription() {
    var u;
    return (u = this.pc) === null || u === void 0 ? void 0 : u.remoteDescription;
  }
  getStats() {
    return this.pc.getStats();
  }
  getConnectedAddress() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      if (!this._pc)
        return;
      let c = "";
      const l = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map();
      if ((yield this._pc.getStats()).forEach((E) => {
        switch (E.type) {
          case "transport":
            c = E.selectedCandidatePairId;
            break;
          case "candidate-pair":
            c === "" && E.selected && (c = E.id), l.set(E.id, E);
            break;
          case "remote-candidate":
            v.set(E.id, "".concat(E.address, ":").concat(E.port));
            break;
        }
      }), c === "")
        return;
      const g = (u = l.get(c)) === null || u === void 0 ? void 0 : u.remoteCandidateId;
      if (g !== void 0)
        return v.get(g);
    });
  }
  setMungedSDP(u, c, l) {
    return __awaiter(this, void 0, void 0, function* () {
      if (c) {
        const v = u.sdp;
        u.sdp = c;
        try {
          this.log.debug("setting munged ".concat(l ? "remote" : "local", " description"), this.logContext), l ? yield this.pc.setRemoteDescription(u) : yield this.pc.setLocalDescription(u);
          return;
        } catch (S) {
          this.log.warn("not able to set ".concat(u.type, ", falling back to unmodified sdp"), Object.assign(Object.assign({}, this.logContext), {
            error: S,
            sdp: c
          })), u.sdp = v;
        }
      }
      try {
        l ? yield this.pc.setRemoteDescription(u) : yield this.pc.setLocalDescription(u);
      } catch (v) {
        let S = "unknown error";
        v instanceof Error ? S = v.message : typeof v == "string" && (S = v);
        const g = {
          error: S,
          sdp: u.sdp
        };
        throw !l && this.pc.remoteDescription && (g.remoteSdp = this.pc.remoteDescription), this.log.error("unable to set ".concat(u.type), Object.assign(Object.assign({}, this.logContext), {
          fields: g
        })), new NegotiationError(S);
      }
    });
  }
}
function ensureAudioNackAndStereo(a, u, c) {
  let l = 0;
  a.rtp.some((v) => v.codec === "opus" ? (l = v.payload, !0) : !1), l > 0 && (a.rtcpFb || (a.rtcpFb = []), c.includes(a.mid) && !a.rtcpFb.some((v) => v.payload === l && v.type === "nack") && a.rtcpFb.push({
    payload: l,
    type: "nack"
  }), u.includes(a.mid) && a.fmtp.some((v) => v.payload === l ? (v.config.includes("stereo=1") || (v.config += ";stereo=1"), !0) : !1));
}
function ensureVideoDDExtensionForSVC(a) {
  var u, c, l, v;
  const S = (c = (u = a.rtp[0]) === null || u === void 0 ? void 0 : u.codec) === null || c === void 0 ? void 0 : c.toLowerCase();
  if (!isSVCCodec(S))
    return;
  let g = 0;
  ((l = a.ext) === null || l === void 0 ? void 0 : l.some((_) => _.uri === ddExtensionURI ? !0 : (_.value > g && (g = _.value), !1))) || (v = a.ext) === null || v === void 0 || v.push({
    value: g + 1,
    uri: ddExtensionURI
  });
}
function extractStereoAndNackAudioFromOffer(a) {
  var u;
  const c = [], l = [], v = parse$1((u = a.sdp) !== null && u !== void 0 ? u : "");
  let S = 0;
  return v.media.forEach((g) => {
    var E;
    g.type === "audio" && (g.rtp.some((_) => _.codec === "opus" ? (S = _.payload, !0) : !1), !((E = g.rtcpFb) === null || E === void 0) && E.some((_) => _.payload === S && _.type === "nack") && l.push(g.mid), g.fmtp.some((_) => _.payload === S ? (_.config.includes("sprop-stereo=1") && c.push(g.mid), !0) : !1));
  }), {
    stereoMids: c,
    nackMids: l
  };
}
const defaultVideoCodec = "vp8", publishDefaults = {
  audioPreset: AudioPresets.music,
  dtx: !0,
  red: !0,
  forceStereo: !1,
  simulcast: !0,
  screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
  stopMicTrackOnMute: !1,
  videoCodec: defaultVideoCodec,
  backupCodec: !0
}, audioDefaults = {
  autoGainControl: !0,
  echoCancellation: !0,
  noiseSuppression: !0
}, videoDefaults = {
  resolution: VideoPresets.h720.resolution
}, roomOptionDefaults = {
  adaptiveStream: !1,
  dynacast: !1,
  stopLocalTrackOnUnpublish: !0,
  reconnectPolicy: new DefaultReconnectPolicy(),
  disconnectOnPageLeave: !0,
  webAudioMix: !0
}, roomConnectOptionDefaults = {
  autoSubscribe: !0,
  maxRetries: 1,
  peerConnectionTimeout: 15e3,
  websocketTimeout: 15e3
};
var PCTransportState;
(function(a) {
  a[a.NEW = 0] = "NEW", a[a.CONNECTING = 1] = "CONNECTING", a[a.CONNECTED = 2] = "CONNECTED", a[a.FAILED = 3] = "FAILED", a[a.CLOSING = 4] = "CLOSING", a[a.CLOSED = 5] = "CLOSED";
})(PCTransportState || (PCTransportState = {}));
class PCTransportManager {
  get needsPublisher() {
    return this.isPublisherConnectionRequired;
  }
  get needsSubscriber() {
    return this.isSubscriberConnectionRequired;
  }
  get currentState() {
    return this.state;
  }
  constructor(u, c, l) {
    var v;
    this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout, this.log = livekitLogger, this.updateState = () => {
      var S;
      const g = this.state, E = this.requiredTransports.map((_) => _.getConnectionState());
      E.every((_) => _ === "connected") ? this.state = PCTransportState.CONNECTED : E.some((_) => _ === "failed") ? this.state = PCTransportState.FAILED : E.some((_) => _ === "connecting") ? this.state = PCTransportState.CONNECTING : E.every((_) => _ === "closed") ? this.state = PCTransportState.CLOSED : E.some((_) => _ === "closed") ? this.state = PCTransportState.CLOSING : E.every((_) => _ === "new") && (this.state = PCTransportState.NEW), g !== this.state && (this.log.debug("pc state change: from ".concat(PCTransportState[g], " to ").concat(PCTransportState[this.state]), this.logContext), (S = this.onStateChange) === null || S === void 0 || S.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState()));
    }, this.log = getLogger((v = l.loggerName) !== null && v !== void 0 ? v : LoggerNames.PCManager), this.loggerOptions = l, this.isPublisherConnectionRequired = !c, this.isSubscriberConnectionRequired = c, this.publisher = new PCTransport(u, l), this.subscriber = new PCTransport(u, l), this.publisher.onConnectionStateChange = this.updateState, this.subscriber.onConnectionStateChange = this.updateState, this.publisher.onIceConnectionStateChange = this.updateState, this.subscriber.onIceConnectionStateChange = this.updateState, this.publisher.onSignalingStatechange = this.updateState, this.subscriber.onSignalingStatechange = this.updateState, this.publisher.onIceCandidate = (S) => {
      var g;
      (g = this.onIceCandidate) === null || g === void 0 || g.call(this, S, SignalTarget.PUBLISHER);
    }, this.subscriber.onIceCandidate = (S) => {
      var g;
      (g = this.onIceCandidate) === null || g === void 0 || g.call(this, S, SignalTarget.SUBSCRIBER);
    }, this.subscriber.onDataChannel = (S) => {
      var g;
      (g = this.onDataChannel) === null || g === void 0 || g.call(this, S);
    }, this.subscriber.onTrack = (S) => {
      var g;
      (g = this.onTrack) === null || g === void 0 || g.call(this, S);
    }, this.publisher.onOffer = (S) => {
      var g;
      (g = this.onPublisherOffer) === null || g === void 0 || g.call(this, S);
    }, this.state = PCTransportState.NEW, this.connectionLock = new Mutex();
  }
  get logContext() {
    var u, c;
    return Object.assign({}, (c = (u = this.loggerOptions).loggerContextCb) === null || c === void 0 ? void 0 : c.call(u));
  }
  requirePublisher() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.isPublisherConnectionRequired = u, this.updateState();
  }
  requireSubscriber() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    this.isSubscriberConnectionRequired = u, this.updateState();
  }
  createAndSendPublisherOffer(u) {
    return this.publisher.createAndSendOffer(u);
  }
  setPublisherAnswer(u) {
    return this.publisher.setRemoteDescription(u);
  }
  removeTrack(u) {
    return this.publisher.removeTrack(u);
  }
  close() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.publisher && this.publisher.getSignallingState() !== "closed") {
        const u = this.publisher;
        for (const c of u.getSenders())
          try {
            u.canRemoveTrack() && u.removeTrack(c);
          } catch (l) {
            this.log.warn("could not removeTrack", Object.assign(Object.assign({}, this.logContext), {
              error: l
            }));
          }
      }
      yield Promise.all([this.publisher.close(), this.subscriber.close()]), this.updateState();
    });
  }
  triggerIceRestart() {
    return __awaiter(this, void 0, void 0, function* () {
      this.subscriber.restartingIce = !0, this.needsPublisher && (yield this.createAndSendPublisherOffer({
        iceRestart: !0
      }));
    });
  }
  addIceCandidate(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      c === SignalTarget.PUBLISHER ? yield this.publisher.addIceCandidate(u) : yield this.subscriber.addIceCandidate(u);
    });
  }
  createSubscriberAnswerFromOffer(u) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.log.debug("received server offer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: u.type,
        sdp: u.sdp,
        signalingState: this.subscriber.getSignallingState().toString()
      })), yield this.subscriber.setRemoteDescription(u), yield this.subscriber.createAndSetAnswer();
    });
  }
  updateConfiguration(u, c) {
    this.publisher.setConfiguration(u), this.subscriber.setConfiguration(u), c && this.triggerIceRestart();
  }
  ensurePCTransportConnection(u, c) {
    var l;
    return __awaiter(this, void 0, void 0, function* () {
      const v = yield this.connectionLock.lock();
      try {
        this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== "connected" && this.publisher.getConnectionState() !== "connecting" && (this.log.debug("negotiation required, start negotiating", this.logContext), this.publisher.negotiate()), yield Promise.all((l = this.requiredTransports) === null || l === void 0 ? void 0 : l.map((S) => this.ensureTransportConnected(S, u, c)));
      } finally {
        v();
      }
    });
  }
  negotiate(u) {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((c, l) => __awaiter(this, void 0, void 0, function* () {
        const v = setTimeout(() => {
          l("negotiation timed out");
        }, this.peerConnectionTimeout), S = () => {
          clearTimeout(v), l("negotiation aborted");
        };
        u.signal.addEventListener("abort", S), this.publisher.once(PCEvents.NegotiationStarted, () => {
          u.signal.aborted || this.publisher.once(PCEvents.NegotiationComplete, () => {
            clearTimeout(v), c();
          });
        }), yield this.publisher.negotiate((g) => {
          clearTimeout(v), l(g);
        });
      }));
    });
  }
  addPublisherTransceiver(u, c) {
    return this.publisher.addTransceiver(u, c);
  }
  addPublisherTrack(u) {
    return this.publisher.addTrack(u);
  }
  createPublisherDataChannel(u, c) {
    return this.publisher.createDataChannel(u, c);
  }
  /**
   * Returns the first required transport's address if no explicit target is specified
   */
  getConnectedAddress(u) {
    return u === SignalTarget.PUBLISHER ? this.publisher.getConnectedAddress() : u === SignalTarget.SUBSCRIBER ? this.publisher.getConnectedAddress() : this.requiredTransports[0].getConnectedAddress();
  }
  get requiredTransports() {
    const u = [];
    return this.isPublisherConnectionRequired && u.push(this.publisher), this.isSubscriberConnectionRequired && u.push(this.subscriber), u;
  }
  ensureTransportConnected(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.peerConnectionTimeout;
    return __awaiter(this, void 0, void 0, function* () {
      if (u.getConnectionState() !== "connected")
        return new Promise((S, g) => __awaiter(this, void 0, void 0, function* () {
          const E = () => {
            this.log.warn("abort transport connection", this.logContext), CriticalTimers.clearTimeout(_), g(new ConnectionError(
              "room connection has been cancelled",
              3
              /* ConnectionErrorReason.Cancelled */
            ));
          };
          c != null && c.signal.aborted && E(), c == null || c.signal.addEventListener("abort", E);
          const _ = CriticalTimers.setTimeout(() => {
            c == null || c.signal.removeEventListener("abort", E), g(new ConnectionError("could not establish pc connection"));
          }, l);
          for (; this.state !== PCTransportState.CONNECTED; )
            if (yield sleep(50), c != null && c.signal.aborted) {
              g(new ConnectionError(
                "room connection has been cancelled",
                3
                /* ConnectionErrorReason.Cancelled */
              ));
              return;
            }
          CriticalTimers.clearTimeout(_), c == null || c.signal.removeEventListener("abort", E), S();
        }));
    });
  }
}
const lossyDataChannel = "_lossy", reliableDataChannel = "_reliable", minReconnectWait = 2 * 1e3, leaveReconnect = "leave-reconnect";
var PCState;
(function(a) {
  a[a.New = 0] = "New", a[a.Connected = 1] = "Connected", a[a.Disconnected = 2] = "Disconnected", a[a.Reconnecting = 3] = "Reconnecting", a[a.Closed = 4] = "Closed";
})(PCState || (PCState = {}));
class RTCEngine extends eventsExports.EventEmitter {
  get isClosed() {
    return this._isClosed;
  }
  get pendingReconnect() {
    return !!this.reconnectTimeout;
  }
  constructor(u) {
    var c;
    super(), this.options = u, this.rtcConfig = {}, this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout, this.fullReconnectOnNext = !1, this.subscriberPrimary = !1, this.pcState = PCState.New, this._isClosed = !0, this.pendingTrackResolvers = {}, this.reconnectAttempts = 0, this.reconnectStart = 0, this.attemptingReconnect = !1, this.joinAttempts = 0, this.maxJoinAttempts = 1, this.shouldFailNext = !1, this.log = livekitLogger, this.handleDataChannel = (l) => {
      let {
        channel: v
      } = l;
      return __awaiter(this, void 0, void 0, function* () {
        if (v) {
          if (v.label === reliableDataChannel)
            this.reliableDCSub = v;
          else if (v.label === lossyDataChannel)
            this.lossyDCSub = v;
          else
            return;
          this.log.debug("on data channel ".concat(v.id, ", ").concat(v.label), this.logContext), v.onmessage = this.handleDataMessage;
        }
      });
    }, this.handleDataMessage = (l) => __awaiter(this, void 0, void 0, function* () {
      var v, S;
      const g = yield this.dataProcessLock.lock();
      try {
        let E;
        if (l.data instanceof ArrayBuffer)
          E = l.data;
        else if (l.data instanceof Blob)
          E = yield l.data.arrayBuffer();
        else {
          this.log.error("unsupported data type", Object.assign(Object.assign({}, this.logContext), {
            data: l.data
          }));
          return;
        }
        const _ = DataPacket.fromBinary(new Uint8Array(E));
        ((v = _.value) === null || v === void 0 ? void 0 : v.case) === "speaker" ? this.emit(EngineEvent.ActiveSpeakersUpdate, _.value.value.speakers) : ((S = _.value) === null || S === void 0 ? void 0 : S.case) === "user" && this.emit(EngineEvent.DataPacketReceived, _.value.value, _.kind);
      } finally {
        g();
      }
    }), this.handleDataError = (l) => {
      const S = l.currentTarget.maxRetransmits === 0 ? "lossy" : "reliable";
      if (l instanceof ErrorEvent && l.error) {
        const {
          error: g
        } = l.error;
        this.log.error("DataChannel error on ".concat(S, ": ").concat(l.message), Object.assign(Object.assign({}, this.logContext), {
          error: g
        }));
      } else
        this.log.error("Unknown DataChannel error on ".concat(S), Object.assign(Object.assign({}, this.logContext), {
          event: l
        }));
    }, this.handleBufferedAmountLow = (l) => {
      const S = l.currentTarget.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;
      this.updateAndEmitDCBufferStatus(S);
    }, this.handleDisconnect = (l, v) => {
      if (this._isClosed)
        return;
      this.log.warn("".concat(l, " disconnected"), this.logContext), this.reconnectAttempts === 0 && (this.reconnectStart = Date.now());
      const S = (_) => {
        this.log.warn("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(_, "ms. giving up"), this.logContext), this.emit(EngineEvent.Disconnected), this.close();
      }, g = Date.now() - this.reconnectStart;
      let E = this.getNextRetryDelay({
        elapsedMs: g,
        retryCount: this.reconnectAttempts
      });
      if (E === null) {
        S(g);
        return;
      }
      l === leaveReconnect && (E = 0), this.log.debug("reconnecting in ".concat(E, "ms"), this.logContext), this.clearReconnectTimeout(), this.token && this.regionUrlProvider && this.regionUrlProvider.updateToken(this.token), this.reconnectTimeout = CriticalTimers.setTimeout(() => this.attemptReconnect(v).finally(() => this.reconnectTimeout = void 0), E);
    }, this.waitForRestarted = () => new Promise((l, v) => {
      this.pcState === PCState.Connected && l();
      const S = () => {
        this.off(EngineEvent.Disconnected, g), l();
      }, g = () => {
        this.off(EngineEvent.Restarted, S), v();
      };
      this.once(EngineEvent.Restarted, S), this.once(EngineEvent.Disconnected, g);
    }), this.updateAndEmitDCBufferStatus = (l) => {
      const v = this.isBufferStatusLow(l);
      typeof v < "u" && v !== this.dcBufferStatus.get(l) && (this.dcBufferStatus.set(l, v), this.emit(EngineEvent.DCBufferStatusChanged, v, l));
    }, this.isBufferStatusLow = (l) => {
      const v = this.dataChannelForKind(l);
      if (v)
        return v.bufferedAmount <= v.bufferedAmountLowThreshold;
    }, this.handleBrowserOnLine = () => {
      this.client.currentState === SignalConnectionState.RECONNECTING && (this.clearReconnectTimeout(), this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED));
    }, this.log = getLogger((c = u.loggerName) !== null && c !== void 0 ? c : LoggerNames.Engine), this.loggerOptions = {
      loggerName: u.loggerName,
      loggerContextCb: () => this.logContext
    }, this.client = new SignalClient(void 0, this.loggerOptions), this.client.signalLatency = this.options.expSignalLatency, this.reconnectPolicy = this.options.reconnectPolicy, this.registerOnLineListener(), this.closingLock = new Mutex(), this.dataProcessLock = new Mutex(), this.dcBufferStatus = /* @__PURE__ */ new Map([[DataPacket_Kind.LOSSY, !0], [DataPacket_Kind.RELIABLE, !0]]), this.client.onParticipantUpdate = (l) => this.emit(EngineEvent.ParticipantUpdate, l), this.client.onConnectionQuality = (l) => this.emit(EngineEvent.ConnectionQualityUpdate, l), this.client.onRoomUpdate = (l) => this.emit(EngineEvent.RoomUpdate, l), this.client.onSubscriptionError = (l) => this.emit(EngineEvent.SubscriptionError, l), this.client.onSubscriptionPermissionUpdate = (l) => this.emit(EngineEvent.SubscriptionPermissionUpdate, l), this.client.onSpeakersChanged = (l) => this.emit(EngineEvent.SpeakersChanged, l), this.client.onStreamStateUpdate = (l) => this.emit(EngineEvent.StreamStateChanged, l);
  }
  /** @internal */
  get logContext() {
    var u, c, l, v, S, g;
    return {
      room: (c = (u = this.latestJoinResponse) === null || u === void 0 ? void 0 : u.room) === null || c === void 0 ? void 0 : c.name,
      roomSid: (v = (l = this.latestJoinResponse) === null || l === void 0 ? void 0 : l.room) === null || v === void 0 ? void 0 : v.sid,
      identity: (g = (S = this.latestJoinResponse) === null || S === void 0 ? void 0 : S.participant) === null || g === void 0 ? void 0 : g.identity
    };
  }
  join(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      this.url = u, this.token = c, this.signalOpts = l, this.maxJoinAttempts = l.maxRetries;
      try {
        this.joinAttempts += 1, this.setupSignalClientCallbacks();
        const S = yield this.client.join(u, c, l, v);
        return this._isClosed = !1, this.latestJoinResponse = S, this.subscriberPrimary = S.subscriberPrimary, this.pcManager || (yield this.configure(S)), this.subscriberPrimary || this.negotiate(), this.clientConfiguration = S.clientConfiguration, S;
      } catch (S) {
        if (S instanceof ConnectionError && S.reason === 1 && (this.log.warn("Couldn't connect to server, attempt ".concat(this.joinAttempts, " of ").concat(this.maxJoinAttempts), this.logContext), this.joinAttempts < this.maxJoinAttempts))
          return this.join(u, c, l, v);
        throw S;
      }
    });
  }
  close() {
    return __awaiter(this, void 0, void 0, function* () {
      const u = yield this.closingLock.lock();
      if (this.isClosed) {
        u();
        return;
      }
      try {
        this._isClosed = !0, this.emit(EngineEvent.Closing), this.removeAllListeners(), this.deregisterOnLineListener(), this.clearPendingReconnect(), yield this.cleanupPeerConnections(), yield this.cleanupClient();
      } finally {
        u();
      }
    });
  }
  cleanupPeerConnections() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      yield (u = this.pcManager) === null || u === void 0 ? void 0 : u.close(), this.pcManager = void 0;
      const c = (l) => {
        l && (l.close(), l.onbufferedamountlow = null, l.onclose = null, l.onclosing = null, l.onerror = null, l.onmessage = null, l.onopen = null);
      };
      c(this.lossyDC), c(this.lossyDCSub), c(this.reliableDC), c(this.reliableDCSub), this.lossyDC = void 0, this.lossyDCSub = void 0, this.reliableDC = void 0, this.reliableDCSub = void 0;
    });
  }
  cleanupClient() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.client.close(), this.client.resetCallbacks();
    });
  }
  addTrack(u) {
    if (this.pendingTrackResolvers[u.cid])
      throw new TrackInvalidError("a track with the same ID has already been published");
    return new Promise((c, l) => {
      const v = setTimeout(() => {
        delete this.pendingTrackResolvers[u.cid], l(new ConnectionError("publication of local track timed out, no response from server"));
      }, 1e4);
      this.pendingTrackResolvers[u.cid] = {
        resolve: (S) => {
          clearTimeout(v), c(S);
        },
        reject: () => {
          clearTimeout(v), l(new Error("Cancelled publication by calling unpublish"));
        }
      }, this.client.sendAddTrack(u);
    });
  }
  /**
   * Removes sender from PeerConnection, returning true if it was removed successfully
   * and a negotiation is necessary
   * @param sender
   * @returns
   */
  removeTrack(u) {
    if (u.track && this.pendingTrackResolvers[u.track.id]) {
      const {
        reject: c
      } = this.pendingTrackResolvers[u.track.id];
      c && c(), delete this.pendingTrackResolvers[u.track.id];
    }
    try {
      return this.pcManager.removeTrack(u), !0;
    } catch (c) {
      this.log.warn("failed to remove track", Object.assign(Object.assign({}, this.logContext), {
        error: c
      }));
    }
    return !1;
  }
  updateMuteStatus(u, c) {
    this.client.sendMuteTrack(u, c);
  }
  get dataSubscriberReadyState() {
    var u;
    return (u = this.reliableDCSub) === null || u === void 0 ? void 0 : u.readyState;
  }
  getConnectedServerAddress() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      return (u = this.pcManager) === null || u === void 0 ? void 0 : u.getConnectedAddress();
    });
  }
  /* @internal */
  setRegionUrlProvider(u) {
    this.regionUrlProvider = u;
  }
  configure(u) {
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW)
        return;
      this.participantSid = (c = u.participant) === null || c === void 0 ? void 0 : c.sid;
      const l = this.makeRTCConfiguration(u);
      this.pcManager = new PCTransportManager(l, u.subscriberPrimary, this.loggerOptions), this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber), this.pcManager.onIceCandidate = (v, S) => {
        this.client.sendIceCandidate(v, S);
      }, this.pcManager.onPublisherOffer = (v) => {
        this.client.sendOffer(v);
      }, this.pcManager.onDataChannel = this.handleDataChannel, this.pcManager.onStateChange = (v, S, g) => __awaiter(this, void 0, void 0, function* () {
        if (this.log.debug("primary PC state changed ".concat(v), this.logContext), v === PCTransportState.CONNECTED) {
          const E = this.pcState === PCState.New;
          this.pcState = PCState.Connected, E && this.emit(EngineEvent.Connected, u);
        } else
          v === PCTransportState.FAILED && this.pcState === PCState.Connected && (this.pcState = PCState.Disconnected, this.handleDisconnect("peerconnection failed", g === "failed" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED));
      }), this.pcManager.onTrack = (v) => {
        this.emit(EngineEvent.MediaTrackAdded, v.track, v.streams[0], v.receiver);
      }, this.createDataChannels();
    });
  }
  setupSignalClientCallbacks() {
    this.client.onAnswer = (u) => __awaiter(this, void 0, void 0, function* () {
      this.pcManager && (this.log.debug("received server answer", Object.assign(Object.assign({}, this.logContext), {
        RTCSdpType: u.type
      })), yield this.pcManager.setPublisherAnswer(u));
    }), this.client.onTrickle = (u, c) => {
      this.pcManager && (this.log.trace("got ICE candidate from peer", Object.assign(Object.assign({}, this.logContext), {
        candidate: u,
        target: c
      })), this.pcManager.addIceCandidate(u, c));
    }, this.client.onOffer = (u) => __awaiter(this, void 0, void 0, function* () {
      if (!this.pcManager)
        return;
      const c = yield this.pcManager.createSubscriberAnswerFromOffer(u);
      this.client.sendAnswer(c);
    }), this.client.onLocalTrackPublished = (u) => {
      var c;
      if (this.log.debug("received trackPublishedResponse", Object.assign(Object.assign({}, this.logContext), {
        cid: u.cid,
        track: (c = u.track) === null || c === void 0 ? void 0 : c.sid
      })), !this.pendingTrackResolvers[u.cid]) {
        this.log.error("missing track resolver for ".concat(u.cid), Object.assign(Object.assign({}, this.logContext), {
          cid: u.cid
        }));
        return;
      }
      const {
        resolve: l
      } = this.pendingTrackResolvers[u.cid];
      delete this.pendingTrackResolvers[u.cid], l(u.track);
    }, this.client.onLocalTrackUnpublished = (u) => {
      this.emit(EngineEvent.LocalTrackUnpublished, u);
    }, this.client.onTokenRefresh = (u) => {
      this.token = u;
    }, this.client.onRemoteMuteChanged = (u, c) => {
      this.emit(EngineEvent.RemoteMute, u, c);
    }, this.client.onSubscribedQualityUpdate = (u) => {
      this.emit(EngineEvent.SubscribedQualityUpdate, u);
    }, this.client.onClose = () => {
      this.handleDisconnect("signal", ReconnectReason.RR_SIGNAL_DISCONNECTED);
    }, this.client.onLeave = (u) => {
      u != null && u.canReconnect ? (this.fullReconnectOnNext = !0, this.handleDisconnect(leaveReconnect)) : (this.emit(EngineEvent.Disconnected, u == null ? void 0 : u.reason), this.close()), this.log.debug("client leave request", Object.assign(Object.assign({}, this.logContext), {
        reason: u == null ? void 0 : u.reason
      }));
    };
  }
  makeRTCConfiguration(u) {
    var c;
    const l = Object.assign({}, this.rtcConfig);
    if (!((c = this.signalOpts) === null || c === void 0) && c.e2eeEnabled && (this.log.debug("E2EE - setting up transports with insertable streams", this.logContext), l.encodedInsertableStreams = !0), u.iceServers && !l.iceServers) {
      const v = [];
      u.iceServers.forEach((S) => {
        const g = {
          urls: S.urls
        };
        S.username && (g.username = S.username), S.credential && (g.credential = S.credential), v.push(g);
      }), l.iceServers = v;
    }
    return u.clientConfiguration && u.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED && (l.iceTransportPolicy = "relay"), l.sdpSemantics = "unified-plan", l.continualGatheringPolicy = "gather_continually", l;
  }
  createDataChannels() {
    this.pcManager && (this.lossyDC && (this.lossyDC.onmessage = null, this.lossyDC.onerror = null), this.reliableDC && (this.reliableDC.onmessage = null, this.reliableDC.onerror = null), this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {
      // will drop older packets that arrive
      ordered: !0,
      maxRetransmits: 0
    }), this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {
      ordered: !0
    }), this.lossyDC.onmessage = this.handleDataMessage, this.reliableDC.onmessage = this.handleDataMessage, this.lossyDC.onerror = this.handleDataError, this.reliableDC.onerror = this.handleDataError, this.lossyDC.bufferedAmountLowThreshold = 65535, this.reliableDC.bufferedAmountLowThreshold = 65535, this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow, this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow);
  }
  setPreferredCodec(u, c, l) {
    if (!("getCapabilities" in RTCRtpSender))
      return;
    const v = RTCRtpSender.getCapabilities(c);
    if (!v)
      return;
    this.log.debug("get sender capabilities", Object.assign(Object.assign({}, this.logContext), {
      cap: v
    }));
    const S = [], g = [], E = [];
    v.codecs.forEach((_) => {
      const k = _.mimeType.toLowerCase();
      if (k === "audio/opus") {
        S.push(_);
        return;
      }
      if (!(k === "video/".concat(l))) {
        E.push(_);
        return;
      }
      if (l === "h264") {
        _.sdpFmtpLine && _.sdpFmtpLine.includes("profile-level-id=42e01f") ? S.push(_) : g.push(_);
        return;
      }
      S.push(_);
    }), supportsSetCodecPreferences(u) && u.setCodecPreferences(S.concat(g, E));
  }
  createSender(u, c, l) {
    return __awaiter(this, void 0, void 0, function* () {
      if (supportsTransceiver())
        return yield this.createTransceiverRTCRtpSender(u, c, l);
      if (supportsAddTrack())
        return this.log.warn("using add-track fallback", this.logContext), yield this.createRTCRtpSender(u.mediaStreamTrack);
      throw new UnexpectedConnectionState("Required webRTC APIs not supported on this device");
    });
  }
  createSimulcastSender(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      if (supportsTransceiver())
        return this.createSimulcastTransceiverSender(u, c, l, v);
      if (supportsAddTrack())
        return this.log.debug("using add-track fallback", this.logContext), this.createRTCRtpSender(u.mediaStreamTrack);
      throw new UnexpectedConnectionState("Cannot stream on this device");
    });
  }
  createTransceiverRTCRtpSender(u, c, l) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      const v = [];
      u.mediaStream && v.push(u.mediaStream);
      const S = {
        direction: "sendonly",
        streams: v
      };
      l && (S.sendEncodings = l);
      const g = yield this.pcManager.addPublisherTransceiver(u.mediaStreamTrack, S);
      return u.kind === Track.Kind.Video && c.videoCodec && (this.setPreferredCodec(g, u.kind, c.videoCodec), u.codec = c.videoCodec), g.sender;
    });
  }
  createSimulcastTransceiverSender(u, c, l, v) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      const S = {
        direction: "sendonly"
      };
      v && (S.sendEncodings = v);
      const g = yield this.pcManager.addPublisherTransceiver(c.mediaStreamTrack, S);
      if (l.videoCodec)
        return this.setPreferredCodec(g, u.kind, l.videoCodec), u.setSimulcastTrackSender(l.videoCodec, g.sender), g.sender;
    });
  }
  createRTCRtpSender(u) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher is closed");
      return this.pcManager.addPublisherTrack(u);
    });
  }
  attemptReconnect(u) {
    var c, l, v;
    return __awaiter(this, void 0, void 0, function* () {
      if (!this._isClosed) {
        if (this.attemptingReconnect) {
          livekitLogger.warn("already attempting reconnect, returning early", this.logContext);
          return;
        }
        (((c = this.clientConfiguration) === null || c === void 0 ? void 0 : c.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep
        // those connections cannot be resumed
        ((v = (l = this.pcManager) === null || l === void 0 ? void 0 : l.currentState) !== null && v !== void 0 ? v : PCTransportState.NEW) === PCTransportState.NEW) && (this.fullReconnectOnNext = !0);
        try {
          this.attemptingReconnect = !0, this.fullReconnectOnNext ? yield this.restartConnection() : yield this.resumeConnection(u), this.clearPendingReconnect(), this.fullReconnectOnNext = !1;
        } catch (S) {
          this.reconnectAttempts += 1;
          let g = !0;
          S instanceof UnexpectedConnectionState ? (this.log.debug("received unrecoverable error", Object.assign(Object.assign({}, this.logContext), {
            error: S
          })), g = !1) : S instanceof SignalReconnectError || (this.fullReconnectOnNext = !0), g ? this.handleDisconnect("reconnect", ReconnectReason.RR_UNKNOWN) : (this.log.info("could not recover connection after ".concat(this.reconnectAttempts, " attempts, ").concat(Date.now() - this.reconnectStart, "ms. giving up"), this.logContext), this.emit(EngineEvent.Disconnected), yield this.close());
        } finally {
          this.attemptingReconnect = !1;
        }
      }
    });
  }
  getNextRetryDelay(u) {
    try {
      return this.reconnectPolicy.nextRetryDelayInMs(u);
    } catch (c) {
      this.log.warn("encountered error in reconnect policy", Object.assign(Object.assign({}, this.logContext), {
        error: c
      }));
    }
    return null;
  }
  restartConnection(u) {
    var c, l, v;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (!this.url || !this.token)
          throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
        this.log.info("reconnecting, attempt: ".concat(this.reconnectAttempts), this.logContext), this.emit(EngineEvent.Restarting), this.client.isDisconnected || (yield this.client.sendLeave()), yield this.cleanupPeerConnections(), yield this.cleanupClient();
        let S;
        try {
          if (!this.signalOpts)
            throw this.log.warn("attempted connection restart, without signal options present", this.logContext), new SignalReconnectError();
          S = yield this.join(u ?? this.url, this.token, this.signalOpts);
        } catch (g) {
          throw g instanceof ConnectionError && g.reason === 0 ? new UnexpectedConnectionState("could not reconnect, token might be expired") : new SignalReconnectError();
        }
        if (this.shouldFailNext)
          throw this.shouldFailNext = !1, new Error("simulated failure");
        if (this.client.setReconnected(), this.emit(EngineEvent.SignalRestarted, S), yield this.waitForPCReconnected(), this.client.currentState !== SignalConnectionState.CONNECTED)
          throw new SignalReconnectError("Signal connection got severed during reconnect");
        (c = this.regionUrlProvider) === null || c === void 0 || c.resetAttempts(), this.emit(EngineEvent.Restarted);
      } catch (S) {
        const g = yield (l = this.regionUrlProvider) === null || l === void 0 ? void 0 : l.getNextBestRegionUrl();
        if (g) {
          yield this.restartConnection(g);
          return;
        } else
          throw (v = this.regionUrlProvider) === null || v === void 0 || v.resetAttempts(), S;
      }
    });
  }
  resumeConnection(u) {
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.url || !this.token)
        throw new UnexpectedConnectionState("could not reconnect, url or token not saved");
      if (!this.pcManager)
        throw new UnexpectedConnectionState("publisher and subscriber connections unset");
      this.log.info("resuming signal connection, attempt ".concat(this.reconnectAttempts), this.logContext), this.emit(EngineEvent.Resuming);
      try {
        this.setupSignalClientCallbacks();
        const l = yield this.client.reconnect(this.url, this.token, this.participantSid, u);
        if (l) {
          const v = this.makeRTCConfiguration(l);
          this.pcManager.updateConfiguration(v);
        }
      } catch (l) {
        let v = "";
        throw l instanceof Error && (v = l.message, this.log.error(l.message, Object.assign(Object.assign({}, this.logContext), {
          error: l
        }))), l instanceof ConnectionError && l.reason === 0 ? new UnexpectedConnectionState("could not reconnect, token might be expired") : l instanceof ConnectionError && l.reason === 4 ? l : new SignalReconnectError(v);
      }
      if (this.emit(EngineEvent.SignalResumed), this.shouldFailNext)
        throw this.shouldFailNext = !1, new Error("simulated failure");
      if (yield this.pcManager.triggerIceRestart(), yield this.waitForPCReconnected(), this.client.currentState !== SignalConnectionState.CONNECTED)
        throw new SignalReconnectError("Signal connection got severed during reconnect");
      this.client.setReconnected(), ((c = this.reliableDC) === null || c === void 0 ? void 0 : c.readyState) === "open" && this.reliableDC.id === null && this.createDataChannels(), this.emit(EngineEvent.Resumed);
    });
  }
  waitForPCInitialConnection(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("PC manager is closed");
      yield this.pcManager.ensurePCTransportConnection(c, u);
    });
  }
  waitForPCReconnected() {
    return __awaiter(this, void 0, void 0, function* () {
      this.pcState = PCState.Reconnecting, this.log.debug("waiting for peer connection to reconnect", this.logContext);
      try {
        if (yield sleep(minReconnectWait), !this.pcManager)
          throw new UnexpectedConnectionState("PC manager is closed");
        yield this.pcManager.ensurePCTransportConnection(void 0, this.peerConnectionTimeout), this.pcState = PCState.Connected;
      } catch (u) {
        throw this.pcState = PCState.Disconnected, new ConnectionError("could not establish PC connection, ".concat(u.message));
      }
    });
  }
  /* @internal */
  sendDataPacket(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      const l = u.toBinary();
      yield this.ensurePublisherConnected(c);
      const v = this.dataChannelForKind(c);
      v && v.send(l), this.updateAndEmitDCBufferStatus(c);
    });
  }
  /**
   * @internal
   */
  ensureDataTransportConnected(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.subscriberPrimary;
    var l;
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.pcManager)
        throw new UnexpectedConnectionState("PC manager is closed");
      const v = c ? this.pcManager.subscriber : this.pcManager.publisher, S = c ? "Subscriber" : "Publisher";
      if (!v)
        throw new ConnectionError("".concat(S, " connection not set"));
      !c && !this.pcManager.publisher.isICEConnected && this.pcManager.publisher.getICEConnectionState() !== "checking" && this.negotiate();
      const g = this.dataChannelForKind(u, c);
      if ((g == null ? void 0 : g.readyState) === "open")
        return;
      const E = (/* @__PURE__ */ new Date()).getTime() + this.peerConnectionTimeout;
      for (; (/* @__PURE__ */ new Date()).getTime() < E; ) {
        if (v.isICEConnected && ((l = this.dataChannelForKind(u, c)) === null || l === void 0 ? void 0 : l.readyState) === "open")
          return;
        yield sleep(50);
      }
      throw new ConnectionError("could not establish ".concat(S, " connection, state: ").concat(v.getICEConnectionState()));
    });
  }
  ensurePublisherConnected(u) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.ensureDataTransportConnected(u, !1);
    });
  }
  /* @internal */
  verifyTransport() {
    return !(!this.pcManager || this.pcManager.currentState !== PCTransportState.CONNECTED || !this.client.ws || this.client.ws.readyState === WebSocket.CLOSED);
  }
  /** @internal */
  negotiate() {
    return __awaiter(this, void 0, void 0, function* () {
      return new Promise((u, c) => __awaiter(this, void 0, void 0, function* () {
        if (!this.pcManager) {
          c(new NegotiationError("PC manager is closed"));
          return;
        }
        this.pcManager.requirePublisher();
        const l = new AbortController(), v = () => {
          l.abort(), this.log.debug("engine disconnected while negotiation was ongoing", this.logContext), u();
        };
        this.isClosed && c("cannot negotiate on closed engine"), this.on(EngineEvent.Closing, v), this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (S) => {
          const g = /* @__PURE__ */ new Map();
          S.forEach((E) => {
            const _ = E.codec.toLowerCase();
            isVideoCodec(_) && g.set(E.payload, _);
          }), this.emit(EngineEvent.RTPVideoMapUpdate, g);
        });
        try {
          yield this.pcManager.negotiate(l), u();
        } catch (S) {
          S instanceof NegotiationError && (this.fullReconnectOnNext = !0), this.handleDisconnect("negotiation", ReconnectReason.RR_UNKNOWN), c(S);
        } finally {
          this.off(EngineEvent.Closing, v);
        }
      }));
    });
  }
  dataChannelForKind(u, c) {
    if (c) {
      if (u === DataPacket_Kind.LOSSY)
        return this.lossyDCSub;
      if (u === DataPacket_Kind.RELIABLE)
        return this.reliableDCSub;
    } else {
      if (u === DataPacket_Kind.LOSSY)
        return this.lossyDC;
      if (u === DataPacket_Kind.RELIABLE)
        return this.reliableDC;
    }
  }
  /** @internal */
  sendSyncState(u, c) {
    var l, v;
    if (!this.pcManager) {
      this.log.warn("sync state cannot be sent without peer connection setup", this.logContext);
      return;
    }
    const S = this.pcManager.subscriber.getLocalDescription(), g = this.pcManager.subscriber.getRemoteDescription(), E = (v = (l = this.signalOpts) === null || l === void 0 ? void 0 : l.autoSubscribe) !== null && v !== void 0 ? v : !0, _ = new Array(), k = new Array();
    u.forEach((L) => {
      L.isDesired !== E && _.push(L.trackSid), L.isEnabled || k.push(L.trackSid);
    }), this.client.sendSyncState(new SyncState({
      answer: S ? toProtoSessionDescription({
        sdp: S.sdp,
        type: S.type
      }) : void 0,
      offer: g ? toProtoSessionDescription({
        sdp: g.sdp,
        type: g.type
      }) : void 0,
      subscription: new UpdateSubscription({
        trackSids: _,
        subscribe: !E,
        participantTracks: []
      }),
      publishTracks: getTrackPublicationInfo(c),
      dataChannels: this.dataChannelsInfo(),
      trackSidsDisabled: k
    }));
  }
  /* @internal */
  failNext() {
    this.shouldFailNext = !0;
  }
  dataChannelsInfo() {
    const u = [], c = (l, v) => {
      (l == null ? void 0 : l.id) !== void 0 && l.id !== null && u.push(new DataChannelInfo({
        label: l.label,
        id: l.id,
        target: v
      }));
    };
    return c(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER), c(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER), c(this.dataChannelForKind(DataPacket_Kind.LOSSY, !0), SignalTarget.SUBSCRIBER), c(this.dataChannelForKind(DataPacket_Kind.RELIABLE, !0), SignalTarget.SUBSCRIBER), u;
  }
  clearReconnectTimeout() {
    this.reconnectTimeout && CriticalTimers.clearTimeout(this.reconnectTimeout);
  }
  clearPendingReconnect() {
    this.clearReconnectTimeout(), this.reconnectAttempts = 0;
  }
  registerOnLineListener() {
    isWeb() && window.addEventListener("online", this.handleBrowserOnLine);
  }
  deregisterOnLineListener() {
    isWeb() && window.removeEventListener("online", this.handleBrowserOnLine);
  }
}
class SignalReconnectError extends Error {
}
class RegionUrlProvider {
  constructor(u, c) {
    this.lastUpdateAt = 0, this.settingsCacheTime = 3e3, this.attemptedRegions = [], this.serverUrl = new URL(u), this.token = c;
  }
  updateToken(u) {
    this.token = u;
  }
  isCloud() {
    return isCloud(this.serverUrl);
  }
  getServerUrl() {
    return this.serverUrl;
  }
  getNextBestRegionUrl(u) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.isCloud())
        throw Error("region availability is only supported for LiveKit Cloud domains");
      (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) && (this.regionSettings = yield this.fetchRegionSettings(u));
      const c = this.regionSettings.regions.filter((l) => !this.attemptedRegions.find((v) => v.url === l.url));
      if (c.length > 0) {
        const l = c[0];
        return this.attemptedRegions.push(l), livekitLogger.debug("next region: ".concat(l.region)), l.url;
      } else
        return null;
    });
  }
  resetAttempts() {
    this.attemptedRegions = [];
  }
  /* @internal */
  fetchRegionSettings(u) {
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield fetch("".concat(getCloudConfigUrl(this.serverUrl), "/regions"), {
        headers: {
          authorization: "Bearer ".concat(this.token)
        },
        signal: u
      });
      if (c.ok) {
        const l = yield c.json();
        return this.lastUpdateAt = Date.now(), l;
      } else
        throw new ConnectionError("Could not fetch region settings: ".concat(c.statusText), c.status === 401 ? 0 : void 0, c.status);
    });
  }
}
function getCloudConfigUrl(a) {
  return "".concat(a.protocol.replace("ws", "http"), "//").concat(a.host, "/settings");
}
const monitorFrequency = 2e3;
function computeBitrate(a, u) {
  if (!u)
    return 0;
  let c, l;
  return "bytesReceived" in a ? (c = a.bytesReceived, l = u.bytesReceived) : "bytesSent" in a && (c = a.bytesSent, l = u.bytesSent), c === void 0 || l === void 0 || a.timestamp === void 0 || u.timestamp === void 0 ? 0 : (c - l) * 8 * 1e3 / (a.timestamp - u.timestamp);
}
class LocalAudioTrack extends LocalTrack {
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, v = arguments.length > 3 ? arguments[3] : void 0, S = arguments.length > 4 ? arguments[4] : void 0;
    super(u, Track.Kind.Audio, c, l, S), this.stopOnMute = !1, this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let g;
      try {
        g = yield this.getSenderStats();
      } catch (E) {
        this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: E
        }));
        return;
      }
      g && this.prevStats && (this._currentBitrate = computeBitrate(g, this.prevStats)), this.prevStats = g;
    }), this.audioContext = v, this.checkForSilence();
  }
  setDeviceId(u) {
    return __awaiter(this, void 0, void 0, function* () {
      return this._constraints.deviceId === u ? !0 : (this._constraints.deviceId = u, this.isMuted || (yield this.restartTrack()), this.isMuted || unwrapConstraint(u) === this.mediaStreamTrack.getSettings().deviceId);
    });
  }
  mute() {
    const u = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided && (this.log.debug("stopping mic track", this.logContext), this._mediaStreamTrack.stop()), yield u.mute.call(this), this;
      } finally {
        c();
      }
    });
  }
  unmute() {
    const u = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        const l = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);
        return this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === "ended" || l) && !this.isUserProvided && (this.log.debug("reacquiring mic track", this.logContext), yield this.restartTrack()), yield u.unmute.call(this), this;
      } finally {
        c();
      }
    });
  }
  restartTrack(u) {
    return __awaiter(this, void 0, void 0, function* () {
      let c;
      if (u) {
        const l = constraintsForOptions({
          audio: u
        });
        typeof l.audio != "boolean" && (c = l.audio);
      }
      yield this.restart(c);
    });
  }
  restart(u) {
    const c = Object.create(null, {
      restart: {
        get: () => super.restart
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield c.restart.call(this, u);
      return this.checkForSilence(), l;
    });
  }
  /* @internal */
  startMonitor() {
    isWeb() && (this.monitorInterval || (this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency)));
  }
  setProcessor(u) {
    var c;
    return __awaiter(this, void 0, void 0, function* () {
      const l = yield this.processorLock.lock();
      try {
        if (!this.audioContext)
          throw Error("Audio context needs to be set on LocalAudioTrack in order to enable processors");
        if (this.processor && (yield this.stopProcessor()), this.kind === "unknown")
          throw TypeError("cannot set processor on track of unknown kind");
        const v = {
          kind: this.kind,
          track: this._mediaStreamTrack,
          audioContext: this.audioContext
        };
        this.log.debug("setting up audio processor ".concat(u.name), this.logContext), yield u.init(v), this.processor = u, this.processor.processedTrack && (yield (c = this.sender) === null || c === void 0 ? void 0 : c.replaceTrack(this.processor.processedTrack));
      } finally {
        l();
      }
    });
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(u) {
    this.audioContext = u;
  }
  getSenderStats() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      if (!(!((u = this.sender) === null || u === void 0) && u.getStats))
        return;
      const c = yield this.sender.getStats();
      let l;
      return c.forEach((v) => {
        v.type === "outbound-rtp" && (l = {
          type: "audio",
          streamId: v.id,
          packetsSent: v.packetsSent,
          packetsLost: v.packetsLost,
          bytesSent: v.bytesSent,
          timestamp: v.timestamp,
          roundTripTime: v.roundTripTime,
          jitter: v.jitter
        });
      }), l;
    });
  }
  checkForSilence() {
    return __awaiter(this, void 0, void 0, function* () {
      const u = yield detectSilence(this);
      return u && (this.isMuted || this.log.warn("silence detected on local audio track", this.logContext), this.emit(TrackEvent.AudioSilenceDetected)), u;
    });
  }
}
function mediaTrackToLocalTrack(a, u, c) {
  switch (a.kind) {
    case "audio":
      return new LocalAudioTrack(a, u, !1, void 0, c);
    case "video":
      return new LocalVideoTrack(a, u, !1, c);
    default:
      throw new TrackInvalidError("unsupported track type: ".concat(a.kind));
  }
}
const presets169 = Object.values(VideoPresets), presets43 = Object.values(VideoPresets43), presetsScreenShare = Object.values(ScreenSharePresets), defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360], defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360], computeDefaultScreenShareSimulcastPresets = (a) => [{
  scaleResolutionDownBy: 2,
  fps: a.encoding.maxFramerate
}].map((c) => {
  var l, v;
  return new VideoPreset(Math.floor(a.width / c.scaleResolutionDownBy), Math.floor(a.height / c.scaleResolutionDownBy), Math.max(15e4, Math.floor(a.encoding.maxBitrate / (Math.pow(c.scaleResolutionDownBy, 2) * (((l = a.encoding.maxFramerate) !== null && l !== void 0 ? l : 30) / ((v = c.fps) !== null && v !== void 0 ? v : 30))))), c.fps, a.encoding.priority);
}), videoRids = ["q", "h", "f"];
function computeVideoEncodings(a, u, c, l) {
  var v, S;
  let g = l == null ? void 0 : l.videoEncoding;
  a && (g = l == null ? void 0 : l.screenShareEncoding);
  const E = l == null ? void 0 : l.simulcast, _ = l == null ? void 0 : l.scalabilityMode, k = l == null ? void 0 : l.videoCodec;
  if (!g && !E && !_ || !u || !c)
    return [{}];
  g || (g = determineAppropriateEncoding(a, u, c, k), livekitLogger.debug("using video encoding", g));
  const L = new VideoPreset(u, c, g.maxBitrate, g.maxFramerate, g.priority);
  if (_ && isSVCCodec(k)) {
    livekitLogger.debug("using svc with scalabilityMode ".concat(_));
    const J = new ScalabilityMode(_), V = [];
    if (J.spatial > 3)
      throw new Error("unsupported scalabilityMode: ".concat(_));
    for (let q = 0; q < J.spatial; q += 1)
      V.push({
        rid: videoRids[2 - q],
        maxBitrate: g.maxBitrate / Math.pow(3, q),
        /* @ts-ignore */
        maxFramerate: L.encoding.maxFramerate
      });
    return V[0].scalabilityMode = _, livekitLogger.debug("encodings", V), V;
  }
  if (!E)
    return [g];
  let M = [];
  a ? M = (v = sortPresets(l == null ? void 0 : l.screenShareSimulcastLayers)) !== null && v !== void 0 ? v : defaultSimulcastLayers(a, L) : M = (S = sortPresets(l == null ? void 0 : l.videoSimulcastLayers)) !== null && S !== void 0 ? S : defaultSimulcastLayers(a, L);
  let $;
  if (M.length > 0) {
    const J = M[0];
    M.length > 1 && ([, $] = M);
    const V = Math.max(u, c);
    if (V >= 960 && $)
      return encodingsFromPresets(u, c, [J, $, L]);
    if (V >= 480)
      return encodingsFromPresets(u, c, [J, L]);
  }
  return encodingsFromPresets(u, c, [L]);
}
function computeTrackBackupEncodings(a, u, c) {
  var l, v, S, g;
  if (!c.backupCodec || c.backupCodec === !0 || c.backupCodec.codec === c.videoCodec)
    return;
  u !== c.backupCodec.codec && livekitLogger.warn("requested a different codec than specified as backup", {
    serverRequested: u,
    backup: c.backupCodec.codec
  }), c.videoCodec = u, c.videoEncoding = c.backupCodec.encoding;
  const E = a.mediaStreamTrack.getSettings(), _ = (l = E.width) !== null && l !== void 0 ? l : (v = a.dimensions) === null || v === void 0 ? void 0 : v.width, k = (S = E.height) !== null && S !== void 0 ? S : (g = a.dimensions) === null || g === void 0 ? void 0 : g.height;
  return computeVideoEncodings(a.source === Track.Source.ScreenShare, _, k, c);
}
function determineAppropriateEncoding(a, u, c, l) {
  const v = presetsForResolution(a, u, c);
  let {
    encoding: S
  } = v[0];
  const g = Math.max(u, c);
  for (let E = 0; E < v.length; E += 1) {
    const _ = v[E];
    if (S = _.encoding, _.width >= g)
      break;
  }
  if (l)
    switch (l) {
      case "av1":
        S = Object.assign({}, S), S.maxBitrate = S.maxBitrate * 0.7;
        break;
      case "vp9":
        S = Object.assign({}, S), S.maxBitrate = S.maxBitrate * 0.85;
        break;
    }
  return S;
}
function presetsForResolution(a, u, c) {
  if (a)
    return presetsScreenShare;
  const l = u > c ? u / c : c / u;
  return Math.abs(l - 16 / 9) < Math.abs(l - 4 / 3) ? presets169 : presets43;
}
function defaultSimulcastLayers(a, u) {
  if (a)
    return computeDefaultScreenShareSimulcastPresets(u);
  const {
    width: c,
    height: l
  } = u, v = c > l ? c / l : l / c;
  return Math.abs(v - 16 / 9) < Math.abs(v - 4 / 3) ? defaultSimulcastPresets169 : defaultSimulcastPresets43;
}
function encodingsFromPresets(a, u, c) {
  const l = [];
  if (c.forEach((v, S) => {
    if (S >= videoRids.length)
      return;
    const g = Math.min(a, u), _ = {
      rid: videoRids[S],
      scaleResolutionDownBy: Math.max(1, g / Math.min(v.width, v.height)),
      maxBitrate: v.encoding.maxBitrate
    };
    v.encoding.maxFramerate && (_.maxFramerate = v.encoding.maxFramerate);
    const k = isFireFox() || S === 0;
    v.encoding.priority && k && (_.priority = v.encoding.priority, _.networkPriority = v.encoding.priority), l.push(_);
  }), isReactNative() && getReactNativeOs() === "ios") {
    let v;
    l.forEach((g) => {
      v ? g.maxFramerate && g.maxFramerate > v && (v = g.maxFramerate) : v = g.maxFramerate;
    });
    let S = !0;
    l.forEach((g) => {
      var E;
      g.maxFramerate != v && (S && (S = !1, livekitLogger.info("Simulcast on iOS React-Native requires all encodings to share the same framerate.")), livekitLogger.info('Setting framerate of encoding "'.concat((E = g.rid) !== null && E !== void 0 ? E : "", '" to ').concat(v)), g.maxFramerate = v);
    });
  }
  return l;
}
function sortPresets(a) {
  if (a)
    return a.sort((u, c) => {
      const {
        encoding: l
      } = u, {
        encoding: v
      } = c;
      return l.maxBitrate > v.maxBitrate ? 1 : l.maxBitrate < v.maxBitrate ? -1 : l.maxBitrate === v.maxBitrate && l.maxFramerate && v.maxFramerate ? l.maxFramerate > v.maxFramerate ? 1 : -1 : 0;
    });
}
class ScalabilityMode {
  constructor(u) {
    const c = u.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
    if (!c)
      throw new Error("invalid scalability mode");
    if (this.spatial = parseInt(c[1]), this.temporal = parseInt(c[2]), c.length > 3)
      switch (c[3]) {
        case "h":
        case "_KEY":
        case "_KEY_SHIFT":
          this.suffix = c[3];
      }
  }
  toString() {
    var u;
    return "L".concat(this.spatial, "T").concat(this.temporal).concat((u = this.suffix) !== null && u !== void 0 ? u : "");
  }
}
const refreshSubscribedCodecAfterNewCodec = 5e3;
class LocalVideoTrack extends LocalTrack {
  /**
   *
   * @param mediaTrack
   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks
   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK
   */
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, v = arguments.length > 3 ? arguments[3] : void 0;
    super(u, Track.Kind.Video, c, l, v), this.simulcastCodecs = /* @__PURE__ */ new Map(), this.monitorSender = () => __awaiter(this, void 0, void 0, function* () {
      if (!this.sender) {
        this._currentBitrate = 0;
        return;
      }
      let S;
      try {
        S = yield this.getSenderStats();
      } catch (E) {
        this.log.error("could not get audio sender stats", Object.assign(Object.assign({}, this.logContext), {
          error: E
        }));
        return;
      }
      const g = new Map(S.map((E) => [E.rid, E]));
      if (this.prevStats) {
        let E = 0;
        g.forEach((_, k) => {
          var L;
          const M = (L = this.prevStats) === null || L === void 0 ? void 0 : L.get(k);
          E += computeBitrate(_, M);
        }), this._currentBitrate = E;
      }
      this.prevStats = g;
    }), this.senderLock = new Mutex();
  }
  get isSimulcast() {
    return !!(this.sender && this.sender.getParameters().encodings.length > 1);
  }
  /* @internal */
  startMonitor(u) {
    var c;
    if (this.signalClient = u, !isWeb())
      return;
    const l = (c = this.sender) === null || c === void 0 ? void 0 : c.getParameters();
    l && (this.encodings = l.encodings), !this.monitorInterval && (this.monitorInterval = setInterval(() => {
      this.monitorSender();
    }, monitorFrequency));
  }
  stop() {
    this._mediaStreamTrack.getConstraints(), this.simulcastCodecs.forEach((u) => {
      u.mediaStreamTrack.stop();
    }), super.stop();
  }
  pauseUpstream() {
    const u = Object.create(null, {
      pauseUpstream: {
        get: () => super.pauseUpstream
      }
    });
    var c, l, v, S, g;
    return __awaiter(this, void 0, void 0, function* () {
      yield u.pauseUpstream.call(this);
      try {
        for (var E = !0, _ = __asyncValues(this.simulcastCodecs.values()), k; k = yield _.next(), c = k.done, !c; E = !0)
          S = k.value, E = !1, yield (g = S.sender) === null || g === void 0 ? void 0 : g.replaceTrack(null);
      } catch (L) {
        l = {
          error: L
        };
      } finally {
        try {
          !E && !c && (v = _.return) && (yield v.call(_));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  resumeUpstream() {
    const u = Object.create(null, {
      resumeUpstream: {
        get: () => super.resumeUpstream
      }
    });
    var c, l, v, S, g;
    return __awaiter(this, void 0, void 0, function* () {
      yield u.resumeUpstream.call(this);
      try {
        for (var E = !0, _ = __asyncValues(this.simulcastCodecs.values()), k; k = yield _.next(), c = k.done, !c; E = !0) {
          S = k.value, E = !1;
          const L = S;
          yield (g = L.sender) === null || g === void 0 ? void 0 : g.replaceTrack(L.mediaStreamTrack);
        }
      } catch (L) {
        l = {
          error: L
        };
      } finally {
        try {
          !E && !c && (v = _.return) && (yield v.call(_));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  mute() {
    const u = Object.create(null, {
      mute: {
        get: () => super.mute
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.source === Track.Source.Camera && !this.isUserProvided && (this.log.debug("stopping camera track", this.logContext), this._mediaStreamTrack.stop()), yield u.mute.call(this), this;
      } finally {
        c();
      }
    });
  }
  unmute() {
    const u = Object.create(null, {
      unmute: {
        get: () => super.unmute
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield this.muteLock.lock();
      try {
        return this.source === Track.Source.Camera && !this.isUserProvided && (this.log.debug("reacquiring camera track", this.logContext), yield this.restartTrack()), yield u.unmute.call(this), this;
      } finally {
        c();
      }
    });
  }
  setTrackMuted(u) {
    super.setTrackMuted(u);
    for (const c of this.simulcastCodecs.values())
      c.mediaStreamTrack.enabled = !u;
  }
  getSenderStats() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      if (!(!((u = this.sender) === null || u === void 0) && u.getStats))
        return [];
      const c = [], l = yield this.sender.getStats();
      return l.forEach((v) => {
        var S;
        if (v.type === "outbound-rtp") {
          const g = {
            type: "video",
            streamId: v.id,
            frameHeight: v.frameHeight,
            frameWidth: v.frameWidth,
            firCount: v.firCount,
            pliCount: v.pliCount,
            nackCount: v.nackCount,
            packetsSent: v.packetsSent,
            bytesSent: v.bytesSent,
            framesSent: v.framesSent,
            timestamp: v.timestamp,
            rid: (S = v.rid) !== null && S !== void 0 ? S : v.id,
            retransmittedPacketsSent: v.retransmittedPacketsSent,
            qualityLimitationReason: v.qualityLimitationReason,
            qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges
          }, E = l.get(v.remoteId);
          E && (g.jitter = E.jitter, g.packetsLost = E.packetsLost, g.roundTripTime = E.roundTripTime), c.push(g);
        }
      }), c;
    });
  }
  setPublishingQuality(u) {
    const c = [];
    for (let l = VideoQuality.LOW; l <= VideoQuality.HIGH; l += 1)
      c.push(new SubscribedQuality({
        quality: l,
        enabled: l <= u
      }));
    this.log.debug("setting publishing quality. max quality ".concat(u), this.logContext), this.setPublishingLayers(c);
  }
  setDeviceId(u) {
    return __awaiter(this, void 0, void 0, function* () {
      return this._constraints.deviceId === u && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(u) ? !0 : (this._constraints.deviceId = u, this.isMuted || (yield this.restartTrack()), this.isMuted || unwrapConstraint(u) === this._mediaStreamTrack.getSettings().deviceId);
    });
  }
  restartTrack(u) {
    var c, l, v, S;
    return __awaiter(this, void 0, void 0, function* () {
      let g;
      if (u) {
        const L = constraintsForOptions({
          video: u
        });
        typeof L.video != "boolean" && (g = L.video);
      }
      yield this.restart(g);
      try {
        for (var E = !0, _ = __asyncValues(this.simulcastCodecs.values()), k; k = yield _.next(), c = k.done, !c; E = !0) {
          S = k.value, E = !1;
          const L = S;
          L.sender && (L.mediaStreamTrack = this.mediaStreamTrack.clone(), yield L.sender.replaceTrack(L.mediaStreamTrack));
        }
      } catch (L) {
        l = {
          error: L
        };
      } finally {
        try {
          !E && !c && (v = _.return) && (yield v.call(_));
        } finally {
          if (l)
            throw l.error;
        }
      }
    });
  }
  setProcessor(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const l = Object.create(null, {
      setProcessor: {
        get: () => super.setProcessor
      }
    });
    var v, S, g, E, _, k;
    return __awaiter(this, void 0, void 0, function* () {
      if (yield l.setProcessor.call(this, u, c), !((_ = this.processor) === null || _ === void 0) && _.processedTrack)
        try {
          for (var L = !0, M = __asyncValues(this.simulcastCodecs.values()), $; $ = yield M.next(), v = $.done, !v; L = !0)
            E = $.value, L = !1, yield (k = E.sender) === null || k === void 0 ? void 0 : k.replaceTrack(this.processor.processedTrack);
        } catch (J) {
          S = {
            error: J
          };
        } finally {
          try {
            !L && !v && (g = M.return) && (yield g.call(M));
          } finally {
            if (S)
              throw S.error;
          }
        }
    });
  }
  addSimulcastTrack(u, c) {
    if (this.simulcastCodecs.has(u)) {
      this.log.error("".concat(u, " already added, skipping adding simulcast codec"), this.logContext);
      return;
    }
    const l = {
      codec: u,
      mediaStreamTrack: this.mediaStreamTrack.clone(),
      sender: void 0,
      encodings: c
    };
    return this.simulcastCodecs.set(u, l), l;
  }
  setSimulcastTrackSender(u, c) {
    const l = this.simulcastCodecs.get(u);
    l && (l.sender = c, setTimeout(() => {
      this.subscribedCodecs && this.setPublishingCodecs(this.subscribedCodecs);
    }, refreshSubscribedCodecAfterNewCodec));
  }
  /**
   * @internal
   * Sets codecs that should be publishing, returns new codecs that have not yet
   * been published
   */
  setPublishingCodecs(u) {
    var c, l, v, S, g, E, _;
    return __awaiter(this, void 0, void 0, function* () {
      if (this.log.debug("setting publishing codecs", Object.assign(Object.assign({}, this.logContext), {
        codecs: u,
        currentCodec: this.codec
      })), !this.codec && u.length > 0)
        return yield this.setPublishingLayers(u[0].qualities), [];
      this.subscribedCodecs = u;
      const k = [];
      try {
        for (c = !0, l = __asyncValues(u); v = yield l.next(), S = v.done, !S; c = !0) {
          _ = v.value, c = !1;
          const L = _;
          if (!this.codec || this.codec === L.codec)
            yield this.setPublishingLayers(L.qualities);
          else {
            const M = this.simulcastCodecs.get(L.codec);
            if (this.log.debug("try setPublishingCodec for ".concat(L.codec), Object.assign(Object.assign({}, this.logContext), {
              simulcastCodecInfo: M
            })), !M || !M.sender) {
              for (const $ of L.qualities)
                if ($.enabled) {
                  k.push(L.codec);
                  break;
                }
            } else
              M.encodings && (this.log.debug("try setPublishingLayersForSender ".concat(L.codec), this.logContext), yield setPublishingLayersForSender(M.sender, M.encodings, L.qualities, this.senderLock, this.log, this.logContext));
          }
        }
      } catch (L) {
        g = {
          error: L
        };
      } finally {
        try {
          !c && !S && (E = l.return) && (yield E.call(l));
        } finally {
          if (g)
            throw g.error;
        }
      }
      return k;
    });
  }
  /**
   * @internal
   * Sets layers that should be publishing
   */
  setPublishingLayers(u) {
    return __awaiter(this, void 0, void 0, function* () {
      this.log.debug("setting publishing layers", Object.assign(Object.assign({}, this.logContext), {
        qualities: u
      })), !(!this.sender || !this.encodings) && (yield setPublishingLayersForSender(this.sender, this.encodings, u, this.senderLock, this.log, this.logContext));
    });
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), isMobile() && this.isInBackground && this.source === Track.Source.Camera && (this._mediaStreamTrack.enabled = !1);
    });
  }
}
function setPublishingLayersForSender(a, u, c, l, v, S) {
  return __awaiter(this, void 0, void 0, function* () {
    const g = yield l.lock();
    v.debug("setPublishingLayersForSender", Object.assign(Object.assign({}, S), {
      sender: a,
      qualities: c,
      senderEncodings: u
    }));
    try {
      const E = a.getParameters(), {
        encodings: _
      } = E;
      if (!_)
        return;
      if (_.length !== u.length) {
        v.warn("cannot set publishing layers, encodings mismatch");
        return;
      }
      let k = !1;
      !1 && _[0].scalabilityMode || _.forEach((M, $) => {
        var J;
        let V = (J = M.rid) !== null && J !== void 0 ? J : "";
        V === "" && (V = "q");
        const q = videoQualityForRid(V), G = c.find((H) => H.quality === q);
        G && M.active !== G.enabled && (k = !0, M.active = G.enabled, v.debug("setting layer ".concat(G.quality, " to ").concat(M.active ? "enabled" : "disabled"), S), isFireFox() && (G.enabled ? (M.scaleResolutionDownBy = u[$].scaleResolutionDownBy, M.maxBitrate = u[$].maxBitrate, M.maxFrameRate = u[$].maxFrameRate) : (M.scaleResolutionDownBy = 4, M.maxBitrate = 10, M.maxFrameRate = 2)));
      }), k && (E.encodings = _, v.debug("setting encodings", Object.assign(Object.assign({}, S), {
        encodings: E.encodings
      })), yield a.setParameters(E));
    } finally {
      g();
    }
  });
}
function videoQualityForRid(a) {
  switch (a) {
    case "f":
      return VideoQuality.HIGH;
    case "h":
      return VideoQuality.MEDIUM;
    case "q":
      return VideoQuality.LOW;
    default:
      return VideoQuality.HIGH;
  }
}
function videoLayersFromEncodings(a, u, c, l) {
  if (!c)
    return [new VideoLayer({
      quality: VideoQuality.HIGH,
      width: a,
      height: u,
      bitrate: 0,
      ssrc: 0
    })];
  if (l) {
    const v = c[0].scalabilityMode, S = new ScalabilityMode(v), g = [];
    for (let E = 0; E < S.spatial; E += 1)
      g.push(new VideoLayer({
        quality: VideoQuality.HIGH - E,
        width: Math.ceil(a / Math.pow(2, E)),
        height: Math.ceil(u / Math.pow(2, E)),
        bitrate: c[0].maxBitrate ? Math.ceil(c[0].maxBitrate / Math.pow(3, E)) : 0,
        ssrc: 0
      }));
    return g;
  }
  return c.map((v) => {
    var S, g, E;
    const _ = (S = v.scaleResolutionDownBy) !== null && S !== void 0 ? S : 1;
    let k = videoQualityForRid((g = v.rid) !== null && g !== void 0 ? g : "");
    return new VideoLayer({
      quality: k,
      width: Math.ceil(a / _),
      height: Math.ceil(u / _),
      bitrate: (E = v.maxBitrate) !== null && E !== void 0 ? E : 0,
      ssrc: 0
    });
  });
}
class RemoteTrack extends Track {
  constructor(u, c, l, v, S) {
    super(u, l, S), this.sid = c, this.receiver = v;
  }
  /** @internal */
  setMuted(u) {
    this.isMuted !== u && (this.isMuted = u, this._mediaStreamTrack.enabled = !u, this.emit(u ? TrackEvent.Muted : TrackEvent.Unmuted, this));
  }
  /** @internal */
  setMediaStream(u) {
    this.mediaStream = u;
    const c = (l) => {
      l.track === this._mediaStreamTrack && (u.removeEventListener("removetrack", c), this.receiver = void 0, this._currentBitrate = 0, this.emit(TrackEvent.Ended, this));
    };
    u.addEventListener("removetrack", c);
  }
  start() {
    this.startMonitor(), super.enable();
  }
  stop() {
    this.stopMonitor(), super.disable();
  }
  /**
   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver
   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport
   *
   * @returns Promise<RTCStatsReport> | undefined
   */
  getRTCStatsReport() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      return !((u = this.receiver) === null || u === void 0) && u.getStats ? yield this.receiver.getStats() : void 0;
    });
  }
  /* @internal */
  startMonitor() {
    this.monitorInterval || (this.monitorInterval = setInterval(() => this.monitorReceiver(), monitorFrequency));
  }
}
class RemoteAudioTrack extends RemoteTrack {
  constructor(u, c, l, v, S, g) {
    super(u, c, Track.Kind.Audio, l, g), this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const E = yield this.getReceiverStats();
      E && this.prevStats && this.receiver && (this._currentBitrate = computeBitrate(E, this.prevStats)), this.prevStats = E;
    }), this.audioContext = v, this.webAudioPluginNodes = [], S && (this.sinkId = S.deviceId);
  }
  /**
   * sets the volume for all attached audio elements
   */
  setVolume(u) {
    var c;
    for (const l of this.attachedElements)
      this.audioContext ? (c = this.gainNode) === null || c === void 0 || c.gain.setTargetAtTime(u, 0, 0.1) : l.volume = u;
    isReactNative() && this._mediaStreamTrack._setVolume(u), this.elementVolume = u;
  }
  /**
   * gets the volume of attached audio elements (loudest)
   */
  getVolume() {
    if (this.elementVolume)
      return this.elementVolume;
    if (isReactNative())
      return 1;
    let u = 0;
    return this.attachedElements.forEach((c) => {
      c.volume > u && (u = c.volume);
    }), u;
  }
  /**
   * calls setSinkId on all attached elements, if supported
   * @param deviceId audio output device
   */
  setSinkId(u) {
    return __awaiter(this, void 0, void 0, function* () {
      this.sinkId = u, yield Promise.all(this.attachedElements.map((c) => {
        if (supportsSetSinkId(c))
          return c.setSinkId(u);
      }));
    });
  }
  attach(u) {
    const c = this.attachedElements.length === 0;
    return u ? super.attach(u) : u = super.attach(), this.sinkId && supportsSetSinkId(u) && u.setSinkId(this.sinkId), this.audioContext && c && (this.log.debug("using audio context mapping", this.logContext), this.connectWebAudio(this.audioContext, u), u.volume = 0, u.muted = !0), this.elementVolume && this.setVolume(this.elementVolume), u;
  }
  detach(u) {
    let c;
    return u ? (c = super.detach(u), this.audioContext && (this.attachedElements.length > 0 ? this.connectWebAudio(this.audioContext, this.attachedElements[0]) : this.disconnectWebAudio())) : (c = super.detach(), this.disconnectWebAudio()), c;
  }
  /**
   * @internal
   * @experimental
   */
  setAudioContext(u) {
    this.audioContext = u, u && this.attachedElements.length > 0 ? this.connectWebAudio(u, this.attachedElements[0]) : u || this.disconnectWebAudio();
  }
  /**
   * @internal
   * @experimental
   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.
   */
  setWebAudioPlugins(u) {
    this.webAudioPluginNodes = u, this.attachedElements.length > 0 && this.audioContext && this.connectWebAudio(this.audioContext, this.attachedElements[0]);
  }
  connectWebAudio(u, c) {
    this.disconnectWebAudio(), this.sourceNode = u.createMediaStreamSource(c.srcObject);
    let l = this.sourceNode;
    this.webAudioPluginNodes.forEach((v) => {
      l.connect(v), l = v;
    }), this.gainNode = u.createGain(), l.connect(this.gainNode), this.gainNode.connect(u.destination), this.elementVolume && this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1), u.state !== "running" && u.resume().then(() => {
      u.state !== "running" && this.emit(TrackEvent.AudioPlaybackFailed, new Error("Audio Context couldn't be started automatically"));
    }).catch((v) => {
      this.emit(TrackEvent.AudioPlaybackFailed, v);
    });
  }
  disconnectWebAudio() {
    var u, c;
    (u = this.gainNode) === null || u === void 0 || u.disconnect(), (c = this.sourceNode) === null || c === void 0 || c.disconnect(), this.gainNode = void 0, this.sourceNode = void 0;
  }
  getReceiverStats() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats)
        return;
      const u = yield this.receiver.getStats();
      let c;
      return u.forEach((l) => {
        l.type === "inbound-rtp" && (c = {
          type: "audio",
          timestamp: l.timestamp,
          jitter: l.jitter,
          bytesReceived: l.bytesReceived,
          concealedSamples: l.concealedSamples,
          concealmentEvents: l.concealmentEvents,
          silentConcealedSamples: l.silentConcealedSamples,
          silentConcealmentEvents: l.silentConcealmentEvents,
          totalAudioEnergy: l.totalAudioEnergy,
          totalSamplesDuration: l.totalSamplesDuration
        });
      }), c;
    });
  }
}
const REACTION_DELAY = 100;
class RemoteVideoTrack extends RemoteTrack {
  constructor(u, c, l, v, S) {
    super(u, c, Track.Kind.Video, l, S), this.elementInfos = [], this.monitorReceiver = () => __awaiter(this, void 0, void 0, function* () {
      if (!this.receiver) {
        this._currentBitrate = 0;
        return;
      }
      const g = yield this.getReceiverStats();
      g && this.prevStats && this.receiver && (this._currentBitrate = computeBitrate(g, this.prevStats)), this.prevStats = g;
    }), this.debouncedHandleResize = r(() => {
      this.updateDimensions();
    }, REACTION_DELAY), this.adaptiveStreamSettings = v;
  }
  get isAdaptiveStream() {
    return this.adaptiveStreamSettings !== void 0;
  }
  /**
   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start
   */
  get mediaStreamTrack() {
    return this._mediaStreamTrack;
  }
  /** @internal */
  setMuted(u) {
    super.setMuted(u), this.attachedElements.forEach((c) => {
      u ? detachTrack(this._mediaStreamTrack, c) : attachToElement(this._mediaStreamTrack, c);
    });
  }
  attach(u) {
    if (u ? super.attach(u) : u = super.attach(), this.adaptiveStreamSettings && this.elementInfos.find((c) => c.element === u) === void 0) {
      const c = new HTMLElementInfo(u);
      this.observeElementInfo(c);
    }
    return u;
  }
  /**
   * Observe an ElementInfo for changes when adaptive streaming.
   * @param elementInfo
   * @internal
   */
  observeElementInfo(u) {
    this.adaptiveStreamSettings && this.elementInfos.find((c) => c === u) === void 0 ? (u.handleResize = () => {
      this.debouncedHandleResize();
    }, u.handleVisibilityChanged = () => {
      this.updateVisibility();
    }, this.elementInfos.push(u), u.observe(), this.debouncedHandleResize(), this.updateVisibility()) : this.log.warn("visibility resize observer not triggered", this.logContext);
  }
  /**
   * Stop observing an ElementInfo for changes.
   * @param elementInfo
   * @internal
   */
  stopObservingElementInfo(u) {
    if (!this.isAdaptiveStream) {
      this.log.warn("stopObservingElementInfo ignored", this.logContext);
      return;
    }
    const c = this.elementInfos.filter((l) => l === u);
    for (const l of c)
      l.stopObserving();
    this.elementInfos = this.elementInfos.filter((l) => l !== u), this.updateVisibility(), this.debouncedHandleResize();
  }
  detach(u) {
    let c = [];
    if (u)
      return this.stopObservingElement(u), super.detach(u);
    c = super.detach();
    for (const l of c)
      this.stopObservingElement(l);
    return c;
  }
  /** @internal */
  getDecoderImplementation() {
    var u;
    return (u = this.prevStats) === null || u === void 0 ? void 0 : u.decoderImplementation;
  }
  getReceiverStats() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.receiver || !this.receiver.getStats)
        return;
      const u = yield this.receiver.getStats();
      let c, l = "", v = /* @__PURE__ */ new Map();
      return u.forEach((S) => {
        S.type === "inbound-rtp" ? (l = S.codecId, c = {
          type: "video",
          framesDecoded: S.framesDecoded,
          framesDropped: S.framesDropped,
          framesReceived: S.framesReceived,
          packetsReceived: S.packetsReceived,
          packetsLost: S.packetsLost,
          frameWidth: S.frameWidth,
          frameHeight: S.frameHeight,
          pliCount: S.pliCount,
          firCount: S.firCount,
          nackCount: S.nackCount,
          jitter: S.jitter,
          timestamp: S.timestamp,
          bytesReceived: S.bytesReceived,
          decoderImplementation: S.decoderImplementation
        }) : S.type === "codec" && v.set(S.id, S);
      }), c && l !== "" && v.get(l) && (c.mimeType = v.get(l).mimeType), c;
    });
  }
  stopObservingElement(u) {
    const c = this.elementInfos.filter((l) => l.element === u);
    for (const l of c)
      this.stopObservingElementInfo(l);
  }
  handleAppVisibilityChanged() {
    const u = Object.create(null, {
      handleAppVisibilityChanged: {
        get: () => super.handleAppVisibilityChanged
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      yield u.handleAppVisibilityChanged.call(this), this.isAdaptiveStream && this.updateVisibility();
    });
  }
  updateVisibility() {
    var u, c;
    const l = this.elementInfos.reduce((E, _) => Math.max(E, _.visibilityChangedAt || 0), 0), v = !((c = (u = this.adaptiveStreamSettings) === null || u === void 0 ? void 0 : u.pauseVideoInBackground) !== null && c !== void 0) || c ? this.isInBackground : !1, S = this.elementInfos.some((E) => E.pictureInPicture), g = this.elementInfos.some((E) => E.visible) && !v || S;
    if (this.lastVisible !== g) {
      if (!g && Date.now() - l < REACTION_DELAY) {
        CriticalTimers.setTimeout(() => {
          this.updateVisibility();
        }, REACTION_DELAY);
        return;
      }
      this.lastVisible = g, this.emit(TrackEvent.VisibilityChanged, g, this);
    }
  }
  updateDimensions() {
    var u, c;
    let l = 0, v = 0;
    const S = this.getPixelDensity();
    for (const g of this.elementInfos) {
      const E = g.width() * S, _ = g.height() * S;
      E + _ > l + v && (l = E, v = _);
    }
    ((u = this.lastDimensions) === null || u === void 0 ? void 0 : u.width) === l && ((c = this.lastDimensions) === null || c === void 0 ? void 0 : c.height) === v || (this.lastDimensions = {
      width: l,
      height: v
    }, this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this));
  }
  getPixelDensity() {
    var u;
    const c = (u = this.adaptiveStreamSettings) === null || u === void 0 ? void 0 : u.pixelDensity;
    return c === "screen" ? getDevicePixelRatio() : c || (getDevicePixelRatio() > 2 ? 2 : 1);
  }
}
class HTMLElementInfo {
  get visible() {
    return this.isPiP || this.isIntersecting;
  }
  get pictureInPicture() {
    return this.isPiP;
  }
  constructor(u, c) {
    this.onVisibilityChanged = (l) => {
      var v;
      const {
        target: S,
        isIntersecting: g
      } = l;
      S === this.element && (this.isIntersecting = g, this.visibilityChangedAt = Date.now(), (v = this.handleVisibilityChanged) === null || v === void 0 || v.call(this));
    }, this.onEnterPiP = () => {
      var l;
      this.isPiP = !0, (l = this.handleVisibilityChanged) === null || l === void 0 || l.call(this);
    }, this.onLeavePiP = () => {
      var l;
      this.isPiP = !1, (l = this.handleVisibilityChanged) === null || l === void 0 || l.call(this);
    }, this.element = u, this.isIntersecting = c ?? isElementInViewport(u), this.isPiP = isWeb() && document.pictureInPictureElement === u, this.visibilityChangedAt = 0;
  }
  width() {
    return this.element.clientWidth;
  }
  height() {
    return this.element.clientHeight;
  }
  observe() {
    this.isIntersecting = isElementInViewport(this.element), this.isPiP = document.pictureInPictureElement === this.element, this.element.handleResize = () => {
      var u;
      (u = this.handleResize) === null || u === void 0 || u.call(this);
    }, this.element.handleVisibilityChanged = this.onVisibilityChanged, getIntersectionObserver().observe(this.element), getResizeObserver().observe(this.element), this.element.addEventListener("enterpictureinpicture", this.onEnterPiP), this.element.addEventListener("leavepictureinpicture", this.onLeavePiP);
  }
  stopObserving() {
    var u, c;
    (u = getIntersectionObserver()) === null || u === void 0 || u.unobserve(this.element), (c = getResizeObserver()) === null || c === void 0 || c.unobserve(this.element), this.element.removeEventListener("enterpictureinpicture", this.onEnterPiP), this.element.removeEventListener("leavepictureinpicture", this.onLeavePiP);
  }
}
function isElementInViewport(a) {
  let u = a.offsetTop, c = a.offsetLeft;
  const l = a.offsetWidth, v = a.offsetHeight, {
    hidden: S
  } = a, {
    opacity: g,
    display: E
  } = getComputedStyle(a);
  for (; a.offsetParent; )
    a = a.offsetParent, u += a.offsetTop, c += a.offsetLeft;
  return u < window.pageYOffset + window.innerHeight && c < window.pageXOffset + window.innerWidth && u + v > window.pageYOffset && c + l > window.pageXOffset && !S && (g !== "" ? parseFloat(g) > 0 : !0) && E !== "none";
}
class TrackPublication extends eventsExports.EventEmitter {
  constructor(u, c, l, v) {
    var S;
    super(), this.metadataMuted = !1, this.encryption = Encryption_Type.NONE, this.log = livekitLogger, this.handleMuted = () => {
      this.emit(TrackEvent.Muted);
    }, this.handleUnmuted = () => {
      this.emit(TrackEvent.Unmuted);
    }, this.log = getLogger((S = v == null ? void 0 : v.loggerName) !== null && S !== void 0 ? S : LoggerNames.Publication), this.loggerContextCb = this.loggerContextCb, this.setMaxListeners(100), this.kind = u, this.trackSid = c, this.trackName = l, this.source = Track.Source.Unknown;
  }
  /** @internal */
  setTrack(u) {
    this.track && (this.track.off(TrackEvent.Muted, this.handleMuted), this.track.off(TrackEvent.Unmuted, this.handleUnmuted)), this.track = u, u && (u.on(TrackEvent.Muted, this.handleMuted), u.on(TrackEvent.Unmuted, this.handleUnmuted));
  }
  get logContext() {
    var u;
    return Object.assign(Object.assign({}, (u = this.loggerContextCb) === null || u === void 0 ? void 0 : u.call(this)), getLogContextFromTrack(this));
  }
  get isMuted() {
    return this.metadataMuted;
  }
  get isEnabled() {
    return !0;
  }
  get isSubscribed() {
    return this.track !== void 0;
  }
  get isEncrypted() {
    return this.encryption !== Encryption_Type.NONE;
  }
  /**
   * an [AudioTrack] if this publication holds an audio track
   */
  get audioTrack() {
    if (this.track instanceof LocalAudioTrack || this.track instanceof RemoteAudioTrack)
      return this.track;
  }
  /**
   * an [VideoTrack] if this publication holds a video track
   */
  get videoTrack() {
    if (this.track instanceof LocalVideoTrack || this.track instanceof RemoteVideoTrack)
      return this.track;
  }
  /** @internal */
  updateInfo(u) {
    this.trackSid = u.sid, this.trackName = u.name, this.source = Track.sourceFromProto(u.source), this.mimeType = u.mimeType, this.kind === Track.Kind.Video && u.width > 0 && (this.dimensions = {
      width: u.width,
      height: u.height
    }, this.simulcasted = u.simulcast), this.encryption = u.encryption, this.trackInfo = u, this.log.debug("update publication info", Object.assign(Object.assign({}, this.logContext), {
      info: u
    }));
  }
}
(function(a) {
  (function(u) {
    u.Desired = "desired", u.Subscribed = "subscribed", u.Unsubscribed = "unsubscribed";
  })(a.SubscriptionStatus || (a.SubscriptionStatus = {})), function(u) {
    u.Allowed = "allowed", u.NotAllowed = "not_allowed";
  }(a.PermissionStatus || (a.PermissionStatus = {}));
})(TrackPublication || (TrackPublication = {}));
class LocalTrackPublication extends TrackPublication {
  get isUpstreamPaused() {
    var u;
    return (u = this.track) === null || u === void 0 ? void 0 : u.isUpstreamPaused;
  }
  constructor(u, c, l, v) {
    super(u, c.sid, c.name, v), this.track = void 0, this.handleTrackEnded = () => {
      this.emit(TrackEvent.Ended);
    }, this.updateInfo(c), this.setTrack(l);
  }
  setTrack(u) {
    this.track && this.track.off(TrackEvent.Ended, this.handleTrackEnded), super.setTrack(u), u && u.on(TrackEvent.Ended, this.handleTrackEnded);
  }
  get isMuted() {
    return this.track ? this.track.isMuted : super.isMuted;
  }
  get audioTrack() {
    return super.audioTrack;
  }
  get videoTrack() {
    return super.videoTrack;
  }
  /**
   * Mute the track associated with this publication
   */
  mute() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      return (u = this.track) === null || u === void 0 ? void 0 : u.mute();
    });
  }
  /**
   * Unmute track associated with this publication
   */
  unmute() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      return (u = this.track) === null || u === void 0 ? void 0 : u.unmute();
    });
  }
  /**
   * Pauses the media stream track associated with this publication from being sent to the server
   * and signals "muted" event to other participants
   * Useful if you want to pause the stream without pausing the local media stream track
   */
  pauseUpstream() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      yield (u = this.track) === null || u === void 0 ? void 0 : u.pauseUpstream();
    });
  }
  /**
   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]
   * and signals "unmuted" event to other participants (unless the track is explicitly muted)
   */
  resumeUpstream() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      yield (u = this.track) === null || u === void 0 ? void 0 : u.resumeUpstream();
    });
  }
}
var ConnectionQuality;
(function(a) {
  a.Excellent = "excellent", a.Good = "good", a.Poor = "poor", a.Lost = "lost", a.Unknown = "unknown";
})(ConnectionQuality || (ConnectionQuality = {}));
function qualityFromProto(a) {
  switch (a) {
    case ConnectionQuality$1.EXCELLENT:
      return ConnectionQuality.Excellent;
    case ConnectionQuality$1.GOOD:
      return ConnectionQuality.Good;
    case ConnectionQuality$1.POOR:
      return ConnectionQuality.Poor;
    case ConnectionQuality$1.LOST:
      return ConnectionQuality.Lost;
    default:
      return ConnectionQuality.Unknown;
  }
}
class Participant extends eventsExports.EventEmitter {
  get logContext() {
    var u, c;
    return Object.assign(Object.assign({}, (c = (u = this.loggerOptions) === null || u === void 0 ? void 0 : u.loggerContextCb) === null || c === void 0 ? void 0 : c.call(u)), {
      participantSid: this.sid,
      participantId: this.identity
    });
  }
  get isEncrypted() {
    return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((u) => u.isEncrypted);
  }
  get isAgent() {
    var u, c;
    return (c = (u = this.permissions) === null || u === void 0 ? void 0 : u.agent) !== null && c !== void 0 ? c : !1;
  }
  /** @internal */
  constructor(u, c, l, v, S) {
    var g;
    super(), this.audioLevel = 0, this.isSpeaking = !1, this._connectionQuality = ConnectionQuality.Unknown, this.log = livekitLogger, this.log = getLogger((g = S == null ? void 0 : S.loggerName) !== null && g !== void 0 ? g : LoggerNames.Participant), this.loggerOptions = S, this.setMaxListeners(100), this.sid = u, this.identity = c, this.name = l, this.metadata = v, this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map();
  }
  getTrackPublications() {
    return Array.from(this.trackPublications.values());
  }
  /**
   * Finds the first track that matches the source filter, for example, getting
   * the user's camera track with getTrackBySource(Track.Source.Camera).
   */
  getTrackPublication(u) {
    for (const [, c] of this.trackPublications)
      if (c.source === u)
        return c;
  }
  /**
   * Finds the first track that matches the track's name.
   */
  getTrackPublicationByName(u) {
    for (const [, c] of this.trackPublications)
      if (c.trackName === u)
        return c;
  }
  get connectionQuality() {
    return this._connectionQuality;
  }
  get isCameraEnabled() {
    var u;
    const c = this.getTrackPublication(Track.Source.Camera);
    return !(!((u = c == null ? void 0 : c.isMuted) !== null && u !== void 0) || u);
  }
  get isMicrophoneEnabled() {
    var u;
    const c = this.getTrackPublication(Track.Source.Microphone);
    return !(!((u = c == null ? void 0 : c.isMuted) !== null && u !== void 0) || u);
  }
  get isScreenShareEnabled() {
    return !!this.getTrackPublication(Track.Source.ScreenShare);
  }
  get isLocal() {
    return !1;
  }
  /** when participant joined the room */
  get joinedAt() {
    return this.participantInfo ? new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3) : /* @__PURE__ */ new Date();
  }
  /** @internal */
  updateInfo(u) {
    return this.participantInfo && this.participantInfo.sid === u.sid && this.participantInfo.version > u.version ? !1 : (this.identity = u.identity, this.sid = u.sid, this._setName(u.name), this._setMetadata(u.metadata), u.permission && this.setPermissions(u.permission), this.participantInfo = u, this.log.trace("update participant info", Object.assign(Object.assign({}, this.logContext), {
      info: u
    })), !0);
  }
  /**
   * Updates metadata from server
   **/
  _setMetadata(u) {
    const c = this.metadata !== u, l = this.metadata;
    this.metadata = u, c && this.emit(ParticipantEvent.ParticipantMetadataChanged, l);
  }
  _setName(u) {
    const c = this.name !== u;
    this.name = u, c && this.emit(ParticipantEvent.ParticipantNameChanged, u);
  }
  /** @internal */
  setPermissions(u) {
    var c, l, v, S, g;
    const E = this.permissions, _ = u.canPublish !== ((c = this.permissions) === null || c === void 0 ? void 0 : c.canPublish) || u.canSubscribe !== ((l = this.permissions) === null || l === void 0 ? void 0 : l.canSubscribe) || u.canPublishData !== ((v = this.permissions) === null || v === void 0 ? void 0 : v.canPublishData) || u.hidden !== ((S = this.permissions) === null || S === void 0 ? void 0 : S.hidden) || u.recorder !== ((g = this.permissions) === null || g === void 0 ? void 0 : g.recorder) || u.canPublishSources.length !== this.permissions.canPublishSources.length || u.canPublishSources.some((k, L) => {
      var M;
      return k !== ((M = this.permissions) === null || M === void 0 ? void 0 : M.canPublishSources[L]);
    });
    return this.permissions = u, _ && this.emit(ParticipantEvent.ParticipantPermissionsChanged, E), _;
  }
  /** @internal */
  setIsSpeaking(u) {
    u !== this.isSpeaking && (this.isSpeaking = u, u && (this.lastSpokeAt = /* @__PURE__ */ new Date()), this.emit(ParticipantEvent.IsSpeakingChanged, u));
  }
  /** @internal */
  setConnectionQuality(u) {
    const c = this._connectionQuality;
    this._connectionQuality = qualityFromProto(u), c !== this._connectionQuality && this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);
  }
  /**
   * @internal
   */
  setAudioContext(u) {
    this.audioContext = u, this.audioTrackPublications.forEach((c) => (c.track instanceof RemoteAudioTrack || c.track instanceof LocalAudioTrack) && c.track.setAudioContext(u));
  }
  addTrackPublication(u) {
    u.on(TrackEvent.Muted, () => {
      this.emit(ParticipantEvent.TrackMuted, u);
    }), u.on(TrackEvent.Unmuted, () => {
      this.emit(ParticipantEvent.TrackUnmuted, u);
    });
    const c = u;
    switch (c.track && (c.track.sid = u.trackSid), this.trackPublications.set(u.trackSid, u), u.kind) {
      case Track.Kind.Audio:
        this.audioTrackPublications.set(u.trackSid, u);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.set(u.trackSid, u);
        break;
    }
  }
}
function trackPermissionToProto(a) {
  var u, c, l;
  if (!a.participantSid && !a.participantIdentity)
    throw new Error("Invalid track permission, must provide at least one of participantIdentity and participantSid");
  return new TrackPermission({
    participantIdentity: (u = a.participantIdentity) !== null && u !== void 0 ? u : "",
    participantSid: (c = a.participantSid) !== null && c !== void 0 ? c : "",
    allTracks: (l = a.allowAll) !== null && l !== void 0 ? l : !1,
    trackSids: a.allowedTrackSids || []
  });
}
class LocalParticipant extends Participant {
  /** @internal */
  constructor(u, c, l, v) {
    super(u, c, void 0, void 0, {
      loggerName: v.loggerName,
      loggerContextCb: () => this.engine.logContext
    }), this.pendingPublishing = /* @__PURE__ */ new Set(), this.pendingPublishPromises = /* @__PURE__ */ new Map(), this.participantTrackPermissions = [], this.allParticipantsAllowedToSubscribe = !0, this.encryptionType = Encryption_Type.NONE, this.handleReconnecting = () => {
      this.reconnectFuture || (this.reconnectFuture = new Future());
    }, this.handleReconnected = () => {
      var S, g;
      (g = (S = this.reconnectFuture) === null || S === void 0 ? void 0 : S.resolve) === null || g === void 0 || g.call(S), this.reconnectFuture = void 0, this.updateTrackSubscriptionPermissions();
    }, this.handleDisconnected = () => {
      var S, g;
      this.reconnectFuture && (this.reconnectFuture.promise.catch((E) => this.log.warn(E.message, this.logContext)), (g = (S = this.reconnectFuture) === null || S === void 0 ? void 0 : S.reject) === null || g === void 0 || g.call(S, "Got disconnected during reconnection attempt"), this.reconnectFuture = void 0);
    }, this.updateTrackSubscriptionPermissions = () => {
      this.log.debug("updating track subscription permissions", Object.assign(Object.assign({}, this.logContext), {
        allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
        participantTrackPermissions: this.participantTrackPermissions
      })), this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((S) => trackPermissionToProto(S)));
    }, this.onTrackUnmuted = (S) => {
      this.onTrackMuted(S, S.isUpstreamPaused);
    }, this.onTrackMuted = (S, g) => {
      if (g === void 0 && (g = !0), !S.sid) {
        this.log.error("could not update mute status for unpublished track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S)));
        return;
      }
      this.engine.updateMuteStatus(S.sid, g);
    }, this.onTrackUpstreamPaused = (S) => {
      this.log.debug("upstream paused", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S))), this.onTrackMuted(S, !0);
    }, this.onTrackUpstreamResumed = (S) => {
      this.log.debug("upstream resumed", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S))), this.onTrackMuted(S, S.isMuted);
    }, this.handleSubscribedQualityUpdate = (S) => __awaiter(this, void 0, void 0, function* () {
      var g, E, _, k, L, M;
      if (!(!((L = this.roomOptions) === null || L === void 0) && L.dynacast))
        return;
      const $ = this.videoTrackPublications.get(S.trackSid);
      if (!$) {
        this.log.warn("received subscribed quality update for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: S.trackSid
        }));
        return;
      }
      if (S.subscribedCodecs.length > 0) {
        if (!$.videoTrack)
          return;
        const G = yield $.videoTrack.setPublishingCodecs(S.subscribedCodecs);
        try {
          for (var J = !0, V = __asyncValues(G), q; q = yield V.next(), g = q.done, !g; J = !0) {
            k = q.value, J = !1;
            const H = k;
            isBackupCodec(H) && (this.log.debug("publish ".concat(H, " for ").concat($.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack($))), yield this.publishAdditionalCodecForTrack($.videoTrack, H, $.options));
          }
        } catch (H) {
          E = {
            error: H
          };
        } finally {
          try {
            !J && !g && (_ = V.return) && (yield _.call(V));
          } finally {
            if (E)
              throw E.error;
          }
        }
      } else
        S.subscribedQualities.length > 0 && (yield (M = $.videoTrack) === null || M === void 0 ? void 0 : M.setPublishingLayers(S.subscribedQualities));
    }), this.handleLocalTrackUnpublished = (S) => {
      const g = this.trackPublications.get(S.trackSid);
      if (!g) {
        this.log.warn("received unpublished event for unknown track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: S.trackSid
        }));
        return;
      }
      this.unpublishTrack(g.track);
    }, this.handleTrackEnded = (S) => __awaiter(this, void 0, void 0, function* () {
      if (S.source === Track.Source.ScreenShare || S.source === Track.Source.ScreenShareAudio)
        this.log.debug("unpublishing local track due to TrackEnded", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S))), this.unpublishTrack(S);
      else if (S.isUserProvided)
        yield S.mute();
      else if (S instanceof LocalAudioTrack || S instanceof LocalVideoTrack)
        try {
          if (isWeb())
            try {
              const g = yield navigator == null ? void 0 : navigator.permissions.query({
                // the permission query for camera and microphone currently not supported in Safari and Firefox
                // @ts-ignore
                name: S.source === Track.Source.Camera ? "camera" : "microphone"
              });
              if (g && g.state === "denied")
                throw this.log.warn("user has revoked access to ".concat(S.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S))), g.onchange = () => {
                  g.state !== "denied" && (S.isMuted || S.restartTrack(), g.onchange = null);
                }, new Error("GetUserMedia Permission denied");
            } catch {
            }
          S.isMuted || (this.log.debug("track ended, attempting to use a different device", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S))), yield S.restartTrack());
        } catch {
          this.log.warn("could not restart track, muting instead", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S))), yield S.mute();
        }
    }), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.trackPublications = /* @__PURE__ */ new Map(), this.engine = l, this.roomOptions = v, this.setupEngine(l), this.activeDeviceMap = /* @__PURE__ */ new Map();
  }
  get lastCameraError() {
    return this.cameraError;
  }
  get lastMicrophoneError() {
    return this.microphoneError;
  }
  get isE2EEEnabled() {
    return this.encryptionType !== Encryption_Type.NONE;
  }
  getTrackPublication(u) {
    const c = super.getTrackPublication(u);
    if (c)
      return c;
  }
  getTrackPublicationByName(u) {
    const c = super.getTrackPublicationByName(u);
    if (c)
      return c;
  }
  /**
   * @internal
   */
  setupEngine(u) {
    this.engine = u, this.engine.on(EngineEvent.RemoteMute, (c, l) => {
      const v = this.trackPublications.get(c);
      !v || !v.track || (l ? v.mute() : v.unmute());
    }), this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected);
  }
  /**
   * Sets and updates the metadata of the local participant.
   * The change does not take immediate effect.
   * If successful, a `ParticipantEvent.MetadataChanged` event will be emitted on the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * @param metadata
   */
  setMetadata(u) {
    var c;
    this.engine.client.sendUpdateLocalMetadata(u, (c = this.name) !== null && c !== void 0 ? c : "");
  }
  /**
   * Sets and updates the name of the local participant.
   * The change does not take immediate effect.
   * If successful, a `ParticipantEvent.ParticipantNameChanged` event will be emitted on the local participant.
   * Note: this requires `canUpdateOwnMetadata` permission.
   * @param metadata
   */
  setName(u) {
    var c;
    this.engine.client.sendUpdateLocalMetadata((c = this.metadata) !== null && c !== void 0 ? c : "", u);
  }
  /**
   * Enable or disable a participant's camera track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setCameraEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.Camera, u, c, l);
  }
  /**
   * Enable or disable a participant's microphone track.
   *
   * If a track has already published, it'll mute or unmute the track.
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setMicrophoneEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.Microphone, u, c, l);
  }
  /**
   * Start or stop sharing a participant's screen
   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise
   */
  setScreenShareEnabled(u, c, l) {
    return this.setTrackEnabled(Track.Source.ScreenShare, u, c, l);
  }
  /** @internal */
  setPermissions(u) {
    const c = this.permissions, l = super.setPermissions(u);
    return l && c && this.emit(ParticipantEvent.ParticipantPermissionsChanged, c), l;
  }
  /** @internal */
  setE2EEEnabled(u) {
    return __awaiter(this, void 0, void 0, function* () {
      this.encryptionType = u ? Encryption_Type.GCM : Encryption_Type.NONE, yield this.republishAllTracks(void 0, !1);
    });
  }
  setTrackEnabled(u, c, l, v) {
    var S, g;
    return __awaiter(this, void 0, void 0, function* () {
      this.log.debug("setTrackEnabled", Object.assign(Object.assign({}, this.logContext), {
        source: u,
        enabled: c
      }));
      let E = this.getTrackPublication(u);
      if (c)
        if (E)
          yield E.unmute();
        else {
          let _;
          if (this.pendingPublishing.has(u)) {
            this.log.info("skipping duplicate published source", Object.assign(Object.assign({}, this.logContext), {
              source: u
            }));
            return;
          }
          this.pendingPublishing.add(u);
          try {
            switch (u) {
              case Track.Source.Camera:
                _ = yield this.createTracks({
                  video: (S = l) !== null && S !== void 0 ? S : !0
                });
                break;
              case Track.Source.Microphone:
                _ = yield this.createTracks({
                  audio: (g = l) !== null && g !== void 0 ? g : !0
                });
                break;
              case Track.Source.ScreenShare:
                _ = yield this.createScreenTracks(Object.assign({}, l));
                break;
              default:
                throw new TrackInvalidError(u);
            }
            const k = [];
            for (const M of _)
              this.log.info("publishing track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(M))), k.push(this.publishTrack(M, v));
            [E] = yield Promise.all(k);
          } catch (k) {
            throw _ == null || _.forEach((L) => {
              L.stop();
            }), k instanceof Error && !(k instanceof TrackInvalidError) && this.emit(ParticipantEvent.MediaDevicesError, k), k;
          } finally {
            this.pendingPublishing.delete(u);
          }
        }
      else if (E && E.track)
        if (u === Track.Source.ScreenShare) {
          E = yield this.unpublishTrack(E.track);
          const _ = this.getTrackPublication(Track.Source.ScreenShareAudio);
          _ && _.track && this.unpublishTrack(_.track);
        } else
          yield E.mute();
      return E;
    });
  }
  /**
   * Publish both camera and microphone at the same time. This is useful for
   * displaying a single Permission Dialog box to the end user.
   */
  enableCameraAndMicrophone() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!(this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone))) {
        this.pendingPublishing.add(Track.Source.Camera), this.pendingPublishing.add(Track.Source.Microphone);
        try {
          const u = yield this.createTracks({
            audio: !0,
            video: !0
          });
          yield Promise.all(u.map((c) => this.publishTrack(c)));
        } finally {
          this.pendingPublishing.delete(Track.Source.Camera), this.pendingPublishing.delete(Track.Source.Microphone);
        }
      }
    });
  }
  /**
   * Create local camera and/or microphone tracks
   * @param options
   * @returns
   */
  createTracks(u) {
    var c, l;
    return __awaiter(this, void 0, void 0, function* () {
      const v = mergeDefaultOptions(u, (c = this.roomOptions) === null || c === void 0 ? void 0 : c.audioCaptureDefaults, (l = this.roomOptions) === null || l === void 0 ? void 0 : l.videoCaptureDefaults), S = constraintsForOptions(v);
      let g;
      try {
        g = yield navigator.mediaDevices.getUserMedia(S);
      } catch (E) {
        throw E instanceof Error && (S.audio && (this.microphoneError = E), S.video && (this.cameraError = E)), E;
      }
      return S.audio && (this.microphoneError = void 0, this.emit(ParticipantEvent.AudioStreamAcquired)), S.video && (this.cameraError = void 0), g.getTracks().map((E) => {
        const _ = E.kind === "audio";
        _ ? u.audio : u.video;
        let k;
        const L = _ ? S.audio : S.video;
        typeof L != "boolean" && (k = L);
        const M = mediaTrackToLocalTrack(E, k, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        return M.kind === Track.Kind.Video ? M.source = Track.Source.Camera : M.kind === Track.Kind.Audio && (M.source = Track.Source.Microphone), M.mediaStream = g, M;
      });
    });
  }
  /**
   * Creates a screen capture tracks with getDisplayMedia().
   * A LocalVideoTrack is always created and returned.
   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.
   */
  createScreenTracks(u) {
    return __awaiter(this, void 0, void 0, function* () {
      if (u === void 0 && (u = {}), navigator.mediaDevices.getDisplayMedia === void 0)
        throw new DeviceUnsupportedError("getDisplayMedia not supported");
      u.resolution === void 0 && !isSafari17() && (u.resolution = ScreenSharePresets.h1080fps30.resolution);
      const c = screenCaptureToDisplayMediaStreamOptions(u), l = yield navigator.mediaDevices.getDisplayMedia(c), v = l.getVideoTracks();
      if (v.length === 0)
        throw new TrackInvalidError("no video track found");
      const S = new LocalVideoTrack(v[0], void 0, !1, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      S.source = Track.Source.ScreenShare, u.contentHint && (S.mediaStreamTrack.contentHint = u.contentHint);
      const g = [S];
      if (l.getAudioTracks().length > 0) {
        this.emit(ParticipantEvent.AudioStreamAcquired);
        const E = new LocalAudioTrack(l.getAudioTracks()[0], void 0, !1, this.audioContext, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
        E.source = Track.Source.ScreenShareAudio, g.push(E);
      }
      return g;
    });
  }
  /**
   * Publish a new track to the room
   * @param track
   * @param options
   */
  publishTrack(u, c) {
    var l, v, S, g;
    return __awaiter(this, void 0, void 0, function* () {
      yield (l = this.reconnectFuture) === null || l === void 0 ? void 0 : l.promise, u instanceof LocalTrack && this.pendingPublishPromises.has(u) && (yield this.pendingPublishPromises.get(u));
      let E;
      if (u instanceof MediaStreamTrack)
        E = u.getConstraints();
      else {
        E = u.constraints;
        let J;
        switch (u.source) {
          case Track.Source.Microphone:
            J = "audioinput";
            break;
          case Track.Source.Camera:
            J = "videoinput";
        }
        J && this.activeDeviceMap.has(J) && (E = Object.assign(Object.assign({}, E), {
          deviceId: this.activeDeviceMap.get(J)
        }));
      }
      if (u instanceof MediaStreamTrack)
        switch (u.kind) {
          case "audio":
            u = new LocalAudioTrack(u, E, !0, this.audioContext, {
              loggerName: this.roomOptions.loggerName,
              loggerContextCb: () => this.logContext
            });
            break;
          case "video":
            u = new LocalVideoTrack(u, E, !0, {
              loggerName: this.roomOptions.loggerName,
              loggerContextCb: () => this.logContext
            });
            break;
          default:
            throw new TrackInvalidError("unsupported MediaStreamTrack kind ".concat(u.kind));
        }
      else
        u.updateLoggerOptions({
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext
        });
      u instanceof LocalAudioTrack && u.setAudioContext(this.audioContext);
      let _;
      if (this.trackPublications.forEach((J) => {
        J.track && J.track === u && (_ = J);
      }), _)
        return this.log.warn("track has already been published, skipping", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(_))), _;
      const k = "channelCount" in u.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount
      u.mediaStreamTrack.getSettings().channelCount === 2 || u.mediaStreamTrack.getConstraints().channelCount === 2, L = (v = c == null ? void 0 : c.forceStereo) !== null && v !== void 0 ? v : k;
      L && (c || (c = {}), c.dtx === void 0 && this.log.info("Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), c.red === void 0 && this.log.info("Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work."), (S = c.dtx) !== null && S !== void 0 || (c.dtx = !1), (g = c.red) !== null && g !== void 0 || (c.red = !1));
      const M = Object.assign(Object.assign({}, this.roomOptions.publishDefaults), c);
      isSafari() && this.roomOptions.e2ee && (this.log.info("End-to-end encryption is set up, simulcast publishing will be disabled on Safari", Object.assign({}, this.logContext)), M.simulcast = !1), M.source && (u.source = M.source);
      const $ = this.publish(u, M, L);
      this.pendingPublishPromises.set(u, $);
      try {
        return yield $;
      } catch (J) {
        throw J;
      } finally {
        this.pendingPublishPromises.delete(u);
      }
    });
  }
  publish(u, c, l) {
    var v, S, g, E, _, k, L, M, $, J, V, q;
    return __awaiter(this, void 0, void 0, function* () {
      Array.from(this.trackPublications.values()).find((oe) => u instanceof LocalTrack && oe.source === u.source) && u.source !== Track.Source.Unknown && this.log.info("publishing a second track with the same source: ".concat(u.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), c.stopMicTrackOnMute && u instanceof LocalAudioTrack && (u.stopOnMute = !0), u.source === Track.Source.ScreenShare && isFireFox() && (c.simulcast = !1), c.videoCodec === "av1" && !supportsAV1() && (c.videoCodec = void 0), c.videoCodec === "vp9" && !supportsVP9() && (c.videoCodec = void 0), c.videoCodec === void 0 && (c.videoCodec = defaultVideoCodec);
      const H = c.videoCodec;
      u.on(TrackEvent.Muted, this.onTrackMuted), u.on(TrackEvent.Unmuted, this.onTrackUnmuted), u.on(TrackEvent.Ended, this.handleTrackEnded), u.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused), u.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);
      const B = new AddTrackRequest({
        // get local track id for use during publishing
        cid: u.mediaStreamTrack.id,
        name: c.name,
        type: Track.kindToProto(u.kind),
        muted: u.isMuted,
        source: Track.sourceToProto(u.source),
        disableDtx: !(!((v = c.dtx) !== null && v !== void 0) || v),
        encryption: this.encryptionType,
        stereo: l,
        disableRed: this.isE2EEEnabled || !(!((S = c.red) !== null && S !== void 0) || S),
        stream: c == null ? void 0 : c.stream
      });
      let Y;
      if (u.kind === Track.Kind.Video) {
        let oe = {
          width: 0,
          height: 0
        };
        try {
          oe = yield u.waitForDimensions();
        } catch {
          const A = (E = (g = this.roomOptions.videoCaptureDefaults) === null || g === void 0 ? void 0 : g.resolution) !== null && E !== void 0 ? E : VideoPresets.h720.resolution;
          oe = {
            width: A.width,
            height: A.height
          }, this.log.error("could not determine track dimensions, using defaults", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)), {
            dims: oe
          }));
        }
        B.width = oe.width, B.height = oe.height, u instanceof LocalVideoTrack && (isSVCCodec(H) && (u.source === Track.Source.ScreenShare && H === "vp9" && (c.scalabilityMode = "L1T3"), c.scalabilityMode = (_ = c.scalabilityMode) !== null && _ !== void 0 ? _ : "L3T3_KEY"), B.simulcastCodecs = [new SimulcastCodec({
          codec: H,
          cid: u.mediaStreamTrack.id
        })], c.backupCodec === !0 && (c.backupCodec = {
          codec: defaultVideoCodec
        }), c.backupCodec && H !== c.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs
        B.encryption === Encryption_Type.NONE && (this.roomOptions.dynacast || (this.roomOptions.dynacast = !0), B.simulcastCodecs.push(new SimulcastCodec({
          codec: c.backupCodec.codec,
          cid: ""
        })))), Y = computeVideoEncodings(u.source === Track.Source.ScreenShare, B.width, B.height, c), B.layers = videoLayersFromEncodings(B.width, B.height, Y, isSVCCodec(c.videoCodec));
      } else
        u.kind === Track.Kind.Audio && (Y = [{
          maxBitrate: (k = c.audioPreset) === null || k === void 0 ? void 0 : k.maxBitrate,
          priority: (M = (L = c.audioPreset) === null || L === void 0 ? void 0 : L.priority) !== null && M !== void 0 ? M : "high",
          networkPriority: (J = ($ = c.audioPreset) === null || $ === void 0 ? void 0 : $.priority) !== null && J !== void 0 ? J : "high"
        }]);
      if (!this.engine || this.engine.isClosed)
        throw new UnexpectedConnectionState("cannot publish track when not connected");
      const ne = yield this.engine.addTrack(B);
      let Z;
      if (ne.codecs.forEach((oe) => {
        Z === void 0 && (Z = oe.mimeType);
      }), Z && u.kind === Track.Kind.Video) {
        const oe = mimeTypeToVideoCodecString(Z);
        oe !== H && (this.log.debug("falling back to server selected codec", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)), {
          codec: oe
        })), c.videoCodec = oe, Y = computeVideoEncodings(u.source === Track.Source.ScreenShare, B.width, B.height, c));
      }
      const re = new LocalTrackPublication(u.kind, ne, u, {
        loggerName: this.roomOptions.loggerName,
        loggerContextCb: () => this.logContext
      });
      if (re.options = c, u.sid = ne.sid, !this.engine.pcManager)
        throw new UnexpectedConnectionState("pcManager is not ready");
      if (this.log.debug("publishing ".concat(u.kind, " with encodings"), Object.assign(Object.assign({}, this.logContext), {
        encodings: Y,
        trackInfo: ne
      })), u.sender = yield this.engine.createSender(u, c, Y), Y)
        if (isFireFox() && u.kind === Track.Kind.Audio) {
          let oe;
          for (const de of this.engine.pcManager.publisher.getTransceivers())
            if (de.sender === u.sender) {
              oe = de;
              break;
            }
          oe && this.engine.pcManager.publisher.setTrackCodecBitrate({
            transceiver: oe,
            codec: "opus",
            maxbr: !((V = Y[0]) === null || V === void 0) && V.maxBitrate ? Y[0].maxBitrate / 1e3 : 0
          });
        } else
          u.codec && isSVCCodec(u.codec) && (!((q = Y[0]) === null || q === void 0) && q.maxBitrate) && this.engine.pcManager.publisher.setTrackCodecBitrate({
            cid: B.cid,
            codec: u.codec,
            maxbr: Y[0].maxBitrate / 1e3
          });
      return yield this.engine.negotiate(), u instanceof LocalVideoTrack ? u.startMonitor(this.engine.client) : u instanceof LocalAudioTrack && u.startMonitor(), this.addTrackPublication(re), this.emit(ParticipantEvent.LocalTrackPublished, re), re;
    });
  }
  get isLocal() {
    return !0;
  }
  /** @internal
   * publish additional codec to existing track
   */
  publishAdditionalCodecForTrack(u, c, l) {
    var v;
    return __awaiter(this, void 0, void 0, function* () {
      if (this.encryptionType !== Encryption_Type.NONE)
        return;
      let S;
      if (this.trackPublications.forEach((M) => {
        M.track && M.track === u && (S = M);
      }), !S)
        throw new TrackInvalidError("track is not published");
      if (!(u instanceof LocalVideoTrack))
        throw new TrackInvalidError("track is not a video track");
      const g = Object.assign(Object.assign({}, (v = this.roomOptions) === null || v === void 0 ? void 0 : v.publishDefaults), l), E = computeTrackBackupEncodings(u, c, g);
      if (!E) {
        this.log.info("backup codec has been disabled, ignoring request to add additional codec for track", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u)));
        return;
      }
      const _ = u.addSimulcastTrack(c, E);
      if (!_)
        return;
      const k = new AddTrackRequest({
        cid: _.mediaStreamTrack.id,
        type: Track.kindToProto(u.kind),
        muted: u.isMuted,
        source: Track.sourceToProto(u.source),
        sid: u.sid,
        simulcastCodecs: [{
          codec: g.videoCodec,
          cid: _.mediaStreamTrack.id
        }]
      });
      if (k.layers = videoLayersFromEncodings(k.width, k.height, E), !this.engine || this.engine.isClosed)
        throw new UnexpectedConnectionState("cannot publish track when not connected");
      const L = yield this.engine.addTrack(k);
      yield this.engine.createSimulcastSender(u, _, g, E), yield this.engine.negotiate(), this.log.debug("published ".concat(c, " for track ").concat(u.sid), Object.assign(Object.assign({}, this.logContext), {
        encodings: E,
        trackInfo: L
      }));
    });
  }
  unpublishTrack(u, c) {
    var l, v;
    return __awaiter(this, void 0, void 0, function* () {
      const S = this.getPublicationForTrack(u), g = S ? getLogContextFromTrack(S) : void 0;
      if (this.log.debug("unpublishing track", Object.assign(Object.assign({}, this.logContext), g)), !S || !S.track) {
        this.log.warn("track was not unpublished because no publication was found", Object.assign(Object.assign({}, this.logContext), g));
        return;
      }
      u = S.track, u.off(TrackEvent.Muted, this.onTrackMuted), u.off(TrackEvent.Unmuted, this.onTrackUnmuted), u.off(TrackEvent.Ended, this.handleTrackEnded), u.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused), u.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed), c === void 0 && (c = (v = (l = this.roomOptions) === null || l === void 0 ? void 0 : l.stopLocalTrackOnUnpublish) !== null && v !== void 0 ? v : !0), c && u.stop();
      let E = !1;
      const _ = u.sender;
      if (u.sender = void 0, this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && _)
        try {
          for (const k of this.engine.pcManager.publisher.getTransceivers())
            k.sender === _ && (k.direction = "inactive", E = !0);
          if (this.engine.removeTrack(_) && (E = !0), u instanceof LocalVideoTrack) {
            for (const [, k] of u.simulcastCodecs)
              k.sender && (this.engine.removeTrack(k.sender) && (E = !0), k.sender = void 0);
            u.simulcastCodecs.clear();
          }
        } catch (k) {
          this.log.warn("failed to unpublish track", Object.assign(Object.assign(Object.assign({}, this.logContext), g), {
            error: k
          }));
        }
      switch (this.trackPublications.delete(S.trackSid), S.kind) {
        case Track.Kind.Audio:
          this.audioTrackPublications.delete(S.trackSid);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.delete(S.trackSid);
          break;
      }
      return this.emit(ParticipantEvent.LocalTrackUnpublished, S), S.setTrack(void 0), E && (yield this.engine.negotiate()), S;
    });
  }
  unpublishTracks(u) {
    return __awaiter(this, void 0, void 0, function* () {
      return (yield Promise.all(u.map((l) => this.unpublishTrack(l)))).filter((l) => l instanceof LocalTrackPublication);
    });
  }
  republishAllTracks(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return __awaiter(this, void 0, void 0, function* () {
      const l = [];
      this.trackPublications.forEach((v) => {
        v.track && (u && (v.options = Object.assign(Object.assign({}, v.options), u)), l.push(v));
      }), yield Promise.all(l.map((v) => __awaiter(this, void 0, void 0, function* () {
        const S = v.track;
        yield this.unpublishTrack(S, !1), c && !S.isMuted && S.source !== Track.Source.ScreenShare && S.source !== Track.Source.ScreenShareAudio && (S instanceof LocalAudioTrack || S instanceof LocalVideoTrack) && !S.isUserProvided && (this.log.debug("restarting existing track", Object.assign(Object.assign({}, this.logContext), {
          track: v.trackSid
        })), yield S.restartTrack()), yield this.publishTrack(S, v.options);
      })));
    });
  }
  /**
   * Publish a new data payload to the room. Data will be forwarded to each
   * participant in the room if the destination field in publishOptions is empty
   *
   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode
   * @param options optionally specify a `reliable`, `topic` and `destination`
   */
  publishData(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return __awaiter(this, void 0, void 0, function* () {
      const l = c.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY, v = c.destinationIdentities, S = c.topic, g = new DataPacket({
        kind: l,
        value: {
          case: "user",
          value: new UserPacket({
            participantIdentity: this.identity,
            payload: u,
            destinationIdentities: v,
            topic: S
          })
        }
      });
      yield this.engine.sendDataPacket(g, l);
    });
  }
  /**
   * Control who can subscribe to LocalParticipant's published tracks.
   *
   * By default, all participants can subscribe. This allows fine-grained control over
   * who is able to subscribe at a participant and track level.
   *
   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and
   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks
   * will not grant permissions to any participants and will require a subsequent
   * permissions update to allow subscription.
   *
   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.
   *  Takes precedence over [[participantTrackPermissions]] if set to true.
   *  By default this is set to true.
   * @param participantTrackPermissions Full list of individual permissions per
   *  participant/track. Any omitted participants will not receive any permissions.
   */
  setTrackSubscriptionPermissions(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    this.participantTrackPermissions = c, this.allParticipantsAllowedToSubscribe = u, this.engine.client.isDisconnected || this.updateTrackSubscriptionPermissions();
  }
  /** @internal */
  updateInfo(u) {
    return u.sid !== this.sid || !super.updateInfo(u) ? !1 : (u.tracks.forEach((c) => {
      var l, v;
      const S = this.trackPublications.get(c.sid);
      if (S) {
        const g = S.isMuted || ((v = (l = S.track) === null || l === void 0 ? void 0 : l.isUpstreamPaused) !== null && v !== void 0 ? v : !1);
        g !== c.muted && (this.log.debug("updating server mute state after reconcile", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(S)), {
          mutedOnServer: g
        })), this.engine.client.sendMuteTrack(c.sid, g));
      }
    }), !0);
  }
  getPublicationForTrack(u) {
    let c;
    return this.trackPublications.forEach((l) => {
      const v = l.track;
      v && (u instanceof MediaStreamTrack ? (v instanceof LocalAudioTrack || v instanceof LocalVideoTrack) && v.mediaStreamTrack === u && (c = l) : u === v && (c = l));
    }), c;
  }
}
class RemoteTrackPublication extends TrackPublication {
  constructor(u, c, l, v) {
    super(u, c.sid, c.name, v), this.track = void 0, this.allowed = !0, this.disabled = !1, this.currentVideoQuality = VideoQuality.HIGH, this.handleEnded = (S) => {
      this.setTrack(void 0), this.emit(TrackEvent.Ended, S);
    }, this.handleVisibilityChange = (S) => {
      this.log.debug("adaptivestream video visibility ".concat(this.trackSid, ", visible=").concat(S), this.logContext), this.disabled = !S, this.emitTrackUpdate();
    }, this.handleVideoDimensionsChange = (S) => {
      this.log.debug("adaptivestream video dimensions ".concat(S.width, "x").concat(S.height), this.logContext), this.videoDimensions = S, this.emitTrackUpdate();
    }, this.subscribed = l, this.updateInfo(c);
  }
  /**
   * Subscribe or unsubscribe to this remote track
   * @param subscribed true to subscribe to a track, false to unsubscribe
   */
  setSubscribed(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus;
    this.subscribed = u, u && (this.allowed = !0);
    const v = new UpdateSubscription({
      trackSids: [this.trackSid],
      subscribe: this.subscribed,
      participantTracks: [new ParticipantTracks({
        // sending an empty participant id since TrackPublication doesn't keep it
        // this is filled in by the participant that receives this message
        participantSid: "",
        trackSids: [this.trackSid]
      })]
    });
    this.emit(TrackEvent.UpdateSubscription, v), this.emitSubscriptionUpdateIfChanged(c), this.emitPermissionUpdateIfChanged(l);
  }
  get subscriptionStatus() {
    return this.subscribed === !1 ? TrackPublication.SubscriptionStatus.Unsubscribed : super.isSubscribed ? TrackPublication.SubscriptionStatus.Subscribed : TrackPublication.SubscriptionStatus.Desired;
  }
  get permissionStatus() {
    return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;
  }
  /**
   * Returns true if track is subscribed, and ready for playback
   */
  get isSubscribed() {
    return this.subscribed === !1 ? !1 : super.isSubscribed;
  }
  // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled
  get isDesired() {
    return this.subscribed !== !1;
  }
  get isEnabled() {
    return !this.disabled;
  }
  /**
   * disable server from sending down data for this track. this is useful when
   * the participant is off screen, you may disable streaming down their video
   * to reduce bandwidth requirements
   * @param enabled
   */
  setEnabled(u) {
    !this.isManualOperationAllowed() || this.disabled === !u || (this.disabled = !u, this.emitTrackUpdate());
  }
  /**
   * for tracks that support simulcasting, adjust subscribed quality
   *
   * This indicates the highest quality the client can accept. if network
   * bandwidth does not allow, server will automatically reduce quality to
   * optimize for uninterrupted video
   */
  setVideoQuality(u) {
    !this.isManualOperationAllowed() || this.currentVideoQuality === u || (this.currentVideoQuality = u, this.videoDimensions = void 0, this.emitTrackUpdate());
  }
  setVideoDimensions(u) {
    var c, l;
    this.isManualOperationAllowed() && (((c = this.videoDimensions) === null || c === void 0 ? void 0 : c.width) === u.width && ((l = this.videoDimensions) === null || l === void 0 ? void 0 : l.height) === u.height || (this.track instanceof RemoteVideoTrack && (this.videoDimensions = u), this.currentVideoQuality = void 0, this.emitTrackUpdate()));
  }
  setVideoFPS(u) {
    this.isManualOperationAllowed() && this.track instanceof RemoteVideoTrack && this.fps !== u && (this.fps = u, this.emitTrackUpdate());
  }
  get videoQuality() {
    return this.currentVideoQuality;
  }
  /** @internal */
  setTrack(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus, v = this.track;
    v !== u && (v && (v.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange), v.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange), v.off(TrackEvent.Ended, this.handleEnded), v.detach(), v.stopMonitor(), this.emit(TrackEvent.Unsubscribed, v)), super.setTrack(u), u && (u.sid = this.trackSid, u.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange), u.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange), u.on(TrackEvent.Ended, this.handleEnded), this.emit(TrackEvent.Subscribed, u)), this.emitPermissionUpdateIfChanged(l), this.emitSubscriptionUpdateIfChanged(c));
  }
  /** @internal */
  setAllowed(u) {
    const c = this.subscriptionStatus, l = this.permissionStatus;
    this.allowed = u, this.emitPermissionUpdateIfChanged(l), this.emitSubscriptionUpdateIfChanged(c);
  }
  /** @internal */
  setSubscriptionError(u) {
    this.emit(TrackEvent.SubscriptionFailed, u);
  }
  /** @internal */
  updateInfo(u) {
    super.updateInfo(u);
    const c = this.metadataMuted;
    this.metadataMuted = u.muted, this.track ? this.track.setMuted(u.muted) : c !== u.muted && this.emit(u.muted ? TrackEvent.Muted : TrackEvent.Unmuted);
  }
  emitSubscriptionUpdateIfChanged(u) {
    const c = this.subscriptionStatus;
    u !== c && this.emit(TrackEvent.SubscriptionStatusChanged, c, u);
  }
  emitPermissionUpdateIfChanged(u) {
    this.permissionStatus !== u && this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, u);
  }
  isManualOperationAllowed() {
    return this.kind === Track.Kind.Video && this.isAdaptiveStream ? (this.log.warn("adaptive stream is enabled, cannot change video track settings", this.logContext), !1) : this.isDesired ? !0 : (this.log.warn("cannot update track settings when not subscribed", this.logContext), !1);
  }
  get isAdaptiveStream() {
    return this.track instanceof RemoteVideoTrack && this.track.isAdaptiveStream;
  }
  /* @internal */
  emitTrackUpdate() {
    const u = new UpdateTrackSettings({
      trackSids: [this.trackSid],
      disabled: this.disabled,
      fps: this.fps
    });
    this.videoDimensions ? (u.width = Math.ceil(this.videoDimensions.width), u.height = Math.ceil(this.videoDimensions.height)) : this.currentVideoQuality !== void 0 ? u.quality = this.currentVideoQuality : u.quality = VideoQuality.HIGH, this.emit(TrackEvent.UpdateSettings, u);
  }
}
class RemoteParticipant extends Participant {
  /** @internal */
  static fromParticipantInfo(u, c) {
    return new RemoteParticipant(u, c.sid, c.identity, c.name, c.metadata);
  }
  /** @internal */
  constructor(u, c, l, v, S, g) {
    super(c, l || "", v, S, g), this.signalClient = u, this.trackPublications = /* @__PURE__ */ new Map(), this.audioTrackPublications = /* @__PURE__ */ new Map(), this.videoTrackPublications = /* @__PURE__ */ new Map(), this.volumeMap = /* @__PURE__ */ new Map();
  }
  addTrackPublication(u) {
    super.addTrackPublication(u), u.on(TrackEvent.UpdateSettings, (c) => {
      this.log.debug("send update settings", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(u))), this.signalClient.sendUpdateTrackSettings(c);
    }), u.on(TrackEvent.UpdateSubscription, (c) => {
      c.participantTracks.forEach((l) => {
        l.participantSid = this.sid;
      }), this.signalClient.sendUpdateSubscription(c);
    }), u.on(TrackEvent.SubscriptionPermissionChanged, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, u, c);
    }), u.on(TrackEvent.SubscriptionStatusChanged, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, u, c);
    }), u.on(TrackEvent.Subscribed, (c) => {
      this.emit(ParticipantEvent.TrackSubscribed, c, u);
    }), u.on(TrackEvent.Unsubscribed, (c) => {
      this.emit(ParticipantEvent.TrackUnsubscribed, c, u);
    }), u.on(TrackEvent.SubscriptionFailed, (c) => {
      this.emit(ParticipantEvent.TrackSubscriptionFailed, u.trackSid, c);
    });
  }
  getTrackPublication(u) {
    const c = super.getTrackPublication(u);
    if (c)
      return c;
  }
  getTrackPublicationByName(u) {
    const c = super.getTrackPublicationByName(u);
    if (c)
      return c;
  }
  /**
   * sets the volume on the participant's audio track
   * by default, this affects the microphone publication
   * a different source can be passed in as a second argument
   * if no track exists the volume will be applied when the microphone track is added
   */
  setVolume(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Track.Source.Microphone;
    this.volumeMap.set(c, u);
    const l = this.getTrackPublication(c);
    l && l.track && l.track.setVolume(u);
  }
  /**
   * gets the volume on the participant's microphone track
   */
  getVolume() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Track.Source.Microphone;
    const c = this.getTrackPublication(u);
    return c && c.track ? c.track.getVolume() : this.volumeMap.get(u);
  }
  /** @internal */
  addSubscribedMediaTrack(u, c, l, v, S, g) {
    let E = this.getTrackPublicationBySid(c);
    if (E || c.startsWith("TR") || this.trackPublications.forEach((L) => {
      !E && u.kind === L.kind.toString() && (E = L);
    }), !E) {
      if (g === 0) {
        this.log.error("could not find published track", Object.assign(Object.assign({}, this.logContext), {
          trackSid: c
        })), this.emit(ParticipantEvent.TrackSubscriptionFailed, c);
        return;
      }
      g === void 0 && (g = 20), setTimeout(() => {
        this.addSubscribedMediaTrack(u, c, l, v, S, g - 1);
      }, 150);
      return;
    }
    if (u.readyState === "ended") {
      this.log.error("unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(E))), this.emit(ParticipantEvent.TrackSubscriptionFailed, c);
      return;
    }
    const _ = u.kind === "video";
    let k;
    return _ ? k = new RemoteVideoTrack(u, c, v, S) : k = new RemoteAudioTrack(u, c, v, this.audioContext, this.audioOutput), k.source = E.source, k.isMuted = E.isMuted, k.setMediaStream(l), k.start(), E.setTrack(k), this.volumeMap.has(E.source) && k instanceof RemoteAudioTrack && k.setVolume(this.volumeMap.get(E.source)), E;
  }
  /** @internal */
  get hasMetadata() {
    return !!this.participantInfo;
  }
  /**
   * @internal
   */
  getTrackPublicationBySid(u) {
    return this.trackPublications.get(u);
  }
  /** @internal */
  updateInfo(u) {
    if (!super.updateInfo(u))
      return !1;
    const c = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map();
    return u.tracks.forEach((v) => {
      var S, g;
      let E = this.getTrackPublicationBySid(v.sid);
      if (E)
        E.updateInfo(v);
      else {
        const _ = Track.kindFromProto(v.type);
        if (!_)
          return;
        E = new RemoteTrackPublication(_, v, (S = this.signalClient.connectOptions) === null || S === void 0 ? void 0 : S.autoSubscribe, {
          loggerContextCb: () => this.logContext,
          loggerName: (g = this.loggerOptions) === null || g === void 0 ? void 0 : g.loggerName
        }), E.updateInfo(v), l.set(v.sid, E);
        const k = Array.from(this.trackPublications.values()).find((L) => L.source === (E == null ? void 0 : E.source));
        k && E.source !== Track.Source.Unknown && this.log.debug("received a second track publication for ".concat(this.identity, " with the same source: ").concat(E.source), Object.assign(Object.assign({}, this.logContext), {
          oldTrack: getLogContextFromTrack(k),
          newTrack: getLogContextFromTrack(E)
        })), this.addTrackPublication(E);
      }
      c.set(v.sid, E);
    }), this.trackPublications.forEach((v) => {
      c.has(v.trackSid) || (this.log.trace("detected removed track on remote participant, unpublishing", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(v))), this.unpublishTrack(v.trackSid, !0));
    }), l.forEach((v) => {
      this.emit(ParticipantEvent.TrackPublished, v);
    }), !0;
  }
  /** @internal */
  unpublishTrack(u, c) {
    const l = this.trackPublications.get(u);
    if (!l)
      return;
    const {
      track: v
    } = l;
    switch (v && (v.stop(), l.setTrack(void 0)), this.trackPublications.delete(u), l.kind) {
      case Track.Kind.Audio:
        this.audioTrackPublications.delete(u);
        break;
      case Track.Kind.Video:
        this.videoTrackPublications.delete(u);
        break;
    }
    c && this.emit(ParticipantEvent.TrackUnpublished, l);
  }
  /**
   * @internal
   */
  setAudioOutput(u) {
    return __awaiter(this, void 0, void 0, function* () {
      this.audioOutput = u;
      const c = [];
      this.audioTrackPublications.forEach((l) => {
        var v;
        l.track instanceof RemoteAudioTrack && c.push(l.track.setSinkId((v = u.deviceId) !== null && v !== void 0 ? v : "default"));
      }), yield Promise.all(c);
    });
  }
  /** @internal */
  emit(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    return this.log.trace("participant event", Object.assign(Object.assign({}, this.logContext), {
      event: u,
      args: l
    })), super.emit(u, ...l);
  }
}
var ConnectionState;
(function(a) {
  a.Disconnected = "disconnected", a.Connecting = "connecting", a.Connected = "connected", a.Reconnecting = "reconnecting";
})(ConnectionState || (ConnectionState = {}));
const connectionReconcileFrequency = 2 * 1e3;
class Room extends eventsExports.EventEmitter {
  /**
   * Creates a new Room, the primary construct for a LiveKit session.
   * @param options
   */
  constructor(u) {
    var c, l, v;
    super(), c = this, this.state = ConnectionState.Disconnected, this.activeSpeakers = [], this.isE2EEEnabled = !1, this.audioEnabled = !0, this.isVideoPlaybackBlocked = !1, this.log = livekitLogger, this.bufferedEvents = [], this.isResuming = !1, this.connect = (S, g, E) => __awaiter(this, void 0, void 0, function* () {
      var _;
      const k = yield this.disconnectLock.lock();
      if (this.state === ConnectionState.Connected)
        return this.log.info("already connected to room ".concat(this.name), this.logContext), k(), Promise.resolve();
      if (this.connectFuture)
        return k(), this.connectFuture.promise;
      this.setAndEmitConnectionState(ConnectionState.Connecting), ((_ = this.regionUrlProvider) === null || _ === void 0 ? void 0 : _.getServerUrl().toString()) !== S && (this.regionUrl = void 0, this.regionUrlProvider = void 0), isCloud(new URL(S)) && (this.regionUrlProvider === void 0 ? this.regionUrlProvider = new RegionUrlProvider(S, g) : this.regionUrlProvider.updateToken(g), this.regionUrlProvider.fetchRegionSettings().catch(($) => {
        this.log.warn("could not fetch region settings", Object.assign(Object.assign({}, this.logContext), {
          error: $
        }));
      }));
      const L = ($, J, V) => __awaiter(this, void 0, void 0, function* () {
        var q;
        this.abortController && this.abortController.abort();
        const G = new AbortController();
        this.abortController = G, k == null || k();
        try {
          yield this.attemptConnection(V ?? S, g, E, G), this.abortController = void 0, $();
        } catch (H) {
          if (this.regionUrlProvider && H instanceof ConnectionError && H.reason !== 3 && H.reason !== 0) {
            let B = null;
            try {
              B = yield this.regionUrlProvider.getNextBestRegionUrl((q = this.abortController) === null || q === void 0 ? void 0 : q.signal);
            } catch (Y) {
              if (Y instanceof ConnectionError && (Y.status === 401 || Y.reason === 3)) {
                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), J(Y);
                return;
              }
            }
            B ? (this.log.info("Initial connection failed with ConnectionError: ".concat(H.message, ". Retrying with another region: ").concat(B), this.logContext), yield L($, J, B)) : (this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), J(H));
          } else
            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish), J(H);
        }
      }), M = this.regionUrl;
      return this.regionUrl = void 0, this.connectFuture = new Future(($, J) => {
        L($, J, M);
      }, () => {
        this.clearConnectionFutures();
      }), this.connectFuture.promise;
    }), this.connectSignal = (S, g, E, _, k, L) => __awaiter(this, void 0, void 0, function* () {
      var M, $, J;
      const V = yield E.join(S, g, {
        autoSubscribe: _.autoSubscribe,
        adaptiveStream: typeof k.adaptiveStream == "object" ? !0 : k.adaptiveStream,
        maxRetries: _.maxRetries,
        e2eeEnabled: !!this.e2eeManager,
        websocketTimeout: _.websocketTimeout
      }, L.signal);
      let q = V.serverInfo;
      if (q || (q = {
        version: V.serverVersion,
        region: V.serverRegion
      }), this.log.debug("connected to Livekit Server ".concat(Object.entries(q).map((G) => {
        let [H, B] = G;
        return "".concat(H, ": ").concat(B);
      }).join(", ")), {
        room: (M = V.room) === null || M === void 0 ? void 0 : M.name,
        roomSid: ($ = V.room) === null || $ === void 0 ? void 0 : $.sid,
        identity: (J = V.participant) === null || J === void 0 ? void 0 : J.identity
      }), !V.serverVersion)
        throw new UnsupportedServer("unknown server version");
      return V.serverVersion === "0.15.1" && this.options.dynacast && (this.log.debug("disabling dynacast due to server version", this.logContext), k.dynacast = !1), V;
    }), this.applyJoinResponse = (S) => {
      const g = S.participant;
      this.localParticipant.sid = g.sid, this.localParticipant.identity = g.identity, this.handleParticipantUpdates([g, ...S.otherParticipants]), S.room && this.handleRoomUpdate(S.room), this.options.e2ee && this.e2eeManager && this.e2eeManager.setSifTrailer(S.sifTrailer);
    }, this.attemptConnection = (S, g, E, _) => __awaiter(this, void 0, void 0, function* () {
      var k, L, M;
      this.state === ConnectionState.Reconnecting || this.isResuming || !((k = this.engine) === null || k === void 0) && k.pendingReconnect ? (this.log.info("Reconnection attempt replaced by new connection attempt", this.logContext), this.recreateEngine()) : this.maybeCreateEngine(), !((L = this.regionUrlProvider) === null || L === void 0) && L.isCloud() && this.engine.setRegionUrlProvider(this.regionUrlProvider), this.acquireAudioContext(), this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), E), this.connOptions.rtcConfig && (this.engine.rtcConfig = this.connOptions.rtcConfig), this.connOptions.peerConnectionTimeout && (this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout);
      try {
        const $ = yield this.connectSignal(S, g, this.engine, this.connOptions, this.options, _);
        this.applyJoinResponse($), this.setupLocalParticipantEvents(), this.emit(RoomEvent.SignalConnected);
      } catch ($) {
        yield this.engine.close(), this.recreateEngine();
        const J = new ConnectionError("could not establish signal connection");
        throw $ instanceof Error && (J.message = "".concat(J.message, ": ").concat($.message)), $ instanceof ConnectionError && (J.reason = $.reason, J.status = $.status), this.log.debug("error trying to establish signal connection", Object.assign(Object.assign({}, this.logContext), {
          error: $
        })), J;
      }
      if (_.signal.aborted)
        throw yield this.engine.close(), this.recreateEngine(), new ConnectionError("Connection attempt aborted");
      try {
        yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, _);
      } catch ($) {
        throw yield this.engine.close(), this.recreateEngine(), $;
      }
      isWeb() && this.options.disconnectOnPageLeave && (window.addEventListener("pagehide", this.onPageLeave), window.addEventListener("beforeunload", this.onPageLeave)), isWeb() && (document.addEventListener("freeze", this.onPageLeave), (M = navigator.mediaDevices) === null || M === void 0 || M.addEventListener("devicechange", this.handleDeviceChange)), this.setAndEmitConnectionState(ConnectionState.Connected), this.emit(RoomEvent.Connected), this.registerConnectionReconcile();
    }), this.disconnect = function() {
      let S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      return __awaiter(c, void 0, void 0, function* () {
        var g, E, _, k;
        const L = yield this.disconnectLock.lock();
        try {
          if (this.state === ConnectionState.Disconnected) {
            this.log.debug("already disconnected", this.logContext);
            return;
          }
          this.log.info("disconnect from room", Object.assign({}, this.logContext)), (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting || this.isResuming) && (this.log.warn("abort connection attempt", this.logContext), (g = this.abortController) === null || g === void 0 || g.abort(), (_ = (E = this.connectFuture) === null || E === void 0 ? void 0 : E.reject) === null || _ === void 0 || _.call(E, new ConnectionError("Client initiated disconnect")), this.connectFuture = void 0), !((k = this.engine) === null || k === void 0) && k.client.isDisconnected || (yield this.engine.client.sendLeave()), this.engine && (yield this.engine.close()), this.handleDisconnect(S, DisconnectReason.CLIENT_INITIATED), this.engine = void 0;
        } finally {
          L();
        }
      });
    }, this.onPageLeave = () => __awaiter(this, void 0, void 0, function* () {
      yield this.disconnect();
    }), this.startAudio = () => __awaiter(this, void 0, void 0, function* () {
      const S = [], g = getBrowser();
      if (g && g.os === "iOS") {
        const E = "livekit-dummy-audio-el";
        let _ = document.getElementById(E);
        if (!_) {
          _ = document.createElement("audio"), _.id = E, _.autoplay = !0, _.hidden = !0;
          const k = getEmptyAudioStreamTrack();
          k.enabled = !0;
          const L = new MediaStream([k]);
          _.srcObject = L, document.addEventListener("visibilitychange", () => {
            _ && (_.srcObject = document.hidden ? null : L, document.hidden || (this.log.debug("page visible again, triggering startAudio to resume playback and update playback status", this.logContext), this.startAudio()));
          }), document.body.append(_), this.once(RoomEvent.Disconnected, () => {
            _ == null || _.remove(), _ = null;
          });
        }
        S.push(_);
      }
      this.remoteParticipants.forEach((E) => {
        E.audioTrackPublications.forEach((_) => {
          _.track && _.track.attachedElements.forEach((k) => {
            S.push(k);
          });
        });
      });
      try {
        yield Promise.all([this.acquireAudioContext(), ...S.map((E) => (E.muted = !1, E.play()))]), this.handleAudioPlaybackStarted();
      } catch (E) {
        throw this.handleAudioPlaybackFailed(E), E;
      }
    }), this.startVideo = () => __awaiter(this, void 0, void 0, function* () {
      const S = [];
      for (const g of this.remoteParticipants.values())
        g.videoTrackPublications.forEach((E) => {
          var _;
          (_ = E.track) === null || _ === void 0 || _.attachedElements.forEach((k) => {
            S.includes(k) || S.push(k);
          });
        });
      yield Promise.all(S.map((g) => g.play())).then(() => {
        this.handleVideoPlaybackStarted();
      }).catch((g) => {
        g.name === "NotAllowedError" ? this.handleVideoPlaybackFailed() : this.log.warn("Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler", this.logContext);
      });
    }), this.handleRestarting = () => {
      this.clearConnectionReconcile(), this.isResuming = !1;
      for (const S of this.remoteParticipants.values())
        this.handleParticipantDisconnected(S.identity, S);
      this.setAndEmitConnectionState(ConnectionState.Reconnecting) && this.emit(RoomEvent.Reconnecting);
    }, this.handleSignalRestarted = (S) => __awaiter(this, void 0, void 0, function* () {
      this.log.debug("signal reconnected to server, region ".concat(S.serverRegion), Object.assign(Object.assign({}, this.logContext), {
        region: S.serverRegion
      })), this.bufferedEvents = [], this.applyJoinResponse(S);
      try {
        yield this.localParticipant.republishAllTracks(void 0, !0);
      } catch (g) {
        this.log.error("error trying to re-publish tracks after reconnection", Object.assign(Object.assign({}, this.logContext), {
          error: g
        }));
      }
      try {
        yield this.engine.waitForRestarted(), this.log.debug("fully reconnected to server", Object.assign(Object.assign({}, this.logContext), {
          region: S.serverRegion
        }));
      } catch {
        return;
      }
      this.setAndEmitConnectionState(ConnectionState.Connected), this.emit(RoomEvent.Reconnected), this.registerConnectionReconcile(), this.emitBufferedEvents();
    }), this.handleParticipantUpdates = (S) => {
      S.forEach((g) => {
        var E;
        if (g.identity === this.localParticipant.identity) {
          this.localParticipant.updateInfo(g);
          return;
        }
        g.identity === "" && (g.identity = (E = this.sidToIdentity.get(g.sid)) !== null && E !== void 0 ? E : "");
        let _ = this.remoteParticipants.get(g.identity);
        g.state === ParticipantInfo_State.DISCONNECTED ? this.handleParticipantDisconnected(g.identity, _) : _ = this.getOrCreateParticipant(g.identity, g);
      });
    }, this.handleActiveSpeakersUpdate = (S) => {
      const g = [], E = {};
      S.forEach((_) => {
        if (E[_.sid] = !0, _.sid === this.localParticipant.sid)
          this.localParticipant.audioLevel = _.level, this.localParticipant.setIsSpeaking(!0), g.push(this.localParticipant);
        else {
          const k = this.getRemoteParticipantBySid(_.sid);
          k && (k.audioLevel = _.level, k.setIsSpeaking(!0), g.push(k));
        }
      }), E[this.localParticipant.sid] || (this.localParticipant.audioLevel = 0, this.localParticipant.setIsSpeaking(!1)), this.remoteParticipants.forEach((_) => {
        E[_.sid] || (_.audioLevel = 0, _.setIsSpeaking(!1));
      }), this.activeSpeakers = g, this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, g);
    }, this.handleSpeakersChanged = (S) => {
      const g = /* @__PURE__ */ new Map();
      this.activeSpeakers.forEach((_) => {
        g.set(_.sid, _);
      }), S.forEach((_) => {
        let k = this.getRemoteParticipantBySid(_.sid);
        _.sid === this.localParticipant.sid && (k = this.localParticipant), k && (k.audioLevel = _.level, k.setIsSpeaking(_.active), _.active ? g.set(_.sid, k) : g.delete(_.sid));
      });
      const E = Array.from(g.values());
      E.sort((_, k) => k.audioLevel - _.audioLevel), this.activeSpeakers = E, this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, E);
    }, this.handleStreamStateUpdate = (S) => {
      S.streamStates.forEach((g) => {
        const E = this.getRemoteParticipantBySid(g.participantSid);
        if (!E)
          return;
        const _ = E.getTrackPublicationBySid(g.trackSid);
        !_ || !_.track || (_.track.streamState = Track.streamStateFromProto(g.state), E.emit(ParticipantEvent.TrackStreamStateChanged, _, _.track.streamState), this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, _, _.track.streamState, E));
      });
    }, this.handleSubscriptionPermissionUpdate = (S) => {
      const g = this.getRemoteParticipantBySid(S.participantSid);
      if (!g)
        return;
      const E = g.getTrackPublicationBySid(S.trackSid);
      E && E.setAllowed(S.allowed);
    }, this.handleSubscriptionError = (S) => {
      const g = Array.from(this.remoteParticipants.values()).find((_) => _.trackPublications.has(S.trackSid));
      if (!g)
        return;
      const E = g.getTrackPublicationBySid(S.trackSid);
      E && E.setSubscriptionError(S.err);
    }, this.handleDataPacket = (S, g) => {
      const E = this.remoteParticipants.get(S.participantIdentity);
      this.emit(RoomEvent.DataReceived, S.payload, E, g, S.topic), E == null || E.emit(ParticipantEvent.DataReceived, S.payload, g);
    }, this.handleAudioPlaybackStarted = () => {
      this.canPlaybackAudio || (this.audioEnabled = !0, this.emit(RoomEvent.AudioPlaybackStatusChanged, !0));
    }, this.handleAudioPlaybackFailed = (S) => {
      this.log.warn("could not playback audio", Object.assign(Object.assign({}, this.logContext), {
        error: S
      })), this.canPlaybackAudio && (this.audioEnabled = !1, this.emit(RoomEvent.AudioPlaybackStatusChanged, !1));
    }, this.handleVideoPlaybackStarted = () => {
      this.isVideoPlaybackBlocked && (this.isVideoPlaybackBlocked = !1, this.emit(RoomEvent.VideoPlaybackStatusChanged, !0));
    }, this.handleVideoPlaybackFailed = () => {
      this.isVideoPlaybackBlocked || (this.isVideoPlaybackBlocked = !0, this.emit(RoomEvent.VideoPlaybackStatusChanged, !1));
    }, this.handleDeviceChange = () => __awaiter(this, void 0, void 0, function* () {
      this.emit(RoomEvent.MediaDevicesChanged);
    }), this.handleRoomUpdate = (S) => {
      const g = this.roomInfo;
      this.roomInfo = S, g && g.metadata !== S.metadata && this.emitWhenConnected(RoomEvent.RoomMetadataChanged, S.metadata), (g == null ? void 0 : g.activeRecording) !== S.activeRecording && this.emitWhenConnected(RoomEvent.RecordingStatusChanged, S.activeRecording);
    }, this.handleConnectionQualityUpdate = (S) => {
      S.updates.forEach((g) => {
        if (g.participantSid === this.localParticipant.sid) {
          this.localParticipant.setConnectionQuality(g.quality);
          return;
        }
        const E = this.getRemoteParticipantBySid(g.participantSid);
        E && E.setConnectionQuality(g.quality);
      });
    }, this.onLocalParticipantMetadataChanged = (S) => {
      this.emit(RoomEvent.ParticipantMetadataChanged, S, this.localParticipant);
    }, this.onLocalParticipantNameChanged = (S) => {
      this.emit(RoomEvent.ParticipantNameChanged, S, this.localParticipant);
    }, this.onLocalTrackMuted = (S) => {
      this.emit(RoomEvent.TrackMuted, S, this.localParticipant);
    }, this.onLocalTrackUnmuted = (S) => {
      this.emit(RoomEvent.TrackUnmuted, S, this.localParticipant);
    }, this.onLocalTrackPublished = (S) => __awaiter(this, void 0, void 0, function* () {
      var g;
      this.emit(RoomEvent.LocalTrackPublished, S, this.localParticipant), S.track instanceof LocalAudioTrack && (yield S.track.checkForSilence()) && this.emit(RoomEvent.LocalAudioSilenceDetected, S);
      const E = yield (g = S.track) === null || g === void 0 ? void 0 : g.getDeviceId(), _ = sourceToKind(S.source);
      _ && E && E !== this.localParticipant.activeDeviceMap.get(_) && (this.localParticipant.activeDeviceMap.set(_, E), this.emit(RoomEvent.ActiveDeviceChanged, _, E));
    }), this.onLocalTrackUnpublished = (S) => {
      this.emit(RoomEvent.LocalTrackUnpublished, S, this.localParticipant);
    }, this.onLocalConnectionQualityChanged = (S) => {
      this.emit(RoomEvent.ConnectionQualityChanged, S, this.localParticipant);
    }, this.onMediaDevicesError = (S) => {
      this.emit(RoomEvent.MediaDevicesError, S);
    }, this.onLocalParticipantPermissionsChanged = (S) => {
      this.emit(RoomEvent.ParticipantPermissionsChanged, S, this.localParticipant);
    }, this.setMaxListeners(100), this.remoteParticipants = /* @__PURE__ */ new Map(), this.sidToIdentity = /* @__PURE__ */ new Map(), this.options = Object.assign(Object.assign({}, roomOptionDefaults), u), this.log = getLogger((l = this.options.loggerName) !== null && l !== void 0 ? l : LoggerNames.Room), this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), u == null ? void 0 : u.audioCaptureDefaults), this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), u == null ? void 0 : u.videoCaptureDefaults), this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), u == null ? void 0 : u.publishDefaults), this.maybeCreateEngine(), this.disconnectLock = new Mutex(), this.localParticipant = new LocalParticipant("", "", this.engine, this.options), this.options.videoCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set("videoinput", unwrapConstraint(this.options.videoCaptureDefaults.deviceId)), this.options.audioCaptureDefaults.deviceId && this.localParticipant.activeDeviceMap.set("audioinput", unwrapConstraint(this.options.audioCaptureDefaults.deviceId)), !((v = this.options.audioOutput) === null || v === void 0) && v.deviceId && this.switchActiveDevice("audiooutput", unwrapConstraint(this.options.audioOutput.deviceId)).catch((S) => this.log.warn("Could not set audio output: ".concat(S.message), this.logContext)), this.options.e2ee && this.setupE2EE();
  }
  /**
   * @experimental
   */
  setE2EEEnabled(u) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.e2eeManager)
        yield Promise.all([this.localParticipant.setE2EEEnabled(u)]), this.localParticipant.identity !== "" && this.e2eeManager.setParticipantCryptorEnabled(u, this.localParticipant.identity);
      else
        throw Error("e2ee not configured, please set e2ee settings within the room options");
    });
  }
  setupE2EE() {
    var u;
    this.options.e2ee && (this.e2eeManager = new E2EEManager(this.options.e2ee), this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (c, l) => {
      l instanceof LocalParticipant && (this.isE2EEEnabled = c), this.emit(RoomEvent.ParticipantEncryptionStatusChanged, c, l);
    }), this.e2eeManager.on(EncryptionEvent.EncryptionError, (c) => this.emit(RoomEvent.EncryptionError, c)), (u = this.e2eeManager) === null || u === void 0 || u.setup(this));
  }
  get logContext() {
    var u;
    return {
      room: this.name,
      roomSid: (u = this.roomInfo) === null || u === void 0 ? void 0 : u.sid,
      identity: this.localParticipant.identity
    };
  }
  /**
   * if the current room has a participant with `recorder: true` in its JWT grant
   **/
  get isRecording() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.activeRecording) !== null && c !== void 0 ? c : !1;
  }
  /**
   * server assigned unique room id.
   * returns once a sid has been issued by the server.
   */
  getSid() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.state === ConnectionState.Disconnected ? "" : this.roomInfo && this.roomInfo.sid !== "" ? this.roomInfo.sid : new Promise((u, c) => {
        const l = (v) => {
          v.sid !== "" && (this.engine.off(EngineEvent.RoomUpdate, l), u(v.sid));
        };
        this.engine.on(EngineEvent.RoomUpdate, l), this.once(RoomEvent.Disconnected, () => {
          this.engine.off(EngineEvent.RoomUpdate, l), c("Room disconnected before room server id was available");
        });
      });
    });
  }
  /** user assigned name, derived from JWT token */
  get name() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.name) !== null && c !== void 0 ? c : "";
  }
  /** room metadata */
  get metadata() {
    var u;
    return (u = this.roomInfo) === null || u === void 0 ? void 0 : u.metadata;
  }
  get numParticipants() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.numParticipants) !== null && c !== void 0 ? c : 0;
  }
  get numPublishers() {
    var u, c;
    return (c = (u = this.roomInfo) === null || u === void 0 ? void 0 : u.numPublishers) !== null && c !== void 0 ? c : 0;
  }
  maybeCreateEngine() {
    this.engine && !this.engine.isClosed || (this.engine = new RTCEngine(this.options), this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (u, c, l) => {
      this.onTrackAdded(u, c, l);
    }).on(EngineEvent.Disconnected, (u) => {
      this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, u);
    }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, () => {
      this.clearConnectionReconcile(), this.isResuming = !0, this.log.info("Resuming signal connection", this.logContext);
    }).on(EngineEvent.Resumed, () => {
      this.registerConnectionReconcile(), this.isResuming = !1, this.log.info("Resumed signal connection", this.logContext), this.updateSubscriptions(), this.emitBufferedEvents();
    }).on(EngineEvent.SignalResumed, () => {
      this.bufferedEvents = [], (this.state === ConnectionState.Reconnecting || this.isResuming) && this.sendSyncState();
    }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.DCBufferStatusChanged, (u, c) => {
      this.emit(RoomEvent.DCBufferStatusChanged, u, c);
    }), this.localParticipant && this.localParticipant.setupEngine(this.engine), this.e2eeManager && this.e2eeManager.setupEngine(this.engine));
  }
  /**
   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.
   * In particular, it handles Chrome's unique behavior of creating `default`
   * devices. When encountered, it'll be removed from the list of devices.
   * The actual default device will be placed at top.
   * @param kind
   * @returns a list of available local devices
   */
  static getLocalDevices(u) {
    let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return DeviceManager.getInstance().getDevices(u, c);
  }
  /**
   * prepareConnection should be called as soon as the page is loaded, in order
   * to speed up the connection attempt. This function will
   * - perform DNS resolution and pre-warm the DNS cache
   * - establish TLS connection and cache TLS keys
   *
   * With LiveKit Cloud, it will also determine the best edge data center for
   * the current client to connect to if a token is provided.
   */
  prepareConnection(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.state === ConnectionState.Disconnected) {
        this.log.debug("prepareConnection to ".concat(u), this.logContext);
        try {
          if (isCloud(new URL(u)) && c) {
            this.regionUrlProvider = new RegionUrlProvider(u, c);
            const l = yield this.regionUrlProvider.getNextBestRegionUrl();
            l && this.state === ConnectionState.Disconnected && (this.regionUrl = l, yield fetch(toHttpUrl(l), {
              method: "HEAD"
            }), this.log.debug("prepared connection to ".concat(l), this.logContext));
          } else
            yield fetch(toHttpUrl(u), {
              method: "HEAD"
            });
        } catch (l) {
          this.log.warn("could not prepare connection", Object.assign(Object.assign({}, this.logContext), {
            error: l
          }));
        }
      }
    });
  }
  /**
   * retrieves a participant by identity
   * @param identity
   * @returns
   */
  getParticipantByIdentity(u) {
    return this.localParticipant.identity === u ? this.localParticipant : this.remoteParticipants.get(u);
  }
  clearConnectionFutures() {
    this.connectFuture = void 0;
  }
  /**
   * @internal for testing
   */
  simulateScenario(u, c) {
    return __awaiter(this, void 0, void 0, function* () {
      let l = () => {
      }, v;
      switch (u) {
        case "signal-reconnect":
          yield this.engine.client.handleOnClose("simulate disconnect");
          break;
        case "speaker":
          v = new SimulateScenario({
            scenario: {
              case: "speakerUpdate",
              value: 3
            }
          });
          break;
        case "node-failure":
          v = new SimulateScenario({
            scenario: {
              case: "nodeFailure",
              value: !0
            }
          });
          break;
        case "server-leave":
          v = new SimulateScenario({
            scenario: {
              case: "serverLeave",
              value: !0
            }
          });
          break;
        case "migration":
          v = new SimulateScenario({
            scenario: {
              case: "migration",
              value: !0
            }
          });
          break;
        case "resume-reconnect":
          this.engine.failNext(), yield this.engine.client.handleOnClose("simulate resume-disconnect");
          break;
        case "disconnect-signal-on-resume":
          l = () => __awaiter(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          }), v = new SimulateScenario({
            scenario: {
              case: "disconnectSignalOnResume",
              value: !0
            }
          });
          break;
        case "disconnect-signal-on-resume-no-messages":
          l = () => __awaiter(this, void 0, void 0, function* () {
            yield this.engine.client.handleOnClose("simulate resume-disconnect");
          }), v = new SimulateScenario({
            scenario: {
              case: "disconnectSignalOnResumeNoMessages",
              value: !0
            }
          });
          break;
        case "full-reconnect":
          this.engine.fullReconnectOnNext = !0, yield this.engine.client.handleOnClose("simulate full-reconnect");
          break;
        case "force-tcp":
        case "force-tls":
          v = new SimulateScenario({
            scenario: {
              case: "switchCandidateProtocol",
              value: u === "force-tls" ? 2 : 1
            }
          }), l = () => __awaiter(this, void 0, void 0, function* () {
            const S = this.engine.client.onLeave;
            S && S(new LeaveRequest({
              reason: DisconnectReason.CLIENT_INITIATED,
              canReconnect: !0
            }));
          });
          break;
        case "subscriber-bandwidth":
          if (c === void 0 || typeof c != "number")
            throw new Error("subscriber-bandwidth requires a number as argument");
          v = new SimulateScenario({
            scenario: {
              case: "subscriberBandwidth",
              value: BigInt(c)
            }
          });
          break;
      }
      v && (yield this.engine.client.sendSimulateScenario(v), yield l());
    });
  }
  /**
   * Returns true if audio playback is enabled
   */
  get canPlaybackAudio() {
    return this.audioEnabled;
  }
  /**
   * Returns true if video playback is enabled
   */
  get canPlaybackVideo() {
    return !this.isVideoPlaybackBlocked;
  }
  getActiveDevice(u) {
    return this.localParticipant.activeDeviceMap.get(u);
  }
  /**
   * Switches all active devices used in this room to the given device.
   *
   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)
   *
   * @param kind use `videoinput` for camera track,
   *  `audioinput` for microphone track,
   *  `audiooutput` to set speaker for all incoming audio tracks
   * @param deviceId
   */
  switchActiveDevice(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    var v, S, g;
    return __awaiter(this, void 0, void 0, function* () {
      let E = !1, _ = !0;
      const k = l ? {
        exact: c
      } : c;
      if (u === "audioinput") {
        const L = this.options.audioCaptureDefaults.deviceId;
        this.options.audioCaptureDefaults.deviceId = k, E = L !== k;
        const M = Array.from(this.localParticipant.audioTrackPublications.values()).filter(($) => $.source === Track.Source.Microphone);
        try {
          _ = (yield Promise.all(M.map(($) => {
            var J;
            return (J = $.audioTrack) === null || J === void 0 ? void 0 : J.setDeviceId(k);
          }))).every(($) => $ === !0);
        } catch ($) {
          throw this.options.audioCaptureDefaults.deviceId = L, $;
        }
      } else if (u === "videoinput") {
        const L = this.options.videoCaptureDefaults.deviceId;
        this.options.videoCaptureDefaults.deviceId = k, E = L !== k;
        const M = Array.from(this.localParticipant.videoTrackPublications.values()).filter(($) => $.source === Track.Source.Camera);
        try {
          _ = (yield Promise.all(M.map(($) => {
            var J;
            return (J = $.videoTrack) === null || J === void 0 ? void 0 : J.setDeviceId(k);
          }))).every(($) => $ === !0);
        } catch ($) {
          throw this.options.videoCaptureDefaults.deviceId = L, $;
        }
      } else if (u === "audiooutput") {
        if (!supportsSetSinkId() && !this.options.webAudioMix || this.options.webAudioMix && this.audioContext && !("setSinkId" in this.audioContext))
          throw new Error("cannot switch audio output, setSinkId not supported");
        (v = (g = this.options).audioOutput) !== null && v !== void 0 || (g.audioOutput = {});
        const L = this.options.audioOutput.deviceId;
        this.options.audioOutput.deviceId = c, E = L !== k;
        try {
          this.options.webAudioMix ? (S = this.audioContext) === null || S === void 0 || S.setSinkId(c) : yield Promise.all(Array.from(this.remoteParticipants.values()).map((M) => M.setAudioOutput({
            deviceId: c
          })));
        } catch (M) {
          throw this.options.audioOutput.deviceId = L, M;
        }
      }
      return E && _ && (this.localParticipant.activeDeviceMap.set(u, c), this.emit(RoomEvent.ActiveDeviceChanged, u, c)), _;
    });
  }
  setupLocalParticipantEvents() {
    this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);
  }
  recreateEngine() {
    var u;
    (u = this.engine) === null || u === void 0 || u.close(), this.engine = void 0, this.isResuming = !1, this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.bufferedEvents = [], this.maybeCreateEngine();
  }
  onTrackAdded(u, c, l) {
    if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {
      const L = () => {
        this.onTrackAdded(u, c, l), M();
      }, M = () => {
        this.off(RoomEvent.Reconnected, L), this.off(RoomEvent.Connected, L), this.off(RoomEvent.Disconnected, M);
      };
      this.once(RoomEvent.Reconnected, L), this.once(RoomEvent.Connected, L), this.once(RoomEvent.Disconnected, M);
      return;
    }
    if (this.state === ConnectionState.Disconnected) {
      this.log.warn("skipping incoming track after Room disconnected", this.logContext);
      return;
    }
    const v = unpackStreamId(c.id), S = v[0];
    let g = v[1], E = u.id;
    if (g && g.startsWith("TR") && (E = g), S === this.localParticipant.sid) {
      this.log.warn("tried to create RemoteParticipant for local participant", this.logContext);
      return;
    }
    const _ = Array.from(this.remoteParticipants.values()).find((L) => L.sid === S);
    if (!_) {
      this.log.error("Tried to add a track for a participant, that's not present. Sid: ".concat(S), this.logContext);
      return;
    }
    let k;
    this.options.adaptiveStream && (typeof this.options.adaptiveStream == "object" ? k = this.options.adaptiveStream : k = {}), _.addSubscribedMediaTrack(u, E, c, l, k);
  }
  handleDisconnect() {
    let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, c = arguments.length > 1 ? arguments[1] : void 0;
    var l;
    if (this.clearConnectionReconcile(), this.isResuming = !1, this.bufferedEvents = [], this.state !== ConnectionState.Disconnected) {
      this.regionUrl = void 0;
      try {
        this.remoteParticipants.forEach((v) => {
          v.trackPublications.forEach((S) => {
            v.unpublishTrack(S.trackSid);
          });
        }), this.localParticipant.trackPublications.forEach((v) => {
          var S, g;
          v.track && this.localParticipant.unpublishTrack(v.track, u), u && ((S = v.track) === null || S === void 0 || S.detach(), (g = v.track) === null || g === void 0 || g.stop());
        }), this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged), this.localParticipant.trackPublications.clear(), this.localParticipant.videoTrackPublications.clear(), this.localParticipant.audioTrackPublications.clear(), this.remoteParticipants.clear(), this.sidToIdentity.clear(), this.activeSpeakers = [], this.audioContext && typeof this.options.webAudioMix == "boolean" && (this.audioContext.close(), this.audioContext = void 0), isWeb() && (window.removeEventListener("beforeunload", this.onPageLeave), window.removeEventListener("pagehide", this.onPageLeave), window.removeEventListener("freeze", this.onPageLeave), (l = navigator.mediaDevices) === null || l === void 0 || l.removeEventListener("devicechange", this.handleDeviceChange));
      } finally {
        this.setAndEmitConnectionState(ConnectionState.Disconnected), this.emit(RoomEvent.Disconnected, c);
      }
    }
  }
  handleParticipantDisconnected(u, c) {
    this.remoteParticipants.delete(u), c && (c.trackPublications.forEach((l) => {
      c.unpublishTrack(l.trackSid, !0);
    }), this.emit(RoomEvent.ParticipantDisconnected, c));
  }
  acquireAudioContext() {
    var u, c;
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof this.options.webAudioMix != "boolean" && this.options.webAudioMix.audioContext ? this.audioContext = this.options.webAudioMix.audioContext : (!this.audioContext || this.audioContext.state === "closed") && (this.audioContext = (u = getNewAudioContext()) !== null && u !== void 0 ? u : void 0), this.audioContext && this.audioContext.state === "suspended")
        try {
          yield this.audioContext.resume();
        } catch (v) {
          this.log.warn("Could not resume audio context", Object.assign(Object.assign({}, this.logContext), {
            error: v
          }));
        }
      this.options.webAudioMix && this.remoteParticipants.forEach((v) => v.setAudioContext(this.audioContext)), this.localParticipant.setAudioContext(this.audioContext);
      const l = ((c = this.audioContext) === null || c === void 0 ? void 0 : c.state) === "running";
      l !== this.canPlaybackAudio && (this.audioEnabled = l, this.emit(RoomEvent.AudioPlaybackStatusChanged, l));
    });
  }
  createParticipant(u, c) {
    var l;
    let v;
    return c ? v = RemoteParticipant.fromParticipantInfo(this.engine.client, c) : v = new RemoteParticipant(this.engine.client, "", u, void 0, void 0, {
      loggerContextCb: () => this.logContext,
      loggerName: this.options.loggerName
    }), this.options.webAudioMix && v.setAudioContext(this.audioContext), !((l = this.options.audioOutput) === null || l === void 0) && l.deviceId && v.setAudioOutput(this.options.audioOutput).catch((S) => this.log.warn("Could not set audio output: ".concat(S.message), this.logContext)), v;
  }
  getOrCreateParticipant(u, c) {
    if (this.remoteParticipants.has(u)) {
      const v = this.remoteParticipants.get(u);
      return c && v.updateInfo(c) && this.sidToIdentity.set(c.sid, c.identity), v;
    }
    const l = this.createParticipant(u, c);
    return this.remoteParticipants.set(u, l), this.sidToIdentity.set(c.sid, c.identity), this.emitWhenConnected(RoomEvent.ParticipantConnected, l), l.on(ParticipantEvent.TrackPublished, (v) => {
      this.emitWhenConnected(RoomEvent.TrackPublished, v, l);
    }).on(ParticipantEvent.TrackSubscribed, (v, S) => {
      v.kind === Track.Kind.Audio ? (v.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted), v.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed)) : v.kind === Track.Kind.Video && (v.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed), v.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted)), this.emit(RoomEvent.TrackSubscribed, v, S, l);
    }).on(ParticipantEvent.TrackUnpublished, (v) => {
      this.emit(RoomEvent.TrackUnpublished, v, l);
    }).on(ParticipantEvent.TrackUnsubscribed, (v, S) => {
      this.emit(RoomEvent.TrackUnsubscribed, v, S, l);
    }).on(ParticipantEvent.TrackSubscriptionFailed, (v) => {
      this.emit(RoomEvent.TrackSubscriptionFailed, v, l);
    }).on(ParticipantEvent.TrackMuted, (v) => {
      this.emitWhenConnected(RoomEvent.TrackMuted, v, l);
    }).on(ParticipantEvent.TrackUnmuted, (v) => {
      this.emitWhenConnected(RoomEvent.TrackUnmuted, v, l);
    }).on(ParticipantEvent.ParticipantMetadataChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, v, l);
    }).on(ParticipantEvent.ParticipantNameChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantNameChanged, v, l);
    }).on(ParticipantEvent.ConnectionQualityChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, v, l);
    }).on(ParticipantEvent.ParticipantPermissionsChanged, (v) => {
      this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, v, l);
    }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (v, S) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, v, S, l);
    }).on(ParticipantEvent.TrackSubscriptionFailed, (v, S) => {
      this.emit(RoomEvent.TrackSubscriptionFailed, v, l, S);
    }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (v, S) => {
      this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, v, S, l);
    }), c && l.updateInfo(c), l;
  }
  sendSyncState() {
    const u = Array.from(this.remoteParticipants.values()).reduce((l, v) => (l.push(...v.getTrackPublications()), l), []), c = this.localParticipant.getTrackPublications();
    this.engine.sendSyncState(u, c);
  }
  /**
   * After resuming, we'll need to notify the server of the current
   * subscription settings.
   */
  updateSubscriptions() {
    for (const u of this.remoteParticipants.values())
      for (const c of u.videoTrackPublications.values())
        c.isSubscribed && c instanceof RemoteTrackPublication && c.emitTrackUpdate();
  }
  getRemoteParticipantBySid(u) {
    const c = this.sidToIdentity.get(u);
    if (c)
      return this.remoteParticipants.get(c);
  }
  registerConnectionReconcile() {
    this.clearConnectionReconcile();
    let u = 0;
    this.connectionReconcileInterval = CriticalTimers.setInterval(() => {
      // ensure we didn't tear it down
      !this.engine || // engine detected close, but Room missed it
      this.engine.isClosed || // transports failed without notifying engine
      !this.engine.verifyTransport() ? (u++, this.log.warn("detected connection state mismatch", Object.assign(Object.assign({}, this.logContext), {
        numFailures: u,
        engine: {
          closed: this.engine.isClosed,
          transportsConnected: this.engine.verifyTransport()
        }
      })), u >= 3 && (this.recreateEngine(), this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH))) : u = 0;
    }, connectionReconcileFrequency);
  }
  clearConnectionReconcile() {
    this.connectionReconcileInterval && CriticalTimers.clearInterval(this.connectionReconcileInterval);
  }
  setAndEmitConnectionState(u) {
    return u === this.state ? !1 : (this.state = u, this.emit(RoomEvent.ConnectionStateChanged, this.state), !0);
  }
  emitBufferedEvents() {
    this.bufferedEvents.forEach((u) => {
      let [c, l] = u;
      this.emit(c, ...l);
    }), this.bufferedEvents = [];
  }
  emitWhenConnected(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect)
      this.bufferedEvents.push([u, l]);
    else if (this.state === ConnectionState.Connected)
      return this.emit(u, ...l);
    return !1;
  }
  /**
   * Allows to populate a room with simulated participants.
   * No actual connection to a server will be established, all state is
   * @experimental
   */
  simulateParticipants(u) {
    var c, l;
    return __awaiter(this, void 0, void 0, function* () {
      const v = Object.assign({
        audio: !0,
        video: !0,
        useRealTracks: !1
      }, u.publish), S = Object.assign({
        count: 9,
        audio: !1,
        video: !0,
        aspectRatios: [1.66, 1.7, 1.3]
      }, u.participants);
      if (this.handleDisconnect(), this.roomInfo = new Room$1({
        sid: "RM_SIMULATED",
        name: "simulated-room",
        emptyTimeout: 0,
        maxParticipants: 0,
        creationTime: protoInt64.parse((/* @__PURE__ */ new Date()).getTime()),
        metadata: "",
        numParticipants: 1,
        numPublishers: 1,
        turnPassword: "",
        enabledCodecs: [],
        activeRecording: !1
      }), this.localParticipant.updateInfo(new ParticipantInfo({
        identity: "simulated-local",
        name: "local-name"
      })), this.setupLocalParticipantEvents(), this.emit(RoomEvent.SignalConnected), this.emit(RoomEvent.Connected), this.setAndEmitConnectionState(ConnectionState.Connected), v.video) {
        const g = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({
          source: TrackSource.CAMERA,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO,
          name: "video-dummy"
        }), new LocalVideoTrack(v.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({
          video: !0
        })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((c = S.aspectRatios[0]) !== null && c !== void 0 ? c : 1), 160, !0, !0), void 0, !1, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(g), this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, g);
      }
      if (v.audio) {
        const g = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({
          source: TrackSource.MICROPHONE,
          sid: Math.floor(Math.random() * 1e4).toString(),
          type: TrackType.AUDIO
        }), new LocalAudioTrack(v.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({
          audio: !0
        })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), void 0, !1, this.audioContext, {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        }), {
          loggerName: this.options.loggerName,
          loggerContextCb: () => this.logContext
        });
        this.localParticipant.addTrackPublication(g), this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, g);
      }
      for (let g = 0; g < S.count - 1; g += 1) {
        let E = new ParticipantInfo({
          sid: Math.floor(Math.random() * 1e4).toString(),
          identity: "simulated-".concat(g),
          state: ParticipantInfo_State.ACTIVE,
          tracks: [],
          joinedAt: protoInt64.parse(Date.now())
        });
        const _ = this.getOrCreateParticipant(E.identity, E);
        if (S.video) {
          const k = createDummyVideoStreamTrack(160 * ((l = S.aspectRatios[g % S.aspectRatios.length]) !== null && l !== void 0 ? l : 1), 160, !1, !0), L = new TrackInfo({
            source: TrackSource.CAMERA,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          });
          _.addSubscribedMediaTrack(k, L.sid, new MediaStream([k])), E.tracks = [...E.tracks, L];
        }
        if (S.audio) {
          const k = getEmptyAudioStreamTrack(), L = new TrackInfo({
            source: TrackSource.MICROPHONE,
            sid: Math.floor(Math.random() * 1e4).toString(),
            type: TrackType.AUDIO
          });
          _.addSubscribedMediaTrack(k, L.sid, new MediaStream([k])), E.tracks = [...E.tracks, L];
        }
        _.updateInfo(E);
      }
    });
  }
  // /** @internal */
  emit(u) {
    for (var c = arguments.length, l = new Array(c > 1 ? c - 1 : 0), v = 1; v < c; v++)
      l[v - 1] = arguments[v];
    if (u !== RoomEvent.ActiveSpeakersChanged) {
      const S = mapArgs(l).filter((g) => g !== void 0);
      this.log.debug("room event ".concat(u), Object.assign(Object.assign({}, this.logContext), {
        event: u,
        args: S
      }));
    }
    return super.emit(u, ...l);
  }
}
function mapArgs(a) {
  return a.map((u) => {
    if (u)
      return Array.isArray(u) ? mapArgs(u) : typeof u == "object" ? "logContext" in u && u.logContext : u;
  });
}
var CheckStatus;
(function(a) {
  a[a.IDLE = 0] = "IDLE", a[a.RUNNING = 1] = "RUNNING", a[a.SKIPPED = 2] = "SKIPPED", a[a.SUCCESS = 3] = "SUCCESS", a[a.FAILED = 4] = "FAILED";
})(CheckStatus || (CheckStatus = {}));
class Checker extends eventsExports.EventEmitter {
  constructor(u, c) {
    let l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    super(), this.status = CheckStatus.IDLE, this.logs = [], this.errorsAsWarnings = !1, this.url = u, this.token = c, this.name = this.constructor.name, this.room = new Room(l.roomOptions), this.connectOptions = l.connectOptions, l.errorsAsWarnings && (this.errorsAsWarnings = l.errorsAsWarnings);
  }
  run(u) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.status !== CheckStatus.IDLE)
        throw Error("check is running already");
      this.setStatus(CheckStatus.RUNNING);
      try {
        yield this.perform();
      } catch (c) {
        c instanceof Error && (this.errorsAsWarnings ? this.appendWarning(c.message) : this.appendError(c.message));
      }
      return yield this.disconnect(), yield new Promise((c) => setTimeout(c, 500)), this.status !== CheckStatus.SKIPPED && this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED), u && u(), this.getInfo();
    });
  }
  isSuccess() {
    return !this.logs.some((u) => u.level === "error");
  }
  connect() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.room.state === ConnectionState.Connected ? this.room : (yield this.room.connect(this.url, this.token), this.room);
    });
  }
  disconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      this.room && this.room.state !== ConnectionState.Disconnected && (yield this.room.disconnect(), yield new Promise((u) => setTimeout(u, 500)));
    });
  }
  skip() {
    this.setStatus(CheckStatus.SKIPPED);
  }
  appendMessage(u) {
    this.logs.push({
      level: "info",
      message: u
    }), this.emit("update", this.getInfo());
  }
  appendWarning(u) {
    this.logs.push({
      level: "warning",
      message: u
    }), this.emit("update", this.getInfo());
  }
  appendError(u) {
    this.logs.push({
      level: "error",
      message: u
    }), this.emit("update", this.getInfo());
  }
  setStatus(u) {
    this.status = u, this.emit("update", this.getInfo());
  }
  get engine() {
    var u;
    return (u = this.room) === null || u === void 0 ? void 0 : u.engine;
  }
  getInfo() {
    return {
      logs: this.logs,
      name: this.name,
      status: this.status,
      description: this.description
    };
  }
}
function createLocalTracks(a) {
  var u, c;
  return __awaiter(this, void 0, void 0, function* () {
    a ?? (a = {}), (u = a.audio) !== null && u !== void 0 || (a.audio = !0), (c = a.video) !== null && c !== void 0 || (a.video = !0);
    const l = mergeDefaultOptions(a, audioDefaults, videoDefaults), v = constraintsForOptions(l), S = navigator.mediaDevices.getUserMedia(v);
    a.audio && (DeviceManager.userMediaPromiseMap.set("audioinput", S), S.catch(() => DeviceManager.userMediaPromiseMap.delete("audioinput"))), a.video && (DeviceManager.userMediaPromiseMap.set("videoinput", S), S.catch(() => DeviceManager.userMediaPromiseMap.delete("videoinput")));
    const g = yield S;
    return g.getTracks().map((E) => {
      const _ = E.kind === "audio";
      _ ? a.audio : a.video;
      let k;
      const L = _ ? v.audio : v.video;
      typeof L != "boolean" && (k = L), k ? k.deviceId = E.getSettings().deviceId : k = {
        deviceId: E.getSettings().deviceId
      };
      const M = mediaTrackToLocalTrack(E, k);
      return M.kind === Track.Kind.Video ? M.source = Track.Source.Camera : M.kind === Track.Kind.Audio && (M.source = Track.Source.Microphone), M.mediaStream = g, M;
    });
  });
}
function createLocalVideoTrack(a) {
  return __awaiter(this, void 0, void 0, function* () {
    return (yield createLocalTracks({
      audio: !1,
      video: a
    }))[0];
  });
}
function createLocalAudioTrack(a) {
  return __awaiter(this, void 0, void 0, function* () {
    return (yield createLocalTracks({
      audio: a,
      video: !1
    }))[0];
  });
}
class PublishAudioCheck extends Checker {
  get description() {
    return "Can publish audio";
  }
  perform() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield this.connect(), l = yield createLocalAudioTrack();
      c.localParticipant.publishTrack(l), yield new Promise((g) => setTimeout(g, 3e3));
      const v = yield (u = l.sender) === null || u === void 0 ? void 0 : u.getStats();
      if (!v)
        throw new Error("Could not get RTCStats");
      let S = 0;
      if (v.forEach((g) => {
        g.type === "outbound-rtp" && g.mediaType === "audio" && (S = g.packetsSent);
      }), S === 0)
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat(S, " audio packets"));
    });
  }
}
class PublishVideoCheck extends Checker {
  get description() {
    return "Can publish video";
  }
  perform() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield this.connect(), l = yield createLocalVideoTrack();
      c.localParticipant.publishTrack(l), yield new Promise((g) => setTimeout(g, 3e3));
      const v = yield (u = l.sender) === null || u === void 0 ? void 0 : u.getStats();
      if (!v)
        throw new Error("Could not get RTCStats");
      let S = 0;
      if (v.forEach((g) => {
        g.type === "outbound-rtp" && g.mediaType === "video" && (S = g.packetsSent);
      }), S === 0)
        throw new Error("Could not determine packets are sent");
      this.appendMessage("published ".concat(S, " video packets"));
    });
  }
}
class ReconnectCheck extends Checker {
  get description() {
    return "Resuming connection after interruption";
  }
  perform() {
    var u;
    return __awaiter(this, void 0, void 0, function* () {
      const c = yield this.connect();
      let l = !1, v = !1, S;
      const g = new Promise((_) => {
        setTimeout(_, 5e3), S = _;
      });
      c.on(RoomEvent.Reconnecting, () => {
        l = !0;
      }).on(RoomEvent.Reconnected, () => {
        v = !0, S(!0);
      }), (u = c.engine.client.ws) === null || u === void 0 || u.close();
      const E = c.engine.client.onClose;
      if (E && E(""), yield g, l) {
        if (!v || c.state !== ConnectionState.Connected)
          throw this.appendWarning("reconnection is only possible in Redis-based configurations"), new Error("Not able to reconnect");
      } else
        throw new Error("Did not attempt to reconnect");
    });
  }
}
class TURNCheck extends Checker {
  get description() {
    return "Can connect via TURN";
  }
  perform() {
    var u, c;
    return __awaiter(this, void 0, void 0, function* () {
      const l = new SignalClient(), v = yield l.join(this.url, this.token, {
        autoSubscribe: !0,
        maxRetries: 0,
        e2eeEnabled: !1,
        websocketTimeout: 15e3
      });
      let S = !1, g = !1, E = !1;
      for (let _ of v.iceServers)
        for (let k of _.urls)
          k.startsWith("turn:") ? (g = !0, E = !0) : k.startsWith("turns:") && (g = !0, E = !0, S = !0), k.startsWith("stun:") && (E = !0);
      E ? g && !S && this.appendWarning("TURN is configured server side, but TURN/TLS is unavailable.") : this.appendWarning("No STUN servers configured on server side."), yield l.close(), !((c = (u = this.connectOptions) === null || u === void 0 ? void 0 : u.rtcConfig) === null || c === void 0) && c.iceServers || g ? yield this.room.connect(this.url, this.token, {
        rtcConfig: {
          iceTransportPolicy: "relay"
        }
      }) : (this.appendWarning("No TURN servers configured."), this.skip(), yield new Promise((_) => setTimeout(_, 0)));
    });
  }
}
class WebRTCCheck extends Checker {
  get description() {
    return "Establishing WebRTC connection";
  }
  perform() {
    return __awaiter(this, void 0, void 0, function* () {
      let u = !1, c = !1;
      this.room.on(RoomEvent.SignalConnected, () => {
        const l = this.room.engine.client.onTrickle;
        this.room.engine.client.onTrickle = (v, S) => {
          if (v.candidate) {
            const g = new RTCIceCandidate(v);
            let E = "".concat(g.protocol, " ").concat(g.address, ":").concat(g.port, " ").concat(g.type);
            g.address && (isIPPrivate(g.address) ? E += " (private)" : g.protocol === "tcp" && g.tcpType === "passive" ? (u = !0, E += " (passive)") : g.protocol === "udp" && (c = !0)), this.appendMessage(E);
          }
          l && l(v, S);
        }, this.room.engine.pcManager && (this.room.engine.pcManager.subscriber.onIceCandidateError = (v) => {
          v instanceof RTCPeerConnectionIceErrorEvent && this.appendWarning("error with ICE candidate: ".concat(v.errorCode, " ").concat(v.errorText, " ").concat(v.url));
        });
      });
      try {
        yield this.connect(), livekitLogger.info("now the room is connected");
      } catch (l) {
        throw this.appendWarning("ports need to be open on firewall in order to connect."), l;
      }
      u || this.appendWarning("Server is not configured for ICE/TCP"), c || this.appendWarning("No public IPv4 UDP candidates were found. Your server is likely not configured correctly");
    });
  }
}
function isIPPrivate(a) {
  const u = a.split(".");
  if (u.length === 4) {
    if (u[0] === "10")
      return !0;
    if (u[0] === "192" && u[1] === "168")
      return !0;
    if (u[0] === "172") {
      const c = parseInt(u[1], 10);
      if (c >= 16 && c <= 31)
        return !0;
    }
  }
  return !1;
}
class WebSocketCheck extends Checker {
  get description() {
    return "Connecting to signal connection via WebSocket";
  }
  perform() {
    var u, c, l;
    return __awaiter(this, void 0, void 0, function* () {
      (this.url.startsWith("ws:") || this.url.startsWith("http:")) && this.appendWarning("Server is insecure, clients may block connections to it");
      let v = new SignalClient();
      const S = yield v.join(this.url, this.token, {
        autoSubscribe: !0,
        maxRetries: 0,
        e2eeEnabled: !1,
        websocketTimeout: 15e3
      });
      this.appendMessage("Connected to server, version ".concat(S.serverVersion, ".")), ((u = S.serverInfo) === null || u === void 0 ? void 0 : u.edition) === ServerInfo_Edition.Cloud && (!((c = S.serverInfo) === null || c === void 0) && c.region) && this.appendMessage("LiveKit Cloud: ".concat((l = S.serverInfo) === null || l === void 0 ? void 0 : l.region)), yield v.close();
    });
  }
}
class ConnectionCheck extends eventsExports.EventEmitter {
  constructor(u, c) {
    super(), this.checkResults = /* @__PURE__ */ new Map(), this.url = u, this.token = c;
  }
  getNextCheckId() {
    const u = this.checkResults.size;
    return this.checkResults.set(u, {
      logs: [],
      status: CheckStatus.IDLE,
      name: "",
      description: ""
    }), u;
  }
  updateCheck(u, c) {
    this.checkResults.set(u, c), this.emit("checkUpdate", u, c);
  }
  isSuccess() {
    return Array.from(this.checkResults.values()).every((u) => u.status !== CheckStatus.FAILED);
  }
  getResults() {
    return Array.from(this.checkResults.values());
  }
  createAndRunCheck(u) {
    return __awaiter(this, void 0, void 0, function* () {
      const c = this.getNextCheckId(), l = new u(this.url, this.token), v = (g) => {
        this.updateCheck(c, g);
      };
      l.on("update", v);
      const S = yield l.run();
      return l.off("update", v), S;
    });
  }
  checkWebsocket() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebSocketCheck);
    });
  }
  checkWebRTC() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createAndRunCheck(WebRTCCheck);
    });
  }
  checkTURN() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createAndRunCheck(TURNCheck);
    });
  }
  checkReconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createAndRunCheck(ReconnectCheck);
    });
  }
  checkPublishAudio() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishAudioCheck);
    });
  }
  checkPublishVideo() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.createAndRunCheck(PublishVideoCheck);
    });
  }
}
const Rendering = lib$2.LiveApiModel.Rendering, VideoRendering = lib$2.LiveApiModel.VideoRendering, AudioRendering = lib$2.LiveApiModel.AudioRendering, RenderingQuality = lib$2.LiveApiModel.RenderingQuality, Encoding = lib$2.LiveApiModel.Encoding, VideoEncoding = lib$2.LiveApiModel.VideoEncoding, AudioEncoding = lib$2.LiveApiModel.AudioEncoding, ProjectBroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase, Role = lib$2.LiveApiModel.Role, DestinationAddress = lib$2.LiveApiModel.DestinationAddress, VideoCodec = lib$2.LiveApiModel.VideoCodec, AudioCodec = lib$2.LiveApiModel.AudioCodec, VideoCodecRateControl = lib$2.LiveApiModel.VideoCodecRateControl, VideoCodecProfile = lib$2.LiveApiModel.VideoCodecProfile, types$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AudioCodec,
  AudioEncoding,
  AudioRendering,
  DestinationAddress,
  Encoding,
  ProjectBroadcastPhase,
  Rendering,
  RenderingQuality,
  Role,
  VideoCodec,
  VideoCodecProfile,
  VideoCodecRateControl,
  VideoEncoding,
  VideoRendering
}, Symbol.toStringTag, { value: "Module" }));
var Permission = /* @__PURE__ */ ((a) => (a[a.ReadProject = 0] = "ReadProject", a[a.UpdateProject = 1] = "UpdateProject", a[a.JoinRoom = 2] = "JoinRoom", a[a.InviteGuests = 3] = "InviteGuests", a[a.ManageGuests = 4] = "ManageGuests", a[a.ManageBroadcast = 5] = "ManageBroadcast", a[a.ManageSelf = 6] = "ManageSelf", a))(Permission || {});
const permissions = {
  [Role.ROLE_HOST]: [
    0,
    1,
    2,
    3,
    4,
    5
    /* ManageBroadcast */
  ],
  [Role.ROLE_COHOST]: [
    0,
    1,
    2,
    3,
    4,
    5
    /* ManageBroadcast */
  ],
  [Role.ROLE_CONTRIBUTOR]: [
    0,
    1,
    2,
    3
    /* InviteGuests */
  ],
  [Role.ROLE_GUEST]: [
    0,
    2,
    6
    /* ManageSelf */
  ],
  [Role.ROLE_VIEWER]: [
    0,
    2
    /* JoinRoom */
  ],
  [Role.ROLE_IMPERSONATE]: [
    0,
    1,
    3,
    4,
    5
    /* ManageBroadcast */
  ]
}, hasPermission = (a, u) => {
  var c;
  return a ? !!((c = permissions[a]) != null && c.find((l) => l === u)) : !1;
};
var DataType = /* @__PURE__ */ ((a) => (a.ChatMessage = "ChatMessage", a.ParticipantMetadataUpdate = "ParticipantMetadataUpdate", a))(DataType || {}), SpecialEvent = /* @__PURE__ */ ((a) => (a.Chat = "Chat", a))(SpecialEvent || {});
const decoder$1 = new TextDecoder(), encoder$1 = new TextEncoder();
class RoomsManager {
  constructor() {
    ht(this, "rooms");
    this.rooms = /* @__PURE__ */ new Map(), this.addRoom = this.addRoom.bind(this), this.ensureRoom = this.ensureRoom.bind(this), this.removeRoom = this.removeRoom.bind(this);
  }
  addRoom(u, c, l) {
    const v = new RoomContext(u, c, l, this);
    return this.rooms.set(c, v), v;
  }
  ensureRoom(u, c, l) {
    return this.rooms.get(c) ? (this.rooms.get(c).token = l, this.rooms.get(c)) : this.addRoom(u, c, l);
  }
  async removeRoom(u) {
    const c = this.rooms.get(u);
    if (!Room)
      throw new Error("room not found!");
    if (c.isConnecting)
      throw new Error("Cannot remove room: Room is in connecting state");
    c.livekitRoom && await c.livekitRoom.disconnect(!0), this.rooms.delete(u);
  }
}
class RoomContext {
  /**
   * @param baseUrl base url for the webrtc server
   * @param token get
   */
  constructor(u, c, l, v) {
    /**
     * base URL for the webrtc server
     */
    ht(this, "_baseUrl");
    ht(this, "_chatHistory");
    /**
     * event listeners just for livekit room connect
     */
    ht(this, "_connectListeners");
    /**
     * Event listeners that are registered OR to be registered upon connection
     * Keys are of type RoomEvent
     */
    ht(this, "_roomEventListenerRegistry");
    /**
     * Event listeners that are registered OR to be registered on the localParticipant upon connection
     * Keys are of type ParticipantEvent
     */
    ht(this, "_localParticipantEventListenerRegistry");
    /**
     * Registry for special/custom events such as chat events
     */
    ht(this, "_specialEventListenerRegistry");
    /**
     * access token for our connection
     * Should be acquired from vapi
     */
    ht(this, "_jwt");
    /**
     * reference to the rooms manager that contains it
     */
    ht(this, "_manager");
    ht(this, "_apiClient");
    ht(this, "audioTracks");
    ht(this, "isConnecting");
    ht(this, "livekitRoom");
    ht(this, "participants");
    ht(this, "guestParticipantMetadata");
    ht(this, "roomName");
    /**
     * Livekit Room Service client, for performing admin functions
     * Should only be defined if user is room admin
     */
    ht(this, "_admin");
    let S = CoreContext.logLevel.toLowerCase();
    setLogLevel(S), this.livekitRoom = new Room({
      // automatically manage subscribed video quality
      // adaptiveStream: true,
      // optimize publishing bandwidth and CPU for published tracks
      dynacast: !0,
      // default capture settings
      videoCaptureDefaults: {
        resolution: VideoPresets.h720.resolution
      }
    }), this._baseUrl = u, this._connectListeners = [], this._roomEventListenerRegistry = {}, this._jwt = l, Object.values(RoomEvent).forEach((g) => {
      this._roomEventListenerRegistry[g] = /* @__PURE__ */ new Set();
    }), this._localParticipantEventListenerRegistry = {}, Object.values(ParticipantEvent).forEach((g) => {
      this._localParticipantEventListenerRegistry[g] = /* @__PURE__ */ new Set();
    }), this._specialEventListenerRegistry = {}, this._manager = v, this._chatHistory = [], this.roomName = c, this.audioTracks = [], this.participants = [], this.guestParticipantMetadata = [], this.isConnecting = !1, this.subscribeToRoomEvent(RoomEvent.DataReceived, (g, E) => {
      var L;
      const _ = decoder$1.decode(g);
      switch (JSON.parse(_).type) {
        case "ChatMessage":
          return this._appendChat(g, E);
        case "ParticipantMetadataUpdate": {
          const M = decoder$1.decode(g), $ = JSON.parse(M);
          hasPermission((L = $ == null ? void 0 : $.metadata) == null ? void 0 : L.participantRole, Permission.ManageSelf) && this._updateGuestParticipantsStore($);
          return;
        }
        default:
          return;
      }
    }), this.connect = this.connect.bind(this), this.subscribeToRoomEvent = this.subscribeToRoomEvent.bind(this), this.subscribeToConnect = this.subscribeToConnect.bind(this), this.subscribeToLocalParticipantEvent = this.subscribeToLocalParticipantEvent.bind(this), this.subscribeToSpecialEvent = this.subscribeToSpecialEvent.bind(this), this.unsubscribeFromRoomEvent = this.unsubscribeFromRoomEvent.bind(this), this.unsubscribeFromSpecialEvent = this.unsubscribeFromSpecialEvent.bind(this), this.unsubscribeFromConnect = this.unsubscribeFromConnect.bind(this), this.unsubscribeFromLocalParticipantEvent = this.unsubscribeFromLocalParticipantEvent.bind(this), this.sendChatMessage = this.sendChatMessage.bind(this), this.kickParticipant = this.kickParticipant.bind(this), this.updateParticipant = this.updateParticipant.bind(this), this.muteTrackAsAdmin = this.muteTrackAsAdmin.bind(this), this._updateParticipants = this._updateParticipants.bind(this), this.subscribeToRoomEvent(RoomEvent.ParticipantConnected, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.ParticipantDisconnected, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.TrackSubscribed, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.TrackUnsubscribed, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.LocalTrackPublished, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.LocalTrackUnpublished, this._updateParticipants), this.subscribeToRoomEvent(RoomEvent.Disconnected, () => {
      this._updateParticipants();
    }), this.subscribeToRoomEvent(RoomEvent.ParticipantMetadataChanged, (g, E) => {
      if (g !== (E == null ? void 0 : E.metadata)) {
        const _ = JSON.parse(E == null ? void 0 : E.metadata);
        if (hasPermission(_ == null ? void 0 : _.participantRole, Permission.ManageSelf)) {
          if (_.hasOwnProperty("isMirrored")) {
            const k = {
              participantId: E == null ? void 0 : E.identity,
              metadata: _,
              type: "ParticipantMetadataUpdate"
              /* ParticipantMetadataUpdate */
            };
            this._updateGuestParticipantsStore(k);
          }
          return;
        }
      }
    });
  }
  bindApiClient(u) {
    this._apiClient = u;
  }
  get isAdmin() {
    return jwtDecode(this._jwt).video.roomAdmin;
  }
  set isAdmin(u) {
    log$1.warn("isAdmin cannot be set");
  }
  get token() {
    return this._jwt;
  }
  set token(u) {
    this._jwt = u;
  }
  get url() {
    return this._baseUrl;
  }
  set url(u) {
  }
  get chatHistory() {
    return this._chatHistory;
  }
  set chatHistory(u) {
    this._chatHistory = u;
  }
  _updateGuestParticipantsStore(u) {
    if (!this.guestParticipantMetadata.length)
      this.guestParticipantMetadata.push(u);
    else {
      const c = this.guestParticipantMetadata.findIndex((l) => l.participantId === (u == null ? void 0 : u.participantId));
      c > -1 ? this.guestParticipantMetadata[c] = u : this.guestParticipantMetadata.push(u);
    }
  }
  _updateParticipants() {
    if (!this.livekitRoom || this.livekitRoom.state === ConnectionState.Disconnected) {
      this.participants = [];
      return;
    } else {
      const u = Array.from(this.livekitRoom.remoteParticipants.values()), c = [this.livekitRoom.localParticipant];
      c.push(...u), this.guestParticipantMetadata = this.guestParticipantMetadata.filter((l) => c.find((v) => (v == null ? void 0 : v.identity) === (l == null ? void 0 : l.participantId))), this.participants = c;
    }
  }
  /**
   * @param identity Identity of the user that you wish to kick
   */
  async kickParticipant(u) {
    if (this._admin)
      this._admin.removeParticipant(this.roomName, u);
    else
      throw new Error("no admin permissions");
  }
  updateParticipant(u, c) {
    if (this._admin) {
      const l = JSON.stringify(c);
      this._admin.updateParticipant(this.roomName, u, l);
    } else
      throw new Error("no admin permissions");
  }
  muteTrackAsAdmin(u, c = !0) {
    if (this._admin) {
      const l = this.participants.find((v) => [...v.audioTrackPublications.values(), ...v.videoTrackPublications.values()].find((S) => S.trackSid === u));
      if (!l) {
        log$1.warn("Could not find participant for track:", {
          trackSid: u
        });
        return;
      }
      this._admin.mutePublishedTrack(this.roomName, l == null ? void 0 : l.identity, u, c);
    } else
      throw new Error("no admin permissions");
  }
  _appendChat(u, c) {
    const l = decoder$1.decode(u), v = JSON.parse(l), S = c.identity, g = c.name, E = {
      ...v,
      displayName: g,
      sender: S
    };
    this.chatHistory = [...this.chatHistory, E], this._triggerSpecialEvents("Chat", E);
  }
  subscribeToConnect(u) {
    return this._connectListeners.push(u), () => this.unsubscribeFromConnect(u);
  }
  unsubscribeFromConnect(u) {
    this._connectListeners = this._connectListeners.filter((c) => c !== u);
  }
  subscribeToSpecialEvent(u, c) {
    return this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromSpecialEvent(u, c);
    };
  }
  unsubscribeFromSpecialEvent(u, c) {
    this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].delete(c);
  }
  _triggerSpecialEvents(u, ...c) {
    this._specialEventListenerRegistry[u] || (this._specialEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._specialEventListenerRegistry[u].forEach((l) => {
      l(...c);
    });
  }
  /**
   * connect to livekit webrtc room
   * @param {string} identity unique user name to be displayed to other users
   */
  async connect(u = {}) {
    var c, l;
    try {
      if (this.livekitRoom.state === "connected" || this.isConnecting)
        return;
      this.isConnecting = !0, await this.livekitRoom.connect(`wss://${this._baseUrl}`, this._jwt, {
        ...u
      }), this.isConnecting = !1, Object.values(RoomEvent).forEach((v) => {
        this.livekitRoom.on(v, (...S) => {
          this._roomEventListenerRegistry[v].forEach((g) => {
            g(...S);
          });
        });
      }), Object.values(ParticipantEvent).forEach((v) => {
        this.livekitRoom.localParticipant.on(v, (...S) => {
          this._localParticipantEventListenerRegistry[v].forEach((g) => {
            g(...S);
          });
        });
      }), this._updateParticipants(), this._connectListeners.forEach((v) => v(this.livekitRoom)), lib$2.LiveKitUtils.isRoomAdmin(this._jwt) ? (log$1.info("Room: Granting admin permissions"), log$1.debug("Livekit server: ", (c = this._apiClient) == null ? void 0 : c.getLiveKitServer(!0)), this._admin = new dist.RoomServiceClient((l = this._apiClient) == null ? void 0 : l.getLiveKitServer(!0), void 0, void 0, this._jwt)) : log$1.debug("Room: Not an admin");
    } catch (v) {
      this.isConnecting = !1, log$1.error(v);
    }
  }
  subscribeToLocalParticipantEvent(u, c) {
    return this._localParticipantEventListenerRegistry[u] || (this._localParticipantEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._localParticipantEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromLocalParticipantEvent(u, c);
    };
  }
  unsubscribeFromLocalParticipantEvent(u, c) {
    this._localParticipantEventListenerRegistry[u] || (this._localParticipantEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._localParticipantEventListenerRegistry[u].delete(c);
  }
  subscribeToRoomEvent(u, c) {
    return this._roomEventListenerRegistry[u] || (this._roomEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._roomEventListenerRegistry[u].add(c), () => {
      this.unsubscribeFromRoomEvent(u, c);
    };
  }
  unsubscribeFromRoomEvent(u, c) {
    this._roomEventListenerRegistry[u] || (this._roomEventListenerRegistry[u] = /* @__PURE__ */ new Set()), this._roomEventListenerRegistry[u].delete(c);
  }
  /**
   * Sends chat message to entire livekit room, or a private message (if specified) from local participant
   * @param {string[]} [recipients] The identities of the recipient participants. If undefined, will send message to all participants in the chat.
   * Only specify for private messages.
   * Do not include the local participant's identity in this.
   */
  sendChatMessage(u) {
    const {
      message: c,
      recipients: l,
      metadata: v
    } = u;
    if (!this.livekitRoom || this.livekitRoom.state !== "connected")
      return;
    const S = {
      type: "ChatMessage",
      recipients: l,
      metadata: v,
      content: c,
      timestamp: Date.now()
    }, g = JSON.stringify(S), E = encoder$1.encode(g);
    if ({
      ...S,
      sender: this.livekitRoom.localParticipant.identity,
      displayName: this.livekitRoom.localParticipant.identity
    }, l) {
      const _ = l.map(this.livekitRoom.getParticipantByIdentity);
      return this.livekitRoom.localParticipant.publishData(E, {
        reliable: !0,
        destinationIdentities: _.map((k) => k.identity)
      }).then(() => {
        this._appendChat(E, this.livekitRoom.localParticipant);
      });
    } else
      return this.livekitRoom.localParticipant.publishData(E, {
        reliable: !0
      }).then(() => {
        this._appendChat(E, this.livekitRoom.localParticipant);
      });
  }
}
const webrtcManager = new RoomsManager(), index$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  webrtcManager
}, Symbol.toStringTag, { value: "Module" })), encoder = new TextEncoder(), decoder = new TextDecoder(), simpleRooms = /* @__PURE__ */ new Map(), getRoom = (a) => {
  if (!a)
    return null;
  if (simpleRooms.get(a))
    return simpleRooms.get(a);
  const u = webrtcManager.rooms.get(a);
  if (!u)
    return null;
  const c = u.livekitRoom, l = c == null ? void 0 : c.localParticipant;
  window.__StudioRoom = c, l || log$1.warn("No local participant!");
  const v = {
    useTracks: /* @__PURE__ */ new Set(),
    useTrack: /* @__PURE__ */ new Map(),
    useParticipants: /* @__PURE__ */ new Set(),
    useParticipant: /* @__PURE__ */ new Map(),
    useChatHistory: /* @__PURE__ */ new Set()
  };
  let S = {
    tracks: [],
    participants: [],
    result: {
      participants: [],
      tracks: []
    },
    chat: u.chatHistory
  };
  const g = () => {
    const q = u.participants, G = u.guestParticipantMetadata, H = q.flatMap((Y) => Y.getTrackPublications().map((ne) => ({
      ...ne,
      participant: Y
    }))), B = {
      participants: q.map((Y) => {
        const ne = G.find((re) => re.participantId === Y.identity);
        if (ne) {
          let re = JSON.parse(Y.metadata);
          re = {
            ...re,
            ...ne.metadata
          }, Y.metadata = JSON.stringify(re);
        }
        const Z = JSON.parse(Y.metadata);
        return {
          id: Y.identity,
          isSelf: Y === l,
          connectionQuality: Y.connectionQuality,
          displayName: Z.displayName || Y.name,
          joinedAt: Y.joinedAt,
          role: Z.participantRole,
          meta: Z,
          trackIds: H.filter((re) => re.participant.sid === Y.sid).map((re) => re.trackSid)
        };
      }),
      tracks: H.map((Y) => {
        var Z, re, oe, de;
        const ne = JSON.parse((Z = Y == null ? void 0 : Y.participant) == null ? void 0 : Z.metadata);
        return {
          mediaStreamTrack: (re = Y.track) == null ? void 0 : re.mediaStreamTrack,
          id: Y.trackSid,
          participantId: (oe = Y.participant) == null ? void 0 : oe.identity,
          isMuted: (de = Y.track) == null ? void 0 : de.isMuted,
          type: Y.source,
          isExternal: !!(ne != null && ne[Y.trackSid])
        };
      })
    };
    S = {
      tracks: H,
      participants: q,
      result: B,
      chat: u.chatHistory
    }, v.useTracks.forEach((Y) => Y(B.tracks)), v.useTrack.forEach((Y, ne) => {
      ne(k(Y));
    }), v.useParticipants.forEach((Y) => Y(B.participants)), v.useParticipant.forEach((Y, ne) => {
      ne(L(Y));
    }), v.useChatHistory.forEach((Y) => {
      Y(S.chat);
    });
  }, E = [RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ParticipantMetadataChanged, RoomEvent.Disconnected, RoomEvent.TrackSubscribed, RoomEvent.TrackUnsubscribed, RoomEvent.LocalTrackPublished, RoomEvent.LocalTrackUnpublished, RoomEvent.ConnectionQualityChanged, RoomEvent.TrackMuted, RoomEvent.TrackUnmuted, RoomEvent.TrackStreamStateChanged];
  u.subscribeToRoomEvent(RoomEvent.DataReceived, (q, G, H) => {
    const B = decoder.decode(q);
    JSON.parse(B).type === DataType.ParticipantMetadataUpdate && g();
  }), E.map((q) => u.subscribeToRoomEvent(q, () => g())).push(u.subscribeToSpecialEvent(SpecialEvent.Chat, g));
  const k = (q) => S.result.tracks.find((G) => G.id === q), L = (q) => S.result.participants.find((G) => G.id === q), M = (q, G) => {
    const H = l.getTrackPublications().find((B) => B.trackSid === q);
    H && (G ? H.mute() : H.unmute());
  };
  let $, J;
  const V = {
    id: u.roomName,
    participantId: l.identity,
    setTrackEnabled: M,
    setCameraEnabled: (q = !0) => l.setCameraEnabled(q),
    setMicrophoneEnabled: (q = !0) => l.setMicrophoneEnabled(q),
    setCamera: async (q = {}) => {
      var H;
      if ($) {
        log$1.warn("Cannot set camera until previous has resolved");
        return;
      }
      $ = !0;
      let G;
      try {
        const Y = l.getTrackPublications().filter((Z) => (Z == null ? void 0 : Z.source) === Track.Source.Camera).find((Z) => !k(Z == null ? void 0 : Z.trackSid).isExternal), ne = await l.createTracks({
          video: {
            deviceId: q.deviceId,
            resolution: q.resolution || {
              width: 1280,
              height: 720,
              frameRate: 30,
              aspectRatio: 16 / 9
            }
          }
        });
        Y != null && Y.isMuted && ne.forEach((Z) => {
          Z.mute();
        }), G = await Promise.all(ne.map((Z) => l.publishTrack(Z))), Y && l.unpublishTrack(Y.track);
      } catch (B) {
        throw B;
      } finally {
        return $ = !1, k((H = G[0]) == null ? void 0 : H.trackSid);
      }
    },
    setMicrophone: async (q) => {
      var H;
      if (J) {
        log$1.warn("Cannot set microphone until previous has resolved");
        return;
      }
      J = !0;
      let G;
      try {
        const Y = l.getTrackPublications().filter((Z) => Z.source === Track.Source.Microphone).find((Z) => !k(Z == null ? void 0 : Z.trackSid).isExternal), ne = await l.createTracks({
          audio: q || !0
        });
        Y != null && Y.isMuted && ne.forEach((Z) => {
          Z.mute();
        }), G = await Promise.all(ne.map((Z) => l.publishTrack(Z))), Y && l.unpublishTrack(Y.track);
      } catch (B) {
        throw B;
      } finally {
        return J = !1, k((H = G[0]) == null ? void 0 : H.trackSid);
      }
    },
    addMicrophone: async (q) => {
      var ne;
      if (J) {
        log$1.warn("Cannot set microphone until previous has resolved");
        return;
      }
      J = !0;
      const G = await l.createTracks({
        audio: q || !0
      }), B = l.getTrackPublications().filter((Z) => Z.source === Track.Source.Microphone).find((Z) => {
        var oe, de;
        const re = k(Z == null ? void 0 : Z.trackSid);
        ((de = (oe = re == null ? void 0 : re.mediaStreamTrack) == null ? void 0 : oe.getSettings()) == null ? void 0 : de.deviceId) === q.deviceId && (re == null || re.isExternal);
      });
      B != null && B.isMuted && G.forEach((Z) => {
        Z.mute();
      });
      const Y = await Promise.all(G.map((Z) => l.publishTrack(Z)));
      return B && l.unpublishTrack(B.track), J = !1, k((ne = Y[0]) == null ? void 0 : ne.trackSid);
    },
    addCamera: async (q = {}) => {
      var Y;
      const G = await l.createTracks({
        video: {
          deviceId: q.deviceId,
          resolution: q.resolution || {
            width: 1280,
            height: 720,
            frameRate: 30,
            aspectRatio: 1.7777777777777777
          }
        }
      }), H = l.getTrackPublications().find((ne) => {
        var Z, re, oe;
        return (ne == null ? void 0 : ne.source) === Track.Source.Camera && ((oe = (re = (Z = ne == null ? void 0 : ne.track) == null ? void 0 : Z.mediaStreamTrack) == null ? void 0 : re.getSettings()) == null ? void 0 : oe.deviceId) === q.deviceId;
      });
      H != null && H.isMuted && G.forEach((ne) => {
        ne.mute();
      });
      const B = await Promise.all(G.map((ne) => l.publishTrack(ne)));
      return H && l.unpublishTrack(H.track), J = !1, k((Y = B[0]) == null ? void 0 : Y.trackSid);
    },
    addScreen: async (q = {
      audio: !1
    }) => {
      const G = await l.createScreenTracks(q), H = await Promise.all(G.map((ne) => l.publishTrack(ne))), B = H.find((ne) => ne.kind === "video"), Y = H.find((ne) => ne.kind === "audio");
      return {
        screen: k(B == null ? void 0 : B.trackSid),
        audio: k(Y == null ? void 0 : Y.trackSid)
      };
    },
    removeTrack: async (q) => {
      const G = S.tracks.find((H) => H.trackSid === q);
      l.unpublishTrack(G.track);
    },
    /* Setting the local participant metadata. */
    setLocalParticipantMetadata: async (q, G) => {
      const H = JSON.stringify(G), B = encoder.encode(JSON.stringify({
        metadata: G,
        type: DataType.ParticipantMetadataUpdate,
        participantId: q
      }));
      return l.setMetadata(H), await l.publishData(B, {
        reliable: !0
      });
    },
    setParticipantMetadata: (q, G) => u.updateParticipant(q, G),
    kickParticipant: u.kickParticipant,
    muteTrackAsAdmin: u.muteTrackAsAdmin,
    sendChatMessage: u.sendChatMessage,
    // Callbacks
    getTracks: () => S.result.tracks,
    useTracks: (q) => (v.useTracks.add(q), q(S.result.tracks), () => {
      v.useTracks.delete(q);
    }),
    getTrack: k,
    useTrack: (q, G) => (v.useTrack.set(G, q), G(k(q)), () => {
      v.useTrack.delete(G);
    }),
    getParticipant: L,
    getParticipants: () => S.result.participants,
    useParticipants: (q) => (v.useParticipants.add(q), q(S.result.participants), () => {
      v.useParticipants.delete(q);
    }),
    useParticipant: (q, G) => (v.useParticipant.set(G, q), G(L(q)), () => {
      v.useTrack.delete(G);
    }),
    useChatHistory: (q) => (v.useChatHistory.add(q), q(S.chat), () => {
      v.useChatHistory.delete(q);
    }),
    useActiveSpeakers: (q) => {
      var H, B;
      const G = (Y) => {
        q(Y.map((ne) => ne.identity));
      };
      return (H = u.livekitRoom) == null || H.on(RoomEvent.ActiveSpeakersChanged, G), G((B = u.livekitRoom) == null ? void 0 : B.activeSpeakers), () => {
        var Y;
        (Y = u.livekitRoom) == null || Y.off(RoomEvent.ActiveSpeakersChanged, G);
      };
    },
    sendData: (q, G = []) => {
      const H = encoder.encode(JSON.stringify(q)), B = G == null ? void 0 : G.map((Y) => {
        var ne;
        return (ne = u.livekitRoom) == null ? void 0 : ne.getParticipantByIdentity(Y);
      }).filter(Boolean);
      return l.publishData(H, {
        reliable: !0,
        destinationIdentities: B.map((Y) => Y.identity)
      });
    },
    onData: (q) => {
      var H;
      const G = (B, Y) => {
        const ne = JSON.parse(decoder.decode(B));
        q(ne, Y == null ? void 0 : Y.identity);
      };
      return (H = u.livekitRoom) == null || H.on(RoomEvent.DataReceived, G), () => {
        var B;
        (B = u.livekitRoom) == null || B.off(RoomEvent.DataReceived, G);
      };
    },
    connect: () => u.connect(),
    disconnect: () => {
      var q;
      return (q = u.livekitRoom) == null ? void 0 : q.disconnect();
    },
    onDisconnected: (q) => {
      var G;
      return (G = u.livekitRoom) == null || G.on(RoomEvent.Disconnected, q), () => {
        var H;
        (H = u.livekitRoom) == null || H.off(RoomEvent.DataReceived, q);
      };
    },
    setAudioOutput: (q) => {
      var G;
      return (G = u.livekitRoom) == null ? void 0 : G.switchActiveDevice("audiooutput", q);
    }
  };
  return g(), simpleRooms.set(a, V), V;
}, {
  state: state$1
} = CoreContext, getAccessTokenData = () => {
  var a;
  return ((a = CoreContext.clients.accessTokenClaims) == null ? void 0 : a.user) || {};
}, getBaseUser = () => state$1.user ? {
  id: state$1.user.id,
  props: state$1.user.props,
  name: state$1.user.name,
  projects: state$1.projects.map(toBaseProject),
  sources: state$1.sources.map(toBaseSource)
} : null, toBaseProject = (a) => {
  const {
    compositor: u,
    videoApi: c,
    props: l = {},
    role: v
  } = a, {
    destinations: S,
    encoding: g,
    rendering: E,
    sources: _
  } = c.project, k = {
    get: u.get,
    getRoot: u.getRoot,
    getParent: u.getParent
  };
  Object.defineProperty(k, "nodes", {
    get() {
      return u.nodes.filter(($) => !$._deleted);
    }
  });
  const L = a.videoApi.phase, M = a.videoApi.broadcastId || null;
  return {
    broadcastPhase: L,
    role: v,
    broadcastId: M,
    isLive: [ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPING].includes(L),
    scene: k,
    joinRoom: async ($ = {}) => CoreContext.Command.joinRoom({
      projectId: a.id,
      ...$
    }),
    subscribe: ($) => CoreContext.subscribe((J, V) => {
      V.projectId && (V == null ? void 0 : V.projectId) === a.id && $(J, V);
    }),
    destinations: S.map(toBaseDestination),
    sources: _.map(toBaseSource),
    encoding: g,
    rendering: E,
    id: a.id,
    hostDisplayName: a.props.hostDisplayName,
    props: l
  };
}, toBaseDestination = (a) => {
  var u;
  return {
    id: a.destinationId,
    enabled: a.enabled,
    address: a.address,
    // For backward compatibility, fall back to "metadata" as props.
    //  All new projects have a dedicated "props" field
    props: ((u = a.metadata) == null ? void 0 : u.props) || (a == null ? void 0 : a.metadata) || {}
  };
}, toBaseSource = (a) => {
  var u;
  return {
    id: a.sourceId,
    address: a.address,
    props: ((u = a.metadata) == null ? void 0 : u.props) || {}
  };
}, hydrateProject = async (a, u, c) => {
  const l = a.metadata || {}, v = {
    collectionId: a.collectionId,
    projectId: a.projectId,
    updateMask: []
  };
  hasPermission(u, Permission.ManageBroadcast) && a.composition.studioSdk.version !== CoreContext.rendererVersion && (v.composition = {
    studioSdk: {
      version: CoreContext.rendererVersion
    }
  }, v.updateMask.push("composition.studioSdk.version")), c && (v.rendering = {
    video: {
      width: c.x,
      height: c.y,
      framerate: 30
    }
  }, v.updateMask.push("rendering")), v.updateMask.length && await CoreContext.clients.LiveApi().project.updateProject(v);
  const g = await layoutToProject(l.layoutId, c);
  return {
    id: a.projectId,
    compositor: g,
    role: u,
    videoApi: {
      project: a,
      phase: ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_UNSPECIFIED
    },
    layoutApi: {
      layoutId: l.layoutId
    },
    // For backward compatibility, fall back to "metadata" as props.
    //  All new projects have a dedicated "props" field
    props: (l == null ? void 0 : l.props) || l
  };
}, sceneNodeToLayer = (a) => {
  const {
    id: u,
    props: c = {},
    children: l = []
  } = a;
  return {
    ...u ? {
      id: u
    } : {},
    type: c.type,
    data: {
      ...c
    },
    children: l.map((v) => v.id)
  };
}, nodeToLayer = (a) => ({
  id: a.id,
  type: a.props.type,
  data: {
    ...a.props
  },
  children: a.childIds.map((u) => u)
}), layerToNode = (a) => ({
  id: String(a.id),
  props: {
    type: a.type,
    ...a.data
  },
  childIds: a.children.map((u) => String(u))
}), layoutToProject = async (a, u) => {
  const {
    layers: c
  } = await CoreContext.clients.LayoutApi().layer.listLayers({
    layoutId: a
  });
  if (u && c) {
    const {
      x: g,
      y: E
    } = u, _ = c == null ? void 0 : c.reduce((k, L) => k ? k.data.isRoot ? k : L.data.isRoot || !c.some((M) => M.children.includes(L.id)) ? L : k : L, null);
    if (_) {
      const k = await CoreContext.clients.LayoutApi().layer.updateLayer({
        layoutId: _.layoutId,
        layerId: _.id,
        layer: {
          x: g,
          y: E,
          data: {
            ..._.data,
            size: {
              x: g,
              y: E
            }
          }
        }
      }), L = c.findIndex((M) => M.id === k.id);
      c[L] = k;
    }
  }
  const l = c.map(layerToNode), v = l.reduce((g, E) => g ? g.props.isRoot ? g : E.props.isRoot || !l.some((_) => _.childIds.includes(E.id)) ? E : g : E, null), S = v ? toSceneTree(l, v.id) : null;
  return CoreContext.compositor.loadProject(S, a);
}, getUser = () => {
  const a = state$1.user;
  if (!a)
    throw new Error("User not loaded");
  return a;
}, getProject = (a) => state$1.projects.find((u) => u.id === a), getProjectByLayoutId = (a) => state$1.projects.find((u) => u.compositor.id === a), getProjectRoom = (a) => {
  var u;
  return getRoom((u = getProject(a)) == null ? void 0 : u.roomId);
}, {
  connectionId
} = CoreContext, latestUpdateVersion = {}, getNextNodeVersion = (a) => (latestUpdateVersion[a] || (latestUpdateVersion[a] = 0), ++latestUpdateVersion[a]), request = (a, u) => {
  const c = u.map((l) => {
    const [v, S] = l;
    return {
      [v]: S
    };
  });
  return log$1.debug("Batch request", c), CoreContext.clients.LayoutApi().layer.batch({
    layoutId: a,
    layers: c,
    requestMetadata: {
      connectionId,
      layoutId: a,
      updateVersions: u.filter(([l]) => l === "update").map(([l, v]) => ({
        [v.id]: getNextNodeVersion(v.id)
      })).reduce((l, v) => ({
        ...v,
        ...l
      }), {})
    }
  });
}, compositorAdapter = (a, u) => ({
  async insert(c = {}, l, v) {
    const S = nodeToLayer({
      id: null,
      props: c,
      childIds: []
    });
    l ? S.type = "child" : S.type = "root", log$1.debug("Insert layer", S);
    const g = await CoreContext.clients.LayoutApi().layer.createLayer({
      layoutId: a,
      layer: {
        ...S,
        requestMetadata: {
          connectionId,
          layoutId: a
        }
      }
    });
    if (g.code)
      throw new Error(g.message);
    const E = await u.get(l);
    if (l && !E)
      throw Error("Parent not found with ID");
    if (E) {
      const _ = nodeToLayer(E), k = insertAt$1(v, g.id, _.children), L = {
        layoutId: a,
        layerId: _.id,
        layer: {
          children: k,
          requestMetadata: {
            connectionId,
            layoutId: a,
            updateVersion: {
              [S.id]: getNextNodeVersion(S.id)
            }
          }
        }
      };
      await CoreContext.clients.LayoutApi().layer.updateLayer(L);
    }
    return String(g.id);
  },
  async update(c, l = {}) {
    const v = u.get(c), S = nodeToLayer({
      ...v,
      props: {
        ...v.props,
        ...l
      }
    }), g = {
      layoutId: a,
      layerId: S.id,
      layer: {
        ...S,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [S.id]: getNextNodeVersion(S.id)
          }
        }
      }
    };
    log$1.debug("Update layer", g), await CoreContext.clients.LayoutApi().layer.updateLayer(g);
  },
  async remove(c) {
    const l = await u.getParent(c);
    if (l) {
      const v = nodeToLayer(l), S = v.children.filter((E) => E !== c), g = {
        layoutId: a,
        layerId: v.id,
        layer: {
          children: S,
          requestMetadata: {
            connectionId,
            layoutId: a,
            updateVersions: {
              [v.id]: getNextNodeVersion(v.id)
            }
          }
        }
      };
      await CoreContext.clients.LayoutApi().layer.updateLayer(g);
    }
    await CoreContext.clients.LayoutApi().layer.deleteLayer({
      layoutId: a,
      layerId: c,
      payload: {
        requestMetadata: {
          connectionId,
          layoutId: a
        }
      }
    });
  },
  // @ts-ignore
  async reorder(c, l) {
    const v = u.get(c), S = nodeToLayer({
      ...v,
      childIds: l
    });
    log$1.debug("Reorder layer children", S), await CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: S.id,
      layer: {
        children: S.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [S.id]: getNextNodeVersion(S.id)
          }
        }
      }
    });
  },
  // @ts-ignore
  async move(c, l, v) {
    const S = u.get(c), g = u.get(u.getParent(c).id), E = nodeToLayer({
      ...g,
      childIds: pull$1(g.childIds, S.id)
    }), _ = u.get(l), k = nodeToLayer({
      ..._,
      childIds: insertAt$1(v, S.id, _.childIds)
    });
    log$1.debug("Move layers"), await Promise.all([CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: E.id,
      layer: {
        children: E.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [E.id]: getNextNodeVersion(E.id)
          }
        }
      }
    }), CoreContext.clients.LayoutApi().layer.updateLayer({
      layoutId: a,
      layerId: k.id,
      layer: {
        children: k.children,
        requestMetadata: {
          connectionId,
          layoutId: a,
          updateVersions: {
            [k.id]: getNextNodeVersion(k.id)
          }
        }
      }
    })]);
  },
  async batch(c) {
    const l = c.map(([S, g]) => [S, sceneNodeToLayer(g)]), v = await request(a, l);
    return log$1.debug("Batch response", v), v;
  }
}), config$1 = (a) => ({
  defaults: {
    previewTokenDuration: 1e3 * 60 * 60,
    guestTokenDuration: 1e3 * 60 * 60 * 12,
    transforms: {
      RoomParticipant: "LS-Room-Participant",
      Image: "LS-Image",
      Banner: "LS-Banner",
      Text: "LS-Text"
    }
  }
}), RoomParticipant$1 = {
  name: "LS-Room-Participant",
  sourceType: "RoomParticipant",
  props: {
    isMuted: {
      type: Boolean,
      required: !1,
      default: !1
    },
    volume: {
      type: Number,
      required: !1,
      default: 1
    }
  },
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), S = getProject(CoreContext.state.activeProjectId), g = getProjectRoom(CoreContext.state.activeProjectId);
    Object.assign(v.style, {
      position: "relative"
    });
    let E, _ = l;
    const k = ($, J) => {
      const V = $ / J.width;
      return V >= 0.5 ? 3 : V > 0.25 ? 2 : V > 0.15 ? 1 : 0;
    }, L = ({
      props: $,
      source: J
    }) => {
      var re, oe, de;
      const V = useRef(), {
        volume: q = 1,
        isHidden: G = !1
      } = $ || {}, [H, B] = useState(0), ne = (J == null ? void 0 : J.id) === (g == null ? void 0 : g.participantId) || ((re = J == null ? void 0 : J.props) == null ? void 0 : re.participantId) === (g == null ? void 0 : g.participantId) || ($ == null ? void 0 : $.isMuted), Z = !($ != null && $.isHidden) && ((oe = J == null ? void 0 : J.props) == null ? void 0 : oe.videoEnabled);
      return useEffect(() => {
        V.current && (V.current.play().catch((A) => {
          document.addEventListener("click", () => {
            var N;
            return (N = V.current) == null ? void 0 : N.play();
          }, {
            once: !0
          });
        }), J != null && J.value && (J == null ? void 0 : J.value) !== V.current.srcObject ? V.current.srcObject = J == null ? void 0 : J.value : J != null && J.value || (V.current.srcObject = null));
      }, [V.current, J == null ? void 0 : J.value]), useEffect(() => {
        !$ && V.current && (V.current.srcObject = null, V.current = null);
      }, [$]), useLayoutEffect(() => {
        if (!V.current)
          return;
        const A = () => {
          const D = V.current;
          D && B(k(D.clientWidth, {
            width: S.compositor.getRoot().props.size.x,
            height: S.compositor.getRoot().props.size.y
          }));
        }, N = new ResizeObserver((D) => {
          A();
        });
        return A(), N == null || N.observe(V.current), () => {
          V.current && (N == null || N.unobserve(V.current), V.current.srcObject = null);
        };
      }, [V.current, S]), useEffect(() => {
        V.current && (V.current.volume = q);
      }, [V.current, q]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: Z ? "0" : "1"
        }
      }, (J == null ? void 0 : J.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        style: {
          borderRadius: "50%",
          background: "#555",
          width: "70px",
          height: "70px",
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1em"
        }
      }, (J == null ? void 0 : J.props.displayName.slice(0, 1)) || "")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%",
          ...!!((de = J == null ? void 0 : J.props) != null && de.mirrored) && {
            transform: "scaleX(-1)"
          }
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: V,
        autoPlay: !0,
        muted: ne,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: Z ? "1" : "0",
          objectFit: (J == null ? void 0 : J.props.type) === "screen" ? "contain" : "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })), (J == null ? void 0 : J.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        className: "NameBannerContainer",
        style: {
          width: "100%",
          height: "100%",
          position: "absolute"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner",
        "data-size": H,
        style: {
          padding: "12px 30px",
          width: "fit-content",
          height: "fit-content",
          top: "100%",
          transform: "translateY(-100%)",
          left: 0
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner-body"
      }, J.props.displayName))));
    }, M = () => ReactDOM.render(/* @__PURE__ */ React.createElement(L, {
      source: E,
      props: _
    }), v);
    return a(($) => {
      _ = $, M();
    }), u(($) => {
      E = $, M();
    }), c(($) => {
      _ = $, M();
    }), {
      root: v
    };
  }
}, Square = {
  name: "LS-Square",
  props: {
    color: {
      default: "green"
    }
  },
  create({
    onUpdate: a
  }) {
    const u = document.createElement("div");
    return a(({
      color: c
    }) => {
      Object.assign(u.style, {
        width: "100%",
        height: "100%",
        background: c || "red"
      });
    }), {
      root: u
    };
  }
}, Image$1 = {
  name: "LS-Image",
  props: {
    src: {},
    fit: {}
  },
  create({
    onUpdate: a
  }) {
    const u = document.createElement("img");
    return a(({
      src: c,
      fit: l
    }) => {
      u.setAttribute("src", c), Object.assign(u.style, {
        width: "100%",
        height: "100%",
        objectFit: l
      });
    }), {
      root: u
    };
  }
}, Element$1 = {
  name: "Element",
  sourceType: "Element",
  create({
    onUpdate: a
  }, {
    tagName: u
  }) {
    const c = document.createElement(u);
    return a(({
      tagName: l,
      attributes: v = {},
      fields: S = {}
    }) => {
      l === "img" ? (c == null ? void 0 : c.src) !== v.src && Object.keys(v).forEach((g) => {
        c.setAttribute(g, v[g]);
      }) : Object.keys(v).forEach((g) => {
        c.setAttribute(g, v[g]);
      }), Object.keys(S).forEach((g) => {
        Object.assign(c[g], S[g]);
      });
    }), {
      root: c
    };
  }
}, Video = {
  name: "LS-Video",
  sourceType: "LS-Video",
  create({
    onUpdate: a,
    onEvent: u,
    onRemove: c
  }) {
    c(() => {
      clearInterval(v);
    });
    const l = document.createElement("video");
    let v;
    return a(({
      attributes: S = {},
      fields: g = {},
      sourceProps: E = {},
      id: _
    }) => {
      (l.src !== S.src || l.id !== S.id && S.id) && (v && clearInterval(v), Object.keys(S).forEach((k) => {
        l.setAttribute(k, S[k]);
      }), l.onloadedmetadata = () => {
        S.muted ? (l.muted = !0, l.play()) : l.muted = !1;
      }, v = setInterval(() => {
        if (l.duration) {
          const k = l.duration - l.currentTime;
          trigger$1("VideoTimeUpdate", {
            category: _,
            id: E == null ? void 0 : E.id,
            time: Math.floor(k)
          });
        }
      }, 1e3), l.loop = !!S.loop, l.onended = () => {
        v && clearInterval(v), trigger$1("VideoEnded", {
          id: E == null ? void 0 : E.id,
          category: _
        });
      }, Object.keys(g).forEach((k) => {
        Object.assign(l[k], g[k]);
      }));
    }), {
      root: l
    };
  }
}, Banner$1 = {
  name: "LS-Banner",
  sourceType: "Banner",
  props: {
    bannerId: {
      type: String,
      required: !0
    }
  },
  useSource(a, u) {
    return a.find((c) => c.id === u.bannerId);
  },
  create({
    onUpdate: a,
    onNewSource: u
  }, c) {
    const l = document.createElement("div");
    let v, S, g;
    const E = ({
      currentSource: k,
      latestSource: L
    }) => {
      const [M, $] = useState(!1), {
        headerText: J,
        bodyText: V
      } = (L == null ? void 0 : L.value) || {};
      return useEffect(() => {
        window.setTimeout(() => {
          $(!!k);
        }), k || $(!1);
      }, [k]), /* @__PURE__ */ React.createElement("div", {
        className: "BannerContainer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "flex-start",
          alignItems: "flex-end",
          transition: "200ms ease all",
          ...M ? {
            zIndex: 2,
            opacity: 1,
            transform: "translateX(0)"
          } : {
            zIndex: 1,
            opacity: 0,
            transform: "translateX(-200px)"
          }
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "Banner",
        style: {
          padding: 10,
          background: "orange",
          width: "fit-content",
          height: "fit-content",
          maxWidth: "84%",
          position: "relative"
        }
      }, J && /* @__PURE__ */ React.createElement("div", {
        className: "Banner-header",
        style: {
          marginBottom: 6
        }
      }, J), V && /* @__PURE__ */ React.createElement("div", {
        className: "Banner-body"
      }, V)));
    }, _ = () => ReactDOM.render(/* @__PURE__ */ React.createElement(React.Fragment, null, g && g.id !== S.id && /* @__PURE__ */ React.createElement(E, {
      key: g == null ? void 0 : g.id,
      currentSource: null,
      latestSource: g
    }), /* @__PURE__ */ React.createElement(E, {
      key: S == null ? void 0 : S.id,
      currentSource: v,
      latestSource: S
    })), l);
    return a(() => {
      _();
    }), u((k) => {
      g = v, v = k, v && (S = v), _();
    }), {
      root: l
    };
  }
};
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(a) {
    for (var u = 1; u < arguments.length; u++) {
      var c = arguments[u];
      for (var l in c)
        Object.prototype.hasOwnProperty.call(c, l) && (a[l] = c[l]);
    }
    return a;
  }, _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(a, u) {
  if (a == null)
    return {};
  var c = {}, l = Object.keys(a), v, S;
  for (S = 0; S < l.length; S++)
    v = l[S], !(u.indexOf(v) >= 0) && (c[v] = a[v]);
  return c;
}
function _setPrototypeOf(a, u) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(l, v) {
    return l.__proto__ = v, l;
  }, _setPrototypeOf(a, u);
}
function _inheritsLoose(a, u) {
  a.prototype = Object.create(u.prototype), a.prototype.constructor = a, _setPrototypeOf(a, u);
}
var propTypes = { exports: {} }, reactIs = { exports: {} }, reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min)
    return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var a = typeof Symbol == "function" && Symbol.for, u = a ? Symbol.for("react.element") : 60103, c = a ? Symbol.for("react.portal") : 60106, l = a ? Symbol.for("react.fragment") : 60107, v = a ? Symbol.for("react.strict_mode") : 60108, S = a ? Symbol.for("react.profiler") : 60114, g = a ? Symbol.for("react.provider") : 60109, E = a ? Symbol.for("react.context") : 60110, _ = a ? Symbol.for("react.async_mode") : 60111, k = a ? Symbol.for("react.concurrent_mode") : 60111, L = a ? Symbol.for("react.forward_ref") : 60112, M = a ? Symbol.for("react.suspense") : 60113, $ = a ? Symbol.for("react.suspense_list") : 60120, J = a ? Symbol.for("react.memo") : 60115, V = a ? Symbol.for("react.lazy") : 60116, q = a ? Symbol.for("react.block") : 60121, G = a ? Symbol.for("react.fundamental") : 60117, H = a ? Symbol.for("react.responder") : 60118, B = a ? Symbol.for("react.scope") : 60119;
  function Y(Z) {
    if (typeof Z == "object" && Z !== null) {
      var re = Z.$$typeof;
      switch (re) {
        case u:
          switch (Z = Z.type, Z) {
            case _:
            case k:
            case l:
            case S:
            case v:
            case M:
              return Z;
            default:
              switch (Z = Z && Z.$$typeof, Z) {
                case E:
                case L:
                case V:
                case J:
                case g:
                  return Z;
                default:
                  return re;
              }
          }
        case c:
          return re;
      }
    }
  }
  function ne(Z) {
    return Y(Z) === k;
  }
  return reactIs_production_min.AsyncMode = _, reactIs_production_min.ConcurrentMode = k, reactIs_production_min.ContextConsumer = E, reactIs_production_min.ContextProvider = g, reactIs_production_min.Element = u, reactIs_production_min.ForwardRef = L, reactIs_production_min.Fragment = l, reactIs_production_min.Lazy = V, reactIs_production_min.Memo = J, reactIs_production_min.Portal = c, reactIs_production_min.Profiler = S, reactIs_production_min.StrictMode = v, reactIs_production_min.Suspense = M, reactIs_production_min.isAsyncMode = function(Z) {
    return ne(Z) || Y(Z) === _;
  }, reactIs_production_min.isConcurrentMode = ne, reactIs_production_min.isContextConsumer = function(Z) {
    return Y(Z) === E;
  }, reactIs_production_min.isContextProvider = function(Z) {
    return Y(Z) === g;
  }, reactIs_production_min.isElement = function(Z) {
    return typeof Z == "object" && Z !== null && Z.$$typeof === u;
  }, reactIs_production_min.isForwardRef = function(Z) {
    return Y(Z) === L;
  }, reactIs_production_min.isFragment = function(Z) {
    return Y(Z) === l;
  }, reactIs_production_min.isLazy = function(Z) {
    return Y(Z) === V;
  }, reactIs_production_min.isMemo = function(Z) {
    return Y(Z) === J;
  }, reactIs_production_min.isPortal = function(Z) {
    return Y(Z) === c;
  }, reactIs_production_min.isProfiler = function(Z) {
    return Y(Z) === S;
  }, reactIs_production_min.isStrictMode = function(Z) {
    return Y(Z) === v;
  }, reactIs_production_min.isSuspense = function(Z) {
    return Y(Z) === M;
  }, reactIs_production_min.isValidElementType = function(Z) {
    return typeof Z == "string" || typeof Z == "function" || Z === l || Z === k || Z === S || Z === v || Z === M || Z === $ || typeof Z == "object" && Z !== null && (Z.$$typeof === V || Z.$$typeof === J || Z.$$typeof === g || Z.$$typeof === E || Z.$$typeof === L || Z.$$typeof === G || Z.$$typeof === H || Z.$$typeof === B || Z.$$typeof === q);
  }, reactIs_production_min.typeOf = Y, reactIs_production_min;
}
var reactIs_development = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process.env.NODE_ENV !== "production" && function() {
    var a = typeof Symbol == "function" && Symbol.for, u = a ? Symbol.for("react.element") : 60103, c = a ? Symbol.for("react.portal") : 60106, l = a ? Symbol.for("react.fragment") : 60107, v = a ? Symbol.for("react.strict_mode") : 60108, S = a ? Symbol.for("react.profiler") : 60114, g = a ? Symbol.for("react.provider") : 60109, E = a ? Symbol.for("react.context") : 60110, _ = a ? Symbol.for("react.async_mode") : 60111, k = a ? Symbol.for("react.concurrent_mode") : 60111, L = a ? Symbol.for("react.forward_ref") : 60112, M = a ? Symbol.for("react.suspense") : 60113, $ = a ? Symbol.for("react.suspense_list") : 60120, J = a ? Symbol.for("react.memo") : 60115, V = a ? Symbol.for("react.lazy") : 60116, q = a ? Symbol.for("react.block") : 60121, G = a ? Symbol.for("react.fundamental") : 60117, H = a ? Symbol.for("react.responder") : 60118, B = a ? Symbol.for("react.scope") : 60119;
    function Y(C) {
      return typeof C == "string" || typeof C == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      C === l || C === k || C === S || C === v || C === M || C === $ || typeof C == "object" && C !== null && (C.$$typeof === V || C.$$typeof === J || C.$$typeof === g || C.$$typeof === E || C.$$typeof === L || C.$$typeof === G || C.$$typeof === H || C.$$typeof === B || C.$$typeof === q);
    }
    function ne(C) {
      if (typeof C == "object" && C !== null) {
        var x = C.$$typeof;
        switch (x) {
          case u:
            var Q = C.type;
            switch (Q) {
              case _:
              case k:
              case l:
              case S:
              case v:
              case M:
                return Q;
              default:
                var Se = Q && Q.$$typeof;
                switch (Se) {
                  case E:
                  case L:
                  case V:
                  case J:
                  case g:
                    return Se;
                  default:
                    return x;
                }
            }
          case c:
            return x;
        }
      }
    }
    var Z = _, re = k, oe = E, de = g, A = u, N = L, D = l, W = V, ee = J, ae = c, ye = S, he = v, le = M, we = !1;
    function Be(C) {
      return we || (we = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), Ne(C) || ne(C) === _;
    }
    function Ne(C) {
      return ne(C) === k;
    }
    function Le(C) {
      return ne(C) === E;
    }
    function $e(C) {
      return ne(C) === g;
    }
    function Ue(C) {
      return typeof C == "object" && C !== null && C.$$typeof === u;
    }
    function Ge(C) {
      return ne(C) === L;
    }
    function He(C) {
      return ne(C) === l;
    }
    function Ve(C) {
      return ne(C) === V;
    }
    function be(C) {
      return ne(C) === J;
    }
    function Ae(C) {
      return ne(C) === c;
    }
    function qe(C) {
      return ne(C) === S;
    }
    function xe(C) {
      return ne(C) === v;
    }
    function Pe(C) {
      return ne(C) === M;
    }
    reactIs_development.AsyncMode = Z, reactIs_development.ConcurrentMode = re, reactIs_development.ContextConsumer = oe, reactIs_development.ContextProvider = de, reactIs_development.Element = A, reactIs_development.ForwardRef = N, reactIs_development.Fragment = D, reactIs_development.Lazy = W, reactIs_development.Memo = ee, reactIs_development.Portal = ae, reactIs_development.Profiler = ye, reactIs_development.StrictMode = he, reactIs_development.Suspense = le, reactIs_development.isAsyncMode = Be, reactIs_development.isConcurrentMode = Ne, reactIs_development.isContextConsumer = Le, reactIs_development.isContextProvider = $e, reactIs_development.isElement = Ue, reactIs_development.isForwardRef = Ge, reactIs_development.isFragment = He, reactIs_development.isLazy = Ve, reactIs_development.isMemo = be, reactIs_development.isPortal = Ae, reactIs_development.isProfiler = qe, reactIs_development.isStrictMode = xe, reactIs_development.isSuspense = Pe, reactIs_development.isValidElementType = Y, reactIs_development.typeOf = ne;
  }()), reactIs_development;
}
var hasRequiredReactIs;
function requireReactIs() {
  return hasRequiredReactIs || (hasRequiredReactIs = 1, process.env.NODE_ENV === "production" ? reactIs.exports = requireReactIs_production_min() : reactIs.exports = requireReactIs_development()), reactIs.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var objectAssign, hasRequiredObjectAssign;
function requireObjectAssign() {
  if (hasRequiredObjectAssign)
    return objectAssign;
  hasRequiredObjectAssign = 1;
  var a = Object.getOwnPropertySymbols, u = Object.prototype.hasOwnProperty, c = Object.prototype.propertyIsEnumerable;
  function l(S) {
    if (S == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(S);
  }
  function v() {
    try {
      if (!Object.assign)
        return !1;
      var S = new String("abc");
      if (S[5] = "de", Object.getOwnPropertyNames(S)[0] === "5")
        return !1;
      for (var g = {}, E = 0; E < 10; E++)
        g["_" + String.fromCharCode(E)] = E;
      var _ = Object.getOwnPropertyNames(g).map(function(L) {
        return g[L];
      });
      if (_.join("") !== "0123456789")
        return !1;
      var k = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(L) {
        k[L] = L;
      }), Object.keys(Object.assign({}, k)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return objectAssign = v() ? Object.assign : function(S, g) {
    for (var E, _ = l(S), k, L = 1; L < arguments.length; L++) {
      E = Object(arguments[L]);
      for (var M in E)
        u.call(E, M) && (_[M] = E[M]);
      if (a) {
        k = a(E);
        for (var $ = 0; $ < k.length; $++)
          c.call(E, k[$]) && (_[k[$]] = E[k[$]]);
      }
    }
    return _;
  }, objectAssign;
}
var ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret;
function requireReactPropTypesSecret() {
  if (hasRequiredReactPropTypesSecret)
    return ReactPropTypesSecret_1;
  hasRequiredReactPropTypesSecret = 1;
  var a = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ReactPropTypesSecret_1 = a, ReactPropTypesSecret_1;
}
var has, hasRequiredHas;
function requireHas() {
  return hasRequiredHas || (hasRequiredHas = 1, has = Function.call.bind(Object.prototype.hasOwnProperty)), has;
}
var checkPropTypes_1, hasRequiredCheckPropTypes;
function requireCheckPropTypes() {
  if (hasRequiredCheckPropTypes)
    return checkPropTypes_1;
  hasRequiredCheckPropTypes = 1;
  var a = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var u = requireReactPropTypesSecret(), c = {}, l = requireHas();
    a = function(S) {
      var g = "Warning: " + S;
      typeof console < "u" && console.error(g);
      try {
        throw new Error(g);
      } catch {
      }
    };
  }
  function v(S, g, E, _, k) {
    if (process.env.NODE_ENV !== "production") {
      for (var L in S)
        if (l(S, L)) {
          var M;
          try {
            if (typeof S[L] != "function") {
              var $ = Error(
                (_ || "React class") + ": " + E + " type `" + L + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof S[L] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw $.name = "Invariant Violation", $;
            }
            M = S[L](g, L, _, E, null, u);
          } catch (V) {
            M = V;
          }
          if (M && !(M instanceof Error) && a(
            (_ || "React class") + ": type specification of " + E + " `" + L + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof M + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), M instanceof Error && !(M.message in c)) {
            c[M.message] = !0;
            var J = k ? k() : "";
            a(
              "Failed " + E + " type: " + M.message + (J ?? "")
            );
          }
        }
    }
  }
  return v.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (c = {});
  }, checkPropTypes_1 = v, checkPropTypes_1;
}
var factoryWithTypeCheckers, hasRequiredFactoryWithTypeCheckers;
function requireFactoryWithTypeCheckers() {
  if (hasRequiredFactoryWithTypeCheckers)
    return factoryWithTypeCheckers;
  hasRequiredFactoryWithTypeCheckers = 1;
  var a = requireReactIs(), u = requireObjectAssign(), c = requireReactPropTypesSecret(), l = requireHas(), v = requireCheckPropTypes(), S = function() {
  };
  process.env.NODE_ENV !== "production" && (S = function(E) {
    var _ = "Warning: " + E;
    typeof console < "u" && console.error(_);
    try {
      throw new Error(_);
    } catch {
    }
  });
  function g() {
    return null;
  }
  return factoryWithTypeCheckers = function(E, _) {
    var k = typeof Symbol == "function" && Symbol.iterator, L = "@@iterator";
    function M(Ne) {
      var Le = Ne && (k && Ne[k] || Ne[L]);
      if (typeof Le == "function")
        return Le;
    }
    var $ = "<<anonymous>>", J = {
      array: H("array"),
      bigint: H("bigint"),
      bool: H("boolean"),
      func: H("function"),
      number: H("number"),
      object: H("object"),
      string: H("string"),
      symbol: H("symbol"),
      any: B(),
      arrayOf: Y,
      element: ne(),
      elementType: Z(),
      instanceOf: re,
      node: N(),
      objectOf: de,
      oneOf: oe,
      oneOfType: A,
      shape: W,
      exact: ee
    };
    function V(Ne, Le) {
      return Ne === Le ? Ne !== 0 || 1 / Ne === 1 / Le : Ne !== Ne && Le !== Le;
    }
    function q(Ne, Le) {
      this.message = Ne, this.data = Le && typeof Le == "object" ? Le : {}, this.stack = "";
    }
    q.prototype = Error.prototype;
    function G(Ne) {
      if (process.env.NODE_ENV !== "production")
        var Le = {}, $e = 0;
      function Ue(He, Ve, be, Ae, qe, xe, Pe) {
        if (Ae = Ae || $, xe = xe || be, Pe !== c) {
          if (_) {
            var C = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw C.name = "Invariant Violation", C;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var x = Ae + ":" + be;
            !Le[x] && // Avoid spamming the console because they are often not actionable except for lib authors
            $e < 3 && (S(
              "You are manually calling a React.PropTypes validation function for the `" + xe + "` prop on `" + Ae + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), Le[x] = !0, $e++);
          }
        }
        return Ve[be] == null ? He ? Ve[be] === null ? new q("The " + qe + " `" + xe + "` is marked as required " + ("in `" + Ae + "`, but its value is `null`.")) : new q("The " + qe + " `" + xe + "` is marked as required in " + ("`" + Ae + "`, but its value is `undefined`.")) : null : Ne(Ve, be, Ae, qe, xe);
      }
      var Ge = Ue.bind(null, !1);
      return Ge.isRequired = Ue.bind(null, !0), Ge;
    }
    function H(Ne) {
      function Le($e, Ue, Ge, He, Ve, be) {
        var Ae = $e[Ue], qe = he(Ae);
        if (qe !== Ne) {
          var xe = le(Ae);
          return new q(
            "Invalid " + He + " `" + Ve + "` of type " + ("`" + xe + "` supplied to `" + Ge + "`, expected ") + ("`" + Ne + "`."),
            { expectedType: Ne }
          );
        }
        return null;
      }
      return G(Le);
    }
    function B() {
      return G(g);
    }
    function Y(Ne) {
      function Le($e, Ue, Ge, He, Ve) {
        if (typeof Ne != "function")
          return new q("Property `" + Ve + "` of component `" + Ge + "` has invalid PropType notation inside arrayOf.");
        var be = $e[Ue];
        if (!Array.isArray(be)) {
          var Ae = he(be);
          return new q("Invalid " + He + " `" + Ve + "` of type " + ("`" + Ae + "` supplied to `" + Ge + "`, expected an array."));
        }
        for (var qe = 0; qe < be.length; qe++) {
          var xe = Ne(be, qe, Ge, He, Ve + "[" + qe + "]", c);
          if (xe instanceof Error)
            return xe;
        }
        return null;
      }
      return G(Le);
    }
    function ne() {
      function Ne(Le, $e, Ue, Ge, He) {
        var Ve = Le[$e];
        if (!E(Ve)) {
          var be = he(Ve);
          return new q("Invalid " + Ge + " `" + He + "` of type " + ("`" + be + "` supplied to `" + Ue + "`, expected a single ReactElement."));
        }
        return null;
      }
      return G(Ne);
    }
    function Z() {
      function Ne(Le, $e, Ue, Ge, He) {
        var Ve = Le[$e];
        if (!a.isValidElementType(Ve)) {
          var be = he(Ve);
          return new q("Invalid " + Ge + " `" + He + "` of type " + ("`" + be + "` supplied to `" + Ue + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return G(Ne);
    }
    function re(Ne) {
      function Le($e, Ue, Ge, He, Ve) {
        if (!($e[Ue] instanceof Ne)) {
          var be = Ne.name || $, Ae = Be($e[Ue]);
          return new q("Invalid " + He + " `" + Ve + "` of type " + ("`" + Ae + "` supplied to `" + Ge + "`, expected ") + ("instance of `" + be + "`."));
        }
        return null;
      }
      return G(Le);
    }
    function oe(Ne) {
      if (!Array.isArray(Ne))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? S(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : S("Invalid argument supplied to oneOf, expected an array.")), g;
      function Le($e, Ue, Ge, He, Ve) {
        for (var be = $e[Ue], Ae = 0; Ae < Ne.length; Ae++)
          if (V(be, Ne[Ae]))
            return null;
        var qe = JSON.stringify(Ne, function(Pe, C) {
          var x = le(C);
          return x === "symbol" ? String(C) : C;
        });
        return new q("Invalid " + He + " `" + Ve + "` of value `" + String(be) + "` " + ("supplied to `" + Ge + "`, expected one of " + qe + "."));
      }
      return G(Le);
    }
    function de(Ne) {
      function Le($e, Ue, Ge, He, Ve) {
        if (typeof Ne != "function")
          return new q("Property `" + Ve + "` of component `" + Ge + "` has invalid PropType notation inside objectOf.");
        var be = $e[Ue], Ae = he(be);
        if (Ae !== "object")
          return new q("Invalid " + He + " `" + Ve + "` of type " + ("`" + Ae + "` supplied to `" + Ge + "`, expected an object."));
        for (var qe in be)
          if (l(be, qe)) {
            var xe = Ne(be, qe, Ge, He, Ve + "." + qe, c);
            if (xe instanceof Error)
              return xe;
          }
        return null;
      }
      return G(Le);
    }
    function A(Ne) {
      if (!Array.isArray(Ne))
        return process.env.NODE_ENV !== "production" && S("Invalid argument supplied to oneOfType, expected an instance of array."), g;
      for (var Le = 0; Le < Ne.length; Le++) {
        var $e = Ne[Le];
        if (typeof $e != "function")
          return S(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + we($e) + " at index " + Le + "."
          ), g;
      }
      function Ue(Ge, He, Ve, be, Ae) {
        for (var qe = [], xe = 0; xe < Ne.length; xe++) {
          var Pe = Ne[xe], C = Pe(Ge, He, Ve, be, Ae, c);
          if (C == null)
            return null;
          C.data && l(C.data, "expectedType") && qe.push(C.data.expectedType);
        }
        var x = qe.length > 0 ? ", expected one of type [" + qe.join(", ") + "]" : "";
        return new q("Invalid " + be + " `" + Ae + "` supplied to " + ("`" + Ve + "`" + x + "."));
      }
      return G(Ue);
    }
    function N() {
      function Ne(Le, $e, Ue, Ge, He) {
        return ae(Le[$e]) ? null : new q("Invalid " + Ge + " `" + He + "` supplied to " + ("`" + Ue + "`, expected a ReactNode."));
      }
      return G(Ne);
    }
    function D(Ne, Le, $e, Ue, Ge) {
      return new q(
        (Ne || "React class") + ": " + Le + " type `" + $e + "." + Ue + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Ge + "`."
      );
    }
    function W(Ne) {
      function Le($e, Ue, Ge, He, Ve) {
        var be = $e[Ue], Ae = he(be);
        if (Ae !== "object")
          return new q("Invalid " + He + " `" + Ve + "` of type `" + Ae + "` " + ("supplied to `" + Ge + "`, expected `object`."));
        for (var qe in Ne) {
          var xe = Ne[qe];
          if (typeof xe != "function")
            return D(Ge, He, Ve, qe, le(xe));
          var Pe = xe(be, qe, Ge, He, Ve + "." + qe, c);
          if (Pe)
            return Pe;
        }
        return null;
      }
      return G(Le);
    }
    function ee(Ne) {
      function Le($e, Ue, Ge, He, Ve) {
        var be = $e[Ue], Ae = he(be);
        if (Ae !== "object")
          return new q("Invalid " + He + " `" + Ve + "` of type `" + Ae + "` " + ("supplied to `" + Ge + "`, expected `object`."));
        var qe = u({}, $e[Ue], Ne);
        for (var xe in qe) {
          var Pe = Ne[xe];
          if (l(Ne, xe) && typeof Pe != "function")
            return D(Ge, He, Ve, xe, le(Pe));
          if (!Pe)
            return new q(
              "Invalid " + He + " `" + Ve + "` key `" + xe + "` supplied to `" + Ge + "`.\nBad object: " + JSON.stringify($e[Ue], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(Ne), null, "  ")
            );
          var C = Pe(be, xe, Ge, He, Ve + "." + xe, c);
          if (C)
            return C;
        }
        return null;
      }
      return G(Le);
    }
    function ae(Ne) {
      switch (typeof Ne) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !Ne;
        case "object":
          if (Array.isArray(Ne))
            return Ne.every(ae);
          if (Ne === null || E(Ne))
            return !0;
          var Le = M(Ne);
          if (Le) {
            var $e = Le.call(Ne), Ue;
            if (Le !== Ne.entries) {
              for (; !(Ue = $e.next()).done; )
                if (!ae(Ue.value))
                  return !1;
            } else
              for (; !(Ue = $e.next()).done; ) {
                var Ge = Ue.value;
                if (Ge && !ae(Ge[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function ye(Ne, Le) {
      return Ne === "symbol" ? !0 : Le ? Le["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && Le instanceof Symbol : !1;
    }
    function he(Ne) {
      var Le = typeof Ne;
      return Array.isArray(Ne) ? "array" : Ne instanceof RegExp ? "object" : ye(Le, Ne) ? "symbol" : Le;
    }
    function le(Ne) {
      if (typeof Ne > "u" || Ne === null)
        return "" + Ne;
      var Le = he(Ne);
      if (Le === "object") {
        if (Ne instanceof Date)
          return "date";
        if (Ne instanceof RegExp)
          return "regexp";
      }
      return Le;
    }
    function we(Ne) {
      var Le = le(Ne);
      switch (Le) {
        case "array":
        case "object":
          return "an " + Le;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + Le;
        default:
          return Le;
      }
    }
    function Be(Ne) {
      return !Ne.constructor || !Ne.constructor.name ? $ : Ne.constructor.name;
    }
    return J.checkPropTypes = v, J.resetWarningCache = v.resetWarningCache, J.PropTypes = J, J;
  }, factoryWithTypeCheckers;
}
var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims;
function requireFactoryWithThrowingShims() {
  if (hasRequiredFactoryWithThrowingShims)
    return factoryWithThrowingShims;
  hasRequiredFactoryWithThrowingShims = 1;
  var a = requireReactPropTypesSecret();
  function u() {
  }
  function c() {
  }
  return c.resetWarningCache = u, factoryWithThrowingShims = function() {
    function l(g, E, _, k, L, M) {
      if (M !== a) {
        var $ = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw $.name = "Invariant Violation", $;
      }
    }
    l.isRequired = l;
    function v() {
      return l;
    }
    var S = {
      array: l,
      bigint: l,
      bool: l,
      func: l,
      number: l,
      object: l,
      string: l,
      symbol: l,
      any: l,
      arrayOf: v,
      element: l,
      elementType: l,
      instanceOf: v,
      node: l,
      objectOf: v,
      oneOf: v,
      oneOfType: v,
      shape: v,
      exact: v,
      checkPropTypes: c,
      resetWarningCache: u
    };
    return S.PropTypes = S, S;
  }, factoryWithThrowingShims;
}
if (process.env.NODE_ENV !== "production") {
  var ReactIs = requireReactIs(), throwOnDirectAccess = !0;
  propTypes.exports = requireFactoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
} else
  propTypes.exports = requireFactoryWithThrowingShims()();
var propTypesExports = propTypes.exports;
const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs$1(propTypesExports);
function hasClass(a, u) {
  return a.classList ? !!u && a.classList.contains(u) : (" " + (a.className.baseVal || a.className) + " ").indexOf(" " + u + " ") !== -1;
}
function addClass(a, u) {
  a.classList ? a.classList.add(u) : hasClass(a, u) || (typeof a.className == "string" ? a.className = a.className + " " + u : a.setAttribute("class", (a.className && a.className.baseVal || "") + " " + u));
}
function replaceClassName(a, u) {
  return a.replace(new RegExp("(^|\\s)" + u + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass$1(a, u) {
  a.classList ? a.classList.remove(u) : typeof a.className == "string" ? a.className = replaceClassName(a.className, u) : a.setAttribute("class", replaceClassName(a.className && a.className.baseVal || "", u));
}
const config = {
  disabled: !1
};
var timeoutsShape = process.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.number, PropTypes.shape({
  enter: PropTypes.number,
  exit: PropTypes.number,
  appear: PropTypes.number
}).isRequired]) : null, classNamesShape = process.env.NODE_ENV !== "production" ? PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
  enter: PropTypes.string,
  exit: PropTypes.string,
  active: PropTypes.string
}), PropTypes.shape({
  enter: PropTypes.string,
  enterDone: PropTypes.string,
  enterActive: PropTypes.string,
  exit: PropTypes.string,
  exitDone: PropTypes.string,
  exitActive: PropTypes.string
})]) : null;
const TransitionGroupContext = React.createContext(null);
var forceReflow = function a(u) {
  return u.scrollTop;
}, UNMOUNTED = "unmounted", EXITED = "exited", ENTERING = "entering", ENTERED = "entered", EXITING = "exiting", Transition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u(l, v) {
    var S;
    S = a.call(this, l, v) || this;
    var g = v, E = g && !g.isMounting ? l.enter : l.appear, _;
    return S.appearStatus = null, l.in ? E ? (_ = EXITED, S.appearStatus = ENTERING) : _ = ENTERED : l.unmountOnExit || l.mountOnEnter ? _ = UNMOUNTED : _ = EXITED, S.state = {
      status: _
    }, S.nextCallback = null, S;
  }
  u.getDerivedStateFromProps = function(v, S) {
    var g = v.in;
    return g && S.status === UNMOUNTED ? {
      status: EXITED
    } : null;
  };
  var c = u.prototype;
  return c.componentDidMount = function() {
    this.updateStatus(!0, this.appearStatus);
  }, c.componentDidUpdate = function(v) {
    var S = null;
    if (v !== this.props) {
      var g = this.state.status;
      this.props.in ? g !== ENTERING && g !== ENTERED && (S = ENTERING) : (g === ENTERING || g === ENTERED) && (S = EXITING);
    }
    this.updateStatus(!1, S);
  }, c.componentWillUnmount = function() {
    this.cancelNextCallback();
  }, c.getTimeouts = function() {
    var v = this.props.timeout, S, g, E;
    return S = g = E = v, v != null && typeof v != "number" && (S = v.exit, g = v.enter, E = v.appear !== void 0 ? v.appear : g), {
      exit: S,
      enter: g,
      appear: E
    };
  }, c.updateStatus = function(v, S) {
    if (v === void 0 && (v = !1), S !== null)
      if (this.cancelNextCallback(), S === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var g = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          g && forceReflow(g);
        }
        this.performEnter(v);
      } else
        this.performExit();
    else
      this.props.unmountOnExit && this.state.status === EXITED && this.setState({
        status: UNMOUNTED
      });
  }, c.performEnter = function(v) {
    var S = this, g = this.props.enter, E = this.context ? this.context.isMounting : v, _ = this.props.nodeRef ? [E] : [ReactDOM.findDOMNode(this), E], k = _[0], L = _[1], M = this.getTimeouts(), $ = E ? M.appear : M.enter;
    if (!v && !g || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        S.props.onEntered(k);
      });
      return;
    }
    this.props.onEnter(k, L), this.safeSetState({
      status: ENTERING
    }, function() {
      S.props.onEntering(k, L), S.onTransitionEnd($, function() {
        S.safeSetState({
          status: ENTERED
        }, function() {
          S.props.onEntered(k, L);
        });
      });
    });
  }, c.performExit = function() {
    var v = this, S = this.props.exit, g = this.getTimeouts(), E = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!S || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        v.props.onExited(E);
      });
      return;
    }
    this.props.onExit(E), this.safeSetState({
      status: EXITING
    }, function() {
      v.props.onExiting(E), v.onTransitionEnd(g.exit, function() {
        v.safeSetState({
          status: EXITED
        }, function() {
          v.props.onExited(E);
        });
      });
    });
  }, c.cancelNextCallback = function() {
    this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
  }, c.safeSetState = function(v, S) {
    S = this.setNextCallback(S), this.setState(v, S);
  }, c.setNextCallback = function(v) {
    var S = this, g = !0;
    return this.nextCallback = function(E) {
      g && (g = !1, S.nextCallback = null, v(E));
    }, this.nextCallback.cancel = function() {
      g = !1;
    }, this.nextCallback;
  }, c.onTransitionEnd = function(v, S) {
    this.setNextCallback(S);
    var g = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this), E = v == null && !this.props.addEndListener;
    if (!g || E) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ = this.props.nodeRef ? [this.nextCallback] : [g, this.nextCallback], k = _[0], L = _[1];
      this.props.addEndListener(k, L);
    }
    v != null && setTimeout(this.nextCallback, v);
  }, c.render = function() {
    var v = this.state.status;
    if (v === UNMOUNTED)
      return null;
    var S = this.props, g = S.children;
    S.in, S.mountOnEnter, S.unmountOnExit, S.appear, S.enter, S.exit, S.timeout, S.addEndListener, S.onEnter, S.onEntering, S.onEntered, S.onExit, S.onExiting, S.onExited, S.nodeRef;
    var E = _objectWithoutPropertiesLoose(S, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof g == "function" ? g(v, E) : React.cloneElement(React.Children.only(g), E))
    );
  }, u;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: PropTypes.shape({
    current: typeof Element > "u" ? PropTypes.any : function(a, u, c, l, v, S) {
      var g = a[u];
      return PropTypes.instanceOf(g && "ownerDocument" in g ? g.ownerDocument.defaultView.Element : Element)(a, u, c, l, v, S);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: PropTypes.oneOfType([PropTypes.func.isRequired, PropTypes.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: PropTypes.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: PropTypes.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: PropTypes.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: PropTypes.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: PropTypes.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: PropTypes.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function a(u) {
    var c = timeoutsShape;
    u.addEndListener || (c = c.isRequired);
    for (var l = arguments.length, v = new Array(l > 1 ? l - 1 : 0), S = 1; S < l; S++)
      v[S - 1] = arguments[S];
    return c.apply(void 0, [u].concat(v));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: PropTypes.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: PropTypes.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: PropTypes.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: PropTypes.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: PropTypes.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: PropTypes.func
} : {};
function noop() {
}
Transition.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
var _addClass = function a(u, c) {
  return u && c && c.split(" ").forEach(function(l) {
    return addClass(u, l);
  });
}, removeClass = function a(u, c) {
  return u && c && c.split(" ").forEach(function(l) {
    return removeClass$1(u, l);
  });
}, CSSTransition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u() {
    for (var l, v = arguments.length, S = new Array(v), g = 0; g < v; g++)
      S[g] = arguments[g];
    return l = a.call.apply(a, [this].concat(S)) || this, l.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    }, l.onEnter = function(E, _) {
      var k = l.resolveArguments(E, _), L = k[0], M = k[1];
      l.removeClasses(L, "exit"), l.addClass(L, M ? "appear" : "enter", "base"), l.props.onEnter && l.props.onEnter(E, _);
    }, l.onEntering = function(E, _) {
      var k = l.resolveArguments(E, _), L = k[0], M = k[1], $ = M ? "appear" : "enter";
      l.addClass(L, $, "active"), l.props.onEntering && l.props.onEntering(E, _);
    }, l.onEntered = function(E, _) {
      var k = l.resolveArguments(E, _), L = k[0], M = k[1], $ = M ? "appear" : "enter";
      l.removeClasses(L, $), l.addClass(L, $, "done"), l.props.onEntered && l.props.onEntered(E, _);
    }, l.onExit = function(E) {
      var _ = l.resolveArguments(E), k = _[0];
      l.removeClasses(k, "appear"), l.removeClasses(k, "enter"), l.addClass(k, "exit", "base"), l.props.onExit && l.props.onExit(E);
    }, l.onExiting = function(E) {
      var _ = l.resolveArguments(E), k = _[0];
      l.addClass(k, "exit", "active"), l.props.onExiting && l.props.onExiting(E);
    }, l.onExited = function(E) {
      var _ = l.resolveArguments(E), k = _[0];
      l.removeClasses(k, "exit"), l.addClass(k, "exit", "done"), l.props.onExited && l.props.onExited(E);
    }, l.resolveArguments = function(E, _) {
      return l.props.nodeRef ? [l.props.nodeRef.current, E] : [E, _];
    }, l.getClassNames = function(E) {
      var _ = l.props.classNames, k = typeof _ == "string", L = k && _ ? _ + "-" : "", M = k ? "" + L + E : _[E], $ = k ? M + "-active" : _[E + "Active"], J = k ? M + "-done" : _[E + "Done"];
      return {
        baseClassName: M,
        activeClassName: $,
        doneClassName: J
      };
    }, l;
  }
  var c = u.prototype;
  return c.addClass = function(v, S, g) {
    var E = this.getClassNames(S)[g + "ClassName"], _ = this.getClassNames("enter"), k = _.doneClassName;
    S === "appear" && g === "done" && k && (E += " " + k), g === "active" && v && forceReflow(v), E && (this.appliedClasses[S][g] = E, _addClass(v, E));
  }, c.removeClasses = function(v, S) {
    var g = this.appliedClasses[S], E = g.base, _ = g.active, k = g.done;
    this.appliedClasses[S] = {}, E && removeClass(v, E), _ && removeClass(v, _), k && removeClass(v, k);
  }, c.render = function() {
    var v = this.props;
    v.classNames;
    var S = _objectWithoutPropertiesLoose(v, ["classNames"]);
    return /* @__PURE__ */ React.createElement(Transition$1, _extends({}, S, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  }, u;
}(React.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = process.env.NODE_ENV !== "production" ? _extends({}, Transition$1.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: classNamesShape,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: PropTypes.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: PropTypes.func
}) : {};
const CSSTransition$1 = CSSTransition;
var _leaveRenders, _enterRenders;
function areChildrenDifferent(a, u) {
  return !(a === u || React.isValidElement(a) && React.isValidElement(u) && a.key != null && a.key === u.key);
}
var modes = {
  out: "out-in",
  in: "in-out"
}, callHook = function a(u, c, l) {
  return function() {
    var v;
    u.props[c] && (v = u.props)[c].apply(v, arguments), l();
  };
}, leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(a) {
  var u = a.current, c = a.changeState;
  return React.cloneElement(u, {
    in: !1,
    onExited: callHook(u, "onExited", function() {
      c(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(a) {
  var u = a.current, c = a.changeState, l = a.children;
  return [u, React.cloneElement(l, {
    in: !0,
    onEntered: callHook(l, "onEntered", function() {
      c(ENTERING);
    })
  })];
}, _leaveRenders), enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(a) {
  var u = a.children, c = a.changeState;
  return React.cloneElement(u, {
    in: !0,
    onEntered: callHook(u, "onEntered", function() {
      c(ENTERED, React.cloneElement(u, {
        in: !0
      }));
    })
  });
}, _enterRenders[modes.in] = function(a) {
  var u = a.current, c = a.children, l = a.changeState;
  return [React.cloneElement(u, {
    in: !1,
    onExited: callHook(u, "onExited", function() {
      l(ENTERED, React.cloneElement(c, {
        in: !0
      }));
    })
  }), React.cloneElement(c, {
    in: !0
  })];
}, _enterRenders), SwitchTransition = /* @__PURE__ */ function(a) {
  _inheritsLoose(u, a);
  function u() {
    for (var l, v = arguments.length, S = new Array(v), g = 0; g < v; g++)
      S[g] = arguments[g];
    return l = a.call.apply(a, [this].concat(S)) || this, l.state = {
      status: ENTERED,
      current: null
    }, l.appeared = !1, l.changeState = function(E, _) {
      _ === void 0 && (_ = l.state.current), l.setState({
        status: E,
        current: _
      });
    }, l;
  }
  var c = u.prototype;
  return c.componentDidMount = function() {
    this.appeared = !0;
  }, u.getDerivedStateFromProps = function(v, S) {
    return v.children == null ? {
      current: null
    } : S.status === ENTERING && v.mode === modes.in ? {
      status: ENTERING
    } : S.current && areChildrenDifferent(S.current, v.children) ? {
      status: EXITING
    } : {
      current: React.cloneElement(v.children, {
        in: !0
      })
    };
  }, c.render = function() {
    var v = this.props, S = v.children, g = v.mode, E = this.state, _ = E.status, k = E.current, L = {
      children: S,
      current: k,
      changeState: this.changeState,
      status: _
    }, M;
    switch (_) {
      case ENTERING:
        M = enterRenders[g](L);
        break;
      case EXITING:
        M = leaveRenders[g](L);
        break;
      case ENTERED:
        M = k;
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, M);
  }, u;
}(React.Component);
SwitchTransition.propTypes = process.env.NODE_ENV !== "production" ? {
  /**
   * Transition modes.
   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
   * `in-out`: New element transitions in first, then when complete, the current element transitions out.
   *
   * @type {'out-in'|'in-out'}
   */
  mode: PropTypes.oneOf([modes.in, modes.out]),
  /**
   * Any `Transition` or `CSSTransition` component.
   */
  children: PropTypes.oneOfType([PropTypes.element.isRequired])
} : {};
SwitchTransition.defaultProps = {
  mode: modes.out
};
const SwitchTransition$1 = SwitchTransition, Animations = {
  "fade-in": ".fade-in{-webkit-animation:fade-in;animation:fade-in}@-webkit-keyframes fade-in{0%{opacity:0}100%{opacity:1}}@keyframes fade-in{0%{opacity:0}100%{opacity:1}}",
  "fade-out": ".fade-out{-webkit-animation:fade-out;animation:fade-out}@-webkit-keyframes fade-out{0%{opacity:1}100%{opacity:0}}@keyframes fade-out{0%{opacity:1}100%{opacity:0}}",
  "slide-in-blurred-top": ".slide-in-blurred-top{-webkit-animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both;animation:slide-in-blurred-top .6s cubic-bezier(.23,1.000,.32,1.000) both}@-webkit-keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}@keyframes slide-in-blurred-top{0%{-webkit-transform:translateY(-1000px) scaleY(2.5) scaleX(.2);transform:translateY(-1000px) scaleY(2.5) scaleX(.2);-webkit-transform-origin:50% 0;transform-origin:50% 0;-webkit-filter:blur(40px);filter:blur(40px);opacity:0}100%{-webkit-transform:translateY(0) scaleY(1) scaleX(1);transform:translateY(0) scaleY(1) scaleX(1);-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-filter:blur(0);filter:blur(0);opacity:1}}",
  "slide-in-left": ".slide-in-left{-webkit-animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both;animation:slide-in-left .5s cubic-bezier(.25,.46,.45,.94) both}@-webkit-keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}@keyframes slide-in-left{0%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}100%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}}",
  "slide-out-left": ".slide-out-left{-webkit-animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both;animation:slide-out-left .5s cubic-bezier(.55,.085,.68,.53) both}@-webkit-keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}@keyframes slide-out-left{0%{-webkit-transform:translateX(0);transform:translateX(0);opacity:1}100%{-webkit-transform:translateX(-1000px);transform:translateX(-1000px);opacity:0}}"
}, APIKitAnimation = (a) => {
  const {
    enter: u,
    exit: c,
    children: l,
    tag: v = "div",
    direction: S = "normal",
    duration: g = 500,
    id: E,
    type: _
  } = a, k = E ? `${_}-${E}` : `${_}-api-kit-animation`;
  return /* @__PURE__ */ React.createElement("div", {
    style: {
      height: "100%",
      width: "100%"
    }
  }, /* @__PURE__ */ React.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: renderStyle(_, u, c, g, S)
    }
  }), /* @__PURE__ */ React.createElement(SwitchTransition$1, {
    mode: "out-in"
  }, /* @__PURE__ */ React.createElement(CSSTransition$1, {
    key: k,
    addEndListener: (L, M) => {
      L.addEventListener("transitionend", M, !1);
    },
    classNames: {
      enter: `${_}-default-enter`,
      enterActive: u,
      exit: `${_}-default-leave`,
      exitActive: c
    },
    timeout: g
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      height: "100%",
      width: "100%"
    }
  }, l))));
}, renderStyle = (a, u, c, l, v) => `
        body {
          margin: 0;
          padding: 0;
        }
        
        ${Animations[u]}
        
        ${Animations[c]}

        .${a}-transition {
          transition: opacity ${l}ms ease-out};
        }

        .${a}-default-enter {
          opacity: 0;
        }

        .${a}-default-enter.${u} {
          animation-direction: ${v};
          animation-duration: ${l / 1e3}s;
          animation-fill-mode: both;
          animation-timing-function: ease-out;
        }

        .${a}-default-leave {
          opacity: 1;
        }

        .${a}-default-leave.${c} {
          animation-direction: ${v};
          animation-duration: ${l / 1e3}s;
          animation-timing-function: ease-out;
          animation-fill-mode: both;
        }
        `, APIKitAnimation$1 = APIKitAnimation;
var APIKitAnimationTypes = /* @__PURE__ */ ((a) => (a.FADE_IN = "fade-in", a.FADE_OUT = "fade-out", a.SLIDE_IN_BLURRED_TOP = "slide-in-blurred-top", a.SLIDE_IN_LEFT = "slide-in-left", a.SLIDE_OUT_LEFT = "slide-out-left", a))(APIKitAnimationTypes || {});
const Logo$1 = {
  name: "LS-Logo",
  sourceType: "Logo",
  create({
    onUpdate: a
  }, {
    sourceProps: u
  }) {
    const c = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {
      x: S
    } = v.props.size, g = (S ?? 1280) / 1920, E = (L) => L * g + "px", _ = ({
      source: L
    }) => {
      var ne;
      const {
        src: M,
        meta: $
      } = (L == null ? void 0 : L.sourceProps) || {}, {
        id: J
      } = L || {}, [V, q] = React.useState(!1);
      useEffect(() => {
        q(!1);
      }, [J]);
      const {
        offsetX: G = 40,
        offsetY: H = 40,
        height: B = 135,
        width: Y = 240
      } = ($ == null ? void 0 : $.style) || {};
      return /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        type: "logo",
        id: J,
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: V ? 1 : 0,
          width: "100%",
          height: "100%"
        },
        className: "logo-transition"
      }, M && /* @__PURE__ */ React.createElement("div", {
        className: "logo wrapper",
        style: {
          padding: `${E(H)} ${E(G)}`
        }
      }, /* @__PURE__ */ React.createElement("img", {
        style: {
          height: "100%",
          width: "100%",
          maxHeight: B ? E(B) : "none",
          maxWidth: Y ? E(Y) : "none",
          ...(ne = u == null ? void 0 : u.meta) == null ? void 0 : ne.style,
          ...$ == null ? void 0 : $.style
        },
        src: M,
        onLoad: () => q(!0)
      }))));
    }, k = (L) => ReactDOM.render(/* @__PURE__ */ React.createElement(_, {
      source: L
    }), c);
    return a((L) => {
      k({
        ...L
      });
    }), {
      root: c
    };
  }
}, Iframe = ({
  url: a,
  allowFullScreen: u,
  position: c,
  display: l,
  height: v,
  width: S,
  overflow: g,
  styles: E,
  onLoad: _,
  id: k,
  frameBorder: L,
  className: M,
  name: $,
  target: J,
  iframeRef: V,
  children: q,
  src: G
}) => {
  const H = Object.assign({
    src: G || a,
    target: J || null,
    style: {
      position: c || null,
      display: l || "block",
      overflow: g || null,
      ...E
    },
    name: $ || null,
    className: M || null,
    id: k || null,
    onLoad: _ || null,
    height: v || "100%",
    width: S || "100%",
    allow: "autoplay"
  });
  let B = /* @__PURE__ */ Object.create(null);
  for (let Y of Object.keys(H))
    H[Y] != null && (B[Y] = H[Y]);
  for (let Y of Object.keys(B.style))
    B.style[Y] == null && delete B.style[Y];
  if (u)
    if ("allow" in B) {
      const Y = B.allow.replace("fullscreen", "");
      B.allow = `fullscreen ${Y.trim()}`.trim();
    } else
      B.allow = "fullscreen";
  return L >= 0 && (B.style.hasOwnProperty("border") || (B.style.border = L)), /* @__PURE__ */ React.createElement(React.Fragment, null, q ? /* @__PURE__ */ React.createElement("iframe", {
    ref: V,
    ...B
  }, q) : /* @__PURE__ */ React.createElement("iframe", {
    ref: V,
    ...B
  }));
}, Iframe$1 = Iframe, Overlay = {
  name: "LS-Overlay",
  sourceType: "Overlay",
  create({
    onUpdate: a,
    onRemove: u
  }, {
    sourceProps: c
  }) {
    u(() => {
      clearInterval(S);
    });
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).role;
    let S;
    const g = ({
      source: M,
      setStartAnimation: $
    }) => {
      const {
        src: J,
        meta: V,
        height: q,
        width: G
      } = (M == null ? void 0 : M.sourceProps) || {}, H = React.useRef(null);
      useEffect(() => {
        H.current && (H.current.style.removeProperty("transformOrigin"), H.current.style.removeProperty("transform"));
      }, [J]);
      const B = () => {
        if (H.current) {
          const ne = getProject(CoreContext.state.activeProjectId).compositor.getRoot(), {
            x: Z,
            y: re
          } = ne.props.size;
          let oe = H.current.clientWidth, de = H.current.clientHeight, A;
          oe && de ? A = Math.min(Z / oe, re / de) : A = 1, H.current.style.willChange = "transform", H.current.style.transformOrigin = "0 0", H.current.style.transform = `scale(${A}) translateZ(0)`, $(!0);
        }
      };
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Iframe$1, {
        key: M.id,
        url: J,
        frameBorder: 0,
        iframeRef: H,
        height: q,
        width: G,
        onLoad: B,
        styles: {
          ...V == null ? void 0 : V.style
        }
      }));
    }, E = ({
      source: M,
      setStartAnimation: $
    }) => {
      var A;
      const {
        src: J,
        type: V,
        meta: q,
        loop: G
      } = (M == null ? void 0 : M.sourceProps) || {}, {
        id: H,
        sourceType: B
      } = M || {}, [Y, ne] = React.useState(null), Z = React.useRef(null);
      console.log("Updated current time", (A = Z == null ? void 0 : Z.current) == null ? void 0 : A.currentTime);
      const re = React.useCallback((N) => {
        Z.current = N, ne(N ? N.id : null);
      }, []), oe = React.useCallback(() => {
        Z != null && Z.current && Z.current.play().catch(() => {
          var N;
          Z.current.muted = !0, (N = Z.current) == null || N.play();
        });
      }, [J]), de = React.useCallback(() => {
        S && clearInterval(S), hasPermission(v, Permission.UpdateProject) && trigger$1("VideoEnded", {
          id: H,
          category: V
        });
      }, [J]);
      return React.useEffect(() => {
        q && (Z != null && Z.current) && Y && hasPermission(v, Permission.ManageSelf) && q != null && q.time && (Z.current.currentTime = Number(q == null ? void 0 : q.time));
      }, [q == null ? void 0 : q.time, Y]), React.useEffect(() => () => {
        S && clearInterval(S);
      }, [H]), React.useEffect(() => {
        Y ? Z.current && (Z.current.src = J, Z.current.play().catch(() => {
          Z.current.muted = !0, Z.current.play();
        }), hasPermission(v, Permission.UpdateProject) && (S = setInterval(() => {
          if (Z.current.duration) {
            const N = Z.current.duration - Z.current.currentTime;
            trigger$1("VideoTimeUpdate", {
              category: B,
              id: H,
              time: Math.floor(N)
            });
          }
        }, 1e3))) : S && clearInterval(S);
      }, [Y]), /* @__PURE__ */ React.createElement(React.Fragment, {
        key: H
      }, J && /* @__PURE__ */ React.createElement("video", {
        loop: G,
        id: H,
        ref: re,
        style: {
          ...c.meta.style,
          ...q.style
        },
        onLoadedData: oe,
        onEnded: de,
        onCanPlay: () => $(!0)
      }));
    }, _ = ({
      source: M,
      setStartAnimation: $
    }) => {
      const {
        src: J,
        meta: V
      } = (M == null ? void 0 : M.sourceProps) || {}, {
        id: q
      } = M || {};
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: q
      }, J && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...c.meta.style,
          ...V.style
        },
        src: J,
        onLoad: () => $(!0)
      }));
    }, k = ({
      source: M
    }) => {
      const {
        type: $
      } = (M == null ? void 0 : M.sourceProps) || {}, {
        id: J
      } = M || {}, [V, q] = React.useState(!1);
      return useEffect(() => {
        q(!1);
      }, [J]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: J,
        type: "overlay",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: V ? 1 : 0
        },
        className: "overlayContainer overlay-transition"
      }, J && $ === "image" && /* @__PURE__ */ React.createElement(_, {
        source: M,
        setStartAnimation: q
      }), J && $ === "video" && /* @__PURE__ */ React.createElement(E, {
        source: M,
        setStartAnimation: q
      }), J && $ === "custom" && /* @__PURE__ */ React.createElement(g, {
        source: M,
        setStartAnimation: q
      })));
    }, L = (M) => ReactDOM.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(k, {
      source: M
    })), l);
    return a((M) => {
      L({
        ...M
      });
    }), {
      root: l
    };
  }
};
var functionExpression = /[\s]*([a-z-]+)[\s]*\([\s]*([^\)]+)[\s]*\)[\s]*/i, floatExpression = /^(\-?\d+\.?\d{0,5})/, toFloat = parseFloat;
function ensurePercent(a) {
  return typeof a == "number" ? a : toFloat(a) * 0.01;
}
function formatPercent(a) {
  return formatFloat(a * 100) + "%";
}
function formatFloat(a) {
  return floatExpression.exec(a.toString())[1];
}
function parseCSSFunction(a) {
  var u = functionExpression.exec(a);
  if (!(!u || !u.length))
    return [u[1]].concat(u[2].split(","));
}
function cssFunction(a, u) {
  var c = Array.prototype.join.call(u, ", ");
  return a + "(" + c + ")";
}
var math = Math, round = math.round;
function roundFloat(a, u) {
  return round(a * u) / u;
}
var _a, RGB = "rgb", HSL = "hsl", converters = (_a = {}, _a[RGB + HSL] = RGBtoHSL, _a[HSL + RGB] = HSLtoRGB, _a), maxChannelValues = {
  r: 255,
  g: 255,
  b: 255,
  h: 360,
  s: 1,
  l: 1,
  a: 1
};
function color(a) {
  return parseHexCode(a) || parseColorFunction(a) || rgb(255, 0, 0);
}
function rgb(a, u, c, l) {
  return new ColorHelper(
    RGB,
    a,
    u,
    c,
    l === void 0 ? 1 : ensurePercent(l),
    l !== void 0
    /* hasAlpha*/
  );
}
function convertHelper(a, u, c) {
  var l = u.f, v = u.r, S = u.g, g = u.b, E = u.a, _ = c === void 0 ? u.o : c;
  return l !== a ? converters[l + a](v, S, g, E, _) : c === void 0 ? u : new ColorHelper(l, v, S, g, E, _);
}
var ColorHelper = (
  /** @class */
  function() {
    function a(u, c, l, v, S, g) {
      var E = this;
      E.f = u, E.o = g;
      var _ = u === HSL;
      E.r = clampColor(_ ? "h" : "r", c), E.g = clampColor(_ ? "s" : "g", l), E.b = clampColor(_ ? "l" : "b", v), E.a = clampColor("a", S);
    }
    return a.prototype.toString = function() {
      var u = this, c = u.o, l = u.f, v = u.r, S = u.g, g = u.b, E = u.a, _, k;
      if (l === RGB)
        _ = c ? "rgba" : RGB, k = [round(v), round(S), round(g)];
      else if (l === HSL)
        _ = c ? "hsla" : HSL, k = [round(v), formatPercent(roundFloat(S, 100)), formatPercent(roundFloat(g, 100))];
      else
        throw new Error("Invalid color format");
      return c && k.push(formatFloat(roundFloat(E, 1e5))), cssFunction(_, k);
    }, a.prototype.toHexString = function() {
      var u = convertHelper(RGB, this);
      return "#" + (toHex(u.r) + toHex(u.g) + toHex(u.b)).toUpperCase();
    }, a.prototype.toHSL = function() {
      return convertHelper(HSL, this, !1);
    }, a.prototype.toHSLA = function() {
      return convertHelper(HSL, this, !0);
    }, a.prototype.toRGB = function() {
      return convertHelper(RGB, this, !1);
    }, a.prototype.toRGBA = function() {
      return convertHelper(RGB, this, !0);
    }, a.prototype.red = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).r;
    }, a.prototype.green = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).g;
    }, a.prototype.blue = function() {
      var u = this;
      return (u.f === RGB ? u : u.toRGB()).b;
    }, a.prototype.hue = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).r;
    }, a.prototype.saturation = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).g;
    }, a.prototype.lightness = function() {
      var u = this;
      return (u.f === HSL ? u : u.toHSL()).b;
    }, a.prototype.alpha = function() {
      return this.a;
    }, a.prototype.opacity = function() {
      return this.a;
    }, a.prototype.invert = function() {
      var u = this, c = convertHelper(RGB, u);
      return convertHelper(u.f, new a(RGB, 255 - c.r, 255 - c.g, 255 - c.b, u.a, u.o));
    }, a.prototype.lighten = function(u, c) {
      var l = this, v = convertHelper(HSL, l), S = maxChannelValues.l, g = v.b + (c ? S - v.b : S) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, v.g, g, l.a, l.o));
    }, a.prototype.darken = function(u, c) {
      var l = this, v = convertHelper(HSL, l), S = v.b - (c ? v.b : maxChannelValues.l) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, v.g, S, l.a, l.o));
    }, a.prototype.saturate = function(u, c) {
      var l = this, v = convertHelper(HSL, l), S = maxChannelValues.s, g = v.g + (c ? S - v.g : S) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, g, v.b, l.a, l.o));
    }, a.prototype.desaturate = function(u, c) {
      var l = this, v = convertHelper(HSL, l), S = maxChannelValues.s, g = v.g - (c ? v.g : S) * ensurePercent(u);
      return convertHelper(l.f, new a(HSL, v.r, g, v.b, l.a, l.o));
    }, a.prototype.grayscale = function() {
      return this.desaturate(1);
    }, a.prototype.fade = function(u) {
      var c = this, l = clampColor("a", ensurePercent(u));
      return convertHelper(c.f, new a(c.f, c.r, c.g, c.b, l, !0));
    }, a.prototype.fadeOut = function(u, c) {
      var l = this, v = 1, S = clampColor("a", l.a - (c ? l.a : v) * ensurePercent(u));
      return convertHelper(l.f, new a(l.f, l.r, l.g, l.b, S, !0));
    }, a.prototype.fadeIn = function(u, c) {
      var l = this, v = 1, S = clampColor("a", l.a + (c ? l.a : v) * ensurePercent(u));
      return convertHelper(l.f, new a(l.f, l.r, l.g, l.b, S, !0));
    }, a.prototype.mix = function(u, c) {
      var l = this, v = ensureColor(u), S = convertHelper(RGB, l), g = convertHelper(RGB, v), E = c === void 0 ? 0.5 : c, _ = 2 * E - 1, k = Math.abs(S.a - g.a), L = ((_ * k === -1 ? _ : (_ + k) / (1 + _ * k)) + 1) / 2, M = 1 - L, $ = new a(RGB, round(S.r * L + g.r * M), round(S.g * L + g.g * M), round(S.b * L + g.b * M), S.a * E + g.a * (1 - E), l.o || v.o);
      return convertHelper(this.f, $);
    }, a.prototype.tint = function(u) {
      return rgb(255, 255, 255).mix(this, u);
    }, a.prototype.shade = function(u) {
      return rgb(0, 0, 0).mix(this, u);
    }, a.prototype.spin = function(u) {
      var c = this, l = convertHelper(HSL, c);
      return convertHelper(c.f, new a(HSL, modDegrees(l.r + u), l.g, l.b, c.a, c.o));
    }, a;
  }()
);
function toHex(a) {
  var u = round(a);
  return (u < 16 ? "0" : "") + u.toString(16);
}
function modDegrees(a) {
  return ((a < 0 ? 360 : 0) + a % 360) % 360;
}
function RGBtoHSL(a, u, c, l, v) {
  var S = a / 255, g = u / 255, E = c / 255, _ = Math.min(S, g, E), k = Math.max(S, g, E), L = (_ + k) / 2, M = k - _, $;
  k === _ ? $ = 0 : S === k ? $ = (g - E) / M : g === k ? $ = 2 + (E - S) / M : E === k ? $ = 4 + (S - g) / M : $ = 0, $ = Math.min($ * 60, 360), $ < 0 && ($ += 360);
  var J;
  return k === _ ? J = 0 : L <= 0.5 ? J = M / (k + _) : J = M / (2 - k - _), new ColorHelper(HSL, $, J, L, l, v);
}
function HSLtoRGB(a, u, c, l, v) {
  var S = a / 360, g = u, E = c;
  if (g === 0) {
    var _ = E * 255;
    return new ColorHelper(RGB, _, _, _, l, v);
  }
  for (var k = E < 0.5 ? E * (1 + g) : E + g - E * g, L = 2 * E - k, M = 0, $ = 0, J = 0, V = 0; V < 3; V++) {
    var q = S + 0.3333333333333333 * -(V - 1);
    q < 0 && q++, q > 1 && q--;
    var _ = void 0;
    6 * q < 1 ? _ = L + (k - L) * 6 * q : 2 * q < 1 ? _ = k : 3 * q < 2 ? _ = L + (k - L) * (2 / 3 - q) * 6 : _ = L, _ *= 255, V === 0 ? M = _ : V === 1 ? $ = _ : J = _;
  }
  return new ColorHelper(RGB, M, $, J, l, v);
}
function clampColor(a, u) {
  var c = 0, l = maxChannelValues[a];
  return u < c ? c : u > l ? l : u;
}
function ensureColor(a) {
  return a instanceof ColorHelper ? a : color(a);
}
function parseHexCode(a) {
  var u = a.match(/#(([a-f0-9]{6})|([a-f0-9]{3}))$/i);
  if (u) {
    var c = u[1], l = parseInt(c.length === 3 ? c[0] + c[0] + c[1] + c[1] + c[2] + c[2] : c, 16), v = l >> 16 & 255, S = l >> 8 & 255, g = l & 255;
    return new ColorHelper(RGB, v, S, g, 1, !1);
  }
}
function parseColorFunction(a) {
  var u = parseCSSFunction(a);
  if (!(!u || !(u.length === 4 || u.length === 5))) {
    var c = u[0], l = c === "rgba", v = c === "hsla", S = c === RGB, g = c === HSL, E = v || l, _;
    if (S || l)
      _ = RGB;
    else if (g || v)
      _ = HSL;
    else
      throw new Error("unsupported color string");
    var k = toFloat(u[1]), L = S || l ? toFloat(u[2]) : ensurePercent(u[2]), M = S || l ? toFloat(u[3]) : ensurePercent(u[3]), $ = E ? toFloat(u[4]) : 1;
    return new ColorHelper(_, k, L, M, $, E);
  }
}
const of = color, transparent = color("rgba(0,0,0,0)"), white = color("#ffffff"), black = color("#000000"), weights = {
  primary: {
    50: "#EAFAF5",
    100: "#D5F6EB",
    200: "#ABEDD7",
    300: "#82E3C3",
    400: "#58DAAF",
    500: "#26AD80",
    600: "#25A77C",
    700: "#1C7D5D",
    800: "#12543E"
  },
  secondary: {
    50: "#FBEAEA",
    100: "#F7D4D4",
    200: "#EFA9A9",
    300: "#E77E7E",
    400: "#FF6F64",
    500: "#E9554A",
    600: "#CB362B",
    700: "#811818",
    800: "#561010"
  },
  neutral: {
    0: "#ffffff",
    10: "#f5f5f5",
    200: "#d9d9d9",
    300: "#bababa",
    350: "#999999",
    400: "#9e9e9e",
    500: "#808080",
    600: "#666666",
    700: "#4d4d4d",
    800: "#303030",
    900: "#141414",
    1e3: "#000000"
  },
  warning: {
    400: "#FFC28A",
    500: "#FFAE64",
    600: "#F29540"
  }
}, types = Object.keys(weights), weight = (a) => (u) => {
  const c = weights[a];
  if (c[u])
    return c[u];
  const l = Object.keys(weights.primary).map(Number), v = l.find((S) => u <= S);
  return v ? c[v] : c[l.slice(l.length - 1)[0]];
}, primary = weight("primary"), neutral = weight("neutral"), secondary = weight("secondary"), warning = weight("warning"), lightstream = color("#26ad80"), twitch = color("#9156ff"), linkedin = color("#2867b2"), youtube = color("#ff0000"), facebook = color("#1877f2"), twitter = color("#1da1f2"), Color = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  black,
  color,
  facebook,
  lightstream,
  linkedin,
  neutral,
  of,
  primary,
  secondary,
  transparent,
  twitch,
  twitter,
  types,
  warning,
  white,
  youtube
}, Symbol.toStringTag, { value: "Module" })), YouTube = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z"
})), YouTubeDuo = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("rect", {
  x: "8",
  y: "9",
  width: "9",
  height: "7",
  fill: neutral(0)
}), /* @__PURE__ */ React.createElement("path", {
  d: "M19.6465 8.53711C19.4707 7.83398 18.9141 7.27734 18.2402 7.10156C16.9805 6.75 12 6.75 12 6.75C12 6.75 6.99023 6.75 5.73047 7.10156C5.05664 7.27734 4.5 7.83398 4.32422 8.53711C3.97266 9.76758 3.97266 12.4043 3.97266 12.4043C3.97266 12.4043 3.97266 15.0117 4.32422 16.2715C4.5 16.9746 5.05664 17.502 5.73047 17.6777C6.99023 18 12 18 12 18C12 18 16.9805 18 18.2402 17.6777C18.9141 17.502 19.4707 16.9746 19.6465 16.2715C19.998 15.0117 19.998 12.4043 19.998 12.4043C19.998 12.4043 19.998 9.76758 19.6465 8.53711ZM10.3594 14.7773V10.0312L14.5195 12.4043L10.3594 14.7773Z"
})), Facebook = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M15.4863 13.3125L15.8965 10.6172H13.2891V8.85938C13.2891 8.09766 13.6406 7.39453 14.8125 7.39453H16.0137V5.08008C16.0137 5.08008 14.9297 4.875 13.9043 4.875C11.7656 4.875 10.3594 6.19336 10.3594 8.53711V10.6172H7.95703V13.3125H10.3594V19.875H13.2891V13.3125H15.4863Z"
})), FacebookCircle = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.2656 12.375C19.2656 8.36133 16.0137 5.10938 12 5.10938C7.98633 5.10938 4.73438 8.36133 4.73438 12.375C4.73438 16.0078 7.37109 19.0254 10.8574 19.5527V14.4844H9.01172V12.375H10.8574V10.793C10.8574 8.97656 11.9414 7.95117 13.582 7.95117C14.4023 7.95117 15.2227 8.09766 15.2227 8.09766V9.88477H14.3145C13.4062 9.88477 13.1133 10.4414 13.1133 11.0273V12.375H15.1348L14.8125 14.4844H13.1133V19.5527C16.5996 19.0254 19.2656 16.0078 19.2656 12.375Z"
})), Twitch = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z"
})), TwitchDuo = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19 6.5H9L8.8125 17.5H13.5L19 13V6.5Z",
  fill: neutral(0)
}), /* @__PURE__ */ React.createElement("path", {
  d: "M16.9551 8.92188H15.8125V12.1445H16.9551V8.92188ZM13.8496 8.89258H12.707V12.1152H13.8496V8.89258ZM9.01562 5.875L6.20312 8.57031V18.209H9.60156V20.875L12.4141 18.209H14.6699L19.7676 13.375V5.875H9.01562ZM18.6543 12.8477L16.3691 14.9863H14.1133L12.1504 16.8613V14.9863H9.60156V6.95898H18.6543V12.8477Z"
})), Twitter = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M20.6681 7.98749C20.6806 8.16248 20.6806 8.33751 20.6806 8.5125C20.6806 13.85 16.6197 20 9.1976 20C6.91098 20 4.78681 19.3375 3 18.1875C3.32489 18.225 3.63723 18.2375 3.97462 18.2375C5.86136 18.2375 7.59821 17.6 8.98518 16.5125C7.21086 16.475 5.72393 15.3125 5.21162 13.7125C5.46155 13.75 5.71143 13.775 5.97386 13.775C6.33621 13.775 6.69859 13.725 7.03594 13.6375C5.18666 13.2625 3.79966 11.6375 3.79966 9.67499V9.62501C4.33693 9.92501 4.96174 10.1125 5.62393 10.1375C4.53685 9.41247 3.82466 8.17498 3.82466 6.77497C3.82466 6.02499 4.02454 5.33749 4.37443 4.73748C6.36117 7.18748 9.34753 8.78745 12.6962 8.96248C12.6337 8.66248 12.5962 8.35001 12.5962 8.03751C12.5962 5.81248 14.3955 4 16.6322 4C17.7942 4 18.8438 4.4875 19.581 5.275C20.4931 5.10001 21.3678 4.76249 22.1425 4.3C21.8426 5.23752 21.2054 6.02502 20.3682 6.52499C21.1804 6.43753 21.9676 6.21248 22.6923 5.90001C22.1426 6.69998 21.4553 7.41245 20.6681 7.98749Z"
})), LinkedIn = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 24 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M19.2 3H4.8C3.81 3 3.009 3.81 3.009 4.8L3 19.2C3 20.19 3.81 21 4.8 21H19.2C20.19 21 21 20.19 21 19.2V4.8C21 3.81 20.19 3 19.2 3ZM8.4 18.3H5.7V10.2H8.4V18.3ZM7.05 8.679C6.15 8.679 5.421 7.95 5.421 7.05C5.421 6.15 6.15 5.421 7.05 5.421C7.95 5.421 8.679 6.15 8.679 7.05C8.679 7.95 7.95 8.679 7.05 8.679ZM18.3 18.3H15.6V13.53C15.6 12.783 14.997 12.18 14.25 12.18C13.503 12.18 12.9 12.783 12.9 13.53V18.3H10.2V10.2H12.9V11.28C13.368 10.524 14.331 10.02 15.15 10.02C16.887 10.02 18.3 11.433 18.3 13.17V18.3Z"
})), Lightstream = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0.144 0 27.712 24"
}, /* @__PURE__ */ React.createElement("path", {
  d: "M16.0369 12.1232L14 15.6518L11.5642 11.4335L6.27356 10.6176L14 24L20.4627 12.805L16.0369 12.1232Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M9.74033 8.27418L7.37317 4.17409H20.6268L19.0921 6.83194L24.3827 6.01602L27.8558 0H0.144165L5.31453 8.95665L9.74033 8.27418Z"
})), LightstreamWithText = /* @__PURE__ */ React.createElement("svg", {
  style: {
    flex: "0 0 100%"
  },
  viewBox: "0 0 3000 524"
}, /* @__PURE__ */ React.createElement("polygon", {
  points: "330.56 263.5 299.73 316.91 262.86 253.06 182.78 240.71 299.73 443.27 397.55 273.82 330.56 263.5"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "235.25 205.24 199.42 143.18 400.03 143.18 376.8 183.41 456.88 171.06 509.45 80 90 80 168.26 215.57 235.25 205.24"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M646.32,345.72h94.91v13.73H630V167.26h16.36Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M846.24,359.45H830V167.26h16.23Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1091.16,336.61q-8.45,12-26.46,18.74t-40.33,6.73q-22.57,0-40.13-10.82t-27.19-30.62q-9.64-19.8-9.77-45.41V250.95q0-40,20.2-63.16t54.25-23.17q29.69,0,47.78,15.11T1091,221.38h-16.24q-3.56-21.18-17.23-32.11t-35.7-10.92q-26.92,0-42.64,19.15t-15.71,54v22.72q0,21.93,7.46,38.77t21.38,26.09q13.92,9.25,32,9.25,21,0,36-6.6,9.76-4.36,14.52-10.16V282h-51.61V268.24h67.85Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1333.71,359.45h-16.37V278.11H1207.53v81.33h-16.23V167.26h16.23v97.12h109.81V167.26h16.37Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1563.2,181h-65.87V359.45H1481.1V181h-65.73V167.26H1563.2Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1990.75,181h-65.87V359.45h-16.23V181h-65.73V167.26h147.83Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M2147.65,279.33h-55.84v80.12h-16.36V167.26h62.43q30.75,0,48,14.9t17.29,41.66a52,52,0,0,1-10.83,32.56q-10.82,14.11-29,19.51l48,81.83v1.72h-17.29Zm-55.84-13.73h49.76q20.45,0,32.86-11.63t12.41-30.14q0-20.36-12.93-31.59T2137.61,181h-45.8Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M2407.62,278.11h-89.88v67.61h103.35v13.73H2301.5V167.26h118.92V181H2317.73v83.39h89.88Z"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "2892.79 183.67 2892.79 183.67 2816.23 326.97 2724.06 154.45 2724.06 189.54 2724.06 359.75 2739.67 359.75 2739.67 218.3 2816.26 359.42 2892.79 218.32 2892.79 359.75 2908.4 359.75 2908.4 189.54 2908.4 154.45 2892.79 183.67"
}), /* @__PURE__ */ React.createElement("polygon", {
  points: "2649.77 359.45 2569.47 154.54 2569.47 154.53 2569.46 154.53 2569.46 154.53 2569.46 154.54 2489.16 359.45 2506.19 359.45 2569.46 194.32 2632.74 359.45 2649.77 359.45"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1764.57,287q-6.73-10.56-20.06-18.15a131.55,131.55,0,0,0-21.47-9.18l-7.64,13.49q19.65,6.61,28.32,13.77,11.22,9.3,11.22,25.28,0,16.37-13.6,26.26t-36,9.9c-11.35,0-21.05-1.94-29.35-5.51l-7,12.33a94,94,0,0,0,36.33,6.91q29.7,0,47.85-13.73t18.15-36.43Q1771.3,297.55,1764.57,287Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1659.11,250.93c7.28,5.25,18,10.18,32.13,14.79l7.72-13.38q-21-6.41-31.29-14.49Q1655.95,228.61,1656,214q0-15.83,13-25.66t35-9.83c13.12,0,23.78,3.19,32.26,9.21l7.23-12.51c-1.71-1-3.43-2.1-5.3-3q-15.09-7.38-34.18-7.38-28.19,0-46.31,13.76t-18.11,35.77Q1639.62,237,1659.11,250.93Z"
}), /* @__PURE__ */ React.createElement("path", {
  d: "M1744.34,268.78a129.23,129.23,0,0,0-21.68-9.32l-7.79,13.49c13.28,4.44,22.87,9.06,28.68,13.88q11.2,9.29,11.2,25.23,0,16.33-13.57,26.21t-36,9.88c-11.8,0-21.85-2-30.34-5.91l-7.08,12.26.2.1a93.63,93.63,0,0,0,37.22,7.25q29.64,0,47.75-13.7t18.11-36.36q0-14.36-6.72-24.9T1744.34,268.78Z"
})), IconMap = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Facebook,
  FacebookCircle,
  Lightstream,
  LightstreamWithText,
  LinkedIn,
  Twitch,
  TwitchDuo,
  Twitter,
  YouTube,
  YouTubeDuo
}, Symbol.toStringTag, { value: "Module" })), nudge = (a) => {
  if (a.nudgeUp || a.nudgeDown || a.nudgeRight || a.nudgeLeft)
    return {
      position: "relative",
      top: a.nudgeDown,
      left: a.nudgeRight,
      right: a.nudgeLeft,
      bottom: a.nudgeUp
    };
}, SVGWrapper = ({
  children: a,
  width: u,
  height: c,
  color: l,
  colorWeight: v = 0,
  marginLeft: S,
  marginTop: g,
  marginRight: E,
  marginBottom: _,
  className: k,
  ...L
}) => (l && Color[l](v), /* @__PURE__ */ React.createElement("div", {
  className: k,
  style: {
    ...nudge(L),
    display: "flex",
    justifyContent: "center",
    flexBasis: u || "auto",
    flexShrink: 0,
    width: u,
    height: c || u && "fit-content",
    marginLeft: S,
    marginTop: g,
    marginBottom: _,
    marginRight: E
  }
}, a)), Icon = ({
  name: a,
  ...u
}) => /* @__PURE__ */ React.createElement(SVGWrapper, {
  ...u
}, IconMap[a]), Icon$1 = Icon, dragImageSvg = `
  <svg height="75" width="120" viewBox="0 0 120 75" xmlns="http://www.w3.org/2000/svg" style="">
    <rect width="120" height="75" rx="3" style="
      opacity: 0.4;
      stroke: white;
      stroke-width: 3px;
      stroke-opacity: 0.7;
    "/>
  </svg>`;
let dragImage;
const loadDragImage = () => dragImage || (dragImage = new Image(), dragImage.src = URL.createObjectURL(new Blob([dragImageSvg], {
  type: "image/svg+xml"
})), dragImage);
class ErrorBoundary extends React.Component {
  constructor(u) {
    super(u), this.state = {
      error: null
    };
  }
  componentDidCatch(u, c) {
    log$1.warn(u, c);
  }
  static getDerivedStateFromError() {
    return {
      error: !0
    };
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
const onDrop = async (a, u) => {
  u.preventDefault(), u.stopPropagation();
  const {
    dropNodeId: c,
    dropType: l,
    project: v
  } = a, S = u.dataTransfer.getData("text/plain");
  if (log$1.debug("Compositor: Dropping", {
    dropType: l,
    dragNodeId: S,
    dropNodeId: c
  }), c === S)
    return;
  const [g, E, _, k] = await Promise.all([v.compositor.get(S), v.compositor.get(c), v.compositor.getParent(S), v.compositor.getParent(c)]);
  if (l === "layout")
    return _.id === c ? void 0 : CoreContext.Command.moveNode({
      projectId: v.id,
      nodeId: g.id,
      parentId: E.id
    });
  if (_.id !== (k == null ? void 0 : k.id))
    return CoreContext.Command.swapNodes({
      projectId: v.id,
      nodeAId: g.id,
      nodeBId: E.id
    });
  const L = _.children.map((M) => M.id);
  return CoreContext.Command.reorderNodes({
    projectId: v.id,
    parentId: _.id,
    childIds: swapItems(g.id, E.id, L)
  });
};
let foundDropTarget = !1;
const ElementTree = (a) => {
  var Y, ne;
  const u = useRef(!1), c = useRef(), l = useRef(), v = useRef(), {
    project: S,
    interactive: g = !0,
    onElementDoubleClick: E,
    checkIsDragTarget: _,
    checkIsDropTarget: k
  } = useContext(CompositorContext), {
    nodeId: L
  } = a, M = S.compositor.get(L);
  if (!M)
    return null;
  const $ = CoreContext.compositor.getElement(M), J = M.props.layout || "Row", V = g && _(M), q = g && k(M);
  let G = q ? {
    onDrop: (Z) => (foundDropTarget = !0, onDrop({
      dropType: "layout",
      dropNodeId: M.id,
      project: S
    }, Z)),
    onDragOver: (Z) => {
      var re;
      Z.preventDefault(), Z.stopPropagation(), (re = v.current) == null || re.toggleAttribute("data-layout-drop-target-active", !0);
    },
    onDragLeave: (Z) => {
      var re;
      Z.preventDefault(), Z.stopPropagation(), (re = v.current) == null || re.toggleAttribute("data-layout-drop-target-active", !1);
    }
  } : {}, H = V ? {
    draggable: !0,
    // If a target is draggable, it will also be treated as
    //  a drop target (swap element positions)
    ondrop: (Z) => (foundDropTarget = !0, onDrop(
      {
        dropType: "transform",
        dropNodeId: M.id,
        project: S
      },
      // @ts-ignore TODO: Convert all to native drag events
      Z
    )),
    ondragstart: (Z) => {
      var re;
      u.current = !0, wrapperEl.toggleAttribute("data-dragging", !0), log$1.debug("Compositor: Dragging", M.id), foundDropTarget = !1, Z.dataTransfer.setData("text/plain", M.id), Z.dataTransfer.dropEffect = "move", Z.dataTransfer.setDragImage(dragImage, 10, 10), (re = v.current) == null || re.toggleAttribute("data-drag-target-active", !0), window.__dragging = !0;
    },
    ondragend: (Z) => {
      var re;
      u.current = !1, foundDropTarget || (log$1.info("Compositor: No drop target - deleting node", M), CoreContext.Command.deleteNode({
        nodeId: M.id
      })), wrapperEl.toggleAttribute("data-dragging", !0), log$1.debug("Compositor: DragEnd", Z), (re = v.current) == null || re.toggleAttribute("data-drag-target-active", !1), wrapperEl.querySelectorAll("[data-item]").forEach((oe) => {
        oe.toggleAttribute("data-drag-target-active", !1), oe.toggleAttribute("data-layout-drop-target-active", !1), oe.toggleAttribute("data-transform-drop-target-active", !1);
      }), window.__dragging = !1;
    },
    ondragover: (Z) => {
      var re;
      Z.preventDefault(), Z.stopPropagation(), !u.current && ((re = v.current) == null || re.toggleAttribute("data-transform-drop-target-active", !0));
    },
    ondragleave: (Z) => {
      var re;
      Z.preventDefault(), Z.stopPropagation(), (re = v.current) == null || re.toggleAttribute("data-transform-drop-target-active", !1);
    }
  } : {};
  useEffect(() => {
    l.current && $ && (l.current.appendChild($.root), Object.assign(l.current.style, {
      width: "100%",
      height: "100%",
      position: "relative",
      overflow: "hidden"
    }), Object.assign($.root.style, {
      pointerEvents: V ? "all" : "none",
      width: "100%",
      height: "100%",
      position: "relative",
      ...M.props.style || {}
    }));
  }, [l.current, $]), useEffect(() => {
    const Z = V ? () => E(M) : () => {
    };
    return c.current && (Object.assign(c.current, H), Object.assign(c.current.style, {
      pointerEvents: V ? "all" : "none"
    }), c.current.addEventListener("dblclick", Z)), () => {
      var re;
      (re = c.current) == null || re.removeEventListener("dblclick", Z);
    };
  }, [c.current]);
  const B = {
    layout: J,
    ...M.props.layoutProps ?? {}
  };
  return /* @__PURE__ */ React.createElement("div", {
    ref: v,
    "data-id": M.id + "-x",
    "data-item": !0,
    ...V && {
      "data-drag-target": !0
    },
    ...q && {
      "data-drop-target": !0
    },
    ...G,
    style: {
      position: "relative",
      width: ((Y = M.props.size) == null ? void 0 : Y.x) || "100%",
      height: ((ne = M.props.size) == null ? void 0 : ne.y) || "100%",
      pointerEvents: "none"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    className: "interactive-overlay",
    ref: c,
    style: {
      height: "100%",
      width: "100%",
      position: "absolute",
      zIndex: 2
    }
  }), /* @__PURE__ */ React.createElement("div", {
    className: "item-element",
    style: {
      display: "flex",
      flex: "0 0 auto",
      justifyContent: "center",
      width: "100%",
      height: "100%"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    ref: l
  }), /* @__PURE__ */ React.createElement(ErrorBoundary, null, /* @__PURE__ */ React.createElement("ls-layout", {
    "data-id": M.id + "-x",
    props: JSON.stringify(B),
    layout: J
  }, M.children.map((Z) => /* @__PURE__ */ React.createElement(ElementTree, {
    key: Z.id,
    nodeId: Z.id
  }))))));
}, Root = (a) => {
  const {
    project: u
  } = useContext(CompositorContext), [c, l] = useState(null);
  return useEffect(() => (l(u.compositor.renderTree()), CoreContext.onInternal("NodeChanged", () => {
    l(u.compositor.renderTree());
  })), []), useEffect(() => {
    const v = u.compositor.getRoot(), {
      x: S
    } = v.props.size, g = () => {
      var J, V, q;
      const {
        bannerStyle: E = "default",
        primaryColor: _ = "#ABABAB",
        showNameBanners: k
      } = u.props ?? {}, L = ((J = u.props) == null ? void 0 : J.logoPosition) ?? ((q = (V = u.props) == null ? void 0 : V.logo) == null ? void 0 : q.logoPosition) ?? "top-right";
      if (!E || !_ || !L)
        return;
      const M = themes[E](_, k, S / 1920), $ = themes[L](S / 1920);
      a.setStyle(`${M} ${$}` || "");
    };
    return g(), CoreContext.onInternal("ProjectChanged", g);
  }, [u]), c ? /* @__PURE__ */ React.createElement("div", {
    onDrop: (v) => {
      foundDropTarget = !0, v.preventDefault();
    },
    onDragOver: (v) => {
      v.preventDefault();
    },
    onDragLeave: (v) => {
      v.preventDefault();
    },
    style: {
      userSelect: "none",
      width: `${c.props.size.x + PADDING * 2}px`,
      height: `${c.props.size.y + PADDING * 2}px`,
      margin: PADDING + "px"
    }
  }, /* @__PURE__ */ React.createElement("div", {
    style: {
      width: "100%",
      height: "100%",
      overflow: "hidden"
    }
  }, /* @__PURE__ */ React.createElement(ElementTree, {
    nodeId: c.id
  }))) : null;
};
let wrapperEl, customStyleEl;
const PADDING = 0, render$1 = (a) => {
  const {
    containerEl: u,
    projectId: c,
    dragAndDrop: l = !1,
    checkDragTarget: v = scenelessProjectDragCheck,
    checkDropTarget: S = scenelessProjectDropCheck
  } = a, g = getProject(c);
  CoreContext.clients.LayoutApi().subscribeToLayout(g.layoutApi.layoutId), loadDragImage();
  const E = a.onElementDoubleClick ?? (() => {
  });
  if (!u || !g)
    return;
  if (!u.shadowRoot) {
    u.attachShadow({
      mode: "open"
    }), customStyleEl = document.createElement("style");
    const J = document.createElement("style");
    J.textContent = getStyle(), wrapperEl = document.createElement("div"), wrapperEl.id = "compositor-root", Object.assign(wrapperEl.style, {
      width: "100%",
      height: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transformOrigin: "center"
    }), u.shadowRoot.appendChild(J), u.shadowRoot.appendChild(customStyleEl), u.shadowRoot.appendChild(wrapperEl), new ResizeObserver((q) => {
      M();
    }).observe(u);
  }
  const _ = g.compositor.getRoot(), {
    x: k,
    y: L
  } = _.props.size, M = () => {
    let {
      width: J,
      height: V
    } = u.getBoundingClientRect();
    const q = J / V, G = k / L;
    let H;
    J && V ? G > q ? H = J / (k + PADDING * 2) : H = V / (L + PADDING * 2) : H = 1, wrapperEl.style.willChange = "transform", wrapperEl.style.transform = `scale(${H}) translateZ(0)`, window.__scale = H, $();
  }, $ = () => {
    ReactDOM.render(/* @__PURE__ */ React.createElement(CompositorProvider, {
      project: g,
      interactive: l,
      onElementDoubleClick: E,
      checkIsDropTarget: S,
      checkIsDragTarget: v
    }, /* @__PURE__ */ React.createElement(Root, {
      setStyle: (J) => {
        customStyleEl.textContent = J;
      }
    })), wrapperEl);
  };
  M();
}, scenelessProjectDragCheck = (a) => a.props.name === "Participant" || a.props.sourceType === "RoomParticipant" || a.props.sourceType === "RTMP", scenelessProjectDropCheck = (a) => a.props.name === "Content", CompositorContext = React.createContext({
  interactive: !1,
  project: null,
  checkIsDragTarget: () => !1,
  checkIsDropTarget: () => !1,
  onElementDoubleClick: () => {
  }
}), CompositorProvider = ({
  children: a,
  ...u
}) => /* @__PURE__ */ React.createElement(CompositorContext.Provider, {
  value: {
    ...u
  }
}, a), getStyle = () => `
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'Arial';
}

video {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.NameBanner {
  top: 100%;
  transform: translateY(-100%);
  left: 0;
  height: 30px;
  background: linear-gradient(90deg, rgba(0, 0, 0, 0.5) 50%, rgba(0, 0, 0, 0) 100%);
  padding: 0px 0px 0px 10px;
  color: rgba(255, 255, 255, 0.9);
  font-weight: bold;
  line-height: 30px;
  width: 100%;
  font-size: 28px;
  position: absolute;
}

ls-layout[layout="Presentation"][props*="\\"cover\\"\\:true"] > :first-child .NameBanner {
  top: 0% !important;
  transform: translateY(0%) !important;
}

[layout="Layered"] > [data-item] {
  transform: scale(1.003) !important;
}
[layout="Layered"] > [data-item]:nth-child(2) {
  transform: scale(1.0015) !important;
}
[layout="Layered"] > [data-item]:nth-child(1) {
  transform: scale(1) !important;
}

.logo {
  position: absolute !important;
}

#compositor-root[data-dragging] {}

[data-drag-target] {}
[data-drag-target]:hover > .interactive-overlay {
  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.5);
  cursor: grab;
}
[data-drop-target] {}
[data-drop-target]:hover {}
[data-drag-target][data-drag-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset rgba(255, 255, 255, 0.2);
}
[data-drag-target][data-drag-target-active] > .item-element {
  opacity: 0.8;
}
[data-layout-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset yellow;
}
[data-transform-drop-target-active] > .interactive-overlay {
  box-shadow: 0 0 0 3px inset white;
}
`;
var BannerStyle = /* @__PURE__ */ ((a) => (a.DEFAULT = "default", a.MINIMAL = "minimal", a.BUBBLE = "bubble", a))(BannerStyle || {});
const themes = {
  "top-left": (a = 1280 / 1920) => `
      .wrapper {
       top:0;
       left:0;
    }`,
  "top-right": (a = 1280 / 1920) => `
      .wrapper {
       top:0;
       right:0;
    }`,
  "bottom-left": (a = 1280 / 1920) => `
      .wrapper {
       bottom:0;
       left:0;
    }`,
  "bottom-right": (a = 1280 / 1920) => `
      .wrapper {
       bottom:0;
       right:0;
    }`,
  default: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = color(a).lightness() < 0.6 ? "#FFF" : "#000", v = color(a).lightness() < 0.6 ? "#FFF" : "#000", S = color(a).lightness() < 0.6 ? "#000" : "#FFF", g = (E) => E * c + "px";
    return `
      .ChatOverlay {
        background: ${a} !important;
        margin-bottom: ${g(40)} !important;
        transition: 300ms ease all;
        left: 0;

        /* Default Size 4 */
        font-size: ${g(44)} !important;
        padding: ${g(40)} ${g(100)} !important;
        border-radius: ${g(20)} !important;
      }
      
      .ChatOverlay-badge-icon {
          width:${g(32)};
          height: ${g(32)};
          fill: currentcolor;
          color: ${S};
      }

       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${g(6)} ${g(12)} ${g(6)} ${g(6)};
          border-radius: ${g(10)};
          align-items: center;
          border-bottom-left-radius: 0px !important;
          position: relative;
          border: none;
          cursor: pointer;
       }
      
       .ChatOverlay-badge-username {
          color:${S};
          padding:${g(6)};
          font-size:${g(18)};
          font-weight:700;
          text-transform: capitalize; 
       }
       
       .ChatOverlay-badge-container::before {
          content:"";
          width:15px;
          height:15px;
          background-color:${v};
          position: absolute;
          bottom:-14px;
          left:0;
          clip-path:polygon(0 100%, 12% 87%, 26% 73%, 45% 53%, 59% 40%, 71% 28%, 85% 14%, 100% 0, 0 0);
        }
       

       .ChatOverlay-avatar {
          height: ${g(120)};
          width: ${g(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }

      .Banner, .NameBanner, .ChatOverlay {
        background: ${a} !important;
        margin-bottom: ${g(40)} !important;
        transition: 300ms ease all;
        left: 0;

        /* Default Size 4 */
        font-size: ${g(44)} !important;
        padding: ${g(40)} ${g(100)} !important;
        border-top-right-radius: ${g(20)} !important;
        border-bottom-right-radius: ${g(20)} !important;
      }

      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
      }

      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${g(40)} ${g(100)} !important;
        font-size: ${g(44)} !important;
        border-top-right-radius: ${g(20)} !important;
        border-bottom-right-radius: ${g(20)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${g(12)} ${g(30)} !important;
        font-size: ${g(44)} !important;
        border-top-right-radius: ${g(20)} !important;
        border-bottom-right-radius: ${g(20)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${g(12)} ${g(20)} !important;
        font-size: ${g(28)} !important;
        border-top-right-radius: ${g(16)} !important;
        border-bottom-right-radius: ${g(16)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${g(8)} ${g(8)} !important;
        font-size: ${g(20)} !important;
        border-top-right-radius: ${g(8)} !important;
        border-bottom-right-radius: ${g(8)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0;
        transform: translateX(-100%);
      }
    `;
  },
  minimal: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = "white", v = "#fff", S = "#000", g = (E) => E * c + "px";
    return `

      .ChatOverlay-badge-icon {
          width:${g(32)};
          height: ${g(32)};
          fill: currentcolor;
          color: ${S};
      }

       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${g(6)} ${g(12)} ${g(6)} ${g(6)};
          align-items: center;
          position: relative;
          border: none;
          cursor: pointer;
       }

       .ChatOverlay-badge-username {
          color:${S};
          padding:${g(6)};
          font-size:${g(18)};
          font-weight:700;
          text-transform: capitalize; 
       }

       .ChatOverlay-avatar {
          height: ${g(120)};
          width: ${g(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }


    .Banner, .NameBanner, .ChatOverlay {
        background: ${color(a).fade(color(a).alpha() * 0.7).toString()} !important;
        padding: ${g(40)} ${g(40)} ${g(40)} ${g(60)} !important;
        position: relative !important;
        margin-bottom: ${g(40)} !important;
        transition: 300ms ease all;
        font-size: ${g(34)} !important;
        left: 0;
      }

      .Banner:before, .NameBanner:before, .ChatOverlay:before {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        transition: 300ms ease all;
        opacity: ${color(a).alpha()};
      }
      .Banner:after, .NameBanner:after, .ChatOverlay:after {
        z-index: 1;
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        transition: 300ms ease all;
        width: ${g(20)};
        background: ${color(a)};
        opacity: ${color(a).alpha()};
      }
      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
        position: relative;
        z-index: 2;
      }
      .Banner-header {
        font-size: ${g(90)};
        position: relative;
        z-index: 2;
      }
      .NameBanner {
        transform-origin: 0 100%;
        margin: 0 !important;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      .NameBanner[data-size="4"] {
        padding: ${g(40)} ${g(40)} ${g(40)} ${g(60)} !important;
        font-size: ${g(34)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${g(16)} ${g(40)} ${g(16)} ${g(60)} !important;
        font-size: ${g(34)} !important;
      }
      .NameBanner[data-size="2"] {
        padding: ${g(12)} ${g(24)} ${g(12)} ${g(44)} !important;
        font-size: ${g(24)} !important;
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${g(12)} ${g(16)} ${g(12)} ${g(36)} !important;
        font-size: ${g(18)} !important;
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
  },
  bubble: (a = "#ABABAB", u = !0, c = 1280 / 1920) => {
    const l = color(a).lightness() < 0.6 ? "#FFF" : "#000", v = color(a).lightness() < 0.6 ? "#FFF" : "#000", S = color(a).lightness() < 0.6 ? "#000" : "#FFF", g = (E) => E * c + "px";
    return `
      .ChatOverlay-badge-icon {
          width:${g(32)};
          height: ${g(32)};
          fill: currentcolor;
          color: ${S};
      }


       .ChatOverlay-badge-container {
          background-color:${v};
          display:flex;
          flex-direction:row;
          padding: ${g(6)} ${g(12)} ${g(6)} ${g(6)};
          align-items: center;
          z-index: 1;
          border: none;
          cursor: pointer;
          top: 0;
          margin-bottom: 2px;
          margin-left: -${g(30)};
          border-radius: 30px;
       }

       .ChatOverlay-badge-username {
          color:${S};
          padding:${g(6)};
          font-size:${g(18)};
          font-weight:700;
          text-transform: capitalize; 
       }

       .ChatOverlayAvatar-container {
          height: ${g(120)};
          width: ${g(120)};
          top: 0;
       }
       .ChatOverlay-avatar {
          height: ${g(120)};
          width: ${g(120)};
          left:0;
          right:0;
          top:0;
          bottom:0;
          border-radius:50%;
       }


      .Banner, .ChatOverlay {
        transform: translateX(-50%);
        left: 50%;
        margin-bottom: ${g(40)} !important;
      }

      .Banner, .NameBanner, .ChatOverlay {
        background: ${color(a)} !important;
        color: ${l} !important;
        border-radius: 500px !important;
        transition: 300ms ease all;

        /* Default Style */
        border: 4px solid ${l} !important;
        padding: ${g(40)} ${g(80)} !important;
        font-size: ${g(40)} !important;
      }
      .Banner-body, .NameBanner-body, .ChatOverlay-body {
        color: ${l} !important;
        text-align: center !important;
        font-family: 'Roboto' !important;
        font-style: normal !important;
        font-weight: 700 !important;
        line-height: 120% !important;
      }
      .NameBanner {
        transform-origin: 0% 100%;
        transform: translateX(-100%);
        opacity: 0 !important;
        white-space: nowrap;
        ${u && `
          opacity: 1 !important;
          transform: translateX(0);
        `}
      }

      ls-layout[layout="Presentation"][props*="\\"cover\\"\\:true"] > :first-child .NameBanner {
        top: 0% !important;
        transform: translateY(0%) !important;
        margin: ${g(20)} ${g(20)};
      }


      .NameBanner[data-size="4"] {
        padding: ${g(40)} ${g(80)} ${g(40)} ${g(80)} !important;
        font-size: ${g(40)} !important;
      }
      .NameBanner[data-size="3"] {
        padding: ${g(12)} ${g(30)} ${g(12)} ${g(30)} !important;
        font-size: ${g(40)} !important;
        margin: -${g(20)} ${g(20)};
      }
      .NameBanner[data-size="2"] {
        padding: ${g(12)} ${g(30)} ${g(12)} ${g(30)} !important;
        font-size: ${g(26)} !important;
        margin: -${g(8)} ${g(8)};
      }
      .NameBanner[data-size="1"], .NameBanner[data-size="0"] {
        padding: ${g(8)} ${g(16)} ${g(8)} ${g(16)} !important;
        font-size: ${g(18)} !important;
        border-width: ${g(2)} !important;
        margin: -${g(16)} ${g(8)};
      }
      .NameBanner[data-size="0"] {
        opacity: 0 !important;
        transform: translateX(-100%);
      }
    `;
  }
}, iconStyles = {
  twitch: {
    icon: "Twitch"
  },
  youtube: {
    icon: "YouTube"
  },
  facebook: {
    icon: "Facebook"
  }
}, fixLink = (a) => !a.startsWith("http:") && !a.startsWith("https:") ? `https://${a}` : a, ChatOverlay = {
  name: "LS-ChatOverlay",
  sourceType: "ChatOverlay",
  create({
    onUpdate: a,
    onEvent: u
  }, c) {
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId), S = v.compositor.getRoot(), {
      x: g
    } = S.props.size, E = (g ?? 1280) / 1920, _ = (q) => q * E + "px";
    let k;
    const L = (q, G) => {
      const H = q.width / G.width;
      return q.height / G.height >= 0.25 && H >= 0.75 ? 4 : H >= 0.75 ? 1 : H >= 0.5 ? -2 : H > 0.25 ? -3 : -4;
    };
    CoreContext.onInternal("ProjectChanged", () => {
      const {
        bannerStyle: q
      } = v.props ?? {};
      q && V({
        ...k,
        metadata: {
          ...k.metadata,
          bannerStyle: q
        }
      });
    });
    const M = React.memo((q) => {
      var G, H, B;
      return (q == null ? void 0 : q.type) === "emoticon" && ((G = q == null ? void 0 : q.data) == null ? void 0 : G.type) === "direct" ? /* @__PURE__ */ React.createElement("img", {
        src: (H = q == null ? void 0 : q.data) == null ? void 0 : H.url,
        style: {
          height: _(36)
        },
        alt: q == null ? void 0 : q.text
      }) : (q == null ? void 0 : q.type) === "link" ? /* @__PURE__ */ React.createElement("a", {
        style: {
          color: "#FFF",
          wordBreak: "break-all"
        },
        target: "_blank",
        rel: "noreferrer",
        href: fixLink((B = q == null ? void 0 : q.data) == null ? void 0 : B.url)
      }, q == null ? void 0 : q.text) : /* @__PURE__ */ React.createElement("span", null, q == null ? void 0 : q.text);
    }), $ = (q) => {
      const G = {
        height: `${q.height}`,
        width: `${q.width}`,
        background: q.background || "transparent",
        display: "inline-block",
        verticalAlign: "middle",
        borderRadius: "50%",
        fontSize: `${q.fontSize}`
      };
      return /* @__PURE__ */ React.createElement("div", {
        style: {
          ...G,
          position: "relative",
          marginRight: q == null ? void 0 : q.marginRight
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          left: "50%",
          position: "absolute",
          top: "50%",
          transform: "translate(-50%, -50%)"
        }
      }, q.username.substring(0, 2).toUpperCase()));
    }, J = (q) => {
      const {
        message: G,
        id: H,
        username: B,
        metadata: Y
      } = q || {}, [ne, Z] = useState(0), {
        index: re,
        platform: oe,
        avatar: de,
        bannerStyle: A
      } = Y || {}, N = useMemo(() => iconStyles[oe], [oe]), D = useRef();
      return useLayoutEffect(() => {
        if (!D.current)
          return;
        const W = () => {
          const ae = D.current;
          ae && Z(L({
            width: ae.clientWidth,
            height: ae.clientHeight
          }, {
            width: v.compositor.getRoot().props.size.x,
            height: v.compositor.getRoot().props.size.y
          }));
        }, ee = new ResizeObserver((ae) => {
          W();
        });
        return W(), ee.observe(D.current), () => {
          D != null && D.current && ee.unobserve(D == null ? void 0 : D.current);
        };
      }, [D.current, v]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: `${H}_${re}`,
        type: "chatoverlay",
        enter: APIKitAnimationTypes.SLIDE_IN_LEFT,
        exit: APIKitAnimationTypes.SLIDE_OUT_LEFT,
        duration: 200
      }, /* @__PURE__ */ React.createElement("div", {
        className: "ChatOverlayContainer",
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "row",
          justifyContent: "flex-start",
          alignItems: "flex-end",
          marginLeft: A !== BannerStyle.BUBBLE ? "5%" : "0px"
        }
      }, A !== BannerStyle.BUBBLE ? (
        /* It's a ternary operator. If the style is not equal to BannerStyle.BUBBLE.toString(), then it will
        render the first div. Otherwise, it will render the second div. */
        /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%",
            display: "flex"
          }
        }, de ? /* @__PURE__ */ React.createElement("span", {
          style: {
            marginRight: "20px"
          }
        }, /* @__PURE__ */ React.createElement("img", {
          src: de,
          className: "ChatOverlay-avatar"
        })) : /* @__PURE__ */ React.createElement($, {
          height: _(110),
          width: _(120),
          background: primary(500),
          username: B,
          marginRight: 20,
          fontSize: _(30)
        }), /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%"
          }
        }, B && /* @__PURE__ */ React.createElement("button", {
          className: "ChatOverlay-badge-container"
        }, (N == null ? void 0 : N.icon) && /* @__PURE__ */ React.createElement(Icon$1, {
          className: "ChatOverlay-badge-icon",
          name: N == null ? void 0 : N.icon
        }), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-badge-username"
        }, B)), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay",
          style: {
            padding: 10,
            background: "orange",
            width: "fit-content",
            height: "fit-content",
            maxWidth: "84%",
            position: "relative"
          }
        }, G && /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-body",
          style: {
            gap: 10,
            display: "flex",
            alignItems: "center",
            flexWrap: "wrap",
            verticalAlign: "middle"
          }
        }, G.map((W, ee) => /* @__PURE__ */ React.createElement(M, {
          key: ee,
          ...W
        }))))))
      ) : (
        /* It's a ternary operator. If the style is not equal to BannerStyle.BUBBLE.toString(), then it will
        render the first div. Otherwise, it will render the second div. */
        /* @__PURE__ */ React.createElement("div", {
          style: {
            width: "100%",
            display: "flex"
          }
        }, /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay",
          style: {
            padding: 10,
            background: "orange",
            width: "fit-content",
            height: "fit-content",
            maxWidth: "84%",
            position: "relative"
          }
        }, /* @__PURE__ */ React.createElement("div", {
          style: {
            display: "flex",
            marginTop: `-${_(160)}`,
            alignItems: "flex-end",
            padding: `${_(14)} ${_(0)} ${_(14)} ${_(0)}`,
            marginLeft: `${ne * 10}px`
          }
        }, de ? /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlayAvatar-container"
        }, /* @__PURE__ */ React.createElement("img", {
          src: de,
          className: "ChatOverlay-avatar"
        })) : /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlayAvatar-container"
        }, /* @__PURE__ */ React.createElement($, {
          height: _(120),
          width: _(120),
          background: primary(500),
          username: B,
          fontSize: _(30)
        })), B && /* @__PURE__ */ React.createElement("button", {
          className: "ChatOverlay-badge-container"
        }, (N == null ? void 0 : N.icon) && /* @__PURE__ */ React.createElement(Icon$1, {
          className: "ChatOverlay-badge-icon",
          name: N == null ? void 0 : N.icon
        }), /* @__PURE__ */ React.createElement("div", {
          className: "ChatOverlay-badge-username"
        }, B))), G && /* @__PURE__ */ React.createElement("div", {
          ref: D,
          className: "ChatOverlay-body",
          style: {
            gap: 10,
            alignItems: "center",
            flexWrap: "wrap",
            verticalAlign: "middle"
          }
        }, G.map((W, ee) => /* @__PURE__ */ React.createElement(M, {
          key: ee,
          ...W
        })))))
      )));
    }, V = (q) => ReactDOM.render(/* @__PURE__ */ React.createElement(J, {
      ...q
    }), l);
    return a((q) => {
      const {
        bannerStyle: G = BannerStyle.DEFAULT
      } = v.props ?? {};
      k = {
        ...q,
        metadata: {
          ...q.metadata,
          bannerStyle: G
        }
      }, V(k);
    }), {
      root: l
    };
  }
}, Background$1 = {
  name: "LS-Background",
  sourceType: "Background",
  create({
    onUpdate: a,
    onRemove: u
  }, {
    sourceProps: c
  }) {
    u(() => {
      clearInterval(S);
    });
    const l = document.createElement("div"), v = getProject(CoreContext.state.activeProjectId).role;
    let S;
    const g = ({
      source: L,
      setStartAnimation: M
    }) => {
      var de, A;
      const {
        src: $,
        type: J,
        meta: V,
        loop: q
      } = (L == null ? void 0 : L.sourceProps) || {}, {
        id: G,
        sourceType: H
      } = L || {}, [B, Y] = React.useState(null), ne = React.useRef(null);
      console.log("Updated current time", (de = ne == null ? void 0 : ne.current) == null ? void 0 : de.currentTime);
      const Z = React.useCallback((N) => {
        ne.current = N, Y(N ? N.id : null);
      }, []), re = React.useCallback(() => {
        ne != null && ne.current && ne.current.play().catch(() => {
          var N;
          ne.current.muted = !0, (N = ne.current) == null || N.play();
        });
      }, [$]), oe = React.useCallback(() => {
        S && clearInterval(S), hasPermission(v, Permission.UpdateProject) && trigger$1("VideoEnded", {
          id: G,
          category: J
        });
      }, [$]);
      return React.useEffect(() => {
        V && (ne != null && ne.current) && B && hasPermission(v, Permission.ManageSelf) && V != null && V.time && (ne.current.currentTime = Number(V == null ? void 0 : V.time));
      }, [V == null ? void 0 : V.time, B]), React.useEffect(() => () => {
        S && clearInterval(S);
      }, [G]), React.useEffect(() => {
        B ? ne.current && (ne.current.src = $, ne.current.play().catch(() => {
          ne.current.muted = !0, ne.current.play();
        }), hasPermission(v, Permission.UpdateProject) && (S = setInterval(() => {
          if (ne.current.duration) {
            const N = ne.current.duration - ne.current.currentTime;
            trigger$1("VideoTimeUpdate", {
              category: H,
              id: G,
              time: Math.floor(N)
            });
          }
        }, 1e3))) : S && clearInterval(S);
      }, [B]), /* @__PURE__ */ React.createElement(React.Fragment, {
        key: G
      }, $ && /* @__PURE__ */ React.createElement("video", {
        loop: q,
        id: G,
        ref: Z,
        style: {
          ...(A = c == null ? void 0 : c.meta) == null ? void 0 : A.style,
          ...V.style
        },
        onLoadedData: re,
        onEnded: oe,
        onCanPlay: () => M(!0)
      }));
    }, E = ({
      source: L,
      setStartAnimation: M
    }) => {
      var G;
      const {
        src: $,
        meta: J,
        type: V
      } = (L == null ? void 0 : L.sourceProps) || {}, {
        id: q
      } = L || {};
      return /* @__PURE__ */ React.createElement(React.Fragment, {
        key: q
      }, $ && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...(G = c == null ? void 0 : c.meta) == null ? void 0 : G.style,
          ...J == null ? void 0 : J.style
        },
        src: $,
        onLoad: () => M(!0)
      }));
    }, _ = ({
      source: L
    }) => {
      const {
        type: M
      } = L.sourceProps, {
        id: $
      } = L || {}, [J, V] = React.useState(!1);
      return useEffect(() => {
        V(!1);
      }, [$]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: $,
        type: "background",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: J ? 1 : 0
        },
        className: "backgroundContainer background-transition"
      }, $ && M === "image" && /* @__PURE__ */ React.createElement(E, {
        source: L,
        setStartAnimation: V
      }), $ && M === "video" && /* @__PURE__ */ React.createElement(g, {
        source: L,
        setStartAnimation: V
      })));
    }, k = (L) => ReactDOM.render(/* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(_, {
      source: L
    })), l);
    return a((L) => {
      k({
        ...L
      });
    }), {
      root: l
    };
  }
}, SourceTriggerMap = [{
  sourceType: "Overlay",
  trigger: "OverlayMetadataUpdate"
}, {
  sourceType: "Background",
  trigger: "BackgroundMetadataUpdate"
}], Video2 = {
  name: "LS-Video-2",
  sourceType: "Video2",
  props: {
    id: {
      type: String,
      required: !0
    }
  },
  useSource(a, u) {
    return a.find((c) => c.props.type === u.id);
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    c(() => {
      clearInterval(_);
    });
    const v = document.createElement("div"), S = getProjectRoom(CoreContext.state.activeProjectId), g = getProject(CoreContext.state.activeProjectId).role;
    let E, _;
    const k = ({
      source: M
    }) => {
      var N;
      const $ = SourceTriggerMap.find((D) => D.sourceType === l.proxySource), {
        src: J,
        type: V,
        meta: q,
        loop: G
      } = (M == null ? void 0 : M.value) || {}, {
        id: H
      } = M || {}, [B, Y] = React.useState(null), ne = React.useRef(null), [Z, re] = React.useState(!1);
      console.log("Updated current time", (N = ne == null ? void 0 : ne.current) == null ? void 0 : N.currentTime), React.useEffect(() => {
        re(!1);
      }, [H]);
      const oe = React.useCallback((D) => {
        ne.current = D, Y(D ? D.id : null);
      }, []), de = React.useCallback(() => {
        ne != null && ne.current && ne.current.play().catch(() => {
          var D;
          ne.current.muted = !0, (D = ne.current) == null || D.play();
        });
      }, [J]), A = React.useCallback(() => {
        _ && clearInterval(_), trigger$1("VideoEnded", {
          id: H,
          category: V
        });
      }, [J]);
      return React.useEffect(() => {
        q && (ne != null && ne.current) && B && hasPermission(g, Permission.ManageSelf) && (ne.current.currentTime = Number(q == null ? void 0 : q.time));
      }, [q == null ? void 0 : q.time, B]), React.useEffect(() => () => {
        _ && clearInterval(_);
      }, [H]), React.useEffect(() => {
        if (!B)
          _ && clearInterval(_);
        else if (ne.current)
          return ne.current.src = J, G && (ne.current.loop = !!G), ne.current.play().catch(() => {
            ne.current.muted = !0, ne.current.play();
          }), _ = setInterval(() => {
            if (ne.current.duration) {
              const D = ne.current.duration - ne.current.currentTime;
              trigger$1("VideoTimeUpdate", {
                category: V,
                id: H,
                time: Math.floor(D)
              });
            }
          }, 1e3), S == null ? void 0 : S.onData((D, W) => {
            var ee, ae;
            (ee = ne == null ? void 0 : ne.current) != null && ee.currentTime && D.type === "UserJoined" && hasPermission(g, Permission.ManageGuests) && triggerInternal$1($.trigger, {
              projectId: CoreContext.state.activeProjectId,
              role: g,
              sourceId: B,
              doTrigger: !0,
              metadata: {
                time: Math.floor((ae = ne == null ? void 0 : ne.current) == null ? void 0 : ae.currentTime) || 0,
                owner: S == null ? void 0 : S.participantId,
                guest: W
              }
            });
          });
      }, [B]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: H,
        type: "video",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: Z ? 1 : 0,
          width: "100%",
          height: "100%"
        },
        className: "video-transition"
      }, J && /* @__PURE__ */ React.createElement("video", {
        id: H,
        ref: oe,
        style: l.style,
        ...l.props,
        onLoadedData: de,
        onEnded: A,
        onCanPlayThrough: () => re(!0)
      })));
    }, L = () => ReactDOM.render(/* @__PURE__ */ React.createElement(k, {
      source: E
    }), v);
    return a(() => {
      L();
    }), u((M) => {
      E = M, L();
    }), {
      root: v
    };
  }
}, Image2 = {
  name: "LS-Image-2",
  sourceType: "Image2",
  props: {
    id: {
      type: String,
      required: !0
    }
  },
  useSource(a, u) {
    return a.find((c) => c.props.type === u.id);
  },
  create({
    onUpdate: a,
    onNewSource: u
  }, c) {
    const l = document.createElement("div");
    let v;
    const S = ({
      source: E
    }) => {
      const {
        src: _,
        meta: k
      } = (E == null ? void 0 : E.value) || {}, {
        id: L
      } = E || {}, [M, $] = React.useState(!1);
      return React.useEffect(() => {
        $(!1);
      }, [L]), /* @__PURE__ */ React.createElement(APIKitAnimation$1, {
        id: L,
        type: "image",
        enter: APIKitAnimationTypes.FADE_IN,
        exit: APIKitAnimationTypes.FADE_OUT,
        duration: 400
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          opacity: M ? 1 : 0,
          width: "100%",
          height: "100%"
        },
        className: "image-transition"
      }, _ && /* @__PURE__ */ React.createElement("img", {
        style: {
          ...c == null ? void 0 : c.style,
          ...k == null ? void 0 : k.style
        },
        src: _,
        onLoad: () => $(!0)
      })));
    }, g = () => ReactDOM.render(/* @__PURE__ */ React.createElement(S, {
      source: v
    }), l);
    return a(() => {
      g();
    }), u((E) => {
      v = E, g();
    }), {
      root: l
    };
  }
}, RTMPSource = {
  name: "LS-RTMP-Source",
  sourceType: "RTMP",
  props: {},
  useSource(a, u) {
    return a.find((c) => isMatch(c.props, u.sourceProps));
  },
  create({
    onUpdate: a,
    onNewSource: u,
    onRemove: c
  }, l) {
    const v = document.createElement("div"), S = getProject(CoreContext.state.activeProjectId);
    getProjectRoom(CoreContext.state.activeProjectId), Object.assign(v.style, {
      position: "relative"
    });
    let g, E = l;
    const _ = (M, $) => {
      const J = M / $.width;
      return J >= 0.5 ? 3 : J > 0.25 ? 2 : J > 0.15 ? 1 : 0;
    }, k = ({
      props: M,
      source: $
    }) => {
      var ne, Z;
      const J = useRef(), {
        volume: V = 1,
        isHidden: q = !1
      } = M || {}, [G, H] = useState(0), B = M == null ? void 0 : M.isMuted, Y = !(M != null && M.isHidden) && ((ne = $ == null ? void 0 : $.props) == null ? void 0 : ne.videoEnabled);
      return useEffect(() => {
        J.current && (J.current.play().catch((re) => {
          document.addEventListener("click", () => {
            var oe;
            return (oe = J.current) == null ? void 0 : oe.play();
          }, {
            once: !0
          });
        }), $ != null && $.value && ($ == null ? void 0 : $.value) !== J.current.srcObject ? J.current.srcObject = $ == null ? void 0 : $.value : $ != null && $.value || (J.current.srcObject = null));
      }, [J.current, $ == null ? void 0 : $.value]), useEffect(() => {
        !M && J.current && (J.current.srcObject = null, J.current = null);
      }, [M]), useLayoutEffect(() => {
        if (!J.current)
          return;
        const re = () => {
          const de = J.current;
          de && H(_(de.clientWidth, {
            width: S.compositor.getRoot().props.size.x,
            height: S.compositor.getRoot().props.size.y
          }));
        }, oe = new ResizeObserver((de) => {
          re();
        });
        return re(), oe == null || oe.observe(J.current), () => {
          J.current && (oe == null || oe.unobserve(J.current), J.current.srcObject = null);
        };
      }, [J.current, S]), useEffect(() => {
        J.current && (J.current.volume = V);
      }, [J.current, V]), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        style: {
          background: "#222",
          position: "absolute",
          height: "100%",
          width: "100%",
          fontSize: "43px",
          color: "rgba(255,255,255,0.6)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          opacity: Y ? "0" : "1"
        }
      }, !!$ && /* @__PURE__ */ React.createElement("div", {
        style: {
          borderRadius: "50%",
          background: "#555",
          width: "70px",
          height: "70px",
          textTransform: "uppercase",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          lineHeight: "1em"
        }
      }, "RTMP")), /* @__PURE__ */ React.createElement("div", {
        style: {
          position: "relative",
          display: "flex",
          height: "100%",
          width: "100%",
          ...!!((Z = $ == null ? void 0 : $.props) != null && Z.mirrored) && {
            transform: "scaleX(-1)"
          }
        }
      }, /* @__PURE__ */ React.createElement("video", {
        ref: J,
        autoPlay: !0,
        muted: B,
        disablePictureInPicture: !0,
        playsInline: !0,
        style: {
          left: "50%",
          top: "50%",
          position: "relative",
          transform: "translate3d(-50%, -50%, 0)",
          height: "100%",
          opacity: Y ? "1" : "0",
          objectFit: "cover",
          background: "rgba(0,0,0,0.6)"
        }
      })), !!($ != null && $.props.displayName) && /* @__PURE__ */ React.createElement("div", {
        className: "NameBannerContainer",
        style: {
          width: "100%",
          height: "100%",
          position: "absolute"
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner",
        "data-size": G,
        style: {
          padding: "12px 30px",
          width: "fit-content",
          height: "fit-content",
          top: "100%",
          transform: "translateY(-100%)",
          left: 0
        }
      }, /* @__PURE__ */ React.createElement("div", {
        className: "NameBanner-body"
      }, $ == null ? void 0 : $.props.displayName))));
    }, L = () => ReactDOM.render(/* @__PURE__ */ React.createElement(k, {
      source: g,
      props: E
    }), v);
    return a((M) => {
      E = M, L();
    }), u((M) => {
      g = M, L();
    }), c((M) => {
      E = M, L();
    }), {
      root: v
    };
  }
}, Transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Background: Background$1,
  Banner: Banner$1,
  ChatOverlay,
  Element: Element$1,
  Image: Image$1,
  Image2,
  Logo: Logo$1,
  Overlay,
  RTMPSource,
  RoomParticipant: RoomParticipant$1,
  Square,
  Video,
  Video2
}, Symbol.toStringTag, { value: "Module" }));
/*! (c) Andrea Giammarchi - ISC */
var self$1 = {};
try {
  self$1.WeakMap = WeakMap;
} catch (a) {
  self$1.WeakMap = function(u, c) {
    var l = c.defineProperty, v = c.hasOwnProperty, S = g.prototype;
    return S.delete = function(_) {
      return this.has(_) && delete _[this._];
    }, S.get = function(_) {
      return this.has(_) ? _[this._] : void 0;
    }, S.has = function(_) {
      return v.call(_, this._);
    }, S.set = function(_, k) {
      return l(_, this._, { configurable: !0, value: k }), this;
    }, g;
    function g(_) {
      l(this, "_", { value: "_@ungap/weakmap" + u++ }), _ && _.forEach(E, this);
    }
    function E(_) {
      this.set(_[0], _[1]);
    }
  }(Math.random(), Object);
}
const WeakMap$1 = self$1.WeakMap;
/*! (c) Andrea Giammarchi - ISC */
var UID = "-" + Math.random().toFixed(6) + "%", UID_IE = !1;
try {
  (function(a, u, c) {
    return u in a && (a.innerHTML = "<p " + c + '="' + UID + '"></p>', a[u].childNodes[0].getAttribute(c) == UID);
  })(document.createElement("template"), "content", "tabindex") || (UID = "_dt: " + UID.slice(1, -1) + ";", UID_IE = !0);
} catch (a) {
}
var UIDC = "<!--" + UID + "-->", COMMENT_NODE = 8, ELEMENT_NODE$1 = 1, TEXT_NODE = 3, SHOULD_USE_TEXT_CONTENT = /^(?:plaintext|script|style|textarea|title|xmp)$/i, VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
/*! (c) Andrea Giammarchi - ISC */
function domsanitizer(a) {
  return a.join(UIDC).replace(selfClosing, fullClosing).replace(attrSeeker, attrReplacer);
}
var spaces = " \\f\\n\\r\\t", almostEverything = "[^" + spaces + `\\/>"'=]+`, attrName = "[" + spaces + "]+" + almostEverything, tagName = "<([A-Za-z]+[A-Za-z0-9:._-]*)((?:", attrPartials = `(?:\\s*=\\s*(?:'[^']*?'|"[^"]*?"|<[^>]*?>|` + almostEverything.replace("\\/", "") + "))?)", attrSeeker = new RegExp(tagName + attrName + attrPartials + "+)([" + spaces + "]*/?>)", "g"), selfClosing = new RegExp(tagName + attrName + attrPartials + "*)([" + spaces + "]*/>)", "g"), findAttributes = new RegExp("(" + attrName + `\\s*=\\s*)(['"]?)` + UIDC + "\\2", "gi");
function attrReplacer(a, u, c, l) {
  return "<" + u + c.replace(findAttributes, replaceAttributes) + l;
}
function replaceAttributes(a, u, c) {
  return u + (c || '"') + UID + (c || '"');
}
function fullClosing(a, u, c) {
  return VOID_ELEMENTS.test(u) ? a : "<" + u + c + "></" + u + ">";
}
const { isArray } = Array, { indexOf, slice } = [], umap = (a) => ({
  // About: get: _.get.bind(_)
  // It looks like WebKit/Safari didn't optimize bind at all,
  // so that using bind slows it down by 60%.
  // Firefox and Chrome are just fine in both cases,
  // so let's use the approach that works fast everywhere 👍
  get: (u) => a.get(u),
  set: (u, c) => (a.set(u, c), c)
}), ELEMENT_NODE = 1, nodeType = 111, remove = ({ firstChild: a, lastChild: u }) => {
  const c = document.createRange();
  return c.setStartAfter(a), c.setEndAfter(u), c.deleteContents(), a;
}, diffable = (a, u) => a.nodeType === nodeType ? 1 / u < 0 ? u ? remove(a) : a.lastChild : u ? a.valueOf() : a.firstChild : a, persistent = (a) => {
  const { childNodes: u } = a, { length: c } = u;
  if (c < 2)
    return c ? u[0] : a;
  const l = slice.call(u, 0), v = l[0], S = l[c - 1];
  return {
    ELEMENT_NODE,
    nodeType,
    firstChild: v,
    lastChild: S,
    valueOf() {
      if (u.length !== c) {
        let g = 0;
        for (; g < c; )
          a.appendChild(l[g++]);
      }
      return a;
    }
  };
};
/*! (c) Andrea Giammarchi - ISC */
var createContent = function(a) {
  var u = "fragment", c = "template", l = "content" in g(c), v = l ? function(_) {
    var k = g(c);
    return k.innerHTML = _, k.content;
  } : function(_) {
    var k = g(u), L = g(c), M = null;
    if (/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(_)) {
      var $ = RegExp.$1;
      L.innerHTML = "<table>" + _ + "</table>", M = L.querySelectorAll($);
    } else
      L.innerHTML = _, M = L.childNodes;
    return S(k, M), k;
  };
  return function(k, L) {
    return (L === "svg" ? E : v)(k);
  };
  function S(_, k) {
    for (var L = k.length; L--; )
      _.appendChild(k[0]);
  }
  function g(_) {
    return _ === u ? a.createDocumentFragment() : a.createElementNS("http://www.w3.org/1999/xhtml", _);
  }
  function E(_) {
    var k = g(u), L = g("div");
    return L.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + _ + "</svg>", S(k, L.firstChild.childNodes), k;
  }
}(document);
const udomdiff = (a, u, c, l, v) => {
  const S = c.length;
  let g = u.length, E = S, _ = 0, k = 0, L = null;
  for (; _ < g || k < E; )
    if (g === _) {
      const M = E < S ? k ? l(c[k - 1], -0).nextSibling : l(c[E - k], 0) : v;
      for (; k < E; )
        a.insertBefore(l(c[k++], 1), M);
    } else if (E === k)
      for (; _ < g; )
        (!L || !L.has(u[_])) && a.removeChild(l(u[_], -1)), _++;
    else if (u[_] === c[k])
      _++, k++;
    else if (u[g - 1] === c[E - 1])
      g--, E--;
    else if (u[_] === c[E - 1] && c[k] === u[g - 1]) {
      const M = l(u[--g], -1).nextSibling;
      a.insertBefore(
        l(c[k++], 1),
        l(u[_++], -1).nextSibling
      ), a.insertBefore(l(c[--E], 1), M), u[g] = c[E];
    } else {
      if (!L) {
        L = /* @__PURE__ */ new Map();
        let M = k;
        for (; M < E; )
          L.set(c[M], M++);
      }
      if (L.has(u[_])) {
        const M = L.get(u[_]);
        if (k < M && M < E) {
          let $ = _, J = 1;
          for (; ++$ < g && $ < E && L.get(u[$]) === M + J; )
            J++;
          if (J > M - k) {
            const V = l(u[_], 0);
            for (; k < M; )
              a.insertBefore(l(c[k++], 1), V);
          } else
            a.replaceChild(
              l(c[k++], 1),
              l(u[_++], -1)
            );
        } else
          _++;
      } else
        a.removeChild(l(u[_++], -1));
    }
  return c;
};
/*! (c) Andrea Giammarchi - ISC */
var importNode = function(a, u, c, l, v) {
  var S = v in a, g = a.createDocumentFragment();
  g[u](a[l]("g")), g[u](a[l](""));
  var E = S ? a[v](g, !0) : g[c](!0);
  return E.childNodes.length < 2 ? function _(k, L) {
    for (var M = k[c](), $ = k.childNodes || [], J = $.length, V = 0; L && V < J; V++)
      M[u](_($[V], L));
    return M;
  } : (
    /* istanbul ignore next */
    S ? a[v] : function(_, k) {
      return _[c](!!k);
    }
  );
}(
  document,
  "appendChild",
  "cloneNode",
  "createTextNode",
  "importNode"
), trim = "".trim || /* istanbul ignore next */
function() {
  return String(this).replace(/^\s+|\s+/g, "");
}, normalizeAttributes = UID_IE ? function(a, u) {
  var c = u.join(" ");
  return u.slice.call(a, 0).sort(function(l, v) {
    return c.indexOf(l.name) <= c.indexOf(v.name) ? -1 : 1;
  });
} : function(a, u) {
  return u.slice.call(a, 0);
};
function find(a, u) {
  for (var c = u.length, l = 0; l < c; )
    a = a.childNodes[u[l++]];
  return a;
}
function parse(a, u, c, l) {
  for (var v = a.childNodes, S = v.length, g = 0; g < S; ) {
    var E = v[g];
    switch (E.nodeType) {
      case ELEMENT_NODE$1:
        var _ = l.concat(g);
        parseAttributes(E, u, c, _), parse(E, u, c, _);
        break;
      case COMMENT_NODE:
        var k = E.textContent;
        if (k === UID)
          c.shift(), u.push(
            // basicHTML or other non standard engines
            // might end up having comments in nodes
            // where they shouldn't, hence this check.
            SHOULD_USE_TEXT_CONTENT.test(a.nodeName) ? Text(a, l) : Any(E, l.concat(g))
          );
        else
          switch (k.slice(0, 2)) {
            case "/*":
              if (k.slice(-2) !== "*/")
                break;
            case "👻":
              a.removeChild(E), g--, S--;
          }
        break;
      case TEXT_NODE:
        SHOULD_USE_TEXT_CONTENT.test(a.nodeName) && trim.call(E.textContent) === UIDC && (c.shift(), u.push(Text(a, l)));
        break;
    }
    g++;
  }
}
function parseAttributes(a, u, c, l) {
  for (var v = a.attributes, S = [], g = [], E = normalizeAttributes(v, c), _ = E.length, k = 0; k < _; ) {
    var L = E[k++], M = L.value === UID, $;
    if (M || 1 < ($ = L.value.split(UIDC)).length) {
      var J = L.name;
      if (S.indexOf(J) < 0) {
        S.push(J);
        var V = c.shift().replace(
          M ? /^(?:|[\S\s]*?\s)(\S+?)\s*=\s*('|")?$/ : new RegExp(
            "^(?:|[\\S\\s]*?\\s)(" + J + `)\\s*=\\s*('|")[\\S\\s]*`,
            "i"
          ),
          "$1"
        ), q = v[V] || // the following ignore is covered by browsers
        // while basicHTML is already case-sensitive
        /* istanbul ignore next */
        v[V.toLowerCase()];
        if (M)
          u.push(Attr(q, l, V, null));
        else {
          for (var G = $.length - 2; G--; )
            c.shift();
          u.push(Attr(q, l, V, $));
        }
      }
      g.push(L);
    }
  }
  _ = g.length, k = 0;
  for (var H = 0 < _ && UID_IE && !("ownerSVGElement" in a); k < _; ) {
    var B = g[k++];
    H && (B.value = ""), a.removeAttribute(B.name);
  }
  var Y = a.nodeName;
  if (/^script$/i.test(Y)) {
    var ne = document.createElement(Y);
    for (_ = v.length, k = 0; k < _; )
      ne.setAttributeNode(v[k++].cloneNode(!0));
    ne.textContent = a.textContent, a.parentNode.replaceChild(ne, a);
  }
}
function Any(a, u) {
  return {
    type: "any",
    node: a,
    path: u
  };
}
function Attr(a, u, c, l) {
  return {
    type: "attr",
    node: a,
    path: u,
    name: c,
    sparse: l
  };
}
function Text(a, u) {
  return {
    type: "text",
    node: a,
    path: u
  };
}
var parsed = umap(new WeakMap$1());
function createInfo(a, u) {
  var c = (a.convert || domsanitizer)(u), l = a.transform;
  l && (c = l(c));
  var v = createContent(c, a.type);
  cleanContent(v);
  var S = [];
  return parse(v, S, u.slice(0), []), {
    content: v,
    updates: function(g) {
      for (var E = [], _ = S.length, k = 0, L = 0; k < _; ) {
        var M = S[k++], $ = find(g, M.path);
        switch (M.type) {
          case "any":
            E.push({ fn: a.any($, []), sparse: !1 });
            break;
          case "attr":
            var J = M.sparse, V = a.attribute($, M.name, M.node);
            J === null ? E.push({ fn: V, sparse: !1 }) : (L += J.length - 2, E.push({ fn: V, sparse: !0, values: J }));
            break;
          case "text":
            E.push({ fn: a.text($), sparse: !1 }), $.textContent = "";
            break;
        }
      }
      return _ += L, function() {
        var q = arguments.length;
        if (_ !== q - 1)
          throw new Error(
            q - 1 + " values instead of " + _ + `
` + u.join("${value}")
          );
        for (var G = 1, H = 1; G < q; ) {
          var B = E[G - H];
          if (B.sparse) {
            var Y = B.values, ne = Y[0], Z = 1, re = Y.length;
            for (H += re - 2; Z < re; )
              ne += arguments[G++] + Y[Z++];
            B.fn(ne);
          } else
            B.fn(arguments[G++]);
        }
        return g;
      };
    }
  };
}
function createDetails(a, u) {
  var c = parsed.get(u) || parsed.set(u, createInfo(a, u));
  return c.updates(importNode.call(document, c.content, !0));
}
var empty = [];
function domtagger(a) {
  var u = empty, c = cleanContent;
  return function(l) {
    return u !== l && (c = createDetails(a, u = l)), c.apply(null, arguments);
  };
}
function cleanContent(a) {
  for (var u = a.childNodes, c = u.length; c--; ) {
    var l = u[c];
    l.nodeType !== 1 && trim.call(l.textContent).length === 0 && a.removeChild(l);
  }
}
/*! (c) Andrea Giammarchi - ISC */
var hyperStyle = /* @__PURE__ */ function() {
  var a = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i, u = /([^A-Z])([A-Z]+)/g;
  return function(E, _) {
    return "ownerSVGElement" in E ? l(E, _) : S(E.style, !1);
  };
  function c(g, E, _) {
    return E + "-" + _.toLowerCase();
  }
  function l(g, E) {
    var _;
    return E ? _ = E.cloneNode(!0) : (g.setAttribute("style", "--hyper:style;"), _ = g.getAttributeNode("style")), _.value = "", g.setAttributeNode(_), S(_, !0);
  }
  function v(g) {
    var E, _ = [];
    for (E in g)
      _.push(E.replace(u, c), ":", g[E], ";");
    return _.join("");
  }
  function S(g, E) {
    var _, k;
    return function(L) {
      var M, $, J, V;
      switch (typeof L) {
        case "object":
          if (L) {
            if (_ === "object") {
              if (!E && k !== L)
                for ($ in k)
                  $ in L || (g[$] = "");
            } else
              E ? g.value = "" : g.cssText = "";
            M = E ? {} : g;
            for ($ in L)
              V = L[$], J = typeof V == "number" && !a.test($) ? V + "px" : V, !E && /^--/.test($) ? M.setProperty($, J) : M[$] = J;
            _ = "object", E ? g.value = v(k = M) : k = L;
            break;
          }
        default:
          k != L && (_ = "string", k = L, E ? g.value = L || "" : g.cssText = L || "");
          break;
      }
    };
  }
}();
const aria = (a) => (u) => {
  for (const c in u) {
    const l = c === "role" ? c : `aria-${c}`, v = u[c];
    v == null ? a.removeAttribute(l) : a.setAttribute(l, v);
  }
}, attribute = (a, u) => {
  let c, l = !0;
  const v = document.createAttributeNS(null, u);
  return (S) => {
    c !== S && (c = S, c == null ? l || (a.removeAttributeNode(v), l = !0) : (v.value = S, l && (a.setAttributeNodeNS(v), l = !1)));
  };
}, boolean = (a, u, c) => (l) => {
  c !== !!l && ((c = !!l) ? a.setAttribute(u, "") : a.removeAttribute(u));
}, data = ({ dataset: a }) => (u) => {
  for (const c in u) {
    const l = u[c];
    l == null ? delete a[c] : a[c] = l;
  }
}, event = (a, u) => {
  let c, l = u.slice(2);
  return !(u in a) && u.toLowerCase() in a && (l = l.toLowerCase()), (v) => {
    const S = isArray(v) ? v : [v, !1];
    c !== S[0] && (c && a.removeEventListener(l, c, S[1]), (c = S[0]) && a.addEventListener(l, c, S[1]));
  };
}, ref = (a) => (u) => {
  typeof u == "function" ? u(a) : u.current = a;
}, setter = (a, u) => u === "dataset" ? data(a) : (c) => {
  a[u] = c;
}, hyperProperty = (a, u) => {
  let c;
  return (l) => {
    c !== l && (c = l, a[u] !== l && (l == null ? (a[u] = "", a.removeAttribute(u)) : a[u] = l));
  };
}, readOnly = /^(?:form|list)$/i, text = (a, u) => a.ownerDocument.createTextNode(u);
function Tagger(a) {
  return this.type = a, domtagger(this);
}
Tagger.prototype = {
  // there are four kind of attributes, and related behavior:
  //  * events, with a name starting with `on`, to add/remove event listeners
  //  * special, with a name present in their inherited prototype, accessed directly
  //  * regular, accessed through get/setAttribute standard DOM methods
  //  * style, the only regular attribute that also accepts an object as value
  //    so that you can style=${{width: 120}}. In this case, the behavior has been
  //    fully inspired by Preact library and its simplicity.
  attribute(a, u, c) {
    const l = this.type === "svg";
    switch (u) {
      case "class":
        if (l)
          return attribute(a, u);
        u = "className";
      case "props":
        return setter(a, u);
      case "aria":
        return aria(a);
      case "style":
        return hyperStyle(a, c, l);
      case "ref":
        return ref(a);
      case ".dataset":
        return data(a);
      default:
        return u.slice(0, 1) === "." ? setter(a, u.slice(1)) : u.slice(0, 1) === "?" ? boolean(a, u.slice(1)) : u.slice(0, 2) === "on" ? event(a, u) : u in a && !(l || readOnly.test(u)) ? hyperProperty(a, u) : attribute(a, u);
    }
  },
  // in a hyper(node)`<div>${content}</div>` case
  // everything could happen:
  //  * it's a JS primitive, stored as text
  //  * it's null or undefined, the node should be cleaned
  //  * it's a promise, update the content once resolved
  //  * it's an explicit intent, perform the desired operation
  //  * it's an Array, resolve all values if Promises and/or
  //    update the node with the resulting list of content
  any(a, u) {
    const { type: c } = this;
    let l = !1, v;
    const S = (g) => {
      switch (typeof g) {
        case "string":
        case "number":
        case "boolean":
          l ? v !== g && (v = g, u[0].textContent = g) : (l = !0, v = g, u = udomdiff(
            a.parentNode,
            u,
            [text(a, g)],
            diffable,
            a
          ));
          break;
        case "function":
          S(g(a));
          break;
        case "object":
        case "undefined":
          if (g == null) {
            l = !1, u = udomdiff(
              a.parentNode,
              u,
              [],
              diffable,
              a
            );
            break;
          }
        default:
          if (l = !1, v = g, isArray(g))
            if (g.length === 0)
              u.length && (u = udomdiff(
                a.parentNode,
                u,
                [],
                diffable,
                a
              ));
            else
              switch (typeof g[0]) {
                case "string":
                case "number":
                case "boolean":
                  S(String(g));
                  break;
                case "function":
                  S(g.map(invoke, a));
                  break;
                case "object":
                  isArray(g[0]) && (g = g.concat.apply([], g));
                default:
                  u = udomdiff(
                    a.parentNode,
                    u,
                    g,
                    diffable,
                    a
                  );
                  break;
              }
          else
            "ELEMENT_NODE" in g ? u = udomdiff(
              a.parentNode,
              u,
              g.nodeType === 11 ? slice.call(g.childNodes) : [g],
              diffable,
              a
            ) : "text" in g ? S(String(g.text)) : "any" in g ? S(g.any) : "html" in g ? u = udomdiff(
              a.parentNode,
              u,
              slice.call(
                createContent(
                  [].concat(g.html).join(""),
                  c
                ).childNodes
              ),
              diffable,
              a
            ) : "length" in g && S(slice.call(g));
          break;
      }
    };
    return S;
  },
  // style or textareas don't accept HTML as content
  // it's pointless to transform or analyze anything
  // different from text there but it's worth checking
  // for possible defined intents.
  text(a) {
    let u;
    const c = (l) => {
      if (u !== l) {
        u = l;
        const v = typeof l;
        v === "object" && l ? "text" in l ? c(String(l.text)) : "any" in l ? c(l.any) : "html" in l ? c([].concat(l.html).join("")) : "length" in l && c(slice.call(l).join("")) : v === "function" ? c(l(a)) : a.textContent = l ?? "";
      }
    };
    return c;
  }
};
function invoke(a) {
  return a(this);
}
const { create: create$1, freeze, keys } = Object, cache = umap(new WeakMap$1()), createRender = (a) => ({
  html: outer("html", a),
  svg: outer("svg", a),
  render(u, c) {
    const l = typeof c == "function" ? c() : c, v = cache.get(u) || cache.set(u, createCache()), S = l instanceof LighterHole ? unroll(a, v, l) : l;
    return S !== v.wire && (v.wire = S, u.textContent = "", u.appendChild(S.valueOf())), u;
  }
}), createCache = () => ({ stack: [], entry: null, wire: null }), outer = (a, u) => {
  const c = umap(new WeakMap$1()), l = (S) => function() {
    return unroll(u, S, v.apply(null, arguments));
  };
  return v.for = (S, g) => {
    const E = c.get(S) || c.set(S, create$1(null));
    return E[g] || (E[g] = l(createCache()));
  }, v.node = function() {
    return unroll(
      u,
      createCache(),
      v.apply(null, arguments)
    ).valueOf();
  }, v;
  function v() {
    return new LighterHole(a, tta.apply(null, arguments));
  }
}, unroll = (a, u, { type: c, template: l, values: v }) => {
  const { length: S } = v;
  unrollValues(a, u, v, S);
  let { entry: g } = u;
  if (!g || g.template !== l || g.type !== c) {
    const E = new a(c);
    u.entry = g = {
      type: c,
      template: l,
      tag: E,
      wire: persistent(E(l, ...v))
    };
  } else
    g.tag(l, ...v);
  return g.wire;
}, unrollValues = (a, { stack: u }, c, l) => {
  for (let v = 0; v < l; v++) {
    const S = c[v];
    S instanceof Hole ? c[v] = unroll(
      a,
      u[v] || (u[v] = createCache()),
      S
    ) : isArray(S) ? unrollValues(
      a,
      u[v] || (u[v] = createCache()),
      S,
      S.length
    ) : u[v] = null;
  }
  l < u.length && u.splice(l);
};
freeze(LighterHole);
function LighterHole(a, u) {
  this.type = a, this.template = u.shift(), this.values = u;
}
const Hole = LighterHole, { render, html, svg } = createRender(Tagger);
function tta() {
  let a = [], u = 0, { length: c } = arguments;
  for (; u < c; )
    a.push(arguments[u++]);
  return a;
}
const Free = {
  name: "Free",
  layout: ({
    props: a,
    children: u,
    size: c
  }) => u.reduce((l, v) => {
    const {
      size: S = {
        x: "100%",
        y: "100%"
      },
      position: g = {
        x: 0,
        y: 0
      },
      opacity: E = 1
    } = v.props;
    return {
      ...l,
      [v.id]: {
        position: {
          x: g.x,
          y: g.y
        },
        size: {
          x: S.x,
          y: S.y
        },
        opacity: E
      }
    };
  }, {})
}, Column = {
  name: "Column",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      justify: l = "center",
      align: v = "center",
      cover: S = !1,
      margin: g = {},
      dimensions: E = 16 / 9,
      reverse: _ = !1
    } = a;
    const k = S ? 0 : Math.min(c.y / 6, 12);
    g = {
      left: k,
      right: k,
      top: k,
      bottom: k,
      between: k,
      ...g
    };
    const L = c.y - g.top - g.bottom, M = c.x - g.left - g.right, $ = g.between * ((u.length || 1) - 1), J = Math.min(M, (L - $) / (u.length || 1) * E), V = J / E;
    return html.node`
      <div style=${{
      height: "100%",
      width: S ? c.x + "px" : "auto",
      display: "flex",
      flexDirection: _ ? "column-reverse" : "column",
      justifyContent: l,
      alignItems: v,
      paddingLeft: g.left + "px",
      paddingTop: g.top + "px",
      paddingBottom: g.bottom + "px",
      paddingRight: g.right + "px"
    }}>
      ${u.map((q, G) => html.node`<div data-node-id=${q.id} .data=${{
      entryTransition: {
        delay: 400 + G * 100,
        offset: {
          x: 0,
          y: "100%"
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      borderRadius: S ? 0 : 5
    }} style=${{
      display: "flex",
      width: S ? "100%" : J + "px",
      height: S ? V + "px" : "auto",
      aspectRatio: E,
      marginBottom: G === u.length - 1 ? 0 : g.between + "px",
      flexGrow: 0,
      flexShrink: 1,
      flexBasis: V + "px"
    }}></div>`)}
      </div>
    `;
  }
}, Row = {
  name: "Row",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      justify: l = "center",
      align: v = "center",
      cover: S = !1,
      margin: g = {},
      dimensions: E,
      maxWidth: _ = 1,
      reverse: k = !1
    } = a;
    const L = S ? 0 : Math.min(c.y / 6, 12);
    g = {
      left: L,
      right: L,
      top: L,
      bottom: L,
      between: L,
      ...g
    };
    const M = c.y - g.top - g.bottom, $ = c.x - g.left - g.right, J = g.between * ((u.length || 1) - 1);
    let V = M, q = Math.min(($ - J) / (u.length || 1), E ? M * E : $, _ * c.x);
    return E && (V = q / E), html.node`
      <div style=${{
      height: S ? c.y + "px" : "auto",
      width: "100%",
      display: "flex",
      flexDirection: k ? "row-reverse" : "row",
      justifyContent: l,
      alignItems: v,
      paddingLeft: g.left + "px",
      paddingTop: g.top + "px",
      paddingBottom: g.bottom + "px",
      paddingRight: g.right + "px"
    }}>
          ${u.map((G, H) => html.node`<div data-node-id=${G.id} .data=${{
      entryTransition: {
        delay: 400 + H * 100,
        offset: {
          x: 0,
          y: "100%"
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.8,
          y: 0.8
        },
        opacity: 0
      },
      borderRadius: S ? 0 : 5
    }} style=${{
      display: "flex",
      height: S ? "100%" : V + "px",
      width: q + "px",
      marginRight: H === u.length - 1 ? 0 : g.between + "px",
      flexGrow: 0,
      flexShrink: 1,
      flexBasis: q + "px"
    }}></div>`)}
      </div>
    `;
  }
}, toMatrix = (a, u) => a.reduce((c, l, v) => (v % u == 0 ? c.push([v]) : c[c.length - 1].push(v)) && c, []), Grid = {
  name: "Grid",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      dimensions: l,
      numPerRow: v,
      margin: S,
      cover: g = !1,
      maxWidth: E,
      between: _
    } = a;
    const k = u.length === 0 || g ? 0 : _ || Math.min(c.y / u.length / 10, 30);
    S = S ?? k;
    const L = c.x < c.y;
    _ = typeof _ == "number" ? _ : S;
    let M = [];
    v ? M = toMatrix(u, v) : M = L ? getTallGrid(u.length) : getWideGrid(u.length);
    const $ = (c.y - (S * 2 + _ * (M.length - 1))) / M.length, J = c.x - S * 2;
    return html.node`
    <div style=${{
      display: "flex",
      width: "100%",
      height: "100%",
      flexDirection: "column",
      justifyContent: "center",
      padding: S + "px",
      gap: _ + "px",
      flexGrow: 0
    }}>${M.map((V, q) => Row.layout({
      props: {
        justify: "center",
        dimensions: l,
        cover: g,
        maxWidth: E || 1 / (M[0].length || 1),
        margin: {
          top: 0,
          right: 0,
          left: 0,
          bottom: 0,
          between: _
        }
      },
      children: V.map((G) => u[G]),
      size: {
        y: $,
        x: J
      }
    }))}</div>`;
  }
}, Presentation = {
  name: "Presentation",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => {
    let {
      margin: l,
      cover: v = !1,
      barWidth: S = 0.2,
      barPosition: g = "side",
      presentationDimensions: E = 16 / 9,
      viewerDimensions: _ = 16 / 9,
      justifyViewers: k = "center",
      useGrid: L = !1,
      reverse: M = !1
    } = a;
    const $ = g === "side" ? c.x * S : c.y * S, J = u[0], V = u.filter((Z) => Z !== J), q = u.length <= 1 ? 0 : Math.min(c.x / 80, 30);
    if (l = l ?? q, !J)
      return Grid.layout({
        props: a,
        children: u,
        size: c
      });
    const G = u[1], H = {
      ...c
    };
    G && (g === "side" ? (H.x = c.x - $, H.y = H.x / E) : (H.y = c.y - $, H.x = H.y * E));
    let B, Y = {};
    L ? (B = Grid.layout, Y = {
      cover: v,
      ...v ? {
        maxWidth: 1
      } : {
        margin: l
      }
    }) : (B = g === "side" ? Column.layout : Row.layout, Y = {
      margin: {
        top: l,
        left: l,
        bottom: l,
        right: l,
        between: l
      },
      dimensions: _,
      justify: k,
      align: "flex-end"
    });
    const ne = g === "side" ? M ? "left" : "right" : M ? "top" : "bottom";
    return html.node`
      <div style=${{
      display: "flex",
      flexDirection: (g === "side" ? "row" : "column") + (M ? "-reverse" : ""),
      justifyContent: "space-around",
      alignItems: "center",
      position: "relative",
      padding: v ? 0 : l,
      [`padding-${ne}`]: 0
    }}>
        ${u[0] && html.node`<div style=${{
      // aspectRatio: String(presentationDimensions),
      width: H.x,
      height: H.y,
      display: "flex",
      flexGrow: 1
    }}>
            <div data-node-id=${J.id} .data=${{
      dimensions: E,
      borderRadius: v ? 0 : 5,
      entryTransition: {
        delay: 0,
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 0.5,
          y: 0.5
        },
        opacity: 0
      },
      exitTransition: {
        offset: {
          x: 0,
          y: 1e3
        },
        scale: {
          x: 2,
          y: 2
        },
        opacity: 0
      }
    }} style=${{
      width: "100%",
      height: "100%",
      ...v ? {
        position: "absolute",
        top: 0,
        left: 0,
        width: L && G ? 100 - S * 100 + "%" : "100%",
        height: "100%"
      } : {}
    }} />
          </div>`}
        ${html.node`<div style=${{
      ...g === "side" ? {
        maxWidth: S * 100 + "%",
        height: "100%"
      } : {
        maxHeight: S * 100 + "%",
        width: "100%"
      }
    }}>${G && B({
      props: Y,
      children: V,
      size: g === "side" ? {
        x: $,
        y: c.y
      } : {
        x: c.x,
        y: $
      }
    })}</div>`}
      </div>
    `;
  }
}, Layered = {
  name: "Layered",
  layout: ({
    props: a = {},
    children: u,
    size: c
  }) => html.node`<div style=${{
    width: "100%",
    height: "100%",
    position: "relative"
  }}>
      ${u.map((l, v) => html.node`<div data-node-id=${l.id} .data=${{
    zIndex: v + 1
  }} style=${{
    position: "absolute",
    inset: "0px"
  }}></div>`)}
    </div>`
}, getWideGrid = (a = 0) => {
  switch (a) {
    case 0:
      return [[]];
    case 1:
      return [[0]];
    case 2:
      return [[0, 1]];
    case 3:
      return [[0, 1], [2]];
    case 4:
      return [[0, 1], [2, 3]];
    case 5:
      return [[0, 1, 2], [3, 4]];
    case 6:
      return [[0, 1, 2], [3, 4, 5]];
    case 7:
      return [[0, 1, 2], [3, 4, 5], [6]];
    case 8:
      return [[0, 1, 2], [3, 4, 5], [6, 7]];
  }
  const u = Array(a).fill(null).map((c, l) => l);
  return toMatrix(u, Math.round(Math.sqrt(a)));
}, getTallGrid = (a = 0) => {
  switch (a) {
    case 0:
      return [[]];
    case 1:
      return [[0]];
    case 2:
      return [[0], [1]];
    case 3:
      return [[0, 1], [2]];
    case 4:
      return [[0, 1], [2, 3]];
    case 5:
      return [[0, 1], [2, 3], [4]];
    case 6:
      return [[0, 1], [2, 3], [4, 5]];
    case 7:
      return [[0, 1], [2, 3], [4, 5], [6]];
    case 8:
      return [[0, 1], [2, 3], [4, 5], [6, 7]];
  }
  const u = Array(a).fill(null).map((c, l) => l);
  return toMatrix(u, Math.ceil(Math.sqrt(u.length)) - 1);
}, Layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Column,
  Free,
  Grid,
  Layered,
  Presentation,
  Row
}, Symbol.toStringTag, { value: "Module" })), deviceWatchers = /* @__PURE__ */ new Set(), updateMediaStreamTracks = (a, u) => {
  const c = {
    audio: a.getAudioTracks()[0],
    video: a.getVideoTracks()[0]
  };
  c.audio !== u.audio && (c.audio && a.removeTrack(c.audio), u.audio && a.addTrack(u.audio)), c.video !== u.video && (c.video && a.removeTrack(c.video), u.video && a.addTrack(u.video));
}, getDevicePermissions = async () => {
  const a = {
    audio: !0,
    video: !0
  };
  return Promise.all([navigator.mediaDevices.getUserMedia({
    video: !0
  }).then((u) => {
    u.getTracks().forEach((c) => c.stop());
  }).catch((u) => {
    u.name === "NotAllowedError" && (a.video = !1);
  }), navigator.mediaDevices.getUserMedia({
    audio: !0
  }).then((u) => {
    u.getTracks().forEach((c) => c.stop());
  }).catch((u) => {
    u.name === "NotAllowedError" && (a.audio = !1);
  })]).then(() => a);
}, ensureDevicePermissions = async () => getDevicePermissions(), watchDevices = (a) => (deviceWatchers.size === 0 && navigator.mediaDevices.addEventListener("devicechange", reportDevices), deviceWatchers.add(a), reportDevices().catch(() => {
}), () => {
  deviceWatchers.delete(a), deviceWatchers.size === 0 && navigator.mediaDevices.removeEventListener("devicechange", reportDevices);
}), getUserMedia = async (...a) => {
  const u = await navigator.mediaDevices.getUserMedia(...a);
  return reportDevices(), u;
}, deviceWithDefaultLabel = (a, u) => ({
  deviceId: a.deviceId,
  groupId: a.groupId,
  kind: a.kind,
  label: a.label || u
}), reportDevices = async () => {
  const a = await navigator.mediaDevices.enumerateDevices(), u = a.filter((v) => v.kind === "videoinput").map((v, S) => deviceWithDefaultLabel(v, "Camera " + (S + 1))), c = a.filter((v) => v.kind === "audioinput").map((v, S) => deviceWithDefaultLabel(v, "Microphone " + (S + 1))), l = a.filter((v) => v.kind === "audiooutput").map((v, S) => deviceWithDefaultLabel(v, "Speaker " + (S + 1)));
  deviceWatchers.forEach((v) => v({
    webcams: u,
    microphones: c,
    speakers: l
  }));
}, webrtc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ensureDevicePermissions,
  getDevicePermissions,
  getUserMedia,
  updateMediaStreamTracks,
  watchDevices
}, Symbol.toStringTag, { value: "Module" })), RoomParticipant = {
  type: "RoomParticipant",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    // 'screen' | 'camera'
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l
  }) {
    CoreContext.on("RoomJoined", ({
      room: v
    }) => {
      let S = {}, g = [], E = [], _ = {};
      const k = () => {
        g.filter((L) => (L == null ? void 0 : L.type) === "camera" && (L == null ? void 0 : L.isExternal) === !0).forEach((L) => {
          var M, $, J;
          if (L.type === "camera") {
            const V = _[L.id], q = v.getParticipant(L.participantId), G = v.getTrack(L.id);
            if (l(L == null ? void 0 : L.id)) {
              const B = v.getTrack((M = q == null ? void 0 : q.meta[L.id]) == null ? void 0 : M.microphone);
              updateMediaStreamTracks(V, {
                video: G == null ? void 0 : G.mediaStreamTrack,
                audio: B == null ? void 0 : B.mediaStreamTrack
              }), c(L.id, {
                videoEnabled: !!(G && !G.isMuted),
                audioEnabled: !!(B && !B.isMuted),
                displayName: (($ = q == null ? void 0 : q.meta[L.id]) == null ? void 0 : $.displayName) || "External Track",
                mirrored: (J = q == null ? void 0 : q.meta[L.id]) == null ? void 0 : J.isMirrored,
                microphone: B,
                external: L == null ? void 0 : L.isExternal
              });
            }
          }
        }), E.forEach((L) => {
          var Y;
          const M = _[L.id], $ = _[L.id + "-screen"], J = L.trackIds.find((ne) => {
            const Z = v.getTrack(ne);
            return (Z == null ? void 0 : Z.type) === "camera" && !(Z != null && Z.isExternal);
          }), V = L.trackIds.find((ne) => {
            const Z = v.getTrack(ne);
            return (Z == null ? void 0 : Z.type) === "microphone" && !(Z != null && Z.isExternal);
          }), q = L.trackIds.find((ne) => {
            const Z = v.getTrack(ne);
            return (Z == null ? void 0 : Z.type) === "screen_share";
          }), G = v.getTrack(J), H = v.getTrack(V), B = v.getTrack(q);
          updateMediaStreamTracks(M, {
            video: G == null ? void 0 : G.mediaStreamTrack,
            audio: H == null ? void 0 : H.mediaStreamTrack
          }), updateMediaStreamTracks($, {
            video: B == null ? void 0 : B.mediaStreamTrack
          }), c(L.id, {
            videoEnabled: !!(G && !G.isMuted),
            audioEnabled: !!(H && !H.isMuted),
            displayName: L.displayName,
            mirrored: (Y = L == null ? void 0 : L.meta) == null ? void 0 : Y.isMirrored,
            external: G == null ? void 0 : G.isExternal
          }), c(L.id + "-screen", {
            videoEnabled: !!(B && !B.isMuted),
            displayName: L.meta.screenDisplayName || `${L.displayName}'s Screen`
          });
        });
      };
      v.useTracks((L) => {
        const M = L.filter((J) => !g.some((V) => V.id === J.id) && !!(J != null && J.mediaStreamTrack)), $ = g.filter((J) => !L.some((V) => V.id === J.id));
        g = L.filter((J) => !!(J != null && J.mediaStreamTrack)), M.forEach((J) => {
          const V = new MediaStream([]);
          _[J.id] = V;
          const {
            id: q,
            participantId: G,
            type: H,
            mediaStreamTrack: B
          } = v.getTrack(J.id);
          B && a({
            id: q,
            isActive: !0,
            value: V,
            props: {
              id: q,
              trackId: q,
              participantId: G,
              isMuted: J.isMuted,
              type: H
            }
          });
        }), $.forEach((J) => {
          var V;
          u(J.id), (V = S[J.id]) == null || V.call(S);
        }), k();
      }), v.useParticipants((L) => {
        const M = L.filter((J) => !E.some((V) => V.id === J.id)), $ = E.filter((J) => !L.some((V) => V.id === J.id));
        E = L, M.forEach((J) => {
          var H;
          const {
            id: V
          } = J, q = new MediaStream([]), G = new MediaStream([]);
          _[V] = q, _[V + "-screen"] = G, a({
            id: V,
            isActive: !0,
            value: q,
            props: {
              id: V,
              type: "camera",
              displayName: J.displayName || J.id,
              audioEnabled: !1,
              videoEnabled: !1,
              mirrored: (H = J == null ? void 0 : J.meta) == null ? void 0 : H.isMirrored
            }
          }), a({
            id: V + "-screen",
            isActive: !0,
            value: G,
            props: {
              id: V,
              type: "screen",
              displayName: J.displayName || J.id,
              audioEnabled: !1,
              videoEnabled: !1
            }
          });
        }), k(), $.forEach((J) => {
          var V;
          u(J.id), (V = S[J.id]) == null || V.call(S);
        });
      });
    });
  }
}, Banner = {
  type: "Banner",
  valueType: Object,
  props: {},
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l,
    modifySourceValue: v
  }) {
    let S = [];
    const g = (E = []) => {
      const _ = E.filter((M) => !S.some(($) => $.id === M.id)), k = S.filter((M) => !E.some(($) => $.id === M.id)), L = E.filter((M) => {
        const $ = S.find((J) => J.id === M.id);
        return !deepEqual(M, $);
      });
      _.forEach((M) => a({
        id: M.id,
        value: {
          headerText: M.props.headerText,
          bodyText: M.props.bodyText
        },
        // TODO: It feels odd to have "props" match "value" exactly.
        //  They probably shouldn't be necessary here.
        props: M.props
      })), k.forEach((M) => u(M.id)), L.forEach((M) => {
        c(M.id, M.props), v(M.id, ($) => {
          $.headerText = M.props.headerText, $.bodyText = M.props.bodyText;
        });
      }), S = E;
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId: E
    }) => {
      var k;
      if (S = [], !E)
        return;
      const _ = getProject(E);
      g(((k = _.props) == null ? void 0 : k.banners) ?? []);
    }), CoreContext.on("ProjectChanged", ({
      project: E
    }) => {
      var _;
      g(((_ = E.props) == null ? void 0 : _.banners) ?? []);
    });
  }
}, Overlays = {
  type: "Overlay",
  valueType: Object,
  props: {},
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l,
    modifySourceValue: v
  }) {
    let S = [];
    const g = (E = []) => {
      const _ = E.filter((M) => !S.some(($) => $.id === M.id)), k = S.filter((M) => !E.some(($) => $.id === M.id)), L = E.filter((M) => {
        const $ = S.find((J) => J.id === M.id);
        return !deepEqual(M, $);
      });
      _.forEach((M) => a({
        id: M.id,
        value: {
          ...M.props
        },
        // TODO: It feels odd to have "props" match "value" exactly.
        //  They probably shouldn't be necessary here.
        props: M.props
      })), k.forEach((M) => u(M.id)), L.forEach((M) => {
        c(M.id, M.props), v(M.id, ($) => {
          Object.keys(M.props).forEach((J) => {
            $[J] = M.props[J];
          });
        });
      }), S = JSON.parse(JSON.stringify(E));
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId: E
    }) => {
      if (S = [], !E)
        return;
      const _ = getProject(E);
      g(_.props.overlays);
    }), CoreContext.on("ProjectChanged", ({
      project: E
    }) => {
      g(E.props.overlays);
    });
  }
}, Background = {
  type: "Background",
  valueType: Object,
  props: {},
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l,
    modifySourceValue: v
  }) {
    let S;
    const g = (E) => {
      if (!E)
        return;
      const _ = (S == null ? void 0 : S.id) !== (E == null ? void 0 : E.id) ? E : null, k = deepEqual(E, S) ? null : E;
      _ && (a({
        id: _ == null ? void 0 : _.id,
        value: {
          ..._ == null ? void 0 : _.props
        },
        // TODO: It feels odd to have "props" match "value" exactly.
        //  They probably shouldn't be necessary here.
        props: _ == null ? void 0 : _.props
      }), u(S == null ? void 0 : S.id)), k && (c(k == null ? void 0 : k.id, k == null ? void 0 : k.props), v(k == null ? void 0 : k.id, (L) => {
        Object.keys(k == null ? void 0 : k.props).forEach((M) => {
          L[M] = k == null ? void 0 : k.props[M];
        });
      })), S = JSON.parse(JSON.stringify(E));
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId: E
    }) => {
      if (S = null, !E)
        return;
      const _ = getProject(E);
      g(_.props.background);
    }), CoreContext.on("ProjectChanged", ({
      project: E
    }) => {
      g(E.props.background);
    });
  }
}, Logo = {
  type: "Logo",
  valueType: Object,
  props: {},
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l,
    modifySourceValue: v
  }) {
    let S;
    const g = (E) => {
      if (!E) {
        S && (u(S == null ? void 0 : S.id), S = null);
        return;
      }
      const _ = (S == null ? void 0 : S.id) !== (E == null ? void 0 : E.id) ? E : null, k = deepEqual(E, S) ? null : E;
      _ && (a({
        id: _ == null ? void 0 : _.id,
        value: {
          ..._ == null ? void 0 : _.props
        },
        // TODO: It feels odd to have "props" match "value" exactly.
        //  They probably shouldn't be necessary here.
        props: _ == null ? void 0 : _.props
      }), u(S == null ? void 0 : S.id)), k && (c(k == null ? void 0 : k.id, k == null ? void 0 : k.props), v(k == null ? void 0 : k.id, (L) => {
        Object.keys(k == null ? void 0 : k.props).forEach((M) => {
          L[M] = k == null ? void 0 : k.props[M];
        });
      })), S = JSON.parse(JSON.stringify(E));
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId: E
    }) => {
      if (S = null, !E)
        return;
      const _ = getProject(E);
      g(_.props.logo);
    }), CoreContext.on("ProjectChanged", ({
      project: E
    }) => {
      g(E.props.logo);
    });
  }
}, {
  state
} = CoreContext, updateUserProps = async (a) => {
  const u = getUser();
  if (!u)
    return;
  const c = {
    ...u.props,
    ...a.props
  }, l = await CoreContext.clients.LiveApi().collection.updateCollection({
    collectionId: u.id,
    updateMask: ["metadata"],
    metadata: {
      ...u.metadata,
      props: c
    }
  });
  await triggerInternal$1("UserChanged", l.collection);
}, createSource = async (a) => {
  const u = getUser().id, {
    source: c
  } = await CoreContext.clients.LiveApi().source.createSource({
    metadata: {},
    collectionId: u,
    address: {
      rtmpPush: {
        enabled: !0
      }
    },
    preview: {
      webrtc: {
        enabled: !0,
        displayName: a.displayName || "RTMP Source"
      }
    }
  });
  await triggerInternal$1("SourceAdded", c);
  const l = await CoreContext.clients.LiveApi().source.addSourceToProject({
    collectionId: u,
    projectId: a.projectId,
    sourceId: c.sourceId
  });
  return await triggerInternal$1("ProjectSourceAdded", {
    projectId: l.project.projectId,
    source: c
  }), c;
}, updateSource = async (a) => {
  const u = getUser().id;
  let c = [], l = {};
  a.metadata && (c.push("metadata"), l.metadata = a.metadata), a.displayName && (c.push("preview.webrtc.displayName"), l = {
    ...l,
    preview: {
      webrtc: {
        displayName: a.displayName
      }
    }
  });
  const {
    source: v
  } = await CoreContext.clients.LiveApi().source.updateSource({
    collectionId: u,
    updateMask: c,
    sourceId: a.sourceId,
    ...l
  });
  return await triggerInternal$1("SourceChanged", v), v;
}, deleteSource = async (a) => {
  const u = getUser().id;
  await CoreContext.clients.LiveApi().source.removeSourceFromProject({
    collectionId: u,
    projectId: a.projectId,
    sourceId: a.sourceId
  }), await triggerInternal$1("ProjectSourceRemoved", {
    projectId: a.projectId,
    sourceId: a.sourceId
  });
  const c = await CoreContext.clients.LiveApi().source.deleteSource({
    sourceId: a.sourceId,
    collectionId: u
  });
  return await triggerInternal$1("SourceRemoved", a.sourceId), c;
}, createProject$1 = async (a = {}) => {
  const {
    props: u = {},
    size: c,
    settings: l = {}
  } = a, v = await CoreContext.Request.createProject({
    settings: l,
    props: u,
    size: c
  });
  await triggerInternal$1("ProjectAdded", v.project);
  const S = await hydrateProject(v.project, "ROLE_HOST");
  return toBaseProject(S);
}, recreateLayout = async (a) => {
  const {
    projectId: u,
    props: c = {}
  } = a, l = getUser().id, v = await CoreContext.clients.LiveApi().project.getProject({
    collectionId: l,
    projectId: u,
    status: !0
  });
  if ([ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING, ProjectBroadcastPhase.PROJECT_BROADCAST_PHASE_STARTING].includes(v.status.phase))
    return;
  const S = v.project.metadata || {}, {
    layoutId: g
  } = S, {
    video: E
  } = v.project.rendering, {
    type: _
  } = v.project.metadata.props || {}, k = await CoreContext.Request.createLayout({
    collectionId: l,
    projectId: u,
    type: _ || "sceneless",
    settings: {},
    size: {
      x: E.width,
      y: E.height
    }
  }), L = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: l,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...S,
      layoutId: k.id
    }
  });
  CoreContext.log.debug("New layout assigned to project:", {
    layout: k
  }), await triggerInternal$1("ProjectChanged", {
    project: L.project
  }), await CoreContext.clients.LayoutApi().layout.deleteLayout({
    layoutId: g
  }), CoreContext.log.debug("Previous layout deleted:", {
    layoutId: g
  });
  const M = await hydrateProject(L.project, "ROLE_HOST");
  return await M.compositor.update(M.compositor.getRoot().id, c), {
    project: toBaseProject(M),
    internalProject: M
  };
}, deleteProject$1 = async (a) => {
  const {
    projectId: u
  } = a;
  await CoreContext.Request.deleteProject({
    projectId: u
  }), await triggerInternal$1("ProjectRemoved", {
    projectId: u
  });
}, updateProjectProps = async (a) => {
  const {
    projectId: u
  } = a, c = getUser().id, l = getProject(u), v = {
    ...l.props,
    ...a.props
  }, S = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: c,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...l.videoApi.project.metadata,
      props: v
    }
  });
  await triggerInternal$1("ProjectChanged", {
    project: S.project
  });
}, updateProjectPropsWithoutTrigger = async (a) => {
  const {
    projectId: u
  } = a, c = getUser().id, l = getProject(u), v = {
    ...l.props,
    ...a.props
  };
  await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: c,
    projectId: u,
    updateMask: ["metadata"],
    metadata: {
      ...l.videoApi.project.metadata,
      props: v
    }
  });
}, setActiveProject = async (a) => {
  const u = state.projects.find((l) => l.id === a.projectId);
  if (!u) {
    state.activeProjectId = null, triggerInternal$1("ActiveProjectChanged", {
      projectId: null
    });
    return;
  }
  const c = state.projects.find((l) => l.id === state.activeProjectId);
  if (u !== c)
    return c && (Array.from(webrtcManager.rooms.keys()).map(webrtcManager.removeRoom), await CoreContext.clients.LayoutApi().unsubscribeFromLayout(c.layoutApi.layoutId), await CoreContext.clients.LiveApi().unsubscribeFromProject(c.videoApi.project.collectionId, c.videoApi.project.projectId)), await CoreContext.clients.LayoutApi().subscribeToLayout(u.layoutApi.layoutId), await CoreContext.clients.LiveApi().subscribeToProject(u.videoApi.project.collectionId, u.videoApi.project.projectId), CoreContext.clients.LiveApi().project.getProject({
      collectionId: u.videoApi.project.collectionId,
      projectId: u.videoApi.project.projectId,
      status: !0
    }).then((l) => {
      var v, S;
      triggerInternal$1("ProjectChanged", {
        project: l.project,
        phase: (v = l.status) == null ? void 0 : v.phase,
        broadcastId: (S = l.status) == null ? void 0 : S.broadcastId
      });
    }), triggerInternal$1("ActiveProjectChanged", {
      projectId: u.id
    }), toBaseProject(u);
}, joinRoom = async (a) => {
  const {
    projectId: u,
    displayName: c = "Guest"
  } = a, l = state.projects.find((M) => M.id === u);
  let v = l.sfuToken;
  if (!v) {
    let {
      webrtcAccess: M
    } = await CoreContext.clients.LiveApi().authentication.createWebRtcAccessToken({
      collectionId: l.videoApi.project.collectionId,
      projectId: l.videoApi.project.projectId,
      displayName: c
    });
    v = M.accessToken;
  }
  const g = jwtDecode(v).video.room, E = new URL(CoreContext.clients.getLiveKitServer()), _ = E.host + E.pathname, k = webrtcManager.ensureRoom(_, g, v);
  k.bindApiClient(CoreContext.clients), await k.connect(), l.sfuToken = v, l.roomId = g;
  const L = getRoom(g);
  return trigger$1("RoomJoined", {
    projectId: l.id,
    room: L
  }), L;
}, createNode = async (a) => {
  let {
    props: u = {},
    parentId: c,
    index: l,
    projectId: v = state.activeProjectId
  } = a;
  const S = getProject(v), g = await S.compositor.insert(u, c, l);
  return triggerInternal$1("NodeAdded", {
    projectId: v,
    nodeId: g
  }), triggerInternal$1("NodeChanged", {
    projectId: v,
    nodeId: c
  }), S.compositor.get(g);
}, deleteNode = async (a) => {
  var S;
  let {
    nodeId: u,
    projectId: c = state.activeProjectId
  } = a;
  const l = getProject(c), v = (S = l.compositor.getParent(u)) == null ? void 0 : S.id;
  l.compositor.remove(u), triggerInternal$1("NodeRemoved", {
    projectId: c,
    nodeId: u
  }), triggerInternal$1("NodeChanged", {
    projectId: c,
    nodeId: v
  });
}, updateNode = async (a) => {
  let {
    nodeId: u,
    props: c = {},
    projectId: l = state.activeProjectId
  } = a;
  const v = getProject(l);
  return delete c.type, delete c.sourceType, v.compositor.update(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  }), v.compositor.get(u);
}, setNodeLayout = async (a) => {
  let {
    nodeId: u,
    layout: c,
    projectId: l = state.activeProjectId,
    layoutProps: v = {}
  } = a;
  getProject(l).compositor.update(u, {
    layout: c,
    layoutProps: v
  }), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, moveNode = async (a) => {
  const {
    nodeId: u,
    parentId: c,
    projectId: l = state.activeProjectId,
    index: v
  } = a;
  getProject(l).compositor.move(u, c, v), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, swapNodes = async (a) => {
  var E, _;
  const {
    nodeAId: u,
    nodeBId: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l), S = (E = v.compositor.getParent(u)) == null ? void 0 : E.id, g = (_ = v.compositor.getParent(c)) == null ? void 0 : _.id;
  v.compositor.swap(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: S
  }), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: g
  });
}, reorderNodes = async (a) => {
  const {
    parentId: u,
    childIds: c,
    projectId: l = state.activeProjectId
  } = a;
  getProject(l).compositor.reorder(u, c), triggerInternal$1("NodeChanged", {
    projectId: l,
    nodeId: u
  });
}, startBroadcast = async (a) => {
  const {
    projectId: u = state.activeProjectId
  } = a, c = getProject(u);
  await CoreContext.clients.LiveApi().project.startProjectBroadcast({
    collectionId: c.videoApi.project.collectionId,
    projectId: c.videoApi.project.projectId
  });
}, stopBroadcast = async (a) => {
  const {
    projectId: u = state.activeProjectId
  } = a, c = getProject(u);
  await CoreContext.clients.LiveApi().project.stopProjectBroadcast({
    collectionId: c.videoApi.project.collectionId,
    projectId: c.videoApi.project.projectId
  });
}, addDestination = async (a) => {
  var k;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    enabled: l,
    projectId: v = state.activeProjectId,
    props: S = {}
  } = a, g = getProject(v), E = {
    rtmpPush: {
      key: c,
      url: u
    }
  }, _ = await ((k = CoreContext.clients.LiveApi().destination) == null ? void 0 : k.createDestination({
    collectionId: g.videoApi.project.collectionId,
    projectId: g.videoApi.project.projectId,
    address: E,
    enabled: l,
    metadata: {
      props: S
    }
  }));
  return await triggerInternal$1("DestinationAdded", _.destination), toBaseDestination(_.destination);
}, removeDestination = async (a) => {
  var v;
  const {
    destinationId: u,
    projectId: c = state.activeProjectId
  } = a, l = getProject(c);
  await ((v = CoreContext.clients.LiveApi().destination) == null ? void 0 : v.deleteDestination({
    collectionId: l.videoApi.project.collectionId,
    projectId: l.videoApi.project.projectId,
    destinationId: u
  })), await triggerInternal$1("DestinationRemoved", {
    projectId: c,
    destinationId: u
  });
}, updateDestination = async (a) => {
  var _;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    destinationId: l,
    projectId: v = state.activeProjectId
  } = a, S = getProject(v), g = {
    key: c,
    url: u
  }, E = await ((_ = CoreContext.clients.LiveApi().destination) == null ? void 0 : _.updateDestination({
    collectionId: S.videoApi.project.collectionId,
    projectId: S.videoApi.project.projectId,
    destinationId: l,
    updateMask: ["address.rtmpPush"],
    address: {
      rtmpPush: g
    }
  }));
  await triggerInternal$1("DestinationChanged", E.destination);
}, updateDestinationProps = async (a) => {
  var E, _;
  const {
    projectId: u = state.activeProjectId,
    destinationId: c,
    props: l = {}
  } = a, v = getProject(u), S = v.videoApi.project.destinations.find((k) => k.destinationId === c);
  if (!S)
    return;
  const g = await ((_ = CoreContext.clients.LiveApi().destination) == null ? void 0 : _.updateDestination({
    collectionId: v.videoApi.project.collectionId,
    projectId: v.videoApi.project.projectId,
    destinationId: c,
    updateMask: ["metadata"],
    metadata: {
      ...S.metadata || {},
      props: {
        ...((E = S.metadata) == null ? void 0 : E.props) || {},
        ...l
      }
    }
  }));
  await triggerInternal$1("DestinationChanged", g.destination);
}, setDestinationEnabled = async (a) => {
  var E;
  const {
    enabled: u,
    destinationId: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l);
  if (v.videoApi.project.destinations.find((_) => c === _.destinationId).enabled === u)
    return;
  const g = await ((E = CoreContext.clients.LiveApi().destination) == null ? void 0 : E.updateDestination({
    collectionId: v.videoApi.project.collectionId,
    projectId: v.videoApi.project.projectId,
    destinationId: c,
    updateMask: ["enabled"],
    enabled: u
  }));
  await triggerInternal$1("DestinationChanged", g.destination);
}, setDestination = async (a) => {
  var E, _;
  const {
    rtmpUrl: u,
    rtmpKey: c,
    projectId: l = state.activeProjectId
  } = a, v = getProject(l), S = {
    key: c,
    url: u
  }, g = !0;
  if (v.videoApi.project.destinations.length > 0) {
    const k = await ((E = CoreContext.clients.LiveApi().destination) == null ? void 0 : E.updateDestination({
      collectionId: v.videoApi.project.collectionId,
      projectId: v.videoApi.project.projectId,
      destinationId: v.videoApi.project.destinations[0].destinationId,
      updateMask: ["address.rtmpPush"],
      address: {
        rtmpPush: S
      }
    }));
    await triggerInternal$1("DestinationChanged", k.destination);
  } else {
    const k = await ((_ = CoreContext.clients.LiveApi().destination) == null ? void 0 : _.createDestination({
      collectionId: v.videoApi.project.collectionId,
      projectId: v.videoApi.project.projectId,
      address: {
        rtmpPush: S
      },
      enabled: g
    }));
    await triggerInternal$1("DestinationAdded", k.destination);
  }
}, commands$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addDestination,
  createNode,
  createProject: createProject$1,
  createSource,
  deleteNode,
  deleteProject: deleteProject$1,
  deleteSource,
  joinRoom,
  moveNode,
  recreateLayout,
  removeDestination,
  reorderNodes,
  setActiveProject,
  setDestination,
  setDestinationEnabled,
  setNodeLayout,
  startBroadcast,
  stopBroadcast,
  swapNodes,
  updateDestination,
  updateDestinationProps,
  updateNode,
  updateProjectProps,
  updateProjectPropsWithoutTrigger,
  updateSource,
  updateUserProps
}, Symbol.toStringTag, { value: "Module" })), useActiveProjectRoom$1 = () => {
  const [a, u] = useState(null);
  return useEffect(() => useActiveProjectRoom(u), []), a;
}, useDevices = () => {
  const [a, u] = useState({
    webcams: [],
    microphones: [],
    speakers: []
  });
  return useEffect(() => watchDevices(u), []), a;
}, StudioContext = React.createContext({
  studio: null,
  project: null,
  room: null,
  webcamId: null,
  microphoneId: null,
  setStudio: () => {
  },
  setProject: () => {
  },
  setRoom: () => {
  },
  setWebcamId: () => {
  },
  setMicrophoneId: () => {
  },
  projectCommands: {}
}), useStudio = () => useContext(StudioContext);
let stored = {
  webcamId: null,
  microphoneId: null
};
try {
  stored.webcamId = localStorage == null ? void 0 : localStorage.getItem("__LS_webcam"), stored.microphoneId = localStorage == null ? void 0 : localStorage.getItem("__LS_microphone");
} catch {
}
const StudioProvider = ({
  children: a
}) => {
  const [u, c] = useState(), [l, v] = useState(), [S, g] = useState(), [E, _] = useState(stored.webcamId), [k, L] = useState(stored.microphoneId), M = useMemo(() => l ? commands(l) : null, [l]);
  return useEffect(() => {
  }, [l]), useEffect(() => {
    u && (E && u.setCamera({
      deviceId: E
    }).catch(($) => {
      console.warn($);
    }), k && u.setMicrophone({
      deviceId: k
    }).catch(($) => {
      console.warn($);
    }));
  }, [u, E, k]), /* @__PURE__ */ React.createElement(StudioContext.Provider, {
    value: {
      studio: S,
      project: l,
      room: u,
      webcamId: E,
      microphoneId: k,
      setStudio: g,
      setProject: v,
      setRoom: c,
      setWebcamId: ($) => {
        try {
          localStorage == null || localStorage.setItem("__LS_webcam", $);
        } catch {
        }
        _($);
      },
      setMicrophoneId: ($) => {
        try {
          localStorage == null || localStorage.setItem("__LS_microphone", $);
        } catch {
        }
        L($);
      },
      projectCommands: M
    }
  }, a);
}, react = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StudioContext,
  StudioProvider,
  useActiveProjectRoom: useActiveProjectRoom$1,
  useDevices,
  useStudio
}, Symbol.toStringTag, { value: "Module" })), ForegroundLayers = [{
  name: "ImageIframeOverlayContainer",
  id: "fg-image-iframe",
  layout: "Free"
}, {
  name: "BannerContainer",
  id: "fg-banners",
  layout: "Column",
  layoutProps: {
    cover: !0
  }
}, {
  name: "VideoOverlayContainer",
  id: "fg-video",
  layout: "Free"
}, {
  name: "LogoContainer",
  layout: "Free",
  id: "logo"
}], defaultStyles = {
  custom: {
    display: "block"
  },
  video: {
    height: "100%",
    width: "100%"
  },
  image: {
    height: "100%",
    width: "100%"
  },
  logo: {
    objectFit: "contain",
    position: "unset"
  }
}, validateEachChildren = (a, u) => {
  let c = !0;
  return a.forEach((l) => {
    var v, S;
    (v = l.props) != null && v.sourceType && !u.includes((S = l.props) == null ? void 0 : S.sourceType) ? c = !1 : l.children.length > 0 && (c = c && validateEachChildren(l.children, u));
  }), c;
}, addingCache = {
  camera: /* @__PURE__ */ new Set(),
  screen: /* @__PURE__ */ new Set(),
  rtmp: /* @__PURE__ */ new Set()
}, commands = (a) => {
  var H, B, Y, ne;
  const u = a.id, c = a.scene.getRoot(), {
    Command: l
  } = CoreContext, v = c.children.find((Z) => Z.props.id === "bg"), S = c.children.find((Z) => Z.props.id === "content"), g = c.children.find((Z) => Z.props.id === "foreground");
  let E = (H = g == null ? void 0 : g.children) == null ? void 0 : H.find((Z) => Z.props.id === "fg-image-iframe"), _ = (B = g == null ? void 0 : g.children) == null ? void 0 : B.find((Z) => Z.props.id === "logo"), k = (Y = g == null ? void 0 : g.children) == null ? void 0 : Y.find((Z) => Z.props.id === "fg-video");
  const L = getProject(a.id);
  let M = (ne = g == null ? void 0 : g.children) == null ? void 0 : ne.find((Z) => Z.props.id === "fg-banners");
  const $ = async () => {
    var Z, re;
    ((Z = v == null ? void 0 : v.props) == null ? void 0 : Z.layout) !== "Layered" && await L.compositor.update(v.id, {
      name: "Background",
      id: "bg",
      layout: "Layered"
    }), ((re = g == null ? void 0 : g.props) == null ? void 0 : re.layout) !== "Layered" && await L.compositor.update(g.id, {
      id: "foreground",
      name: "Overlays",
      layout: "Layered"
    });
  }, J = async () => {
    validateEachChildren(v.children, ["Background"]) || v.children.forEach(async (Z) => {
      await CoreContext.Command.deleteNode({
        nodeId: Z.id
      });
    });
  }, V = async () => {
    const Z = async () => {
      var A;
      if (M)
        return M.id;
      {
        const N = await L.compositor.insert({
          name: "BannerContainer",
          id: "fg-banners",
          layout: "Column",
          layoutProps: {
            cover: !0
          }
        }, g.id);
        return M = (A = g == null ? void 0 : g.children) == null ? void 0 : A.find((D) => D.id === N), N;
      }
    }, re = async () => {
      var A;
      if (E)
        return E.id;
      {
        const N = await L.compositor.insert({
          name: "ImageIframeOverlay",
          id: "fg-image-iframe",
          layout: "Free"
        }, g.id);
        return E = (A = g == null ? void 0 : g.children) == null ? void 0 : A.find((D) => D.id === N), N;
      }
    }, oe = async () => {
      var A;
      if (k)
        return k.id;
      {
        const N = await L.compositor.insert({
          name: "VideoOverlay",
          id: "fg-video",
          layout: "Free"
        }, g.id);
        return k = (A = g == null ? void 0 : g.children) == null ? void 0 : A.find((D) => D.id === N), N;
      }
    }, de = async () => {
      var A;
      if (_)
        return _.id;
      {
        const N = await L.compositor.insert({
          name: "Logo",
          layout: "Free",
          sourceType: "Logo",
          id: "logo",
          style: {
            width: "100%",
            height: "100%",
            objectFit: "contain",
            position: "unset"
          }
        }, g.id);
        return _ = (A = g == null ? void 0 : g.children) == null ? void 0 : A.find((D) => D.id === N), N;
      }
    };
    try {
      const A = await Promise.all([Z(), re(), oe(), de()]);
      await L.compositor.reorder(g.id, A);
    } catch {
    }
  }, q = {
    getBackground() {
      return v;
    },
    getContent() {
      return S;
    },
    getForeground() {
      return g;
    },
    getLayout() {
      return S.props.layout;
    },
    getBanners() {
      var Z;
      return ((Z = getProject(a.id).props) == null ? void 0 : Z.banners) || [];
    },
    getOverlays() {
      return getProject(a.id).props.overlays || [];
    },
    getParticipants() {
      return S.children.filter((Z) => Z.props.sourceType === "RoomParticipant");
    },
    getLogo() {
      var Z, re;
      return (re = (Z = _ == null ? void 0 : _.children[0]) == null ? void 0 : Z.props) == null ? void 0 : re.id;
    },
    async removeLogo() {
      const [Z, ...re] = (_ == null ? void 0 : _.children) || [];
      re.forEach((oe) => {
        CoreContext.Command.deleteNode({
          nodeId: oe.id
        });
      }), Z && await CoreContext.Command.deleteNode({
        nodeId: Z.id
      });
    },
    getImageOverlay() {
      var re, oe;
      const Z = (re = E == null ? void 0 : E.children) == null ? void 0 : re.find((de) => {
        var A, N;
        return ((N = (A = de == null ? void 0 : de.props) == null ? void 0 : A.sourceProps) == null ? void 0 : N.type) === "image";
      });
      return (oe = Z == null ? void 0 : Z.props) == null ? void 0 : oe.id;
    },
    getVideoOverlay() {
      var re, oe;
      const Z = (re = k == null ? void 0 : k.children) == null ? void 0 : re.find((de) => {
        var A, N;
        return ((N = (A = de == null ? void 0 : de.props) == null ? void 0 : A.sourceProps) == null ? void 0 : N.type) === "video";
      });
      return (oe = Z == null ? void 0 : Z.props) == null ? void 0 : oe.id;
    },
    autoPlayBackgroundVideo(Z = {
      muted: !0,
      autoplay: !0
    }) {
      const re = v.children.find((oe) => oe.props.id === "bg-video");
      re && CoreContext.Command.updateNode({
        nodeId: re.id,
        props: {
          ...re.props,
          attributes: {
            ...re.props.attributes,
            ...Z
          }
        }
      });
    },
    autoPlayVideoOverlay(Z, re = {
      muted: !0,
      autoplay: !0
    }) {
      var de;
      const oe = (de = k == null ? void 0 : k.children) == null ? void 0 : de.find((A) => {
        var N, D;
        return ((D = (N = A.props) == null ? void 0 : N.sourceProps) == null ? void 0 : D.id) === Z;
      });
      oe && oe.props.sourceProps.type === "video" && CoreContext.Command.updateNode({
        nodeId: oe.id,
        props: {
          ...oe.props,
          attributes: {
            ...oe.props.attributes,
            ...re
          }
        }
      });
    },
    getBackgroundMedia() {
      var re, oe;
      return (oe = (re = v.children.filter((de) => de)[0]) == null ? void 0 : re.props) == null ? void 0 : oe.id;
    },
    getBackgroundImage() {
      var re;
      const Z = v.children.find((oe) => {
        var de, A;
        return ((A = (de = oe.props) == null ? void 0 : de.sourceProps) == null ? void 0 : A.type) === "image";
      });
      return (re = Z == null ? void 0 : Z.props) == null ? void 0 : re.id;
    },
    getBackgroundVideo() {
      var re;
      const Z = v.children.find((oe) => {
        var de, A;
        return ((A = (de = oe.props) == null ? void 0 : de.sourceProps) == null ? void 0 : A.type) === "video";
      });
      return (re = Z == null ? void 0 : Z.props) == null ? void 0 : re.id;
    },
    async addLogo(Z, re) {
      const [oe, ...de] = (_ == null ? void 0 : _.children) || [];
      de.forEach((A) => {
        CoreContext.Command.deleteNode({
          nodeId: A.id
        });
      }), oe ? await CoreContext.Command.updateNode({
        nodeId: oe.id,
        props: {
          sourceType: "Logo",
          id: Z,
          sourceProps: {
            ...re,
            meta: {
              style: {
                ...defaultStyles.logo
              },
              ...re.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: _ == null ? void 0 : _.id,
        props: {
          sourceType: "Logo",
          id: Z,
          sourceProps: {
            ...re,
            meta: {
              style: {
                ...defaultStyles.logo
              },
              ...re.meta
            }
          }
        }
      });
    },
    addBanner(Z = {}) {
      var A;
      const re = Z.meta || {}, oe = {
        id: generateId(),
        props: {
          ...Z,
          meta: re
        }
      }, de = ((A = getProject(u).props) == null ? void 0 : A.banners) || [];
      return l.updateProjectProps({
        projectId: u,
        props: {
          banners: [...de, oe]
        }
      });
    },
    editBanner(Z, re = {}) {
      const de = q.getBanners().map((A) => A.id !== Z ? A : {
        ...A,
        props: re
      });
      return l.updateProjectProps({
        projectId: u,
        props: {
          banners: de
        }
      });
    },
    removeBanner(Z) {
      var oe;
      const re = q.getBanners();
      return (oe = M == null ? void 0 : M.children) == null || oe.forEach((de) => {
        de.props.bannerId === Z && CoreContext.Command.deleteNode({
          nodeId: de.id
        });
      }), l.updateProjectProps({
        projectId: u,
        props: {
          banners: re.filter((de) => de.id !== Z)
        }
      });
    },
    async setActiveBanner(Z) {
      var A, N;
      const [re, ...{}] = (M == null ? void 0 : M.children) || [];
      ((N = (A = re == null ? void 0 : re.props) == null ? void 0 : A.sourceType) == null ? void 0 : N.toLowerCase()) === "chatoverlay" && await CoreContext.Command.deleteNode({
        nodeId: re.id
      });
      const [oe, ...de] = (M == null ? void 0 : M.children) || [];
      if (de.forEach((D) => {
        CoreContext.Command.deleteNode({
          nodeId: D.id
        });
      }), oe)
        CoreContext.Command.updateNode({
          nodeId: oe.id,
          props: {
            sourceType: "Banner",
            bannerId: Z
          }
        });
      else
        return CoreContext.Command.createNode({
          parentId: M == null ? void 0 : M.id,
          props: {
            sourceType: "Banner",
            bannerId: Z
          }
        });
    },
    getActiveBanner() {
      var Z, re, oe;
      return ((oe = (re = (Z = M.children) == null ? void 0 : Z[0]) == null ? void 0 : re.props) == null ? void 0 : oe.bannerId) ?? null;
    },
    async addChatOverlay(Z, re) {
      var N, D;
      const [oe, ...{}] = (M == null ? void 0 : M.children) || [];
      ((D = (N = oe == null ? void 0 : oe.props) == null ? void 0 : N.sourceType) == null ? void 0 : D.toLowerCase()) === "banner" && await CoreContext.Command.deleteNode({
        nodeId: oe.id
      });
      const [de, ...A] = (M == null ? void 0 : M.children) || [];
      A.forEach((W) => {
        CoreContext.Command.deleteNode({
          nodeId: W.id
        });
      }), de ? await CoreContext.Command.updateNode({
        nodeId: de.id,
        props: {
          sourceType: "ChatOverlay",
          chatOverlayId: Z,
          id: Z,
          ...re
        }
      }) : await CoreContext.Command.createNode({
        parentId: M == null ? void 0 : M.id,
        props: {
          sourceType: "ChatOverlay",
          chatOverlayId: Z,
          id: Z,
          ...re
        }
      });
    },
    async removeChatOverlay(Z) {
      var re;
      (re = M == null ? void 0 : M.children) == null || re.forEach(async (oe) => {
        oe.props.chatOverlayId === Z && await CoreContext.Command.deleteNode({
          nodeId: oe.id
        });
      });
    },
    getChatOverlay() {
      var Z, re, oe, de, A;
      return (oe = (re = (Z = M.children) == null ? void 0 : Z[0]) == null ? void 0 : re.props) != null && oe.chatOverlayId && ((A = (de = M.children) == null ? void 0 : de[0]) == null ? void 0 : A.props) || null;
    },
    getCustomOverlay() {
      var re, oe;
      const Z = (re = E == null ? void 0 : E.children) == null ? void 0 : re.find((de) => {
        var A, N;
        return ((N = (A = de == null ? void 0 : de.props) == null ? void 0 : A.sourceProps) == null ? void 0 : N.type) === "custom";
      });
      return (oe = Z == null ? void 0 : Z.props) == null ? void 0 : oe.id;
    },
    async addImageOverlay(Z, re) {
      const [oe, ...de] = (E == null ? void 0 : E.children) || [];
      de.forEach((N) => {
        CoreContext.Command.deleteNode({
          nodeId: N.id
        });
      });
      const A = {
        ...defaultStyles.image,
        ...(k == null ? void 0 : k.children.length) && {
          opacity: 0
        }
      };
      oe ? await CoreContext.Command.updateNode({
        nodeId: oe == null ? void 0 : oe.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...re,
            type: "image",
            meta: {
              style: {
                ...A
              }
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: E == null ? void 0 : E.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...re,
            type: "image",
            meta: {
              style: {
                ...A
              }
            }
          }
        }
      });
    },
    async addVideoOverlay(Z, re) {
      const [oe, ...de] = (k == null ? void 0 : k.children) || [];
      de.forEach((A) => {
        CoreContext.Command.deleteNode({
          nodeId: A.id
        });
      }), E.children.forEach(({
        id: A,
        props: N
      }) => {
        var D, W;
        if (((W = (D = N.sourceProps.meta) == null ? void 0 : D.style) == null ? void 0 : W.opacity) !== 0) {
          const ee = N.sourceProps.type, ae = {
            ...defaultStyles[ee],
            opacity: 0
          };
          CoreContext.Command.updateNode({
            nodeId: A,
            props: {
              ...N,
              sourceProps: {
                ...N.sourceProps,
                meta: {
                  style: {
                    ...ae
                  }
                }
              }
            }
          });
        }
      }), oe ? await CoreContext.Command.updateNode({
        nodeId: oe == null ? void 0 : oe.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...re,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...re.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: k == null ? void 0 : k.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...re,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...re.meta
            }
          }
        }
      });
    },
    async updateVideoOverlayProps(Z, re) {
      var de, A;
      const oe = ((de = k == null ? void 0 : k.children) == null ? void 0 : de.find((N) => {
        var D;
        return ((D = N == null ? void 0 : N.props) == null ? void 0 : D.id) === Z;
      })) || null;
      oe && await CoreContext.Command.updateNode({
        nodeId: oe == null ? void 0 : oe.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...(A = oe == null ? void 0 : oe.props) == null ? void 0 : A.sourceProps,
            ...re,
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...re.meta
            }
          }
        }
      });
    },
    async addCustomOverlay(Z, re) {
      const [oe, ...de] = (E == null ? void 0 : E.children) || [];
      de.forEach((N) => {
        CoreContext.Command.deleteNode({
          nodeId: N.id
        });
      });
      const A = {
        ...defaultStyles.custom,
        ...(k == null ? void 0 : k.children.length) && {
          opacity: 0
        }
      };
      oe ? await CoreContext.Command.updateNode({
        nodeId: oe == null ? void 0 : oe.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...re,
            type: "custom",
            meta: {
              style: {
                ...A
              }
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: E == null ? void 0 : E.id,
        props: {
          sourceType: "Overlay",
          id: Z,
          sourceProps: {
            ...re,
            type: "custom",
            meta: {
              style: {
                ...A
              }
            }
          }
        }
      });
    },
    async removeCustomOverlay() {
      var oe, de;
      const [Z, ...re] = (E == null ? void 0 : E.children) || [];
      re.forEach((A) => {
        CoreContext.Command.deleteNode({
          nodeId: A.id
        });
      }), Z && ((de = (oe = Z == null ? void 0 : Z.props) == null ? void 0 : oe.sourceProps) == null ? void 0 : de.type) === "custom" && await CoreContext.Command.deleteNode({
        nodeId: Z.id
      });
    },
    async removeImageOverlay() {
      var oe, de;
      const [Z, ...re] = (E == null ? void 0 : E.children) || [];
      re.forEach((A) => {
        CoreContext.Command.deleteNode({
          nodeId: A.id
        });
      }), Z && ((de = (oe = Z == null ? void 0 : Z.props) == null ? void 0 : oe.sourceProps) == null ? void 0 : de.type) === "image" && await CoreContext.Command.deleteNode({
        nodeId: Z.id
      });
    },
    async removeVideoOverlay() {
      const [Z, ...re] = (k == null ? void 0 : k.children) || [];
      re.forEach((oe) => {
        CoreContext.Command.deleteNode({
          nodeId: oe.id
        });
      }), Z && await CoreContext.Command.deleteNode({
        nodeId: Z.id
      }), E == null || E.children.forEach(({
        id: oe,
        props: de
      }) => {
        var A, N;
        if (((N = (A = de.sourceProps.meta) == null ? void 0 : A.style) == null ? void 0 : N.opacity) === 0) {
          const D = de.sourceProps.type, W = {
            ...defaultStyles[D],
            opacity: 1
          };
          CoreContext.Command.updateNode({
            nodeId: oe,
            props: {
              ...de,
              sourceProps: {
                ...de.sourceProps,
                meta: {
                  style: {
                    ...W
                  }
                }
              }
            }
          });
        }
      });
    },
    setLayout(Z, re = {}) {
      const oe = S.props.layoutProps.showcase;
      l.setNodeLayout({
        nodeId: S.id,
        layout: Z,
        layoutProps: {
          showcase: oe,
          ...re
        }
      });
    },
    async setBackgroundImage(Z, re) {
      const [oe, ...de] = (v == null ? void 0 : v.children) || [];
      de.forEach((A) => {
        CoreContext.Command.deleteNode({
          nodeId: A.id
        });
      }), oe ? await CoreContext.Command.updateNode({
        nodeId: oe.id,
        props: {
          id: Z,
          sourceType: "Background",
          sourceProps: {
            ...re,
            type: "image",
            meta: {
              style: {
                ...defaultStyles.image
              },
              ...re == null ? void 0 : re.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: v == null ? void 0 : v.id,
        props: {
          id: Z,
          sourceType: "Background",
          sourceProps: {
            ...re,
            type: "image",
            meta: {
              style: {
                ...defaultStyles.image
              },
              ...re == null ? void 0 : re.meta
            }
          }
        }
      });
    },
    async setBackgroundVideo(Z, re) {
      const [oe, ...de] = (v == null ? void 0 : v.children) || [];
      de.forEach((A) => {
        CoreContext.Command.deleteNode({
          nodeId: A.id
        });
      }), oe ? await CoreContext.Command.updateNode({
        nodeId: oe.id,
        props: {
          id: Z,
          sourceType: "Background",
          sourceProps: {
            ...re,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...re == null ? void 0 : re.meta
            }
          }
        }
      }) : await CoreContext.Command.createNode({
        parentId: v == null ? void 0 : v.id,
        props: {
          id: Z,
          sourceType: "Background",
          sourceProps: {
            ...re,
            type: "video",
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...re == null ? void 0 : re.meta
            }
          }
        }
      });
    },
    async updateBackgroundVideoProps(Z, re) {
      var de, A;
      const oe = ((de = v == null ? void 0 : v.children) == null ? void 0 : de.find((N) => {
        var D;
        return ((D = N == null ? void 0 : N.props) == null ? void 0 : D.id) === Z;
      })) || null;
      oe && await CoreContext.Command.updateNode({
        nodeId: oe == null ? void 0 : oe.id,
        props: {
          sourceType: "Background",
          id: Z,
          sourceProps: {
            ...(A = oe == null ? void 0 : oe.props) == null ? void 0 : A.sourceProps,
            ...re,
            meta: {
              style: {
                ...defaultStyles.video
              },
              ...re.meta
            }
          }
        }
      });
    },
    async removeBackgroundImage() {
      const [Z, ...re] = (v == null ? void 0 : v.children) || [];
      re.forEach((oe) => {
        CoreContext.Command.deleteNode({
          nodeId: oe.id
        });
      }), Z && Z.props.sourceProps.type === "image" && await CoreContext.Command.deleteNode({
        nodeId: Z.id
      });
    },
    async removeBackgroundVideo() {
      const [Z, ...re] = (v == null ? void 0 : v.children) || [];
      re.forEach((oe) => {
        CoreContext.Command.deleteNode({
          nodeId: oe.id
        });
      }), Z && Z.props.sourceProps.type === "video" && await CoreContext.Command.deleteNode({
        nodeId: Z.id
      });
    },
    /* A function that takes in a sourceType and a callback function. It then creates a shallow copy of
      the root node and finds all the nodes that have the same sourceType as the one passed in. It then
      creates a listener for when the node changes, is added, or is removed. When any of these events
      happen, it will call the callback function with the new state. */
    useLayerState(Z, re) {
      const oe = cloneDeep$1(c);
      let de = findAll(oe, (ee) => ee.props.sourceType === Z);
      const A = () => {
        re((de == null ? void 0 : de.map((ee) => ee.props)) || {});
      }, N = CoreContext.onInternal("NodeChanged", (ee) => {
        const ae = de == null ? void 0 : de.find((le) => le.id === ee.nodeId);
        if (de != null && de.length && !ae)
          return;
        const ye = de, he = cloneDeep$1(c);
        de = findAll(he, (le) => {
          var we;
          return ((we = le == null ? void 0 : le.props) == null ? void 0 : we.sourceType) === Z;
        }), deepEqual(ye, de) || A();
      }), D = CoreContext.onInternal("NodeAdded", (ee) => {
        var le;
        if (de == null ? void 0 : de.find((we) => we.id === ee.nodeId))
          return;
        const ye = cloneDeep$1(c);
        de = findAll(ye, (we) => {
          var Be;
          return ((Be = we == null ? void 0 : we.props) == null ? void 0 : Be.sourceType) === Z;
        });
        const he = de == null ? void 0 : de.find((we) => we.id === ee.nodeId);
        ((le = he == null ? void 0 : he.props) == null ? void 0 : le.sourceType) === Z && A();
      }), W = CoreContext.onInternal("NodeRemoved", (ee) => {
        var ye;
        const ae = de == null ? void 0 : de.find((he) => he.id === ee.nodeId);
        ae && (de = de == null ? void 0 : de.filter((he) => he.id !== ee.nodeId), ((ye = ae == null ? void 0 : ae.props) == null ? void 0 : ye.sourceType) === Z && A());
      });
      return A(), () => {
        N(), D(), W();
      };
    },
    setShowcase(Z, re = "camera") {
      const oe = q.getParticipantNode(Z, re);
      return CoreContext.Command.updateNode({
        nodeId: S.id,
        props: {
          layoutProps: {
            ...S.props.layoutProps,
            showcase: (oe == null ? void 0 : oe.id) ?? null
          }
        }
      });
    },
    useShowcase(Z) {
      const re = () => {
        const oe = S.props.layoutProps.showcase, de = S.children.find((N) => N.id === oe);
        if (!de)
          return Z({
            participantId: null,
            type: null
          });
        const {
          sourceProps: A
        } = de.props;
        return Z({
          participantId: A.id,
          type: A.type
        });
      };
      return re(), CoreContext.onInternal("NodeChanged", (oe) => {
        oe.nodeId === S.id && re();
      });
    },
    getRTMPNode(Z) {
      return S.children.find((re) => {
        var oe, de;
        return ((oe = re.props.sourceProps) == null ? void 0 : oe.id) === Z && ((de = re.props.sourceProps) == null ? void 0 : de.type) === "rtmp";
      });
    },
    useRTMPNodes(Z) {
      let re = [];
      const oe = () => {
        const N = S.children.filter((D) => {
          var W, ee;
          return ((ee = (W = D.props) == null ? void 0 : W.sourceProps) == null ? void 0 : ee.type) === "rtmp";
        });
        return re = N.map((D) => D.id), Z(N);
      };
      oe();
      const de = CoreContext.onInternal("NodeAdded", (N) => {
        var W, ee;
        const D = a.scene.get(N.nodeId);
        ((ee = (W = D == null ? void 0 : D.props) == null ? void 0 : W.sourceProps) == null ? void 0 : ee.type) === "rtmp" && oe();
      }), A = CoreContext.onInternal("NodeRemoved", (N) => {
        re.indexOf(N.nodeId) !== -1 && oe();
      });
      return () => {
        de(), A();
      };
    },
    async addRTMPSource(Z, re = {
      isMuted: !0,
      isHidden: !1,
      volume: 0
    }) {
      const oe = "rtmp";
      if (addingCache[oe].has(Z))
        return;
      const {
        isMuted: de = !1,
        isHidden: A = !1,
        volume: N = 1
      } = re;
      if (S.children.find((ee) => {
        var ae, ye;
        return ((ae = ee.props.sourceProps) == null ? void 0 : ae.id) === Z && ((ye = ee.props.sourceProps) == null ? void 0 : ye.type) === oe;
      }))
        return;
      addingCache[oe].add(Z), S.children[0];
      let W = S.children.length;
      await CoreContext.Command.createNode({
        props: {
          name: "RTMP",
          sourceType: "RTMP",
          sourceProps: {
            type: oe,
            id: Z
          },
          volume: N,
          isMuted: de,
          isHidden: A
        },
        parentId: S.id,
        index: W
      }).finally(() => {
        addingCache[oe].delete(Z);
      });
    },
    removeRTMPSource(Z) {
      const re = "rtmp";
      S.children.filter((oe) => {
        var de, A;
        return ((de = oe.props.sourceProps) == null ? void 0 : de.id) === Z && ((A = oe.props.sourceProps) == null ? void 0 : A.type) === re && oe.props.sourceType === "RTMP";
      }).forEach((oe) => {
        CoreContext.Command.deleteNode({
          nodeId: oe.id
        });
      });
    },
    async addParticipantTrack(Z, re = {
      isMuted: !0,
      isHidden: !1,
      volume: 0
    }, oe = "camera") {
      if (addingCache[oe].has(Z))
        return;
      const {
        isMuted: de = !1,
        isHidden: A = !1,
        volume: N = 1
      } = re;
      if (S.children.find((ae) => {
        var ye, he;
        return ((ye = ae.props.sourceProps) == null ? void 0 : ye.id) === Z && ((he = ae.props.sourceProps) == null ? void 0 : he.type) === oe;
      }))
        return;
      addingCache[oe].add(Z);
      const W = S.children[0];
      let ee = S.children.length;
      oe === "screen" && (W == null ? void 0 : W.props.sourceProps.type) !== "screen" && (ee = 0), await CoreContext.Command.createNode({
        props: {
          name: "Participant",
          sourceType: "RoomParticipant",
          sourceProps: {
            type: oe,
            id: Z
          },
          volume: N,
          isMuted: de,
          isHidden: A
        },
        parentId: S.id,
        index: ee
      }).finally(() => {
        addingCache[oe].delete(Z);
      });
    },
    removeParticipantTrack(Z, re = "camera") {
      S.children.filter((oe) => {
        var de, A;
        return ((de = oe.props.sourceProps) == null ? void 0 : de.id) === Z && ((A = oe.props.sourceProps) == null ? void 0 : A.type) === re && oe.props.sourceType === "RoomParticipant";
      }).forEach((oe) => {
        CoreContext.Command.deleteNode({
          nodeId: oe.id
        });
      });
    },
    async addParticipant(Z, re = {}, oe = "camera") {
      if (addingCache[oe].has(Z))
        return;
      const {
        isMuted: de = !1,
        isHidden: A = !1,
        volume: N = 1
      } = re;
      if (S.children.find((ae) => {
        var ye, he;
        return ((ye = ae.props.sourceProps) == null ? void 0 : ye.id) === Z && ((he = ae.props.sourceProps) == null ? void 0 : he.type) === oe;
      }))
        return;
      addingCache[oe].add(Z);
      const W = S.children[0];
      let ee = S.children.length;
      oe === "screen" && (W == null ? void 0 : W.props.sourceProps.type) !== "screen" && (ee = 0), await CoreContext.Command.createNode({
        props: {
          name: "Participant",
          sourceType: "RoomParticipant",
          sourceProps: {
            type: oe,
            id: Z
          },
          volume: N,
          isMuted: de,
          isHidden: A
        },
        parentId: S.id,
        index: ee
      }).finally(() => {
        addingCache[oe].delete(Z);
      });
    },
    removeParticipant(Z, re = "camera") {
      S.children.filter((oe) => {
        var de, A;
        return ((de = oe.props.sourceProps) == null ? void 0 : de.id) === Z && ((A = oe.props.sourceProps) == null ? void 0 : A.type) === re && oe.props.sourceType === "RoomParticipant";
      }).forEach((oe) => {
        CoreContext.Command.deleteNode({
          nodeId: oe.id
        });
      });
    },
    getParticipantNode(Z, re = "camera") {
      return S.children.find((oe) => {
        var de, A;
        return ((de = oe.props.sourceProps) == null ? void 0 : de.id) === Z && ((A = oe.props.sourceProps) == null ? void 0 : A.type) === re;
      });
    },
    getParticipantState(Z, re = "camera") {
      var oe;
      return (oe = q.getParticipantNode(Z, re)) == null ? void 0 : oe.props;
    },
    useParticipantState(Z, re, oe = "camera") {
      let de = q.getParticipantNode(Z, oe);
      const A = () => {
        re(de == null ? void 0 : de.props);
      }, N = CoreContext.onInternal("NodeChanged", (W) => {
        if (W.nodeId !== S.id)
          return;
        const ee = de;
        de = q.getParticipantNode(Z, oe), ee !== de && A();
      }), D = CoreContext.onInternal("NodeChanged", (W) => {
        !de || W.nodeId !== de.id || A();
      });
      return A(), () => {
        N(), D();
      };
    },
    setParticipantVolume(Z, re) {
      const oe = q.getParticipantNode(Z);
      oe && CoreContext.Command.updateNode({
        nodeId: oe.id,
        props: {
          volume: re
        }
      });
    },
    setParticipantMuted(Z, re) {
      const oe = q.getParticipantNode(Z);
      oe && CoreContext.Command.updateNode({
        nodeId: oe.id,
        props: {
          isMuted: re
        }
      });
    },
    setParticipantHidden(Z, re) {
      const oe = q.getParticipantNode(Z);
      oe && CoreContext.Command.updateNode({
        nodeId: oe.id,
        props: {
          isHidden: re
        }
      });
    },
    pruneParticipants() {
      const Z = getProjectRoom(u);
      Z && S.children.filter((re) => {
        var W, ee, ae;
        if (re.props.sourceType !== "RoomParticipant")
          return !1;
        const oe = (W = re.props.sourceProps) == null ? void 0 : W.type, de = Z.getParticipant((ee = re.props.sourceProps) == null ? void 0 : ee.id), A = Z.getTrack((ae = re.props.sourceProps) == null ? void 0 : ae.id);
        return !de && !A ? !0 : oe === "camera" ? !1 : !de.trackIds.map((ye) => Z.getTrack(ye)).filter(Boolean).some((ye) => (ye.type === Track.Source.Camera || ye.type === Track.Source.Microphone ? "camera" : "screen") === oe);
      }).forEach((re) => {
        CoreContext.Command.deleteNode({
          nodeId: re.id
        });
      });
    },
    getProp(Z) {
      return getProject(a.id).props[Z];
    },
    setProp(Z, re) {
      return l.updateProjectProps({
        projectId: u,
        props: {
          [Z]: re
        }
      });
    },
    useProp(Z, re) {
      return CoreContext.on("ProjectChanged", (oe) => {
        u === oe.project.id && re(oe.project.props[Z]);
      });
    },
    createSource(Z) {
      return CoreContext.Command.createSource(Z);
    },
    deleteSource(Z) {
      const re = "rtmp";
      return S.children.filter((oe) => {
        var de, A;
        return ((de = oe.props.sourceProps) == null ? void 0 : de.id) === Z.sourceId && ((A = oe.props.sourceProps) == null ? void 0 : A.type) === re && oe.props.sourceType === "RTMP";
      }).forEach((oe) => {
        CoreContext.Command.deleteNode({
          nodeId: oe.id
        });
      }), CoreContext.Command.deleteSource(Z);
    }
  };
  return (async () => {
    await $(), await J(), await V();
  })(), q;
}, create = async (a = {}, u = {}, c) => CoreContext.Command.createProject({
  settings: a,
  props: u,
  size: c
}), createCompositor = async (a, u, c) => {
  const {
    layout: l,
    layoutProps: v = {}
  } = c, S = await CoreContext.compositor.createProject({
    props: {
      name: "Root",
      type: "sceneless-project",
      sourceType: "Element",
      layout: "Layered",
      size: u,
      isRoot: !0,
      tagName: "div",
      version: "beta",
      fields: {
        style: {
          background: "black"
        }
      }
    }
  }, a), g = S.getRoot(), E = await Promise.all([S.insert({
    name: "Background",
    id: "bg",
    layout: "Layered"
  }, g.id), S.insert({
    id: "content",
    name: "Content",
    layout: l,
    layoutProps: v
  }, g.id), S.insert({
    id: "foreground",
    name: "Overlays",
    layout: "Layered"
  }, g.id)]);
  await S.reorder(g.id, E);
  const _ = g.children.find((M) => M.props.id === "foreground"), k = ForegroundLayers.map((M) => S.insert(M, _.id)), L = await Promise.all(k);
  return await S.reorder(_.id, L), S;
}, scenelessProject = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  commands,
  create,
  createCompositor
}, Symbol.toStringTag, { value: "Module" })), useActiveProjectRoom = (a) => {
  const u = getProject(CoreContext.state.activeProjectId);
  return a(u ? getRoom(u.roomId) : null), CoreContext.on("RoomJoined", () => {
    const c = getProject(CoreContext.state.activeProjectId);
    a(c ? getRoom(c.roomId) : null);
  });
}, callbacks = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useActiveProjectRoom
}, Symbol.toStringTag, { value: "Module" })), index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Callback: callbacks,
  React: react,
  Room: webrtc,
  ScenelessProject: scenelessProject
}, Symbol.toStringTag, { value: "Module" })), runFilters = (a, u = []) => u.reduce((c, l) => l(c), a), transforms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  runFilters
}, Symbol.toStringTag, { value: "Module" })), createDefault = () => ({
  root: document.createElement("div")
}), init$2 = (a = {}, u, c) => {
  const l = {}, v = a.defaultTransforms || {}, S = (G) => {
    asArray(G).forEach((H) => {
      l[H.name] = H;
    });
  }, g = {}, E = {}, _ = {}, k = (G) => _[G] || [], L = (G) => E[G] || [], M = (G) => g[G], $ = (G) => l[G];
  u.on("SourceChanged", (G) => {
    L(G.id).forEach((B) => {
      const Y = u.getNode(B.nodeId);
      B._onUpdateHandlers.forEach((ne) => ne(Y.props || {}));
    });
  }), u.on("AvailableSourcesChanged", ({
    type: G,
    sources: H
  }) => {
    k(G).forEach((Y) => {
      J(Y.nodeId);
    });
  });
  const J = (G) => {
    var A, N, D;
    const H = M(G);
    if (!H)
      return;
    const B = $(H.transformName);
    if (!B.useSource)
      return;
    const Y = u.getNode(G), ne = H.proxySource ? H.proxySource : H.sourceType, Z = c.getSources(ne), re = B.useSource(Z, Y.props), oe = H.sourceValue, de = re == null ? void 0 : re.value;
    H.source !== re && (E[(A = H.source) == null ? void 0 : A.id] && (E[(N = H.source) == null ? void 0 : N.id] = E[(D = H.source) == null ? void 0 : D.id].filter((W) => W.nodeId !== G)), E[re == null ? void 0 : re.id] = [...E[re == null ? void 0 : re.id] || [], H]), H.source = re, H.sourceValue = de, Object.is(oe, de) || H._onNewSourceHandlers.forEach((W) => W(re));
  }, V = (G) => {
    const H = q(G), Y = runFilters(G, []);
    return J(G.id), H == null || H._onUpdateHandlers.forEach((ne) => ne(G.props || {})), {
      ...Y,
      children: Y.children.map(V)
    };
  }, q = (G) => {
    if (g[G.id])
      return g[G.id];
    const {
      props: H = {}
    } = G, {
      sourceType: B,
      proxySource: Y
    } = H;
    if (!B)
      return null;
    let ne = v[B], Z;
    if (ne ? Z = l[ne] : Z = Object.values(l).find((ae) => ae.sourceType === B), !Z)
      throw new Error("Could not find matching transform for sourceType: " + B);
    const re = [], oe = [], de = [], A = [], D = {
      ...(Z.create || createDefault)({
        onEvent: (ae, ye, ...he) => {
          const le = u.on(ae, ye, ...he);
          return A.push(le), le;
        },
        onNewSource: (ae) => re.push(ae),
        onUpdate: (ae) => oe.push(ae),
        onRemove: (ae) => de.push(ae)
      }, G.props),
      proxySource: Y,
      sourceType: B,
      nodeId: G.id,
      transformName: Z.name,
      _onNewSourceHandlers: re,
      _onUpdateHandlers: oe,
      _disposables: A
    };
    g[G.id] = D;
    const W = Y || B;
    _[W] = [..._[W] || [], D], Z.useSource && J(G.id);
    const ee = [
      // Dispose when node is removed
      u.on("NodeRemoved", ({
        nodeId: ae
      }) => {
        if (ae === G.id) {
          const ye = u.getNode(ae), {
            sourceType: he = "Element"
          } = ye.props;
          ee.forEach((we) => we == null ? void 0 : we()), A.forEach((we) => we == null ? void 0 : we()), de.forEach((we) => we == null ? void 0 : we()), delete g[ye.id];
          const le = Y || he;
          _[le] = _[le].filter((we) => we !== g[ye.id]);
        }
      })
    ];
    return D;
  };
  return {
    transforms: l,
    nodeElementIndex: g,
    elementSourceTypeIndex: _,
    registerTransform: S,
    getElementsBySourceType: k,
    getElementByNodeId: M,
    getTransformByName: $,
    updateSourceForNode: J,
    renderTree: V,
    getElement: q
  };
}, TRANSITION_DURATION = 300, findLayoutUp = (a, u, c = 0) => {
  const v = a.parentElement;
  return v instanceof Layout && (c = 0, !u || u(v)) ? v : v ? c > 4 ? null : findLayoutUp(v, u, c + 1) : null;
}, TRANSITION_FIELDS = "opacity, transform, width, height, left, right, top, bottom, inset", layoutIndex = {}, parentIdIndex = {}, childIndex = {};
let rootLayout, _cid = 1;
const ignoredAttributes = ["style", "id", "className"];
let tickOps = {};
const tick = () => {
  if (nextTick = null, window.__dragging) {
    nextTick = nextTick || requestAnimationFrame(tick);
    return;
  }
  const a = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  Object.entries(tickOps).forEach(([l, v]) => {
    v.forEach(([S, g, E]) => {
      switch (S) {
        case "childInserted": {
          u.has(E) ? u.delete(E) : a.add(E);
          break;
        }
        case "childRemoved": {
          a.has(E) ? a.delete(E) : u.add(E);
          break;
        }
        case "childRemoveFinished": {
          c.add(E);
          break;
        }
      }
    });
  });
  try {
    u.forEach((v) => {
      var E, _, k;
      const S = childIndex[v], g = Array.from(((E = S.parentEl) == null ? void 0 : E.children) || []);
      S.nextSiblingEl && g.includes(S.nextSiblingEl) ? (_ = S.parentEl) == null || _.insertBefore(S, S.nextSiblingEl) : (S.nextSiblingEl = null, (k = S.parentEl) == null || k.append(S)), S.runRemove();
    }), c.forEach((v) => {
      const S = childIndex[v];
      if (S.removed) {
        S.previousSiblingEl && (S.previousSiblingEl.nextSiblingEl = S.nextSiblingEl), S.nextSiblingEl && (S.nextSiblingEl.previousSiblingEl = S.previousSiblingEl);
        return;
      }
    });
    const l = window.__scale;
    Object.entries(tickOps).forEach(([v, S]) => {
      const g = layoutIndex[v], E = g.getBoundingClientRect(), _ = {
        x: E.width / l,
        y: E.height / l
      };
      g.updatePositions({
        size: _,
        inserted: a,
        removed: u
      });
    });
  } catch (l) {
    log$1.warn("Failed to run Layout ops", l);
  }
  tickOps = {};
};
let nextTick;
const queueOp = (a) => {
  const [u, c] = a, l = tickOps[c] || [];
  tickOps[c] = [...l, a], nextTick = nextTick || requestAnimationFrame(tick);
};
class Layout extends HTMLElement {
  constructor() {
    super();
    ht(this, "parentEl");
    ht(this, "slotEl");
    ht(this, "parentLayout");
    ht(this, "nodes");
    ht(this, "mutationObserver");
    ht(this, "latestSize");
    ht(this, "isFirst", !0);
    ht(this, "isUpdating", !1);
    ht(this, "cid");
    this.cid = ++_cid;
  }
  log(...c) {
    var l;
    log$1.debug(...c, {
      id: this.dataset.id,
      parent: (l = this.parentLayout) == null ? void 0 : l.dataset.id
    }, this);
  }
  connectedCallback() {
    var c;
    this.parentEl = this.parentElement, this.parentLayout = findLayoutUp(this), this.slotEl = this.closest("[data-layout-child]"), Array.from(this.children).forEach((l) => this.initializeChild(l)), rootLayout || (rootLayout = this), layoutIndex[this.dataset.id] = this, parentIdIndex[this.dataset.id] = (c = this.parentLayout) == null ? void 0 : c.id, Object.assign(this.style, {
      width: "100%",
      height: "100%",
      position: "absolute",
      top: "0px",
      left: "0px",
      pointerEvents: "none",
      boxSizing: "border-box"
    }), this.mutationObserver && this.mutationObserver.disconnect(), this.mutationObserver = new MutationObserver((l) => {
      this.isConnected && l.forEach((v) => {
        v.type === "attributes" && !ignoredAttributes.includes(v.attributeName) ? queueOp(["attributesChanged", this.dataset.id]) : v.type === "childList" && (v.addedNodes.forEach((S) => {
          const g = childIndex[S.dataset.id];
          S.removed || (g ? g !== S && (this.initializeChild(S), S.setAttribute("style", g.getAttribute("style")), S.data = g.data) : this.initializeChild(S), queueOp(["childInserted", this.dataset.id, S.dataset.id]));
        }), v.removedNodes.forEach((S) => {
          S.removed || queueOp(["childRemoved", this.dataset.id, S.dataset.id]);
        }));
      });
    }), this.mutationObserver.observe(this, {
      childList: !0,
      attributes: !0
    }), this.latestSize || queueOp(["attributesChanged", this.dataset.id]);
  }
  disconnectedCallback() {
  }
  adoptedCallback() {
  }
  updatePositions(c) {
    if (this.isUpdating)
      return;
    this.isUpdating = !0;
    const {
      size: l,
      inserted: v = /* @__PURE__ */ new Set(),
      removed: S = /* @__PURE__ */ new Set()
    } = c;
    this.nodes = Array.from(this.children || []).filter((k) => !k.removed).map((k, L) => {
      const M = getElementAttributes(k);
      return {
        // TODO: Does this work well enough? Think through keying
        id: k.dataset.id,
        props: M,
        children: []
      };
    });
    const g = JSON.parse(this.getAttribute("props") || "{}");
    this.latestSize = l;
    const E = {
      id: this.dataset.id,
      props: g,
      children: this.nodes,
      size: l
    };
    let _ = layoutChildren(E);
    Promise.all(Object.entries(_).map(async ([k, L]) => {
      var ne, Z, re, oe;
      let M = childIndex[k] || this.querySelector(`[data-layout-child][data-id="${k}"]`);
      const $ = {
        ...M.data,
        ...L
      };
      M.data = $;
      const {
        size: J,
        position: V,
        zIndex: q = 1,
        opacity: G = 1,
        borderRadius: H = 0,
        entryTransition: B = {},
        exitTransition: Y = {}
      } = $;
      if (M) {
        if (M.removed)
          return;
        Y && (M.data.exitTransition = Y), B && (M.data.entryTransition = B), M.data.size = J, M.data.position = V;
        const de = window.__scale, A = this.getBoundingClientRect(), N = A.width / de, D = N - sizeToNum(V.x, N) - sizeToNum(J.x, N), W = A.height / de, ee = W - sizeToNum(V.y, W) - sizeToNum(J.y, W);
        Object.assign(M.style, {
          position: "absolute",
          transformOrigin: "50% 50%",
          transitionDuration: "0ms",
          transitionDelay: "0ms",
          transform: "translate3d(0, 0, 0) scaleX(1) scaleY(1)",
          visibility: "visible",
          boxSizing: "border-box",
          overflow: "hidden",
          borderRadius: H + "px",
          width: "auto",
          height: "auto"
        });
        let ae = "0ms", ye = this.isFirst ? asDuration(0) : asDuration(TRANSITION_DURATION);
        if (v.has(k))
          Object.assign(M.style, {
            transitionProperty: TRANSITION_FIELDS,
            transitionDuration: "0ms",
            transitionTimingFunction: B.timingFn ?? "ease",
            transform: `translate3d(calc(${asSize(((ne = B.offset) == null ? void 0 : ne.x) ?? 0)}), calc(${asSize(((Z = B.offset) == null ? void 0 : Z.y) ?? 0)}), 0) scaleX(${((re = B.scale) == null ? void 0 : re.x) ?? 1}) scaleY(${((oe = B.scale) == null ? void 0 : oe.y) ?? 1})`,
            opacity: B.opacity ?? G,
            left: asSize(V.x) || 0,
            right: asSize(D) || 0,
            top: asSize(V.y) || 0,
            bottom: asSize(ee) || 0
          }), ae = asDuration(B.delay ?? 0);
        else if (M.data.rootOffset) {
          const we = rootLayout.getBoundingClientRect(), Be = this.getBoundingClientRect(), Ne = {
            x: Be.x / de - we.x / de,
            y: Be.y / de - we.y / de
          }, Le = Ne.x + Be.width / de, $e = M.data.rootOffset.x + Number(M.data.size.x), Ue = Ne.y + Be.height / de, Ge = M.data.rootOffset.y + Number(M.data.size.y);
          M.data.rootOffset.x - Ne.x, M.data.rootOffset.y - Ne.y, Le - $e, Ue - Ge;
        }
        M.addEventListener("transitionstart", () => {
          M.style.zIndex = String(q + 1);
        }), await new Promise((we) => window.setTimeout(we)), Object.assign(M.style, {
          transitionProperty: TRANSITION_FIELDS,
          transitionDuration: ye,
          transitionDelay: ae,
          transform: "translate3d(0, 0, 0) scaleX(1) scaleY(1)",
          opacity: G,
          left: asSize(V.x) || 0,
          top: asSize(V.y) || 0,
          width: N ? "auto" : J.x,
          right: N ? asSize(D) || 0 : "auto",
          height: W ? "auto" : J.y,
          bottom: W ? asSize(ee) || 0 : "auto",
          zIndex: q
        });
        const le = () => {
          const we = rootLayout.getBoundingClientRect(), Be = M.getBoundingClientRect();
          M.data.rootOffset = {
            x: Be.x / de - we.x / de,
            y: Be.y / de - we.y / de
          };
        };
        le(), M.addEventListener("transitionend", () => {
          M.style.zIndex = String(q), le();
        });
      }
    })).then(() => {
      this.isUpdating = !1;
    }), this.isFirst = !1, Array.from(this.querySelectorAll("ls-layout")).forEach((k) => {
      if (!_[k.dataset.id])
        return;
      const L = _[k.dataset.id].size;
      k.updatePositions({
        size: {
          x: sizeToNum(L.x, l.x),
          y: sizeToNum(L.y, l.y)
        }
      });
    });
  }
  initializeChild(c) {
    var v;
    if (!((v = c.dataset) != null && v.id))
      return log$1.warn("Layout: Child requires `data-id` at the time it is added to a Layout");
    c._remove = c.remove, c.remove = () => {
      this.removeChild(c);
    }, c.mutationObserver || (c.mutationObserver = new MutationObserver((S) => {
      S.forEach((g) => {
        if (g.type === "attributes") {
          if (g.attributeName === "style")
            return;
          queueOp(["childAttributesChanged", this.dataset.id, c.dataset.id]);
        }
      });
    }), c.mutationObserver.observe(c, {
      childList: !0,
      attributes: !0
    }));
    const l = {
      entryTransition: {
        delay: 0,
        opacity: 0,
        scale: {
          x: 1,
          y: 1
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      exitTransition: {
        delay: 0,
        opacity: 0,
        scale: {
          x: 1,
          y: 1
        },
        offset: {
          x: 0,
          y: 0
        }
      },
      position: {
        x: 0,
        y: 0
      },
      size: {
        x: 0,
        y: 0
      },
      opacity: 0,
      fit: "cover",
      borderRadius: 0,
      zIndex: 1
    };
    c.data = l, c.parentEl = c.parentElement, c.nextSiblingEl = c.nextSibling, c.previousSiblingEl = c.previousSibling, c.previousSiblingEl && (c.previousSiblingEl.nextSiblingEl = c), c.toggleAttribute("data-layout-child", !0), childIndex[c.dataset.id] = c, c.runRemove = async () => {
      var g, E, _, k;
      c.removed = !0;
      const S = TRANSITION_DURATION;
      return await new Promise((L) => window.setTimeout(L)), Object.assign(c.style, {
        zIndex: 0,
        transitionDelay: asDuration(0),
        transitionDuration: asDuration(S),
        transitionProperty: TRANSITION_FIELDS,
        transitionTimingFunction: l.exitTransition.timingFn ?? "ease",
        transform: `translate3d(calc(${asSize(((g = l.exitTransition.offset) == null ? void 0 : g.x) ?? 0)}), calc( ${asSize(((E = l.exitTransition.offset) == null ? void 0 : E.y) ?? 0)}), 0) scaleX(${((_ = l.exitTransition.scale) == null ? void 0 : _.x) ?? 1}) scaleY(${((k = l.exitTransition.scale) == null ? void 0 : k.y) ?? 1})`,
        opacity: l.exitTransition.opacity ?? 0
      }), c.removed = !0, c.transition = new Promise((L) => {
        const M = () => {
          c.transition = null, c._remove(), queueOp(["childRemoveFinished", this.dataset.id, c.dataset.id]), clearTimeout($), L();
        }, $ = window.setTimeout(M, parseInt(String(S)) + 600);
        c.addEventListener("transitionend", M, {
          once: !0
        });
      }), c.transition;
    };
  }
}
const ensureLayoutContainer = (a) => {
  const u = document.getElementById("__ls-layout-container");
  if (u)
    return Object.assign(u.style, {
      width: a.x + "px",
      height: a.y + "px"
    }), u;
  const c = document.createElement("div");
  return c.id = "__ls-layout-container", Object.assign(c.style, {
    position: "fixed",
    // pointerEvents: 'none',
    visibility: "hidden",
    top: "0px",
    left: "0px",
    zIndex: -1,
    width: a.x + "px",
    height: a.y + "px"
  }), document.body.append(c), c;
}, layoutChildren = ({
  id: a,
  props: u = {},
  children: c,
  size: l
}) => {
  const v = {
    props: u,
    children: c,
    size: l
  }, S = htmlLayouts[u.layout] ? htmlLayouts[u.layout].layout(v) : htmlLayouts.Free.layout(v);
  if (!(S instanceof HTMLElement))
    return S;
  const g = Array.from(S.querySelectorAll("[data-node-id]")), E = document.createElement("div");
  E.style.height = S.style.height = l.y + "px", E.style.width = S.style.width = l.x + "px", E.style.position = "absolute", E.style.top = "0px", E.style.left = "0px", E.style.boxSizing = "border-box", E.setAttribute("data-wrapper-id", a), E.append(S);
  const _ = ensureLayoutContainer(l), k = _.querySelector(`[data-wrapper-id="${a}"]`);
  k ? k.replaceWith(E) : _.append(E);
  const L = S.getBoundingClientRect(), M = {};
  return g.forEach(($) => {
    var H, B, Y, ne;
    const J = $.dataset.nodeId;
    if (!J)
      return;
    const V = Number($.dataset.opacity ?? ($.style.opacity || 1)), q = $.getBoundingClientRect();
    let G = {
      position: {
        x: q.x - L.x + "px",
        y: q.y - L.y + "px"
      },
      size: {
        x: q.width + "px",
        y: q.height + "px"
      },
      opacity: V,
      zIndex: (H = $.data) == null ? void 0 : H.zIndex,
      entryTransition: ((B = $.data) == null ? void 0 : B.entryTransition) ?? {},
      exitTransition: ((Y = $.data) == null ? void 0 : Y.exitTransition) ?? {},
      borderRadius: ((ne = $.data) == null ? void 0 : ne.borderRadius) ?? 0
    };
    `${u.showcase}-x` === J && (G.position = {
      x: L.x + "px",
      y: L.y + "px"
    }, G.size = {
      x: L.width + "px",
      y: L.height + "px"
    }, G.zIndex = 10), M[J] = G, positionIndex[$.dataset.nodeId] = G;
  }), M;
}, positionIndex = {}, htmlLayouts = {}, registerLayout = (a) => {
  asArray(a).forEach((u) => {
    htmlLayouts[u.name] = u;
  });
}, sourceTypes = {}, init$1 = (a = {}, u) => {
  const c = {}, l = {}, v = (_) => {
    u.triggerEvent("SourceChanged", _);
  }, S = (_) => {
    u.triggerEvent("AvailableSourcesChanged", {
      type: _,
      sources: l[_]
    });
  }, E = {
    sourceIndex: c,
    sourceTypeIndex: l,
    registerSource: (_) => {
      asArray(_).forEach((k) => {
        var M;
        const L = ($) => {
          const J = c[$];
          if (J && J.type !== k.type)
            throw new Error(`Attempted to modify source of type ${J.type} from ${k.type}`);
        };
        (M = k.init) == null || M.call(k, {
          getSource: ($) => E.getSource($),
          removeSource: ($) => (L($), E.removeSource($)),
          setSourceActive: ($, J) => (L($), E.setSourceActive($, J)),
          updateSource: ($, J) => (L($), E.updateSource($, J)),
          modifySourceValue($, J) {
            return L($), E.modifySourceValue($, J);
          },
          addSource: ($) => E.addSource(k.type, $)
        }), sourceTypes[k.type] = k;
      });
    },
    getSource: (_) => c[_],
    getSources: (_) => l[_] || [],
    useSource: (_, k) => (k(c[_]), u.on("SourceChanged", (L) => {
      L.id === _ && k(L);
    })),
    useSources: (_, k) => (k(l[_] || []), u.on("AvailableSourcesChanged", (L) => {
      L.type === _ && k(L.sources);
    })),
    addSource: (_, k) => {
      if (!k.id)
        throw new Error('Cannot add source without field "id"');
      if (c[k.id])
        return;
      if (!k.value)
        throw new Error('Cannot add source with an empty field "value"');
      if (!sourceTypes[_])
        throw new Error("Could not find definition for source type: " + _);
      const {
        id: M,
        value: $ = null,
        props: J = {},
        isActive: V = !0
      } = k;
      c[M] = {
        id: M,
        type: _,
        props: J,
        value: $,
        isActive: V
      }, l[_] = [...l[_] || [], c[M]], v(c[M]), S(_);
    },
    removeSource: (_) => {
      const k = c[_];
      k && (delete c[_], l[k.type] = l[k.type].filter((L) => L.id !== _), S(k.type));
    },
    updateSource: (_, k) => {
      const L = c[_];
      L.props = {
        ...L.props,
        ...k
      }, v(L), S(L.type);
    },
    /**
     * Imperatively update a Source's value.
     * Triggers an event to inform elements to re-render.
     */
    modifySourceValue: async (_, k) => {
      const L = c[_];
      await k(L.value), v(L);
    },
    setSourceActive: (_, k = !0) => {
      const L = c[_];
      L.isActive = k, S(L.type);
    }
  };
  return E;
}, sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  init: init$1,
  sourceTypes
}, Symbol.toStringTag, { value: "Module" })), layouts = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), {
  forEachDown,
  insertAt,
  toDataNode,
  pull,
  replaceItem
} = Logic;
let compositor;
const start = (a) => {
  if (compositor)
    return compositor;
  const {
    dbAdapter: u,
    transformSettings: c = {},
    sourceSettings: l = {}
  } = a, v = {}, S = {};
  try {
    customElements.define("ls-layout", Layout);
  } catch (H) {
    log$1.warn(H);
  }
  const g = {}, E = {}, _ = {};
  let k = 0;
  const L = /* @__PURE__ */ new Map(), M = (H, B) => {
    if (typeof H != "function")
      return;
    const Y = ++k;
    return L.set(Y, H), H.nodeId = B, () => {
      L.delete(Y);
    };
  }, $ = (H, B, Y) => M((ne, Z) => {
    ne === H && B(Z);
  }, Y), J = (H, B) => {
    L.forEach((Y) => {
      Y.nodeId ? B != null && B.nodeId && (B == null ? void 0 : B.nodeId) === Y.nodeId && Y(H, B) : Y(H, B);
    });
  }, V = {
    projects: S,
    subscribe: M,
    on: $,
    triggerEvent: J,
    getProject: (H) => S[H],
    getNodeProject: (H) => S[g[H]],
    getNodeParent: (H) => _[E[H]],
    getNode: (H) => _[H],
    createProject: async (H = {}, B) => {
      const {
        id: Y,
        props: ne = {},
        children: Z = []
      } = H, re = await u(B, {
        get: () => null,
        getParent: () => null
      }).insert(ne), oe = {
        id: re,
        props: ne,
        children: Z
      };
      return forEachDown(H, (de) => {
      }), _[re] = oe, compositor.loadProject(oe, B);
    },
    loadProject: (H, B) => {
      if (!H)
        return;
      if (B = B || H.id, S[B])
        return S[B];
      forEachDown(H, (re, oe) => {
        _[re.id] = re, E[re.id] = oe == null ? void 0 : oe.id, g[re.id] = B;
      });
      const Y = {
        insert: async (re, oe, de = 0) => {
          if (re.id && _[re.id])
            return _[re.id];
          if (re.children || (re.children = []), re.props || (re.props = {}), oe) {
            const A = _[oe];
            if (!A)
              throw "Parent node not found with ID";
            A.children = insertAt(de, re, A.children || []), E[re.id] = oe;
          }
          return _[re.id] = re, g[re.id] = B, re.id;
        },
        update: async (re, oe = {}, de) => {
          const A = _[re];
          if (de) {
            const N = de.map((D) => {
              const W = _[D];
              return E[W.id] = re, W;
            });
            A.children = N;
          }
          A.props = {
            ...A.props,
            ...oe
          };
        },
        remove: async (re) => {
          const oe = _[E[re]];
          oe && (oe.children = oe.children.filter((A) => A.id !== re));
          const de = _[re];
          forEachDown(de, (A) => {
            _[A.id] && (_[A.id]._deleted = !0), J("NodeRemoved", {
              projectId: ne.id,
              nodeId: A.id
            });
          });
        }
      }, ne = {
        id: B,
        getRoot: () => H,
        get(re) {
          return _[re];
        },
        getParent(re) {
          return _[E[re]];
        },
        renderTree() {
          return G.renderTree(H);
        },
        local: Y,
        insert: async (re = {}, oe, de = 0) => {
          const N = {
            id: await Z.insert(re, oe, de),
            props: re,
            children: []
          };
          return Y.insert(N, oe, de);
        },
        update: async (re, oe) => (await Y.update(re, oe), Z.update(re, oe)),
        remove: async (re) => {
          await Y.remove(re);
          const oe = _[E[re]], de = oe.children.filter((A) => A.id !== re);
          return Z.batch([["delete", {
            id: re
          }], ["update", {
            ...oe,
            children: de
          }]]);
        },
        reorder: async (re, oe) => {
          const de = _[re];
          return de.children = oe.map((A) => de.children.find((N) => N.id === A)), Z.batch([["update", de]]);
        },
        move: async (re, oe, de = 0) => {
          const A = _[re], N = _[E[re]], D = _[oe];
          N.children = pull(N.children, A), D.children = insertAt(de, A, D.children), Z.batch([["update", D], ["update", N]]), E[re] = oe;
        },
        swap: async (re, oe) => {
          const de = _[re], A = _[oe], N = _[E[re]], D = _[E[oe]];
          N.children = replaceItem((W) => W.id === re, A, N.children), D.children = replaceItem((W) => W.id === oe, de, D.children), E[re] = D.id, E[oe] = N.id, Z.batch([["update", N], ["update", D]]);
        }
      };
      Object.defineProperty(ne, "nodes", {
        get() {
          return Object.values(_).filter((re) => g[re.id] === ne.id);
        }
      });
      const Z = v[B] || u(B, {
        get: (re) => toDataNode(ne.get(re)),
        getParent: (re) => toDataNode(ne.getParent(re))
      });
      return v[B] = Z, S[B] = ne, ne;
    }
  }, q = init$1(l, V), G = init$2(c, V, q);
  return compositor = {
    registerLayout,
    registerTransform: G.registerTransform,
    registerSource: q.registerSource,
    getElement: G.getElement,
    getSource: q.getSource,
    getSources: q.getSources,
    useSource: q.useSource,
    useSources: q.useSources,
    ...V
  }, compositor;
}, index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Layout: layouts,
  Source: sources,
  Transform: transforms,
  start
}, Symbol.toStringTag, { value: "Module" })), createProject = async (a) => {
  const u = getUser().id, c = a.type || "sceneless", l = a.size || {
    x: 1280,
    y: 720
  }, v = a.settings || {};
  let S = await CoreContext.clients.LiveApi().project.createProject({
    collectionId: u,
    rendering: {
      video: {
        width: l.x,
        height: l.y,
        framerate: 30
      }
    },
    composition: {
      studioSdk: {
        version: CoreContext.rendererVersion
      }
    },
    metadata: {},
    webrtc: {
      hosted: {}
    }
  });
  const g = await createLayout({
    projectId: S.project.projectId,
    collectionId: S.project.collectionId,
    settings: v,
    size: l,
    type: c
  }), {
    displayName: E
  } = getAccessTokenData(), _ = {
    type: c,
    layoutId: g.id,
    hostDisplayName: E,
    props: a.props || {}
  };
  let k = await CoreContext.clients.LiveApi().project.updateProject({
    collectionId: u,
    projectId: S.project.projectId,
    updateMask: ["metadata"],
    metadata: _
  });
  return S.project = k.project, S.project.metadata = _, S;
}, deleteProject = async (a) => {
  const {
    projectId: u
  } = a, c = getProject(u), l = getUser().id;
  await Promise.all([CoreContext.clients.LiveApi().project.deleteProject({
    collectionId: l,
    projectId: u
  }), CoreContext.clients.LayoutApi().layout.deleteLayout({
    layoutId: c.layoutApi.layoutId
  })]);
}, loadUser = async (a) => {
  var g;
  const u = await loadCollections();
  let c;
  const {
    displayName: l,
    serviceUserId: v
  } = getAccessTokenData();
  u.length === 0 ? c = (await CoreContext.clients.LiveApi().collection.createCollection({
    metadata: {
      serviceUserId: v,
      displayName: l,
      props: {}
    }
  })).collection : c = u[0], await CoreContext.clients.LiveApi().subscribeToCollection(c.collectionId);
  const S = await Promise.all(c.projects.filter((E) => {
    var _;
    return !!((_ = E.metadata) != null && _.layoutId);
  }).map((E) => hydrateProject(E, "ROLE_HOST", a)));
  return {
    user: {
      id: c.collectionId,
      metadata: c.metadata,
      props: ((g = c.metadata) == null ? void 0 : g.props) || {},
      name: l
    },
    projects: S,
    sources: c.sources
  };
}, loadCollections = async () => (await CoreContext.clients.LiveApi().collection.getCollections({})).collections, createLayout = async (a) => {
  const {
    settings: u,
    size: c,
    type: l,
    projectId: v,
    collectionId: S
  } = a, g = await CoreContext.clients.LayoutApi().layout.createLayout({
    layout: {
      projectId: v,
      collectionId: S
    }
  });
  return l === "sceneless" ? await createCompositor(g.id, c, u) : await CoreContext.compositor.createProject({
    props: {
      name: "Root",
      layout: "Free",
      ...u,
      isRoot: !0,
      size: c
    }
  }, g.id), g;
}, requests = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createLayout,
  createProject,
  deleteProject,
  loadCollections,
  loadUser
}, Symbol.toStringTag, { value: "Module" }));
class EngineWebsocket {
  constructor(u, c) {
    ht(this, "ws", null);
    ht(this, "sources", /* @__PURE__ */ new Set());
    this.connectSource = u, this.disconnectSource = c, this.connect = this.connect.bind(this), this.handleMessage = this.handleMessage.bind(this);
  }
  connect() {
    const u = this.handleMessage.bind(this);
    this.ws = new WebSocket("ws://127.0.0.1:8000"), this.ws.addEventListener("message", u), this.ws.addEventListener("error", (c) => {
      console.error("Unable to connect to websocket", c);
    }), this.ws.addEventListener("close", () => {
      var c, l;
      (c = this.ws) == null || c.removeEventListener("message", u);
      try {
        (l = this.ws) == null || l.close(), this.ws = null;
      } catch {
      }
      setTimeout(() => {
        this.connect();
      }, 1e3);
    });
  }
  handleMessage(u) {
    try {
      const c = JSON.parse(u.data);
      if (c.name === "state") {
        this.sources.clear(), console.info("[Engine]: state", c.payload);
        for (const l of c.payload.sources)
          l.connected && (this.sources.has(l.id) || (this.sources.add(l.id), this.connectSource(l.id)));
      } else
        c.name === "source.disconnect" ? (console.info("[Engine]: source disconnect", c.payload.id), this.sources.delete(c.payload.id), this.disconnectSource(c.payload.id)) : c.name === "source.connect" && (console.info("[Engine]: source connect", c.payload.id), this.sources.add(c.payload.id), this.connectSource(c.payload.id));
    } catch (c) {
      console.error("unable to handle message: ", c);
    }
  }
}
function setupEngineWebsocket(a, u) {
  return new EngineWebsocket(a, u);
}
const lookupDevice = (a, u) => {
  const c = a.find((v) => v.label === u && v.kind === "videoinput"), l = a.find((v) => v.label === `Monitor of ${u}` && v.kind === "audioinput");
  if (c && l)
    return {
      videoDevice: c,
      audioDevice: l
    };
  if (c) {
    if (c.label === "Logitech BRIO (046d:085e)") {
      const v = a.find((S) => (
        /*(device.groupId === videoDevice.groupId) &&*/
        S.kind === "audioinput" && S.label === "Loopback Audio 2 (Virtual)"
      ));
      return {
        videoDevice: c,
        audioDevice: v
      };
    }
    if (c.label === "OBS Virtual Camera (m-de:vice)") {
      const v = a.find((S) => (
        /*(device.groupId === videoDevice.groupId) &&*/
        S.kind === "audioinput" && S.label === "Loopback Audio (Virtual)"
      ));
      return {
        videoDevice: c,
        audioDevice: v
      };
    }
    return {
      videoDevice: c,
      audioDevice: null
    };
  }
  return null;
}, connectDevice = async (a) => {
  new MediaStream([]);
  const u = await navigator.mediaDevices.enumerateDevices(), c = lookupDevice(u, a);
  if (c) {
    const l = {
      video: {
        width: 999999,
        height: 999999,
        deviceId: {
          exact: c.videoDevice.deviceId
        }
      }
    };
    c.audioDevice && (l.audio = {
      autoGainControl: !1,
      channelCount: 2,
      echoCancellation: !1,
      // @ts-ignore: https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/latency
      latency: 0,
      noiseSuppression: !1,
      sampleRate: 128e3,
      sampleSize: 16,
      deviceId: {
        exact: c.audioDevice.deviceId
      }
    });
    const v = await navigator.mediaDevices.getUserMedia(l);
    if (v)
      return v;
    console.warn(`No stream found for source ${a}.`);
  } else
    console.warn(`No device found for source ${a}.`);
}, RTMP = {
  type: "RTMP",
  valueType: MediaStream,
  props: {
    id: {},
    type: {},
    videoEnabled: {},
    audioEnabled: {}
  },
  init({
    addSource: a,
    removeSource: u,
    updateSource: c,
    getSource: l
  }) {
    let v, S = {}, g = [], E = [];
    const _ = (k) => {
      const L = k.filter(($) => !E.some((J) => J.id === $.id)), M = E.filter(($) => !k.some((J) => J.id === $.id));
      E = k, L.forEach(async ($) => {
        const J = new MediaStream([]);
        S[$.id] = J;
        const V = J.getVideoTracks();
        a({
          id: `rtmp-${$.id}`,
          isActive: !0,
          value: J,
          props: {
            id: $.id,
            isMuted: !1,
            participantId: $.id,
            type: "rtmp",
            videoEnabled: !!V.length,
            audioEnabled: !0
          }
        });
      }), M.forEach(($) => {
        u(`rtmp-${$.id}`);
      });
    };
    CoreContext.on("ActiveProjectChanged", ({
      projectId: k
    }) => {
      const L = toBaseProject(getProject(k));
      _(L.sources), L.role === Role.ROLE_RENDERER && (v || (v = setupEngineWebsocket(async function($) {
        const J = S[$];
        toBaseProject(getProject(k));
        const V = await connectDevice($);
        if (l(`rtmp-${$}`) && V) {
          const G = V.getAudioTracks()[0], H = V.getVideoTracks()[0];
          updateMediaStreamTracks(J, {
            video: H,
            audio: G
          }), c(`rtmp-${$}`, {
            videoEnabled: !!H,
            audioEnabled: !!G,
            mirrored: !1,
            external: !0
          });
        }
      }, async function($) {
        toBaseProject(getProject(k)).sources.find((G) => G.id === $);
        const V = S[$];
        (V == null ? void 0 : V.getTracks()).forEach((G) => {
          S[$].removeTrack(G);
        });
      }), v.connect()));
    }), CoreContext.on("RoomJoined", ({
      projectId: k,
      room: L
    }) => {
      if (toBaseProject(getProject(k)).role !== Role.ROLE_RENDERER) {
        const $ = () => {
          g.filter((J) => (J == null ? void 0 : J.type) === "screen_share" && (J == null ? void 0 : J.isExternal) === !0).forEach((J) => {
            var V;
            if (J.type === "screen_share") {
              const q = S[J.participantId], G = L.getParticipant(J.participantId);
              if (E.some((H) => H.id === G.id)) {
                const H = L.getTrack(J.id);
                if (l(`rtmp-${G == null ? void 0 : G.id}`)) {
                  const Y = L.getTracks().find((ne) => ne.participantId === G.id && ne.mediaStreamTrack.kind === "audio");
                  updateMediaStreamTracks(q, {
                    video: H == null ? void 0 : H.mediaStreamTrack,
                    audio: Y == null ? void 0 : Y.mediaStreamTrack
                  }), c(`rtmp-${G == null ? void 0 : G.id}`, {
                    videoEnabled: !!(H != null && H.mediaStreamTrack && !H.isMuted),
                    audioEnabled: !!(Y && !Y.isMuted),
                    mirrored: (V = G == null ? void 0 : G.meta[J.id]) == null ? void 0 : V.isMirrored,
                    external: J == null ? void 0 : J.isExternal
                  });
                }
              }
            }
          });
        };
        L.useTracks((J) => {
          const V = J.filter((H) => E.some((B) => B.id === H.participantId)).filter((H) => ["screen_share"].includes(H.type)), q = V.filter((H) => !g.some((B) => B.id === H.id) && !!(H != null && H.mediaStreamTrack)), G = g.filter((H) => !V.some((B) => B.id === H.id));
          g = V.filter((H) => !!(H != null && H.mediaStreamTrack)), G.forEach((H) => {
            const B = S[H.participantId];
            H.mediaStreamTrack.kind === "video" && (updateMediaStreamTracks(B, {
              video: null
            }), c(`rtmp-${H.participantId}`, {
              videoEnabled: !1
            })), H.mediaStreamTrack.kind === "audio" && (updateMediaStreamTracks(B, {
              audio: null
            }), c(`rtmp-${H.participantId}`, {
              audioEnabled: !1
            }));
          }), q.forEach((H) => {
            if (H.type === "screen_share" && H.mediaStreamTrack.kind === "video") {
              const B = S[H.participantId], Y = g.find((ne) => {
                var Z;
                return ne.participantId === H.participantId && ((Z = ne.mediaStreamTrack) == null ? void 0 : Z.kind) === "audio";
              });
              updateMediaStreamTracks(B, {
                video: H == null ? void 0 : H.mediaStreamTrack,
                audio: Y == null ? void 0 : Y.mediaStreamTrack
              }), c(`rtmp-${H.participantId}`, {
                videoEnabled: !!(H && !(H != null && H.isMuted)),
                audioEnabled: !!(Y && !(Y != null && Y.isMuted))
              });
            }
          }), $();
        });
      }
    }), CoreContext.on("ProjectSourceAdded", ({
      source: k,
      projectId: L
    }) => {
      const M = toBaseProject(getProject(L));
      _(M == null ? void 0 : M.sources);
    }), CoreContext.on("ProjectSourceRemoved", ({
      sourceId: k,
      projectId: L
    }) => {
      const M = toBaseProject(getProject(L));
      _(M == null ? void 0 : M.sources);
    });
  }
}, Sources = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Background,
  Banner,
  Logo,
  Overlays,
  RTMP,
  RoomParticipant
}, Symbol.toStringTag, { value: "Module" })), BroadcastPhase = lib$2.LiveApiModel.ProjectBroadcastPhase, {
  trigger,
  triggerInternal
} = CoreContext, EventType = lib$2.LiveApiModel.EventType, EventSubType = lib$2.LiveApiModel.EventSubType, init = async (a = {}) => {
  const u = a.env || "prod", c = a.logLevel || "Warn";
  log$1.getLogger("livekit").setLevel(c), log$1.setLevel(c), log$1.info("Initializing Studio SDK...");
  const {
    layouts: v = [],
    transforms: S = [],
    sources: g = [],
    defaultTransforms: E = {},
    useLatestRenderer: _ = !1,
    guestToken: k,
    rendererVersion: L
  } = a, M = new lib$2.ApiStream({
    sdkVersion: CoreContext.version,
    env: u,
    logLevel: c
  }), $ = config$1(), J = start({
    dbAdapter: compositorAdapter,
    transformSettings: {
      defaultTransforms: {
        ...E,
        ...$.defaults.transforms
      }
    }
  });
  CoreContext.config = $, CoreContext.clients = M, CoreContext.compositor = J, CoreContext.logLevel = c, CoreContext.Request = await Promise.resolve().then(() => requests), CoreContext.Command = await Promise.resolve().then(() => commands$1), CoreContext.rendererVersion = _ ? "latest-v2" : L || CoreContext.version, window.__StudioKit = {
    ...CoreContext
  }, J && (J.registerSource([...Object.values(Sources), ...g]), J.registerTransform([...Object.values(Transforms), ...S]), J.registerLayout([...Object.values(Layouts), ...v]));
  const V = await M.load(k);
  let q;
  V && await M.LiveApi().project.getProject({
    ...V
  }).then((H) => hydrateProject(H.project, V.role)).then(async (H) => {
    setAppState({
      // As a contributor, `user` refers to the collection
      //  that the project belongs to. This will be referenced
      //  when making requests requiring `collectionId`.
      user: {
        id: V.collectionId,
        props: {},
        name: null,
        metadata: {}
      },
      // TODO: Populate
      sources: [],
      projects: [H],
      activeProjectId: null
    }), H.isInitial = !0, q = await CoreContext.Command.setActiveProject({
      projectId: H.id
    });
  }), M.LiveApi().on(EventType.EVENT_TYPE_COLLECTION, (H, B) => {
    switch (log$1.info("Received: Collection event", B, H), B) {
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("UserChanged", H.update.collection);
        return;
      }
    }
  }), M.LiveApi().on(EventType.EVENT_TYPE_DESTINATION, (H, B) => {
    switch (log$1.info("Received: Destination event", B, H), B) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const {
          destination: Y
        } = H.create;
        triggerInternal("DestinationAdded", Y);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const {
          destination: Y
        } = H.update;
        triggerInternal("DestinationChanged", Y);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("DestinationRemoved", H.delete);
        return;
      }
    }
  }), M.LiveApi().on(EventType.EVENT_TYPE_SOURCE, (H, B) => {
    switch (log$1.info("Received: Source event", B, H), B) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        triggerInternal("SourceAdded", H.create.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        triggerInternal("SourceChanged", H.update.source);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("SourceRemoved", H.delete.sourceId);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_ADD: {
        triggerInternal("ProjectSourceAdded", {
          projectId: H.add.projectId,
          source: H.add.source
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_REMOVE: {
        triggerInternal("ProjectSourceRemoved", {
          projectId: H.add.projectId,
          sourceId: H.add.sourceId
        });
        return;
      }
    }
  }), M.LiveApi().on(EventType.EVENT_TYPE_PROJECT, (H, B) => {
    var Y;
    switch (log$1.info("Received: Project event", B, H), B) {
      case EventSubType.EVENT_SUB_TYPE_CREATE: {
        const ne = H.create.project;
        if (getProject(ne.projectId))
          return;
        triggerInternal("ProjectAdded", ne);
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_UPDATE: {
        const {
          project: ne
        } = H.update, Z = getProject(ne.projectId);
        if (!Z)
          return;
        triggerInternal("ProjectChanged", {
          project: ne,
          phase: Z.videoApi.phase
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_DELETE: {
        triggerInternal("ProjectRemoved", {
          projectId: H.delete.projectId
        });
        return;
      }
      case EventSubType.EVENT_SUB_TYPE_STATE: {
        const ne = getProject((Y = H.state) == null ? void 0 : Y.projectId);
        if (!ne)
          return;
        let Z = H.state.broadcastId;
        if (H.state.error && trigger("BroadcastError", {
          projectId: ne.id,
          broadcastId: H.state.broadcastId,
          error: H.state.error
        }), H.state.phase) {
          const re = H.state.phase;
          re === BroadcastPhase.PROJECT_BROADCAST_PHASE_RUNNING ? trigger("BroadcastStarted", {
            projectId: ne.id,
            broadcastId: H.state.broadcastId
          }) : re === BroadcastPhase.PROJECT_BROADCAST_PHASE_STOPPED && (Z = null, trigger("BroadcastStopped", {
            projectId: ne.id,
            broadcastId: H.state.broadcastId
          }));
        }
        triggerInternal("ProjectChanged", {
          project: ne.videoApi.project,
          phase: H.state.phase,
          broadcastId: Z
        });
        return;
      }
    }
  }), M.LayoutApi().on(lib$2.LayoutApiModel.EventType.EVENT_TYPE_LAYER, (H, B) => {
    var Y;
    if (B === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_CREATE) {
      log$1.debug("Received: Node Insert", H.create);
      const {
        connectionId: ne,
        layoutId: Z
      } = H.create.requestMetadata;
      if (CoreContext.connectionId === ne)
        return;
      const re = layerToNode(H.create), oe = getProjectByLayoutId(Z), de = [re, ...oe.compositor.nodes.map(toDataNode$1)], A = toSceneTree(de, re.id);
      oe.compositor.local.insert(A), triggerInternal("NodeAdded", {
        projectId: oe.id,
        nodeId: re.id
      });
    } else if (B === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_UPDATE) {
      log$1.debug("Received: Node Update", H.update);
      const {
        connectionId: ne,
        layoutId: Z,
        updateVersions: re = {}
      } = ((Y = H.update) == null ? void 0 : Y.requestMetadata) || {};
      if (CoreContext.connectionId === ne)
        return;
      const oe = layerToNode(H.update);
      if ((latestUpdateVersion[oe.id] || 0) > re[oe.id])
        return log$1.info("Ignoring node update - updateID is less than latest.");
      latestUpdateVersion[oe.id] = re[oe.id];
      const A = getProjectByLayoutId(Z);
      A.compositor.local.update(H.update.id, oe.props, oe.childIds), triggerInternal("NodeChanged", {
        projectId: A.id,
        nodeId: oe.id
      });
    } else if (B === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_DELETE) {
      log$1.debug("Received: Node Delete", H.delete);
      const {
        connectionId: ne,
        layoutId: Z
      } = H.delete.requestMetadata;
      if (CoreContext.connectionId === ne)
        return;
      const re = getProjectByLayoutId(Z);
      re.compositor.local.remove(H.delete.id), triggerInternal("NodeRemoved", {
        projectId: re.id,
        nodeId: H.delete.id
      });
    } else if (B === lib$2.LayoutApiModel.EventSubType.EVENT_SUB_TYPE_BATCH) {
      log$1.debug("Received: Node Batch Update", H.batch);
      const {
        connectionId: ne,
        layoutId: Z,
        updateVersions: re = {}
      } = H.batch.requestMetadata;
      if (CoreContext.connectionId === ne)
        return;
      const oe = getProjectByLayoutId(Z);
      H.batch.layers.forEach((de) => {
        try {
          const [A, N] = Object.entries(de)[0];
          if (A === "create") {
            const D = layerToNode(N);
            oe.compositor.local.insert(D), triggerInternal("NodeAdded", {
              projectId: oe.id,
              nodeId: D.id
            });
          } else if (A === "update") {
            const D = layerToNode(N);
            if ((latestUpdateVersion[D.id] || 0) > re[D.id])
              return log$1.info("Ignoring node update - updateID is less than latest.");
            latestUpdateVersion[D.id] = re[D.id], oe.compositor.local.update(D.id, D.props, D.childIds), triggerInternal("NodeChanged", {
              projectId: oe.id,
              nodeId: D.id
            });
          } else
            A === "delete" && (oe.compositor.local.remove(N.id), triggerInternal("NodeRemoved", {
              projectId: oe.id,
              nodeId: N.id
            }));
        } catch (A) {
          log$1.warn("Error handling batch item", A, {
            item: de
          });
        }
      }), oe && triggerInternal("NodeChanged", {
        projectId: oe.id,
        nodeId: oe.compositor.getRoot().id
      });
    }
  });
  const G = (H = {}, B) => {
    const {
      displayName: Y,
      role: ne,
      maxDuration: Z = CoreContext.config.defaults.guestTokenDuration,
      projectId: re = CoreContext.state.activeProjectId
    } = H, oe = getProject(re), de = Y ? {
      direct: {
        displayName: Y
      }
    } : {
      exchange: {
        maxDuration: Z
      }
    };
    return M.LiveApi().authentication.createGuestAccessToken({
      projectId: re,
      token: de,
      url: B,
      collectionId: oe.videoApi.project.collectionId,
      maxDuration: Z,
      role: ne || lib$2.LiveApiModel.Role.ROLE_GUEST
    });
  };
  return {
    ...omit(CoreContext, ["clients", "config", "connectionId", "Request", "state", "trigger"]),
    createDemoToken: async () => (console.warn("createDemoToken() is currently unavailable."), ""),
    createPreviewLink: async (H = {}) => {
      const {
        maxDuration: B,
        projectId: Y = CoreContext.state.activeProjectId
      } = H, ne = getProject(Y), Z = ne.videoApi.project.composition.studioSdk.rendererUrl;
      return (await M.LiveApi().authentication.createGuestAccessToken({
        projectId: Y,
        token: {
          direct: {
            displayName: "Preview"
          }
        },
        url: Z,
        collectionId: ne.videoApi.project.collectionId,
        maxDuration: B || CoreContext.config.defaults.previewTokenDuration,
        role: lib$2.LiveApiModel.Role.ROLE_VIEWER
      })).url;
    },
    createGuestLink: async (H, B = {}) => (await G(B, H)).url,
    createGuestToken: async (H = {}) => (await G(H)).accessToken,
    initialProject: q,
    load,
    render: render$1
  };
}, load = async (a, u) => {
  let c = getBaseUser();
  if (c)
    return log$1.info("Attempted to load user again - returning existing user"), c;
  if (!a) {
    log$1.warn("Access token required for load()");
    return;
  }
  log$1.info("Loading user..."), await CoreContext.clients.load(a);
  const v = await CoreContext.Request.loadUser(u);
  return setAppState({
    user: v.user,
    sources: v.sources,
    projects: v.projects,
    activeProjectId: null
  }), c = getBaseUser(), trigger("UserLoaded", c), c;
};
export {
  commands$1 as Command,
  index as Compositor,
  context as Context,
  events$1 as Events,
  index$1 as Helpers,
  requests as Request,
  index$2 as Room,
  types$1 as SDK,
  init
};
//# sourceMappingURL=index.js.map
